(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adopt = adopt;
exports.assignNewId = assignNewId;
exports.create = create;
exports.dispatch = dispatch;
exports.eid = eid;
exports.extend = extend;
exports.find = baseFind;
exports.getClass = getClass;
exports.invent = invent;
exports.makeInstance = makeInstance;
exports.makeMorphable = makeMorphable;
exports.mockAdopt = mockAdopt;
exports.nodeOrNew = nodeOrNew;
exports.off = off;
exports.on = on;
exports.parser = parser;
exports.register = register;
exports.registerMorphableType = registerMorphableType;
exports.registerWindow = registerWindow;
exports.wrapWithAttrCheck = wrapWithAttrCheck;
exports.utils = exports.root = exports.regex = exports.namespaces = exports.easing = exports.defaults = exports.Use = exports.Tspan = exports.TransformBag = exports.Timeline = exports.TextPath = exports.Text = exports.Symbol = exports.Svg = exports.Style = exports.Stop = exports.Spring = exports.Shape = exports.SVG = exports.Runner = exports.Rect = exports.Queue = exports.Polyline = exports.Polygon = exports.PointArray = exports.Point = exports.Pattern = exports.PathArray = exports.Path = exports.PID = exports.ObjectBag = exports.Number = exports.NonMorphable = exports.Morphable = exports.Matrix = exports.Mask = exports.Marker = exports.List = exports.Line = exports.Image = exports.Gradient = exports.G = exports.ForeignObject = exports.EventTarget = exports.Ellipse = exports.Element = exports.Ease = exports.Dom = exports.Defs = exports.Controller = exports.Container = exports.Color = exports.ClipPath = exports.Circle = exports.Box = exports.Array = exports.Animator = exports.A = void 0;

function _typeof3(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof3 = function _typeof3(obj) { return typeof obj; }; } else { _typeof3 = function _typeof3(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof3(obj); }

/*!
* @svgdotjs/svg.js - A lightweight library for manipulating and animating SVG.
* @version 3.0.16
* https://svgdotjs.github.io/
*
* @copyright Wout Fierens <wout@mick-wout.com>
* @license MIT
*
* BUILT: Tue Nov 12 2019 21:57:16 GMT+0100 (GMT+01:00)
*/
;
var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
  return module = {
    exports: {}
  }, fn(module, module.exports), module.exports;
}

var check = function check(it) {
  return it && it.Math == Math && it;
}; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028


var global_1 = // eslint-disable-next-line no-undef
check((typeof globalThis === "undefined" ? "undefined" : _typeof3(globalThis)) == 'object' && globalThis) || check((typeof window === "undefined" ? "undefined" : _typeof3(window)) == 'object' && window) || check((typeof self === "undefined" ? "undefined" : _typeof3(self)) == 'object' && self) || check(_typeof3(commonjsGlobal) == 'object' && commonjsGlobal) || // eslint-disable-next-line no-new-func
Function('return this')();

var fails = function fails(exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
}; // Thank's IE8 for his funny defineProperty


var descriptors = !fails(function () {
  return Object.defineProperty({}, 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});
var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug

var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({
  1: 2
}, 1); // `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable

var f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;
var objectPropertyIsEnumerable = {
  f: f
};

var createPropertyDescriptor = function createPropertyDescriptor(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var toString = {}.toString;

var classofRaw = function classofRaw(it) {
  return toString.call(it).slice(8, -1);
};

var split = ''.split; // fallback for non-array-like ES3 and non-enumerable old V8 strings

var indexedObject = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
} : Object; // `RequireObjectCoercible` abstract operation
// https://tc39.github.io/ecma262/#sec-requireobjectcoercible

var requireObjectCoercible = function requireObjectCoercible(it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
}; // toObject with fallback for non-array-like ES3 strings


var toIndexedObject = function toIndexedObject(it) {
  return indexedObject(requireObjectCoercible(it));
};

var isObject = function isObject(it) {
  return _typeof3(it) === 'object' ? it !== null : typeof it === 'function';
}; // `ToPrimitive` abstract operation
// https://tc39.github.io/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string


var toPrimitive = function toPrimitive(input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};

var hasOwnProperty = {}.hasOwnProperty;

var has = function has(it, key) {
  return hasOwnProperty.call(it, key);
};

var document$1 = global_1.document; // typeof document.createElement is 'object' in old IE

var EXISTS = isObject(document$1) && isObject(document$1.createElement);

var documentCreateElement = function documentCreateElement(it) {
  return EXISTS ? document$1.createElement(it) : {};
}; // Thank's IE8 for his funny defineProperty


var ie8DomDefine = !descriptors && !fails(function () {
  return Object.defineProperty(documentCreateElement('div'), 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});
var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor

var f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (ie8DomDefine) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) {
    /* empty */
  }
  if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
};
var objectGetOwnPropertyDescriptor = {
  f: f$1
};

var anObject = function anObject(it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  }

  return it;
};

var nativeDefineProperty = Object.defineProperty; // `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty

var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (ie8DomDefine) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};
var objectDefineProperty = {
  f: f$2
};
var createNonEnumerableProperty = descriptors ? function (object, key, value) {
  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var setGlobal = function setGlobal(key, value) {
  try {
    createNonEnumerableProperty(global_1, key, value);
  } catch (error) {
    global_1[key] = value;
  }

  return value;
};

var SHARED = '__core-js_shared__';
var store = global_1[SHARED] || setGlobal(SHARED, {});
var sharedStore = store;
var shared = createCommonjsModule(function (module) {
  (module.exports = function (key, value) {
    return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
  })('versions', []).push({
    version: '3.3.6',
    mode: 'global',
    copyright: 'Â© 2019 Denis Pushkarev (zloirock.ru)'
  });
});
var functionToString = shared('native-function-to-string', Function.toString);
var WeakMap = global_1.WeakMap;
var nativeWeakMap = typeof WeakMap === 'function' && /native code/.test(functionToString.call(WeakMap));
var id = 0;
var postfix = Math.random();

var uid = function uid(key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};

var keys = shared('keys');

var sharedKey = function sharedKey(key) {
  return keys[key] || (keys[key] = uid(key));
};

var hiddenKeys = {};
var WeakMap$1 = global_1.WeakMap;
var set, get, has$1;

var enforce = function enforce(it) {
  return has$1(it) ? get(it) : set(it, {});
};

var getterFor = function getterFor(TYPE) {
  return function (it) {
    var state;

    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    }

    return state;
  };
};

if (nativeWeakMap) {
  var store$1 = new WeakMap$1();
  var wmget = store$1.get;
  var wmhas = store$1.has;
  var wmset = store$1.set;

  set = function set(it, metadata) {
    wmset.call(store$1, it, metadata);
    return metadata;
  };

  get = function get(it) {
    return wmget.call(store$1, it) || {};
  };

  has$1 = function has$1(it) {
    return wmhas.call(store$1, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;

  set = function set(it, metadata) {
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };

  get = function get(it) {
    return has(it, STATE) ? it[STATE] : {};
  };

  has$1 = function has$1(it) {
    return has(it, STATE);
  };
}

var internalState = {
  set: set,
  get: get,
  has: has$1,
  enforce: enforce,
  getterFor: getterFor
};
var redefine = createCommonjsModule(function (module) {
  var getInternalState = internalState.get;
  var enforceInternalState = internalState.enforce;
  var TEMPLATE = String(functionToString).split('toString');
  shared('inspectSource', function (it) {
    return functionToString.call(it);
  });
  (module.exports = function (O, key, value, options) {
    var unsafe = options ? !!options.unsafe : false;
    var simple = options ? !!options.enumerable : false;
    var noTargetGet = options ? !!options.noTargetGet : false;

    if (typeof value == 'function') {
      if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
      enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
    }

    if (O === global_1) {
      if (simple) O[key] = value;else setGlobal(key, value);
      return;
    } else if (!unsafe) {
      delete O[key];
    } else if (!noTargetGet && O[key]) {
      simple = true;
    }

    if (simple) O[key] = value;else createNonEnumerableProperty(O, key, value); // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
  })(Function.prototype, 'toString', function toString() {
    return typeof this == 'function' && getInternalState(this).source || functionToString.call(this);
  });
});
var path = global_1;

var aFunction = function aFunction(variable) {
  return typeof variable == 'function' ? variable : undefined;
};

var getBuiltIn = function getBuiltIn(namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace]) : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
};

var ceil = Math.ceil;
var floor = Math.floor; // `ToInteger` abstract operation
// https://tc39.github.io/ecma262/#sec-tointeger

var toInteger = function toInteger(argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};

var min = Math.min; // `ToLength` abstract operation
// https://tc39.github.io/ecma262/#sec-tolength

var toLength = function toLength(argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

var max = Math.max;
var min$1 = Math.min; // Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(length, length).

var toAbsoluteIndex = function toAbsoluteIndex(index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
}; // `Array.prototype.{ indexOf, includes }` methods implementation


var createMethod = function createMethod(IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value; // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare

    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++]; // eslint-disable-next-line no-self-compare

      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    }
    return !IS_INCLUDES && -1;
  };
};

var arrayIncludes = {
  // `Array.prototype.includes` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};
var indexOf = arrayIncludes.indexOf;

var objectKeysInternal = function objectKeysInternal(object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;

  for (key in O) {
    !has(hiddenKeys, key) && has(O, key) && result.push(key);
  } // Don't enum bug & hidden keys


  while (names.length > i) {
    if (has(O, key = names[i++])) {
      ~indexOf(result, key) || result.push(key);
    }
  }

  return result;
}; // IE8- don't enum bug keys


var enumBugKeys = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];
var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames

var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return objectKeysInternal(O, hiddenKeys$1);
};

var objectGetOwnPropertyNames = {
  f: f$3
};
var f$4 = Object.getOwnPropertySymbols;
var objectGetOwnPropertySymbols = {
  f: f$4
}; // all object keys, includes non-enumerable and symbols

var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = objectGetOwnPropertyNames.f(anObject(it));
  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};

var copyConstructorProperties = function copyConstructorProperties(target, source) {
  var keys = ownKeys(source);
  var defineProperty = objectDefineProperty.f;
  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};

var replacement = /#|\.prototype\./;

var isForced = function isForced(feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';
var isForced_1 = isForced;
var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/

var _export = function _export(options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;

  if (GLOBAL) {
    target = global_1;
  } else if (STATIC) {
    target = global_1[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global_1[TARGET] || {}).prototype;
  }

  if (target) for (key in source) {
    sourceProperty = source[key];

    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor$1(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];

    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contained in target

    if (!FORCED && targetProperty !== undefined) {
      if (_typeof3(sourceProperty) === _typeof3(targetProperty)) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    } // add a flag to not completely full polyfills


    if (options.sham || targetProperty && targetProperty.sham) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    } // extend global


    redefine(target, key, sourceProperty, options);
  }
}; // `IsArray` abstract operation
// https://tc39.github.io/ecma262/#sec-isarray


var isArray = Array.isArray || function isArray(arg) {
  return classofRaw(arg) == 'Array';
};

var createProperty = function createProperty(object, key, value) {
  var propertyKey = toPrimitive(key);
  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));else object[propertyKey] = value;
};

var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
  // Chrome 38 Symbol has incorrect toString conversion
  // eslint-disable-next-line no-undef
  return !String(Symbol());
});
var Symbol$1 = global_1.Symbol;
var store$2 = shared('wks');

var wellKnownSymbol = function wellKnownSymbol(name) {
  return store$2[name] || (store$2[name] = nativeSymbol && Symbol$1[name] || (nativeSymbol ? Symbol$1 : uid)('Symbol.' + name));
};

var userAgent = getBuiltIn('navigator', 'userAgent') || '';
var process = global_1.process;
var versions = process && process.versions;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] + match[1];
} else if (userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);

  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

var v8Version = version && +version;
var SPECIES = wellKnownSymbol('species');

var arrayMethodHasSpeciesSupport = function arrayMethodHasSpeciesSupport(METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return v8Version >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};

    constructor[SPECIES] = function () {
      return {
        foo: 1
      };
    };

    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};

var SPECIES$1 = wellKnownSymbol('species');
var nativeSlice = [].slice;
var max$1 = Math.max; // `Array.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects

_export({
  target: 'Array',
  proto: true,
  forced: !arrayMethodHasSpeciesSupport('slice')
}, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = toLength(O.length);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length); // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible

    var Constructor, result, n;

    if (isArray(O)) {
      Constructor = O.constructor; // cross-realm fallback

      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES$1];
        if (Constructor === null) Constructor = undefined;
      }

      if (Constructor === Array || Constructor === undefined) {
        return nativeSlice.call(O, k, fin);
      }
    }

    result = new (Constructor === undefined ? Array : Constructor)(max$1(fin - k, 0));

    for (n = 0; k < fin; k++, n++) {
      if (k in O) createProperty(result, n, O[k]);
    }

    result.length = n;
    return result;
  }
});

var defineProperty = objectDefineProperty.f;
var FunctionPrototype = Function.prototype;
var FunctionPrototypeToString = FunctionPrototype.toString;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name'; // Function instances `.name` property
// https://tc39.github.io/ecma262/#sec-function-instances-name

if (descriptors && !(NAME in FunctionPrototype)) {
  defineProperty(FunctionPrototype, NAME, {
    configurable: true,
    get: function get() {
      try {
        return FunctionPrototypeToString.call(this).match(nameRE)[1];
      } catch (error) {
        return '';
      }
    }
  });
}

var nativeGetOwnPropertyNames = objectGetOwnPropertyNames.f;
var toString$1 = {}.toString;
var windowNames = (typeof window === "undefined" ? "undefined" : _typeof3(window)) == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function getWindowNames(it) {
  try {
    return nativeGetOwnPropertyNames(it);
  } catch (error) {
    return windowNames.slice();
  }
}; // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window


var f$5 = function getOwnPropertyNames(it) {
  return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : nativeGetOwnPropertyNames(toIndexedObject(it));
};

var objectGetOwnPropertyNamesExternal = {
  f: f$5
};
var nativeGetOwnPropertyNames$1 = objectGetOwnPropertyNamesExternal.f;
var FAILS_ON_PRIMITIVES = fails(function () {
  return !Object.getOwnPropertyNames(1);
}); // `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames

_export({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES
}, {
  getOwnPropertyNames: nativeGetOwnPropertyNames$1
});

function _typeof2(obj) {
  if (typeof Symbol === "function" && _typeof3(Symbol.iterator) === "symbol") {
    _typeof2 = function _typeof2(obj) {
      return _typeof3(obj);
    };
  } else {
    _typeof2 = function _typeof2(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof3(obj);
    };
  }

  return _typeof2(obj);
}

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
} // `ToObject` abstract operation
// https://tc39.github.io/ecma262/#sec-toobject


var toObject = function toObject(argument) {
  return Object(requireObjectCoercible(argument));
}; // `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys


var objectKeys = Object.keys || function keys(O) {
  return objectKeysInternal(O, enumBugKeys);
}; // `Object.defineProperties` method
// https://tc39.github.io/ecma262/#sec-object.defineproperties


var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;

  while (length > index) {
    objectDefineProperty.f(O, key = keys[index++], Properties[key]);
  }

  return O;
};
var html = getBuiltIn('document', 'documentElement');
var IE_PROTO = sharedKey('IE_PROTO');
var PROTOTYPE = 'prototype';

var Empty = function Empty() {
  /* empty */
}; // Create object with fake `null` prototype: use iframe Object with cleared prototype


var _createDict = function createDict() {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var length = enumBugKeys.length;
  var lt = '<';
  var script = 'script';
  var gt = '>';
  var js = 'java' + script + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  iframe.src = String(js);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + script + gt + 'document.F=Object' + lt + '/' + script + gt);
  iframeDocument.close();
  _createDict = iframeDocument.F;

  while (length--) {
    delete _createDict[PROTOTYPE][enumBugKeys[length]];
  }

  return _createDict();
}; // `Object.create` method
// https://tc39.github.io/ecma262/#sec-object.create


var objectCreate = Object.create || function create(O, Properties) {
  var result;

  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

    result[IE_PROTO] = O;
  } else result = _createDict();

  return Properties === undefined ? result : objectDefineProperties(result, Properties);
};

hiddenKeys[IE_PROTO] = true;
var f$6 = wellKnownSymbol;
var wrappedWellKnownSymbol = {
  f: f$6
};
var defineProperty$1 = objectDefineProperty.f;

var defineWellKnownSymbol = function defineWellKnownSymbol(NAME) {
  var _Symbol2 = path.Symbol || (path.Symbol = {});

  if (!has(_Symbol2, NAME)) defineProperty$1(_Symbol2, NAME, {
    value: wrappedWellKnownSymbol.f(NAME)
  });
};

var defineProperty$2 = objectDefineProperty.f;
var TO_STRING_TAG = wellKnownSymbol('toStringTag');

var setToStringTag = function setToStringTag(it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty$2(it, TO_STRING_TAG, {
      configurable: true,
      value: TAG
    });
  }
};

var aFunction$1 = function aFunction$1(it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  }

  return it;
}; // optional / simple context binding


var bindContext = function bindContext(fn, that, length) {
  aFunction$1(fn);
  if (that === undefined) return fn;

  switch (length) {
    case 0:
      return function () {
        return fn.call(that);
      };

    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }

  return function ()
  /* ...args */
  {
    return fn.apply(that, arguments);
  };
};

var SPECIES$2 = wellKnownSymbol('species'); // `ArraySpeciesCreate` abstract operation
// https://tc39.github.io/ecma262/#sec-arrayspeciescreate

var arraySpeciesCreate = function arraySpeciesCreate(originalArray, length) {
  var C;

  if (isArray(originalArray)) {
    C = originalArray.constructor; // cross-realm fallback

    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;else if (isObject(C)) {
      C = C[SPECIES$2];
      if (C === null) C = undefined;
    }
  }

  return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
};

var push = [].push; // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation

var createMethod$1 = function createMethod$1(TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = indexedObject(O);
    var boundFunction = bindContext(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var value, result;

    for (; length > index; index++) {
      if (NO_HOLES || index in self) {
        value = self[index];
        result = boundFunction(value, index, O);

        if (TYPE) {
          if (IS_MAP) target[index] = result; // map
          else if (result) switch (TYPE) {
              case 3:
                return true;
              // some

              case 5:
                return value;
              // find

              case 6:
                return index;
              // findIndex

              case 2:
                push.call(target, value);
              // filter
            } else if (IS_EVERY) return false; // every
        }
      }
    }

    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

var arrayIteration = {
  // `Array.prototype.forEach` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
  forEach: createMethod$1(0),
  // `Array.prototype.map` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.map
  map: createMethod$1(1),
  // `Array.prototype.filter` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
  filter: createMethod$1(2),
  // `Array.prototype.some` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.some
  some: createMethod$1(3),
  // `Array.prototype.every` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.every
  every: createMethod$1(4),
  // `Array.prototype.find` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.find
  find: createMethod$1(5),
  // `Array.prototype.findIndex` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod$1(6)
};
var $forEach = arrayIteration.forEach;
var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE$1 = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var setInternalState = internalState.set;
var getInternalState = internalState.getterFor(SYMBOL);
var ObjectPrototype = Object[PROTOTYPE$1];
var $Symbol = global_1.Symbol;
var JSON$1 = global_1.JSON;
var nativeJSONStringify = JSON$1 && JSON$1.stringify;
var nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
var nativeDefineProperty$1 = objectDefineProperty.f;
var nativeGetOwnPropertyNames$2 = objectGetOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable$1 = objectPropertyIsEnumerable.f;
var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');
var WellKnownSymbolsStore = shared('wks');
var QObject = global_1.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

var USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

var setSymbolDescriptor = descriptors && fails(function () {
  return objectCreate(nativeDefineProperty$1({}, 'a', {
    get: function get() {
      return nativeDefineProperty$1(this, 'a', {
        value: 7
      }).a;
    }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty$1(O, P, Attributes);

  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty$1(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty$1;

var wrap = function wrap(tag, description) {
  var symbol = AllSymbols[tag] = objectCreate($Symbol[PROTOTYPE$1]);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!descriptors) symbol.description = description;
  return symbol;
};

var isSymbol = nativeSymbol && _typeof3($Symbol.iterator) == 'symbol' ? function (it) {
  return _typeof3(it) == 'symbol';
} : function (it) {
  return Object(it) instanceof $Symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPrimitive(P, true);
  anObject(Attributes);

  if (has(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!has(O, HIDDEN)) nativeDefineProperty$1(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = objectCreate(Attributes, {
        enumerable: createPropertyDescriptor(0, false)
      });
    }

    return setSymbolDescriptor(O, key, Attributes);
  }

  return nativeDefineProperty$1(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!descriptors || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? objectCreate(O) : $defineProperties(objectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPrimitive(V, true);
  var enumerable = nativePropertyIsEnumerable$1.call(this, P);
  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPrimitive(P, true);
  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);

  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }

  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames$2(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
  });
  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames$2(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
      result.push(AllSymbols[key]);
    }
  });
  return result;
}; // `Symbol` constructor
// https://tc39.github.io/ecma262/#sec-symbol-constructor


if (!nativeSymbol) {
  $Symbol = function _Symbol3() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
    var tag = uid(description);

    var setter = function setter(value) {
      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };

    if (descriptors && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, {
      configurable: true,
      set: setter
    });
    return wrap(tag, description);
  };

  redefine($Symbol[PROTOTYPE$1], 'toString', function toString() {
    return getInternalState(this).tag;
  });
  objectPropertyIsEnumerable.f = $propertyIsEnumerable;
  objectDefineProperty.f = $defineProperty;
  objectGetOwnPropertyDescriptor.f = $getOwnPropertyDescriptor;
  objectGetOwnPropertyNames.f = objectGetOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  objectGetOwnPropertySymbols.f = $getOwnPropertySymbols;

  if (descriptors) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty$1($Symbol[PROTOTYPE$1], 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    {
      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, {
        unsafe: true
      });
    }
  }

  wrappedWellKnownSymbol.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };
}

_export({
  global: true,
  wrap: true,
  forced: !nativeSymbol,
  sham: !nativeSymbol
}, {
  Symbol: $Symbol
});

$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});

_export({
  target: SYMBOL,
  stat: true,
  forced: !nativeSymbol
}, {
  // `Symbol.for` method
  // https://tc39.github.io/ecma262/#sec-symbol.for
  'for': function _for(key) {
    var string = String(key);
    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = $Symbol(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  },
  // `Symbol.keyFor` method
  // https://tc39.github.io/ecma262/#sec-symbol.keyfor
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  },
  useSetter: function useSetter() {
    USE_SETTER = true;
  },
  useSimple: function useSimple() {
    USE_SETTER = false;
  }
});

_export({
  target: 'Object',
  stat: true,
  forced: !nativeSymbol,
  sham: !descriptors
}, {
  // `Object.create` method
  // https://tc39.github.io/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

_export({
  target: 'Object',
  stat: true,
  forced: !nativeSymbol
}, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames,
  // `Object.getOwnPropertySymbols` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
  getOwnPropertySymbols: $getOwnPropertySymbols
}); // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443


_export({
  target: 'Object',
  stat: true,
  forced: fails(function () {
    objectGetOwnPropertySymbols.f(1);
  })
}, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return objectGetOwnPropertySymbols.f(toObject(it));
  }
}); // `JSON.stringify` method behavior with symbols
// https://tc39.github.io/ecma262/#sec-json.stringify


JSON$1 && _export({
  target: 'JSON',
  stat: true,
  forced: !nativeSymbol || fails(function () {
    var symbol = $Symbol(); // MS Edge converts symbol values to JSON as {}

    return nativeJSONStringify([symbol]) != '[null]' // WebKit converts symbol values to JSON as null
    || nativeJSONStringify({
      a: symbol
    }) != '{}' // V8 throws on boxed symbols
    || nativeJSONStringify(Object(symbol)) != '{}';
  })
}, {
  stringify: function stringify(it) {
    var args = [it];
    var index = 1;
    var replacer, $replacer;

    while (arguments.length > index) {
      args.push(arguments[index++]);
    }

    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

    if (!isArray(replacer)) replacer = function replacer(key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return nativeJSONStringify.apply(JSON$1, args);
  }
}); // `Symbol.prototype[@@toPrimitive]` method
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive

if (!$Symbol[PROTOTYPE$1][TO_PRIMITIVE]) {
  createNonEnumerableProperty($Symbol[PROTOTYPE$1], TO_PRIMITIVE, $Symbol[PROTOTYPE$1].valueOf);
} // `Symbol.prototype[@@toStringTag]` property
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag


setToStringTag($Symbol, SYMBOL);
hiddenKeys[HIDDEN] = true;
var defineProperty$3 = objectDefineProperty.f;
var NativeSymbol = global_1.Symbol;

if (descriptors && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) || // Safari 12 bug
NativeSymbol().description !== undefined)) {
  var EmptyStringDescriptionStore = {}; // wrap Symbol constructor for correct work with undefined description

  var SymbolWrapper = function _Symbol4() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
    var result = this instanceof SymbolWrapper ? new NativeSymbol(description) // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
    : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };

  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
  symbolPrototype.constructor = SymbolWrapper;
  var symbolToString = symbolPrototype.toString;

  var _native = String(NativeSymbol('test')) == 'Symbol(test)';

  var regexp = /^Symbol\((.*)\)[^)]+$/;
  defineProperty$3(symbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = isObject(this) ? this.valueOf() : this;
      var string = symbolToString.call(symbol);
      if (has(EmptyStringDescriptionStore, symbol)) return '';
      var desc = _native ? string.slice(7, -1) : string.replace(regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });

  _export({
    global: true,
    forced: true
  }, {
    Symbol: SymbolWrapper
  });
} // `Symbol.iterator` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.iterator


defineWellKnownSymbol('iterator');
var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype; // Array.prototype[@@unscopables]
// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

if (ArrayPrototype[UNSCOPABLES] == undefined) {
  createNonEnumerableProperty(ArrayPrototype, UNSCOPABLES, objectCreate(null));
} // add a key to Array.prototype[@@unscopables]


var addToUnscopables = function addToUnscopables(key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};

var iterators = {};
var correctPrototypeGetter = !fails(function () {
  function F() {
    /* empty */
  }

  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});
var IE_PROTO$1 = sharedKey('IE_PROTO');
var ObjectPrototype$1 = Object.prototype; // `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof

var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];

  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }

  return O instanceof Object ? ObjectPrototype$1 : null;
};
var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function returnThis() {
  return this;
}; // `%IteratorPrototype%` object
// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object


var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

if ([].keys) {
  arrayIterator = [].keys(); // Safari 8 has buggy iterators w/o `next`

  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;else {
    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

if (IteratorPrototype == undefined) IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

if (!has(IteratorPrototype, ITERATOR)) {
  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
}

var iteratorsCore = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};
var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;

var returnThis$1 = function returnThis$1() {
  return this;
};

var createIteratorConstructor = function createIteratorConstructor(IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, {
    next: createPropertyDescriptor(1, next)
  });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false);
  iterators[TO_STRING_TAG] = returnThis$1;
  return IteratorConstructor;
};

var aPossiblePrototype = function aPossiblePrototype(it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  }

  return it;
}; // `Object.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.

/* eslint-disable no-proto */


var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;

  try {
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) {
    /* empty */
  }

  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);else O.__proto__ = proto;
    return O;
  };
}() : undefined);
var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$1 = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis$2 = function returnThis$2() {
  return this;
};

var defineIterator = function defineIterator(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function getIterationMethod(KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];

    switch (KIND) {
      case KEYS:
        return function keys() {
          return new IteratorConstructor(this, KIND);
        };

      case VALUES:
        return function values() {
          return new IteratorConstructor(this, KIND);
        };

      case ENTRIES:
        return function entries() {
          return new IteratorConstructor(this, KIND);
        };
    }

    return function () {
      return new IteratorConstructor(this);
    };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR$1] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY; // fix native

  if (anyNativeIterator) {
    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));

    if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {
      if (objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {
        if (objectSetPrototypeOf) {
          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);
        } else if (typeof CurrentIteratorPrototype[ITERATOR$1] != 'function') {
          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$1, returnThis$2);
        }
      } // Set @@toStringTag to native iterators


      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
    }
  } // fix Array#{values, @@iterator}.name in V8 / FF


  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;

    defaultIterator = function values() {
      return nativeIterator.call(this);
    };
  } // define iterator


  if (IterablePrototype[ITERATOR$1] !== defaultIterator) {
    createNonEnumerableProperty(IterablePrototype, ITERATOR$1, defaultIterator);
  }

  iterators[NAME] = defaultIterator; // export additional methods

  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else _export({
      target: NAME,
      proto: true,
      forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME
    }, methods);
  }

  return methods;
};

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState$1 = internalState.set;
var getInternalState$1 = internalState.getterFor(ARRAY_ITERATOR); // `Array.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.github.io/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.github.io/ecma262/#sec-createarrayiterator

var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState$1(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated),
    // target
    index: 0,
    // next index
    kind: kind // kind

  }); // `%ArrayIteratorPrototype%.next` method
  // https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState$1(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;

  if (!target || index >= target.length) {
    state.target = undefined;
    return {
      value: undefined,
      done: true
    };
  }

  if (kind == 'keys') return {
    value: index,
    done: false
  };
  if (kind == 'values') return {
    value: target[index],
    done: false
  };
  return {
    value: [index, target[index]],
    done: false
  };
}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject

iterators.Arguments = iterators.Array; // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');
var nativeAssign = Object.assign; // `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign
// should work with symbols and should have deterministic property order (V8 bug)

var objectAssign = !nativeAssign || fails(function () {
  var A = {};
  var B = {}; // eslint-disable-next-line no-undef

  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) {
    B[chr] = chr;
  });
  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
  var propertyIsEnumerable = objectPropertyIsEnumerable.f;

  while (argumentsLength > index) {
    var S = indexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;

    while (length > j) {
      key = keys[j++];
      if (!descriptors || propertyIsEnumerable.call(S, key)) T[key] = S[key];
    }
  }

  return T;
} : nativeAssign; // `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign

_export({
  target: 'Object',
  stat: true,
  forced: Object.assign !== objectAssign
}, {
  assign: objectAssign
});

var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag'); // ES3 wrong here

var CORRECT_ARGUMENTS = classofRaw(function () {
  return arguments;
}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

var tryGet = function tryGet(it, key) {
  try {
    return it[key];
  } catch (error) {
    /* empty */
  }
}; // getting tag from ES6+ `Object.prototype.toString`


var classof = function classof(it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
  : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$1)) == 'string' ? tag // builtinTag case
  : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback
  : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};

var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');
var test = {};
test[TO_STRING_TAG$2] = 'z'; // `Object.prototype.toString` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring

var objectToString = String(test) !== '[object z]' ? function toString() {
  return '[object ' + classof(this) + ']';
} : test.toString;
var ObjectPrototype$2 = Object.prototype; // `Object.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring

if (objectToString !== ObjectPrototype$2.toString) {
  redefine(ObjectPrototype$2, 'toString', objectToString, {
    unsafe: true
  });
}

var freezing = !fails(function () {
  return Object.isExtensible(Object.preventExtensions({}));
});
var internalMetadata = createCommonjsModule(function (module) {
  var defineProperty = objectDefineProperty.f;
  var METADATA = uid('meta');
  var id = 0;

  var isExtensible = Object.isExtensible || function () {
    return true;
  };

  var setMetadata = function setMetadata(it) {
    defineProperty(it, METADATA, {
      value: {
        objectID: 'O' + ++id,
        // object ID
        weakData: {} // weak collections IDs

      }
    });
  };

  var fastKey = function fastKey(it, create) {
    // return a primitive with prefix
    if (!isObject(it)) return _typeof3(it) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

    if (!has(it, METADATA)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return 'F'; // not necessary to add metadata

      if (!create) return 'E'; // add missing metadata

      setMetadata(it); // return object ID
    }

    return it[METADATA].objectID;
  };

  var getWeakData = function getWeakData(it, create) {
    if (!has(it, METADATA)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return true; // not necessary to add metadata

      if (!create) return false; // add missing metadata

      setMetadata(it); // return the store of weak collections IDs
    }

    return it[METADATA].weakData;
  }; // add metadata on freeze-family methods calling


  var onFreeze = function onFreeze(it) {
    if (freezing && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
    return it;
  };

  var meta = module.exports = {
    REQUIRED: false,
    fastKey: fastKey,
    getWeakData: getWeakData,
    onFreeze: onFreeze
  };
  hiddenKeys[METADATA] = true;
});
var ITERATOR$2 = wellKnownSymbol('iterator');
var ArrayPrototype$1 = Array.prototype; // check on default Array iterator

var isArrayIteratorMethod = function isArrayIteratorMethod(it) {
  return it !== undefined && (iterators.Array === it || ArrayPrototype$1[ITERATOR$2] === it);
};

var ITERATOR$3 = wellKnownSymbol('iterator');

var getIteratorMethod = function getIteratorMethod(it) {
  if (it != undefined) return it[ITERATOR$3] || it['@@iterator'] || iterators[classof(it)];
}; // call something on iterator step with safe closing on error


var callWithSafeIterationClosing = function callWithSafeIterationClosing(iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
  } catch (error) {
    var returnMethod = iterator['return'];
    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
    throw error;
  }
};

var iterate_1 = createCommonjsModule(function (module) {
  var Result = function Result(stopped, result) {
    this.stopped = stopped;
    this.result = result;
  };

  var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
    var boundFunction = bindContext(fn, that, AS_ENTRIES ? 2 : 1);
    var iterator, iterFn, index, length, result, next, step;

    if (IS_ITERATOR) {
      iterator = iterable;
    } else {
      iterFn = getIteratorMethod(iterable);
      if (typeof iterFn != 'function') throw TypeError('Target is not iterable'); // optimisation for array iterators

      if (isArrayIteratorMethod(iterFn)) {
        for (index = 0, length = toLength(iterable.length); length > index; index++) {
          result = AS_ENTRIES ? boundFunction(anObject(step = iterable[index])[0], step[1]) : boundFunction(iterable[index]);
          if (result && result instanceof Result) return result;
        }

        return new Result(false);
      }

      iterator = iterFn.call(iterable);
    }

    next = iterator.next;

    while (!(step = next.call(iterator)).done) {
      result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
      if (_typeof3(result) == 'object' && result && result instanceof Result) return result;
    }

    return new Result(false);
  };

  iterate.stop = function (result) {
    return new Result(true, result);
  };
});

var anInstance = function anInstance(it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  }

  return it;
};

var ITERATOR$4 = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function next() {
      return {
        done: !!called++
      };
    },
    'return': function _return() {
      SAFE_CLOSING = true;
    }
  };

  iteratorWithReturn[ITERATOR$4] = function () {
    return this;
  }; // eslint-disable-next-line no-throw-literal


  Array.from(iteratorWithReturn, function () {
    throw 2;
  });
} catch (error) {
  /* empty */
}

var checkCorrectnessOfIteration = function checkCorrectnessOfIteration(exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;

  try {
    var object = {};

    object[ITERATOR$4] = function () {
      return {
        next: function next() {
          return {
            done: ITERATION_SUPPORT = true
          };
        }
      };
    };

    exec(object);
  } catch (error) {
    /* empty */
  }

  return ITERATION_SUPPORT;
}; // makes subclassing work correct for wrapped built-ins


var inheritIfRequired = function inheritIfRequired($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if ( // it can work only with native `setPrototypeOf`
  objectSetPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
  typeof (NewTarget = dummy.constructor) == 'function' && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) objectSetPrototypeOf($this, NewTargetPrototype);
  return $this;
};

var collection = function collection(CONSTRUCTOR_NAME, wrapper, common, IS_MAP, IS_WEAK) {
  var NativeConstructor = global_1[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var ADDER = IS_MAP ? 'set' : 'add';
  var exported = {};

  var fixMethod = function fixMethod(KEY) {
    var nativeMethod = NativePrototype[KEY];
    redefine(NativePrototype, KEY, KEY == 'add' ? function add(value) {
      nativeMethod.call(this, value === 0 ? 0 : value);
      return this;
    } : KEY == 'delete' ? function (key) {
      return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
    } : KEY == 'get' ? function get(key) {
      return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
    } : KEY == 'has' ? function has(key) {
      return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
    } : function set(key, value) {
      nativeMethod.call(this, key === 0 ? 0 : key, value);
      return this;
    });
  }; // eslint-disable-next-line max-len


  if (isForced_1(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
    new NativeConstructor().entries().next();
  })))) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    internalMetadata.REQUIRED = true;
  } else if (isForced_1(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor(); // early implementations not supports chaining

    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false

    var THROWS_ON_PRIMITIVES = fails(function () {
      instance.has(1);
    }); // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new

    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) {
      new NativeConstructor(iterable);
    }); // for early implementations -0 and +0 not the same

    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;

      while (index--) {
        $instance[ADDER](index, index);
      }

      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method

    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }

  exported[CONSTRUCTOR_NAME] = Constructor;

  _export({
    global: true,
    forced: Constructor != NativeConstructor
  }, exported);

  setToStringTag(Constructor, CONSTRUCTOR_NAME);
  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
  return Constructor;
};

var redefineAll = function redefineAll(target, src, options) {
  for (var key in src) {
    redefine(target, key, src[key], options);
  }

  return target;
};

var SPECIES$3 = wellKnownSymbol('species');

var setSpecies = function setSpecies(CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = objectDefineProperty.f;

  if (descriptors && Constructor && !Constructor[SPECIES$3]) {
    defineProperty(Constructor, SPECIES$3, {
      configurable: true,
      get: function get() {
        return this;
      }
    });
  }
};

var defineProperty$4 = objectDefineProperty.f;
var fastKey = internalMetadata.fastKey;
var setInternalState$2 = internalState.set;
var internalStateGetterFor = internalState.getterFor;
var collectionStrong = {
  getConstructor: function getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, CONSTRUCTOR_NAME);
      setInternalState$2(that, {
        type: CONSTRUCTOR_NAME,
        index: objectCreate(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!descriptors) that.size = 0;
      if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);
    });
    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function define(that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index; // change existing entry

      if (entry) {
        entry.value = value; // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (descriptors) state.size++;else that.size++; // add to index

        if (index !== 'F') state.index[index] = entry;
      }

      return that;
    };

    var getEntry = function getEntry(that, key) {
      var state = getInternalState(that); // fast case

      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index]; // frozen object case

      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key) return entry;
      }
    };

    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;

        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }

        state.first = state.last = undefined;
        if (descriptors) state.size = 0;else that.size = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function _delete(key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);

        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first == entry) state.first = next;
          if (state.last == entry) state.last = prev;
          if (descriptors) state.size--;else that.size--;
        }

        return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn
      /* , that = undefined */
      ) {
        var state = getInternalState(this);
        var boundFunction = bindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;

        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this); // revert to the last existing entry

          while (entry && entry.removed) {
            entry = entry.previous;
          }
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });
    redefineAll(C.prototype, IS_MAP ? {
      // 23.1.3.6 Map.prototype.get(key)
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // 23.1.3.9 Map.prototype.set(key, value)
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // 23.2.3.1 Set.prototype.add(value)
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (descriptors) defineProperty$4(C.prototype, 'size', {
      get: function get() {
        return getInternalState(this).size;
      }
    });
    return C;
  },
  setStrong: function setStrong(C, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME); // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11

    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState$2(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last; // revert to the last existing entry

      while (entry && entry.removed) {
        entry = entry.previous;
      } // get next entry


      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return {
          value: undefined,
          done: true
        };
      } // return step by kind


      if (kind == 'keys') return {
        value: entry.key,
        done: false
      };
      if (kind == 'values') return {
        value: entry.value,
        done: false
      };
      return {
        value: [entry.key, entry.value],
        done: false
      };
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2

    setSpecies(CONSTRUCTOR_NAME);
  }
}; // `Set` constructor
// https://tc39.github.io/ecma262/#sec-set-objects

var es_set = collection('Set', function (get) {
  return function Set() {
    return get(this, arguments.length ? arguments[0] : undefined);
  };
}, collectionStrong); // `String.prototype.{ codePointAt, at }` methods implementation

var createMethod$2 = function createMethod$2(CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = String(requireObjectCoercible($this));
    var position = toInteger(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = S.charCodeAt(position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

var stringMultibyte = {
  // `String.prototype.codePointAt` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod$2(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod$2(true)
};
var charAt = stringMultibyte.charAt;
var STRING_ITERATOR = 'String Iterator';
var setInternalState$3 = internalState.set;
var getInternalState$2 = internalState.getterFor(STRING_ITERATOR); // `String.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator

defineIterator(String, 'String', function (iterated) {
  setInternalState$3(this, {
    type: STRING_ITERATOR,
    string: String(iterated),
    index: 0
  }); // `%StringIteratorPrototype%.next` method
  // https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState$2(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return {
    value: undefined,
    done: true
  };
  point = charAt(string, index);
  state.index += point.length;
  return {
    value: point,
    done: false
  };
}); // iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods

var domIterables = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};
var ITERATOR$5 = wellKnownSymbol('iterator');
var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');
var ArrayValues = es_array_iterator.values;

for (var COLLECTION_NAME in domIterables) {
  var Collection = global_1[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;

  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR$5] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR$5, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR$5] = ArrayValues;
    }

    if (!CollectionPrototype[TO_STRING_TAG$3]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG$3, COLLECTION_NAME);
    }

    if (domIterables[COLLECTION_NAME]) for (var METHOD_NAME in es_array_iterator) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, es_array_iterator[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = es_array_iterator[METHOD_NAME];
      }
    }
  }
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

var methods = {};
var names = [];

function registerMethods(name, m) {
  if (Array.isArray(name)) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = name[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _name = _step.value;
        registerMethods(_name, m);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return;
  }

  if (_typeof(name) === 'object') {
    for (var _name2 in name) {
      registerMethods(_name2, name[_name2]);
    }

    return;
  }

  addMethodNames(Object.getOwnPropertyNames(m));
  methods[name] = Object.assign(methods[name] || {}, m);
}

function getMethodsFor(name) {
  return methods[name] || {};
}

function getMethodNames() {
  return _toConsumableArray(new Set(names));
}

function addMethodNames(_names) {
  names.push.apply(names, _toConsumableArray(_names));
}

var $includes = arrayIncludes.includes; // `Array.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-array.prototype.includes

_export({
  target: 'Array',
  proto: true
}, {
  includes: function includes(el
  /* , fromIndex = 0 */
  ) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
}); // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables


addToUnscopables('includes'); // `RegExp.prototype.flags` getter implementation
// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags

var regexpFlags = function regexpFlags() {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.

var nativeReplace = String.prototype.replace;
var patchedExec = nativeExec;

var UPDATES_LAST_INDEX_WRONG = function () {
  var re1 = /a/;
  var re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
}(); // nonparticipating capturing group, copied from es5-shim's String#split patch.


var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }

    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }

    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

var regexpExec = patchedExec;

_export({
  target: 'RegExp',
  proto: true,
  forced: /./.exec !== regexpExec
}, {
  exec: regexpExec
});

var MATCH = wellKnownSymbol('match'); // `IsRegExp` abstract operation
// https://tc39.github.io/ecma262/#sec-isregexp

var isRegexp = function isRegexp(it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
};

var notARegexp = function notARegexp(it) {
  if (isRegexp(it)) {
    throw TypeError("The method doesn't accept regular expressions");
  }

  return it;
};

var MATCH$1 = wellKnownSymbol('match');

var correctIsRegexpLogic = function correctIsRegexpLogic(METHOD_NAME) {
  var regexp = /./;

  try {
    '/./'[METHOD_NAME](regexp);
  } catch (e) {
    try {
      regexp[MATCH$1] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (f) {
      /* empty */
    }
  }

  return false;
}; // `String.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-string.prototype.includes


_export({
  target: 'String',
  proto: true,
  forced: !correctIsRegexpLogic('includes')
}, {
  includes: function includes(searchString
  /* , position = 0 */
  ) {
    return !!~String(requireObjectCoercible(this)).indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);
  }
});

var SPECIES$4 = wellKnownSymbol('species');
var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;

  re.exec = function () {
    var result = [];
    result.groups = {
      a: '7'
    };
    return result;
  };

  return ''.replace(re, '$<a>') !== '7';
}); // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
  var re = /(?:)/;
  var originalExec = re.exec;

  re.exec = function () {
    return originalExec.apply(this, arguments);
  };

  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});

var fixRegexpWellKnownSymbolLogic = function fixRegexpWellKnownSymbolLogic(KEY, length, exec, sham) {
  var SYMBOL = wellKnownSymbol(KEY);
  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};

    O[SYMBOL] = function () {
      return 7;
    };

    return ''[KEY](O) != 7;
  });
  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {}; // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.

      re.constructor = {};

      re.constructor[SPECIES$4] = function () {
        return re;
      };

      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () {
      execCalled = true;
      return null;
    };

    re[SYMBOL]('');
    return !execCalled;
  });

  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return {
            done: true,
            value: nativeRegExpMethod.call(regexp, str, arg2)
          };
        }

        return {
          done: true,
          value: nativeMethod.call(str, regexp, arg2)
        };
      }

      return {
        done: false
      };
    });
    var stringMethod = methods[0];
    var regexMethod = methods[1];
    redefine(String.prototype, KEY, stringMethod);
    redefine(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
    ? function (string, arg) {
      return regexMethod.call(string, this, arg);
    } // 21.2.5.6 RegExp.prototype[@@match](string)
    // 21.2.5.9 RegExp.prototype[@@search](string)
    : function (string) {
      return regexMethod.call(string, this);
    });
    if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
  }
};

var charAt$1 = stringMultibyte.charAt; // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex

var advanceStringIndex = function advanceStringIndex(S, index, unicode) {
  return index + (unicode ? charAt$1(S, index).length : 1);
}; // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec


var regexpExecAbstract = function regexpExecAbstract(R, S) {
  var exec = R.exec;

  if (typeof exec === 'function') {
    var result = exec.call(R, S);

    if (_typeof3(result) !== 'object') {
      throw TypeError('RegExp exec method returned something other than an Object or null');
    }

    return result;
  }

  if (classofRaw(R) !== 'RegExp') {
    throw TypeError('RegExp#exec called on incompatible receiver');
  }

  return regexpExec.call(R, S);
};

var max$2 = Math.max;
var min$2 = Math.min;
var floor$1 = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;

var maybeToString = function maybeToString(it) {
  return it === undefined ? it : String(it);
}; // @@replace logic


fixRegexpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative) {
  return [// `String.prototype.replace` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.replace
  function replace(searchValue, replaceValue) {
    var O = requireObjectCoercible(this);
    var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
    return replacer !== undefined ? replacer.call(searchValue, O, replaceValue) : nativeReplace.call(String(O), searchValue, replaceValue);
  }, // `RegExp.prototype[@@replace]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
  function (regexp, replaceValue) {
    var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var functionalReplace = typeof replaceValue === 'function';
    if (!functionalReplace) replaceValue = String(replaceValue);
    var global = rx.global;

    if (global) {
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
    }

    var results = [];

    while (true) {
      var result = regexpExecAbstract(rx, S);
      if (result === null) break;
      results.push(result);
      if (!global) break;
      var matchStr = String(result[0]);
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
    }

    var accumulatedResult = '';
    var nextSourcePosition = 0;

    for (var i = 0; i < results.length; i++) {
      result = results[i];
      var matched = String(result[0]);
      var position = max$2(min$2(toInteger(result.index), S.length), 0);
      var captures = []; // NOTE: This is equivalent to
      //   captures = result.slice(1).map(maybeToString)
      // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
      // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
      // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

      for (var j = 1; j < result.length; j++) {
        captures.push(maybeToString(result[j]));
      }

      var namedCaptures = result.groups;

      if (functionalReplace) {
        var replacerArgs = [matched].concat(captures, position, S);
        if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
        var replacement = String(replaceValue.apply(undefined, replacerArgs));
      } else {
        replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
      }

      if (position >= nextSourcePosition) {
        accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
        nextSourcePosition = position + matched.length;
      }
    }

    return accumulatedResult + S.slice(nextSourcePosition);
  }]; // https://tc39.github.io/ecma262/#sec-getsubstitution

  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }

    return nativeReplace.call(replacement, symbols, function (match, ch) {
      var capture;

      switch (ch.charAt(0)) {
        case '$':
          return '$';

        case '&':
          return matched;

        case '`':
          return str.slice(0, position);

        case "'":
          return str.slice(tailPos);

        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;

        default:
          // \d\d?
          var n = +ch;
          if (n === 0) return match;

          if (n > m) {
            var f = floor$1(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }

          capture = captures[n - 1];
      }

      return capture === undefined ? '' : capture;
    });
  }
}); // a string of all valid unicode whitespaces
// eslint-disable-next-line max-len

var whitespaces = "\t\n\x0B\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$'); // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation

var createMethod$3 = function createMethod$3(TYPE) {
  return function ($this) {
    var string = String(requireObjectCoercible($this));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };
};

var stringTrim = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
  start: createMethod$3(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
  end: createMethod$3(2),
  // `String.prototype.trim` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.trim
  trim: createMethod$3(3)
};
var non = "\u200B\x85\u180E"; // check that a method works with the correct list
// of whitespaces and has a correct name

var forcedStringTrimMethod = function forcedStringTrimMethod(METHOD_NAME) {
  return fails(function () {
    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
  });
};

var $trim = stringTrim.trim; // `String.prototype.trim` method
// https://tc39.github.io/ecma262/#sec-string.prototype.trim

_export({
  target: 'String',
  proto: true,
  forced: forcedStringTrimMethod('trim')
}, {
  trim: function trim() {
    return $trim(this);
  }
}); // Map function


function map(array, block) {
  var i;
  var il = array.length;
  var result = [];

  for (i = 0; i < il; i++) {
    result.push(block(array[i]));
  }

  return result;
} // Filter function


function filter(array, block) {
  var i;
  var il = array.length;
  var result = [];

  for (i = 0; i < il; i++) {
    if (block(array[i])) {
      result.push(array[i]);
    }
  }

  return result;
} // Degrees to radians


function radians(d) {
  return d % 360 * Math.PI / 180;
} // Radians to degrees


function degrees(r) {
  return r * 180 / Math.PI % 360;
} // Convert dash-separated-string to camelCase


function camelCase(s) {
  return s.toLowerCase().replace(/-(.)/g, function (m, g) {
    return g.toUpperCase();
  });
} // Convert camel cased string to string seperated


function unCamelCase(s) {
  return s.replace(/([A-Z])/g, function (m, g) {
    return '-' + g.toLowerCase();
  });
} // Capitalize first letter of a string


function capitalize(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
} // Calculate proportional width and height values when necessary


function proportionalSize(element, width, height, box) {
  if (width == null || height == null) {
    box = box || element.bbox();

    if (width == null) {
      width = box.width / box.height * height;
    } else if (height == null) {
      height = box.height / box.width * width;
    }
  }

  return {
    width: width,
    height: height
  };
}

function getOrigin(o, element) {
  // Allow origin or around as the names
  var origin = o.origin; // o.around == null ? o.origin : o.around

  var ox, oy; // Allow the user to pass a string to rotate around a given point

  if (typeof origin === 'string' || origin == null) {
    // Get the bounding box of the element with no transformations applied
    var string = (origin || 'center').toLowerCase().trim();

    var _element$bbox = element.bbox(),
        height = _element$bbox.height,
        width = _element$bbox.width,
        x = _element$bbox.x,
        y = _element$bbox.y; // Calculate the transformed x and y coordinates


    var bx = string.includes('left') ? x : string.includes('right') ? x + width : x + width / 2;
    var by = string.includes('top') ? y : string.includes('bottom') ? y + height : y + height / 2; // Set the bounds eg : "bottom-left", "Top right", "middle" etc...

    ox = o.ox != null ? o.ox : bx;
    oy = o.oy != null ? o.oy : by;
  } else {
    ox = origin[0];
    oy = origin[1];
  } // Return the origin as it is if it wasn't a string


  return [ox, oy];
}

var utils = {
  __proto__: null,
  map: map,
  filter: filter,
  radians: radians,
  degrees: degrees,
  camelCase: camelCase,
  unCamelCase: unCamelCase,
  capitalize: capitalize,
  proportionalSize: proportionalSize,
  getOrigin: getOrigin
}; // Default namespaces

exports.utils = utils;
var ns = 'http://www.w3.org/2000/svg';
var xmlns = 'http://www.w3.org/2000/xmlns/';
var xlink = 'http://www.w3.org/1999/xlink';
var svgjs = 'http://svgjs.com/svgjs';
var namespaces = {
  __proto__: null,
  ns: ns,
  xmlns: xmlns,
  xlink: xlink,
  svgjs: svgjs
};
exports.namespaces = namespaces;
var globals = {
  window: typeof window === 'undefined' ? null : window,
  document: typeof document === 'undefined' ? null : document
};

function registerWindow() {
  var win = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var doc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  globals.window = win;
  globals.document = doc;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Base = function Base() {
  _classCallCheck(this, Base);
};

var elements = {};
var root = '___SYMBOL___ROOT___'; // Method for element creation

exports.root = root;

function create(name) {
  // create element
  return globals.document.createElementNS(ns, name);
}

function makeInstance(element) {
  if (element instanceof Base) return element;

  if (_typeof(element) === 'object') {
    return adopter(element);
  }

  if (element == null) {
    return new elements[root]();
  }

  if (typeof element === 'string' && element.charAt(0) !== '<') {
    return adopter(globals.document.querySelector(element));
  }

  var node = create('svg');
  node.innerHTML = element; // We can use firstChild here because we know,
  // that the first char is < and thus an element

  element = adopter(node.firstChild);
  return element;
}

function nodeOrNew(name, node) {
  return node instanceof globals.window.Node ? node : create(name);
} // Adopt existing svg elements


function adopt(node) {
  // check for presence of node
  if (!node) return null; // make sure a node isn't already adopted

  if (node.instance instanceof Base) return node.instance; // initialize variables

  var className = capitalize(node.nodeName || 'Dom'); // Make sure that gradients are adopted correctly

  if (className === 'LinearGradient' || className === 'RadialGradient') {
    className = 'Gradient'; // Fallback to Dom if element is not known
  } else if (!elements[className]) {
    className = 'Dom';
  }

  return new elements[className](node);
}

var adopter = adopt;

function mockAdopt() {
  var mock = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : adopt;
  adopter = mock;
}

function register(element) {
  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : element.name;
  var asRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  elements[name] = element;
  if (asRoot) elements[root] = element;
  addMethodNames(Object.getOwnPropertyNames(element.prototype));
  return element;
}

function getClass(name) {
  return elements[name];
} // Element id sequence


var did = 1000; // Get next named element id

function eid(name) {
  return 'Svgjs' + capitalize(name) + did++;
} // Deep new id assignment


function assignNewId(node) {
  // do the same for SVG child nodes as well
  for (var i = node.children.length - 1; i >= 0; i--) {
    assignNewId(node.children[i]);
  }

  if (node.id) {
    return adopt(node).id(eid(node.nodeName));
  }

  return adopt(node);
} // Method for extending objects


function extend(modules, methods, attrCheck) {
  var key, i;
  modules = Array.isArray(modules) ? modules : [modules];

  for (i = modules.length - 1; i >= 0; i--) {
    for (key in methods) {
      var method = methods[key];

      if (attrCheck) {
        method = wrapWithAttrCheck(methods[key]);
      }

      modules[i].prototype[key] = method;
    }
  }
} // export function extendWithAttrCheck (...args) {
//   extend(...args, true)
// }


function wrapWithAttrCheck(fn) {
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var o = args[args.length - 1];

    if (o && o.constructor === Object && !(o instanceof Array)) {
      return fn.apply(this, args.slice(0, -1)).attr(o);
    } else {
      return fn.apply(this, args);
    }
  };
}

function invent(config) {
  // Create element initializer
  var initializer = typeof config.create === 'function' ? config.create : function (node) {
    this.constructor(node || create(config.create));
  }; // Inherit prototype

  if (config.inherit) {
    /* eslint new-cap: off */
    initializer.prototype = new config.inherit();
    initializer.prototype.constructor = initializer;
  } // Extend with methods


  if (config.extend) {
    extend(initializer, config.extend);
  } // Attach construct method to parent


  if (config.construct) {
    extend(config.parent || elements.Container, config.construct);
  }

  return initializer;
}

function siblings() {
  return this.parent().children();
} // Get the curent position siblings


function position() {
  return this.parent().index(this);
} // Get the next element (will return null if there is none)


function next() {
  return this.siblings()[this.position() + 1];
} // Get the next element (will return null if there is none)


function prev() {
  return this.siblings()[this.position() - 1];
} // Send given element one step forward


function forward() {
  var i = this.position() + 1;
  var p = this.parent(); // move node one step forward

  p.removeElement(this).add(this, i); // make sure defs node is always at the top

  if (typeof p.isRoot === 'function' && p.isRoot()) {
    p.node.appendChild(p.defs().node);
  }

  return this;
} // Send given element one step backward


function backward() {
  var i = this.position();

  if (i > 0) {
    this.parent().removeElement(this).add(this, i - 1);
  }

  return this;
} // Send given element all the way to the front


function front() {
  var p = this.parent(); // Move node forward

  p.node.appendChild(this.node); // Make sure defs node is always at the top

  if (typeof p.isRoot === 'function' && p.isRoot()) {
    p.node.appendChild(p.defs().node);
  }

  return this;
} // Send given element all the way to the back


function back() {
  if (this.position() > 0) {
    this.parent().removeElement(this).add(this, 0);
  }

  return this;
} // Inserts a given element before the targeted element


function before(element) {
  element = makeInstance(element);
  element.remove();
  var i = this.position();
  this.parent().add(element, i);
  return this;
} // Inserts a given element after the targeted element


function after(element) {
  element = makeInstance(element);
  element.remove();
  var i = this.position();
  this.parent().add(element, i + 1);
  return this;
}

function insertBefore(element) {
  element = makeInstance(element);
  element.before(this);
  return this;
}

function insertAfter(element) {
  element = makeInstance(element);
  element.after(this);
  return this;
}

registerMethods('Dom', {
  siblings: siblings,
  position: position,
  next: next,
  prev: prev,
  forward: forward,
  backward: backward,
  front: front,
  back: back,
  before: before,
  after: after,
  insertBefore: insertBefore,
  insertAfter: insertAfter
});
var $filter = arrayIteration.filter; // `Array.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-array.prototype.filter
// with adding support of @@species

_export({
  target: 'Array',
  proto: true,
  forced: !arrayMethodHasSpeciesSupport('filter')
}, {
  filter: function filter(callbackfn
  /* , thisArg */
  ) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var sloppyArrayMethod = function sloppyArrayMethod(METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !method || !fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal
    method.call(null, argument || function () {
      throw 1;
    }, 1);
  });
};

var $indexOf = arrayIncludes.indexOf;
var nativeIndexOf = [].indexOf;
var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
var SLOPPY_METHOD = sloppyArrayMethod('indexOf'); // `Array.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-array.prototype.indexof

_export({
  target: 'Array',
  proto: true,
  forced: NEGATIVE_ZERO || SLOPPY_METHOD
}, {
  indexOf: function indexOf(searchElement
  /* , fromIndex = 0 */
  ) {
    return NEGATIVE_ZERO // convert -0 to +0
    ? nativeIndexOf.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var nativeJoin = [].join;
var ES3_STRINGS = indexedObject != Object;
var SLOPPY_METHOD$1 = sloppyArrayMethod('join', ','); // `Array.prototype.join` method
// https://tc39.github.io/ecma262/#sec-array.prototype.join

_export({
  target: 'Array',
  proto: true,
  forced: ES3_STRINGS || SLOPPY_METHOD$1
}, {
  join: function join(separator) {
    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
  }
});

var SPECIES$5 = wellKnownSymbol('species'); // `SpeciesConstructor` abstract operation
// https://tc39.github.io/ecma262/#sec-speciesconstructor

var speciesConstructor = function speciesConstructor(O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES$5]) == undefined ? defaultConstructor : aFunction$1(S);
};

var arrayPush = [].push;
var min$3 = Math.min;
var MAX_UINT32 = 0xFFFFFFFF; // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError

var SUPPORTS_Y = !fails(function () {
  return !RegExp(MAX_UINT32, 'y');
}); // @@split logic

fixRegexpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit;

  if ('abbc'.split(/(b)*/)[1] == 'c' || 'test'.split(/(?:)/, -1).length != 4 || 'ab'.split(/(?:ab)*/).length != 2 || '.'.split(/(.?)(.?)/).length != 4 || '.'.split(/()()/).length > 1 || ''.split(/.?/).length) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function internalSplit(separator, limit) {
      var string = String(requireObjectCoercible(this));
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (separator === undefined) return [string]; // If `separator` is not a regex, use native split

      if (!isRegexp(separator)) {
        return nativeSplit.call(string, separator, lim);
      }

      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
      var lastLastIndex = 0; // Make `global` and avoid `lastIndex` issues by working with a copy

      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;

      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy.lastIndex;

        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
          lastLength = match[0].length;
          lastLastIndex = lastIndex;
          if (output.length >= lim) break;
        }

        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
      }

      if (lastLastIndex === string.length) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));

      return output.length > lim ? output.slice(0, lim) : output;
    }; // Chakra, V8

  } else if ('0'.split(undefined, 0).length) {
    internalSplit = function internalSplit(separator, limit) {
      return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
    };
  } else internalSplit = nativeSplit;

  return [// `String.prototype.split` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.split
  function split(separator, limit) {
    var O = requireObjectCoercible(this);
    var splitter = separator == undefined ? undefined : separator[SPLIT];
    return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
  }, // `RegExp.prototype[@@split]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
  //
  // NOTE: This cannot be properly polyfilled in engines that don't support
  // the 'y' flag.
  function (regexp, limit) {
    var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var C = speciesConstructor(rx, RegExp);
    var unicodeMatching = rx.unicode;
    var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (SUPPORTS_Y ? 'y' : 'g'); // ^(? + rx + ) is needed, in combination with some S slicing, to
    // simulate the 'y' flag.

    var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
    var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
    if (lim === 0) return [];
    if (S.length === 0) return regexpExecAbstract(splitter, S) === null ? [S] : [];
    var p = 0;
    var q = 0;
    var A = [];

    while (q < S.length) {
      splitter.lastIndex = SUPPORTS_Y ? q : 0;
      var z = regexpExecAbstract(splitter, SUPPORTS_Y ? S : S.slice(q));
      var e;

      if (z === null || (e = min$3(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) {
        q = advanceStringIndex(S, q, unicodeMatching);
      } else {
        A.push(S.slice(p, q));
        if (A.length === lim) return A;

        for (var i = 1; i <= z.length - 1; i++) {
          A.push(z[i]);
          if (A.length === lim) return A;
        }

        q = p = e;
      }
    }

    A.push(S.slice(p));
    return A;
  }];
}, !SUPPORTS_Y); // Parse unit value

var numberAndUnit = /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i; // Parse hex value

var hex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i; // Parse rgb value

var rgb = /rgb\((\d+),(\d+),(\d+)\)/; // Parse reference id

var reference = /(#[a-z0-9\-_]+)/i; // splits a transformation chain

var transforms = /\)\s*,?\s*/; // Whitespace

var whitespace$1 = /\s/g; // Test hex value

var isHex = /^#[a-f0-9]{3,6}$/i; // Test rgb value

var isRgb = /^rgb\(/; // Test css declaration

var isCss = /[^:]+:[^;]+;?/; // Test for blank string

var isBlank = /^(\s+)?$/; // Test for numeric string

var isNumber = /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i; // Test for percent value

var isPercent = /^-?[\d.]+%$/; // Test for image url

var isImage = /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i; // split at whitespace and comma

var delimiter = /[\s,]+/; // The following regex are used to parse the d attribute of a path
// Matches all hyphens which are not after an exponent

var hyphen = /([^e])-/gi; // Replaces and tests for all path letters

var pathLetters = /[MLHVCSQTAZ]/gi; // yes we need this one, too

var isPathLetter = /[MLHVCSQTAZ]/i; // matches 0.154.23.45

var numbersWithDots = /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi; // matches .

var dots = /\./g;
var regex = {
  __proto__: null,
  numberAndUnit: numberAndUnit,
  hex: hex,
  rgb: rgb,
  reference: reference,
  transforms: transforms,
  whitespace: whitespace$1,
  isHex: isHex,
  isRgb: isRgb,
  isCss: isCss,
  isBlank: isBlank,
  isNumber: isNumber,
  isPercent: isPercent,
  isImage: isImage,
  delimiter: delimiter,
  hyphen: hyphen,
  pathLetters: pathLetters,
  isPathLetter: isPathLetter,
  numbersWithDots: numbersWithDots,
  dots: dots
};
exports.regex = regex;

function classes() {
  var attr = this.attr('class');
  return attr == null ? [] : attr.trim().split(delimiter);
} // Return true if class exists on the node, false otherwise


function hasClass(name) {
  return this.classes().indexOf(name) !== -1;
} // Add class to the node


function addClass(name) {
  if (!this.hasClass(name)) {
    var array = this.classes();
    array.push(name);
    this.attr('class', array.join(' '));
  }

  return this;
} // Remove class from the node


function removeClass(name) {
  if (this.hasClass(name)) {
    this.attr('class', this.classes().filter(function (c) {
      return c !== name;
    }).join(' '));
  }

  return this;
} // Toggle the presence of a class on the node


function toggleClass(name) {
  return this.hasClass(name) ? this.removeClass(name) : this.addClass(name);
}

registerMethods('Dom', {
  classes: classes,
  hasClass: hasClass,
  addClass: addClass,
  removeClass: removeClass,
  toggleClass: toggleClass
});
var $forEach$1 = arrayIteration.forEach; // `Array.prototype.forEach` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach

var arrayForEach = sloppyArrayMethod('forEach') ? function forEach(callbackfn
/* , thisArg */
) {
  return $forEach$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
} : [].forEach; // `Array.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach

_export({
  target: 'Array',
  proto: true,
  forced: [].forEach != arrayForEach
}, {
  forEach: arrayForEach
});

for (var COLLECTION_NAME$1 in domIterables) {
  var Collection$1 = global_1[COLLECTION_NAME$1];
  var CollectionPrototype$1 = Collection$1 && Collection$1.prototype; // some Chrome versions have non-configurable methods on DOMTokenList

  if (CollectionPrototype$1 && CollectionPrototype$1.forEach !== arrayForEach) try {
    createNonEnumerableProperty(CollectionPrototype$1, 'forEach', arrayForEach);
  } catch (error) {
    CollectionPrototype$1.forEach = arrayForEach;
  }
}

function css(style, val) {
  var ret = {};

  if (arguments.length === 0) {
    // get full style as object
    this.node.style.cssText.split(/\s*;\s*/).filter(function (el) {
      return !!el.length;
    }).forEach(function (el) {
      var t = el.split(/\s*:\s*/);
      ret[t[0]] = t[1];
    });
    return ret;
  }

  if (arguments.length < 2) {
    // get style properties in the array
    if (Array.isArray(style)) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = style[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var name = _step.value;
          var cased = camelCase(name);
          ret[cased] = this.node.style[cased];
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return ret;
    } // get style for property


    if (typeof style === 'string') {
      return this.node.style[camelCase(style)];
    } // set styles in object


    if (_typeof(style) === 'object') {
      for (var _name in style) {
        // set empty string if null/undefined/'' was given
        this.node.style[camelCase(_name)] = style[_name] == null || isBlank.test(style[_name]) ? '' : style[_name];
      }
    }
  } // set style for property


  if (arguments.length === 2) {
    this.node.style[camelCase(style)] = val == null || isBlank.test(val) ? '' : val;
  }

  return this;
} // Show element


function show() {
  return this.css('display', '');
} // Hide element


function hide() {
  return this.css('display', 'none');
} // Is element visible?


function visible() {
  return this.css('display') !== 'none';
}

registerMethods('Dom', {
  css: css,
  show: show,
  hide: hide,
  visible: visible
});

function data$1(a, v, r) {
  if (_typeof(a) === 'object') {
    for (v in a) {
      this.data(v, a[v]);
    }
  } else if (arguments.length < 2) {
    try {
      return JSON.parse(this.attr('data-' + a));
    } catch (e) {
      return this.attr('data-' + a);
    }
  } else {
    this.attr('data-' + a, v === null ? null : r === true || typeof v === 'string' || typeof v === 'number' ? v : JSON.stringify(v));
  }

  return this;
}

registerMethods('Dom', {
  data: data$1
});

function remember(k, v) {
  // remember every item in an object individually
  if (_typeof(arguments[0]) === 'object') {
    for (var key in k) {
      this.remember(key, k[key]);
    }
  } else if (arguments.length === 1) {
    // retrieve memory
    return this.memory()[k];
  } else {
    // store memory
    this.memory()[k] = v;
  }

  return this;
} // Erase a given memory


function forget() {
  if (arguments.length === 0) {
    this._memory = {};
  } else {
    for (var i = arguments.length - 1; i >= 0; i--) {
      delete this.memory()[arguments[i]];
    }
  }

  return this;
} // This triggers creation of a new hidden class which is not performant
// However, this function is not rarely used so it will not happen frequently
// Return local memory object


function memory() {
  return this._memory = this._memory || {};
}

registerMethods('Dom', {
  remember: remember,
  forget: forget,
  memory: memory
}); // `Array.prototype.{ reduce, reduceRight }` methods implementation

var createMethod$4 = function createMethod$4(IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aFunction$1(callbackfn);
    var O = toObject(that);
    var self = indexedObject(O);
    var length = toLength(O.length);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }

      index += i;

      if (IS_RIGHT ? index < 0 : length <= index) {
        throw TypeError('Reduce of empty array with no initial value');
      }
    }

    for (; IS_RIGHT ? index >= 0 : length > index; index += i) {
      if (index in self) {
        memo = callbackfn(memo, self[index], index, O);
      }
    }

    return memo;
  };
};

var arrayReduce = {
  // `Array.prototype.reduce` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
  left: createMethod$4(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
  right: createMethod$4(true)
};
var $reduce = arrayReduce.left; // `Array.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reduce

_export({
  target: 'Array',
  proto: true,
  forced: sloppyArrayMethod('reduce')
}, {
  reduce: function reduce(callbackfn
  /* , initialValue */
  ) {
    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var listenerId = 0;
var windowEvents = {};

function getEvents(instance) {
  var n = instance.getEventHolder(); // We dont want to save events in global space

  if (n === globals.window) n = windowEvents;
  if (!n.events) n.events = {};
  return n.events;
}

function getEventTarget(instance) {
  return instance.getEventTarget();
}

function clearEvents(instance) {
  var n = instance.getEventHolder();
  if (n.events) n.events = {};
} // Add event binder in the SVG namespace


function on(node, events, listener, binding, options) {
  var l = listener.bind(binding || node);
  var instance = makeInstance(node);
  var bag = getEvents(instance);
  var n = getEventTarget(instance); // events can be an array of events or a string of events

  events = Array.isArray(events) ? events : events.split(delimiter); // add id to listener

  if (!listener._svgjsListenerId) {
    listener._svgjsListenerId = ++listenerId;
  }

  events.forEach(function (event) {
    var ev = event.split('.')[0];
    var ns = event.split('.')[1] || '*'; // ensure valid object

    bag[ev] = bag[ev] || {};
    bag[ev][ns] = bag[ev][ns] || {}; // reference listener

    bag[ev][ns][listener._svgjsListenerId] = l; // add listener

    n.addEventListener(ev, l, options || false);
  });
} // Add event unbinder in the SVG namespace


function off(node, events, listener, options) {
  var instance = makeInstance(node);
  var bag = getEvents(instance);
  var n = getEventTarget(instance); // listener can be a function or a number

  if (typeof listener === 'function') {
    listener = listener._svgjsListenerId;
    if (!listener) return;
  } // events can be an array of events or a string or undefined


  events = Array.isArray(events) ? events : (events || '').split(delimiter);
  events.forEach(function (event) {
    var ev = event && event.split('.')[0];
    var ns = event && event.split('.')[1];
    var namespace, l;

    if (listener) {
      // remove listener reference
      if (bag[ev] && bag[ev][ns || '*']) {
        // removeListener
        n.removeEventListener(ev, bag[ev][ns || '*'][listener], options || false);
        delete bag[ev][ns || '*'][listener];
      }
    } else if (ev && ns) {
      // remove all listeners for a namespaced event
      if (bag[ev] && bag[ev][ns]) {
        for (l in bag[ev][ns]) {
          off(n, [ev, ns].join('.'), l);
        }

        delete bag[ev][ns];
      }
    } else if (ns) {
      // remove all listeners for a specific namespace
      for (event in bag) {
        for (namespace in bag[event]) {
          if (ns === namespace) {
            off(n, [event, ns].join('.'));
          }
        }
      }
    } else if (ev) {
      // remove all listeners for the event
      if (bag[ev]) {
        for (namespace in bag[ev]) {
          off(n, [ev, namespace].join('.'));
        }

        delete bag[ev];
      }
    } else {
      // remove all listeners on a given node
      for (event in bag) {
        off(n, event);
      }

      clearEvents(instance);
    }
  });
}

function dispatch(node, event, data) {
  var n = getEventTarget(node); // Dispatch event

  if (event instanceof globals.window.Event) {
    n.dispatchEvent(event);
  } else {
    event = new globals.window.CustomEvent(event, {
      detail: data,
      cancelable: true
    });
    n.dispatchEvent(event);
  }

  return event;
}

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded'; // We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679

var IS_CONCAT_SPREADABLE_SUPPORT = v8Version >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});
var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

var isConcatSpreadable = function isConcatSpreadable(O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT; // `Array.prototype.concat` method
// https://tc39.github.io/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species

_export({
  target: 'Array',
  proto: true,
  forced: FORCED
}, {
  concat: function concat(arg) {
    // eslint-disable-line no-unused-vars
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;

    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];

      if (isConcatSpreadable(E)) {
        len = toLength(E.length);
        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);

        for (k = 0; k < len; k++, n++) {
          if (k in E) createProperty(A, n, E[k]);
        }
      } else {
        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty(A, n++, E);
      }
    }

    A.length = n;
    return A;
  }
});

var $map = arrayIteration.map; // `Array.prototype.map` method
// https://tc39.github.io/ecma262/#sec-array.prototype.map
// with adding support of @@species

_export({
  target: 'Array',
  proto: true,
  forced: !arrayMethodHasSpeciesSupport('map')
}, {
  map: function map(callbackfn
  /* , thisArg */
  ) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

var DatePrototype = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var nativeDateToString = DatePrototype[TO_STRING];
var getTime = DatePrototype.getTime; // `Date.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-date.prototype.tostring

if (new Date(NaN) + '' != INVALID_DATE) {
  redefine(DatePrototype, TO_STRING, function toString() {
    var value = getTime.call(this); // eslint-disable-next-line no-self-compare

    return value === value ? nativeDateToString.call(this) : INVALID_DATE;
  });
}

var trim = stringTrim.trim;
var nativeParseInt = global_1.parseInt;
var hex$1 = /^[+-]?0[Xx]/;
var FORCED$1 = nativeParseInt(whitespaces + '08') !== 8 || nativeParseInt(whitespaces + '0x16') !== 22; // `parseInt` method
// https://tc39.github.io/ecma262/#sec-parseint-string-radix

var _parseInt = FORCED$1 ? function parseInt(string, radix) {
  var S = trim(String(string));
  return nativeParseInt(S, radix >>> 0 || (hex$1.test(S) ? 16 : 10));
} : nativeParseInt; // `parseInt` method
// https://tc39.github.io/ecma262/#sec-parseint-string-radix


_export({
  global: true,
  forced: parseInt != _parseInt
}, {
  parseInt: _parseInt
});

var TO_STRING$1 = 'toString';
var RegExpPrototype = RegExp.prototype;
var nativeToString = RegExpPrototype[TO_STRING$1];
var NOT_GENERIC = fails(function () {
  return nativeToString.call({
    source: 'a',
    flags: 'b'
  }) != '/a/b';
}); // FF44- RegExp#toString has a wrong name

var INCORRECT_NAME = nativeToString.name != TO_STRING$1; // `RegExp.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring

if (NOT_GENERIC || INCORRECT_NAME) {
  redefine(RegExp.prototype, TO_STRING$1, function toString() {
    var R = anObject(this);
    var p = String(R.source);
    var rf = R.flags;
    var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? regexpFlags.call(R) : rf);
    return '/' + p + '/' + f;
  }, {
    unsafe: true
  });
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function sixDigitHex(hex) {
  return hex.length === 4 ? ['#', hex.substring(1, 2), hex.substring(1, 2), hex.substring(2, 3), hex.substring(2, 3), hex.substring(3, 4), hex.substring(3, 4)].join('') : hex;
}

function componentHex(component) {
  var integer = Math.round(component);
  var bounded = Math.max(0, Math.min(255, integer));
  var hex = bounded.toString(16);
  return hex.length === 1 ? '0' + hex : hex;
}

function is(object, space) {
  for (var i = space.length; i--;) {
    if (object[space[i]] == null) {
      return false;
    }
  }

  return true;
}

function getParameters(a, b) {
  var params = is(a, 'rgb') ? {
    _a: a.r,
    _b: a.g,
    _c: a.b,
    space: 'rgb'
  } : is(a, 'xyz') ? {
    _a: a.x,
    _b: a.y,
    _c: a.z,
    _d: 0,
    space: 'xyz'
  } : is(a, 'hsl') ? {
    _a: a.h,
    _b: a.s,
    _c: a.l,
    _d: 0,
    space: 'hsl'
  } : is(a, 'lab') ? {
    _a: a.l,
    _b: a.a,
    _c: a.b,
    _d: 0,
    space: 'lab'
  } : is(a, 'lch') ? {
    _a: a.l,
    _b: a.c,
    _c: a.h,
    _d: 0,
    space: 'lch'
  } : is(a, 'cmyk') ? {
    _a: a.c,
    _b: a.m,
    _c: a.y,
    _d: a.k,
    space: 'cmyk'
  } : {
    _a: 0,
    _b: 0,
    _c: 0,
    space: 'rgb'
  };
  params.space = b || params.space;
  return params;
}

function cieSpace(space) {
  if (space === 'lab' || space === 'xyz' || space === 'lch') {
    return true;
  } else {
    return false;
  }
}

function hueToRgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}

var Color = /*#__PURE__*/function () {
  function Color() {
    _classCallCheck(this, Color);

    this.init.apply(this, arguments);
  }

  _createClass(Color, [{
    key: "init",
    value: function init() {
      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var space = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'rgb'; // This catches the case when a falsy value is passed like ''

      a = !a ? 0 : a; // Reset all values in case the init function is rerun with new color space

      if (this.space) {
        for (var component in this.space) {
          delete this[this.space[component]];
        }
      }

      if (typeof a === 'number') {
        // Allow for the case that we don't need d...
        space = typeof d === 'string' ? d : space;
        d = typeof d === 'string' ? 0 : d; // Assign the values straight to the color

        Object.assign(this, {
          _a: a,
          _b: b,
          _c: c,
          _d: d,
          space: space
        }); // If the user gave us an array, make the color from it
      } else if (a instanceof Array) {
        this.space = b || (typeof a[3] === 'string' ? a[3] : a[4]) || 'rgb';
        Object.assign(this, {
          _a: a[0],
          _b: a[1],
          _c: a[2],
          _d: a[3] || 0
        });
      } else if (a instanceof Object) {
        // Set the object up and assign its values directly
        var values = getParameters(a, b);
        Object.assign(this, values);
      } else if (typeof a === 'string') {
        if (isRgb.test(a)) {
          var noWhitespace = a.replace(whitespace$1, '');

          var _rgb$exec$slice$map = rgb.exec(noWhitespace).slice(1, 4).map(function (v) {
            return parseInt(v);
          }),
              _rgb$exec$slice$map2 = _slicedToArray(_rgb$exec$slice$map, 3),
              _a2 = _rgb$exec$slice$map2[0],
              _b2 = _rgb$exec$slice$map2[1],
              _c2 = _rgb$exec$slice$map2[2];

          Object.assign(this, {
            _a: _a2,
            _b: _b2,
            _c: _c2,
            _d: 0,
            space: 'rgb'
          });
        } else if (isHex.test(a)) {
          var hexParse = function hexParse(v) {
            return parseInt(v, 16);
          };

          var _hex$exec$map = hex.exec(sixDigitHex(a)).map(hexParse),
              _hex$exec$map2 = _slicedToArray(_hex$exec$map, 4),
              _a3 = _hex$exec$map2[1],
              _b3 = _hex$exec$map2[2],
              _c3 = _hex$exec$map2[3];

          Object.assign(this, {
            _a: _a3,
            _b: _b3,
            _c: _c3,
            _d: 0,
            space: 'rgb'
          });
        } else throw Error('Unsupported string format, can\'t construct Color');
      } // Now add the components as a convenience


      var _a = this._a,
          _b = this._b,
          _c = this._c,
          _d = this._d;
      var components = this.space === 'rgb' ? {
        r: _a,
        g: _b,
        b: _c
      } : this.space === 'xyz' ? {
        x: _a,
        y: _b,
        z: _c
      } : this.space === 'hsl' ? {
        h: _a,
        s: _b,
        l: _c
      } : this.space === 'lab' ? {
        l: _a,
        a: _b,
        b: _c
      } : this.space === 'lch' ? {
        l: _a,
        c: _b,
        h: _c
      } : this.space === 'cmyk' ? {
        c: _a,
        m: _b,
        y: _c,
        k: _d
      } : {};
      Object.assign(this, components);
    }
    /*
    Conversion Methods
    */

  }, {
    key: "rgb",
    value: function rgb() {
      if (this.space === 'rgb') {
        return this;
      } else if (cieSpace(this.space)) {
        // Convert to the xyz color space
        var x = this.x,
            y = this.y,
            z = this.z;

        if (this.space === 'lab' || this.space === 'lch') {
          // Get the values in the lab space
          var l = this.l,
              a = this.a,
              _b4 = this.b;

          if (this.space === 'lch') {
            var c = this.c,
                h = this.h;
            var dToR = Math.PI / 180;
            a = c * Math.cos(dToR * h);
            _b4 = c * Math.sin(dToR * h);
          } // Undo the nonlinear function


          var yL = (l + 16) / 116;
          var xL = a / 500 + yL;
          var zL = yL - _b4 / 200; // Get the xyz values

          var ct = 16 / 116;
          var mx = 0.008856;
          var nm = 7.787;
          x = 0.95047 * (Math.pow(xL, 3) > mx ? Math.pow(xL, 3) : (xL - ct) / nm);
          y = 1.00000 * (Math.pow(yL, 3) > mx ? Math.pow(yL, 3) : (yL - ct) / nm);
          z = 1.08883 * (Math.pow(zL, 3) > mx ? Math.pow(zL, 3) : (zL - ct) / nm);
        } // Convert xyz to unbounded rgb values


        var rU = x * 3.2406 + y * -1.5372 + z * -0.4986;
        var gU = x * -0.9689 + y * 1.8758 + z * 0.0415;
        var bU = x * 0.0557 + y * -0.2040 + z * 1.0570; // Convert the values to true rgb values

        var pow = Math.pow;
        var bd = 0.0031308;
        var r = rU > bd ? 1.055 * pow(rU, 1 / 2.4) - 0.055 : 12.92 * rU;
        var g = gU > bd ? 1.055 * pow(gU, 1 / 2.4) - 0.055 : 12.92 * gU;
        var b = bU > bd ? 1.055 * pow(bU, 1 / 2.4) - 0.055 : 12.92 * bU; // Make and return the color

        var color = new Color(255 * r, 255 * g, 255 * b);
        return color;
      } else if (this.space === 'hsl') {
        // https://bgrins.github.io/TinyColor/docs/tinycolor.html
        // Get the current hsl values
        var _h = this.h,
            s = this.s,
            _l = this.l;
        _h /= 360;
        s /= 100;
        _l /= 100; // If we are grey, then just make the color directly

        if (s === 0) {
          _l *= 255;

          var _color2 = new Color(_l, _l, _l);

          return _color2;
        } // TODO I have no idea what this does :D If you figure it out, tell me!


        var q = _l < 0.5 ? _l * (1 + s) : _l + s - _l * s;
        var p = 2 * _l - q; // Get the rgb values

        var _r = 255 * hueToRgb(p, q, _h + 1 / 3);

        var _g = 255 * hueToRgb(p, q, _h);

        var _b5 = 255 * hueToRgb(p, q, _h - 1 / 3); // Make a new color


        var _color = new Color(_r, _g, _b5);

        return _color;
      } else if (this.space === 'cmyk') {
        // https://gist.github.com/felipesabino/5066336
        // Get the normalised cmyk values
        var _c4 = this.c,
            m = this.m,
            _y = this.y,
            k = this.k; // Get the rgb values

        var _r2 = 255 * (1 - Math.min(1, _c4 * (1 - k) + k));

        var _g2 = 255 * (1 - Math.min(1, m * (1 - k) + k));

        var _b6 = 255 * (1 - Math.min(1, _y * (1 - k) + k)); // Form the color and return it


        var _color3 = new Color(_r2, _g2, _b6);

        return _color3;
      } else {
        return this;
      }
    }
  }, {
    key: "lab",
    value: function lab() {
      // Get the xyz color
      var _this$xyz = this.xyz(),
          x = _this$xyz.x,
          y = _this$xyz.y,
          z = _this$xyz.z; // Get the lab components


      var l = 116 * y - 16;
      var a = 500 * (x - y);
      var b = 200 * (y - z); // Construct and return a new color

      var color = new Color(l, a, b, 'lab');
      return color;
    }
  }, {
    key: "xyz",
    value: function xyz() {
      // Normalise the red, green and blue values
      var _this$rgb = this.rgb(),
          r255 = _this$rgb._a,
          g255 = _this$rgb._b,
          b255 = _this$rgb._c;

      var _map = [r255, g255, b255].map(function (v) {
        return v / 255;
      }),
          _map2 = _slicedToArray(_map, 3),
          r = _map2[0],
          g = _map2[1],
          b = _map2[2]; // Convert to the lab rgb space


      var rL = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      var gL = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      var bL = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92; // Convert to the xyz color space without bounding the values

      var xU = (rL * 0.4124 + gL * 0.3576 + bL * 0.1805) / 0.95047;
      var yU = (rL * 0.2126 + gL * 0.7152 + bL * 0.0722) / 1.00000;
      var zU = (rL * 0.0193 + gL * 0.1192 + bL * 0.9505) / 1.08883; // Get the proper xyz values by applying the bounding

      var x = xU > 0.008856 ? Math.pow(xU, 1 / 3) : 7.787 * xU + 16 / 116;
      var y = yU > 0.008856 ? Math.pow(yU, 1 / 3) : 7.787 * yU + 16 / 116;
      var z = zU > 0.008856 ? Math.pow(zU, 1 / 3) : 7.787 * zU + 16 / 116; // Make and return the color

      var color = new Color(x, y, z, 'xyz');
      return color;
    }
  }, {
    key: "lch",
    value: function lch() {
      // Get the lab color directly
      var _this$lab = this.lab(),
          l = _this$lab.l,
          a = _this$lab.a,
          b = _this$lab.b; // Get the chromaticity and the hue using polar coordinates


      var c = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
      var h = 180 * Math.atan2(b, a) / Math.PI;

      if (h < 0) {
        h *= -1;
        h = 360 - h;
      } // Make a new color and return it


      var color = new Color(l, c, h, 'lch');
      return color;
    }
  }, {
    key: "hsl",
    value: function hsl() {
      // Get the rgb values
      var _this$rgb2 = this.rgb(),
          _a = _this$rgb2._a,
          _b = _this$rgb2._b,
          _c = _this$rgb2._c;

      var _map3 = [_a, _b, _c].map(function (v) {
        return v / 255;
      }),
          _map4 = _slicedToArray(_map3, 3),
          r = _map4[0],
          g = _map4[1],
          b = _map4[2]; // Find the maximum and minimum values to get the lightness


      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var l = (max + min) / 2; // If the r, g, v values are identical then we are grey

      var isGrey = max === min; // Calculate the hue and saturation

      var delta = max - min;
      var s = isGrey ? 0 : l > 0.5 ? delta / (2 - max - min) : delta / (max + min);
      var h = isGrey ? 0 : max === r ? ((g - b) / delta + (g < b ? 6 : 0)) / 6 : max === g ? ((b - r) / delta + 2) / 6 : max === b ? ((r - g) / delta + 4) / 6 : 0; // Construct and return the new color

      var color = new Color(360 * h, 100 * s, 100 * l, 'hsl');
      return color;
    }
  }, {
    key: "cmyk",
    value: function cmyk() {
      // Get the rgb values for the current color
      var _this$rgb3 = this.rgb(),
          _a = _this$rgb3._a,
          _b = _this$rgb3._b,
          _c = _this$rgb3._c;

      var _map5 = [_a, _b, _c].map(function (v) {
        return v / 255;
      }),
          _map6 = _slicedToArray(_map5, 3),
          r = _map6[0],
          g = _map6[1],
          b = _map6[2]; // Get the cmyk values in an unbounded format


      var k = Math.min(1 - r, 1 - g, 1 - b);

      if (k === 1) {
        // Catch the black case
        return new Color(0, 0, 0, 1, 'cmyk');
      }

      var c = (1 - r - k) / (1 - k);
      var m = (1 - g - k) / (1 - k);
      var y = (1 - b - k) / (1 - k); // Construct the new color

      var color = new Color(c, m, y, k, 'cmyk');
      return color;
    }
    /*
    Input and Output methods
    */

  }, {
    key: "_clamped",
    value: function _clamped() {
      var _this$rgb4 = this.rgb(),
          _a = _this$rgb4._a,
          _b = _this$rgb4._b,
          _c = _this$rgb4._c;

      var max = Math.max,
          min = Math.min,
          round = Math.round;

      var format = function format(v) {
        return max(0, min(round(v), 255));
      };

      return [_a, _b, _c].map(format);
    }
  }, {
    key: "toHex",
    value: function toHex() {
      var _this$_clamped$map = this._clamped().map(componentHex),
          _this$_clamped$map2 = _slicedToArray(_this$_clamped$map, 3),
          r = _this$_clamped$map2[0],
          g = _this$_clamped$map2[1],
          b = _this$_clamped$map2[2];

      return "#".concat(r).concat(g).concat(b);
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.toHex();
    }
  }, {
    key: "toRgb",
    value: function toRgb() {
      var _this$_clamped = this._clamped(),
          _this$_clamped2 = _slicedToArray(_this$_clamped, 3),
          rV = _this$_clamped2[0],
          gV = _this$_clamped2[1],
          bV = _this$_clamped2[2];

      var string = "rgb(".concat(rV, ",").concat(gV, ",").concat(bV, ")");
      return string;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var _a = this._a,
          _b = this._b,
          _c = this._c,
          _d = this._d,
          space = this.space;
      return [_a, _b, _c, _d, space];
    }
    /*
    Generating random colors
    */

  }], [{
    key: "random",
    value: function random() {
      var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'vibrant';
      var t = arguments.length > 1 ? arguments[1] : undefined; // Get the math modules

      var random = Math.random,
          round = Math.round,
          sin = Math.sin,
          pi = Math.PI; // Run the correct generator

      if (mode === 'vibrant') {
        var l = (81 - 57) * random() + 57;
        var c = (83 - 45) * random() + 45;
        var h = 360 * random();
        var color = new Color(l, c, h, 'lch');
        return color;
      } else if (mode === 'sine') {
        t = t == null ? random() : t;
        var r = round(80 * sin(2 * pi * t / 0.5 + 0.01) + 150);
        var g = round(50 * sin(2 * pi * t / 0.5 + 4.6) + 200);
        var b = round(100 * sin(2 * pi * t / 0.5 + 2.3) + 150);

        var _color4 = new Color(r, g, b);

        return _color4;
      } else if (mode === 'pastel') {
        var _l2 = (94 - 86) * random() + 86;

        var _c5 = (26 - 9) * random() + 9;

        var _h2 = 360 * random();

        var _color5 = new Color(_l2, _c5, _h2, 'lch');

        return _color5;
      } else if (mode === 'dark') {
        var _l3 = 10 + 10 * random();

        var _c6 = (125 - 75) * random() + 86;

        var _h3 = 360 * random();

        var _color6 = new Color(_l3, _c6, _h3, 'lch');

        return _color6;
      } else if (mode === 'rgb') {
        var _r3 = 255 * random();

        var _g3 = 255 * random();

        var _b7 = 255 * random();

        var _color7 = new Color(_r3, _g3, _b7);

        return _color7;
      } else if (mode === 'lab') {
        var _l4 = 100 * random();

        var a = 256 * random() - 128;

        var _b8 = 256 * random() - 128;

        var _color8 = new Color(_l4, a, _b8, 'lab');

        return _color8;
      } else if (mode === 'grey') {
        var grey = 255 * random();

        var _color9 = new Color(grey, grey, grey);

        return _color9;
      }
    }
    /*
    Constructing colors
    */
    // Test if given value is a color string

  }, {
    key: "test",
    value: function test(color) {
      return typeof color === 'string' && (isHex.test(color) || isRgb.test(color));
    } // Test if given value is an rgb object

  }, {
    key: "isRgb",
    value: function isRgb(color) {
      return color && typeof color.r === 'number' && typeof color.g === 'number' && typeof color.b === 'number';
    } // Test if given value is a color

  }, {
    key: "isColor",
    value: function isColor(color) {
      return color && (color instanceof Color || this.isRgb(color) || this.test(color));
    }
  }]);

  return Color;
}();

exports.Color = Color;
var FAILS_ON_PRIMITIVES$1 = fails(function () {
  objectKeys(1);
}); // `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys

_export({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES$1
}, {
  keys: function keys(it) {
    return objectKeys(toObject(it));
  }
}); // @@match logic


fixRegexpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
  return [// `String.prototype.match` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.match
  function match(regexp) {
    var O = requireObjectCoercible(this);
    var matcher = regexp == undefined ? undefined : regexp[MATCH];
    return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, // `RegExp.prototype[@@match]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
  function (regexp) {
    var res = maybeCallNative(nativeMatch, regexp, this);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    if (!rx.global) return regexpExecAbstract(rx, S);
    var fullUnicode = rx.unicode;
    rx.lastIndex = 0;
    var A = [];
    var n = 0;
    var result;

    while ((result = regexpExecAbstract(rx, S)) !== null) {
      var matchStr = String(result[0]);
      A[n] = matchStr;
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      n++;
    }

    return n === 0 ? null : A;
  }];
});

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

var getOwnPropertyNames = objectGetOwnPropertyNames.f;
var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
var defineProperty$5 = objectDefineProperty.f;
var trim$1 = stringTrim.trim;
var NUMBER = 'Number';
var NativeNumber = global_1[NUMBER];
var NumberPrototype = NativeNumber.prototype; // Opera ~12 has broken Object#toString

var BROKEN_CLASSOF = classofRaw(objectCreate(NumberPrototype)) == NUMBER; // `ToNumber` abstract operation
// https://tc39.github.io/ecma262/#sec-tonumber

var toNumber = function toNumber(argument) {
  var it = toPrimitive(argument, false);
  var first, third, radix, maxCode, digits, length, index, code;

  if (typeof it == 'string' && it.length > 2) {
    it = trim$1(it);
    first = it.charCodeAt(0);

    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66:
        case 98:
          radix = 2;
          maxCode = 49;
          break;
        // fast equal of /^0b[01]+$/i

        case 79:
        case 111:
          radix = 8;
          maxCode = 55;
          break;
        // fast equal of /^0o[0-7]+$/i

        default:
          return +it;
      }

      digits = it.slice(2);
      length = digits.length;

      for (index = 0; index < length; index++) {
        code = digits.charCodeAt(index); // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols

        if (code < 48 || code > maxCode) return NaN;
      }

      return parseInt(digits, radix);
    }
  }

  return +it;
}; // `Number` constructor
// https://tc39.github.io/ecma262/#sec-number-constructor


if (isForced_1(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
  var NumberWrapper = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var dummy = this;
    return dummy instanceof NumberWrapper // check on 1..constructor(foo) case
    && (BROKEN_CLASSOF ? fails(function () {
      NumberPrototype.valueOf.call(dummy);
    }) : classofRaw(dummy) != NUMBER) ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
  };

  for (var keys$1 = descriptors ? getOwnPropertyNames(NativeNumber) : ( // ES3:
  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES2015 (in case, if modules with ES2015 Number statics required before):
  'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j = 0, key; keys$1.length > j; j++) {
    if (has(NativeNumber, key = keys$1[j]) && !has(NumberWrapper, key)) {
      defineProperty$5(NumberWrapper, key, getOwnPropertyDescriptor$2(NativeNumber, key));
    }
  }

  NumberWrapper.prototype = NumberPrototype;
  NumberPrototype.constructor = NumberWrapper;
  redefine(global_1, NUMBER, NumberWrapper);
}

var trim$2 = stringTrim.trim;
var nativeParseFloat = global_1.parseFloat;
var FORCED$2 = 1 / nativeParseFloat(whitespaces + '-0') !== -Infinity; // `parseFloat` method
// https://tc39.github.io/ecma262/#sec-parsefloat-string

var _parseFloat = FORCED$2 ? function parseFloat(string) {
  var trimmedString = trim$2(String(string));
  var result = nativeParseFloat(trimmedString);
  return result === 0 && trimmedString.charAt(0) == '-' ? -0 : result;
} : nativeParseFloat; // `parseFloat` method
// https://tc39.github.io/ecma262/#sec-parsefloat-string


_export({
  global: true,
  forced: parseFloat != _parseFloat
}, {
  parseFloat: _parseFloat
});

var Point = /*#__PURE__*/function () {
  // Initialize
  function Point() {
    _classCallCheck(this, Point);

    this.init.apply(this, arguments);
  }

  _createClass(Point, [{
    key: "init",
    value: function init(x, y) {
      var base = {
        x: 0,
        y: 0
      }; // ensure source as object

      var source = Array.isArray(x) ? {
        x: x[0],
        y: x[1]
      } : _typeof(x) === 'object' ? {
        x: x.x,
        y: x.y
      } : {
        x: x,
        y: y
      }; // merge source

      this.x = source.x == null ? base.x : source.x;
      this.y = source.y == null ? base.y : source.y;
      return this;
    } // Clone point

  }, {
    key: "clone",
    value: function clone() {
      return new Point(this);
    }
  }, {
    key: "transform",
    value: function transform(m) {
      return this.clone().transformO(m);
    } // Transform point with matrix

  }, {
    key: "transformO",
    value: function transformO(m) {
      if (!Matrix.isMatrixLike(m)) {
        m = new Matrix(m);
      }

      var x = this.x,
          y = this.y; // Perform the matrix multiplication

      this.x = m.a * x + m.c * y + m.e;
      this.y = m.b * x + m.d * y + m.f;
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      return [this.x, this.y];
    }
  }]);

  return Point;
}();

exports.Point = Point;

function point(x, y) {
  return new Point(x, y).transform(this.screenCTM().inverse());
}

function closeEnough(a, b, threshold) {
  return Math.abs(b - a) < (threshold || 1e-6);
}

var Matrix = /*#__PURE__*/function () {
  function Matrix() {
    _classCallCheck(this, Matrix);

    this.init.apply(this, arguments);
  } // Initialize


  _createClass(Matrix, [{
    key: "init",
    value: function init(source) {
      var base = Matrix.fromArray([1, 0, 0, 1, 0, 0]); // ensure source as object

      source = source instanceof Element ? source.matrixify() : typeof source === 'string' ? Matrix.fromArray(source.split(delimiter).map(parseFloat)) : Array.isArray(source) ? Matrix.fromArray(source) : _typeof(source) === 'object' && Matrix.isMatrixLike(source) ? source : _typeof(source) === 'object' ? new Matrix().transform(source) : arguments.length === 6 ? Matrix.fromArray([].slice.call(arguments)) : base; // Merge the source matrix with the base matrix

      this.a = source.a != null ? source.a : base.a;
      this.b = source.b != null ? source.b : base.b;
      this.c = source.c != null ? source.c : base.c;
      this.d = source.d != null ? source.d : base.d;
      this.e = source.e != null ? source.e : base.e;
      this.f = source.f != null ? source.f : base.f;
      return this;
    } // Clones this matrix

  }, {
    key: "clone",
    value: function clone() {
      return new Matrix(this);
    } // Transform a matrix into another matrix by manipulating the space

  }, {
    key: "transform",
    value: function transform(o) {
      // Check if o is a matrix and then left multiply it directly
      if (Matrix.isMatrixLike(o)) {
        var matrix = new Matrix(o);
        return matrix.multiplyO(this);
      } // Get the proposed transformations and the current transformations


      var t = Matrix.formatTransforms(o);
      var current = this;

      var _transform = new Point(t.ox, t.oy).transform(current),
          ox = _transform.x,
          oy = _transform.y; // Construct the resulting matrix


      var transformer = new Matrix().translateO(t.rx, t.ry).lmultiplyO(current).translateO(-ox, -oy).scaleO(t.scaleX, t.scaleY).skewO(t.skewX, t.skewY).shearO(t.shear).rotateO(t.theta).translateO(ox, oy); // If we want the origin at a particular place, we force it there

      if (isFinite(t.px) || isFinite(t.py)) {
        var origin = new Point(ox, oy).transform(transformer); // TODO: Replace t.px with isFinite(t.px)

        var dx = t.px ? t.px - origin.x : 0;
        var dy = t.py ? t.py - origin.y : 0;
        transformer.translateO(dx, dy);
      } // Translate now after positioning


      transformer.translateO(t.tx, t.ty);
      return transformer;
    } // Applies a matrix defined by its affine parameters

  }, {
    key: "compose",
    value: function compose(o) {
      if (o.origin) {
        o.originX = o.origin[0];
        o.originY = o.origin[1];
      } // Get the parameters


      var ox = o.originX || 0;
      var oy = o.originY || 0;
      var sx = o.scaleX || 1;
      var sy = o.scaleY || 1;
      var lam = o.shear || 0;
      var theta = o.rotate || 0;
      var tx = o.translateX || 0;
      var ty = o.translateY || 0; // Apply the standard matrix

      var result = new Matrix().translateO(-ox, -oy).scaleO(sx, sy).shearO(lam).rotateO(theta).translateO(tx, ty).lmultiplyO(this).translateO(ox, oy);
      return result;
    } // Decomposes this matrix into its affine parameters

  }, {
    key: "decompose",
    value: function decompose() {
      var cx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var cy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; // Get the parameters from the matrix

      var a = this.a;
      var b = this.b;
      var c = this.c;
      var d = this.d;
      var e = this.e;
      var f = this.f; // Figure out if the winding direction is clockwise or counterclockwise

      var determinant = a * d - b * c;
      var ccw = determinant > 0 ? 1 : -1; // Since we only shear in x, we can use the x basis to get the x scale
      // and the rotation of the resulting matrix

      var sx = ccw * Math.sqrt(a * a + b * b);
      var thetaRad = Math.atan2(ccw * b, ccw * a);
      var theta = 180 / Math.PI * thetaRad;
      var ct = Math.cos(thetaRad);
      var st = Math.sin(thetaRad); // We can then solve the y basis vector simultaneously to get the other
      // two affine parameters directly from these parameters

      var lam = (a * c + b * d) / determinant;
      var sy = c * sx / (lam * a - b) || d * sx / (lam * b + a); // Use the translations

      var tx = e - cx + cx * ct * sx + cy * (lam * ct * sx - st * sy);
      var ty = f - cy + cx * st * sx + cy * (lam * st * sx + ct * sy); // Construct the decomposition and return it

      return {
        // Return the affine parameters
        scaleX: sx,
        scaleY: sy,
        shear: lam,
        rotate: theta,
        translateX: tx,
        translateY: ty,
        originX: cx,
        originY: cy,
        // Return the matrix parameters
        a: this.a,
        b: this.b,
        c: this.c,
        d: this.d,
        e: this.e,
        f: this.f
      };
    } // Left multiplies by the given matrix

  }, {
    key: "multiply",
    value: function multiply(matrix) {
      return this.clone().multiplyO(matrix);
    }
  }, {
    key: "multiplyO",
    value: function multiplyO(matrix) {
      // Get the matrices
      var l = this;
      var r = matrix instanceof Matrix ? matrix : new Matrix(matrix);
      return Matrix.matrixMultiply(l, r, this);
    }
  }, {
    key: "lmultiply",
    value: function lmultiply(matrix) {
      return this.clone().lmultiplyO(matrix);
    }
  }, {
    key: "lmultiplyO",
    value: function lmultiplyO(matrix) {
      var r = this;
      var l = matrix instanceof Matrix ? matrix : new Matrix(matrix);
      return Matrix.matrixMultiply(l, r, this);
    } // Inverses matrix

  }, {
    key: "inverseO",
    value: function inverseO() {
      // Get the current parameters out of the matrix
      var a = this.a;
      var b = this.b;
      var c = this.c;
      var d = this.d;
      var e = this.e;
      var f = this.f; // Invert the 2x2 matrix in the top left

      var det = a * d - b * c;
      if (!det) throw new Error('Cannot invert ' + this); // Calculate the top 2x2 matrix

      var na = d / det;
      var nb = -b / det;
      var nc = -c / det;
      var nd = a / det; // Apply the inverted matrix to the top right

      var ne = -(na * e + nc * f);
      var nf = -(nb * e + nd * f); // Construct the inverted matrix

      this.a = na;
      this.b = nb;
      this.c = nc;
      this.d = nd;
      this.e = ne;
      this.f = nf;
      return this;
    }
  }, {
    key: "inverse",
    value: function inverse() {
      return this.clone().inverseO();
    } // Translate matrix

  }, {
    key: "translate",
    value: function translate(x, y) {
      return this.clone().translateO(x, y);
    }
  }, {
    key: "translateO",
    value: function translateO(x, y) {
      this.e += x || 0;
      this.f += y || 0;
      return this;
    } // Scale matrix

  }, {
    key: "scale",
    value: function scale(x, y, cx, cy) {
      var _this$clone;

      return (_this$clone = this.clone()).scaleO.apply(_this$clone, arguments);
    }
  }, {
    key: "scaleO",
    value: function scaleO(x) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;
      var cx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var cy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0; // Support uniform scaling

      if (arguments.length === 3) {
        cy = cx;
        cx = y;
        y = x;
      }

      var a = this.a,
          b = this.b,
          c = this.c,
          d = this.d,
          e = this.e,
          f = this.f;
      this.a = a * x;
      this.b = b * y;
      this.c = c * x;
      this.d = d * y;
      this.e = e * x - cx * x + cx;
      this.f = f * y - cy * y + cy;
      return this;
    } // Rotate matrix

  }, {
    key: "rotate",
    value: function rotate(r, cx, cy) {
      return this.clone().rotateO(r, cx, cy);
    }
  }, {
    key: "rotateO",
    value: function rotateO(r) {
      var cx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var cy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0; // Convert degrees to radians

      r = radians(r);
      var cos = Math.cos(r);
      var sin = Math.sin(r);
      var a = this.a,
          b = this.b,
          c = this.c,
          d = this.d,
          e = this.e,
          f = this.f;
      this.a = a * cos - b * sin;
      this.b = b * cos + a * sin;
      this.c = c * cos - d * sin;
      this.d = d * cos + c * sin;
      this.e = e * cos - f * sin + cy * sin - cx * cos + cx;
      this.f = f * cos + e * sin - cx * sin - cy * cos + cy;
      return this;
    } // Flip matrix on x or y, at a given offset

  }, {
    key: "flip",
    value: function flip(axis, around) {
      return this.clone().flipO(axis, around);
    }
  }, {
    key: "flipO",
    value: function flipO(axis, around) {
      return axis === 'x' ? this.scaleO(-1, 1, around, 0) : axis === 'y' ? this.scaleO(1, -1, 0, around) : this.scaleO(-1, -1, axis, around || axis); // Define an x, y flip point
    } // Shear matrix

  }, {
    key: "shear",
    value: function shear(a, cx, cy) {
      return this.clone().shearO(a, cx, cy);
    }
  }, {
    key: "shearO",
    value: function shearO(lx) {
      var cy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var a = this.a,
          b = this.b,
          c = this.c,
          d = this.d,
          e = this.e,
          f = this.f;
      this.a = a + b * lx;
      this.c = c + d * lx;
      this.e = e + f * lx - cy * lx;
      return this;
    } // Skew Matrix

  }, {
    key: "skew",
    value: function skew(x, y, cx, cy) {
      var _this$clone2;

      return (_this$clone2 = this.clone()).skewO.apply(_this$clone2, arguments);
    }
  }, {
    key: "skewO",
    value: function skewO(x) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;
      var cx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var cy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0; // support uniformal skew

      if (arguments.length === 3) {
        cy = cx;
        cx = y;
        y = x;
      } // Convert degrees to radians


      x = radians(x);
      y = radians(y);
      var lx = Math.tan(x);
      var ly = Math.tan(y);
      var a = this.a,
          b = this.b,
          c = this.c,
          d = this.d,
          e = this.e,
          f = this.f;
      this.a = a + b * lx;
      this.b = b + a * ly;
      this.c = c + d * lx;
      this.d = d + c * ly;
      this.e = e + f * lx - cy * lx;
      this.f = f + e * ly - cx * ly;
      return this;
    } // SkewX

  }, {
    key: "skewX",
    value: function skewX(x, cx, cy) {
      return this.skew(x, 0, cx, cy);
    }
  }, {
    key: "skewXO",
    value: function skewXO(x, cx, cy) {
      return this.skewO(x, 0, cx, cy);
    } // SkewY

  }, {
    key: "skewY",
    value: function skewY(y, cx, cy) {
      return this.skew(0, y, cx, cy);
    }
  }, {
    key: "skewYO",
    value: function skewYO(y, cx, cy) {
      return this.skewO(0, y, cx, cy);
    } // Transform around a center point

  }, {
    key: "aroundO",
    value: function aroundO(cx, cy, matrix) {
      var dx = cx || 0;
      var dy = cy || 0;
      return this.translateO(-dx, -dy).lmultiplyO(matrix).translateO(dx, dy);
    }
  }, {
    key: "around",
    value: function around(cx, cy, matrix) {
      return this.clone().aroundO(cx, cy, matrix);
    } // Check if two matrices are equal

  }, {
    key: "equals",
    value: function equals(other) {
      var comp = new Matrix(other);
      return closeEnough(this.a, comp.a) && closeEnough(this.b, comp.b) && closeEnough(this.c, comp.c) && closeEnough(this.d, comp.d) && closeEnough(this.e, comp.e) && closeEnough(this.f, comp.f);
    } // Convert matrix to string

  }, {
    key: "toString",
    value: function toString() {
      return 'matrix(' + this.a + ',' + this.b + ',' + this.c + ',' + this.d + ',' + this.e + ',' + this.f + ')';
    }
  }, {
    key: "toArray",
    value: function toArray() {
      return [this.a, this.b, this.c, this.d, this.e, this.f];
    }
  }, {
    key: "valueOf",
    value: function valueOf() {
      return {
        a: this.a,
        b: this.b,
        c: this.c,
        d: this.d,
        e: this.e,
        f: this.f
      };
    }
  }], [{
    key: "fromArray",
    value: function fromArray(a) {
      return {
        a: a[0],
        b: a[1],
        c: a[2],
        d: a[3],
        e: a[4],
        f: a[5]
      };
    }
  }, {
    key: "isMatrixLike",
    value: function isMatrixLike(o) {
      return o.a != null || o.b != null || o.c != null || o.d != null || o.e != null || o.f != null;
    }
  }, {
    key: "formatTransforms",
    value: function formatTransforms(o) {
      // Get all of the parameters required to form the matrix
      var flipBoth = o.flip === 'both' || o.flip === true;
      var flipX = o.flip && (flipBoth || o.flip === 'x') ? -1 : 1;
      var flipY = o.flip && (flipBoth || o.flip === 'y') ? -1 : 1;
      var skewX = o.skew && o.skew.length ? o.skew[0] : isFinite(o.skew) ? o.skew : isFinite(o.skewX) ? o.skewX : 0;
      var skewY = o.skew && o.skew.length ? o.skew[1] : isFinite(o.skew) ? o.skew : isFinite(o.skewY) ? o.skewY : 0;
      var scaleX = o.scale && o.scale.length ? o.scale[0] * flipX : isFinite(o.scale) ? o.scale * flipX : isFinite(o.scaleX) ? o.scaleX * flipX : flipX;
      var scaleY = o.scale && o.scale.length ? o.scale[1] * flipY : isFinite(o.scale) ? o.scale * flipY : isFinite(o.scaleY) ? o.scaleY * flipY : flipY;
      var shear = o.shear || 0;
      var theta = o.rotate || o.theta || 0;
      var origin = new Point(o.origin || o.around || o.ox || o.originX, o.oy || o.originY);
      var ox = origin.x;
      var oy = origin.y;
      var position = new Point(o.position || o.px || o.positionX, o.py || o.positionY);
      var px = position.x;
      var py = position.y;
      var translate = new Point(o.translate || o.tx || o.translateX, o.ty || o.translateY);
      var tx = translate.x;
      var ty = translate.y;
      var relative = new Point(o.relative || o.rx || o.relativeX, o.ry || o.relativeY);
      var rx = relative.x;
      var ry = relative.y; // Populate all of the values

      return {
        scaleX: scaleX,
        scaleY: scaleY,
        skewX: skewX,
        skewY: skewY,
        shear: shear,
        theta: theta,
        rx: rx,
        ry: ry,
        tx: tx,
        ty: ty,
        ox: ox,
        oy: oy,
        px: px,
        py: py
      };
    } // left matrix, right matrix, target matrix which is overwritten

  }, {
    key: "matrixMultiply",
    value: function matrixMultiply(l, r, o) {
      // Work out the product directly
      var a = l.a * r.a + l.c * r.b;
      var b = l.b * r.a + l.d * r.b;
      var c = l.a * r.c + l.c * r.d;
      var d = l.b * r.c + l.d * r.d;
      var e = l.e + l.a * r.e + l.c * r.f;
      var f = l.f + l.b * r.e + l.d * r.f; // make sure to use local variables because l/r and o could be the same

      o.a = a;
      o.b = b;
      o.c = c;
      o.d = d;
      o.e = e;
      o.f = f;
      return o;
    }
  }]);

  return Matrix;
}();

exports.Matrix = Matrix;

function ctm() {
  return new Matrix(this.node.getCTM());
}

function screenCTM() {
  /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537
     This is needed because FF does not return the transformation matrix
     for the inner coordinate system when getScreenCTM() is called on nested svgs.
     However all other Browsers do that */
  if (typeof this.isRoot === 'function' && !this.isRoot()) {
    var rect = this.rect(1, 1);
    var m = rect.node.getScreenCTM();
    rect.remove();
    return new Matrix(m);
  }

  return new Matrix(this.node.getScreenCTM());
}

register(Matrix, 'Matrix');

function parser() {
  // Reuse cached element if possible
  if (!parser.nodes) {
    var svg = makeInstance().size(2, 0);
    svg.node.style.cssText = ['opacity: 0', 'position: absolute', 'left: -100%', 'top: -100%', 'overflow: hidden'].join(';');
    svg.attr('focusable', 'false');
    svg.attr('aria-hidden', 'true');
    var path = svg.path().node;
    parser.nodes = {
      svg: svg,
      path: path
    };
  }

  if (!parser.nodes.svg.node.parentNode) {
    var b = globals.document.body || globals.document.documentElement;
    parser.nodes.svg.addTo(b);
  }

  return parser.nodes;
}

function isNulledBox(box) {
  return !box.width && !box.height && !box.x && !box.y;
}

function domContains(node) {
  return node === globals.document || (globals.document.documentElement.contains || function (node) {
    // This is IE - it does not support contains() for top-level SVGs
    while (node.parentNode) {
      node = node.parentNode;
    }

    return node === globals.document;
  }).call(globals.document.documentElement, node);
}

var Box = /*#__PURE__*/function () {
  function Box() {
    _classCallCheck(this, Box);

    this.init.apply(this, arguments);
  }

  _createClass(Box, [{
    key: "init",
    value: function init(source) {
      var base = [0, 0, 0, 0];
      source = typeof source === 'string' ? source.split(delimiter).map(parseFloat) : Array.isArray(source) ? source : _typeof(source) === 'object' ? [source.left != null ? source.left : source.x, source.top != null ? source.top : source.y, source.width, source.height] : arguments.length === 4 ? [].slice.call(arguments) : base;
      this.x = source[0] || 0;
      this.y = source[1] || 0;
      this.width = this.w = source[2] || 0;
      this.height = this.h = source[3] || 0; // Add more bounding box properties

      this.x2 = this.x + this.w;
      this.y2 = this.y + this.h;
      this.cx = this.x + this.w / 2;
      this.cy = this.y + this.h / 2;
      return this;
    } // Merge rect box with another, return a new instance

  }, {
    key: "merge",
    value: function merge(box) {
      var x = Math.min(this.x, box.x);
      var y = Math.min(this.y, box.y);
      var width = Math.max(this.x + this.width, box.x + box.width) - x;
      var height = Math.max(this.y + this.height, box.y + box.height) - y;
      return new Box(x, y, width, height);
    }
  }, {
    key: "transform",
    value: function transform(m) {
      if (!(m instanceof Matrix)) {
        m = new Matrix(m);
      }

      var xMin = Infinity;
      var xMax = -Infinity;
      var yMin = Infinity;
      var yMax = -Infinity;
      var pts = [new Point(this.x, this.y), new Point(this.x2, this.y), new Point(this.x, this.y2), new Point(this.x2, this.y2)];
      pts.forEach(function (p) {
        p = p.transform(m);
        xMin = Math.min(xMin, p.x);
        xMax = Math.max(xMax, p.x);
        yMin = Math.min(yMin, p.y);
        yMax = Math.max(yMax, p.y);
      });
      return new Box(xMin, yMin, xMax - xMin, yMax - yMin);
    }
  }, {
    key: "addOffset",
    value: function addOffset() {
      // offset by window scroll position, because getBoundingClientRect changes when window is scrolled
      this.x += globals.window.pageXOffset;
      this.y += globals.window.pageYOffset;
      return this;
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      return [this.x, this.y, this.width, this.height];
    }
  }, {
    key: "isNulled",
    value: function isNulled() {
      return isNulledBox(this);
    }
  }]);

  return Box;
}();

exports.Box = Box;

function getBox(cb, retry) {
  var box;

  try {
    box = cb(this.node);

    if (isNulledBox(box) && !domContains(this.node)) {
      throw new Error('Element not in the dom');
    }
  } catch (e) {
    box = retry(this);
  }

  return box;
}

function bbox() {
  return new Box(getBox.call(this, function (node) {
    return node.getBBox();
  }, function (el) {
    try {
      var clone = el.clone().addTo(parser().svg).show();
      var box = clone.node.getBBox();
      clone.remove();
      return box;
    } catch (e) {
      throw new Error('Getting bbox of element "' + el.node.nodeName + '" is not possible. ' + e.toString());
    }
  }));
}

function rbox(el) {
  var box = new Box(getBox.call(this, function (node) {
    return node.getBoundingClientRect();
  }, function (el) {
    throw new Error('Getting rbox of element "' + el.node.nodeName + '" is not possible');
  }));
  if (el) return box.transform(el.screenCTM().inverse());
  return box.addOffset();
}

registerMethods({
  viewbox: {
    viewbox: function viewbox(x, y, width, height) {
      // act as getter
      if (x == null) return new Box(this.attr('viewBox')); // act as setter

      return this.attr('viewBox', new Box(x, y, width, height));
    },
    zoom: function zoom(level, point) {
      var width = this.node.clientWidth;
      var height = this.node.clientHeight;
      var v = this.viewbox(); // Firefox does not support clientHeight and returns 0
      // https://bugzilla.mozilla.org/show_bug.cgi?id=874811

      if (!width && !height) {
        var style = window.getComputedStyle(this.node);
        width = parseFloat(style.getPropertyValue('width'));
        height = parseFloat(style.getPropertyValue('height'));
      }

      var zoomX = width / v.width;
      var zoomY = height / v.height;
      var zoom = Math.min(zoomX, zoomY);

      if (level == null) {
        return zoom;
      }

      var zoomAmount = zoom / level;
      if (zoomAmount === Infinity) zoomAmount = Number.MIN_VALUE;
      point = point || new Point(width / 2 / zoomX + v.x, height / 2 / zoomY + v.y);
      var box = new Box(v).transform(new Matrix({
        scale: zoomAmount,
        origin: point
      }));
      return this.viewbox(box);
    }
  }
});
register(Box, 'Box');
/* eslint no-new-func: "off" */

var subClassArray = function () {
  try {
    // try es6 subclassing
    return Function('name', 'baseClass', '_constructor', ['baseClass = baseClass || Array', 'return {', '  [name]: class extends baseClass {', '    constructor (...args) {', '      super(...args)', '      _constructor && _constructor.apply(this, args)', '    }', '  }', '}[name]'].join('\n'));
  } catch (e) {
    // Use es5 approach
    return function (name) {
      var baseClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Array;

      var _constructor = arguments.length > 2 ? arguments[2] : undefined;

      var Arr = function Arr() {
        baseClass.apply(this, arguments);
        _constructor && _constructor.apply(this, arguments);
      };

      Arr.prototype = Object.create(baseClass.prototype);
      Arr.prototype.constructor = Arr;

      Arr.prototype.map = function (fn) {
        var arr = new Arr();
        arr.push.apply(arr, Array.prototype.map.call(this, fn));
        return arr;
      };

      return Arr;
    };
  }
}();

var List = subClassArray('List', Array, function () {
  var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : []; // This catches the case, that native map tries to create an array with new Array(1)

  if (typeof arr === 'number') return this;
  this.length = 0;
  this.push.apply(this, _toConsumableArray(arr));
});
exports.List = List;
extend(List, {
  each: function each(fnOrMethodName) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (typeof fnOrMethodName === 'function') {
      return this.map(function (el) {
        return fnOrMethodName.call(el, el);
      });
    } else {
      return this.map(function (el) {
        return el[fnOrMethodName].apply(el, args);
      });
    }
  },
  toArray: function toArray() {
    return Array.prototype.concat.apply([], this);
  }
});
var reserved = ['toArray', 'constructor', 'each'];

List.extend = function (methods) {
  methods = methods.reduce(function (obj, name) {
    // Don't overwrite own methods
    if (reserved.includes(name)) return obj; // Don't add private methods

    if (name[0] === '_') return obj; // Relay every call to each()

    obj[name] = function () {
      for (var _len2 = arguments.length, attrs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        attrs[_key2] = arguments[_key2];
      }

      return this.each.apply(this, [name].concat(attrs));
    };

    return obj;
  }, {});
  extend(List, methods);
};

function baseFind(query, parent) {
  return new List(map((parent || globals.document).querySelectorAll(query), function (node) {
    return adopt(node);
  }));
} // Scoped find method


function find(query) {
  return baseFind(query, this.node);
}

function findOne(query) {
  return adopt(this.node.querySelector(query));
}

var EventTarget = /*#__PURE__*/function (_Base) {
  _inherits(EventTarget, _Base);

  function EventTarget() {
    var _this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$events = _ref.events,
        events = _ref$events === void 0 ? {} : _ref$events;

    _classCallCheck(this, EventTarget);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(EventTarget).call(this));
    _this.events = events;
    return _this;
  }

  _createClass(EventTarget, [{
    key: "addEventListener",
    value: function addEventListener() {}
  }, {
    key: "dispatch",
    value: function dispatch$1(event, data) {
      return dispatch(this, event, data);
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      var bag = this.getEventHolder().events;
      if (!bag) return true;
      var events = bag[event.type];

      for (var i in events) {
        for (var j in events[i]) {
          events[i][j](event);
        }
      }

      return !event.defaultPrevented;
    } // Fire given event

  }, {
    key: "fire",
    value: function fire(event, data) {
      this.dispatch(event, data);
      return this;
    }
  }, {
    key: "getEventHolder",
    value: function getEventHolder() {
      return this;
    }
  }, {
    key: "getEventTarget",
    value: function getEventTarget() {
      return this;
    } // Unbind event from listener

  }, {
    key: "off",
    value: function off$1(event, listener) {
      off(this, event, listener);
      return this;
    } // Bind given event to listener

  }, {
    key: "on",
    value: function on$1(event, listener, binding, options) {
      on(this, event, listener, binding, options);
      return this;
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener() {}
  }]);

  return EventTarget;
}(Base);

exports.EventTarget = EventTarget;
register(EventTarget, 'EventTarget');

function noop() {} // Default animation values


var timeline = {
  duration: 400,
  ease: '>',
  delay: 0
}; // Default attribute values

var attrs = {
  // fill and stroke
  'fill-opacity': 1,
  'stroke-opacity': 1,
  'stroke-width': 0,
  'stroke-linejoin': 'miter',
  'stroke-linecap': 'butt',
  fill: '#000000',
  stroke: '#000000',
  opacity: 1,
  // position
  x: 0,
  y: 0,
  cx: 0,
  cy: 0,
  // size
  width: 0,
  height: 0,
  // radius
  r: 0,
  rx: 0,
  ry: 0,
  // gradient
  offset: 0,
  'stop-opacity': 1,
  'stop-color': '#000000',
  // text
  'text-anchor': 'start'
};
var defaults = {
  __proto__: null,
  noop: noop,
  timeline: timeline,
  attrs: attrs
};
exports.defaults = defaults;
var SVGArray = subClassArray('SVGArray', Array, function (arr) {
  this.init(arr);
});
exports.Array = SVGArray;
extend(SVGArray, {
  init: function init(arr) {
    // This catches the case, that native map tries to create an array with new Array(1)
    if (typeof arr === 'number') return this;
    this.length = 0;
    this.push.apply(this, _toConsumableArray(this.parse(arr)));
    return this;
  },
  toArray: function toArray() {
    return Array.prototype.concat.apply([], this);
  },
  toString: function toString() {
    return this.join(' ');
  },
  // Flattens the array if needed
  valueOf: function valueOf() {
    var ret = [];
    ret.push.apply(ret, _toConsumableArray(this));
    return ret;
  },
  // Parse whitespace separated string
  parse: function parse() {
    var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : []; // If already is an array, no need to parse it

    if (array instanceof Array) return array;
    return array.trim().split(delimiter).map(parseFloat);
  },
  clone: function clone() {
    return new this.constructor(this);
  },
  toSet: function toSet() {
    return new Set(this);
  }
});

var SVGNumber = /*#__PURE__*/function () {
  // Initialize
  function SVGNumber() {
    _classCallCheck(this, SVGNumber);

    this.init.apply(this, arguments);
  }

  _createClass(SVGNumber, [{
    key: "init",
    value: function init(value, unit) {
      unit = Array.isArray(value) ? value[1] : unit;
      value = Array.isArray(value) ? value[0] : value; // initialize defaults

      this.value = 0;
      this.unit = unit || ''; // parse value

      if (typeof value === 'number') {
        // ensure a valid numeric value
        this.value = isNaN(value) ? 0 : !isFinite(value) ? value < 0 ? -3.4e+38 : +3.4e+38 : value;
      } else if (typeof value === 'string') {
        unit = value.match(numberAndUnit);

        if (unit) {
          // make value numeric
          this.value = parseFloat(unit[1]); // normalize

          if (unit[5] === '%') {
            this.value /= 100;
          } else if (unit[5] === 's') {
            this.value *= 1000;
          } // store unit


          this.unit = unit[5];
        }
      } else {
        if (value instanceof SVGNumber) {
          this.value = value.valueOf();
          this.unit = value.unit;
        }
      }

      return this;
    }
  }, {
    key: "toString",
    value: function toString() {
      return (this.unit === '%' ? ~~(this.value * 1e8) / 1e6 : this.unit === 's' ? this.value / 1e3 : this.value) + this.unit;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.toString();
    }
  }, {
    key: "toArray",
    value: function toArray() {
      return [this.value, this.unit];
    }
  }, {
    key: "valueOf",
    value: function valueOf() {
      return this.value;
    } // Add number

  }, {
    key: "plus",
    value: function plus(number) {
      number = new SVGNumber(number);
      return new SVGNumber(this + number, this.unit || number.unit);
    } // Subtract number

  }, {
    key: "minus",
    value: function minus(number) {
      number = new SVGNumber(number);
      return new SVGNumber(this - number, this.unit || number.unit);
    } // Multiply number

  }, {
    key: "times",
    value: function times(number) {
      number = new SVGNumber(number);
      return new SVGNumber(this * number, this.unit || number.unit);
    } // Divide number

  }, {
    key: "divide",
    value: function divide(number) {
      number = new SVGNumber(number);
      return new SVGNumber(this / number, this.unit || number.unit);
    }
  }, {
    key: "convert",
    value: function convert(unit) {
      return new SVGNumber(this.value, unit);
    }
  }]);

  return SVGNumber;
}();

exports.Number = SVGNumber;
var hooks = [];

function registerAttrHook(fn) {
  hooks.push(fn);
} // Set svg element attribute


function attr(attr, val, ns) {
  var _this = this; // act as full getter


  if (attr == null) {
    // get an object of attributes
    attr = {};
    val = this.node.attributes;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = val[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var node = _step.value;
        attr[node.nodeName] = isNumber.test(node.nodeValue) ? parseFloat(node.nodeValue) : node.nodeValue;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return attr;
  } else if (attr instanceof Array) {
    // loop through array and get all values
    return attr.reduce(function (last, curr) {
      last[curr] = _this.attr(curr);
      return last;
    }, {});
  } else if (_typeof(attr) === 'object' && attr.constructor === Object) {
    // apply every attribute individually if an object is passed
    for (val in attr) {
      this.attr(val, attr[val]);
    }
  } else if (val === null) {
    // remove value
    this.node.removeAttribute(attr);
  } else if (val == null) {
    // act as a getter if the first and only argument is not an object
    val = this.node.getAttribute(attr);
    return val == null ? attrs[attr] : isNumber.test(val) ? parseFloat(val) : val;
  } else {
    // Loop through hooks and execute them to convert value
    val = hooks.reduce(function (_val, hook) {
      return hook(attr, _val, _this);
    }, val); // ensure correct numeric values (also accepts NaN and Infinity)

    if (typeof val === 'number') {
      val = new SVGNumber(val);
    } else if (Color.isColor(val)) {
      // ensure full hex color
      val = new Color(val);
    } else if (val.constructor === Array) {
      // Check for plain arrays and parse array values
      val = new SVGArray(val);
    } // if the passed attribute is leading...


    if (attr === 'leading') {
      // ... call the leading method instead
      if (this.leading) {
        this.leading(val);
      }
    } else {
      // set given attribute on node
      typeof ns === 'string' ? this.node.setAttributeNS(ns, attr, val.toString()) : this.node.setAttribute(attr, val.toString());
    } // rebuild if required


    if (this.rebuild && (attr === 'font-size' || attr === 'x')) {
      this.rebuild();
    }
  }

  return this;
}

var Dom = /*#__PURE__*/function (_EventTarget) {
  _inherits(Dom, _EventTarget);

  function Dom(node, attrs) {
    var _this2;

    _classCallCheck(this, Dom);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Dom).call(this, node));
    _this2.node = node;
    _this2.type = node.nodeName;

    if (attrs && node !== attrs) {
      _this2.attr(attrs);
    }

    return _this2;
  } // Add given element at a position


  _createClass(Dom, [{
    key: "add",
    value: function add(element, i) {
      element = makeInstance(element);

      if (i == null) {
        this.node.appendChild(element.node);
      } else if (element.node !== this.node.childNodes[i]) {
        this.node.insertBefore(element.node, this.node.childNodes[i]);
      }

      return this;
    } // Add element to given container and return self

  }, {
    key: "addTo",
    value: function addTo(parent) {
      return makeInstance(parent).put(this);
    } // Returns all child elements

  }, {
    key: "children",
    value: function children() {
      return new List(map(this.node.children, function (node) {
        return adopt(node);
      }));
    } // Remove all elements in this container

  }, {
    key: "clear",
    value: function clear() {
      // remove children
      while (this.node.hasChildNodes()) {
        this.node.removeChild(this.node.lastChild);
      }

      return this;
    } // Clone element

  }, {
    key: "clone",
    value: function clone() {
      // write dom data to the dom so the clone can pickup the data
      this.writeDataToDom(); // clone element and assign new id

      return assignNewId(this.node.cloneNode(true));
    } // Iterates over all children and invokes a given block

  }, {
    key: "each",
    value: function each(block, deep) {
      var children = this.children();
      var i, il;

      for (i = 0, il = children.length; i < il; i++) {
        block.apply(children[i], [i, children]);

        if (deep) {
          children[i].each(block, deep);
        }
      }

      return this;
    }
  }, {
    key: "element",
    value: function element(nodeName) {
      return this.put(new Dom(create(nodeName)));
    } // Get first child

  }, {
    key: "first",
    value: function first() {
      return adopt(this.node.firstChild);
    } // Get a element at the given index

  }, {
    key: "get",
    value: function get(i) {
      return adopt(this.node.childNodes[i]);
    }
  }, {
    key: "getEventHolder",
    value: function getEventHolder() {
      return this.node;
    }
  }, {
    key: "getEventTarget",
    value: function getEventTarget() {
      return this.node;
    } // Checks if the given element is a child

  }, {
    key: "has",
    value: function has(element) {
      return this.index(element) >= 0;
    } // Get / set id

  }, {
    key: "id",
    value: function id(_id) {
      // generate new id if no id set
      if (typeof _id === 'undefined' && !this.node.id) {
        this.node.id = eid(this.type);
      } // dont't set directly width this.node.id to make `null` work correctly


      return this.attr('id', _id);
    } // Gets index of given element

  }, {
    key: "index",
    value: function index(element) {
      return [].slice.call(this.node.childNodes).indexOf(element.node);
    } // Get the last child

  }, {
    key: "last",
    value: function last() {
      return adopt(this.node.lastChild);
    } // matches the element vs a css selector

  }, {
    key: "matches",
    value: function matches(selector) {
      var el = this.node;
      return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);
    } // Returns the parent element instance

  }, {
    key: "parent",
    value: function parent(type) {
      var parent = this; // check for parent

      if (!parent.node.parentNode) return null; // get parent element

      parent = adopt(parent.node.parentNode);
      if (!type) return parent; // loop trough ancestors if type is given

      while (parent) {
        if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent;
        if (!parent.node.parentNode || parent.node.parentNode.nodeName === '#document' || parent.node.parentNode.nodeName === '#document-fragment') return null; // #759, #720

        parent = adopt(parent.node.parentNode);
      }
    } // Basically does the same as `add()` but returns the added element instead

  }, {
    key: "put",
    value: function put(element, i) {
      this.add(element, i);
      return element;
    } // Add element to given container and return container

  }, {
    key: "putIn",
    value: function putIn(parent) {
      return makeInstance(parent).add(this);
    } // Remove element

  }, {
    key: "remove",
    value: function remove() {
      if (this.parent()) {
        this.parent().removeElement(this);
      }

      return this;
    } // Remove a given child

  }, {
    key: "removeElement",
    value: function removeElement(element) {
      this.node.removeChild(element.node);
      return this;
    } // Replace this with element

  }, {
    key: "replace",
    value: function replace(element) {
      element = makeInstance(element);
      this.node.parentNode.replaceChild(element.node, this.node);
      return element;
    }
  }, {
    key: "round",
    value: function round() {
      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;
      var map = arguments.length > 1 ? arguments[1] : undefined;
      var factor = Math.pow(10, precision);
      var attrs = this.attr(); // If we have no map, build one from attrs

      if (!map) {
        map = Object.keys(attrs);
      } // Holds rounded attributes


      var newAttrs = {};
      map.forEach(function (key) {
        newAttrs[key] = Math.round(attrs[key] * factor) / factor;
      });
      this.attr(newAttrs);
      return this;
    } // Return id on string conversion

  }, {
    key: "toString",
    value: function toString() {
      return this.id();
    } // Import raw svg

  }, {
    key: "svg",
    value: function svg(svgOrFn, outerHTML) {
      var well, len, fragment;

      if (svgOrFn === false) {
        outerHTML = false;
        svgOrFn = null;
      } // act as getter if no svg string is given


      if (svgOrFn == null || typeof svgOrFn === 'function') {
        // The default for exports is, that the outerNode is included
        outerHTML = outerHTML == null ? true : outerHTML; // write svgjs data to the dom

        this.writeDataToDom();
        var current = this; // An export modifier was passed

        if (svgOrFn != null) {
          current = adopt(current.node.cloneNode(true)); // If the user wants outerHTML we need to process this node, too

          if (outerHTML) {
            var result = svgOrFn(current);
            current = result || current; // The user does not want this node? Well, then he gets nothing

            if (result === false) return '';
          } // Deep loop through all children and apply modifier


          current.each(function () {
            var result = svgOrFn(this);

            var _this = result || this; // If modifier returns false, discard node


            if (result === false) {
              this.remove(); // If modifier returns new node, use it
            } else if (result && this !== _this) {
              this.replace(_this);
            }
          }, true);
        } // Return outer or inner content


        return outerHTML ? current.node.outerHTML : current.node.innerHTML;
      } // Act as setter if we got a string
      // The default for import is, that the current node is not replaced


      outerHTML = outerHTML == null ? false : outerHTML; // Create temporary holder

      well = globals.document.createElementNS(ns, 'svg');
      fragment = globals.document.createDocumentFragment(); // Dump raw svg

      well.innerHTML = svgOrFn; // Transplant nodes into the fragment

      for (len = well.children.length; len--;) {
        fragment.appendChild(well.firstElementChild);
      }

      var parent = this.parent(); // Add the whole fragment at once

      return outerHTML ? this.replace(fragment) && parent : this.add(fragment);
    }
  }, {
    key: "words",
    value: function words(text) {
      // This is faster than removing all children and adding a new one
      this.node.textContent = text;
      return this;
    } // write svgjs data to the dom

  }, {
    key: "writeDataToDom",
    value: function writeDataToDom() {
      // dump variables recursively
      this.each(function () {
        this.writeDataToDom();
      });
      return this;
    }
  }]);

  return Dom;
}(EventTarget);

exports.Dom = Dom;
extend(Dom, {
  attr: attr,
  find: find,
  findOne: findOne
});
register(Dom, 'Dom');

var Element = /*#__PURE__*/function (_Dom) {
  _inherits(Element, _Dom);

  function Element(node, attrs) {
    var _this;

    _classCallCheck(this, Element);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Element).call(this, node, attrs)); // initialize data object

    _this.dom = {}; // create circular reference

    _this.node.instance = _assertThisInitialized(_this);

    if (node.hasAttribute('svgjs:data')) {
      // pull svgjs data from the dom (getAttributeNS doesn't work in html5)
      _this.setData(JSON.parse(node.getAttribute('svgjs:data')) || {});
    }

    return _this;
  } // Move element by its center


  _createClass(Element, [{
    key: "center",
    value: function center(x, y) {
      return this.cx(x).cy(y);
    } // Move by center over x-axis

  }, {
    key: "cx",
    value: function cx(x) {
      return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2);
    } // Move by center over y-axis

  }, {
    key: "cy",
    value: function cy(y) {
      return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2);
    } // Get defs

  }, {
    key: "defs",
    value: function defs() {
      return this.root().defs();
    } // Relative move over x and y axes

  }, {
    key: "dmove",
    value: function dmove(x, y) {
      return this.dx(x).dy(y);
    } // Relative move over x axis

  }, {
    key: "dx",
    value: function dx() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return this.x(new SVGNumber(x).plus(this.x()));
    } // Relative move over y axis

  }, {
    key: "dy",
    value: function dy() {
      var y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return this.y(new SVGNumber(y).plus(this.y()));
    } // Get parent document

  }, {
    key: "root",
    value: function root$1() {
      var p = this.parent(getClass(root));
      return p && p.root();
    }
  }, {
    key: "getEventHolder",
    value: function getEventHolder() {
      return this;
    } // Set height of element

  }, {
    key: "height",
    value: function height(_height) {
      return this.attr('height', _height);
    } // Checks whether the given point inside the bounding box of the element

  }, {
    key: "inside",
    value: function inside(x, y) {
      var box = this.bbox();
      return x > box.x && y > box.y && x < box.x + box.width && y < box.y + box.height;
    } // Move element to given x and y values

  }, {
    key: "move",
    value: function move(x, y) {
      return this.x(x).y(y);
    } // return array of all ancestors of given type up to the root svg

  }, {
    key: "parents",
    value: function parents() {
      var until = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : globals.document;
      until = makeInstance(until);
      var parents = new List();
      var parent = this;

      while ((parent = parent.parent()) && parent.node !== until.node && parent.node !== globals.document) {
        parents.push(parent);
      }

      return parents;
    } // Get referenced element form attribute value

  }, {
    key: "reference",
    value: function reference$1(attr) {
      attr = this.attr(attr);
      if (!attr) return null;
      var m = attr.match(reference);
      return m ? makeInstance(m[1]) : null;
    } // set given data to the elements data property

  }, {
    key: "setData",
    value: function setData(o) {
      this.dom = o;
      return this;
    } // Set element size to given width and height

  }, {
    key: "size",
    value: function size(width, height) {
      var p = proportionalSize(this, width, height);
      return this.width(new SVGNumber(p.width)).height(new SVGNumber(p.height));
    } // Set width of element

  }, {
    key: "width",
    value: function width(_width) {
      return this.attr('width', _width);
    } // write svgjs data to the dom

  }, {
    key: "writeDataToDom",
    value: function writeDataToDom() {
      // remove previously set data
      this.node.removeAttribute('svgjs:data');

      if (Object.keys(this.dom).length) {
        this.node.setAttribute('svgjs:data', JSON.stringify(this.dom)); // see #428
      }

      return _get(_getPrototypeOf(Element.prototype), "writeDataToDom", this).call(this);
    } // Move over x-axis

  }, {
    key: "x",
    value: function x(_x) {
      return this.attr('x', _x);
    } // Move over y-axis

  }, {
    key: "y",
    value: function y(_y) {
      return this.attr('y', _y);
    }
  }]);

  return Element;
}(Dom);

exports.Element = Element;
extend(Element, {
  bbox: bbox,
  rbox: rbox,
  point: point,
  ctm: ctm,
  screenCTM: screenCTM
});
register(Element, 'Element');
var sugar = {
  stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset'],
  fill: ['color', 'opacity', 'rule'],
  prefix: function prefix(t, a) {
    return a === 'color' ? t : t + '-' + a;
  }
} // Add sugar for fill and stroke
;
['fill', 'stroke'].forEach(function (m) {
  var extension = {};
  var i;

  extension[m] = function (o) {
    if (typeof o === 'undefined') {
      return this.attr(m);
    }

    if (typeof o === 'string' || o instanceof Color || Color.isRgb(o) || o instanceof Element) {
      this.attr(m, o);
    } else {
      // set all attributes from sugar.fill and sugar.stroke list
      for (i = sugar[m].length - 1; i >= 0; i--) {
        if (o[sugar[m][i]] != null) {
          this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]]);
        }
      }
    }

    return this;
  };

  registerMethods(['Element', 'Runner'], extension);
});
registerMethods(['Element', 'Runner'], {
  // Let the user set the matrix directly
  matrix: function matrix(mat, b, c, d, e, f) {
    // Act as a getter
    if (mat == null) {
      return new Matrix(this);
    } // Act as a setter, the user can pass a matrix or a set of numbers


    return this.attr('transform', new Matrix(mat, b, c, d, e, f));
  },
  // Map rotation to transform
  rotate: function rotate(angle, cx, cy) {
    return this.transform({
      rotate: angle,
      ox: cx,
      oy: cy
    }, true);
  },
  // Map skew to transform
  skew: function skew(x, y, cx, cy) {
    return arguments.length === 1 || arguments.length === 3 ? this.transform({
      skew: x,
      ox: y,
      oy: cx
    }, true) : this.transform({
      skew: [x, y],
      ox: cx,
      oy: cy
    }, true);
  },
  shear: function shear(lam, cx, cy) {
    return this.transform({
      shear: lam,
      ox: cx,
      oy: cy
    }, true);
  },
  // Map scale to transform
  scale: function scale(x, y, cx, cy) {
    return arguments.length === 1 || arguments.length === 3 ? this.transform({
      scale: x,
      ox: y,
      oy: cx
    }, true) : this.transform({
      scale: [x, y],
      ox: cx,
      oy: cy
    }, true);
  },
  // Map translate to transform
  translate: function translate(x, y) {
    return this.transform({
      translate: [x, y]
    }, true);
  },
  // Map relative translations to transform
  relative: function relative(x, y) {
    return this.transform({
      relative: [x, y]
    }, true);
  },
  // Map flip to transform
  flip: function flip(direction, around) {
    var directionString = typeof direction === 'string' ? direction : isFinite(direction) ? 'both' : 'both';
    var origin = direction === 'both' && isFinite(around) ? [around, around] : direction === 'x' ? [around, 0] : direction === 'y' ? [0, around] : isFinite(direction) ? [direction, direction] : [0, 0];
    return this.transform({
      flip: directionString,
      origin: origin
    }, true);
  },
  // Opacity
  opacity: function opacity(value) {
    return this.attr('opacity', value);
  }
});
registerMethods('radius', {
  // Add x and y radius
  radius: function radius(x, y) {
    var type = (this._element || this).type;
    return type === 'radialGradient' || type === 'radialGradient' ? this.attr('r', new SVGNumber(x)) : this.rx(x).ry(y == null ? x : y);
  }
});
registerMethods('Path', {
  // Get path length
  length: function length() {
    return this.node.getTotalLength();
  },
  // Get point at length
  pointAt: function pointAt(length) {
    return new Point(this.node.getPointAtLength(length));
  }
});
registerMethods(['Element', 'Runner'], {
  // Set font
  font: function font(a, v) {
    if (_typeof(a) === 'object') {
      for (v in a) {
        this.font(v, a[v]);
      }

      return this;
    }

    return a === 'leading' ? this.leading(v) : a === 'anchor' ? this.attr('text-anchor', v) : a === 'size' || a === 'family' || a === 'weight' || a === 'stretch' || a === 'variant' || a === 'style' ? this.attr('font-' + a, v) : this.attr(a, v);
  }
});
registerMethods('Text', {
  ax: function ax(x) {
    return this.attr('x', x);
  },
  ay: function ay(y) {
    return this.attr('y', y);
  },
  amove: function amove(x, y) {
    return this.ax(x).ay(y);
  }
}); // Add events to elements

var methods$1 = ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mousemove', 'mouseenter', 'mouseleave', 'touchstart', 'touchmove', 'touchleave', 'touchend', 'touchcancel'].reduce(function (last, event) {
  // add event to Element
  var fn = function fn(f) {
    if (f === null) {
      off(this, event);
    } else {
      on(this, event, f);
    }

    return this;
  };

  last[event] = fn;
  return last;
}, {});
registerMethods('Element', methods$1);
var nativeReverse = [].reverse;
var test$1 = [1, 2]; // `Array.prototype.reverse` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reverse
// fix for Safari 12.0 bug
// https://bugs.webkit.org/show_bug.cgi?id=188794

_export({
  target: 'Array',
  proto: true,
  forced: String(test$1) === String(test$1.reverse())
}, {
  reverse: function reverse() {
    // eslint-disable-next-line no-self-assign
    if (isArray(this)) this.length = this.length;
    return nativeReverse.call(this);
  }
}); // `Object.defineProperties` method
// https://tc39.github.io/ecma262/#sec-object.defineproperties


_export({
  target: 'Object',
  stat: true,
  forced: !descriptors,
  sham: !descriptors
}, {
  defineProperties: objectDefineProperties
}); // `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty


_export({
  target: 'Object',
  stat: true,
  forced: !descriptors,
  sham: !descriptors
}, {
  defineProperty: objectDefineProperty.f
});

var nativeGetOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
var FAILS_ON_PRIMITIVES$2 = fails(function () {
  nativeGetOwnPropertyDescriptor$2(1);
});
var FORCED$3 = !descriptors || FAILS_ON_PRIMITIVES$2; // `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor

_export({
  target: 'Object',
  stat: true,
  forced: FORCED$3,
  sham: !descriptors
}, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor$2(toIndexedObject(it), key);
  }
}); // `Object.getOwnPropertyDescriptors` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors


_export({
  target: 'Object',
  stat: true,
  sham: !descriptors
}, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject(object);
    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
    var keys = ownKeys(O);
    var result = {};
    var index = 0;
    var key, descriptor;

    while (keys.length > index) {
      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
      if (descriptor !== undefined) createProperty(result, key, descriptor);
    }

    return result;
  }
});

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$1(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function untransform() {
  return this.attr('transform', null);
} // merge the whole transformation chain into one matrix and returns it


function matrixify() {
  var matrix = (this.attr('transform') || ''). // split transformations
  split(transforms).slice(0, -1).map(function (str) {
    // generate key => value pairs
    var kv = str.trim().split('(');
    return [kv[0], kv[1].split(delimiter).map(function (str) {
      return parseFloat(str);
    })];
  }).reverse() // merge every transformation into one matrix
  .reduce(function (matrix, transform) {
    if (transform[0] === 'matrix') {
      return matrix.lmultiply(Matrix.fromArray(transform[1]));
    }

    return matrix[transform[0]].apply(matrix, transform[1]);
  }, new Matrix());
  return matrix;
} // add an element to another parent without changing the visual representation on the screen


function toParent(parent) {
  if (this === parent) return this;
  var ctm = this.screenCTM();
  var pCtm = parent.screenCTM().inverse();
  this.addTo(parent).untransform().transform(pCtm.multiply(ctm));
  return this;
} // same as above with parent equals root-svg


function toRoot() {
  return this.toParent(this.root());
} // Add transformations


function transform(o, relative) {
  // Act as a getter if no object was passed
  if (o == null || typeof o === 'string') {
    var decomposed = new Matrix(this).decompose();
    return o == null ? decomposed : decomposed[o];
  }

  if (!Matrix.isMatrixLike(o)) {
    // Set the origin according to the defined transform
    o = _objectSpread({}, o, {
      origin: getOrigin(o, this)
    });
  } // The user can pass a boolean, an Element or an Matrix or nothing


  var cleanRelative = relative === true ? this : relative || false;
  var result = new Matrix(cleanRelative).transform(o);
  return this.attr('transform', result);
}

registerMethods('Element', {
  untransform: untransform,
  matrixify: matrixify,
  toParent: toParent,
  toRoot: toRoot,
  transform: transform
});

function rx(rx) {
  return this.attr('rx', rx);
} // Radius y value


function ry(ry) {
  return this.attr('ry', ry);
} // Move over x-axis


function x(x) {
  return x == null ? this.cx() - this.rx() : this.cx(x + this.rx());
} // Move over y-axis


function y(y) {
  return y == null ? this.cy() - this.ry() : this.cy(y + this.ry());
} // Move by center over x-axis


function cx(x) {
  return x == null ? this.attr('cx') : this.attr('cx', x);
} // Move by center over y-axis


function cy(y) {
  return y == null ? this.attr('cy') : this.attr('cy', y);
} // Set width of element


function width(width) {
  return width == null ? this.rx() * 2 : this.rx(new SVGNumber(width).divide(2));
} // Set height of element


function height(height) {
  return height == null ? this.ry() * 2 : this.ry(new SVGNumber(height).divide(2));
}

var circled = {
  __proto__: null,
  rx: rx,
  ry: ry,
  x: x,
  y: y,
  cx: cx,
  cy: cy,
  width: width,
  height: height
};

var Shape = /*#__PURE__*/function (_Element) {
  _inherits(Shape, _Element);

  function Shape() {
    _classCallCheck(this, Shape);

    return _possibleConstructorReturn(this, _getPrototypeOf(Shape).apply(this, arguments));
  }

  return Shape;
}(Element);

exports.Shape = Shape;
register(Shape, 'Shape');

var Circle = /*#__PURE__*/function (_Shape) {
  _inherits(Circle, _Shape);

  function Circle(node) {
    _classCallCheck(this, Circle);

    return _possibleConstructorReturn(this, _getPrototypeOf(Circle).call(this, nodeOrNew('circle', node), node));
  }

  _createClass(Circle, [{
    key: "radius",
    value: function radius(r) {
      return this.attr('r', r);
    } // Radius x value

  }, {
    key: "rx",
    value: function rx(_rx) {
      return this.attr('r', _rx);
    } // Alias radius x value

  }, {
    key: "ry",
    value: function ry(_ry) {
      return this.rx(_ry);
    }
  }, {
    key: "size",
    value: function size(_size) {
      return this.radius(new SVGNumber(_size).divide(2));
    }
  }]);

  return Circle;
}(Shape);

exports.Circle = Circle;
extend(Circle, {
  x: x,
  y: y,
  cx: cx,
  cy: cy,
  width: width,
  height: height
});
registerMethods({
  Container: {
    // Create circle element
    circle: wrapWithAttrCheck(function (size) {
      return this.put(new Circle()).size(size).move(0, 0);
    })
  }
});
register(Circle, 'Circle');

var Container = /*#__PURE__*/function (_Element) {
  _inherits(Container, _Element);

  function Container() {
    _classCallCheck(this, Container);

    return _possibleConstructorReturn(this, _getPrototypeOf(Container).apply(this, arguments));
  }

  _createClass(Container, [{
    key: "flatten",
    value: function flatten(parent) {
      this.each(function () {
        if (this instanceof Container) return this.flatten(parent).ungroup(parent);
        return this.toParent(parent);
      }); // we need this so that the root does not get removed

      this.node.firstElementChild || this.remove();
      return this;
    }
  }, {
    key: "ungroup",
    value: function ungroup(parent) {
      parent = parent || this.parent();
      this.each(function () {
        return this.toParent(parent);
      });
      this.remove();
      return this;
    }
  }]);

  return Container;
}(Element);

exports.Container = Container;
register(Container, 'Container');

var Defs = /*#__PURE__*/function (_Container) {
  _inherits(Defs, _Container);

  function Defs(node) {
    _classCallCheck(this, Defs);

    return _possibleConstructorReturn(this, _getPrototypeOf(Defs).call(this, nodeOrNew('defs', node), node));
  }

  _createClass(Defs, [{
    key: "flatten",
    value: function flatten() {
      return this;
    }
  }, {
    key: "ungroup",
    value: function ungroup() {
      return this;
    }
  }]);

  return Defs;
}(Container);

exports.Defs = Defs;
register(Defs, 'Defs');

var Ellipse = /*#__PURE__*/function (_Shape) {
  _inherits(Ellipse, _Shape);

  function Ellipse(node) {
    _classCallCheck(this, Ellipse);

    return _possibleConstructorReturn(this, _getPrototypeOf(Ellipse).call(this, nodeOrNew('ellipse', node), node));
  }

  _createClass(Ellipse, [{
    key: "size",
    value: function size(width, height) {
      var p = proportionalSize(this, width, height);
      return this.rx(new SVGNumber(p.width).divide(2)).ry(new SVGNumber(p.height).divide(2));
    }
  }]);

  return Ellipse;
}(Shape);

exports.Ellipse = Ellipse;
extend(Ellipse, circled);
registerMethods('Container', {
  // Create an ellipse
  ellipse: wrapWithAttrCheck(function () {
    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;
    return this.put(new Ellipse()).size(width, height).move(0, 0);
  })
});
register(Ellipse, 'Ellipse');

var Stop = /*#__PURE__*/function (_Element) {
  _inherits(Stop, _Element);

  function Stop(node) {
    _classCallCheck(this, Stop);

    return _possibleConstructorReturn(this, _getPrototypeOf(Stop).call(this, nodeOrNew('stop', node), node));
  } // add color stops


  _createClass(Stop, [{
    key: "update",
    value: function update(o) {
      if (typeof o === 'number' || o instanceof SVGNumber) {
        o = {
          offset: arguments[0],
          color: arguments[1],
          opacity: arguments[2]
        };
      } // set attributes


      if (o.opacity != null) this.attr('stop-opacity', o.opacity);
      if (o.color != null) this.attr('stop-color', o.color);
      if (o.offset != null) this.attr('offset', new SVGNumber(o.offset));
      return this;
    }
  }]);

  return Stop;
}(Element);

exports.Stop = Stop;
register(Stop, 'Stop');

function from(x, y) {
  return (this._element || this).type === 'radialGradient' ? this.attr({
    fx: new SVGNumber(x),
    fy: new SVGNumber(y)
  }) : this.attr({
    x1: new SVGNumber(x),
    y1: new SVGNumber(y)
  });
}

function to(x, y) {
  return (this._element || this).type === 'radialGradient' ? this.attr({
    cx: new SVGNumber(x),
    cy: new SVGNumber(y)
  }) : this.attr({
    x2: new SVGNumber(x),
    y2: new SVGNumber(y)
  });
}

var gradiented = {
  __proto__: null,
  from: from,
  to: to
};

var Gradient = /*#__PURE__*/function (_Container) {
  _inherits(Gradient, _Container);

  function Gradient(type, attrs) {
    _classCallCheck(this, Gradient);

    return _possibleConstructorReturn(this, _getPrototypeOf(Gradient).call(this, nodeOrNew(type + 'Gradient', typeof type === 'string' ? null : type), attrs));
  } // Add a color stop


  _createClass(Gradient, [{
    key: "stop",
    value: function stop(offset, color, opacity) {
      return this.put(new Stop()).update(offset, color, opacity);
    } // Update gradient

  }, {
    key: "update",
    value: function update(block) {
      // remove all stops
      this.clear(); // invoke passed block

      if (typeof block === 'function') {
        block.call(this, this);
      }

      return this;
    } // Return the fill id

  }, {
    key: "url",
    value: function url() {
      return 'url(#' + this.id() + ')';
    } // Alias string convertion to fill

  }, {
    key: "toString",
    value: function toString() {
      return this.url();
    } // custom attr to handle transform

  }, {
    key: "attr",
    value: function attr(a, b, c) {
      if (a === 'transform') a = 'gradientTransform';
      return _get(_getPrototypeOf(Gradient.prototype), "attr", this).call(this, a, b, c);
    }
  }, {
    key: "targets",
    value: function targets() {
      return baseFind('svg [fill*="' + this.id() + '"]');
    }
  }, {
    key: "bbox",
    value: function bbox() {
      return new Box();
    }
  }]);

  return Gradient;
}(Container);

exports.Gradient = Gradient;
extend(Gradient, gradiented);
registerMethods({
  Container: {
    // Create gradient element in defs
    gradient: wrapWithAttrCheck(function (type, block) {
      return this.defs().gradient(type, block);
    })
  },
  // define gradient
  Defs: {
    gradient: wrapWithAttrCheck(function (type, block) {
      return this.put(new Gradient(type)).update(block);
    })
  }
});
register(Gradient, 'Gradient');

var Pattern = /*#__PURE__*/function (_Container) {
  _inherits(Pattern, _Container); // Initialize node


  function Pattern(node) {
    _classCallCheck(this, Pattern);

    return _possibleConstructorReturn(this, _getPrototypeOf(Pattern).call(this, nodeOrNew('pattern', node), node));
  } // Return the fill id


  _createClass(Pattern, [{
    key: "url",
    value: function url() {
      return 'url(#' + this.id() + ')';
    } // Update pattern by rebuilding

  }, {
    key: "update",
    value: function update(block) {
      // remove content
      this.clear(); // invoke passed block

      if (typeof block === 'function') {
        block.call(this, this);
      }

      return this;
    } // Alias string convertion to fill

  }, {
    key: "toString",
    value: function toString() {
      return this.url();
    } // custom attr to handle transform

  }, {
    key: "attr",
    value: function attr(a, b, c) {
      if (a === 'transform') a = 'patternTransform';
      return _get(_getPrototypeOf(Pattern.prototype), "attr", this).call(this, a, b, c);
    }
  }, {
    key: "targets",
    value: function targets() {
      return baseFind('svg [fill*="' + this.id() + '"]');
    }
  }, {
    key: "bbox",
    value: function bbox() {
      return new Box();
    }
  }]);

  return Pattern;
}(Container);

exports.Pattern = Pattern;
registerMethods({
  Container: {
    // Create pattern element in defs
    pattern: function pattern() {
      var _this$defs;

      return (_this$defs = this.defs()).pattern.apply(_this$defs, arguments);
    }
  },
  Defs: {
    pattern: wrapWithAttrCheck(function (width, height, block) {
      return this.put(new Pattern()).update(block).attr({
        x: 0,
        y: 0,
        width: width,
        height: height,
        patternUnits: 'userSpaceOnUse'
      });
    })
  }
});
register(Pattern, 'Pattern');

var Image = /*#__PURE__*/function (_Shape) {
  _inherits(Image, _Shape);

  function Image(node) {
    _classCallCheck(this, Image);

    return _possibleConstructorReturn(this, _getPrototypeOf(Image).call(this, nodeOrNew('image', node), node));
  } // (re)load image


  _createClass(Image, [{
    key: "load",
    value: function load(url, callback) {
      if (!url) return this;
      var img = new globals.window.Image();
      on(img, 'load', function (e) {
        var p = this.parent(Pattern); // ensure image size

        if (this.width() === 0 && this.height() === 0) {
          this.size(img.width, img.height);
        }

        if (p instanceof Pattern) {
          // ensure pattern size if not set
          if (p.width() === 0 && p.height() === 0) {
            p.size(this.width(), this.height());
          }
        }

        if (typeof callback === 'function') {
          callback.call(this, e);
        }
      }, this);
      on(img, 'load error', function () {
        // dont forget to unbind memory leaking events
        off(img);
      });
      return this.attr('href', img.src = url, xlink);
    }
  }]);

  return Image;
}(Shape);

exports.Image = Image;
registerAttrHook(function (attr, val, _this) {
  // convert image fill and stroke to patterns
  if (attr === 'fill' || attr === 'stroke') {
    if (isImage.test(val)) {
      val = _this.root().defs().image(val);
    }
  }

  if (val instanceof Image) {
    val = _this.root().defs().pattern(0, 0, function (pattern) {
      pattern.add(val);
    });
  }

  return val;
});
registerMethods({
  Container: {
    // create image element, load image and set its size
    image: wrapWithAttrCheck(function (source, callback) {
      return this.put(new Image()).size(0, 0).load(source, callback);
    })
  }
});
register(Image, 'Image');
var PointArray = subClassArray('PointArray', SVGArray);
exports.PointArray = PointArray;
extend(PointArray, {
  // Convert array to string
  toString: function toString() {
    // convert to a poly point string
    for (var i = 0, il = this.length, array = []; i < il; i++) {
      array.push(this[i].join(','));
    }

    return array.join(' ');
  },
  // Convert array to line object
  toLine: function toLine() {
    return {
      x1: this[0][0],
      y1: this[0][1],
      x2: this[1][0],
      y2: this[1][1]
    };
  },
  // Get morphed array at given position
  at: function at(pos) {
    // make sure a destination is defined
    if (!this.destination) return this; // generate morphed point string

    for (var i = 0, il = this.length, array = []; i < il; i++) {
      array.push([this[i][0] + (this.destination[i][0] - this[i][0]) * pos, this[i][1] + (this.destination[i][1] - this[i][1]) * pos]);
    }

    return new PointArray(array);
  },
  // Parse point string and flat array
  parse: function parse() {
    var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [[0, 0]];
    var points = []; // if it is an array

    if (array instanceof Array) {
      // and it is not flat, there is no need to parse it
      if (array[0] instanceof Array) {
        return array;
      }
    } else {
      // Else, it is considered as a string
      // parse points
      array = array.trim().split(delimiter).map(parseFloat);
    } // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints
    // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.


    if (array.length % 2 !== 0) array.pop(); // wrap points in two-tuples

    for (var i = 0, len = array.length; i < len; i = i + 2) {
      points.push([array[i], array[i + 1]]);
    }

    return points;
  },
  // transform points with matrix (similar to Point.transform)
  transform: function transform(m) {
    var points = [];

    for (var i = 0; i < this.length; i++) {
      var point = this[i]; // Perform the matrix multiplication

      points.push([m.a * point[0] + m.c * point[1] + m.e, m.b * point[0] + m.d * point[1] + m.f]);
    } // Return the required point


    return new PointArray(points);
  },
  // Move point string
  move: function move(x, y) {
    var box = this.bbox(); // get relative offset

    x -= box.x;
    y -= box.y; // move every point

    if (!isNaN(x) && !isNaN(y)) {
      for (var i = this.length - 1; i >= 0; i--) {
        this[i] = [this[i][0] + x, this[i][1] + y];
      }
    }

    return this;
  },
  // Resize poly string
  size: function size(width, height) {
    var i;
    var box = this.bbox(); // recalculate position of all points according to new size

    for (i = this.length - 1; i >= 0; i--) {
      if (box.width) this[i][0] = (this[i][0] - box.x) * width / box.width + box.x;
      if (box.height) this[i][1] = (this[i][1] - box.y) * height / box.height + box.y;
    }

    return this;
  },
  // Get bounding box of points
  bbox: function bbox() {
    var maxX = -Infinity;
    var maxY = -Infinity;
    var minX = Infinity;
    var minY = Infinity;
    this.forEach(function (el) {
      maxX = Math.max(el[0], maxX);
      maxY = Math.max(el[1], maxY);
      minX = Math.min(el[0], minX);
      minY = Math.min(el[1], minY);
    });
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
});
var MorphArray = PointArray; // Move by left top corner over x-axis

function x$1(x) {
  return x == null ? this.bbox().x : this.move(x, this.bbox().y);
} // Move by left top corner over y-axis


function y$1(y) {
  return y == null ? this.bbox().y : this.move(this.bbox().x, y);
} // Set width of element


function width$1(width) {
  var b = this.bbox();
  return width == null ? b.width : this.size(width, b.height);
} // Set height of element


function height$1(height) {
  var b = this.bbox();
  return height == null ? b.height : this.size(b.width, height);
}

var pointed = {
  __proto__: null,
  MorphArray: MorphArray,
  x: x$1,
  y: y$1,
  width: width$1,
  height: height$1
};

var Line = /*#__PURE__*/function (_Shape) {
  _inherits(Line, _Shape); // Initialize node


  function Line(node) {
    _classCallCheck(this, Line);

    return _possibleConstructorReturn(this, _getPrototypeOf(Line).call(this, nodeOrNew('line', node), node));
  } // Get array


  _createClass(Line, [{
    key: "array",
    value: function array() {
      return new PointArray([[this.attr('x1'), this.attr('y1')], [this.attr('x2'), this.attr('y2')]]);
    } // Overwrite native plot() method

  }, {
    key: "plot",
    value: function plot(x1, y1, x2, y2) {
      if (x1 == null) {
        return this.array();
      } else if (typeof y1 !== 'undefined') {
        x1 = {
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2
        };
      } else {
        x1 = new PointArray(x1).toLine();
      }

      return this.attr(x1);
    } // Move by left top corner

  }, {
    key: "move",
    value: function move(x, y) {
      return this.attr(this.array().move(x, y).toLine());
    } // Set element size to given width and height

  }, {
    key: "size",
    value: function size(width, height) {
      var p = proportionalSize(this, width, height);
      return this.attr(this.array().size(p.width, p.height).toLine());
    }
  }]);

  return Line;
}(Shape);

exports.Line = Line;
extend(Line, pointed);
registerMethods({
  Container: {
    // Create a line element
    line: wrapWithAttrCheck(function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      } // make sure plot is called as a setter
      // x1 is not necessarily a number, it can also be an array, a string and a PointArray


      return Line.prototype.plot.apply(this.put(new Line()), args[0] != null ? args : [0, 0, 0, 0]);
    })
  }
});
register(Line, 'Line');

var Marker = /*#__PURE__*/function (_Container) {
  _inherits(Marker, _Container); // Initialize node


  function Marker(node) {
    _classCallCheck(this, Marker);

    return _possibleConstructorReturn(this, _getPrototypeOf(Marker).call(this, nodeOrNew('marker', node), node));
  } // Set width of element


  _createClass(Marker, [{
    key: "width",
    value: function width(_width) {
      return this.attr('markerWidth', _width);
    } // Set height of element

  }, {
    key: "height",
    value: function height(_height) {
      return this.attr('markerHeight', _height);
    } // Set marker refX and refY

  }, {
    key: "ref",
    value: function ref(x, y) {
      return this.attr('refX', x).attr('refY', y);
    } // Update marker

  }, {
    key: "update",
    value: function update(block) {
      // remove all content
      this.clear(); // invoke passed block

      if (typeof block === 'function') {
        block.call(this, this);
      }

      return this;
    } // Return the fill id

  }, {
    key: "toString",
    value: function toString() {
      return 'url(#' + this.id() + ')';
    }
  }]);

  return Marker;
}(Container);

exports.Marker = Marker;
registerMethods({
  Container: {
    marker: function marker() {
      var _this$defs; // Create marker element in defs


      return (_this$defs = this.defs()).marker.apply(_this$defs, arguments);
    }
  },
  Defs: {
    // Create marker
    marker: wrapWithAttrCheck(function (width, height, block) {
      // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto
      return this.put(new Marker()).size(width, height).ref(width / 2, height / 2).viewbox(0, 0, width, height).attr('orient', 'auto').update(block);
    })
  },
  marker: {
    // Create and attach markers
    marker: function marker(_marker, width, height, block) {
      var attr = ['marker']; // Build attribute name

      if (_marker !== 'all') attr.push(_marker);
      attr = attr.join('-'); // Set marker attribute

      _marker = arguments[1] instanceof Marker ? arguments[1] : this.defs().marker(width, height, block);
      return this.attr(attr, _marker);
    }
  }
});
register(Marker, 'Marker');
var nativeSort = [].sort;
var test$2 = [1, 2, 3]; // IE8-

var FAILS_ON_UNDEFINED = fails(function () {
  test$2.sort(undefined);
}); // V8 bug

var FAILS_ON_NULL = fails(function () {
  test$2.sort(null);
}); // Old WebKit

var SLOPPY_METHOD$2 = sloppyArrayMethod('sort');
var FORCED$4 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || SLOPPY_METHOD$2; // `Array.prototype.sort` method
// https://tc39.github.io/ecma262/#sec-array.prototype.sort

_export({
  target: 'Array',
  proto: true,
  forced: FORCED$4
}, {
  sort: function sort(comparefn) {
    return comparefn === undefined ? nativeSort.call(toObject(this)) : nativeSort.call(toObject(this), aFunction$1(comparefn));
  }
});
/***
Base Class
==========
The base stepper class that will be
***/


function makeSetterGetter(k, f) {
  return function (v) {
    if (v == null) return this[v];
    this[k] = v;
    if (f) f.call(this);
    return this;
  };
}

var easing = {
  '-': function _(pos) {
    return pos;
  },
  '<>': function _(pos) {
    return -Math.cos(pos * Math.PI) / 2 + 0.5;
  },
  '>': function _(pos) {
    return Math.sin(pos * Math.PI / 2);
  },
  '<': function _(pos) {
    return -Math.cos(pos * Math.PI / 2) + 1;
  },
  bezier: function bezier(x1, y1, x2, y2) {
    // see https://www.w3.org/TR/css-easing-1/#cubic-bezier-algo
    return function (t) {
      if (t < 0) {
        if (x1 > 0) {
          return y1 / x1 * t;
        } else if (x2 > 0) {
          return y2 / x2 * t;
        } else {
          return 0;
        }
      } else if (t > 1) {
        if (x2 < 1) {
          return (1 - y2) / (1 - x2) * t + (y2 - x2) / (1 - x2);
        } else if (x1 < 1) {
          return (1 - y1) / (1 - x1) * t + (y1 - x1) / (1 - x1);
        } else {
          return 1;
        }
      } else {
        return 3 * t * Math.pow(1 - t, 2) * y1 + 3 * Math.pow(t, 2) * (1 - t) * y2 + Math.pow(t, 3);
      }
    };
  },
  // see https://www.w3.org/TR/css-easing-1/#step-timing-function-algo
  steps: function steps(_steps) {
    var stepPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'end'; // deal with "jump-" prefix

    stepPosition = stepPosition.split('-').reverse()[0];
    var jumps = _steps;

    if (stepPosition === 'none') {
      --jumps;
    } else if (stepPosition === 'both') {
      ++jumps;
    } // The beforeFlag is essentially useless


    return function (t) {
      var beforeFlag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // Step is called currentStep in referenced url

      var step = Math.floor(t * _steps);
      var jumping = t * step % 1 === 0;

      if (stepPosition === 'start' || stepPosition === 'both') {
        ++step;
      }

      if (beforeFlag && jumping) {
        --step;
      }

      if (t >= 0 && step < 0) {
        step = 0;
      }

      if (t <= 1 && step > jumps) {
        step = jumps;
      }

      return step / jumps;
    };
  }
};
exports.easing = easing;

var Stepper = /*#__PURE__*/function () {
  function Stepper() {
    _classCallCheck(this, Stepper);
  }

  _createClass(Stepper, [{
    key: "done",
    value: function done() {
      return false;
    }
  }]);

  return Stepper;
}();
/***
Easing Functions
================
***/


var Ease = /*#__PURE__*/function (_Stepper) {
  _inherits(Ease, _Stepper);

  function Ease(fn) {
    var _this;

    _classCallCheck(this, Ease);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Ease).call(this));
    _this.ease = easing[fn || timeline.ease] || fn;
    return _this;
  }

  _createClass(Ease, [{
    key: "step",
    value: function step(from, to, pos) {
      if (typeof from !== 'number') {
        return pos < 1 ? from : to;
      }

      return from + (to - from) * this.ease(pos);
    }
  }]);

  return Ease;
}(Stepper);
/***
Controller Types
================
***/


exports.Ease = Ease;

var Controller = /*#__PURE__*/function (_Stepper2) {
  _inherits(Controller, _Stepper2);

  function Controller(fn) {
    var _this2;

    _classCallCheck(this, Controller);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Controller).call(this));
    _this2.stepper = fn;
    return _this2;
  }

  _createClass(Controller, [{
    key: "step",
    value: function step(current, target, dt, c) {
      return this.stepper(current, target, dt, c);
    }
  }, {
    key: "done",
    value: function done(c) {
      return c.done;
    }
  }]);

  return Controller;
}(Stepper);

exports.Controller = Controller;

function recalculate() {
  // Apply the default parameters
  var duration = (this._duration || 500) / 1000;
  var overshoot = this._overshoot || 0; // Calculate the PID natural response

  var eps = 1e-10;
  var pi = Math.PI;
  var os = Math.log(overshoot / 100 + eps);
  var zeta = -os / Math.sqrt(pi * pi + os * os);
  var wn = 3.9 / (zeta * duration); // Calculate the Spring values

  this.d = 2 * zeta * wn;
  this.k = wn * wn;
}

var Spring = /*#__PURE__*/function (_Controller) {
  _inherits(Spring, _Controller);

  function Spring(duration, overshoot) {
    var _this3;

    _classCallCheck(this, Spring);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(Spring).call(this));

    _this3.duration(duration || 500).overshoot(overshoot || 0);

    return _this3;
  }

  _createClass(Spring, [{
    key: "step",
    value: function step(current, target, dt, c) {
      if (typeof current === 'string') return current;
      c.done = dt === Infinity;
      if (dt === Infinity) return target;
      if (dt === 0) return current;
      if (dt > 100) dt = 16;
      dt /= 1000; // Get the previous velocity

      var velocity = c.velocity || 0; // Apply the control to get the new position and store it

      var acceleration = -this.d * velocity - this.k * (current - target);
      var newPosition = current + velocity * dt + acceleration * dt * dt / 2; // Store the velocity

      c.velocity = velocity + acceleration * dt; // Figure out if we have converged, and if so, pass the value

      c.done = Math.abs(target - newPosition) + Math.abs(velocity) < 0.002;
      return c.done ? target : newPosition;
    }
  }]);

  return Spring;
}(Controller);

exports.Spring = Spring;
extend(Spring, {
  duration: makeSetterGetter('_duration', recalculate),
  overshoot: makeSetterGetter('_overshoot', recalculate)
});

var PID = /*#__PURE__*/function (_Controller2) {
  _inherits(PID, _Controller2);

  function PID(p, i, d, windup) {
    var _this4;

    _classCallCheck(this, PID);

    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(PID).call(this));
    p = p == null ? 0.1 : p;
    i = i == null ? 0.01 : i;
    d = d == null ? 0 : d;
    windup = windup == null ? 1000 : windup;

    _this4.p(p).i(i).d(d).windup(windup);

    return _this4;
  }

  _createClass(PID, [{
    key: "step",
    value: function step(current, target, dt, c) {
      if (typeof current === 'string') return current;
      c.done = dt === Infinity;
      if (dt === Infinity) return target;
      if (dt === 0) return current;
      var p = target - current;
      var i = (c.integral || 0) + p * dt;
      var d = (p - (c.error || 0)) / dt;
      var windup = this.windup; // antiwindup

      if (windup !== false) {
        i = Math.max(-windup, Math.min(i, windup));
      }

      c.error = p;
      c.integral = i;
      c.done = Math.abs(p) < 0.001;
      return c.done ? target : current + (this.P * p + this.I * i + this.D * d);
    }
  }]);

  return PID;
}(Controller);

exports.PID = PID;
extend(PID, {
  windup: makeSetterGetter('windup'),
  p: makeSetterGetter('P'),
  i: makeSetterGetter('I'),
  d: makeSetterGetter('D')
});
var PathArray = subClassArray('PathArray', SVGArray);
exports.PathArray = PathArray;

function pathRegReplace(a, b, c, d) {
  return c + d.replace(dots, ' .');
}

function arrayToString(a) {
  for (var i = 0, il = a.length, s = ''; i < il; i++) {
    s += a[i][0];

    if (a[i][1] != null) {
      s += a[i][1];

      if (a[i][2] != null) {
        s += ' ';
        s += a[i][2];

        if (a[i][3] != null) {
          s += ' ';
          s += a[i][3];
          s += ' ';
          s += a[i][4];

          if (a[i][5] != null) {
            s += ' ';
            s += a[i][5];
            s += ' ';
            s += a[i][6];

            if (a[i][7] != null) {
              s += ' ';
              s += a[i][7];
            }
          }
        }
      }
    }
  }

  return s + ' ';
}

var pathHandlers = {
  M: function M(c, p, p0) {
    p.x = p0.x = c[0];
    p.y = p0.y = c[1];
    return ['M', p.x, p.y];
  },
  L: function L(c, p) {
    p.x = c[0];
    p.y = c[1];
    return ['L', c[0], c[1]];
  },
  H: function H(c, p) {
    p.x = c[0];
    return ['H', c[0]];
  },
  V: function V(c, p) {
    p.y = c[0];
    return ['V', c[0]];
  },
  C: function C(c, p) {
    p.x = c[4];
    p.y = c[5];
    return ['C', c[0], c[1], c[2], c[3], c[4], c[5]];
  },
  S: function S(c, p) {
    p.x = c[2];
    p.y = c[3];
    return ['S', c[0], c[1], c[2], c[3]];
  },
  Q: function Q(c, p) {
    p.x = c[2];
    p.y = c[3];
    return ['Q', c[0], c[1], c[2], c[3]];
  },
  T: function T(c, p) {
    p.x = c[0];
    p.y = c[1];
    return ['T', c[0], c[1]];
  },
  Z: function Z(c, p, p0) {
    p.x = p0.x;
    p.y = p0.y;
    return ['Z'];
  },
  A: function A(c, p) {
    p.x = c[5];
    p.y = c[6];
    return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]];
  }
};
var mlhvqtcsaz = 'mlhvqtcsaz'.split('');

for (var i = 0, il = mlhvqtcsaz.length; i < il; ++i) {
  pathHandlers[mlhvqtcsaz[i]] = function (i) {
    return function (c, p, p0) {
      if (i === 'H') c[0] = c[0] + p.x;else if (i === 'V') c[0] = c[0] + p.y;else if (i === 'A') {
        c[5] = c[5] + p.x;
        c[6] = c[6] + p.y;
      } else {
        for (var j = 0, jl = c.length; j < jl; ++j) {
          c[j] = c[j] + (j % 2 ? p.y : p.x);
        }
      }
      return pathHandlers[i](c, p, p0);
    };
  }(mlhvqtcsaz[i].toUpperCase());
}

extend(PathArray, {
  // Convert array to string
  toString: function toString() {
    return arrayToString(this);
  },
  // Move path string
  move: function move(x, y) {
    // get bounding box of current situation
    var box = this.bbox(); // get relative offset

    x -= box.x;
    y -= box.y;

    if (!isNaN(x) && !isNaN(y)) {
      // move every point
      for (var l, i = this.length - 1; i >= 0; i--) {
        l = this[i][0];

        if (l === 'M' || l === 'L' || l === 'T') {
          this[i][1] += x;
          this[i][2] += y;
        } else if (l === 'H') {
          this[i][1] += x;
        } else if (l === 'V') {
          this[i][1] += y;
        } else if (l === 'C' || l === 'S' || l === 'Q') {
          this[i][1] += x;
          this[i][2] += y;
          this[i][3] += x;
          this[i][4] += y;

          if (l === 'C') {
            this[i][5] += x;
            this[i][6] += y;
          }
        } else if (l === 'A') {
          this[i][6] += x;
          this[i][7] += y;
        }
      }
    }

    return this;
  },
  // Resize path string
  size: function size(width, height) {
    // get bounding box of current situation
    var box = this.bbox();
    var i, l; // If the box width or height is 0 then we ignore
    // transformations on the respective axis

    box.width = box.width === 0 ? 1 : box.width;
    box.height = box.height === 0 ? 1 : box.height; // recalculate position of all points according to new size

    for (i = this.length - 1; i >= 0; i--) {
      l = this[i][0];

      if (l === 'M' || l === 'L' || l === 'T') {
        this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;
        this[i][2] = (this[i][2] - box.y) * height / box.height + box.y;
      } else if (l === 'H') {
        this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;
      } else if (l === 'V') {
        this[i][1] = (this[i][1] - box.y) * height / box.height + box.y;
      } else if (l === 'C' || l === 'S' || l === 'Q') {
        this[i][1] = (this[i][1] - box.x) * width / box.width + box.x;
        this[i][2] = (this[i][2] - box.y) * height / box.height + box.y;
        this[i][3] = (this[i][3] - box.x) * width / box.width + box.x;
        this[i][4] = (this[i][4] - box.y) * height / box.height + box.y;

        if (l === 'C') {
          this[i][5] = (this[i][5] - box.x) * width / box.width + box.x;
          this[i][6] = (this[i][6] - box.y) * height / box.height + box.y;
        }
      } else if (l === 'A') {
        // resize radii
        this[i][1] = this[i][1] * width / box.width;
        this[i][2] = this[i][2] * height / box.height; // move position values

        this[i][6] = (this[i][6] - box.x) * width / box.width + box.x;
        this[i][7] = (this[i][7] - box.y) * height / box.height + box.y;
      }
    }

    return this;
  },
  // Test if the passed path array use the same path data commands as this path array
  equalCommands: function equalCommands(pathArray) {
    var i, il, equalCommands;
    pathArray = new PathArray(pathArray);
    equalCommands = this.length === pathArray.length;

    for (i = 0, il = this.length; equalCommands && i < il; i++) {
      equalCommands = this[i][0] === pathArray[i][0];
    }

    return equalCommands;
  },
  // Make path array morphable
  morph: function morph(pathArray) {
    pathArray = new PathArray(pathArray);

    if (this.equalCommands(pathArray)) {
      this.destination = pathArray;
    } else {
      this.destination = null;
    }

    return this;
  },
  // Get morphed path array at given position
  at: function at(pos) {
    // make sure a destination is defined
    if (!this.destination) return this;
    var sourceArray = this;
    var destinationArray = this.destination.value;
    var array = [];
    var pathArray = new PathArray();
    var i, il, j, jl; // Animate has specified in the SVG spec
    // See: https://www.w3.org/TR/SVG11/paths.html#PathElement

    for (i = 0, il = sourceArray.length; i < il; i++) {
      array[i] = [sourceArray[i][0]];

      for (j = 1, jl = sourceArray[i].length; j < jl; j++) {
        array[i][j] = sourceArray[i][j] + (destinationArray[i][j] - sourceArray[i][j]) * pos;
      } // For the two flags of the elliptical arc command, the SVG spec say:
      // Flags and booleans are interpolated as fractions between zero and one, with any non-zero value considered to be a value of one/true
      // Elliptical arc command as an array followed by corresponding indexes:
      // ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]
      //   0    1   2        3                 4             5      6  7


      if (array[i][0] === 'A') {
        array[i][4] = +(array[i][4] !== 0);
        array[i][5] = +(array[i][5] !== 0);
      }
    } // Directly modify the value of a path array, this is done this way for performance


    pathArray.value = array;
    return pathArray;
  },
  // Absolutize and parse path to array
  parse: function parse() {
    var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [['M', 0, 0]]; // if it's already a patharray, no need to parse it

    if (array instanceof PathArray) return array; // prepare for parsing

    var s;
    var paramCnt = {
      M: 2,
      L: 2,
      H: 1,
      V: 1,
      C: 6,
      S: 4,
      Q: 4,
      T: 2,
      A: 7,
      Z: 0
    };

    if (typeof array === 'string') {
      array = array.replace(numbersWithDots, pathRegReplace) // convert 45.123.123 to 45.123 .123
      .replace(pathLetters, ' $& ') // put some room between letters and numbers
      .replace(hyphen, '$1 -') // add space before hyphen
      .trim() // trim
      .split(delimiter); // split into array
    } else {
      array = array.reduce(function (prev, curr) {
        return [].concat.call(prev, curr);
      }, []);
    } // array now is an array containing all parts of a path e.g. ['M', '0', '0', 'L', '30', '30' ...]


    var result = [];
    var p = new Point();
    var p0 = new Point();
    var index = 0;
    var len = array.length;

    do {
      // Test if we have a path letter
      if (isPathLetter.test(array[index])) {
        s = array[index];
        ++index; // If last letter was a move command and we got no new, it defaults to [L]ine
      } else if (s === 'M') {
        s = 'L';
      } else if (s === 'm') {
        s = 'l';
      }

      result.push(pathHandlers[s].call(null, array.slice(index, index = index + paramCnt[s.toUpperCase()]).map(parseFloat), p, p0));
    } while (len > index);

    return result;
  },
  // Get bounding box of path
  bbox: function bbox() {
    parser().path.setAttribute('d', this.toString());
    return parser.nodes.path.getBBox();
  }
});

var Morphable = /*#__PURE__*/function () {
  function Morphable(stepper) {
    _classCallCheck(this, Morphable);

    this._stepper = stepper || new Ease('-');
    this._from = null;
    this._to = null;
    this._type = null;
    this._context = null;
    this._morphObj = null;
  }

  _createClass(Morphable, [{
    key: "from",
    value: function from(val) {
      if (val == null) {
        return this._from;
      }

      this._from = this._set(val);
      return this;
    }
  }, {
    key: "to",
    value: function to(val) {
      if (val == null) {
        return this._to;
      }

      this._to = this._set(val);
      return this;
    }
  }, {
    key: "type",
    value: function type(_type) {
      // getter
      if (_type == null) {
        return this._type;
      } // setter


      this._type = _type;
      return this;
    }
  }, {
    key: "_set",
    value: function _set(value) {
      if (!this._type) {
        var type = _typeof(value);

        if (type === 'number') {
          this.type(SVGNumber);
        } else if (type === 'string') {
          if (Color.isColor(value)) {
            this.type(Color);
          } else if (delimiter.test(value)) {
            this.type(pathLetters.test(value) ? PathArray : SVGArray);
          } else if (numberAndUnit.test(value)) {
            this.type(SVGNumber);
          } else {
            this.type(NonMorphable);
          }
        } else if (morphableTypes.indexOf(value.constructor) > -1) {
          this.type(value.constructor);
        } else if (Array.isArray(value)) {
          this.type(SVGArray);
        } else if (type === 'object') {
          this.type(ObjectBag);
        } else {
          this.type(NonMorphable);
        }
      }

      var result = new this._type(value);

      if (this._type === Color) {
        result = this._to ? result[this._to[4]]() : this._from ? result[this._from[4]]() : result;
      }

      result = result.toArray();
      this._morphObj = this._morphObj || new this._type();
      this._context = this._context || Array.apply(null, Array(result.length)).map(Object).map(function (o) {
        o.done = true;
        return o;
      });
      return result;
    }
  }, {
    key: "stepper",
    value: function stepper(_stepper) {
      if (_stepper == null) return this._stepper;
      this._stepper = _stepper;
      return this;
    }
  }, {
    key: "done",
    value: function done() {
      var complete = this._context.map(this._stepper.done).reduce(function (last, curr) {
        return last && curr;
      }, true);

      return complete;
    }
  }, {
    key: "at",
    value: function at(pos) {
      var _this = this;

      return this._morphObj.fromArray(this._from.map(function (i, index) {
        return _this._stepper.step(i, _this._to[index], pos, _this._context[index], _this._context);
      }));
    }
  }]);

  return Morphable;
}();

exports.Morphable = Morphable;

var NonMorphable = /*#__PURE__*/function () {
  function NonMorphable() {
    _classCallCheck(this, NonMorphable);

    this.init.apply(this, arguments);
  }

  _createClass(NonMorphable, [{
    key: "init",
    value: function init(val) {
      val = Array.isArray(val) ? val[0] : val;
      this.value = val;
      return this;
    }
  }, {
    key: "valueOf",
    value: function valueOf() {
      return this.value;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      return [this.value];
    }
  }]);

  return NonMorphable;
}();

exports.NonMorphable = NonMorphable;

var TransformBag = /*#__PURE__*/function () {
  function TransformBag() {
    _classCallCheck(this, TransformBag);

    this.init.apply(this, arguments);
  }

  _createClass(TransformBag, [{
    key: "init",
    value: function init(obj) {
      if (Array.isArray(obj)) {
        obj = {
          scaleX: obj[0],
          scaleY: obj[1],
          shear: obj[2],
          rotate: obj[3],
          translateX: obj[4],
          translateY: obj[5],
          originX: obj[6],
          originY: obj[7]
        };
      }

      Object.assign(this, TransformBag.defaults, obj);
      return this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var v = this;
      return [v.scaleX, v.scaleY, v.shear, v.rotate, v.translateX, v.translateY, v.originX, v.originY];
    }
  }]);

  return TransformBag;
}();

exports.TransformBag = TransformBag;
TransformBag.defaults = {
  scaleX: 1,
  scaleY: 1,
  shear: 0,
  rotate: 0,
  translateX: 0,
  translateY: 0,
  originX: 0,
  originY: 0
};

var ObjectBag = /*#__PURE__*/function () {
  function ObjectBag() {
    _classCallCheck(this, ObjectBag);

    this.init.apply(this, arguments);
  }

  _createClass(ObjectBag, [{
    key: "init",
    value: function init(objOrArr) {
      this.values = [];

      if (Array.isArray(objOrArr)) {
        this.values = objOrArr;
        return;
      }

      objOrArr = objOrArr || {};
      var entries = [];

      for (var i in objOrArr) {
        entries.push([i, objOrArr[i]]);
      }

      entries.sort(function (a, b) {
        return a[0] - b[0];
      });
      this.values = entries.reduce(function (last, curr) {
        return last.concat(curr);
      }, []);
      return this;
    }
  }, {
    key: "valueOf",
    value: function valueOf() {
      var obj = {};
      var arr = this.values;

      for (var i = 0, len = arr.length; i < len; i += 2) {
        obj[arr[i]] = arr[i + 1];
      }

      return obj;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      return this.values;
    }
  }]);

  return ObjectBag;
}();

exports.ObjectBag = ObjectBag;
var morphableTypes = [NonMorphable, TransformBag, ObjectBag];

function registerMorphableType() {
  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  morphableTypes.push.apply(morphableTypes, _toConsumableArray([].concat(type)));
}

function makeMorphable() {
  extend(morphableTypes, {
    to: function to(val) {
      return new Morphable().type(this.constructor).from(this.valueOf()).to(val);
    },
    fromArray: function fromArray(arr) {
      this.init(arr);
      return this;
    }
  });
}

var Path = /*#__PURE__*/function (_Shape) {
  _inherits(Path, _Shape); // Initialize node


  function Path(node) {
    _classCallCheck(this, Path);

    return _possibleConstructorReturn(this, _getPrototypeOf(Path).call(this, nodeOrNew('path', node), node));
  } // Get array


  _createClass(Path, [{
    key: "array",
    value: function array() {
      return this._array || (this._array = new PathArray(this.attr('d')));
    } // Plot new path

  }, {
    key: "plot",
    value: function plot(d) {
      return d == null ? this.array() : this.clear().attr('d', typeof d === 'string' ? d : this._array = new PathArray(d));
    } // Clear array cache

  }, {
    key: "clear",
    value: function clear() {
      delete this._array;
      return this;
    } // Move by left top corner

  }, {
    key: "move",
    value: function move(x, y) {
      return this.attr('d', this.array().move(x, y));
    } // Move by left top corner over x-axis

  }, {
    key: "x",
    value: function x(_x) {
      return _x == null ? this.bbox().x : this.move(_x, this.bbox().y);
    } // Move by left top corner over y-axis

  }, {
    key: "y",
    value: function y(_y) {
      return _y == null ? this.bbox().y : this.move(this.bbox().x, _y);
    } // Set element size to given width and height

  }, {
    key: "size",
    value: function size(width, height) {
      var p = proportionalSize(this, width, height);
      return this.attr('d', this.array().size(p.width, p.height));
    } // Set width of element

  }, {
    key: "width",
    value: function width(_width) {
      return _width == null ? this.bbox().width : this.size(_width, this.bbox().height);
    } // Set height of element

  }, {
    key: "height",
    value: function height(_height) {
      return _height == null ? this.bbox().height : this.size(this.bbox().width, _height);
    }
  }, {
    key: "targets",
    value: function targets() {
      return baseFind('svg textpath [href*="' + this.id() + '"]');
    }
  }]);

  return Path;
}(Shape); // Define morphable array


exports.Path = Path;
Path.prototype.MorphArray = PathArray; // Add parent method

registerMethods({
  Container: {
    // Create a wrapped path element
    path: wrapWithAttrCheck(function (d) {
      // make sure plot is called as a setter
      return this.put(new Path()).plot(d || new PathArray());
    })
  }
});
register(Path, 'Path');

function array() {
  return this._array || (this._array = new PointArray(this.attr('points')));
} // Plot new path


function plot(p) {
  return p == null ? this.array() : this.clear().attr('points', typeof p === 'string' ? p : this._array = new PointArray(p));
} // Clear array cache


function clear() {
  delete this._array;
  return this;
} // Move by left top corner


function move(x, y) {
  return this.attr('points', this.array().move(x, y));
} // Set element size to given width and height


function size(width, height) {
  var p = proportionalSize(this, width, height);
  return this.attr('points', this.array().size(p.width, p.height));
}

var poly = {
  __proto__: null,
  array: array,
  plot: plot,
  clear: clear,
  move: move,
  size: size
};

var Polygon = /*#__PURE__*/function (_Shape) {
  _inherits(Polygon, _Shape); // Initialize node


  function Polygon(node) {
    _classCallCheck(this, Polygon);

    return _possibleConstructorReturn(this, _getPrototypeOf(Polygon).call(this, nodeOrNew('polygon', node), node));
  }

  return Polygon;
}(Shape);

exports.Polygon = Polygon;
registerMethods({
  Container: {
    // Create a wrapped polygon element
    polygon: wrapWithAttrCheck(function (p) {
      // make sure plot is called as a setter
      return this.put(new Polygon()).plot(p || new PointArray());
    })
  }
});
extend(Polygon, pointed);
extend(Polygon, poly);
register(Polygon, 'Polygon');

var Polyline = /*#__PURE__*/function (_Shape) {
  _inherits(Polyline, _Shape); // Initialize node


  function Polyline(node) {
    _classCallCheck(this, Polyline);

    return _possibleConstructorReturn(this, _getPrototypeOf(Polyline).call(this, nodeOrNew('polyline', node), node));
  }

  return Polyline;
}(Shape);

exports.Polyline = Polyline;
registerMethods({
  Container: {
    // Create a wrapped polygon element
    polyline: wrapWithAttrCheck(function (p) {
      // make sure plot is called as a setter
      return this.put(new Polyline()).plot(p || new PointArray());
    })
  }
});
extend(Polyline, pointed);
extend(Polyline, poly);
register(Polyline, 'Polyline');

var Rect = /*#__PURE__*/function (_Shape) {
  _inherits(Rect, _Shape); // Initialize node


  function Rect(node) {
    _classCallCheck(this, Rect);

    return _possibleConstructorReturn(this, _getPrototypeOf(Rect).call(this, nodeOrNew('rect', node), node));
  }

  return Rect;
}(Shape);

exports.Rect = Rect;
extend(Rect, {
  rx: rx,
  ry: ry
});
registerMethods({
  Container: {
    // Create a rect element
    rect: wrapWithAttrCheck(function (width, height) {
      return this.put(new Rect()).size(width, height);
    })
  }
});
register(Rect, 'Rect');
var max$3 = Math.max;
var min$4 = Math.min;
var MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded'; // `Array.prototype.splice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.splice
// with adding support of @@species

_export({
  target: 'Array',
  proto: true,
  forced: !arrayMethodHasSpeciesSupport('splice')
}, {
  splice: function splice(start, deleteCount
  /* , ...items */
  ) {
    var O = toObject(this);
    var len = toLength(O.length);
    var actualStart = toAbsoluteIndex(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;

    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min$4(max$3(toInteger(deleteCount), 0), len - actualStart);
    }

    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER$1) {
      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
    }

    A = arraySpeciesCreate(O, actualDeleteCount);

    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }

    A.length = actualDeleteCount;

    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];else delete O[to];
      }

      for (k = len; k > len - actualDeleteCount + insertCount; k--) {
        delete O[k - 1];
      }
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];else delete O[to];
      }
    }

    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }

    O.length = len - actualDeleteCount + insertCount;
    return A;
  }
});

var Queue = /*#__PURE__*/function () {
  function Queue() {
    _classCallCheck(this, Queue);

    this._first = null;
    this._last = null;
  }

  _createClass(Queue, [{
    key: "push",
    value: function push(value) {
      // An item stores an id and the provided value
      var item = value.next ? value : {
        value: value,
        next: null,
        prev: null
      }; // Deal with the queue being empty or populated

      if (this._last) {
        item.prev = this._last;
        this._last.next = item;
        this._last = item;
      } else {
        this._last = item;
        this._first = item;
      } // Return the current item


      return item;
    }
  }, {
    key: "shift",
    value: function shift() {
      // Check if we have a value
      var remove = this._first;
      if (!remove) return null; // If we do, remove it and relink things

      this._first = remove.next;
      if (this._first) this._first.prev = null;
      this._last = this._first ? this._last : null;
      return remove.value;
    } // Shows us the first item in the list

  }, {
    key: "first",
    value: function first() {
      return this._first && this._first.value;
    } // Shows us the last item in the list

  }, {
    key: "last",
    value: function last() {
      return this._last && this._last.value;
    } // Removes the item that was returned from the push

  }, {
    key: "remove",
    value: function remove(item) {
      // Relink the previous item
      if (item.prev) item.prev.next = item.next;
      if (item.next) item.next.prev = item.prev;
      if (item === this._last) this._last = item.prev;
      if (item === this._first) this._first = item.next; // Invalidate item

      item.prev = null;
      item.next = null;
    }
  }]);

  return Queue;
}();

exports.Queue = Queue;
var Animator = {
  nextDraw: null,
  frames: new Queue(),
  timeouts: new Queue(),
  immediates: new Queue(),
  timer: function timer() {
    return globals.window.performance || globals.window.Date;
  },
  transforms: [],
  frame: function frame(fn) {
    // Store the node
    var node = Animator.frames.push({
      run: fn
    }); // Request an animation frame if we don't have one

    if (Animator.nextDraw === null) {
      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
    } // Return the node so we can remove it easily


    return node;
  },
  timeout: function timeout(fn, delay) {
    delay = delay || 0; // Work out when the event should fire

    var time = Animator.timer().now() + delay; // Add the timeout to the end of the queue

    var node = Animator.timeouts.push({
      run: fn,
      time: time
    }); // Request another animation frame if we need one

    if (Animator.nextDraw === null) {
      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
    }

    return node;
  },
  immediate: function immediate(fn) {
    // Add the immediate fn to the end of the queue
    var node = Animator.immediates.push(fn); // Request another animation frame if we need one

    if (Animator.nextDraw === null) {
      Animator.nextDraw = globals.window.requestAnimationFrame(Animator._draw);
    }

    return node;
  },
  cancelFrame: function cancelFrame(node) {
    node != null && Animator.frames.remove(node);
  },
  clearTimeout: function clearTimeout(node) {
    node != null && Animator.timeouts.remove(node);
  },
  cancelImmediate: function cancelImmediate(node) {
    node != null && Animator.immediates.remove(node);
  },
  _draw: function _draw(now) {
    // Run all the timeouts we can run, if they are not ready yet, add them
    // to the end of the queue immediately! (bad timeouts!!! [sarcasm])
    var nextTimeout = null;
    var lastTimeout = Animator.timeouts.last();

    while (nextTimeout = Animator.timeouts.shift()) {
      // Run the timeout if its time, or push it to the end
      if (now >= nextTimeout.time) {
        nextTimeout.run();
      } else {
        Animator.timeouts.push(nextTimeout);
      } // If we hit the last item, we should stop shifting out more items


      if (nextTimeout === lastTimeout) break;
    } // Run all of the animation frames


    var nextFrame = null;
    var lastFrame = Animator.frames.last();

    while (nextFrame !== lastFrame && (nextFrame = Animator.frames.shift())) {
      nextFrame.run(now);
    }

    var nextImmediate = null;

    while (nextImmediate = Animator.immediates.shift()) {
      nextImmediate();
    } // If we have remaining timeouts or frames, draw until we don't anymore


    Animator.nextDraw = Animator.timeouts.first() || Animator.frames.first() ? globals.window.requestAnimationFrame(Animator._draw) : null;
  }
};
exports.Animator = Animator;

var makeSchedule = function makeSchedule(runnerInfo) {
  var start = runnerInfo.start;
  var duration = runnerInfo.runner.duration();
  var end = start + duration;
  return {
    start: start,
    duration: duration,
    end: end,
    runner: runnerInfo.runner
  };
};

var defaultSource = function defaultSource() {
  var w = globals.window;
  return (w.performance || w.Date).now();
};

var Timeline = /*#__PURE__*/function (_EventTarget) {
  _inherits(Timeline, _EventTarget); // Construct a new timeline on the given element


  function Timeline() {
    var _this;

    var timeSource = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultSource;

    _classCallCheck(this, Timeline);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Timeline).call(this));
    _this._timeSource = timeSource; // Store the timing variables

    _this._startTime = 0;
    _this._speed = 1.0; // Determines how long a runner is hold in memory. Can be a dt or true/false

    _this._persist = 0; // Keep track of the running animations and their starting parameters

    _this._nextFrame = null;
    _this._paused = true;
    _this._runners = [];
    _this._runnerIds = [];
    _this._lastRunnerId = -1;
    _this._time = 0;
    _this._lastSourceTime = 0;
    _this._lastStepTime = 0; // Make sure that step is always called in class context

    _this._step = _this._stepFn.bind(_assertThisInitialized(_this), false);
    _this._stepImmediate = _this._stepFn.bind(_assertThisInitialized(_this), true);
    return _this;
  } // schedules a runner on the timeline


  _createClass(Timeline, [{
    key: "schedule",
    value: function schedule(runner, delay, when) {
      if (runner == null) {
        return this._runners.map(makeSchedule);
      } // The start time for the next animation can either be given explicitly,
      // derived from the current timeline time or it can be relative to the
      // last start time to chain animations direclty


      var absoluteStartTime = 0;
      var endTime = this.getEndTime();
      delay = delay || 0; // Work out when to start the animation

      if (when == null || when === 'last' || when === 'after') {
        // Take the last time and increment
        absoluteStartTime = endTime;
      } else if (when === 'absolute' || when === 'start') {
        absoluteStartTime = delay;
        delay = 0;
      } else if (when === 'now') {
        absoluteStartTime = this._time;
      } else if (when === 'relative') {
        var _runnerInfo = this._runners[runner.id];

        if (_runnerInfo) {
          absoluteStartTime = _runnerInfo.start + delay;
          delay = 0;
        }
      } else {
        throw new Error('Invalid value for the "when" parameter');
      } // Manage runner


      runner.unschedule();
      runner.timeline(this);
      var persist = runner.persist();
      var runnerInfo = {
        persist: persist === null ? this._persist : persist,
        start: absoluteStartTime + delay,
        runner: runner
      };
      this._lastRunnerId = runner.id;

      this._runners.push(runnerInfo);

      this._runners.sort(function (a, b) {
        return a.start - b.start;
      });

      this._runnerIds = this._runners.map(function (info) {
        return info.runner.id;
      });

      this.updateTime()._continue();

      return this;
    } // Remove the runner from this timeline

  }, {
    key: "unschedule",
    value: function unschedule(runner) {
      var index = this._runnerIds.indexOf(runner.id);

      if (index < 0) return this;

      this._runners.splice(index, 1);

      this._runnerIds.splice(index, 1);

      runner.timeline(null);
      return this;
    } // Calculates the end of the timeline

  }, {
    key: "getEndTime",
    value: function getEndTime() {
      var lastRunnerInfo = this._runners[this._runnerIds.indexOf(this._lastRunnerId)];

      var lastDuration = lastRunnerInfo ? lastRunnerInfo.runner.duration() : 0;
      var lastStartTime = lastRunnerInfo ? lastRunnerInfo.start : 0;
      return lastStartTime + lastDuration;
    }
  }, {
    key: "getEndTimeOfTimeline",
    value: function getEndTimeOfTimeline() {
      var lastEndTime = 0;

      for (var i = 0; i < this._runners.length; i++) {
        var runnerInfo = this._runners[i];
        var duration = runnerInfo ? runnerInfo.runner.duration() : 0;
        var startTime = runnerInfo ? runnerInfo.start : 0;
        var endTime = startTime + duration;

        if (endTime > lastEndTime) {
          lastEndTime = endTime;
        }
      }

      return lastEndTime;
    } // Makes sure, that after pausing the time doesn't jump

  }, {
    key: "updateTime",
    value: function updateTime() {
      if (!this.active()) {
        this._lastSourceTime = this._timeSource();
      }

      return this;
    }
  }, {
    key: "play",
    value: function play() {
      // Now make sure we are not paused and continue the animation
      this._paused = false;
      return this.updateTime()._continue();
    }
  }, {
    key: "pause",
    value: function pause() {
      this._paused = true;
      return this._continue();
    }
  }, {
    key: "stop",
    value: function stop() {
      // Go to start and pause
      this.time(0);
      return this.pause();
    }
  }, {
    key: "finish",
    value: function finish() {
      // Go to end and pause
      this.time(this.getEndTimeOfTimeline() + 1);
      return this.pause();
    }
  }, {
    key: "speed",
    value: function speed(_speed) {
      if (_speed == null) return this._speed;
      this._speed = _speed;
      return this;
    }
  }, {
    key: "reverse",
    value: function reverse(yes) {
      var currentSpeed = this.speed();
      if (yes == null) return this.speed(-currentSpeed);
      var positive = Math.abs(currentSpeed);
      return this.speed(yes ? positive : -positive);
    }
  }, {
    key: "seek",
    value: function seek(dt) {
      return this.time(this._time + dt);
    }
  }, {
    key: "time",
    value: function time(_time) {
      if (_time == null) return this._time;
      this._time = _time;
      return this._continue(true);
    }
  }, {
    key: "persist",
    value: function persist(dtOrForever) {
      if (dtOrForever == null) return this._persist;
      this._persist = dtOrForever;
      return this;
    }
  }, {
    key: "source",
    value: function source(fn) {
      if (fn == null) return this._timeSource;
      this._timeSource = fn;
      return this;
    }
  }, {
    key: "_stepFn",
    value: function _stepFn() {
      var immediateStep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false; // Get the time delta from the last time and update the time

      var time = this._timeSource();

      var dtSource = time - this._lastSourceTime;
      if (immediateStep) dtSource = 0;
      var dtTime = this._speed * dtSource + (this._time - this._lastStepTime);
      this._lastSourceTime = time; // Only update the time if we use the timeSource.
      // Otherwise use the current time

      if (!immediateStep) {
        // Update the time
        this._time += dtTime;
        this._time = this._time < 0 ? 0 : this._time;
      }

      this._lastStepTime = this._time;
      this.fire('time', this._time); // This is for the case that the timeline was seeked so that the time
      // is now before the startTime of the runner. Thats why we need to set
      // the runner to position 0
      // FIXME:
      // However, reseting in insertion order leads to bugs. Considering the case,
      // where 2 runners change the same attriute but in different times,
      // reseting both of them will lead to the case where the later defined
      // runner always wins the reset even if the other runner started earlier
      // and therefore should win the attribute battle
      // this can be solved by reseting them backwards

      for (var k = this._runners.length; k--;) {
        // Get and run the current runner and ignore it if its inactive
        var runnerInfo = this._runners[k];
        var runner = runnerInfo.runner; // Make sure that we give the actual difference
        // between runner start time and now

        var dtToStart = this._time - runnerInfo.start; // Dont run runner if not started yet
        // and try to reset it

        if (dtToStart <= 0) {
          runner.reset();
        }
      } // Run all of the runners directly


      var runnersLeft = false;

      for (var i = 0, len = this._runners.length; i < len; i++) {
        // Get and run the current runner and ignore it if its inactive
        var _runnerInfo2 = this._runners[i];
        var _runner = _runnerInfo2.runner;
        var dt = dtTime; // Make sure that we give the actual difference
        // between runner start time and now

        var _dtToStart = this._time - _runnerInfo2.start; // Dont run runner if not started yet


        if (_dtToStart <= 0) {
          runnersLeft = true;
          continue;
        } else if (_dtToStart < dt) {
          // Adjust dt to make sure that animation is on point
          dt = _dtToStart;
        }

        if (!_runner.active()) continue; // If this runner is still going, signal that we need another animation
        // frame, otherwise, remove the completed runner

        var finished = _runner.step(dt).done;

        if (!finished) {
          runnersLeft = true; // continue
        } else if (_runnerInfo2.persist !== true) {
          // runner is finished. And runner might get removed
          var endTime = _runner.duration() - _runner.time() + this._time;

          if (endTime + _runnerInfo2.persist < this._time) {
            // Delete runner and correct index
            _runner.unschedule();

            --i;
            --len;
          }
        }
      } // Basically: we continue when there are runners right from us in time
      // when -->, and when runners are left from us when <--


      if (runnersLeft && !(this._speed < 0 && this._time === 0) || this._runnerIds.length && this._speed < 0 && this._time > 0) {
        this._continue();
      } else {
        this.pause();
        this.fire('finished');
      }

      return this;
    } // Checks if we are running and continues the animation

  }, {
    key: "_continue",
    value: function _continue() {
      var immediateStep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      Animator.cancelFrame(this._nextFrame);
      this._nextFrame = null;
      if (immediateStep) return this._stepImmediate();
      if (this._paused) return this;
      this._nextFrame = Animator.frame(this._step);
      return this;
    }
  }, {
    key: "active",
    value: function active() {
      return !!this._nextFrame;
    }
  }]);

  return Timeline;
}(EventTarget);

exports.Timeline = Timeline;
registerMethods({
  Element: {
    timeline: function timeline(_timeline) {
      if (_timeline == null) {
        this._timeline = this._timeline || new Timeline();
        return this._timeline;
      } else {
        this._timeline = _timeline;
        return this;
      }
    }
  }
});

function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$2(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

var Runner = /*#__PURE__*/function (_EventTarget) {
  _inherits(Runner, _EventTarget);

  function Runner(options) {
    var _this;

    _classCallCheck(this, Runner);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Runner).call(this)); // Store a unique id on the runner, so that we can identify it later

    _this.id = Runner.id++; // Ensure a default value

    options = options == null ? timeline.duration : options; // Ensure that we get a controller

    options = typeof options === 'function' ? new Controller(options) : options; // Declare all of the variables

    _this._element = null;
    _this._timeline = null;
    _this.done = false;
    _this._queue = []; // Work out the stepper and the duration

    _this._duration = typeof options === 'number' && options;
    _this._isDeclarative = options instanceof Controller;
    _this._stepper = _this._isDeclarative ? options : new Ease(); // We copy the current values from the timeline because they can change

    _this._history = {}; // Store the state of the runner

    _this.enabled = true;
    _this._time = 0;
    _this._lastTime = 0; // At creation, the runner is in reseted state

    _this._reseted = true; // Save transforms applied to this runner

    _this.transforms = new Matrix();
    _this.transformId = 1; // Looping variables

    _this._haveReversed = false;
    _this._reverse = false;
    _this._loopsDone = 0;
    _this._swing = false;
    _this._wait = 0;
    _this._times = 1;
    _this._frameId = null; // Stores how long a runner is stored after beeing done

    _this._persist = _this._isDeclarative ? true : null;
    return _this;
  }
  /*
  Runner Definitions
  ==================
  These methods help us define the runtime behaviour of the Runner or they
  help us make new runners from the current runner
  */


  _createClass(Runner, [{
    key: "element",
    value: function element(_element) {
      if (_element == null) return this._element;
      this._element = _element;

      _element._prepareRunner();

      return this;
    }
  }, {
    key: "timeline",
    value: function timeline(_timeline) {
      // check explicitly for undefined so we can set the timeline to null
      if (typeof _timeline === 'undefined') return this._timeline;
      this._timeline = _timeline;
      return this;
    }
  }, {
    key: "animate",
    value: function animate(duration, delay, when) {
      var o = Runner.sanitise(duration, delay, when);
      var runner = new Runner(o.duration);
      if (this._timeline) runner.timeline(this._timeline);
      if (this._element) runner.element(this._element);
      return runner.loop(o).schedule(o.delay, o.when);
    }
  }, {
    key: "schedule",
    value: function schedule(timeline, delay, when) {
      // The user doesn't need to pass a timeline if we already have one
      if (!(timeline instanceof Timeline)) {
        when = delay;
        delay = timeline;
        timeline = this.timeline();
      } // If there is no timeline, yell at the user...


      if (!timeline) {
        throw Error('Runner cannot be scheduled without timeline');
      } // Schedule the runner on the timeline provided


      timeline.schedule(this, delay, when);
      return this;
    }
  }, {
    key: "unschedule",
    value: function unschedule() {
      var timeline = this.timeline();
      timeline && timeline.unschedule(this);
      return this;
    }
  }, {
    key: "loop",
    value: function loop(times, swing, wait) {
      // Deal with the user passing in an object
      if (_typeof(times) === 'object') {
        swing = times.swing;
        wait = times.wait;
        times = times.times;
      } // Sanitise the values and store them


      this._times = times || Infinity;
      this._swing = swing || false;
      this._wait = wait || 0; // Allow true to be passed

      if (this._times === true) {
        this._times = Infinity;
      }

      return this;
    }
  }, {
    key: "delay",
    value: function delay(_delay) {
      return this.animate(0, _delay);
    }
    /*
    Basic Functionality
    ===================
    These methods allow us to attach basic functions to the runner directly
    */

  }, {
    key: "queue",
    value: function queue(initFn, runFn, retargetFn, isTransform) {
      this._queue.push({
        initialiser: initFn || noop,
        runner: runFn || noop,
        retarget: retargetFn,
        isTransform: isTransform,
        initialised: false,
        finished: false
      });

      var timeline = this.timeline();
      timeline && this.timeline()._continue();
      return this;
    }
  }, {
    key: "during",
    value: function during(fn) {
      return this.queue(null, fn);
    }
  }, {
    key: "after",
    value: function after(fn) {
      return this.on('finished', fn);
    }
    /*
    Runner animation methods
    ========================
    Control how the animation plays
    */

  }, {
    key: "time",
    value: function time(_time) {
      if (_time == null) {
        return this._time;
      }

      var dt = _time - this._time;
      this.step(dt);
      return this;
    }
  }, {
    key: "duration",
    value: function duration() {
      return this._times * (this._wait + this._duration) - this._wait;
    }
  }, {
    key: "loops",
    value: function loops(p) {
      var loopDuration = this._duration + this._wait;

      if (p == null) {
        var loopsDone = Math.floor(this._time / loopDuration);
        var relativeTime = this._time - loopsDone * loopDuration;
        var position = relativeTime / this._duration;
        return Math.min(loopsDone + position, this._times);
      }

      var whole = Math.floor(p);
      var partial = p % 1;
      var time = loopDuration * whole + this._duration * partial;
      return this.time(time);
    }
  }, {
    key: "persist",
    value: function persist(dtOrForever) {
      if (dtOrForever == null) return this._persist;
      this._persist = dtOrForever;
      return this;
    }
  }, {
    key: "position",
    value: function position(p) {
      // Get all of the variables we need
      var x = this._time;
      var d = this._duration;
      var w = this._wait;
      var t = this._times;
      var s = this._swing;
      var r = this._reverse;
      var position;

      if (p == null) {
        /*
        This function converts a time to a position in the range [0, 1]
        The full explanation can be found in this desmos demonstration
          https://www.desmos.com/calculator/u4fbavgche
        The logic is slightly simplified here because we can use booleans
        */
        // Figure out the value without thinking about the start or end time
        var f = function f(x) {
          var swinging = s * Math.floor(x % (2 * (w + d)) / (w + d));
          var backwards = swinging && !r || !swinging && r;
          var uncliped = Math.pow(-1, backwards) * (x % (w + d)) / d + backwards;
          var clipped = Math.max(Math.min(uncliped, 1), 0);
          return clipped;
        }; // Figure out the value by incorporating the start time


        var endTime = t * (w + d) - w;
        position = x <= 0 ? Math.round(f(1e-5)) : x < endTime ? f(x) : Math.round(f(endTime - 1e-5));
        return position;
      } // Work out the loops done and add the position to the loops done


      var loopsDone = Math.floor(this.loops());
      var swingForward = s && loopsDone % 2 === 0;
      var forwards = swingForward && !r || r && swingForward;
      position = loopsDone + (forwards ? p : 1 - p);
      return this.loops(position);
    }
  }, {
    key: "progress",
    value: function progress(p) {
      if (p == null) {
        return Math.min(1, this._time / this.duration());
      }

      return this.time(p * this.duration());
    }
  }, {
    key: "step",
    value: function step(dt) {
      // If we are inactive, this stepper just gets skipped
      if (!this.enabled) return this; // Update the time and get the new position

      dt = dt == null ? 16 : dt;
      this._time += dt;
      var position = this.position(); // Figure out if we need to run the stepper in this frame

      var running = this._lastPosition !== position && this._time >= 0;
      this._lastPosition = position; // Figure out if we just started

      var duration = this.duration();
      var justStarted = this._lastTime <= 0 && this._time > 0;
      var justFinished = this._lastTime < duration && this._time >= duration;
      this._lastTime = this._time;

      if (justStarted) {
        this.fire('start', this);
      } // Work out if the runner is finished set the done flag here so animations
      // know, that they are running in the last step (this is good for
      // transformations which can be merged)


      var declarative = this._isDeclarative;
      this.done = !declarative && !justFinished && this._time >= duration; // Runner is running. So its not in reseted state anymore

      this._reseted = false; // Call initialise and the run function

      if (running || declarative) {
        this._initialise(running); // clear the transforms on this runner so they dont get added again and again


        this.transforms = new Matrix();

        var converged = this._run(declarative ? dt : position);

        this.fire('step', this);
      } // correct the done flag here
      // declaritive animations itself know when they converged


      this.done = this.done || converged && declarative;

      if (justFinished) {
        this.fire('finished', this);
      }

      return this;
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this._reseted) return this;
      this.time(0);
      this._reseted = true;
      return this;
    }
  }, {
    key: "finish",
    value: function finish() {
      return this.step(Infinity);
    }
  }, {
    key: "reverse",
    value: function reverse(_reverse) {
      this._reverse = _reverse == null ? !this._reverse : _reverse;
      return this;
    }
  }, {
    key: "ease",
    value: function ease(fn) {
      this._stepper = new Ease(fn);
      return this;
    }
  }, {
    key: "active",
    value: function active(enabled) {
      if (enabled == null) return this.enabled;
      this.enabled = enabled;
      return this;
    }
    /*
    Private Methods
    ===============
    Methods that shouldn't be used externally
    */
    // Save a morpher to the morpher list so that we can retarget it later

  }, {
    key: "_rememberMorpher",
    value: function _rememberMorpher(method, morpher) {
      this._history[method] = {
        morpher: morpher,
        caller: this._queue[this._queue.length - 1]
      }; // We have to resume the timeline in case a controller
      // is already done without beeing ever run
      // This can happen when e.g. this is done:
      //    anim = el.animate(new SVG.Spring)
      // and later
      //    anim.move(...)

      if (this._isDeclarative) {
        var timeline = this.timeline();
        timeline && timeline.play();
      }
    } // Try to set the target for a morpher if the morpher exists, otherwise
    // do nothing and return false

  }, {
    key: "_tryRetarget",
    value: function _tryRetarget(method, target, extra) {
      if (this._history[method]) {
        // if the last method wasnt even initialised, throw it away
        if (!this._history[method].caller.initialised) {
          var index = this._queue.indexOf(this._history[method].caller);

          this._queue.splice(index, 1);

          return false;
        } // for the case of transformations, we use the special retarget function
        // which has access to the outer scope


        if (this._history[method].caller.retarget) {
          this._history[method].caller.retarget(target, extra); // for everything else a simple morpher change is sufficient

        } else {
          this._history[method].morpher.to(target);
        }

        this._history[method].caller.finished = false;
        var timeline = this.timeline();
        timeline && timeline.play();
        return true;
      }

      return false;
    } // Run each initialise function in the runner if required

  }, {
    key: "_initialise",
    value: function _initialise(running) {
      // If we aren't running, we shouldn't initialise when not declarative
      if (!running && !this._isDeclarative) return; // Loop through all of the initialisers

      for (var i = 0, len = this._queue.length; i < len; ++i) {
        // Get the current initialiser
        var current = this._queue[i]; // Determine whether we need to initialise

        var needsIt = this._isDeclarative || !current.initialised && running;
        running = !current.finished; // Call the initialiser if we need to

        if (needsIt && running) {
          current.initialiser.call(this);
          current.initialised = true;
        }
      }
    } // Run each run function for the position or dt given

  }, {
    key: "_run",
    value: function _run(positionOrDt) {
      // Run all of the _queue directly
      var allfinished = true;

      for (var i = 0, len = this._queue.length; i < len; ++i) {
        // Get the current function to run
        var current = this._queue[i]; // Run the function if its not finished, we keep track of the finished
        // flag for the sake of declarative _queue

        var converged = current.runner.call(this, positionOrDt);
        current.finished = current.finished || converged === true;
        allfinished = allfinished && current.finished;
      } // We report when all of the constructors are finished


      return allfinished;
    }
  }, {
    key: "addTransform",
    value: function addTransform(transform, index) {
      this.transforms.lmultiplyO(transform);
      return this;
    }
  }, {
    key: "clearTransform",
    value: function clearTransform() {
      this.transforms = new Matrix();
      return this;
    } // TODO: Keep track of all transformations so that deletion is faster

  }, {
    key: "clearTransformsFromQueue",
    value: function clearTransformsFromQueue() {
      if (!this.done || !this._timeline || !this._timeline._runnerIds.includes(this.id)) {
        this._queue = this._queue.filter(function (item) {
          return !item.isTransform;
        });
      }
    }
  }], [{
    key: "sanitise",
    value: function sanitise(duration, delay, when) {
      // Initialise the default parameters
      var times = 1;
      var swing = false;
      var wait = 0;
      duration = duration || timeline.duration;
      delay = delay || timeline.delay;
      when = when || 'last'; // If we have an object, unpack the values

      if (_typeof(duration) === 'object' && !(duration instanceof Stepper)) {
        delay = duration.delay || delay;
        when = duration.when || when;
        swing = duration.swing || swing;
        times = duration.times || times;
        wait = duration.wait || wait;
        duration = duration.duration || timeline.duration;
      }

      return {
        duration: duration,
        delay: delay,
        swing: swing,
        times: times,
        wait: wait,
        when: when
      };
    }
  }]);

  return Runner;
}(EventTarget);

exports.Runner = Runner;
Runner.id = 0;

var FakeRunner = /*#__PURE__*/function () {
  function FakeRunner() {
    var transforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Matrix();
    var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
    var done = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

    _classCallCheck(this, FakeRunner);

    this.transforms = transforms;
    this.id = id;
    this.done = done;
  }

  _createClass(FakeRunner, [{
    key: "clearTransformsFromQueue",
    value: function clearTransformsFromQueue() {}
  }]);

  return FakeRunner;
}();

extend([Runner, FakeRunner], {
  mergeWith: function mergeWith(runner) {
    return new FakeRunner(runner.transforms.lmultiply(this.transforms), runner.id);
  }
}); // FakeRunner.emptyRunner = new FakeRunner()

var lmultiply = function lmultiply(last, curr) {
  return last.lmultiplyO(curr);
};

var getRunnerTransform = function getRunnerTransform(runner) {
  return runner.transforms;
};

function mergeTransforms() {
  // Find the matrix to apply to the element and apply it
  var runners = this._transformationRunners.runners;
  var netTransform = runners.map(getRunnerTransform).reduce(lmultiply, new Matrix());
  this.transform(netTransform);

  this._transformationRunners.merge();

  if (this._transformationRunners.length() === 1) {
    this._frameId = null;
  }
}

var RunnerArray = /*#__PURE__*/function () {
  function RunnerArray() {
    _classCallCheck(this, RunnerArray);

    this.runners = [];
    this.ids = [];
  }

  _createClass(RunnerArray, [{
    key: "add",
    value: function add(runner) {
      if (this.runners.includes(runner)) return;
      var id = runner.id + 1;
      this.runners.push(runner);
      this.ids.push(id);
      return this;
    }
  }, {
    key: "getByID",
    value: function getByID(id) {
      return this.runners[this.ids.indexOf(id + 1)];
    }
  }, {
    key: "remove",
    value: function remove(id) {
      var index = this.ids.indexOf(id + 1);
      this.ids.splice(index, 1);
      this.runners.splice(index, 1);
      return this;
    }
  }, {
    key: "merge",
    value: function merge() {
      var _this2 = this;

      var lastRunner = null;
      this.runners.forEach(function (runner, i) {
        var condition = lastRunner && runner.done && lastRunner.done // don't merge runner when persisted on timeline
        && (!runner._timeline || !runner._timeline._runnerIds.includes(runner.id)) && (!lastRunner._timeline || !lastRunner._timeline._runnerIds.includes(lastRunner.id));

        if (condition) {
          // the +1 happens in the function
          _this2.remove(runner.id);

          _this2.edit(lastRunner.id, runner.mergeWith(lastRunner));
        }

        lastRunner = runner;
      });
      return this;
    }
  }, {
    key: "edit",
    value: function edit(id, newRunner) {
      var index = this.ids.indexOf(id + 1);
      this.ids.splice(index, 1, id + 1);
      this.runners.splice(index, 1, newRunner);
      return this;
    }
  }, {
    key: "length",
    value: function length() {
      return this.ids.length;
    }
  }, {
    key: "clearBefore",
    value: function clearBefore(id) {
      var deleteCnt = this.ids.indexOf(id + 1) || 1;
      this.ids.splice(0, deleteCnt, 0);
      this.runners.splice(0, deleteCnt, new FakeRunner()).forEach(function (r) {
        return r.clearTransformsFromQueue();
      });
      return this;
    }
  }]);

  return RunnerArray;
}();

registerMethods({
  Element: {
    animate: function animate(duration, delay, when) {
      var o = Runner.sanitise(duration, delay, when);
      var timeline = this.timeline();
      return new Runner(o.duration).loop(o).element(this).timeline(timeline.play()).schedule(o.delay, o.when);
    },
    delay: function delay(by, when) {
      return this.animate(0, by, when);
    },
    // this function searches for all runners on the element and deletes the ones
    // which run before the current one. This is because absolute transformations
    // overwfrite anything anyway so there is no need to waste time computing
    // other runners
    _clearTransformRunnersBefore: function _clearTransformRunnersBefore(currentRunner) {
      this._transformationRunners.clearBefore(currentRunner.id);
    },
    _currentTransform: function _currentTransform(current) {
      return this._transformationRunners.runners // we need the equal sign here to make sure, that also transformations
      // on the same runner which execute before the current transformation are
      // taken into account
      .filter(function (runner) {
        return runner.id <= current.id;
      }).map(getRunnerTransform).reduce(lmultiply, new Matrix());
    },
    _addRunner: function _addRunner(runner) {
      this._transformationRunners.add(runner); // Make sure that the runner merge is executed at the very end of
      // all Animator functions. Thats why we use immediate here to execute
      // the merge right after all frames are run


      Animator.cancelImmediate(this._frameId);
      this._frameId = Animator.immediate(mergeTransforms.bind(this));
    },
    _prepareRunner: function _prepareRunner() {
      if (this._frameId == null) {
        this._transformationRunners = new RunnerArray().add(new FakeRunner(new Matrix(this)));
      }
    }
  }
});
extend(Runner, {
  attr: function attr(a, v) {
    return this.styleAttr('attr', a, v);
  },
  // Add animatable styles
  css: function css(s, v) {
    return this.styleAttr('css', s, v);
  },
  styleAttr: function styleAttr(type, name, val) {
    // apply attributes individually
    if (_typeof(name) === 'object') {
      for (var key in name) {
        this.styleAttr(type, key, name[key]);
      }

      return this;
    }

    var morpher = new Morphable(this._stepper).to(val);
    this.queue(function () {
      morpher = morpher.from(this.element()[type](name));
    }, function (pos) {
      this.element()[type](name, morpher.at(pos));
      return morpher.done();
    });
    return this;
  },
  zoom: function zoom(level, point) {
    if (this._tryRetarget('zoom', to, point)) return this;
    var morpher = new Morphable(this._stepper).to(new SVGNumber(level));
    this.queue(function () {
      morpher = morpher.from(this.element().zoom());
    }, function (pos) {
      this.element().zoom(morpher.at(pos), point);
      return morpher.done();
    }, function (newLevel, newPoint) {
      point = newPoint;
      morpher.to(newLevel);
    });

    this._rememberMorpher('zoom', morpher);

    return this;
  },

  /**
   ** absolute transformations
   **/
  //
  // M v -----|-----(D M v = F v)------|----->  T v
  //
  // 1. define the final state (T) and decompose it (once)
  //    t = [tx, ty, the, lam, sy, sx]
  // 2. on every frame: pull the current state of all previous transforms
  //    (M - m can change)
  //   and then write this as m = [tx0, ty0, the0, lam0, sy0, sx0]
  // 3. Find the interpolated matrix F(pos) = m + pos * (t - m)
  //   - Note F(0) = M
  //   - Note F(1) = T
  // 4. Now you get the delta matrix as a result: D = F * inv(M)
  transform: function transform(transforms, relative, affine) {
    // If we have a declarative function, we should retarget it if possible
    relative = transforms.relative || relative;

    if (this._isDeclarative && !relative && this._tryRetarget('transform', transforms)) {
      return this;
    } // Parse the parameters


    var isMatrix = Matrix.isMatrixLike(transforms);
    affine = transforms.affine != null ? transforms.affine : affine != null ? affine : !isMatrix; // Create a morepher and set its type

    var morpher = new Morphable(this._stepper).type(affine ? TransformBag : Matrix);
    var origin;
    var element;
    var current;
    var currentAngle;
    var startTransform;

    function setup() {
      // make sure element and origin is defined
      element = element || this.element();
      origin = origin || getOrigin(transforms, element);
      startTransform = new Matrix(relative ? undefined : element); // add the runner to the element so it can merge transformations

      element._addRunner(this); // Deactivate all transforms that have run so far if we are absolute


      if (!relative) {
        element._clearTransformRunnersBefore(this);
      }
    }

    function run(pos) {
      // clear all other transforms before this in case something is saved
      // on this runner. We are absolute. We dont need these!
      if (!relative) this.clearTransform();

      var _transform = new Point(origin).transform(element._currentTransform(this)),
          x = _transform.x,
          y = _transform.y;

      var target = new Matrix(_objectSpread$1({}, transforms, {
        origin: [x, y]
      }));
      var start = this._isDeclarative && current ? current : startTransform;

      if (affine) {
        target = target.decompose(x, y);
        start = start.decompose(x, y); // Get the current and target angle as it was set

        var rTarget = target.rotate;
        var rCurrent = start.rotate; // Figure out the shortest path to rotate directly

        var possibilities = [rTarget - 360, rTarget, rTarget + 360];
        var distances = possibilities.map(function (a) {
          return Math.abs(a - rCurrent);
        });
        var shortest = Math.min.apply(Math, _toConsumableArray(distances));
        var index = distances.indexOf(shortest);
        target.rotate = possibilities[index];
      }

      if (relative) {
        // we have to be careful here not to overwrite the rotation
        // with the rotate method of Matrix
        if (!isMatrix) {
          target.rotate = transforms.rotate || 0;
        }

        if (this._isDeclarative && currentAngle) {
          start.rotate = currentAngle;
        }
      }

      morpher.from(start);
      morpher.to(target);
      var affineParameters = morpher.at(pos);
      currentAngle = affineParameters.rotate;
      current = new Matrix(affineParameters);
      this.addTransform(current);

      element._addRunner(this);

      return morpher.done();
    }

    function retarget(newTransforms) {
      // only get a new origin if it changed since the last call
      if ((newTransforms.origin || 'center').toString() !== (transforms.origin || 'center').toString()) {
        origin = getOrigin(transforms, element);
      } // overwrite the old transformations with the new ones


      transforms = _objectSpread$1({}, newTransforms, {
        origin: origin
      });
    }

    this.queue(setup, run, retarget, true);
    this._isDeclarative && this._rememberMorpher('transform', morpher);
    return this;
  },
  // Animatable x-axis
  x: function x(_x, relative) {
    return this._queueNumber('x', _x);
  },
  // Animatable y-axis
  y: function y(_y) {
    return this._queueNumber('y', _y);
  },
  dx: function dx() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return this._queueNumberDelta('x', x);
  },
  dy: function dy() {
    var y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return this._queueNumberDelta('y', y);
  },
  dmove: function dmove(x, y) {
    return this.dx(x).dy(y);
  },
  _queueNumberDelta: function _queueNumberDelta(method, to) {
    to = new SVGNumber(to); // Try to change the target if we have this method already registerd

    if (this._tryRetarget(method, to)) return this; // Make a morpher and queue the animation

    var morpher = new Morphable(this._stepper).to(to);
    var from = null;
    this.queue(function () {
      from = this.element()[method]();
      morpher.from(from);
      morpher.to(from + to);
    }, function (pos) {
      this.element()[method](morpher.at(pos));
      return morpher.done();
    }, function (newTo) {
      morpher.to(from + new SVGNumber(newTo));
    }); // Register the morpher so that if it is changed again, we can retarget it

    this._rememberMorpher(method, morpher);

    return this;
  },
  _queueObject: function _queueObject(method, to) {
    // Try to change the target if we have this method already registerd
    if (this._tryRetarget(method, to)) return this; // Make a morpher and queue the animation

    var morpher = new Morphable(this._stepper).to(to);
    this.queue(function () {
      morpher.from(this.element()[method]());
    }, function (pos) {
      this.element()[method](morpher.at(pos));
      return morpher.done();
    }); // Register the morpher so that if it is changed again, we can retarget it

    this._rememberMorpher(method, morpher);

    return this;
  },
  _queueNumber: function _queueNumber(method, value) {
    return this._queueObject(method, new SVGNumber(value));
  },
  // Animatable center x-axis
  cx: function cx(x) {
    return this._queueNumber('cx', x);
  },
  // Animatable center y-axis
  cy: function cy(y) {
    return this._queueNumber('cy', y);
  },
  // Add animatable move
  move: function move(x, y) {
    return this.x(x).y(y);
  },
  // Add animatable center
  center: function center(x, y) {
    return this.cx(x).cy(y);
  },
  // Add animatable size
  size: function size(width, height) {
    // animate bbox based size for all other elements
    var box;

    if (!width || !height) {
      box = this._element.bbox();
    }

    if (!width) {
      width = box.width / box.height * height;
    }

    if (!height) {
      height = box.height / box.width * width;
    }

    return this.width(width).height(height);
  },
  // Add animatable width
  width: function width(_width) {
    return this._queueNumber('width', _width);
  },
  // Add animatable height
  height: function height(_height) {
    return this._queueNumber('height', _height);
  },
  // Add animatable plot
  plot: function plot(a, b, c, d) {
    // Lines can be plotted with 4 arguments
    if (arguments.length === 4) {
      return this.plot([a, b, c, d]);
    }

    if (this._tryRetarget('plot', a)) return this;
    var morpher = new Morphable(this._stepper).type(this._element.MorphArray).to(a);
    this.queue(function () {
      morpher.from(this._element.array());
    }, function (pos) {
      this._element.plot(morpher.at(pos));

      return morpher.done();
    });

    this._rememberMorpher('plot', morpher);

    return this;
  },
  // Add leading method
  leading: function leading(value) {
    return this._queueNumber('leading', value);
  },
  // Add animatable viewbox
  viewbox: function viewbox(x, y, width, height) {
    return this._queueObject('viewbox', new Box(x, y, width, height));
  },
  update: function update(o) {
    if (_typeof(o) !== 'object') {
      return this.update({
        offset: arguments[0],
        color: arguments[1],
        opacity: arguments[2]
      });
    }

    if (o.opacity != null) this.attr('stop-opacity', o.opacity);
    if (o.color != null) this.attr('stop-color', o.color);
    if (o.offset != null) this.attr('offset', o.offset);
    return this;
  }
});
extend(Runner, {
  rx: rx,
  ry: ry,
  from: from,
  to: to
});
register(Runner, 'Runner');

var Svg = /*#__PURE__*/function (_Container) {
  _inherits(Svg, _Container);

  function Svg(node) {
    var _this;

    _classCallCheck(this, Svg);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Svg).call(this, nodeOrNew('svg', node), node));

    _this.namespace();

    return _this;
  }

  _createClass(Svg, [{
    key: "isRoot",
    value: function isRoot() {
      return !this.node.parentNode || !(this.node.parentNode instanceof globals.window.SVGElement) || this.node.parentNode.nodeName === '#document';
    } // Check if this is a root svg
    // If not, call docs from this element

  }, {
    key: "root",
    value: function root() {
      if (this.isRoot()) return this;
      return _get(_getPrototypeOf(Svg.prototype), "root", this).call(this);
    } // Add namespaces

  }, {
    key: "namespace",
    value: function namespace() {
      if (!this.isRoot()) return this.root().namespace();
      return this.attr({
        xmlns: ns,
        version: '1.1'
      }).attr('xmlns:xlink', xlink, xmlns).attr('xmlns:svgjs', svgjs, xmlns);
    } // Creates and returns defs element

  }, {
    key: "defs",
    value: function defs() {
      if (!this.isRoot()) return this.root().defs();
      return adopt(this.node.querySelector('defs')) || this.put(new Defs());
    } // custom parent method

  }, {
    key: "parent",
    value: function parent(type) {
      if (this.isRoot()) {
        return this.node.parentNode.nodeName === '#document' ? null : adopt(this.node.parentNode);
      }

      return _get(_getPrototypeOf(Svg.prototype), "parent", this).call(this, type);
    }
  }, {
    key: "clear",
    value: function clear() {
      // remove children
      while (this.node.hasChildNodes()) {
        this.node.removeChild(this.node.lastChild);
      } // remove defs reference


      delete this._defs;
      return this;
    }
  }]);

  return Svg;
}(Container);

exports.Svg = Svg;
registerMethods({
  Container: {
    // Create nested svg document
    nested: wrapWithAttrCheck(function () {
      return this.put(new Svg());
    })
  }
});
register(Svg, 'Svg', true);

var _Symbol = /*#__PURE__*/function (_Container) {
  _inherits(_Symbol, _Container); // Initialize node


  function _Symbol(node) {
    _classCallCheck(this, _Symbol);

    return _possibleConstructorReturn(this, _getPrototypeOf(_Symbol).call(this, nodeOrNew('symbol', node), node));
  }

  return _Symbol;
}(Container);

exports.Symbol = _Symbol;
registerMethods({
  Container: {
    symbol: wrapWithAttrCheck(function () {
      return this.put(new _Symbol());
    })
  }
});
register(_Symbol, 'Symbol');

function plain(text) {
  // clear if build mode is disabled
  if (this._build === false) {
    this.clear();
  } // create text node


  this.node.appendChild(globals.document.createTextNode(text));
  return this;
} // Get length of text element


function length() {
  return this.node.getComputedTextLength();
}

var textable = {
  __proto__: null,
  plain: plain,
  length: length
};

var Text = /*#__PURE__*/function (_Shape) {
  _inherits(Text, _Shape); // Initialize node


  function Text(node) {
    var _this;

    _classCallCheck(this, Text);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Text).call(this, nodeOrNew('text', node), node));
    _this.dom.leading = new SVGNumber(1.3); // store leading value for rebuilding

    _this._rebuild = true; // enable automatic updating of dy values

    _this._build = false; // disable build mode for adding multiple lines

    return _this;
  } // Move over x-axis
  // Text is moved its bounding box
  // text-anchor does NOT matter


  _createClass(Text, [{
    key: "x",
    value: function x(_x) {
      var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();

      if (_x == null) {
        return box.x;
      }

      return this.attr('x', this.attr('x') + _x - box.x);
    } // Move over y-axis

  }, {
    key: "y",
    value: function y(_y) {
      var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();

      if (_y == null) {
        return box.y;
      }

      return this.attr('y', this.attr('y') + _y - box.y);
    }
  }, {
    key: "move",
    value: function move(x, y) {
      var box = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.bbox();
      return this.x(x, box).y(y, box);
    } // Move center over x-axis

  }, {
    key: "cx",
    value: function cx(x) {
      var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();

      if (x == null) {
        return box.cx;
      }

      return this.attr('x', this.attr('x') + x - box.cx);
    } // Move center over y-axis

  }, {
    key: "cy",
    value: function cy(y) {
      var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();

      if (y == null) {
        return box.cy;
      }

      return this.attr('y', this.attr('y') + y - box.cy);
    }
  }, {
    key: "center",
    value: function center(x, y) {
      var box = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.bbox();
      return this.cx(x, box).cy(y, box);
    } // Set the text content

  }, {
    key: "text",
    value: function text(_text) {
      // act as getter
      if (_text === undefined) {
        var children = this.node.childNodes;
        var firstLine = 0;
        _text = '';

        for (var i = 0, len = children.length; i < len; ++i) {
          // skip textPaths - they are no lines
          if (children[i].nodeName === 'textPath') {
            if (i === 0) firstLine = 1;
            continue;
          } // add newline if its not the first child and newLined is set to true


          if (i !== firstLine && children[i].nodeType !== 3 && adopt(children[i]).dom.newLined === true) {
            _text += '\n';
          } // add content of this node


          _text += children[i].textContent;
        }

        return _text;
      } // remove existing content


      this.clear().build(true);

      if (typeof _text === 'function') {
        // call block
        _text.call(this, this);
      } else {
        // store text and make sure text is not blank
        _text = _text.split('\n'); // build new lines

        for (var j = 0, jl = _text.length; j < jl; j++) {
          this.tspan(_text[j]).newLine();
        }
      } // disable build mode and rebuild lines


      return this.build(false).rebuild();
    } // Set / get leading

  }, {
    key: "leading",
    value: function leading(value) {
      // act as getter
      if (value == null) {
        return this.dom.leading;
      } // act as setter


      this.dom.leading = new SVGNumber(value);
      return this.rebuild();
    } // Rebuild appearance type

  }, {
    key: "rebuild",
    value: function rebuild(_rebuild) {
      // store new rebuild flag if given
      if (typeof _rebuild === 'boolean') {
        this._rebuild = _rebuild;
      } // define position of all lines


      if (this._rebuild) {
        var self = this;
        var blankLineOffset = 0;
        var leading = this.dom.leading;
        this.each(function () {
          var fontSize = globals.window.getComputedStyle(this.node).getPropertyValue('font-size');
          var dy = leading * new SVGNumber(fontSize);

          if (this.dom.newLined) {
            this.attr('x', self.attr('x'));

            if (this.text() === '\n') {
              blankLineOffset += dy;
            } else {
              this.attr('dy', dy + blankLineOffset);
              blankLineOffset = 0;
            }
          }
        });
        this.fire('rebuild');
      }

      return this;
    } // Enable / disable build mode

  }, {
    key: "build",
    value: function build(_build) {
      this._build = !!_build;
      return this;
    } // overwrite method from parent to set data properly

  }, {
    key: "setData",
    value: function setData(o) {
      this.dom = o;
      this.dom.leading = new SVGNumber(o.leading || 1.3);
      return this;
    }
  }]);

  return Text;
}(Shape);

exports.Text = Text;
extend(Text, textable);
registerMethods({
  Container: {
    // Create text element
    text: wrapWithAttrCheck(function (text) {
      return this.put(new Text()).text(text);
    }),
    // Create plain text element
    plain: wrapWithAttrCheck(function (text) {
      return this.put(new Text()).plain(text);
    })
  }
});
register(Text, 'Text');

var Tspan = /*#__PURE__*/function (_Text) {
  _inherits(Tspan, _Text); // Initialize node


  function Tspan(node) {
    _classCallCheck(this, Tspan);

    return _possibleConstructorReturn(this, _getPrototypeOf(Tspan).call(this, nodeOrNew('tspan', node), node));
  } // Set text content


  _createClass(Tspan, [{
    key: "text",
    value: function text(_text) {
      if (_text == null) return this.node.textContent + (this.dom.newLined ? '\n' : '');
      typeof _text === 'function' ? _text.call(this, this) : this.plain(_text);
      return this;
    } // Shortcut dx

  }, {
    key: "dx",
    value: function dx(_dx) {
      return this.attr('dx', _dx);
    } // Shortcut dy

  }, {
    key: "dy",
    value: function dy(_dy) {
      return this.attr('dy', _dy);
    }
  }, {
    key: "x",
    value: function x(_x) {
      return this.attr('x', _x);
    }
  }, {
    key: "y",
    value: function y(_y) {
      return this.attr('x', _y);
    }
  }, {
    key: "move",
    value: function move(x, y) {
      return this.x(x).y(y);
    } // Create new line

  }, {
    key: "newLine",
    value: function newLine() {
      // fetch text parent
      var t = this.parent(Text); // mark new line

      this.dom.newLined = true;
      var fontSize = globals.window.getComputedStyle(this.node).getPropertyValue('font-size');
      var dy = t.dom.leading * new SVGNumber(fontSize); // apply new position

      return this.dy(dy).attr('x', t.x());
    }
  }]);

  return Tspan;
}(Text);

exports.Tspan = Tspan;
extend(Tspan, textable);
registerMethods({
  Tspan: {
    tspan: wrapWithAttrCheck(function (text) {
      var tspan = new Tspan(); // clear if build mode is disabled

      if (!this._build) {
        this.clear();
      } // add new tspan


      this.node.appendChild(tspan.node);
      return tspan.text(text);
    })
  }
});
register(Tspan, 'Tspan');

var ClipPath = /*#__PURE__*/function (_Container) {
  _inherits(ClipPath, _Container);

  function ClipPath(node) {
    _classCallCheck(this, ClipPath);

    return _possibleConstructorReturn(this, _getPrototypeOf(ClipPath).call(this, nodeOrNew('clipPath', node), node));
  } // Unclip all clipped elements and remove itself


  _createClass(ClipPath, [{
    key: "remove",
    value: function remove() {
      // unclip all targets
      this.targets().forEach(function (el) {
        el.unclip();
      }); // remove clipPath from parent

      return _get(_getPrototypeOf(ClipPath.prototype), "remove", this).call(this);
    }
  }, {
    key: "targets",
    value: function targets() {
      return baseFind('svg [clip-path*="' + this.id() + '"]');
    }
  }]);

  return ClipPath;
}(Container);

exports.ClipPath = ClipPath;
registerMethods({
  Container: {
    // Create clipping element
    clip: wrapWithAttrCheck(function () {
      return this.defs().put(new ClipPath());
    })
  },
  Element: {
    // Distribute clipPath to svg element
    clipWith: function clipWith(element) {
      // use given clip or create a new one
      var clipper = element instanceof ClipPath ? element : this.parent().clip().add(element); // apply mask

      return this.attr('clip-path', 'url("#' + clipper.id() + '")');
    },
    // Unclip element
    unclip: function unclip() {
      return this.attr('clip-path', null);
    },
    clipper: function clipper() {
      return this.reference('clip-path');
    }
  }
});
register(ClipPath, 'ClipPath');

var ForeignObject = /*#__PURE__*/function (_Element) {
  _inherits(ForeignObject, _Element);

  function ForeignObject(node) {
    _classCallCheck(this, ForeignObject);

    return _possibleConstructorReturn(this, _getPrototypeOf(ForeignObject).call(this, nodeOrNew('foreignObject', node), node));
  }

  return ForeignObject;
}(Element);

exports.ForeignObject = ForeignObject;
registerMethods({
  Container: {
    foreignObject: wrapWithAttrCheck(function (width, height) {
      return this.put(new ForeignObject()).size(width, height);
    })
  }
});
register(ForeignObject, 'ForeignObject');

var G = /*#__PURE__*/function (_Container) {
  _inherits(G, _Container);

  function G(node) {
    _classCallCheck(this, G);

    return _possibleConstructorReturn(this, _getPrototypeOf(G).call(this, nodeOrNew('g', node), node));
  }

  _createClass(G, [{
    key: "x",
    value: function x(_x) {
      var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();
      if (_x == null) return box.x;
      return this.move(_x, box.y, box);
    }
  }, {
    key: "y",
    value: function y(_y) {
      var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();
      if (_y == null) return box.y;
      return this.move(box.x, _y, box);
    }
  }, {
    key: "move",
    value: function move() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var box = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.bbox();
      var dx = x - box.x;
      var dy = y - box.y;
      return this.dmove(dx, dy);
    }
  }, {
    key: "dx",
    value: function dx(_dx) {
      return this.dmove(_dx, 0);
    }
  }, {
    key: "dy",
    value: function dy(_dy) {
      return this.dmove(0, _dy);
    }
  }, {
    key: "dmove",
    value: function dmove(dx, dy) {
      this.children().forEach(function (child, i) {
        // Get the childs bbox
        var bbox = child.bbox(); // Get childs matrix

        var m = new Matrix(child); // Translate childs matrix by amount and
        // transform it back into parents space

        var matrix = m.translate(dx, dy).transform(m.inverse()); // Calculate new x and y from old box

        var p = new Point(bbox.x, bbox.y).transform(matrix); // Move element

        child.move(p.x, p.y);
      });
      return this;
    }
  }, {
    key: "width",
    value: function width(_width) {
      var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();
      if (_width == null) return box.width;
      return this.size(_width, box.height, box);
    }
  }, {
    key: "height",
    value: function height(_height) {
      var box = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.bbox();
      if (_height == null) return box.height;
      return this.size(box.width, _height, box);
    }
  }, {
    key: "size",
    value: function size(width, height) {
      var box = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.bbox();
      var p = proportionalSize(this, width, height, box);
      var scaleX = p.width / box.width;
      var scaleY = p.height / box.height;
      this.children().forEach(function (child, i) {
        var o = new Point(box).transform(new Matrix(child).inverse());
        child.scale(scaleX, scaleY, o.x, o.y);
      });
      return this;
    }
  }]);

  return G;
}(Container);

exports.G = G;
registerMethods({
  Container: {
    // Create a group element
    group: wrapWithAttrCheck(function () {
      return this.put(new G());
    })
  }
});
register(G, 'G');

var A = /*#__PURE__*/function (_Container) {
  _inherits(A, _Container);

  function A(node) {
    _classCallCheck(this, A);

    return _possibleConstructorReturn(this, _getPrototypeOf(A).call(this, nodeOrNew('a', node), node));
  } // Link url


  _createClass(A, [{
    key: "to",
    value: function to(url) {
      return this.attr('href', url, xlink);
    } // Link target attribute

  }, {
    key: "target",
    value: function target(_target) {
      return this.attr('target', _target);
    }
  }]);

  return A;
}(Container);

exports.A = A;
registerMethods({
  Container: {
    // Create a hyperlink element
    link: wrapWithAttrCheck(function (url) {
      return this.put(new A()).to(url);
    })
  },
  Element: {
    // Create a hyperlink element
    linkTo: function linkTo(url) {
      var link = new A();

      if (typeof url === 'function') {
        url.call(link, link);
      } else {
        link.to(url);
      }

      return this.parent().put(link).put(this);
    }
  }
});
register(A, 'A');

var Mask = /*#__PURE__*/function (_Container) {
  _inherits(Mask, _Container); // Initialize node


  function Mask(node) {
    _classCallCheck(this, Mask);

    return _possibleConstructorReturn(this, _getPrototypeOf(Mask).call(this, nodeOrNew('mask', node), node));
  } // Unmask all masked elements and remove itself


  _createClass(Mask, [{
    key: "remove",
    value: function remove() {
      // unmask all targets
      this.targets().forEach(function (el) {
        el.unmask();
      }); // remove mask from parent

      return _get(_getPrototypeOf(Mask.prototype), "remove", this).call(this);
    }
  }, {
    key: "targets",
    value: function targets() {
      return baseFind('svg [mask*="' + this.id() + '"]');
    }
  }]);

  return Mask;
}(Container);

exports.Mask = Mask;
registerMethods({
  Container: {
    mask: wrapWithAttrCheck(function () {
      return this.defs().put(new Mask());
    })
  },
  Element: {
    // Distribute mask to svg element
    maskWith: function maskWith(element) {
      // use given mask or create a new one
      var masker = element instanceof Mask ? element : this.parent().mask().add(element); // apply mask

      return this.attr('mask', 'url("#' + masker.id() + '")');
    },
    // Unmask element
    unmask: function unmask() {
      return this.attr('mask', null);
    },
    masker: function masker() {
      return this.reference('mask');
    }
  }
});
register(Mask, 'Mask');

function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$3(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function cssRule(selector, rule) {
  if (!selector) return '';
  if (!rule) return selector;
  var ret = selector + '{';

  for (var i in rule) {
    ret += unCamelCase(i) + ':' + rule[i] + ';';
  }

  ret += '}';
  return ret;
}

var Style = /*#__PURE__*/function (_Element) {
  _inherits(Style, _Element);

  function Style(node) {
    _classCallCheck(this, Style);

    return _possibleConstructorReturn(this, _getPrototypeOf(Style).call(this, nodeOrNew('style', node), node));
  }

  _createClass(Style, [{
    key: "addText",
    value: function addText() {
      var w = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      this.node.textContent += w;
      return this;
    }
  }, {
    key: "font",
    value: function font(name, src) {
      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.rule('@font-face', _objectSpread$2({
        fontFamily: name,
        src: src
      }, params));
    }
  }, {
    key: "rule",
    value: function rule(selector, obj) {
      return this.addText(cssRule(selector, obj));
    }
  }]);

  return Style;
}(Element);

exports.Style = Style;
registerMethods('Dom', {
  style: wrapWithAttrCheck(function (selector, obj) {
    return this.put(new Style()).rule(selector, obj);
  }),
  fontface: wrapWithAttrCheck(function (name, src, params) {
    return this.put(new Style()).font(name, src, params);
  })
});
register(Style, 'Style');

var TextPath = /*#__PURE__*/function (_Text) {
  _inherits(TextPath, _Text); // Initialize node


  function TextPath(node) {
    _classCallCheck(this, TextPath);

    return _possibleConstructorReturn(this, _getPrototypeOf(TextPath).call(this, nodeOrNew('textPath', node), node));
  } // return the array of the path track element


  _createClass(TextPath, [{
    key: "array",
    value: function array() {
      var track = this.track();
      return track ? track.array() : null;
    } // Plot path if any

  }, {
    key: "plot",
    value: function plot(d) {
      var track = this.track();
      var pathArray = null;

      if (track) {
        pathArray = track.plot(d);
      }

      return d == null ? pathArray : this;
    } // Get the path element

  }, {
    key: "track",
    value: function track() {
      return this.reference('href');
    }
  }]);

  return TextPath;
}(Text);

exports.TextPath = TextPath;
registerMethods({
  Container: {
    textPath: wrapWithAttrCheck(function (text, path) {
      // Convert text to instance if needed
      if (!(text instanceof Text)) {
        text = this.text(text);
      }

      return text.path(path);
    })
  },
  Text: {
    // Create path for text to run on
    path: wrapWithAttrCheck(function (track) {
      var importNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var textPath = new TextPath(); // if track is a path, reuse it

      if (!(track instanceof Path)) {
        // create path element
        track = this.defs().path(track);
      } // link textPath to path and add content


      textPath.attr('href', '#' + track, xlink); // Transplant all nodes from text to textPath

      var node;

      if (importNodes) {
        while (node = this.node.firstChild) {
          textPath.node.appendChild(node);
        }
      } // add textPath element as child node and return textPath


      return this.put(textPath);
    }),
    // Get the textPath children
    textPath: function textPath() {
      return this.findOne('textPath');
    }
  },
  Path: {
    // creates a textPath from this path
    text: wrapWithAttrCheck(function (text) {
      // Convert text to instance if needed
      if (!(text instanceof Text)) {
        text = new Text().addTo(this.parent()).text(text);
      } // Create textPath from text and path and return


      return text.path(this);
    }),
    targets: function targets() {
      return baseFind('svg [href*="' + this.id() + '"]');
    }
  }
});
TextPath.prototype.MorphArray = PathArray;
register(TextPath, 'TextPath');

var Use = /*#__PURE__*/function (_Shape) {
  _inherits(Use, _Shape);

  function Use(node) {
    _classCallCheck(this, Use);

    return _possibleConstructorReturn(this, _getPrototypeOf(Use).call(this, nodeOrNew('use', node), node));
  } // Use element as a reference


  _createClass(Use, [{
    key: "element",
    value: function element(_element, file) {
      // Set lined element
      return this.attr('href', (file || '') + '#' + _element, xlink);
    }
  }]);

  return Use;
}(Shape);

exports.Use = Use;
registerMethods({
  Container: {
    // Create a use element
    use: wrapWithAttrCheck(function (element, file) {
      return this.put(new Use()).element(element, file);
    })
  }
});
register(Use, 'Use');
/* Optional Modules */

var SVG = makeInstance;
exports.SVG = SVG;
extend([Svg, _Symbol, Image, Pattern, Marker], getMethodsFor('viewbox'));
extend([Line, Polyline, Polygon, Path], getMethodsFor('marker'));
extend(Text, getMethodsFor('Text'));
extend(Path, getMethodsFor('Path'));
extend(Defs, getMethodsFor('Defs'));
extend([Text, Tspan], getMethodsFor('Tspan'));
extend([Rect, Ellipse, Circle, Gradient], getMethodsFor('radius'));
extend(EventTarget, getMethodsFor('EventTarget'));
extend(Dom, getMethodsFor('Dom'));
extend(Element, getMethodsFor('Element'));
extend(Shape, getMethodsFor('Shape')); // extend(Element, getConstructor('Memory'))

extend(Container, getMethodsFor('Container'));
extend(Runner, getMethodsFor('Runner'));
List.extend(getMethodNames());
registerMorphableType([SVGNumber, Color, Box, Matrix, SVGArray, PointArray, PathArray]);
makeMorphable();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
// https://d3js.org/d3-quadtree/ v1.0.7 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

function tree_add(d) {
  var x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
}

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, abort.
  if (x0 > x1 || y0 > y1) return this;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}

function tree_cover(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries donât change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else {
    var z = x1 - x0,
        node = this._root,
        parent,
        i;

    while (x0 > x || x >= x1 || y0 > y || y >= y1) {
      i = (y < y0) << 1 | (x < x0);
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0: x1 = x0 + z, y1 = y0 + z; break;
        case 1: x0 = x1 - z, y1 = y0 + z; break;
        case 2: x1 = x0 + z, y0 = y1 - z; break;
        case 3: x0 = x1 - z, y0 = y1 - z; break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}

function tree_data() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
}

function tree_extent(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
}

function Quad(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}

function tree_find(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new Quad(node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant canât contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new Quad(node[3], xm, ym, x2, y2),
        new Quad(node[2], x1, ym, xm, y2),
        new Quad(node[1], xm, y1, x2, ym),
        new Quad(node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isnât necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
}

function tree_remove(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
}

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}

function tree_root() {
  return this._root;
}

function tree_size() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
}

function tree_visit(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
    }
  }
  return this;
}

function tree_visitAfter(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

function defaultX(d) {
  return d[0];
}

function tree_x(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}

function defaultY(d) {
  return d[1];
}

function tree_y(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}

function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = tree_add;
treeProto.addAll = addAll;
treeProto.cover = tree_cover;
treeProto.data = tree_data;
treeProto.extent = tree_extent;
treeProto.find = tree_find;
treeProto.remove = tree_remove;
treeProto.removeAll = removeAll;
treeProto.root = tree_root;
treeProto.size = tree_size;
treeProto.visit = tree_visit;
treeProto.visitAfter = tree_visitAfter;
treeProto.x = tree_x;
treeProto.y = tree_y;

exports.quadtree = quadtree;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],4:[function(require,module,exports){
/* interact.js 1.10.27 | https://raw.github.com/taye/interact.js/main/LICENSE */

!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).interact=e()}(this,(function(){"use strict";function t(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function e(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?t(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):t(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function n(t){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},n(t)}function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,d(r.key),r)}}function o(t,e,n){return e&&i(t.prototype,e),n&&i(t,n),Object.defineProperty(t,"prototype",{writable:!1}),t}function a(t,e,n){return(e=d(e))in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function s(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&l(t,e)}function c(t){return c=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},c(t)}function l(t,e){return l=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},l(t,e)}function u(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function p(t){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var n,r=c(t);if(e){var i=c(this).constructor;n=Reflect.construct(r,arguments,i)}else n=r.apply(this,arguments);return function(t,e){if(e&&("object"==typeof e||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return u(t)}(this,n)}}function f(){return f="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,n){var r=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=c(t)););return t}(t,e);if(r){var i=Object.getOwnPropertyDescriptor(r,e);return i.get?i.get.call(arguments.length<3?t:n):i.value}},f.apply(this,arguments)}function d(t){var e=function(t,e){if("object"!=typeof t||null===t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var r=n.call(t,e||"default");if("object"!=typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"==typeof e?e:e+""}var h=function(t){return!(!t||!t.Window)&&t instanceof t.Window},v=void 0,g=void 0;function m(t){v=t;var e=t.document.createTextNode("");e.ownerDocument!==t.document&&"function"==typeof t.wrap&&t.wrap(e)===e&&(t=t.wrap(t)),g=t}function y(t){return h(t)?t:(t.ownerDocument||t).defaultView||g.window}"undefined"!=typeof window&&window&&m(window);var b=function(t){return!!t&&"object"===n(t)},x=function(t){return"function"==typeof t},w={window:function(t){return t===g||h(t)},docFrag:function(t){return b(t)&&11===t.nodeType},object:b,func:x,number:function(t){return"number"==typeof t},bool:function(t){return"boolean"==typeof t},string:function(t){return"string"==typeof t},element:function(t){if(!t||"object"!==n(t))return!1;var e=y(t)||g;return/object|function/.test("undefined"==typeof Element?"undefined":n(Element))?t instanceof Element||t instanceof e.Element:1===t.nodeType&&"string"==typeof t.nodeName},plainObject:function(t){return b(t)&&!!t.constructor&&/function Object\b/.test(t.constructor.toString())},array:function(t){return b(t)&&void 0!==t.length&&x(t.splice)}};function E(t){var e=t.interaction;if("drag"===e.prepared.name){var n=e.prepared.axis;"x"===n?(e.coords.cur.page.y=e.coords.start.page.y,e.coords.cur.client.y=e.coords.start.client.y,e.coords.velocity.client.y=0,e.coords.velocity.page.y=0):"y"===n&&(e.coords.cur.page.x=e.coords.start.page.x,e.coords.cur.client.x=e.coords.start.client.x,e.coords.velocity.client.x=0,e.coords.velocity.page.x=0)}}function T(t){var e=t.iEvent,n=t.interaction;if("drag"===n.prepared.name){var r=n.prepared.axis;if("x"===r||"y"===r){var i="x"===r?"y":"x";e.page[i]=n.coords.start.page[i],e.client[i]=n.coords.start.client[i],e.delta[i]=0}}}var S={id:"actions/drag",install:function(t){var e=t.actions,n=t.Interactable,r=t.defaults;n.prototype.draggable=S.draggable,e.map.drag=S,e.methodDict.drag="draggable",r.actions.drag=S.defaults},listeners:{"interactions:before-action-move":E,"interactions:action-resume":E,"interactions:action-move":T,"auto-start:check":function(t){var e=t.interaction,n=t.interactable,r=t.buttons,i=n.options.drag;if(i&&i.enabled&&(!e.pointerIsDown||!/mouse|pointer/.test(e.pointerType)||0!=(r&n.options.drag.mouseButtons)))return t.action={name:"drag",axis:"start"===i.lockAxis?i.startAxis:i.lockAxis},!1}},draggable:function(t){return w.object(t)?(this.options.drag.enabled=!1!==t.enabled,this.setPerAction("drag",t),this.setOnEvents("drag",t),/^(xy|x|y|start)$/.test(t.lockAxis)&&(this.options.drag.lockAxis=t.lockAxis),/^(xy|x|y)$/.test(t.startAxis)&&(this.options.drag.startAxis=t.startAxis),this):w.bool(t)?(this.options.drag.enabled=t,this):this.options.drag},beforeMove:E,move:T,defaults:{startAxis:"xy",lockAxis:"xy"},getCursor:function(){return"move"},filterEventType:function(t){return 0===t.search("drag")}},_=S,P={init:function(t){var e=t;P.document=e.document,P.DocumentFragment=e.DocumentFragment||O,P.SVGElement=e.SVGElement||O,P.SVGSVGElement=e.SVGSVGElement||O,P.SVGElementInstance=e.SVGElementInstance||O,P.Element=e.Element||O,P.HTMLElement=e.HTMLElement||P.Element,P.Event=e.Event,P.Touch=e.Touch||O,P.PointerEvent=e.PointerEvent||e.MSPointerEvent},document:null,DocumentFragment:null,SVGElement:null,SVGSVGElement:null,SVGElementInstance:null,Element:null,HTMLElement:null,Event:null,Touch:null,PointerEvent:null};function O(){}var k=P;var D={init:function(t){var e=k.Element,n=t.navigator||{};D.supportsTouch="ontouchstart"in t||w.func(t.DocumentTouch)&&k.document instanceof t.DocumentTouch,D.supportsPointerEvent=!1!==n.pointerEnabled&&!!k.PointerEvent,D.isIOS=/iP(hone|od|ad)/.test(n.platform),D.isIOS7=/iP(hone|od|ad)/.test(n.platform)&&/OS 7[^\d]/.test(n.appVersion),D.isIe9=/MSIE 9/.test(n.userAgent),D.isOperaMobile="Opera"===n.appName&&D.supportsTouch&&/Presto/.test(n.userAgent),D.prefixedMatchesSelector="matches"in e.prototype?"matches":"webkitMatchesSelector"in e.prototype?"webkitMatchesSelector":"mozMatchesSelector"in e.prototype?"mozMatchesSelector":"oMatchesSelector"in e.prototype?"oMatchesSelector":"msMatchesSelector",D.pEventTypes=D.supportsPointerEvent?k.PointerEvent===t.MSPointerEvent?{up:"MSPointerUp",down:"MSPointerDown",over:"mouseover",out:"mouseout",move:"MSPointerMove",cancel:"MSPointerCancel"}:{up:"pointerup",down:"pointerdown",over:"pointerover",out:"pointerout",move:"pointermove",cancel:"pointercancel"}:null,D.wheelEvent=k.document&&"onmousewheel"in k.document?"mousewheel":"wheel"},supportsTouch:null,supportsPointerEvent:null,isIOS7:null,isIOS:null,isIe9:null,isOperaMobile:null,prefixedMatchesSelector:null,pEventTypes:null,wheelEvent:null};var I=D;function M(t,e){if(t.contains)return t.contains(e);for(;e;){if(e===t)return!0;e=e.parentNode}return!1}function z(t,e){for(;w.element(t);){if(R(t,e))return t;t=A(t)}return null}function A(t){var e=t.parentNode;if(w.docFrag(e)){for(;(e=e.host)&&w.docFrag(e););return e}return e}function R(t,e){return g!==v&&(e=e.replace(/\/deep\//g," ")),t[I.prefixedMatchesSelector](e)}var C=function(t){return t.parentNode||t.host};function j(t,e){for(var n,r=[],i=t;(n=C(i))&&i!==e&&n!==i.ownerDocument;)r.unshift(i),i=n;return r}function F(t,e,n){for(;w.element(t);){if(R(t,e))return!0;if((t=A(t))===n)return R(t,e)}return!1}function X(t){return t.correspondingUseElement||t}function Y(t){var e=t instanceof k.SVGElement?t.getBoundingClientRect():t.getClientRects()[0];return e&&{left:e.left,right:e.right,top:e.top,bottom:e.bottom,width:e.width||e.right-e.left,height:e.height||e.bottom-e.top}}function L(t){var e,n=Y(t);if(!I.isIOS7&&n){var r={x:(e=(e=y(t))||g).scrollX||e.document.documentElement.scrollLeft,y:e.scrollY||e.document.documentElement.scrollTop};n.left+=r.x,n.right+=r.x,n.top+=r.y,n.bottom+=r.y}return n}function q(t){for(var e=[];t;)e.push(t),t=A(t);return e}function B(t){return!!w.string(t)&&(k.document.querySelector(t),!0)}function V(t,e){for(var n in e)t[n]=e[n];return t}function W(t,e,n){return"parent"===t?A(n):"self"===t?e.getRect(n):z(n,t)}function G(t,e,n,r){var i=t;return w.string(i)?i=W(i,e,n):w.func(i)&&(i=i.apply(void 0,r)),w.element(i)&&(i=L(i)),i}function N(t){return t&&{x:"x"in t?t.x:t.left,y:"y"in t?t.y:t.top}}function U(t){return!t||"x"in t&&"y"in t||((t=V({},t)).x=t.left||0,t.y=t.top||0,t.width=t.width||(t.right||0)-t.x,t.height=t.height||(t.bottom||0)-t.y),t}function H(t,e,n){t.left&&(e.left+=n.x),t.right&&(e.right+=n.x),t.top&&(e.top+=n.y),t.bottom&&(e.bottom+=n.y),e.width=e.right-e.left,e.height=e.bottom-e.top}function K(t,e,n){var r=n&&t.options[n];return N(G(r&&r.origin||t.options.origin,t,e,[t&&e]))||{x:0,y:0}}function $(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:function(t){return!0},r=arguments.length>3?arguments[3]:void 0;if(r=r||{},w.string(t)&&-1!==t.search(" ")&&(t=J(t)),w.array(t))return t.forEach((function(t){return $(t,e,n,r)})),r;if(w.object(t)&&(e=t,t=""),w.func(e)&&n(t))r[t]=r[t]||[],r[t].push(e);else if(w.array(e))for(var i=0,o=e;i<o.length;i++){var a=o[i];$(t,a,n,r)}else if(w.object(e))for(var s in e){$(J(s).map((function(e){return"".concat(t).concat(e)})),e[s],n,r)}return r}function J(t){return t.trim().split(/ +/)}var Q=function(t,e){return Math.sqrt(t*t+e*e)},Z=["webkit","moz"];function tt(t,e){t.__set||(t.__set={});var n=function(n){if(Z.some((function(t){return 0===n.indexOf(t)})))return 1;"function"!=typeof t[n]&&"__set"!==n&&Object.defineProperty(t,n,{get:function(){return n in t.__set?t.__set[n]:t.__set[n]=e[n]},set:function(e){t.__set[n]=e},configurable:!0})};for(var r in e)n(r);return t}function et(t,e){t.page=t.page||{},t.page.x=e.page.x,t.page.y=e.page.y,t.client=t.client||{},t.client.x=e.client.x,t.client.y=e.client.y,t.timeStamp=e.timeStamp}function nt(t){t.page.x=0,t.page.y=0,t.client.x=0,t.client.y=0}function rt(t){return t instanceof k.Event||t instanceof k.Touch}function it(t,e,n){return t=t||"page",(n=n||{}).x=e[t+"X"],n.y=e[t+"Y"],n}function ot(t,e){return e=e||{x:0,y:0},I.isOperaMobile&&rt(t)?(it("screen",t,e),e.x+=window.scrollX,e.y+=window.scrollY):it("page",t,e),e}function at(t){return w.number(t.pointerId)?t.pointerId:t.identifier}function st(t,e,n){var r=e.length>1?lt(e):e[0];ot(r,t.page),function(t,e){e=e||{},I.isOperaMobile&&rt(t)?it("screen",t,e):it("client",t,e)}(r,t.client),t.timeStamp=n}function ct(t){var e=[];return w.array(t)?(e[0]=t[0],e[1]=t[1]):"touchend"===t.type?1===t.touches.length?(e[0]=t.touches[0],e[1]=t.changedTouches[0]):0===t.touches.length&&(e[0]=t.changedTouches[0],e[1]=t.changedTouches[1]):(e[0]=t.touches[0],e[1]=t.touches[1]),e}function lt(t){for(var e={pageX:0,pageY:0,clientX:0,clientY:0,screenX:0,screenY:0},n=0;n<t.length;n++){var r=t[n];for(var i in e)e[i]+=r[i]}for(var o in e)e[o]/=t.length;return e}function ut(t){if(!t.length)return null;var e=ct(t),n=Math.min(e[0].pageX,e[1].pageX),r=Math.min(e[0].pageY,e[1].pageY),i=Math.max(e[0].pageX,e[1].pageX),o=Math.max(e[0].pageY,e[1].pageY);return{x:n,y:r,left:n,top:r,right:i,bottom:o,width:i-n,height:o-r}}function pt(t,e){var n=e+"X",r=e+"Y",i=ct(t),o=i[0][n]-i[1][n],a=i[0][r]-i[1][r];return Q(o,a)}function ft(t,e){var n=e+"X",r=e+"Y",i=ct(t),o=i[1][n]-i[0][n],a=i[1][r]-i[0][r];return 180*Math.atan2(a,o)/Math.PI}function dt(t){return w.string(t.pointerType)?t.pointerType:w.number(t.pointerType)?[void 0,void 0,"touch","pen","mouse"][t.pointerType]:/touch/.test(t.type||"")||t instanceof k.Touch?"touch":"mouse"}function ht(t){var e=w.func(t.composedPath)?t.composedPath():t.path;return[X(e?e[0]:t.target),X(t.currentTarget)]}var vt=function(){function t(e){r(this,t),this.immediatePropagationStopped=!1,this.propagationStopped=!1,this._interaction=e}return o(t,[{key:"preventDefault",value:function(){}},{key:"stopPropagation",value:function(){this.propagationStopped=!0}},{key:"stopImmediatePropagation",value:function(){this.immediatePropagationStopped=this.propagationStopped=!0}}]),t}();Object.defineProperty(vt.prototype,"interaction",{get:function(){return this._interaction._proxy},set:function(){}});var gt=function(t,e){for(var n=0;n<e.length;n++){var r=e[n];t.push(r)}return t},mt=function(t){return gt([],t)},yt=function(t,e){for(var n=0;n<t.length;n++)if(e(t[n],n,t))return n;return-1},bt=function(t,e){return t[yt(t,e)]},xt=function(t){s(n,t);var e=p(n);function n(t,i,o){var a;r(this,n),(a=e.call(this,i._interaction)).dropzone=void 0,a.dragEvent=void 0,a.relatedTarget=void 0,a.draggable=void 0,a.propagationStopped=!1,a.immediatePropagationStopped=!1;var s="dragleave"===o?t.prev:t.cur,c=s.element,l=s.dropzone;return a.type=o,a.target=c,a.currentTarget=c,a.dropzone=l,a.dragEvent=i,a.relatedTarget=i.target,a.draggable=i.interactable,a.timeStamp=i.timeStamp,a}return o(n,[{key:"reject",value:function(){var t=this,e=this._interaction.dropState;if("dropactivate"===this.type||this.dropzone&&e.cur.dropzone===this.dropzone&&e.cur.element===this.target)if(e.prev.dropzone=this.dropzone,e.prev.element=this.target,e.rejected=!0,e.events.enter=null,this.stopImmediatePropagation(),"dropactivate"===this.type){var r=e.activeDrops,i=yt(r,(function(e){var n=e.dropzone,r=e.element;return n===t.dropzone&&r===t.target}));e.activeDrops.splice(i,1);var o=new n(e,this.dragEvent,"dropdeactivate");o.dropzone=this.dropzone,o.target=this.target,this.dropzone.fire(o)}else this.dropzone.fire(new n(e,this.dragEvent,"dragleave"))}},{key:"preventDefault",value:function(){}},{key:"stopPropagation",value:function(){this.propagationStopped=!0}},{key:"stopImmediatePropagation",value:function(){this.immediatePropagationStopped=this.propagationStopped=!0}}]),n}(vt);function wt(t,e){for(var n=0,r=t.slice();n<r.length;n++){var i=r[n],o=i.dropzone,a=i.element;e.dropzone=o,e.target=a,o.fire(e),e.propagationStopped=e.immediatePropagationStopped=!1}}function Et(t,e){for(var n=function(t,e){for(var n=[],r=0,i=t.interactables.list;r<i.length;r++){var o=i[r];if(o.options.drop.enabled){var a=o.options.drop.accept;if(!(w.element(a)&&a!==e||w.string(a)&&!R(e,a)||w.func(a)&&!a({dropzone:o,draggableElement:e})))for(var s=0,c=o.getAllElements();s<c.length;s++){var l=c[s];l!==e&&n.push({dropzone:o,element:l,rect:o.getRect(l)})}}}return n}(t,e),r=0;r<n.length;r++){var i=n[r];i.rect=i.dropzone.getRect(i.element)}return n}function Tt(t,e,n){for(var r=t.dropState,i=t.interactable,o=t.element,a=[],s=0,c=r.activeDrops;s<c.length;s++){var l=c[s],u=l.dropzone,p=l.element,f=l.rect,d=u.dropCheck(e,n,i,o,p,f);a.push(d?p:null)}var h=function(t){for(var e,n,r,i=[],o=0;o<t.length;o++){var a=t[o],s=t[e];if(a&&o!==e)if(s){var c=C(a),l=C(s);if(c!==a.ownerDocument)if(l!==a.ownerDocument)if(c!==l){i=i.length?i:j(s);var u=void 0;if(s instanceof k.HTMLElement&&a instanceof k.SVGElement&&!(a instanceof k.SVGSVGElement)){if(a===l)continue;u=a.ownerSVGElement}else u=a;for(var p=j(u,s.ownerDocument),f=0;p[f]&&p[f]===i[f];)f++;var d=[p[f-1],p[f],i[f]];if(d[0])for(var h=d[0].lastChild;h;){if(h===d[1]){e=o,i=p;break}if(h===d[2])break;h=h.previousSibling}}else r=s,void 0,void 0,(parseInt(y(n=a).getComputedStyle(n).zIndex,10)||0)>=(parseInt(y(r).getComputedStyle(r).zIndex,10)||0)&&(e=o);else e=o}else e=o}return e}(a);return r.activeDrops[h]||null}function St(t,e,n){var r=t.dropState,i={enter:null,leave:null,activate:null,deactivate:null,move:null,drop:null};return"dragstart"===n.type&&(i.activate=new xt(r,n,"dropactivate"),i.activate.target=null,i.activate.dropzone=null),"dragend"===n.type&&(i.deactivate=new xt(r,n,"dropdeactivate"),i.deactivate.target=null,i.deactivate.dropzone=null),r.rejected||(r.cur.element!==r.prev.element&&(r.prev.dropzone&&(i.leave=new xt(r,n,"dragleave"),n.dragLeave=i.leave.target=r.prev.element,n.prevDropzone=i.leave.dropzone=r.prev.dropzone),r.cur.dropzone&&(i.enter=new xt(r,n,"dragenter"),n.dragEnter=r.cur.element,n.dropzone=r.cur.dropzone)),"dragend"===n.type&&r.cur.dropzone&&(i.drop=new xt(r,n,"drop"),n.dropzone=r.cur.dropzone,n.relatedTarget=r.cur.element),"dragmove"===n.type&&r.cur.dropzone&&(i.move=new xt(r,n,"dropmove"),n.dropzone=r.cur.dropzone)),i}function _t(t,e){var n=t.dropState,r=n.activeDrops,i=n.cur,o=n.prev;e.leave&&o.dropzone.fire(e.leave),e.enter&&i.dropzone.fire(e.enter),e.move&&i.dropzone.fire(e.move),e.drop&&i.dropzone.fire(e.drop),e.deactivate&&wt(r,e.deactivate),n.prev.dropzone=i.dropzone,n.prev.element=i.element}function Pt(t,e){var n=t.interaction,r=t.iEvent,i=t.event;if("dragmove"===r.type||"dragend"===r.type){var o=n.dropState;e.dynamicDrop&&(o.activeDrops=Et(e,n.element));var a=r,s=Tt(n,a,i);o.rejected=o.rejected&&!!s&&s.dropzone===o.cur.dropzone&&s.element===o.cur.element,o.cur.dropzone=s&&s.dropzone,o.cur.element=s&&s.element,o.events=St(n,0,a)}}var Ot={id:"actions/drop",install:function(t){var e=t.actions,n=t.interactStatic,r=t.Interactable,i=t.defaults;t.usePlugin(_),r.prototype.dropzone=function(t){return function(t,e){if(w.object(e)){if(t.options.drop.enabled=!1!==e.enabled,e.listeners){var n=$(e.listeners),r=Object.keys(n).reduce((function(t,e){return t[/^(enter|leave)/.test(e)?"drag".concat(e):/^(activate|deactivate|move)/.test(e)?"drop".concat(e):e]=n[e],t}),{}),i=t.options.drop.listeners;i&&t.off(i),t.on(r),t.options.drop.listeners=r}return w.func(e.ondrop)&&t.on("drop",e.ondrop),w.func(e.ondropactivate)&&t.on("dropactivate",e.ondropactivate),w.func(e.ondropdeactivate)&&t.on("dropdeactivate",e.ondropdeactivate),w.func(e.ondragenter)&&t.on("dragenter",e.ondragenter),w.func(e.ondragleave)&&t.on("dragleave",e.ondragleave),w.func(e.ondropmove)&&t.on("dropmove",e.ondropmove),/^(pointer|center)$/.test(e.overlap)?t.options.drop.overlap=e.overlap:w.number(e.overlap)&&(t.options.drop.overlap=Math.max(Math.min(1,e.overlap),0)),"accept"in e&&(t.options.drop.accept=e.accept),"checker"in e&&(t.options.drop.checker=e.checker),t}if(w.bool(e))return t.options.drop.enabled=e,t;return t.options.drop}(this,t)},r.prototype.dropCheck=function(t,e,n,r,i,o){return function(t,e,n,r,i,o,a){var s=!1;if(!(a=a||t.getRect(o)))return!!t.options.drop.checker&&t.options.drop.checker(e,n,s,t,o,r,i);var c=t.options.drop.overlap;if("pointer"===c){var l=K(r,i,"drag"),u=ot(e);u.x+=l.x,u.y+=l.y;var p=u.x>a.left&&u.x<a.right,f=u.y>a.top&&u.y<a.bottom;s=p&&f}var d=r.getRect(i);if(d&&"center"===c){var h=d.left+d.width/2,v=d.top+d.height/2;s=h>=a.left&&h<=a.right&&v>=a.top&&v<=a.bottom}if(d&&w.number(c)){s=Math.max(0,Math.min(a.right,d.right)-Math.max(a.left,d.left))*Math.max(0,Math.min(a.bottom,d.bottom)-Math.max(a.top,d.top))/(d.width*d.height)>=c}t.options.drop.checker&&(s=t.options.drop.checker(e,n,s,t,o,r,i));return s}(this,t,e,n,r,i,o)},n.dynamicDrop=function(e){return w.bool(e)?(t.dynamicDrop=e,n):t.dynamicDrop},V(e.phaselessTypes,{dragenter:!0,dragleave:!0,dropactivate:!0,dropdeactivate:!0,dropmove:!0,drop:!0}),e.methodDict.drop="dropzone",t.dynamicDrop=!1,i.actions.drop=Ot.defaults},listeners:{"interactions:before-action-start":function(t){var e=t.interaction;"drag"===e.prepared.name&&(e.dropState={cur:{dropzone:null,element:null},prev:{dropzone:null,element:null},rejected:null,events:null,activeDrops:[]})},"interactions:after-action-start":function(t,e){var n=t.interaction,r=(t.event,t.iEvent);if("drag"===n.prepared.name){var i=n.dropState;i.activeDrops=[],i.events={},i.activeDrops=Et(e,n.element),i.events=St(n,0,r),i.events.activate&&(wt(i.activeDrops,i.events.activate),e.fire("actions/drop:start",{interaction:n,dragEvent:r}))}},"interactions:action-move":Pt,"interactions:after-action-move":function(t,e){var n=t.interaction,r=t.iEvent;if("drag"===n.prepared.name){var i=n.dropState;_t(n,i.events),e.fire("actions/drop:move",{interaction:n,dragEvent:r}),i.events={}}},"interactions:action-end":function(t,e){if("drag"===t.interaction.prepared.name){var n=t.interaction,r=t.iEvent;Pt(t,e),_t(n,n.dropState.events),e.fire("actions/drop:end",{interaction:n,dragEvent:r})}},"interactions:stop":function(t){var e=t.interaction;if("drag"===e.prepared.name){var n=e.dropState;n&&(n.activeDrops=null,n.events=null,n.cur.dropzone=null,n.cur.element=null,n.prev.dropzone=null,n.prev.element=null,n.rejected=!1)}}},getActiveDrops:Et,getDrop:Tt,getDropEvents:St,fireDropEvents:_t,filterEventType:function(t){return 0===t.search("drag")||0===t.search("drop")},defaults:{enabled:!1,accept:null,overlap:"pointer"}},kt=Ot;function Dt(t){var e=t.interaction,n=t.iEvent,r=t.phase;if("gesture"===e.prepared.name){var i=e.pointers.map((function(t){return t.pointer})),o="start"===r,a="end"===r,s=e.interactable.options.deltaSource;if(n.touches=[i[0],i[1]],o)n.distance=pt(i,s),n.box=ut(i),n.scale=1,n.ds=0,n.angle=ft(i,s),n.da=0,e.gesture.startDistance=n.distance,e.gesture.startAngle=n.angle;else if(a||e.pointers.length<2){var c=e.prevEvent;n.distance=c.distance,n.box=c.box,n.scale=c.scale,n.ds=0,n.angle=c.angle,n.da=0}else n.distance=pt(i,s),n.box=ut(i),n.scale=n.distance/e.gesture.startDistance,n.angle=ft(i,s),n.ds=n.scale-e.gesture.scale,n.da=n.angle-e.gesture.angle;e.gesture.distance=n.distance,e.gesture.angle=n.angle,w.number(n.scale)&&n.scale!==1/0&&!isNaN(n.scale)&&(e.gesture.scale=n.scale)}}var It={id:"actions/gesture",before:["actions/drag","actions/resize"],install:function(t){var e=t.actions,n=t.Interactable,r=t.defaults;n.prototype.gesturable=function(t){return w.object(t)?(this.options.gesture.enabled=!1!==t.enabled,this.setPerAction("gesture",t),this.setOnEvents("gesture",t),this):w.bool(t)?(this.options.gesture.enabled=t,this):this.options.gesture},e.map.gesture=It,e.methodDict.gesture="gesturable",r.actions.gesture=It.defaults},listeners:{"interactions:action-start":Dt,"interactions:action-move":Dt,"interactions:action-end":Dt,"interactions:new":function(t){t.interaction.gesture={angle:0,distance:0,scale:1,startAngle:0,startDistance:0}},"auto-start:check":function(t){if(!(t.interaction.pointers.length<2)){var e=t.interactable.options.gesture;if(e&&e.enabled)return t.action={name:"gesture"},!1}}},defaults:{},getCursor:function(){return""},filterEventType:function(t){return 0===t.search("gesture")}},Mt=It;function zt(t,e,n,r,i,o,a){if(!e)return!1;if(!0===e){var s=w.number(o.width)?o.width:o.right-o.left,c=w.number(o.height)?o.height:o.bottom-o.top;if(a=Math.min(a,Math.abs(("left"===t||"right"===t?s:c)/2)),s<0&&("left"===t?t="right":"right"===t&&(t="left")),c<0&&("top"===t?t="bottom":"bottom"===t&&(t="top")),"left"===t){var l=s>=0?o.left:o.right;return n.x<l+a}if("top"===t){var u=c>=0?o.top:o.bottom;return n.y<u+a}if("right"===t)return n.x>(s>=0?o.right:o.left)-a;if("bottom"===t)return n.y>(c>=0?o.bottom:o.top)-a}return!!w.element(r)&&(w.element(e)?e===r:F(r,e,i))}function At(t){var e=t.iEvent,n=t.interaction;if("resize"===n.prepared.name&&n.resizeAxes){var r=e;n.interactable.options.resize.square?("y"===n.resizeAxes?r.delta.x=r.delta.y:r.delta.y=r.delta.x,r.axes="xy"):(r.axes=n.resizeAxes,"x"===n.resizeAxes?r.delta.y=0:"y"===n.resizeAxes&&(r.delta.x=0))}}var Rt,Ct,jt={id:"actions/resize",before:["actions/drag"],install:function(t){var e=t.actions,n=t.browser,r=t.Interactable,i=t.defaults;jt.cursors=function(t){return t.isIe9?{x:"e-resize",y:"s-resize",xy:"se-resize",top:"n-resize",left:"w-resize",bottom:"s-resize",right:"e-resize",topleft:"se-resize",bottomright:"se-resize",topright:"ne-resize",bottomleft:"ne-resize"}:{x:"ew-resize",y:"ns-resize",xy:"nwse-resize",top:"ns-resize",left:"ew-resize",bottom:"ns-resize",right:"ew-resize",topleft:"nwse-resize",bottomright:"nwse-resize",topright:"nesw-resize",bottomleft:"nesw-resize"}}(n),jt.defaultMargin=n.supportsTouch||n.supportsPointerEvent?20:10,r.prototype.resizable=function(e){return function(t,e,n){if(w.object(e))return t.options.resize.enabled=!1!==e.enabled,t.setPerAction("resize",e),t.setOnEvents("resize",e),w.string(e.axis)&&/^x$|^y$|^xy$/.test(e.axis)?t.options.resize.axis=e.axis:null===e.axis&&(t.options.resize.axis=n.defaults.actions.resize.axis),w.bool(e.preserveAspectRatio)?t.options.resize.preserveAspectRatio=e.preserveAspectRatio:w.bool(e.square)&&(t.options.resize.square=e.square),t;if(w.bool(e))return t.options.resize.enabled=e,t;return t.options.resize}(this,e,t)},e.map.resize=jt,e.methodDict.resize="resizable",i.actions.resize=jt.defaults},listeners:{"interactions:new":function(t){t.interaction.resizeAxes="xy"},"interactions:action-start":function(t){!function(t){var e=t.iEvent,n=t.interaction;if("resize"===n.prepared.name&&n.prepared.edges){var r=e,i=n.rect;n._rects={start:V({},i),corrected:V({},i),previous:V({},i),delta:{left:0,right:0,width:0,top:0,bottom:0,height:0}},r.edges=n.prepared.edges,r.rect=n._rects.corrected,r.deltaRect=n._rects.delta}}(t),At(t)},"interactions:action-move":function(t){!function(t){var e=t.iEvent,n=t.interaction;if("resize"===n.prepared.name&&n.prepared.edges){var r=e,i=n.interactable.options.resize.invert,o="reposition"===i||"negate"===i,a=n.rect,s=n._rects,c=s.start,l=s.corrected,u=s.delta,p=s.previous;if(V(p,l),o){if(V(l,a),"reposition"===i){if(l.top>l.bottom){var f=l.top;l.top=l.bottom,l.bottom=f}if(l.left>l.right){var d=l.left;l.left=l.right,l.right=d}}}else l.top=Math.min(a.top,c.bottom),l.bottom=Math.max(a.bottom,c.top),l.left=Math.min(a.left,c.right),l.right=Math.max(a.right,c.left);for(var h in l.width=l.right-l.left,l.height=l.bottom-l.top,l)u[h]=l[h]-p[h];r.edges=n.prepared.edges,r.rect=l,r.deltaRect=u}}(t),At(t)},"interactions:action-end":function(t){var e=t.iEvent,n=t.interaction;if("resize"===n.prepared.name&&n.prepared.edges){var r=e;r.edges=n.prepared.edges,r.rect=n._rects.corrected,r.deltaRect=n._rects.delta}},"auto-start:check":function(t){var e=t.interaction,n=t.interactable,r=t.element,i=t.rect,o=t.buttons;if(i){var a=V({},e.coords.cur.page),s=n.options.resize;if(s&&s.enabled&&(!e.pointerIsDown||!/mouse|pointer/.test(e.pointerType)||0!=(o&s.mouseButtons))){if(w.object(s.edges)){var c={left:!1,right:!1,top:!1,bottom:!1};for(var l in c)c[l]=zt(l,s.edges[l],a,e._latestPointer.eventTarget,r,i,s.margin||jt.defaultMargin);c.left=c.left&&!c.right,c.top=c.top&&!c.bottom,(c.left||c.right||c.top||c.bottom)&&(t.action={name:"resize",edges:c})}else{var u="y"!==s.axis&&a.x>i.right-jt.defaultMargin,p="x"!==s.axis&&a.y>i.bottom-jt.defaultMargin;(u||p)&&(t.action={name:"resize",axes:(u?"x":"")+(p?"y":"")})}return!t.action&&void 0}}}},defaults:{square:!1,preserveAspectRatio:!1,axis:"xy",margin:NaN,edges:null,invert:"none"},cursors:null,getCursor:function(t){var e=t.edges,n=t.axis,r=t.name,i=jt.cursors,o=null;if(n)o=i[r+n];else if(e){for(var a="",s=0,c=["top","bottom","left","right"];s<c.length;s++){var l=c[s];e[l]&&(a+=l)}o=i[a]}return o},filterEventType:function(t){return 0===t.search("resize")},defaultMargin:null},Ft=jt,Xt={id:"actions",install:function(t){t.usePlugin(Mt),t.usePlugin(Ft),t.usePlugin(_),t.usePlugin(kt)}},Yt=0;var Lt={request:function(t){return Rt(t)},cancel:function(t){return Ct(t)},init:function(t){if(Rt=t.requestAnimationFrame,Ct=t.cancelAnimationFrame,!Rt)for(var e=["ms","moz","webkit","o"],n=0;n<e.length;n++){var r=e[n];Rt=t["".concat(r,"RequestAnimationFrame")],Ct=t["".concat(r,"CancelAnimationFrame")]||t["".concat(r,"CancelRequestAnimationFrame")]}Rt=Rt&&Rt.bind(t),Ct=Ct&&Ct.bind(t),Rt||(Rt=function(e){var n=Date.now(),r=Math.max(0,16-(n-Yt)),i=t.setTimeout((function(){e(n+r)}),r);return Yt=n+r,i},Ct=function(t){return clearTimeout(t)})}};var qt={defaults:{enabled:!1,margin:60,container:null,speed:300},now:Date.now,interaction:null,i:0,x:0,y:0,isScrolling:!1,prevTime:0,margin:0,speed:0,start:function(t){qt.isScrolling=!0,Lt.cancel(qt.i),t.autoScroll=qt,qt.interaction=t,qt.prevTime=qt.now(),qt.i=Lt.request(qt.scroll)},stop:function(){qt.isScrolling=!1,qt.interaction&&(qt.interaction.autoScroll=null),Lt.cancel(qt.i)},scroll:function(){var t=qt.interaction,e=t.interactable,n=t.element,r=t.prepared.name,i=e.options[r].autoScroll,o=Bt(i.container,e,n),a=qt.now(),s=(a-qt.prevTime)/1e3,c=i.speed*s;if(c>=1){var l={x:qt.x*c,y:qt.y*c};if(l.x||l.y){var u=Vt(o);w.window(o)?o.scrollBy(l.x,l.y):o&&(o.scrollLeft+=l.x,o.scrollTop+=l.y);var p=Vt(o),f={x:p.x-u.x,y:p.y-u.y};(f.x||f.y)&&e.fire({type:"autoscroll",target:n,interactable:e,delta:f,interaction:t,container:o})}qt.prevTime=a}qt.isScrolling&&(Lt.cancel(qt.i),qt.i=Lt.request(qt.scroll))},check:function(t,e){var n;return null==(n=t.options[e].autoScroll)?void 0:n.enabled},onInteractionMove:function(t){var e=t.interaction,n=t.pointer;if(e.interacting()&&qt.check(e.interactable,e.prepared.name))if(e.simulation)qt.x=qt.y=0;else{var r,i,o,a,s=e.interactable,c=e.element,l=e.prepared.name,u=s.options[l].autoScroll,p=Bt(u.container,s,c);if(w.window(p))a=n.clientX<qt.margin,r=n.clientY<qt.margin,i=n.clientX>p.innerWidth-qt.margin,o=n.clientY>p.innerHeight-qt.margin;else{var f=Y(p);a=n.clientX<f.left+qt.margin,r=n.clientY<f.top+qt.margin,i=n.clientX>f.right-qt.margin,o=n.clientY>f.bottom-qt.margin}qt.x=i?1:a?-1:0,qt.y=o?1:r?-1:0,qt.isScrolling||(qt.margin=u.margin,qt.speed=u.speed,qt.start(e))}}};function Bt(t,e,n){return(w.string(t)?W(t,e,n):t)||y(n)}function Vt(t){return w.window(t)&&(t=window.document.body),{x:t.scrollLeft,y:t.scrollTop}}var Wt={id:"auto-scroll",install:function(t){var e=t.defaults,n=t.actions;t.autoScroll=qt,qt.now=function(){return t.now()},n.phaselessTypes.autoscroll=!0,e.perAction.autoScroll=qt.defaults},listeners:{"interactions:new":function(t){t.interaction.autoScroll=null},"interactions:destroy":function(t){t.interaction.autoScroll=null,qt.stop(),qt.interaction&&(qt.interaction=null)},"interactions:stop":qt.stop,"interactions:action-move":function(t){return qt.onInteractionMove(t)}}},Gt=Wt;function Nt(t,e){var n=!1;return function(){return n||(g.console.warn(e),n=!0),t.apply(this,arguments)}}function Ut(t,e){return t.name=e.name,t.axis=e.axis,t.edges=e.edges,t}function Ht(t){return w.bool(t)?(this.options.styleCursor=t,this):null===t?(delete this.options.styleCursor,this):this.options.styleCursor}function Kt(t){return w.func(t)?(this.options.actionChecker=t,this):null===t?(delete this.options.actionChecker,this):this.options.actionChecker}var $t={id:"auto-start/interactableMethods",install:function(t){var e=t.Interactable;e.prototype.getAction=function(e,n,r,i){var o=function(t,e,n,r,i){var o=t.getRect(r),a=e.buttons||{0:1,1:4,3:8,4:16}[e.button],s={action:null,interactable:t,interaction:n,element:r,rect:o,buttons:a};return i.fire("auto-start:check",s),s.action}(this,n,r,i,t);return this.options.actionChecker?this.options.actionChecker(e,n,o,this,i,r):o},e.prototype.ignoreFrom=Nt((function(t){return this._backCompatOption("ignoreFrom",t)}),"Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue})."),e.prototype.allowFrom=Nt((function(t){return this._backCompatOption("allowFrom",t)}),"Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue})."),e.prototype.actionChecker=Kt,e.prototype.styleCursor=Ht}};function Jt(t,e,n,r,i){return e.testIgnoreAllow(e.options[t.name],n,r)&&e.options[t.name].enabled&&ee(e,n,t,i)?t:null}function Qt(t,e,n,r,i,o,a){for(var s=0,c=r.length;s<c;s++){var l=r[s],u=i[s],p=l.getAction(e,n,t,u);if(p){var f=Jt(p,l,u,o,a);if(f)return{action:f,interactable:l,element:u}}}return{action:null,interactable:null,element:null}}function Zt(t,e,n,r,i){var o=[],a=[],s=r;function c(t){o.push(t),a.push(s)}for(;w.element(s);){o=[],a=[],i.interactables.forEachMatch(s,c);var l=Qt(t,e,n,o,a,r,i);if(l.action&&!l.interactable.options[l.action.name].manualStart)return l;s=A(s)}return{action:null,interactable:null,element:null}}function te(t,e,n){var r=e.action,i=e.interactable,o=e.element;r=r||{name:null},t.interactable=i,t.element=o,Ut(t.prepared,r),t.rect=i&&r.name?i.getRect(o):null,ie(t,n),n.fire("autoStart:prepared",{interaction:t})}function ee(t,e,n,r){var i=t.options,o=i[n.name].max,a=i[n.name].maxPerElement,s=r.autoStart.maxInteractions,c=0,l=0,u=0;if(!(o&&a&&s))return!1;for(var p=0,f=r.interactions.list;p<f.length;p++){var d=f[p],h=d.prepared.name;if(d.interacting()){if(++c>=s)return!1;if(d.interactable===t){if((l+=h===n.name?1:0)>=o)return!1;if(d.element===e&&(u++,h===n.name&&u>=a))return!1}}}return s>0}function ne(t,e){return w.number(t)?(e.autoStart.maxInteractions=t,this):e.autoStart.maxInteractions}function re(t,e,n){var r=n.autoStart.cursorElement;r&&r!==t&&(r.style.cursor=""),t.ownerDocument.documentElement.style.cursor=e,t.style.cursor=e,n.autoStart.cursorElement=e?t:null}function ie(t,e){var n=t.interactable,r=t.element,i=t.prepared;if("mouse"===t.pointerType&&n&&n.options.styleCursor){var o="";if(i.name){var a=n.options[i.name].cursorChecker;o=w.func(a)?a(i,n,r,t._interacting):e.actions.map[i.name].getCursor(i)}re(t.element,o||"",e)}else e.autoStart.cursorElement&&re(e.autoStart.cursorElement,"",e)}var oe={id:"auto-start/base",before:["actions"],install:function(t){var e=t.interactStatic,n=t.defaults;t.usePlugin($t),n.base.actionChecker=null,n.base.styleCursor=!0,V(n.perAction,{manualStart:!1,max:1/0,maxPerElement:1,allowFrom:null,ignoreFrom:null,mouseButtons:1}),e.maxInteractions=function(e){return ne(e,t)},t.autoStart={maxInteractions:1/0,withinInteractionLimit:ee,cursorElement:null}},listeners:{"interactions:down":function(t,e){var n=t.interaction,r=t.pointer,i=t.event,o=t.eventTarget;n.interacting()||te(n,Zt(n,r,i,o,e),e)},"interactions:move":function(t,e){!function(t,e){var n=t.interaction,r=t.pointer,i=t.event,o=t.eventTarget;"mouse"!==n.pointerType||n.pointerIsDown||n.interacting()||te(n,Zt(n,r,i,o,e),e)}(t,e),function(t,e){var n=t.interaction;if(n.pointerIsDown&&!n.interacting()&&n.pointerWasMoved&&n.prepared.name){e.fire("autoStart:before-start",t);var r=n.interactable,i=n.prepared.name;i&&r&&(r.options[i].manualStart||!ee(r,n.element,n.prepared,e)?n.stop():(n.start(n.prepared,r,n.element),ie(n,e)))}}(t,e)},"interactions:stop":function(t,e){var n=t.interaction,r=n.interactable;r&&r.options.styleCursor&&re(n.element,"",e)}},maxInteractions:ne,withinInteractionLimit:ee,validateAction:Jt},ae=oe;var se={id:"auto-start/dragAxis",listeners:{"autoStart:before-start":function(t,e){var n=t.interaction,r=t.eventTarget,i=t.dx,o=t.dy;if("drag"===n.prepared.name){var a=Math.abs(i),s=Math.abs(o),c=n.interactable.options.drag,l=c.startAxis,u=a>s?"x":a<s?"y":"xy";if(n.prepared.axis="start"===c.lockAxis?u[0]:c.lockAxis,"xy"!==u&&"xy"!==l&&l!==u){n.prepared.name=null;for(var p=r,f=function(t){if(t!==n.interactable){var i=n.interactable.options.drag;if(!i.manualStart&&t.testIgnoreAllow(i,p,r)){var o=t.getAction(n.downPointer,n.downEvent,n,p);if(o&&"drag"===o.name&&function(t,e){if(!e)return!1;var n=e.options.drag.startAxis;return"xy"===t||"xy"===n||n===t}(u,t)&&ae.validateAction(o,t,p,r,e))return t}}};w.element(p);){var d=e.interactables.forEachMatch(p,f);if(d){n.prepared.name="drag",n.interactable=d,n.element=p;break}p=A(p)}}}}}};function ce(t){var e=t.prepared&&t.prepared.name;if(!e)return null;var n=t.interactable.options;return n[e].hold||n[e].delay}var le={id:"auto-start/hold",install:function(t){var e=t.defaults;t.usePlugin(ae),e.perAction.hold=0,e.perAction.delay=0},listeners:{"interactions:new":function(t){t.interaction.autoStartHoldTimer=null},"autoStart:prepared":function(t){var e=t.interaction,n=ce(e);n>0&&(e.autoStartHoldTimer=setTimeout((function(){e.start(e.prepared,e.interactable,e.element)}),n))},"interactions:move":function(t){var e=t.interaction,n=t.duplicate;e.autoStartHoldTimer&&e.pointerWasMoved&&!n&&(clearTimeout(e.autoStartHoldTimer),e.autoStartHoldTimer=null)},"autoStart:before-start":function(t){var e=t.interaction;ce(e)>0&&(e.prepared.name=null)}},getHoldDuration:ce},ue=le,pe={id:"auto-start",install:function(t){t.usePlugin(ae),t.usePlugin(ue),t.usePlugin(se)}},fe=function(t){return/^(always|never|auto)$/.test(t)?(this.options.preventDefault=t,this):w.bool(t)?(this.options.preventDefault=t?"always":"never",this):this.options.preventDefault};function de(t){var e=t.interaction,n=t.event;e.interactable&&e.interactable.checkAndPreventDefault(n)}var he={id:"core/interactablePreventDefault",install:function(t){var e=t.Interactable;e.prototype.preventDefault=fe,e.prototype.checkAndPreventDefault=function(e){return function(t,e,n){var r=t.options.preventDefault;if("never"!==r)if("always"!==r){if(e.events.supportsPassive&&/^touch(start|move)$/.test(n.type)){var i=y(n.target).document,o=e.getDocOptions(i);if(!o||!o.events||!1!==o.events.passive)return}/^(mouse|pointer|touch)*(down|start)/i.test(n.type)||w.element(n.target)&&R(n.target,"input,select,textarea,[contenteditable=true],[contenteditable=true] *")||n.preventDefault()}else n.preventDefault()}(this,t,e)},t.interactions.docEvents.push({type:"dragstart",listener:function(e){for(var n=0,r=t.interactions.list;n<r.length;n++){var i=r[n];if(i.element&&(i.element===e.target||M(i.element,e.target)))return void i.interactable.checkAndPreventDefault(e)}}})},listeners:["down","move","up","cancel"].reduce((function(t,e){return t["interactions:".concat(e)]=de,t}),{})};function ve(t,e){if(e.phaselessTypes[t])return!0;for(var n in e.map)if(0===t.indexOf(n)&&t.substr(n.length)in e.phases)return!0;return!1}function ge(t){var e={};for(var n in t){var r=t[n];w.plainObject(r)?e[n]=ge(r):w.array(r)?e[n]=mt(r):e[n]=r}return e}var me=function(){function t(e){r(this,t),this.states=[],this.startOffset={left:0,right:0,top:0,bottom:0},this.startDelta=void 0,this.result=void 0,this.endResult=void 0,this.startEdges=void 0,this.edges=void 0,this.interaction=void 0,this.interaction=e,this.result=ye(),this.edges={left:!1,right:!1,top:!1,bottom:!1}}return o(t,[{key:"start",value:function(t,e){var n,r,i=t.phase,o=this.interaction,a=function(t){var e=t.interactable.options[t.prepared.name],n=e.modifiers;if(n&&n.length)return n;return["snap","snapSize","snapEdges","restrict","restrictEdges","restrictSize"].map((function(t){var n=e[t];return n&&n.enabled&&{options:n,methods:n._methods}})).filter((function(t){return!!t}))}(o);this.prepareStates(a),this.startEdges=V({},o.edges),this.edges=V({},this.startEdges),this.startOffset=(n=o.rect,r=e,n?{left:r.x-n.left,top:r.y-n.top,right:n.right-r.x,bottom:n.bottom-r.y}:{left:0,top:0,right:0,bottom:0}),this.startDelta={x:0,y:0};var s=this.fillArg({phase:i,pageCoords:e,preEnd:!1});return this.result=ye(),this.startAll(s),this.result=this.setAll(s)}},{key:"fillArg",value:function(t){var e=this.interaction;return t.interaction=e,t.interactable=e.interactable,t.element=e.element,t.rect||(t.rect=e.rect),t.edges||(t.edges=this.startEdges),t.startOffset=this.startOffset,t}},{key:"startAll",value:function(t){for(var e=0,n=this.states;e<n.length;e++){var r=n[e];r.methods.start&&(t.state=r,r.methods.start(t))}}},{key:"setAll",value:function(t){var e=t.phase,n=t.preEnd,r=t.skipModifiers,i=t.rect,o=t.edges;t.coords=V({},t.pageCoords),t.rect=V({},i),t.edges=V({},o);for(var a=r?this.states.slice(r):this.states,s=ye(t.coords,t.rect),c=0;c<a.length;c++){var l,u=a[c],p=u.options,f=V({},t.coords),d=null;null!=(l=u.methods)&&l.set&&this.shouldDo(p,n,e)&&(t.state=u,d=u.methods.set(t),H(t.edges,t.rect,{x:t.coords.x-f.x,y:t.coords.y-f.y})),s.eventProps.push(d)}V(this.edges,t.edges),s.delta.x=t.coords.x-t.pageCoords.x,s.delta.y=t.coords.y-t.pageCoords.y,s.rectDelta.left=t.rect.left-i.left,s.rectDelta.right=t.rect.right-i.right,s.rectDelta.top=t.rect.top-i.top,s.rectDelta.bottom=t.rect.bottom-i.bottom;var h=this.result.coords,v=this.result.rect;if(h&&v){var g=s.rect.left!==v.left||s.rect.right!==v.right||s.rect.top!==v.top||s.rect.bottom!==v.bottom;s.changed=g||h.x!==s.coords.x||h.y!==s.coords.y}return s}},{key:"applyToInteraction",value:function(t){var e=this.interaction,n=t.phase,r=e.coords.cur,i=e.coords.start,o=this.result,a=this.startDelta,s=o.delta;"start"===n&&V(this.startDelta,o.delta);for(var c=0,l=[[i,a],[r,s]];c<l.length;c++){var u=l[c],p=u[0],f=u[1];p.page.x+=f.x,p.page.y+=f.y,p.client.x+=f.x,p.client.y+=f.y}var d=this.result.rectDelta,h=t.rect||e.rect;h.left+=d.left,h.right+=d.right,h.top+=d.top,h.bottom+=d.bottom,h.width=h.right-h.left,h.height=h.bottom-h.top}},{key:"setAndApply",value:function(t){var e=this.interaction,n=t.phase,r=t.preEnd,i=t.skipModifiers,o=this.setAll(this.fillArg({preEnd:r,phase:n,pageCoords:t.modifiedCoords||e.coords.cur.page}));if(this.result=o,!o.changed&&(!i||i<this.states.length)&&e.interacting())return!1;if(t.modifiedCoords){var a=e.coords.cur.page,s={x:t.modifiedCoords.x-a.x,y:t.modifiedCoords.y-a.y};o.coords.x+=s.x,o.coords.y+=s.y,o.delta.x+=s.x,o.delta.y+=s.y}this.applyToInteraction(t)}},{key:"beforeEnd",value:function(t){var e=t.interaction,n=t.event,r=this.states;if(r&&r.length){for(var i=!1,o=0;o<r.length;o++){var a=r[o];t.state=a;var s=a.options,c=a.methods,l=c.beforeEnd&&c.beforeEnd(t);if(l)return this.endResult=l,!1;i=i||!i&&this.shouldDo(s,!0,t.phase,!0)}i&&e.move({event:n,preEnd:!0})}}},{key:"stop",value:function(t){var e=t.interaction;if(this.states&&this.states.length){var n=V({states:this.states,interactable:e.interactable,element:e.element,rect:null},t);this.fillArg(n);for(var r=0,i=this.states;r<i.length;r++){var o=i[r];n.state=o,o.methods.stop&&o.methods.stop(n)}this.states=null,this.endResult=null}}},{key:"prepareStates",value:function(t){this.states=[];for(var e=0;e<t.length;e++){var n=t[e],r=n.options,i=n.methods,o=n.name;this.states.push({options:r,methods:i,index:e,name:o})}return this.states}},{key:"restoreInteractionCoords",value:function(t){var e=t.interaction,n=e.coords,r=e.rect,i=e.modification;if(i.result){for(var o=i.startDelta,a=i.result,s=a.delta,c=a.rectDelta,l=0,u=[[n.start,o],[n.cur,s]];l<u.length;l++){var p=u[l],f=p[0],d=p[1];f.page.x-=d.x,f.page.y-=d.y,f.client.x-=d.x,f.client.y-=d.y}r.left-=c.left,r.right-=c.right,r.top-=c.top,r.bottom-=c.bottom}}},{key:"shouldDo",value:function(t,e,n,r){return!(!t||!1===t.enabled||r&&!t.endOnly||t.endOnly&&!e||"start"===n&&!t.setStart)}},{key:"copyFrom",value:function(t){this.startOffset=t.startOffset,this.startDelta=t.startDelta,this.startEdges=t.startEdges,this.edges=t.edges,this.states=t.states.map((function(t){return ge(t)})),this.result=ye(V({},t.result.coords),V({},t.result.rect))}},{key:"destroy",value:function(){for(var t in this)this[t]=null}}]),t}();function ye(t,e){return{rect:e,coords:t,delta:{x:0,y:0},rectDelta:{left:0,right:0,top:0,bottom:0},eventProps:[],changed:!0}}function be(t,e){var n=t.defaults,r={start:t.start,set:t.set,beforeEnd:t.beforeEnd,stop:t.stop},i=function(t){var i=t||{};for(var o in i.enabled=!1!==i.enabled,n)o in i||(i[o]=n[o]);var a={options:i,methods:r,name:e,enable:function(){return i.enabled=!0,a},disable:function(){return i.enabled=!1,a}};return a};return e&&"string"==typeof e&&(i._defaults=n,i._methods=r),i}function xe(t){var e=t.iEvent,n=t.interaction.modification.result;n&&(e.modifiers=n.eventProps)}var we={id:"modifiers/base",before:["actions"],install:function(t){t.defaults.perAction.modifiers=[]},listeners:{"interactions:new":function(t){var e=t.interaction;e.modification=new me(e)},"interactions:before-action-start":function(t){var e=t.interaction,n=t.interaction.modification;n.start(t,e.coords.start.page),e.edges=n.edges,n.applyToInteraction(t)},"interactions:before-action-move":function(t){var e=t.interaction,n=e.modification,r=n.setAndApply(t);return e.edges=n.edges,r},"interactions:before-action-end":function(t){var e=t.interaction,n=e.modification,r=n.beforeEnd(t);return e.edges=n.startEdges,r},"interactions:action-start":xe,"interactions:action-move":xe,"interactions:action-end":xe,"interactions:after-action-start":function(t){return t.interaction.modification.restoreInteractionCoords(t)},"interactions:after-action-move":function(t){return t.interaction.modification.restoreInteractionCoords(t)},"interactions:stop":function(t){return t.interaction.modification.stop(t)}}},Ee=we,Te={base:{preventDefault:"auto",deltaSource:"page"},perAction:{enabled:!1,origin:{x:0,y:0}},actions:{}},Se=function(t){s(n,t);var e=p(n);function n(t,i,o,a,s,c,l){var p;r(this,n),(p=e.call(this,t)).relatedTarget=null,p.screenX=void 0,p.screenY=void 0,p.button=void 0,p.buttons=void 0,p.ctrlKey=void 0,p.shiftKey=void 0,p.altKey=void 0,p.metaKey=void 0,p.page=void 0,p.client=void 0,p.delta=void 0,p.rect=void 0,p.x0=void 0,p.y0=void 0,p.t0=void 0,p.dt=void 0,p.duration=void 0,p.clientX0=void 0,p.clientY0=void 0,p.velocity=void 0,p.speed=void 0,p.swipe=void 0,p.axes=void 0,p.preEnd=void 0,s=s||t.element;var f=t.interactable,d=(f&&f.options||Te).deltaSource,h=K(f,s,o),v="start"===a,g="end"===a,m=v?u(p):t.prevEvent,y=v?t.coords.start:g?{page:m.page,client:m.client,timeStamp:t.coords.cur.timeStamp}:t.coords.cur;return p.page=V({},y.page),p.client=V({},y.client),p.rect=V({},t.rect),p.timeStamp=y.timeStamp,g||(p.page.x-=h.x,p.page.y-=h.y,p.client.x-=h.x,p.client.y-=h.y),p.ctrlKey=i.ctrlKey,p.altKey=i.altKey,p.shiftKey=i.shiftKey,p.metaKey=i.metaKey,p.button=i.button,p.buttons=i.buttons,p.target=s,p.currentTarget=s,p.preEnd=c,p.type=l||o+(a||""),p.interactable=f,p.t0=v?t.pointers[t.pointers.length-1].downTime:m.t0,p.x0=t.coords.start.page.x-h.x,p.y0=t.coords.start.page.y-h.y,p.clientX0=t.coords.start.client.x-h.x,p.clientY0=t.coords.start.client.y-h.y,p.delta=v||g?{x:0,y:0}:{x:p[d].x-m[d].x,y:p[d].y-m[d].y},p.dt=t.coords.delta.timeStamp,p.duration=p.timeStamp-p.t0,p.velocity=V({},t.coords.velocity[d]),p.speed=Q(p.velocity.x,p.velocity.y),p.swipe=g||"inertiastart"===a?p.getSwipe():null,p}return o(n,[{key:"getSwipe",value:function(){var t=this._interaction;if(t.prevEvent.speed<600||this.timeStamp-t.prevEvent.timeStamp>150)return null;var e=180*Math.atan2(t.prevEvent.velocityY,t.prevEvent.velocityX)/Math.PI;e<0&&(e+=360);var n=112.5<=e&&e<247.5,r=202.5<=e&&e<337.5;return{up:r,down:!r&&22.5<=e&&e<157.5,left:n,right:!n&&(292.5<=e||e<67.5),angle:e,speed:t.prevEvent.speed,velocity:{x:t.prevEvent.velocityX,y:t.prevEvent.velocityY}}}},{key:"preventDefault",value:function(){}},{key:"stopImmediatePropagation",value:function(){this.immediatePropagationStopped=this.propagationStopped=!0}},{key:"stopPropagation",value:function(){this.propagationStopped=!0}}]),n}(vt);Object.defineProperties(Se.prototype,{pageX:{get:function(){return this.page.x},set:function(t){this.page.x=t}},pageY:{get:function(){return this.page.y},set:function(t){this.page.y=t}},clientX:{get:function(){return this.client.x},set:function(t){this.client.x=t}},clientY:{get:function(){return this.client.y},set:function(t){this.client.y=t}},dx:{get:function(){return this.delta.x},set:function(t){this.delta.x=t}},dy:{get:function(){return this.delta.y},set:function(t){this.delta.y=t}},velocityX:{get:function(){return this.velocity.x},set:function(t){this.velocity.x=t}},velocityY:{get:function(){return this.velocity.y},set:function(t){this.velocity.y=t}}});var _e=o((function t(e,n,i,o,a){r(this,t),this.id=void 0,this.pointer=void 0,this.event=void 0,this.downTime=void 0,this.downTarget=void 0,this.id=e,this.pointer=n,this.event=i,this.downTime=o,this.downTarget=a})),Pe=function(t){return t.interactable="",t.element="",t.prepared="",t.pointerIsDown="",t.pointerWasMoved="",t._proxy="",t}({}),Oe=function(t){return t.start="",t.move="",t.end="",t.stop="",t.interacting="",t}({}),ke=0,De=function(){function t(e){var n=this,i=e.pointerType,o=e.scopeFire;r(this,t),this.interactable=null,this.element=null,this.rect=null,this._rects=void 0,this.edges=null,this._scopeFire=void 0,this.prepared={name:null,axis:null,edges:null},this.pointerType=void 0,this.pointers=[],this.downEvent=null,this.downPointer={},this._latestPointer={pointer:null,event:null,eventTarget:null},this.prevEvent=null,this.pointerIsDown=!1,this.pointerWasMoved=!1,this._interacting=!1,this._ending=!1,this._stopped=!0,this._proxy=void 0,this.simulation=null,this.doMove=Nt((function(t){this.move(t)}),"The interaction.doMove() method has been renamed to interaction.move()"),this.coords={start:{page:{x:0,y:0},client:{x:0,y:0},timeStamp:0},prev:{page:{x:0,y:0},client:{x:0,y:0},timeStamp:0},cur:{page:{x:0,y:0},client:{x:0,y:0},timeStamp:0},delta:{page:{x:0,y:0},client:{x:0,y:0},timeStamp:0},velocity:{page:{x:0,y:0},client:{x:0,y:0},timeStamp:0}},this._id=ke++,this._scopeFire=o,this.pointerType=i;var a=this;this._proxy={};var s=function(t){Object.defineProperty(n._proxy,t,{get:function(){return a[t]}})};for(var c in Pe)s(c);var l=function(t){Object.defineProperty(n._proxy,t,{value:function(){return a[t].apply(a,arguments)}})};for(var u in Oe)l(u);this._scopeFire("interactions:new",{interaction:this})}return o(t,[{key:"pointerMoveTolerance",get:function(){return 1}},{key:"pointerDown",value:function(t,e,n){var r=this.updatePointer(t,e,n,!0),i=this.pointers[r];this._scopeFire("interactions:down",{pointer:t,event:e,eventTarget:n,pointerIndex:r,pointerInfo:i,type:"down",interaction:this})}},{key:"start",value:function(t,e,n){return!(this.interacting()||!this.pointerIsDown||this.pointers.length<("gesture"===t.name?2:1)||!e.options[t.name].enabled)&&(Ut(this.prepared,t),this.interactable=e,this.element=n,this.rect=e.getRect(n),this.edges=this.prepared.edges?V({},this.prepared.edges):{left:!0,right:!0,top:!0,bottom:!0},this._stopped=!1,this._interacting=this._doPhase({interaction:this,event:this.downEvent,phase:"start"})&&!this._stopped,this._interacting)}},{key:"pointerMove",value:function(t,e,n){this.simulation||this.modification&&this.modification.endResult||this.updatePointer(t,e,n,!1);var r,i,o=this.coords.cur.page.x===this.coords.prev.page.x&&this.coords.cur.page.y===this.coords.prev.page.y&&this.coords.cur.client.x===this.coords.prev.client.x&&this.coords.cur.client.y===this.coords.prev.client.y;this.pointerIsDown&&!this.pointerWasMoved&&(r=this.coords.cur.client.x-this.coords.start.client.x,i=this.coords.cur.client.y-this.coords.start.client.y,this.pointerWasMoved=Q(r,i)>this.pointerMoveTolerance);var a,s,c,l=this.getPointerIndex(t),u={pointer:t,pointerIndex:l,pointerInfo:this.pointers[l],event:e,type:"move",eventTarget:n,dx:r,dy:i,duplicate:o,interaction:this};o||(a=this.coords.velocity,s=this.coords.delta,c=Math.max(s.timeStamp/1e3,.001),a.page.x=s.page.x/c,a.page.y=s.page.y/c,a.client.x=s.client.x/c,a.client.y=s.client.y/c,a.timeStamp=c),this._scopeFire("interactions:move",u),o||this.simulation||(this.interacting()&&(u.type=null,this.move(u)),this.pointerWasMoved&&et(this.coords.prev,this.coords.cur))}},{key:"move",value:function(t){t&&t.event||nt(this.coords.delta),(t=V({pointer:this._latestPointer.pointer,event:this._latestPointer.event,eventTarget:this._latestPointer.eventTarget,interaction:this},t||{})).phase="move",this._doPhase(t)}},{key:"pointerUp",value:function(t,e,n,r){var i=this.getPointerIndex(t);-1===i&&(i=this.updatePointer(t,e,n,!1));var o=/cancel$/i.test(e.type)?"cancel":"up";this._scopeFire("interactions:".concat(o),{pointer:t,pointerIndex:i,pointerInfo:this.pointers[i],event:e,eventTarget:n,type:o,curEventTarget:r,interaction:this}),this.simulation||this.end(e),this.removePointer(t,e)}},{key:"documentBlur",value:function(t){this.end(t),this._scopeFire("interactions:blur",{event:t,type:"blur",interaction:this})}},{key:"end",value:function(t){var e;this._ending=!0,t=t||this._latestPointer.event,this.interacting()&&(e=this._doPhase({event:t,interaction:this,phase:"end"})),this._ending=!1,!0===e&&this.stop()}},{key:"currentAction",value:function(){return this._interacting?this.prepared.name:null}},{key:"interacting",value:function(){return this._interacting}},{key:"stop",value:function(){this._scopeFire("interactions:stop",{interaction:this}),this.interactable=this.element=null,this._interacting=!1,this._stopped=!0,this.prepared.name=this.prevEvent=null}},{key:"getPointerIndex",value:function(t){var e=at(t);return"mouse"===this.pointerType||"pen"===this.pointerType?this.pointers.length-1:yt(this.pointers,(function(t){return t.id===e}))}},{key:"getPointerInfo",value:function(t){return this.pointers[this.getPointerIndex(t)]}},{key:"updatePointer",value:function(t,e,n,r){var i,o,a,s=at(t),c=this.getPointerIndex(t),l=this.pointers[c];return r=!1!==r&&(r||/(down|start)$/i.test(e.type)),l?l.pointer=t:(l=new _e(s,t,e,null,null),c=this.pointers.length,this.pointers.push(l)),st(this.coords.cur,this.pointers.map((function(t){return t.pointer})),this._now()),i=this.coords.delta,o=this.coords.prev,a=this.coords.cur,i.page.x=a.page.x-o.page.x,i.page.y=a.page.y-o.page.y,i.client.x=a.client.x-o.client.x,i.client.y=a.client.y-o.client.y,i.timeStamp=a.timeStamp-o.timeStamp,r&&(this.pointerIsDown=!0,l.downTime=this.coords.cur.timeStamp,l.downTarget=n,tt(this.downPointer,t),this.interacting()||(et(this.coords.start,this.coords.cur),et(this.coords.prev,this.coords.cur),this.downEvent=e,this.pointerWasMoved=!1)),this._updateLatestPointer(t,e,n),this._scopeFire("interactions:update-pointer",{pointer:t,event:e,eventTarget:n,down:r,pointerInfo:l,pointerIndex:c,interaction:this}),c}},{key:"removePointer",value:function(t,e){var n=this.getPointerIndex(t);if(-1!==n){var r=this.pointers[n];this._scopeFire("interactions:remove-pointer",{pointer:t,event:e,eventTarget:null,pointerIndex:n,pointerInfo:r,interaction:this}),this.pointers.splice(n,1),this.pointerIsDown=!1}}},{key:"_updateLatestPointer",value:function(t,e,n){this._latestPointer.pointer=t,this._latestPointer.event=e,this._latestPointer.eventTarget=n}},{key:"destroy",value:function(){this._latestPointer.pointer=null,this._latestPointer.event=null,this._latestPointer.eventTarget=null}},{key:"_createPreparedEvent",value:function(t,e,n,r){return new Se(this,t,this.prepared.name,e,this.element,n,r)}},{key:"_fireEvent",value:function(t){var e;null==(e=this.interactable)||e.fire(t),(!this.prevEvent||t.timeStamp>=this.prevEvent.timeStamp)&&(this.prevEvent=t)}},{key:"_doPhase",value:function(t){var e=t.event,n=t.phase,r=t.preEnd,i=t.type,o=this.rect;if(o&&"move"===n&&(H(this.edges,o,this.coords.delta[this.interactable.options.deltaSource]),o.width=o.right-o.left,o.height=o.bottom-o.top),!1===this._scopeFire("interactions:before-action-".concat(n),t))return!1;var a=t.iEvent=this._createPreparedEvent(e,n,r,i);return this._scopeFire("interactions:action-".concat(n),t),"start"===n&&(this.prevEvent=a),this._fireEvent(a),this._scopeFire("interactions:after-action-".concat(n),t),!0}},{key:"_now",value:function(){return Date.now()}}]),t}();function Ie(t){Me(t.interaction)}function Me(t){if(!function(t){return!(!t.offset.pending.x&&!t.offset.pending.y)}(t))return!1;var e=t.offset.pending;return Ae(t.coords.cur,e),Ae(t.coords.delta,e),H(t.edges,t.rect,e),e.x=0,e.y=0,!0}function ze(t){var e=t.x,n=t.y;this.offset.pending.x+=e,this.offset.pending.y+=n,this.offset.total.x+=e,this.offset.total.y+=n}function Ae(t,e){var n=t.page,r=t.client,i=e.x,o=e.y;n.x+=i,n.y+=o,r.x+=i,r.y+=o}Oe.offsetBy="";var Re={id:"offset",before:["modifiers","pointer-events","actions","inertia"],install:function(t){t.Interaction.prototype.offsetBy=ze},listeners:{"interactions:new":function(t){t.interaction.offset={total:{x:0,y:0},pending:{x:0,y:0}}},"interactions:update-pointer":function(t){return function(t){t.pointerIsDown&&(Ae(t.coords.cur,t.offset.total),t.offset.pending.x=0,t.offset.pending.y=0)}(t.interaction)},"interactions:before-action-start":Ie,"interactions:before-action-move":Ie,"interactions:before-action-end":function(t){var e=t.interaction;if(Me(e))return e.move({offset:!0}),e.end(),!1},"interactions:stop":function(t){var e=t.interaction;e.offset.total.x=0,e.offset.total.y=0,e.offset.pending.x=0,e.offset.pending.y=0}}},Ce=Re;var je=function(){function t(e){r(this,t),this.active=!1,this.isModified=!1,this.smoothEnd=!1,this.allowResume=!1,this.modification=void 0,this.modifierCount=0,this.modifierArg=void 0,this.startCoords=void 0,this.t0=0,this.v0=0,this.te=0,this.targetOffset=void 0,this.modifiedOffset=void 0,this.currentOffset=void 0,this.lambda_v0=0,this.one_ve_v0=0,this.timeout=void 0,this.interaction=void 0,this.interaction=e}return o(t,[{key:"start",value:function(t){var e=this.interaction,n=Fe(e);if(!n||!n.enabled)return!1;var r=e.coords.velocity.client,i=Q(r.x,r.y),o=this.modification||(this.modification=new me(e));if(o.copyFrom(e.modification),this.t0=e._now(),this.allowResume=n.allowResume,this.v0=i,this.currentOffset={x:0,y:0},this.startCoords=e.coords.cur.page,this.modifierArg=o.fillArg({pageCoords:this.startCoords,preEnd:!0,phase:"inertiastart"}),this.t0-e.coords.cur.timeStamp<50&&i>n.minSpeed&&i>n.endSpeed)this.startInertia();else{if(o.result=o.setAll(this.modifierArg),!o.result.changed)return!1;this.startSmoothEnd()}return e.modification.result.rect=null,e.offsetBy(this.targetOffset),e._doPhase({interaction:e,event:t,phase:"inertiastart"}),e.offsetBy({x:-this.targetOffset.x,y:-this.targetOffset.y}),e.modification.result.rect=null,this.active=!0,e.simulation=this,!0}},{key:"startInertia",value:function(){var t=this,e=this.interaction.coords.velocity.client,n=Fe(this.interaction),r=n.resistance,i=-Math.log(n.endSpeed/this.v0)/r;this.targetOffset={x:(e.x-i)/r,y:(e.y-i)/r},this.te=i,this.lambda_v0=r/this.v0,this.one_ve_v0=1-n.endSpeed/this.v0;var o=this.modification,a=this.modifierArg;a.pageCoords={x:this.startCoords.x+this.targetOffset.x,y:this.startCoords.y+this.targetOffset.y},o.result=o.setAll(a),o.result.changed&&(this.isModified=!0,this.modifiedOffset={x:this.targetOffset.x+o.result.delta.x,y:this.targetOffset.y+o.result.delta.y}),this.onNextFrame((function(){return t.inertiaTick()}))}},{key:"startSmoothEnd",value:function(){var t=this;this.smoothEnd=!0,this.isModified=!0,this.targetOffset={x:this.modification.result.delta.x,y:this.modification.result.delta.y},this.onNextFrame((function(){return t.smoothEndTick()}))}},{key:"onNextFrame",value:function(t){var e=this;this.timeout=Lt.request((function(){e.active&&t()}))}},{key:"inertiaTick",value:function(){var t,e,n,r,i,o,a,s=this,c=this.interaction,l=Fe(c).resistance,u=(c._now()-this.t0)/1e3;if(u<this.te){var p,f=1-(Math.exp(-l*u)-this.lambda_v0)/this.one_ve_v0;this.isModified?(t=0,e=0,n=this.targetOffset.x,r=this.targetOffset.y,i=this.modifiedOffset.x,o=this.modifiedOffset.y,p={x:Ye(a=f,t,n,i),y:Ye(a,e,r,o)}):p={x:this.targetOffset.x*f,y:this.targetOffset.y*f};var d={x:p.x-this.currentOffset.x,y:p.y-this.currentOffset.y};this.currentOffset.x+=d.x,this.currentOffset.y+=d.y,c.offsetBy(d),c.move(),this.onNextFrame((function(){return s.inertiaTick()}))}else c.offsetBy({x:this.modifiedOffset.x-this.currentOffset.x,y:this.modifiedOffset.y-this.currentOffset.y}),this.end()}},{key:"smoothEndTick",value:function(){var t=this,e=this.interaction,n=e._now()-this.t0,r=Fe(e).smoothEndDuration;if(n<r){var i={x:Le(n,0,this.targetOffset.x,r),y:Le(n,0,this.targetOffset.y,r)},o={x:i.x-this.currentOffset.x,y:i.y-this.currentOffset.y};this.currentOffset.x+=o.x,this.currentOffset.y+=o.y,e.offsetBy(o),e.move({skipModifiers:this.modifierCount}),this.onNextFrame((function(){return t.smoothEndTick()}))}else e.offsetBy({x:this.targetOffset.x-this.currentOffset.x,y:this.targetOffset.y-this.currentOffset.y}),this.end()}},{key:"resume",value:function(t){var e=t.pointer,n=t.event,r=t.eventTarget,i=this.interaction;i.offsetBy({x:-this.currentOffset.x,y:-this.currentOffset.y}),i.updatePointer(e,n,r,!0),i._doPhase({interaction:i,event:n,phase:"resume"}),et(i.coords.prev,i.coords.cur),this.stop()}},{key:"end",value:function(){this.interaction.move(),this.interaction.end(),this.stop()}},{key:"stop",value:function(){this.active=this.smoothEnd=!1,this.interaction.simulation=null,Lt.cancel(this.timeout)}}]),t}();function Fe(t){var e=t.interactable,n=t.prepared;return e&&e.options&&n.name&&e.options[n.name].inertia}var Xe={id:"inertia",before:["modifiers","actions"],install:function(t){var e=t.defaults;t.usePlugin(Ce),t.usePlugin(Ee),t.actions.phases.inertiastart=!0,t.actions.phases.resume=!0,e.perAction.inertia={enabled:!1,resistance:10,minSpeed:100,endSpeed:10,allowResume:!0,smoothEndDuration:300}},listeners:{"interactions:new":function(t){var e=t.interaction;e.inertia=new je(e)},"interactions:before-action-end":function(t){var e=t.interaction,n=t.event;return(!e._interacting||e.simulation||!e.inertia.start(n))&&null},"interactions:down":function(t){var e=t.interaction,n=t.eventTarget,r=e.inertia;if(r.active)for(var i=n;w.element(i);){if(i===e.element){r.resume(t);break}i=A(i)}},"interactions:stop":function(t){var e=t.interaction.inertia;e.active&&e.stop()},"interactions:before-action-resume":function(t){var e=t.interaction.modification;e.stop(t),e.start(t,t.interaction.coords.cur.page),e.applyToInteraction(t)},"interactions:before-action-inertiastart":function(t){return t.interaction.modification.setAndApply(t)},"interactions:action-resume":xe,"interactions:action-inertiastart":xe,"interactions:after-action-inertiastart":function(t){return t.interaction.modification.restoreInteractionCoords(t)},"interactions:after-action-resume":function(t){return t.interaction.modification.restoreInteractionCoords(t)}}};function Ye(t,e,n,r){var i=1-t;return i*i*e+2*i*t*n+t*t*r}function Le(t,e,n,r){return-n*(t/=r)*(t-2)+e}var qe=Xe;function Be(t,e){for(var n=0;n<e.length;n++){var r=e[n];if(t.immediatePropagationStopped)break;r(t)}}var Ve=function(){function t(e){r(this,t),this.options=void 0,this.types={},this.propagationStopped=!1,this.immediatePropagationStopped=!1,this.global=void 0,this.options=V({},e||{})}return o(t,[{key:"fire",value:function(t){var e,n=this.global;(e=this.types[t.type])&&Be(t,e),!t.propagationStopped&&n&&(e=n[t.type])&&Be(t,e)}},{key:"on",value:function(t,e){var n=$(t,e);for(t in n)this.types[t]=gt(this.types[t]||[],n[t])}},{key:"off",value:function(t,e){var n=$(t,e);for(t in n){var r=this.types[t];if(r&&r.length)for(var i=0,o=n[t];i<o.length;i++){var a=o[i],s=r.indexOf(a);-1!==s&&r.splice(s,1)}}}},{key:"getRect",value:function(t){return null}}]),t}();var We=function(){function t(e){r(this,t),this.currentTarget=void 0,this.originalEvent=void 0,this.type=void 0,this.originalEvent=e,tt(this,e)}return o(t,[{key:"preventOriginalDefault",value:function(){this.originalEvent.preventDefault()}},{key:"stopPropagation",value:function(){this.originalEvent.stopPropagation()}},{key:"stopImmediatePropagation",value:function(){this.originalEvent.stopImmediatePropagation()}}]),t}();function Ge(t){return w.object(t)?{capture:!!t.capture,passive:!!t.passive}:{capture:!!t,passive:!1}}function Ne(t,e){return t===e||("boolean"==typeof t?!!e.capture===t&&!1==!!e.passive:!!t.capture==!!e.capture&&!!t.passive==!!e.passive)}var Ue={id:"events",install:function(t){var e,n=[],r={},i=[],o={add:a,remove:s,addDelegate:function(t,e,n,o,s){var u=Ge(s);if(!r[n]){r[n]=[];for(var p=0;p<i.length;p++){var f=i[p];a(f,n,c),a(f,n,l,!0)}}var d=r[n],h=bt(d,(function(n){return n.selector===t&&n.context===e}));h||(h={selector:t,context:e,listeners:[]},d.push(h));h.listeners.push({func:o,options:u})},removeDelegate:function(t,e,n,i,o){var a,u=Ge(o),p=r[n],f=!1;if(!p)return;for(a=p.length-1;a>=0;a--){var d=p[a];if(d.selector===t&&d.context===e){for(var h=d.listeners,v=h.length-1;v>=0;v--){var g=h[v];if(g.func===i&&Ne(g.options,u)){h.splice(v,1),h.length||(p.splice(a,1),s(e,n,c),s(e,n,l,!0)),f=!0;break}}if(f)break}}},delegateListener:c,delegateUseCapture:l,delegatedEvents:r,documents:i,targets:n,supportsOptions:!1,supportsPassive:!1};function a(t,e,r,i){if(t.addEventListener){var a=Ge(i),s=bt(n,(function(e){return e.eventTarget===t}));s||(s={eventTarget:t,events:{}},n.push(s)),s.events[e]||(s.events[e]=[]),bt(s.events[e],(function(t){return t.func===r&&Ne(t.options,a)}))||(t.addEventListener(e,r,o.supportsOptions?a:a.capture),s.events[e].push({func:r,options:a}))}}function s(t,e,r,i){if(t.addEventListener&&t.removeEventListener){var a=yt(n,(function(e){return e.eventTarget===t})),c=n[a];if(c&&c.events)if("all"!==e){var l=!1,u=c.events[e];if(u){if("all"===r){for(var p=u.length-1;p>=0;p--){var f=u[p];s(t,e,f.func,f.options)}return}for(var d=Ge(i),h=0;h<u.length;h++){var v=u[h];if(v.func===r&&Ne(v.options,d)){t.removeEventListener(e,r,o.supportsOptions?d:d.capture),u.splice(h,1),0===u.length&&(delete c.events[e],l=!0);break}}}l&&!Object.keys(c.events).length&&n.splice(a,1)}else for(e in c.events)c.events.hasOwnProperty(e)&&s(t,e,"all")}}function c(t,e){for(var n=Ge(e),i=new We(t),o=r[t.type],a=ht(t)[0],s=a;w.element(s);){for(var c=0;c<o.length;c++){var l=o[c],u=l.selector,p=l.context;if(R(s,u)&&M(p,a)&&M(p,s)){var f=l.listeners;i.currentTarget=s;for(var d=0;d<f.length;d++){var h=f[d];Ne(h.options,n)&&h.func(i)}}}s=A(s)}}function l(t){return c(t,!0)}return null==(e=t.document)||e.createElement("div").addEventListener("test",null,{get capture(){return o.supportsOptions=!0},get passive(){return o.supportsPassive=!0}}),t.events=o,o}},He={methodOrder:["simulationResume","mouseOrPen","hasPointer","idle"],search:function(t){for(var e=0,n=He.methodOrder;e<n.length;e++){var r=n[e],i=He[r](t);if(i)return i}return null},simulationResume:function(t){var e=t.pointerType,n=t.eventType,r=t.eventTarget,i=t.scope;if(!/down|start/i.test(n))return null;for(var o=0,a=i.interactions.list;o<a.length;o++){var s=a[o],c=r;if(s.simulation&&s.simulation.allowResume&&s.pointerType===e)for(;c;){if(c===s.element)return s;c=A(c)}}return null},mouseOrPen:function(t){var e,n=t.pointerId,r=t.pointerType,i=t.eventType,o=t.scope;if("mouse"!==r&&"pen"!==r)return null;for(var a=0,s=o.interactions.list;a<s.length;a++){var c=s[a];if(c.pointerType===r){if(c.simulation&&!Ke(c,n))continue;if(c.interacting())return c;e||(e=c)}}if(e)return e;for(var l=0,u=o.interactions.list;l<u.length;l++){var p=u[l];if(!(p.pointerType!==r||/down/i.test(i)&&p.simulation))return p}return null},hasPointer:function(t){for(var e=t.pointerId,n=0,r=t.scope.interactions.list;n<r.length;n++){var i=r[n];if(Ke(i,e))return i}return null},idle:function(t){for(var e=t.pointerType,n=0,r=t.scope.interactions.list;n<r.length;n++){var i=r[n];if(1===i.pointers.length){var o=i.interactable;if(o&&(!o.options.gesture||!o.options.gesture.enabled))continue}else if(i.pointers.length>=2)continue;if(!i.interacting()&&e===i.pointerType)return i}return null}};function Ke(t,e){return t.pointers.some((function(t){return t.id===e}))}var $e=He,Je=["pointerDown","pointerMove","pointerUp","updatePointer","removePointer","windowBlur"];function Qe(t,e){return function(n){var r=e.interactions.list,i=dt(n),o=ht(n),a=o[0],s=o[1],c=[];if(/^touch/.test(n.type)){e.prevTouchTime=e.now();for(var l=0,u=n.changedTouches;l<u.length;l++){var p=u[l],f={pointer:p,pointerId:at(p),pointerType:i,eventType:n.type,eventTarget:a,curEventTarget:s,scope:e},d=Ze(f);c.push([f.pointer,f.eventTarget,f.curEventTarget,d])}}else{var h=!1;if(!I.supportsPointerEvent&&/mouse/.test(n.type)){for(var v=0;v<r.length&&!h;v++)h="mouse"!==r[v].pointerType&&r[v].pointerIsDown;h=h||e.now()-e.prevTouchTime<500||0===n.timeStamp}if(!h){var g={pointer:n,pointerId:at(n),pointerType:i,eventType:n.type,curEventTarget:s,eventTarget:a,scope:e},m=Ze(g);c.push([g.pointer,g.eventTarget,g.curEventTarget,m])}}for(var y=0;y<c.length;y++){var b=c[y],x=b[0],w=b[1],E=b[2];b[3][t](x,n,w,E)}}}function Ze(t){var e=t.pointerType,n=t.scope,r={interaction:$e.search(t),searchDetails:t};return n.fire("interactions:find",r),r.interaction||n.interactions.new({pointerType:e})}function tn(t,e){var n=t.doc,r=t.scope,i=t.options,o=r.interactions.docEvents,a=r.events,s=a[e];for(var c in r.browser.isIOS&&!i.events&&(i.events={passive:!1}),a.delegatedEvents)s(n,c,a.delegateListener),s(n,c,a.delegateUseCapture,!0);for(var l=i&&i.events,u=0;u<o.length;u++){var p=o[u];s(n,p.type,p.listener,l)}}var en={id:"core/interactions",install:function(t){for(var e={},n=0;n<Je.length;n++){var i=Je[n];e[i]=Qe(i,t)}var a,c=I.pEventTypes;function l(){for(var e=0,n=t.interactions.list;e<n.length;e++){var r=n[e];if(r.pointerIsDown&&"touch"===r.pointerType&&!r._interacting)for(var i=function(){var e=a[o];t.documents.some((function(t){return M(t.doc,e.downTarget)}))||r.removePointer(e.pointer,e.event)},o=0,a=r.pointers;o<a.length;o++)i()}}(a=k.PointerEvent?[{type:c.down,listener:l},{type:c.down,listener:e.pointerDown},{type:c.move,listener:e.pointerMove},{type:c.up,listener:e.pointerUp},{type:c.cancel,listener:e.pointerUp}]:[{type:"mousedown",listener:e.pointerDown},{type:"mousemove",listener:e.pointerMove},{type:"mouseup",listener:e.pointerUp},{type:"touchstart",listener:l},{type:"touchstart",listener:e.pointerDown},{type:"touchmove",listener:e.pointerMove},{type:"touchend",listener:e.pointerUp},{type:"touchcancel",listener:e.pointerUp}]).push({type:"blur",listener:function(e){for(var n=0,r=t.interactions.list;n<r.length;n++){r[n].documentBlur(e)}}}),t.prevTouchTime=0,t.Interaction=function(e){s(i,e);var n=p(i);function i(){return r(this,i),n.apply(this,arguments)}return o(i,[{key:"pointerMoveTolerance",get:function(){return t.interactions.pointerMoveTolerance},set:function(e){t.interactions.pointerMoveTolerance=e}},{key:"_now",value:function(){return t.now()}}]),i}(De),t.interactions={list:[],new:function(e){e.scopeFire=function(e,n){return t.fire(e,n)};var n=new t.Interaction(e);return t.interactions.list.push(n),n},listeners:e,docEvents:a,pointerMoveTolerance:1},t.usePlugin(he)},listeners:{"scope:add-document":function(t){return tn(t,"add")},"scope:remove-document":function(t){return tn(t,"remove")},"interactable:unset":function(t,e){for(var n=t.interactable,r=e.interactions.list.length-1;r>=0;r--){var i=e.interactions.list[r];i.interactable===n&&(i.stop(),e.fire("interactions:destroy",{interaction:i}),i.destroy(),e.interactions.list.length>2&&e.interactions.list.splice(r,1))}}},onDocSignal:tn,doOnInteractions:Qe,methodNames:Je},nn=en,rn=function(t){return t[t.On=0]="On",t[t.Off=1]="Off",t}(rn||{}),on=function(){function t(e,n,i,o){r(this,t),this.target=void 0,this.options=void 0,this._actions=void 0,this.events=new Ve,this._context=void 0,this._win=void 0,this._doc=void 0,this._scopeEvents=void 0,this._actions=n.actions,this.target=e,this._context=n.context||i,this._win=y(B(e)?this._context:e),this._doc=this._win.document,this._scopeEvents=o,this.set(n)}return o(t,[{key:"_defaults",get:function(){return{base:{},perAction:{},actions:{}}}},{key:"setOnEvents",value:function(t,e){return w.func(e.onstart)&&this.on("".concat(t,"start"),e.onstart),w.func(e.onmove)&&this.on("".concat(t,"move"),e.onmove),w.func(e.onend)&&this.on("".concat(t,"end"),e.onend),w.func(e.oninertiastart)&&this.on("".concat(t,"inertiastart"),e.oninertiastart),this}},{key:"updatePerActionListeners",value:function(t,e,n){var r,i=this,o=null==(r=this._actions.map[t])?void 0:r.filterEventType,a=function(t){return(null==o||o(t))&&ve(t,i._actions)};(w.array(e)||w.object(e))&&this._onOff(rn.Off,t,e,void 0,a),(w.array(n)||w.object(n))&&this._onOff(rn.On,t,n,void 0,a)}},{key:"setPerAction",value:function(t,e){var n=this._defaults;for(var r in e){var i=r,o=this.options[t],a=e[i];"listeners"===i&&this.updatePerActionListeners(t,o.listeners,a),w.array(a)?o[i]=mt(a):w.plainObject(a)?(o[i]=V(o[i]||{},ge(a)),w.object(n.perAction[i])&&"enabled"in n.perAction[i]&&(o[i].enabled=!1!==a.enabled)):w.bool(a)&&w.object(n.perAction[i])?o[i].enabled=a:o[i]=a}}},{key:"getRect",value:function(t){return t=t||(w.element(this.target)?this.target:null),w.string(this.target)&&(t=t||this._context.querySelector(this.target)),L(t)}},{key:"rectChecker",value:function(t){var e=this;return w.func(t)?(this.getRect=function(n){var r=V({},t.apply(e,n));return"width"in r||(r.width=r.right-r.left,r.height=r.bottom-r.top),r},this):null===t?(delete this.getRect,this):this.getRect}},{key:"_backCompatOption",value:function(t,e){if(B(e)||w.object(e)){for(var n in this.options[t]=e,this._actions.map)this.options[n][t]=e;return this}return this.options[t]}},{key:"origin",value:function(t){return this._backCompatOption("origin",t)}},{key:"deltaSource",value:function(t){return"page"===t||"client"===t?(this.options.deltaSource=t,this):this.options.deltaSource}},{key:"getAllElements",value:function(){var t=this.target;return w.string(t)?Array.from(this._context.querySelectorAll(t)):w.func(t)&&t.getAllElements?t.getAllElements():w.element(t)?[t]:[]}},{key:"context",value:function(){return this._context}},{key:"inContext",value:function(t){return this._context===t.ownerDocument||M(this._context,t)}},{key:"testIgnoreAllow",value:function(t,e,n){return!this.testIgnore(t.ignoreFrom,e,n)&&this.testAllow(t.allowFrom,e,n)}},{key:"testAllow",value:function(t,e,n){return!t||!!w.element(n)&&(w.string(t)?F(n,t,e):!!w.element(t)&&M(t,n))}},{key:"testIgnore",value:function(t,e,n){return!(!t||!w.element(n))&&(w.string(t)?F(n,t,e):!!w.element(t)&&M(t,n))}},{key:"fire",value:function(t){return this.events.fire(t),this}},{key:"_onOff",value:function(t,e,n,r,i){w.object(e)&&!w.array(e)&&(r=n,n=null);var o=$(e,n,i);for(var a in o){"wheel"===a&&(a=I.wheelEvent);for(var s=0,c=o[a];s<c.length;s++){var l=c[s];ve(a,this._actions)?this.events[t===rn.On?"on":"off"](a,l):w.string(this.target)?this._scopeEvents[t===rn.On?"addDelegate":"removeDelegate"](this.target,this._context,a,l,r):this._scopeEvents[t===rn.On?"add":"remove"](this.target,a,l,r)}}return this}},{key:"on",value:function(t,e,n){return this._onOff(rn.On,t,e,n)}},{key:"off",value:function(t,e,n){return this._onOff(rn.Off,t,e,n)}},{key:"set",value:function(t){var e=this._defaults;for(var n in w.object(t)||(t={}),this.options=ge(e.base),this._actions.methodDict){var r=n,i=this._actions.methodDict[r];this.options[r]={},this.setPerAction(r,V(V({},e.perAction),e.actions[r])),this[i](t[r])}for(var o in t)"getRect"!==o?w.func(this[o])&&this[o](t[o]):this.rectChecker(t.getRect);return this}},{key:"unset",value:function(){if(w.string(this.target))for(var t in this._scopeEvents.delegatedEvents)for(var e=this._scopeEvents.delegatedEvents[t],n=e.length-1;n>=0;n--){var r=e[n],i=r.selector,o=r.context,a=r.listeners;i===this.target&&o===this._context&&e.splice(n,1);for(var s=a.length-1;s>=0;s--)this._scopeEvents.removeDelegate(this.target,this._context,t,a[s][0],a[s][1])}else this._scopeEvents.remove(this.target,"all")}}]),t}(),an=function(){function t(e){var n=this;r(this,t),this.list=[],this.selectorMap={},this.scope=void 0,this.scope=e,e.addListeners({"interactable:unset":function(t){var e=t.interactable,r=e.target,i=w.string(r)?n.selectorMap[r]:r[n.scope.id],o=yt(i,(function(t){return t===e}));i.splice(o,1)}})}return o(t,[{key:"new",value:function(t,e){e=V(e||{},{actions:this.scope.actions});var n=new this.scope.Interactable(t,e,this.scope.document,this.scope.events);return this.scope.addDocument(n._doc),this.list.push(n),w.string(t)?(this.selectorMap[t]||(this.selectorMap[t]=[]),this.selectorMap[t].push(n)):(n.target[this.scope.id]||Object.defineProperty(t,this.scope.id,{value:[],configurable:!0}),t[this.scope.id].push(n)),this.scope.fire("interactable:new",{target:t,options:e,interactable:n,win:this.scope._win}),n}},{key:"getExisting",value:function(t,e){var n=e&&e.context||this.scope.document,r=w.string(t),i=r?this.selectorMap[t]:t[this.scope.id];if(i)return bt(i,(function(e){return e._context===n&&(r||e.inContext(t))}))}},{key:"forEachMatch",value:function(t,e){for(var n=0,r=this.list;n<r.length;n++){var i=r[n],o=void 0;if((w.string(i.target)?w.element(t)&&R(t,i.target):t===i.target)&&i.inContext(t)&&(o=e(i)),void 0!==o)return o}}}]),t}();var sn=function(){function t(){var e=this;r(this,t),this.id="__interact_scope_".concat(Math.floor(100*Math.random())),this.isInitialized=!1,this.listenerMaps=[],this.browser=I,this.defaults=ge(Te),this.Eventable=Ve,this.actions={map:{},phases:{start:!0,move:!0,end:!0},methodDict:{},phaselessTypes:{}},this.interactStatic=function(t){var e=function e(n,r){var i=t.interactables.getExisting(n,r);return i||((i=t.interactables.new(n,r)).events.global=e.globalEvents),i};return e.getPointerAverage=lt,e.getTouchBBox=ut,e.getTouchDistance=pt,e.getTouchAngle=ft,e.getElementRect=L,e.getElementClientRect=Y,e.matchesSelector=R,e.closest=z,e.globalEvents={},e.version="1.10.27",e.scope=t,e.use=function(t,e){return this.scope.usePlugin(t,e),this},e.isSet=function(t,e){return!!this.scope.interactables.get(t,e&&e.context)},e.on=Nt((function(t,e,n){if(w.string(t)&&-1!==t.search(" ")&&(t=t.trim().split(/ +/)),w.array(t)){for(var r=0,i=t;r<i.length;r++){var o=i[r];this.on(o,e,n)}return this}if(w.object(t)){for(var a in t)this.on(a,t[a],e);return this}return ve(t,this.scope.actions)?this.globalEvents[t]?this.globalEvents[t].push(e):this.globalEvents[t]=[e]:this.scope.events.add(this.scope.document,t,e,{options:n}),this}),"The interact.on() method is being deprecated"),e.off=Nt((function(t,e,n){if(w.string(t)&&-1!==t.search(" ")&&(t=t.trim().split(/ +/)),w.array(t)){for(var r=0,i=t;r<i.length;r++){var o=i[r];this.off(o,e,n)}return this}if(w.object(t)){for(var a in t)this.off(a,t[a],e);return this}var s;return ve(t,this.scope.actions)?t in this.globalEvents&&-1!==(s=this.globalEvents[t].indexOf(e))&&this.globalEvents[t].splice(s,1):this.scope.events.remove(this.scope.document,t,e,n),this}),"The interact.off() method is being deprecated"),e.debug=function(){return this.scope},e.supportsTouch=function(){return I.supportsTouch},e.supportsPointerEvent=function(){return I.supportsPointerEvent},e.stop=function(){for(var t=0,e=this.scope.interactions.list;t<e.length;t++)e[t].stop();return this},e.pointerMoveTolerance=function(t){return w.number(t)?(this.scope.interactions.pointerMoveTolerance=t,this):this.scope.interactions.pointerMoveTolerance},e.addDocument=function(t,e){this.scope.addDocument(t,e)},e.removeDocument=function(t){this.scope.removeDocument(t)},e}(this),this.InteractEvent=Se,this.Interactable=void 0,this.interactables=new an(this),this._win=void 0,this.document=void 0,this.window=void 0,this.documents=[],this._plugins={list:[],map:{}},this.onWindowUnload=function(t){return e.removeDocument(t.target)};var n=this;this.Interactable=function(t){s(i,t);var e=p(i);function i(){return r(this,i),e.apply(this,arguments)}return o(i,[{key:"_defaults",get:function(){return n.defaults}},{key:"set",value:function(t){return f(c(i.prototype),"set",this).call(this,t),n.fire("interactable:set",{options:t,interactable:this}),this}},{key:"unset",value:function(){f(c(i.prototype),"unset",this).call(this);var t=n.interactables.list.indexOf(this);t<0||(n.interactables.list.splice(t,1),n.fire("interactable:unset",{interactable:this}))}}]),i}(on)}return o(t,[{key:"addListeners",value:function(t,e){this.listenerMaps.push({id:e,map:t})}},{key:"fire",value:function(t,e){for(var n=0,r=this.listenerMaps;n<r.length;n++){var i=r[n].map[t];if(i&&!1===i(e,this,t))return!1}}},{key:"init",value:function(t){return this.isInitialized?this:function(t,e){t.isInitialized=!0,w.window(e)&&m(e);return k.init(e),I.init(e),Lt.init(e),t.window=e,t.document=e.document,t.usePlugin(nn),t.usePlugin(Ue),t}(this,t)}},{key:"pluginIsInstalled",value:function(t){var e=t.id;return e?!!this._plugins.map[e]:-1!==this._plugins.list.indexOf(t)}},{key:"usePlugin",value:function(t,e){if(!this.isInitialized)return this;if(this.pluginIsInstalled(t))return this;if(t.id&&(this._plugins.map[t.id]=t),this._plugins.list.push(t),t.install&&t.install(this,e),t.listeners&&t.before){for(var n=0,r=this.listenerMaps.length,i=t.before.reduce((function(t,e){return t[e]=!0,t[cn(e)]=!0,t}),{});n<r;n++){var o=this.listenerMaps[n].id;if(o&&(i[o]||i[cn(o)]))break}this.listenerMaps.splice(n,0,{id:t.id,map:t.listeners})}else t.listeners&&this.listenerMaps.push({id:t.id,map:t.listeners});return this}},{key:"addDocument",value:function(t,e){if(-1!==this.getDocIndex(t))return!1;var n=y(t);e=e?V({},e):{},this.documents.push({doc:t,options:e}),this.events.documents.push(t),t!==this.document&&this.events.add(n,"unload",this.onWindowUnload),this.fire("scope:add-document",{doc:t,window:n,scope:this,options:e})}},{key:"removeDocument",value:function(t){var e=this.getDocIndex(t),n=y(t),r=this.documents[e].options;this.events.remove(n,"unload",this.onWindowUnload),this.documents.splice(e,1),this.events.documents.splice(e,1),this.fire("scope:remove-document",{doc:t,window:n,scope:this,options:r})}},{key:"getDocIndex",value:function(t){for(var e=0;e<this.documents.length;e++)if(this.documents[e].doc===t)return e;return-1}},{key:"getDocOptions",value:function(t){var e=this.getDocIndex(t);return-1===e?null:this.documents[e].options}},{key:"now",value:function(){return(this.window.Date||Date).now()}}]),t}();function cn(t){return t&&t.replace(/\/.*$/,"")}var ln=new sn,un=ln.interactStatic,pn="undefined"!=typeof globalThis?globalThis:window;ln.init(pn);var fn=Object.freeze({__proto__:null,edgeTarget:function(){},elements:function(){},grid:function(t){var e=[["x","y"],["left","top"],["right","bottom"],["width","height"]].filter((function(e){var n=e[0],r=e[1];return n in t||r in t})),n=function(n,r){for(var i=t.range,o=t.limits,a=void 0===o?{left:-1/0,right:1/0,top:-1/0,bottom:1/0}:o,s=t.offset,c=void 0===s?{x:0,y:0}:s,l={range:i,grid:t,x:null,y:null},u=0;u<e.length;u++){var p=e[u],f=p[0],d=p[1],h=Math.round((n-c.x)/t[f]),v=Math.round((r-c.y)/t[d]);l[f]=Math.max(a.left,Math.min(a.right,h*t[f]+c.x)),l[d]=Math.max(a.top,Math.min(a.bottom,v*t[d]+c.y))}return l};return n.grid=t,n.coordFields=e,n}}),dn={id:"snappers",install:function(t){var e=t.interactStatic;e.snappers=V(e.snappers||{},fn),e.createSnapGrid=e.snappers.grid}},hn=dn,vn={start:function(t){var n=t.state,r=t.rect,i=t.edges,o=t.pageCoords,a=n.options,s=a.ratio,c=a.enabled,l=n.options,u=l.equalDelta,p=l.modifiers;"preserve"===s&&(s=r.width/r.height),n.startCoords=V({},o),n.startRect=V({},r),n.ratio=s,n.equalDelta=u;var f=n.linkedEdges={top:i.top||i.left&&!i.bottom,left:i.left||i.top&&!i.right,bottom:i.bottom||i.right&&!i.top,right:i.right||i.bottom&&!i.left};if(n.xIsPrimaryAxis=!(!i.left&&!i.right),n.equalDelta){var d=(f.left?1:-1)*(f.top?1:-1);n.edgeSign={x:d,y:d}}else n.edgeSign={x:f.left?-1:1,y:f.top?-1:1};if(!1!==c&&V(i,f),null!=p&&p.length){var h=new me(t.interaction);h.copyFrom(t.interaction.modification),h.prepareStates(p),n.subModification=h,h.startAll(e({},t))}},set:function(t){var n=t.state,r=t.rect,i=t.coords,o=n.linkedEdges,a=V({},i),s=n.equalDelta?gn:mn;if(V(t.edges,o),s(n,n.xIsPrimaryAxis,i,r),!n.subModification)return null;var c=V({},r);H(o,c,{x:i.x-a.x,y:i.y-a.y});var l=n.subModification.setAll(e(e({},t),{},{rect:c,edges:o,pageCoords:i,prevCoords:i,prevRect:c})),u=l.delta;l.changed&&(s(n,Math.abs(u.x)>Math.abs(u.y),l.coords,l.rect),V(i,l.coords));return l.eventProps},defaults:{ratio:"preserve",equalDelta:!1,modifiers:[],enabled:!1}};function gn(t,e,n){var r=t.startCoords,i=t.edgeSign;e?n.y=r.y+(n.x-r.x)*i.y:n.x=r.x+(n.y-r.y)*i.x}function mn(t,e,n,r){var i=t.startRect,o=t.startCoords,a=t.ratio,s=t.edgeSign;if(e){var c=r.width/a;n.y=o.y+(c-i.height)*s.y}else{var l=r.height*a;n.x=o.x+(l-i.width)*s.x}}var yn=be(vn,"aspectRatio"),bn=function(){};bn._defaults={};var xn=bn;function wn(t,e,n){return w.func(t)?G(t,e.interactable,e.element,[n.x,n.y,e]):G(t,e.interactable,e.element)}var En={start:function(t){var e=t.rect,n=t.startOffset,r=t.state,i=t.interaction,o=t.pageCoords,a=r.options,s=a.elementRect,c=V({left:0,top:0,right:0,bottom:0},a.offset||{});if(e&&s){var l=wn(a.restriction,i,o);if(l){var u=l.right-l.left-e.width,p=l.bottom-l.top-e.height;u<0&&(c.left+=u,c.right+=u),p<0&&(c.top+=p,c.bottom+=p)}c.left+=n.left-e.width*s.left,c.top+=n.top-e.height*s.top,c.right+=n.right-e.width*(1-s.right),c.bottom+=n.bottom-e.height*(1-s.bottom)}r.offset=c},set:function(t){var e=t.coords,n=t.interaction,r=t.state,i=r.options,o=r.offset,a=wn(i.restriction,n,e);if(a){var s=function(t){return!t||"left"in t&&"top"in t||((t=V({},t)).left=t.x||0,t.top=t.y||0,t.right=t.right||t.left+t.width,t.bottom=t.bottom||t.top+t.height),t}(a);e.x=Math.max(Math.min(s.right-o.right,e.x),s.left+o.left),e.y=Math.max(Math.min(s.bottom-o.bottom,e.y),s.top+o.top)}},defaults:{restriction:null,elementRect:null,offset:null,endOnly:!1,enabled:!1}},Tn=be(En,"restrict"),Sn={top:1/0,left:1/0,bottom:-1/0,right:-1/0},_n={top:-1/0,left:-1/0,bottom:1/0,right:1/0};function Pn(t,e){for(var n=0,r=["top","left","bottom","right"];n<r.length;n++){var i=r[n];i in t||(t[i]=e[i])}return t}var On={noInner:Sn,noOuter:_n,start:function(t){var e,n=t.interaction,r=t.startOffset,i=t.state,o=i.options;o&&(e=N(wn(o.offset,n,n.coords.start.page))),e=e||{x:0,y:0},i.offset={top:e.y+r.top,left:e.x+r.left,bottom:e.y-r.bottom,right:e.x-r.right}},set:function(t){var e=t.coords,n=t.edges,r=t.interaction,i=t.state,o=i.offset,a=i.options;if(n){var s=V({},e),c=wn(a.inner,r,s)||{},l=wn(a.outer,r,s)||{};Pn(c,Sn),Pn(l,_n),n.top?e.y=Math.min(Math.max(l.top+o.top,s.y),c.top+o.top):n.bottom&&(e.y=Math.max(Math.min(l.bottom+o.bottom,s.y),c.bottom+o.bottom)),n.left?e.x=Math.min(Math.max(l.left+o.left,s.x),c.left+o.left):n.right&&(e.x=Math.max(Math.min(l.right+o.right,s.x),c.right+o.right))}},defaults:{inner:null,outer:null,offset:null,endOnly:!1,enabled:!1}},kn=be(On,"restrictEdges"),Dn=V({get elementRect(){return{top:0,left:0,bottom:1,right:1}},set elementRect(t){}},En.defaults),In=be({start:En.start,set:En.set,defaults:Dn},"restrictRect"),Mn={width:-1/0,height:-1/0},zn={width:1/0,height:1/0};var An=be({start:function(t){return On.start(t)},set:function(t){var e=t.interaction,n=t.state,r=t.rect,i=t.edges,o=n.options;if(i){var a=U(wn(o.min,e,t.coords))||Mn,s=U(wn(o.max,e,t.coords))||zn;n.options={endOnly:o.endOnly,inner:V({},On.noInner),outer:V({},On.noOuter)},i.top?(n.options.inner.top=r.bottom-a.height,n.options.outer.top=r.bottom-s.height):i.bottom&&(n.options.inner.bottom=r.top+a.height,n.options.outer.bottom=r.top+s.height),i.left?(n.options.inner.left=r.right-a.width,n.options.outer.left=r.right-s.width):i.right&&(n.options.inner.right=r.left+a.width,n.options.outer.right=r.left+s.width),On.set(t),n.options=o}},defaults:{min:null,max:null,endOnly:!1,enabled:!1}},"restrictSize");var Rn={start:function(t){var e,n=t.interaction,r=t.interactable,i=t.element,o=t.rect,a=t.state,s=t.startOffset,c=a.options,l=c.offsetWithOrigin?function(t){var e=t.interaction.element,n=N(G(t.state.options.origin,null,null,[e])),r=n||K(t.interactable,e,t.interaction.prepared.name);return r}(t):{x:0,y:0};if("startCoords"===c.offset)e={x:n.coords.start.page.x,y:n.coords.start.page.y};else{var u=G(c.offset,r,i,[n]);(e=N(u)||{x:0,y:0}).x+=l.x,e.y+=l.y}var p=c.relativePoints;a.offsets=o&&p&&p.length?p.map((function(t,n){return{index:n,relativePoint:t,x:s.left-o.width*t.x+e.x,y:s.top-o.height*t.y+e.y}})):[{index:0,relativePoint:null,x:e.x,y:e.y}]},set:function(t){var e=t.interaction,n=t.coords,r=t.state,i=r.options,o=r.offsets,a=K(e.interactable,e.element,e.prepared.name),s=V({},n),c=[];i.offsetWithOrigin||(s.x-=a.x,s.y-=a.y);for(var l=0,u=o;l<u.length;l++)for(var p=u[l],f=s.x-p.x,d=s.y-p.y,h=0,v=i.targets.length;h<v;h++){var g=i.targets[h],m=void 0;(m=w.func(g)?g(f,d,e._proxy,p,h):g)&&c.push({x:(w.number(m.x)?m.x:f)+p.x,y:(w.number(m.y)?m.y:d)+p.y,range:w.number(m.range)?m.range:i.range,source:g,index:h,offset:p})}for(var y={target:null,inRange:!1,distance:0,range:0,delta:{x:0,y:0}},b=0;b<c.length;b++){var x=c[b],E=x.range,T=x.x-s.x,S=x.y-s.y,_=Q(T,S),P=_<=E;E===1/0&&y.inRange&&y.range!==1/0&&(P=!1),y.target&&!(P?y.inRange&&E!==1/0?_/E<y.distance/y.range:E===1/0&&y.range!==1/0||_<y.distance:!y.inRange&&_<y.distance)||(y.target=x,y.distance=_,y.range=E,y.inRange=P,y.delta.x=T,y.delta.y=S)}return y.inRange&&(n.x=y.target.x,n.y=y.target.y),r.closest=y,y},defaults:{range:1/0,targets:null,offset:null,offsetWithOrigin:!0,origin:null,relativePoints:null,endOnly:!1,enabled:!1}},Cn=be(Rn,"snap");var jn={start:function(t){var e=t.state,n=t.edges,r=e.options;if(!n)return null;t.state={options:{targets:null,relativePoints:[{x:n.left?0:1,y:n.top?0:1}],offset:r.offset||"self",origin:{x:0,y:0},range:r.range}},e.targetFields=e.targetFields||[["width","height"],["x","y"]],Rn.start(t),e.offsets=t.state.offsets,t.state=e},set:function(t){var e=t.interaction,n=t.state,r=t.coords,i=n.options,o=n.offsets,a={x:r.x-o[0].x,y:r.y-o[0].y};n.options=V({},i),n.options.targets=[];for(var s=0,c=i.targets||[];s<c.length;s++){var l=c[s],u=void 0;if(u=w.func(l)?l(a.x,a.y,e):l){for(var p=0,f=n.targetFields;p<f.length;p++){var d=f[p],h=d[0],v=d[1];if(h in u||v in u){u.x=u[h],u.y=u[v];break}}n.options.targets.push(u)}}var g=Rn.set(t);return n.options=i,g},defaults:{range:1/0,targets:null,offset:null,endOnly:!1,enabled:!1}},Fn=be(jn,"snapSize");var Xn={aspectRatio:yn,restrictEdges:kn,restrict:Tn,restrictRect:In,restrictSize:An,snapEdges:be({start:function(t){var e=t.edges;return e?(t.state.targetFields=t.state.targetFields||[[e.left?"left":"right",e.top?"top":"bottom"]],jn.start(t)):null},set:jn.set,defaults:V(ge(jn.defaults),{targets:void 0,range:void 0,offset:{x:0,y:0}})},"snapEdges"),snap:Cn,snapSize:Fn,spring:xn,avoid:xn,transform:xn,rubberband:xn},Yn={id:"modifiers",install:function(t){var e=t.interactStatic;for(var n in t.usePlugin(Ee),t.usePlugin(hn),e.modifiers=Xn,Xn){var r=Xn[n],i=r._defaults,o=r._methods;i._methods=o,t.defaults.perAction[n]=i}}},Ln=Yn,qn=function(t){s(n,t);var e=p(n);function n(t,i,o,a,s,c){var l;if(r(this,n),tt(u(l=e.call(this,s)),o),o!==i&&tt(u(l),i),l.timeStamp=c,l.originalEvent=o,l.type=t,l.pointerId=at(i),l.pointerType=dt(i),l.target=a,l.currentTarget=null,"tap"===t){var p=s.getPointerIndex(i);l.dt=l.timeStamp-s.pointers[p].downTime;var f=l.timeStamp-s.tapTime;l.double=!!s.prevTap&&"doubletap"!==s.prevTap.type&&s.prevTap.target===l.target&&f<500}else"doubletap"===t&&(l.dt=i.timeStamp-s.tapTime,l.double=!0);return l}return o(n,[{key:"_subtractOrigin",value:function(t){var e=t.x,n=t.y;return this.pageX-=e,this.pageY-=n,this.clientX-=e,this.clientY-=n,this}},{key:"_addOrigin",value:function(t){var e=t.x,n=t.y;return this.pageX+=e,this.pageY+=n,this.clientX+=e,this.clientY+=n,this}},{key:"preventDefault",value:function(){this.originalEvent.preventDefault()}}]),n}(vt),Bn={id:"pointer-events/base",before:["inertia","modifiers","auto-start","actions"],install:function(t){t.pointerEvents=Bn,t.defaults.actions.pointerEvents=Bn.defaults,V(t.actions.phaselessTypes,Bn.types)},listeners:{"interactions:new":function(t){var e=t.interaction;e.prevTap=null,e.tapTime=0},"interactions:update-pointer":function(t){var e=t.down,n=t.pointerInfo;if(!e&&n.hold)return;n.hold={duration:1/0,timeout:null}},"interactions:move":function(t,e){var n=t.interaction,r=t.pointer,i=t.event,o=t.eventTarget;t.duplicate||n.pointerIsDown&&!n.pointerWasMoved||(n.pointerIsDown&&Gn(t),Vn({interaction:n,pointer:r,event:i,eventTarget:o,type:"move"},e))},"interactions:down":function(t,e){!function(t,e){for(var n=t.interaction,r=t.pointer,i=t.event,o=t.eventTarget,a=t.pointerIndex,s=n.pointers[a].hold,c=q(o),l={interaction:n,pointer:r,event:i,eventTarget:o,type:"hold",targets:[],path:c,node:null},u=0;u<c.length;u++){var p=c[u];l.node=p,e.fire("pointerEvents:collect-targets",l)}if(!l.targets.length)return;for(var f=1/0,d=0,h=l.targets;d<h.length;d++){var v=h[d].eventable.options.holdDuration;v<f&&(f=v)}s.duration=f,s.timeout=setTimeout((function(){Vn({interaction:n,eventTarget:o,pointer:r,event:i,type:"hold"},e)}),f)}(t,e),Vn(t,e)},"interactions:up":function(t,e){Gn(t),Vn(t,e),function(t,e){var n=t.interaction,r=t.pointer,i=t.event,o=t.eventTarget;n.pointerWasMoved||Vn({interaction:n,eventTarget:o,pointer:r,event:i,type:"tap"},e)}(t,e)},"interactions:cancel":function(t,e){Gn(t),Vn(t,e)}},PointerEvent:qn,fire:Vn,collectEventTargets:Wn,defaults:{holdDuration:600,ignoreFrom:null,allowFrom:null,origin:{x:0,y:0}},types:{down:!0,move:!0,up:!0,cancel:!0,tap:!0,doubletap:!0,hold:!0}};function Vn(t,e){var n=t.interaction,r=t.pointer,i=t.event,o=t.eventTarget,a=t.type,s=t.targets,c=void 0===s?Wn(t,e):s,l=new qn(a,r,i,o,n,e.now());e.fire("pointerEvents:new",{pointerEvent:l});for(var u={interaction:n,pointer:r,event:i,eventTarget:o,targets:c,type:a,pointerEvent:l},p=0;p<c.length;p++){var f=c[p];for(var d in f.props||{})l[d]=f.props[d];var h=K(f.eventable,f.node);if(l._subtractOrigin(h),l.eventable=f.eventable,l.currentTarget=f.node,f.eventable.fire(l),l._addOrigin(h),l.immediatePropagationStopped||l.propagationStopped&&p+1<c.length&&c[p+1].node!==l.currentTarget)break}if(e.fire("pointerEvents:fired",u),"tap"===a){var v=l.double?Vn({interaction:n,pointer:r,event:i,eventTarget:o,type:"doubletap"},e):l;n.prevTap=v,n.tapTime=v.timeStamp}return l}function Wn(t,e){var n=t.interaction,r=t.pointer,i=t.event,o=t.eventTarget,a=t.type,s=n.getPointerIndex(r),c=n.pointers[s];if("tap"===a&&(n.pointerWasMoved||!c||c.downTarget!==o))return[];for(var l=q(o),u={interaction:n,pointer:r,event:i,eventTarget:o,type:a,path:l,targets:[],node:null},p=0;p<l.length;p++){var f=l[p];u.node=f,e.fire("pointerEvents:collect-targets",u)}return"hold"===a&&(u.targets=u.targets.filter((function(t){var e,r;return t.eventable.options.holdDuration===(null==(e=n.pointers[s])||null==(r=e.hold)?void 0:r.duration)}))),u.targets}function Gn(t){var e=t.interaction,n=t.pointerIndex,r=e.pointers[n].hold;r&&r.timeout&&(clearTimeout(r.timeout),r.timeout=null)}var Nn=Object.freeze({__proto__:null,default:Bn});function Un(t){var e=t.interaction;e.holdIntervalHandle&&(clearInterval(e.holdIntervalHandle),e.holdIntervalHandle=null)}var Hn={id:"pointer-events/holdRepeat",install:function(t){t.usePlugin(Bn);var e=t.pointerEvents;e.defaults.holdRepeatInterval=0,e.types.holdrepeat=t.actions.phaselessTypes.holdrepeat=!0},listeners:["move","up","cancel","endall"].reduce((function(t,e){return t["pointerEvents:".concat(e)]=Un,t}),{"pointerEvents:new":function(t){var e=t.pointerEvent;"hold"===e.type&&(e.count=(e.count||0)+1)},"pointerEvents:fired":function(t,e){var n=t.interaction,r=t.pointerEvent,i=t.eventTarget,o=t.targets;if("hold"===r.type&&o.length){var a=o[0].eventable.options.holdRepeatInterval;a<=0||(n.holdIntervalHandle=setTimeout((function(){e.pointerEvents.fire({interaction:n,eventTarget:i,type:"hold",pointer:r,event:r},e)}),a))}}})},Kn=Hn;var $n={id:"pointer-events/interactableTargets",install:function(t){var e=t.Interactable;e.prototype.pointerEvents=function(t){return V(this.events.options,t),this};var n=e.prototype._backCompatOption;e.prototype._backCompatOption=function(t,e){var r=n.call(this,t,e);return r===this&&(this.events.options[t]=e),r}},listeners:{"pointerEvents:collect-targets":function(t,e){var n=t.targets,r=t.node,i=t.type,o=t.eventTarget;e.interactables.forEachMatch(r,(function(t){var e=t.events,a=e.options;e.types[i]&&e.types[i].length&&t.testIgnoreAllow(a,r,o)&&n.push({node:r,eventable:e,props:{interactable:t}})}))},"interactable:new":function(t){var e=t.interactable;e.events.getRect=function(t){return e.getRect(t)}},"interactable:set":function(t,e){var n=t.interactable,r=t.options;V(n.events.options,e.pointerEvents.defaults),V(n.events.options,r.pointerEvents||{})}}},Jn=$n,Qn={id:"pointer-events",install:function(t){t.usePlugin(Nn),t.usePlugin(Kn),t.usePlugin(Jn)}},Zn=Qn;var tr={id:"reflow",install:function(t){var e=t.Interactable;t.actions.phases.reflow=!0,e.prototype.reflow=function(e){return function(t,e,n){for(var r=t.getAllElements(),i=n.window.Promise,o=i?[]:null,a=function(){var a=r[s],c=t.getRect(a);if(!c)return 1;var l,u=bt(n.interactions.list,(function(n){return n.interacting()&&n.interactable===t&&n.element===a&&n.prepared.name===e.name}));if(u)u.move(),o&&(l=u._reflowPromise||new i((function(t){u._reflowResolve=t})));else{var p=U(c),f=function(t){return{coords:t,get page(){return this.coords.page},get client(){return this.coords.client},get timeStamp(){return this.coords.timeStamp},get pageX(){return this.coords.page.x},get pageY(){return this.coords.page.y},get clientX(){return this.coords.client.x},get clientY(){return this.coords.client.y},get pointerId(){return this.coords.pointerId},get target(){return this.coords.target},get type(){return this.coords.type},get pointerType(){return this.coords.pointerType},get buttons(){return this.coords.buttons},preventDefault:function(){}}}({page:{x:p.x,y:p.y},client:{x:p.x,y:p.y},timeStamp:n.now()});l=function(t,e,n,r,i){var o=t.interactions.new({pointerType:"reflow"}),a={interaction:o,event:i,pointer:i,eventTarget:n,phase:"reflow"};o.interactable=e,o.element=n,o.prevEvent=i,o.updatePointer(i,i,n,!0),nt(o.coords.delta),Ut(o.prepared,r),o._doPhase(a);var s=t.window,c=s.Promise,l=c?new c((function(t){o._reflowResolve=t})):void 0;o._reflowPromise=l,o.start(r,e,n),o._interacting?(o.move(a),o.end(i)):(o.stop(),o._reflowResolve());return o.removePointer(i,i),l}(n,t,a,e,f)}o&&o.push(l)},s=0;s<r.length&&!a();s++);return o&&i.all(o).then((function(){return t}))}(this,e,t)}},listeners:{"interactions:stop":function(t,e){var n=t.interaction;"reflow"===n.pointerType&&(n._reflowResolve&&n._reflowResolve(),function(t,e){t.splice(t.indexOf(e),1)}(e.interactions.list,n))}}},er=tr;if(un.use(he),un.use(Ce),un.use(Zn),un.use(qe),un.use(Ln),un.use(pe),un.use(Xt),un.use(Gt),un.use(er),un.default=un,"object"===("undefined"==typeof module?"undefined":n(module))&&module)try{module.exports=un}catch(t){}return un.default=un,un}));


},{}],5:[function(require,module,exports){
/*!
 * isect v3.0.0
 * (c) 2018 Andrei Kashcha.
 * Released under the MIT License.
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.isect = {})));
}(this, (function (exports) { 'use strict';

  /* follows "An implementation of top-down splaying"
   * by D. Sleator <sleator@cs.cmu.edu> March 1992
   */

  /**
   * @typedef {*} Key
   */


  /**
   * @typedef {*} Value
   */


  /**
   * @typedef {function(node:Node):void} Visitor
   */


  /**
   * @typedef {function(a:Key, b:Key):number} Comparator
   */


  /**
   * @param {function(node:Node):string} NodePrinter
   */


  /**
   * @typedef {Object}  Node
   * @property {Key}    Key
   * @property {Value=} data
   * @property {Node}   left
   * @property {Node}   right
   */

  var Node = function Node (key, data) {
    this.key  = key;
    this.data = data;
    this.left = null;
    this.right= null;
  };

  function DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }


  /**
   * Simple top down splay, not requiring i to be in the tree t.
   * @param {Key} i
   * @param {Node?} t
   * @param {Comparator} comparator
   */
  function splay (i, t, comparator) {
    if (t === null) { return t; }
    var l, r, y;
    var N = new Node();
    l = r = N;

    while (true) {
      var cmp = comparator(i, t.key);
      //if (i < t.key) {
      if (cmp < 0) {
        if (t.left === null) { break; }
        //if (i < t.left.key) {
        if (comparator(i, t.left.key) < 0) {
          y = t.left;                           /* rotate right */
          t.left = y.right;
          y.right = t;
          t = y;
          if (t.left === null) { break; }
        }
        r.left = t;                               /* link right */
        r = t;
        t = t.left;
      //} else if (i > t.key) {
      } else if (cmp > 0) {
        if (t.right === null) { break; }
        //if (i > t.right.key) {
        if (comparator(i, t.right.key) > 0) {
          y = t.right;                          /* rotate left */
          t.right = y.left;
          y.left = t;
          t = y;
          if (t.right === null) { break; }
        }
        l.right = t;                              /* link left */
        l = t;
        t = t.right;
      } else {
        break;
      }
    }
    /* assemble */
    l.right = t.left;
    r.left = t.right;
    t.left = N.right;
    t.right = N.left;
    return t;
  }


  /**
   * @param  {Key}        i
   * @param  {Value}      data
   * @param  {Comparator} comparator
   * @param  {Tree}       tree
   * @return {Node}      root
   */
  function insert (i, data, t, comparator, tree) {
    var node = new Node(i, data);

    tree._size++;

    if (t === null) {
      node.left = node.right = null;
      return node;
    }

    t = splay(i, t, comparator);
    var cmp = comparator(i, t.key);
    if (cmp < 0) {
      node.left = t.left;
      node.right = t;
      t.left = null;
    } else if (cmp >= 0) {
      node.right = t.right;
      node.left = t;
      t.right = null;
    }
    return node;
  }


  /**
   * Insert i into the tree t, unless it's already there.
   * @param  {Key}        i
   * @param  {Value}      data
   * @param  {Comparator} comparator
   * @param  {Tree}       tree
   * @return {Node}       root
   */
  function add (i, data, t, comparator, tree) {
    var node = new Node(i, data);

    if (t === null) {
      node.left = node.right = null;
      tree._size++;
      return node;
    }

    t = splay(i, t, comparator);
    var cmp = comparator(i, t.key);
    if (cmp === 0) { return t; }
    else {
      if (cmp < 0) {
        node.left = t.left;
        node.right = t;
        t.left = null;
      } else if (cmp > 0) {
        node.right = t.right;
        node.left = t;
        t.right = null;
      }
      tree._size++;
      return node;
    }
  }


  /**
   * Deletes i from the tree if it's there
   * @param {Key}        i
   * @param {Tree}       tree
   * @param {Comparator} comparator
   * @param {Tree}       tree
   * @return {Node}      new root
   */
  function remove (i, t, comparator, tree) {
    var x;
    if (t === null) { return null; }
    t = splay(i, t, comparator);
    var cmp = comparator(i, t.key);
    if (cmp === 0) {               /* found it */
      if (t.left === null) {
        x = t.right;
      } else {
        x = splay(i, t.left, comparator);
        x.right = t.right;
      }
      tree._size--;
      return x;
    }
    return t;                         /* It wasn't there */
  }


  function split (key, v, comparator) {
    var left, right;
    if (v === null) {
      left = right = null;
    } else {
      v = splay(key, v, comparator);

      var cmp = comparator(v.key, key);
      if (cmp === 0) {
        left  = v.left;
        right = v.right;
      } else if (cmp < 0) {
        right   = v.right;
        v.right = null;
        left    = v;
      } else {
        left   = v.left;
        v.left = null;
        right  = v;
      }
    }
    return { left: left, right: right };
  }


  function merge (left, right, comparator) {
    if (right === null) { return left; }
    if (left  === null) { return right; }

    right = splay(left.key, right, comparator);
    right.left = left;
    return right;
  }


  /**
   * Prints level of the tree
   * @param  {Node}                        root
   * @param  {String}                      prefix
   * @param  {Boolean}                     isTail
   * @param  {Array<string>}               out
   * @param  {Function(node:Node):String}  printNode
   */
  function printRow (root, prefix, isTail, out, printNode) {
    if (root) {
      out(("" + prefix + (isTail ? 'âââ ' : 'âââ ') + (printNode(root)) + "\n"));
      var indent = prefix + (isTail ? '    ' : 'â   ');
      if (root.left)  { printRow(root.left,  indent, false, out, printNode); }
      if (root.right) { printRow(root.right, indent, true,  out, printNode); }
    }
  }


  var Tree = function Tree (comparator) {
    if ( comparator === void 0 ) comparator = DEFAULT_COMPARE;

    this._comparator = comparator;
    this._root = null;
    this._size = 0;
  };

  var prototypeAccessors = { size: { configurable: true } };


  /**
   * Inserts a key, allows duplicates
   * @param{Key}  key
   * @param{Value=} data
   * @return {Node|null}
   */
  Tree.prototype.insert = function insert$1 (key, data) {
    return this._root = insert(key, data, this._root, this._comparator, this);
  };


  /**
   * Adds a key, if it is not present in the tree
   * @param{Key}  key
   * @param{Value=} data
   * @return {Node|null}
   */
  Tree.prototype.add = function add$1 (key, data) {
    return this._root = add(key, data, this._root, this._comparator, this);
  };


  /**
   * @param{Key} key
   * @return {Node|null}
   */
  Tree.prototype.remove = function remove$1 (key) {
    this._root = remove(key, this._root, this._comparator, this);
  };


  /**
   * Removes and returns the node with smallest key
   * @return {?Node}
   */
  Tree.prototype.pop = function pop () {
    var node = this._root;
    if (node) {
      while (node.left) { node = node.left; }
      this._root = splay(node.key,this._root, this._comparator);
      this._root = remove(node.key, this._root, this._comparator, this);
      return { key: node.key, data: node.data };
    }
    return null;
  };


  /**
   * @param{Key} key
   * @return {Node|null}
   */
  Tree.prototype.findStatic = function findStatic (key) {
    var current = this._root;
    var compare = this._comparator;
    while (current) {
      var cmp = compare(key, current.key);
      if (cmp === 0)  { return current; }
      else if (cmp < 0) { current = current.left; }
      else            { current = current.right; }
    }
    return null;
  };


  /**
   * @param{Key} key
   * @return {Node|null}
   */
  Tree.prototype.find = function find (key) {
    if (this._root) {
      this._root = splay(key, this._root, this._comparator);
      if (this._comparator(key, this._root.key) !== 0) { return null; }
    }
    return this._root;
  };


  /**
   * @param{Key} key
   * @return {Boolean}
   */
  Tree.prototype.contains = function contains (key) {
    var current = this._root;
    var compare = this._comparator;
    while (current) {
      var cmp = compare(key, current.key);
      if (cmp === 0)  { return true; }
      else if (cmp < 0) { current = current.left; }
      else            { current = current.right; }
    }
    return false;
  };


  /**
   * @param{Visitor} visitor
   * @param{*=}    ctx
   * @return {SplayTree}
   */
  Tree.prototype.forEach = function forEach (visitor, ctx) {
    var current = this._root;
    var Q = [];/* Initialize stack s */
    var done = false;

    while (!done) {
      if (current !==null) {
        Q.push(current);
        current = current.left;
      } else {
        if (Q.length !== 0) {
          current = Q.pop();
          visitor.call(ctx, current);

          current = current.right;
        } else { done = true; }
      }
    }
    return this;
  };


  /**
   * Walk key range from `low` to `high`. Stops if `fn` returns a value.
   * @param{Key}    low
   * @param{Key}    high
   * @param{Function} fn
   * @param{*?}     ctx
   * @return {SplayTree}
   */
  Tree.prototype.range = function range (low, high, fn, ctx) {
      var this$1 = this;

    var Q = [];
    var compare = this._comparator;
    var node = this._root, cmp;

    while (Q.length !== 0 || node) {
      if (node) {
        Q.push(node);
        node = node.left;
      } else {
        node = Q.pop();
        cmp = compare(node.key, high);
        if (cmp > 0) {
          break;
        } else if (compare(node.key, low) >= 0) {
          if (fn.call(ctx, node)) { return this$1; } // stop if smth is returned
        }
        node = node.right;
      }
    }
    return this;
  };


  /**
   * Returns array of keys
   * @return {Array<Key>}
   */
  Tree.prototype.keys = function keys () {
    var keys = [];
    this.forEach(function (ref) {
        var key = ref.key;

        return keys.push(key);
      });
    return keys;
  };


  /**
   * Returns array of all the data in the nodes
   * @return {Array<Value>}
   */
  Tree.prototype.values = function values () {
    var values = [];
    this.forEach(function (ref) {
        var data = ref.data;

        return values.push(data);
      });
    return values;
  };


  /**
   * @return {Key|null}
   */
  Tree.prototype.min = function min () {
    if (this._root) { return this.minNode(this._root).key; }
    return null;
  };


  /**
   * @return {Key|null}
   */
  Tree.prototype.max = function max () {
    if (this._root) { return this.maxNode(this._root).key; }
    return null;
  };


  /**
   * @return {Node|null}
   */
  Tree.prototype.minNode = function minNode (t) {
      if ( t === void 0 ) t = this._root;

    if (t) { while (t.left) { t = t.left; } }
    return t;
  };


  /**
   * @return {Node|null}
   */
  Tree.prototype.maxNode = function maxNode (t) {
      if ( t === void 0 ) t = this._root;

    if (t) { while (t.right) { t = t.right; } }
    return t;
  };


  /**
   * Returns node at given index
   * @param{number} index
   * @return {?Node}
   */
  Tree.prototype.at = function at (index) {
    var current = this._root, done = false, i = 0;
    var Q = [];

    while (!done) {
      if (current) {
        Q.push(current);
        current = current.left;
      } else {
        if (Q.length > 0) {
          current = Q.pop();
          if (i === index) { return current; }
          i++;
          current = current.right;
        } else { done = true; }
      }
    }
    return null;
  };


  /**
   * @param{Node} d
   * @return {Node|null}
   */
  Tree.prototype.next = function next (d) {
    var root = this._root;
    var successor = null;

    if (d.right) {
      successor = d.right;
      while (successor.left) { successor = successor.left; }
      return successor;
    }

    var comparator = this._comparator;
    while (root) {
      var cmp = comparator(d.key, root.key);
      if (cmp === 0) { break; }
      else if (cmp < 0) {
        successor = root;
        root = root.left;
      } else { root = root.right; }
    }

    return successor;
  };


  /**
   * @param{Node} d
   * @return {Node|null}
   */
  Tree.prototype.prev = function prev (d) {
    var root = this._root;
    var predecessor = null;

    if (d.left !== null) {
      predecessor = d.left;
      while (predecessor.right) { predecessor = predecessor.right; }
      return predecessor;
    }

    var comparator = this._comparator;
    while (root) {
      var cmp = comparator(d.key, root.key);
      if (cmp === 0) { break; }
      else if (cmp < 0) { root = root.left; }
      else {
        predecessor = root;
        root = root.right;
      }
    }
    return predecessor;
  };


  /**
   * @return {SplayTree}
   */
  Tree.prototype.clear = function clear () {
    this._root = null;
    this._size = 0;
    return this;
  };


  /**
   * @return {NodeList}
   */
  Tree.prototype.toList = function toList$1 () {
    return toList(this._root);
  };


  /**
   * Bulk-load items. Both array have to be same size
   * @param{Array<Key>}  keys
   * @param{Array<Value>}[values]
   * @param{Boolean}     [presort=false] Pre-sort keys and values, using
   *                                       tree's comparator. Sorting is done
   *                                       in-place
   * @return {AVLTree}
   */
  Tree.prototype.load = function load (keys, values, presort) {
      if ( keys === void 0 ) keys = [];
      if ( values === void 0 ) values = [];
      if ( presort === void 0 ) presort = false;

    var size = keys.length;
    var comparator = this._comparator;

    // sort if needed
    if (presort) { sort(keys, values, 0, size - 1, comparator); }

    if (this._root === null) { // empty tree
      this._root = loadRecursive(this._root, keys, values, 0, size);
      this._size = size;
    } else { // that re-builds the whole tree from two in-order traversals
      var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);
      size = this._size + size;
      this._root = sortedListToBST({ head: mergedList }, 0, size);
    }
    return this;
  };


  /**
   * @return {Boolean}
   */
  Tree.prototype.isEmpty = function isEmpty () { return this._root === null; };

  prototypeAccessors.size.get = function () { return this._size; };


  /**
   * @param{NodePrinter=} printNode
   * @return {String}
   */
  Tree.prototype.toString = function toString (printNode) {
      if ( printNode === void 0 ) printNode = function (n) { return n.key; };

    var out = [];
    printRow(this._root, '', true, function (v) { return out.push(v); }, printNode);
    return out.join('');
  };


  Tree.prototype.update = function update (key, newKey, newData) {
    var comparator = this._comparator;
    var ref = split(key, this._root, comparator);
      var left = ref.left;
      var right = ref.right;
    this._size--;
    if (comparator(key, newKey) < 0) {
      right = insert(newKey, newData, right, comparator, this);
    } else {
      left = insert(newKey, newData, left, comparator, this);
    }
    this._root = merge(left, right, comparator);
  };


  Tree.prototype.split = function split$1 (key) {
    return split(key, this._root, this._comparator);
  };

  Object.defineProperties( Tree.prototype, prototypeAccessors );


  function loadRecursive (parent, keys, values, start, end) {
    var size = end - start;
    if (size > 0) {
      var middle = start + Math.floor(size / 2);
      var key    = keys[middle];
      var data   = values[middle];
      var node   = { key: key, data: data, parent: parent };
      node.left    = loadRecursive(node, keys, values, start, middle);
      node.right   = loadRecursive(node, keys, values, middle + 1, end);
      return node;
    }
    return null;
  }


  function createList(keys, values) {
    var head = { next: null };
    var p = head;
    for (var i = 0; i < keys.length; i++) {
      p = p.next = { key: keys[i], data: values[i] };
    }
    p.next = null;
    return head.next;
  }


  function toList (root) {
    var current = root;
    var Q = [], done = false;

    var head = { next: null };
    var p = head;

    while (!done) {
      if (current) {
        Q.push(current);
        current = current.left;
      } else {
        if (Q.length > 0) {
          current = p = p.next = Q.pop();
          current = current.right;
        } else { done = true; }
      }
    }
    p.next = null; // that'll work even if the tree was empty
    return head.next;
  }


  function sortedListToBST(list, start, end) {
    var size = end - start;
    if (size > 0) {
      var middle = start + Math.floor(size / 2);
      var left = sortedListToBST(list, start, middle);

      var root = list.head;
      root.left = left;

      list.head = list.head.next;

      root.right = sortedListToBST(list, middle + 1, end);
      return root;
    }
    return null;
  }


  function mergeLists (l1, l2, compare) {
    if ( compare === void 0 ) compare = function (a, b) { return a - b; };

    var head = {}; // dummy
    var p = head;

    var p1 = l1;
    var p2 = l2;

    while (p1 !== null && p2 !== null) {
      if (compare(p1.key, p2.key) < 0) {
        p.next = p1;
        p1 = p1.next;
      } else {
        p.next = p2;
        p2 = p2.next;
      }
      p = p.next;
    }

    if (p1 !== null)      { p.next = p1; }
    else if (p2 !== null) { p.next = p2; }

    return head.next;
  }


  function sort(keys, values, left, right, compare) {
    if (left >= right) { return; }

    var pivot = keys[(left + right) >> 1];
    var i = left - 1;
    var j = right + 1;

    while (true) {
      do { i++; } while (compare(keys[i], pivot) < 0);
      do { j--; } while (compare(keys[j], pivot) > 0);
      if (i >= j) { break; }

      var tmp = keys[i];
      keys[i] = keys[j];
      keys[j] = tmp;

      tmp = values[i];
      values[i] = values[j];
      values[j] = tmp;
    }

    sort(keys, values,  left,     j, compare);
    sort(keys, values, j + 1, right, compare);
  }

  function createEventQueue(byY) {
    var q = new Tree(byY);

    return {
      isEmpty: isEmpty,
      size: size,
      pop: pop,
      find: find,
      insert: insert
    }

    function find(p) {
      return q.find(p);
    }

    function size() {
      return q.size;
    }

    function isEmpty() {
      return q.isEmpty();
    }

    function insert(event) {
      // debugger;
      q.add(event.point, event);
    }

    function pop() {
      var node = q.pop();
      return node && node.data;
    }
  }

  /**
   * Just a collection of geometry related utilities
   */

  // This is used for precision checking (e.g. two numbers are equal
  // if their difference is smaller than this number). The value is 
  // chosen empirically. We still may run into precision related issues.
  // TODO: we should allow consumers to configure this.
  var EPS = 1e-9;//10;

  function getIntersectionXPoint(segment, xPos, yPos) {
    var dy1 = segment.from.y - yPos;
    var dy2 = yPos - segment.to.y;
    var dy = segment.to.y - segment.from.y;
    if (Math.abs(dy1) < EPS) {
      // The segment starts on the sweep line
      if (Math.abs(dy) < EPS) {
        // the segment is horizontal. Intersection is at the point
        if (xPos <= segment.from.x) { return segment.from.x; }
        if (xPos > segment.to.x) { return segment.to.x; }
        return xPos;
      }
      return segment.from.x;
    }
    
    var dx = (segment.to.x - segment.from.x); 
    var xOffset; 
    if (dy1 >= dy2) {
      xOffset = dy1 * (dx / dy); 
      return (segment.from.x - xOffset);
    } 
    xOffset = dy2 * (dx / dy);
    return (segment.to.x + xOffset);
  }

  function angle(dx, dy) {
    // https://stackoverflow.com/questions/16542042/fastest-way-to-sort-vectors-by-angle-without-actually-computing-that-angle
    var p = dx/(Math.abs(dx) + Math.abs(dy)); // -1 .. 1 increasing with x

    if (dy < 0) { return p - 1; }  // -2 .. 0 increasing with x
    return 1 - p               //  0 .. 2 decreasing with x
  }

  function intersectSegments(a, b) {
    //  https://stackoverflow.com/a/1968345/125351
    var aStart = a.from, bStart = b.from;
    var p0_x = aStart.x, p0_y = aStart.y,
        p2_x = bStart.x, p2_y = bStart.y;

    var s1_x = a.dx, s1_y = a.dy, s2_x = b.dx, s2_y = b.dy;
    var div = s1_x * s2_y - s2_x * s1_y;

    var s = (s1_y * (p0_x - p2_x) - s1_x * (p0_y - p2_y)) / div;
    if (s < 0 || s > 1) { return; }

    var t = (s2_x * (p2_y - p0_y) + s2_y * (p0_x - p2_x)) / div;

    if (t >= 0 && t <= 1) {
      return {
        x: p0_x - (t * s1_x),
        y: p0_y - (t * s1_y)
      }
    }
  }

  function samePoint(a, b) {
    return Math.abs(a.x - b.x) < EPS && Math.abs(a.y - b.y) < EPS;
  }

  /**
   * Creates a new sweep status data structure.
   */
  function createSweepStatus(onError, EPS$$1) {
    var lastPointY, prevY;
    var lastPointX, prevX;
    var useBelow = false;
    var status = new Tree(compareSegments);

    // To save on GC we return mutable object.
    var currentBoundary = {
      beforeLeft: null,
      left: null,
      right: null,
      afterRight: null,
    };

    var currentLeftRight = {left: null, right: null};

    return {
      /**
       * Add new segments into the status tree.
       */
      insertSegments: insertSegments,

      /**
       * Remove segments from the status tree.
       */
      deleteSegments: deleteSegments,

      /**
       * Returns segments that are to the left and right from a given point.
       */
      getLeftRightPoint: getLeftRightPoint,

      /**
       * For a given collections of segments finds the most left and the most right
       * segments. Also returns segments immediately before left, and after right segments.
       */
      getBoundarySegments: getBoundarySegments,

      findSegmentsWithPoint: findSegmentsWithPoint,

      /**
       * Current binary search tree with segments
       */
      status: status,

      /**
       * Introspection method that verifies if there are duplicates in the segment tree.
       * If there are - `onError()` is called.
       */
      checkDuplicate: checkDuplicate,

      /**
       * Prints current segments in order of their intersection with sweep line. Introspection method.
       */
      printStatus: printStatus,

      /**
       * Returns current position of the sweep line.
       */
      getLastPoint: function getLastPoint() {
        return {x: lastPointX, y: lastPointY};
      }
    }

    function compareSegments(a, b) {
      if (a === b) { return 0; }

      var ak = getIntersectionXPoint(a, lastPointX, lastPointY);
      var bk = getIntersectionXPoint(b, lastPointX, lastPointY);

      var res = ak - bk;
      if (Math.abs(res) >= EPS$$1) {
        // We are okay fine. Intersection distance between two segments
        // is good to give conclusive answer
        return res;
      }

      var aIsHorizontal = Math.abs(a.dy) < EPS$$1;
      var bIsHorizontal = Math.abs(b.dy) < EPS$$1;
      if (aIsHorizontal && bIsHorizontal) {
        return b.to.x - a.to.x;
      }
      // TODO: What if both a and b is horizontal?
      // move horizontal to end
      if (aIsHorizontal) { 
        return useBelow ? -1 : 1;
      }

      if (bIsHorizontal) {
        if (useBelow) {
          return (b.from.x >= lastPointX) ? -1 : 1
        }
        return -1;
        // return useBelow ? 1 : -1;
      }
      var pa = a.angle;
      var pb = b.angle;
      if (Math.abs(pa - pb) >= EPS$$1) {
        return useBelow ? pa - pb : pb - pa;
      }

      var segDist = a.from.y - b.from.y;
      if (Math.abs(segDist) >= EPS$$1) {
        return -segDist;
      }
      segDist = a.to.y - b.to.y;
      if (Math.abs(segDist) >= EPS$$1) {
        // TODO: Is this accurate?
        return -segDist;
      }

      return 0;
      // Could also use:
      // var aAngle = Math.atan2(a.from.y - a.to.y, a.from.x - a.to.x);
      // var bAngle = Math.atan2(b.from.y - b.to.y, b.from.x - b.to.x);
      // return useBelow ? bAngle - aAngle : aAngle - bAngle;
    }

    function getBoundarySegments(upper, interior) {
      var leftMost, rightMost, i;
      var uLength = upper.length;

      if (uLength > 0) {
        leftMost = rightMost = upper[0];
      } else {
        leftMost = rightMost = interior[0];
      }

      for (i = 1; i < uLength; ++i) {
        var s = upper[i];
        var cmp = compareSegments(leftMost, s);
        if (cmp > 0) { leftMost = s; }

        cmp = compareSegments(rightMost, s);
        if (cmp < 0) { rightMost = s; }
      }

      var startFrom = uLength > 0 ? 0 : 1;
      for (i = startFrom; i < interior.length; ++i) {
        s = interior[i];
        cmp = compareSegments(leftMost, s);
        if (cmp > 0) { leftMost = s; }

        cmp = compareSegments(rightMost, s);
        if (cmp < 0) { rightMost = s; }
      }

      // at this point we have our left/right segments in the status.
      // Let's find their prev/next elements and report them back:
      var left = status.find(leftMost);
      if (!left) {
        onError('Left is missing. Precision error?');
      }

      var right = status.find(rightMost);
      if (!right) {
        onError('Right is missing. Precision error?');
      }

      var beforeLeft = left && status.prev(left);
      var afterRight = right && status.next(right);

      while (afterRight && right.key.dy === 0 && afterRight.key.dy === 0) {
        // horizontal segments are special :(
        afterRight = status.next(afterRight);
      }

      currentBoundary.beforeLeft = beforeLeft && beforeLeft.key;
      currentBoundary.left = left && left.key;
      currentBoundary.right = right && right.key;
      currentBoundary.afterRight = afterRight && afterRight.key;

      return currentBoundary;
    }

    function getLeftRightPoint(p) {
      // We are trying to find left and right segments that are nearest to the
      // point p. For this we traverse the binary search tree, and remember
      // node with the shortest distance to p.
      var lastLeft;
      var current = status._root;
      var minX = Number.POSITIVE_INFINITY;
      while (current) {
        var x = getIntersectionXPoint(current.key, p.x, p.y);
        var dx = p.x - x;
        if (dx >= 0) {
          if (dx < minX) {
            minX = dx;
            lastLeft = current;
            current = current.left;
          } else {
            break;
          }
        } else {
          if (-dx < minX) {
            minX = -dx;
            lastLeft = current;
            current = current.right;
          } else {
            break;
          }
        }
      }

      currentLeftRight.left = lastLeft && lastLeft.key;
      var next = lastLeft && status.next(lastLeft);
      currentLeftRight.right = next && next.key;
      return currentLeftRight;

      // Conceptually, the code above should be equivalent to the code below;
      // The code below is easier to understand, but intuitively, the code above
      // should have better performance (as we do not traverse the entire status
      // tree)

      // var right, left,  x;
      // var all = status.keys()
      // for (var i = 0; i < all.length; ++i) {
      //   var segment = all[i];
      //   x = getIntersectionXPoint(segment, p.x, p.y);
      //   if (x > p.x && !right) {
      //     right = segment;
      //     break;
      //   } else if (x < p.x) {
      //     left = segment;
      //   }
      // }

      // currentLeftRight.left = left;
      // currentLeftRight.right = right;

      // return currentLeftRight;
    }

    function findSegmentsWithPoint(p, onFound) {
      // Option 1.
      // var arrResults = [];
      // status.forEach(current => {
      //   var x = getIntersectionXPoint(current.key, p.x, p.y);
      //   var dx = p.x - x;
      //   if (Math.abs(dx) < EPS) {
      //     onFound(current.key);
      //    // arrResults.push(current.key)
      //   }
      // });
      // return arrResults;

      // Option 2.

      // let current = status._root;
      // const Q = [];  /* Initialize stack s */
      // let done = false;
      // var res = [];
      // var breakEarly = false;

      // while (!done) {
      //   if (current !==  null) {
      //     Q.push(current);
      //     current = current.left;
      //   } else {
      //     if (Q.length !== 0) {
      //       current = Q.pop();

      //       var x = getIntersectionXPoint(current.key, p.x, p.y);
      //       var dx = p.x - x;
      //       if (Math.abs(dx) < EPS) {
      //         res.push(current.key)
      //         breakEarly = true;
      //       } else if (breakEarly) {
      //         done = true;
      //       }

      //       current = current.right;
      //     } else done = true;
      //   }
      // }

      // return res;

      // option 3.
      var current = status._root;

      while (current) {
        var x = getIntersectionXPoint(current.key, p.x, p.y);
        var dx = p.x - x;
        if (Math.abs(dx) < EPS$$1) {
          collectAdjacentNodes(current, p, onFound);
          break;
        } else if (dx < 0) {
          current = current.left;
        } else {
          current = current.right;
        }
      }
    }

    function collectAdjacentNodes(root, p, onFound) {
      onFound(root.key);
      goOverPredecessors(root.left, p, onFound);
      goOverSuccessors(root.right, p, onFound);
    }

    function goOverPredecessors(root, p, res) {
      if (!root) { return; }
      var x = getIntersectionXPoint(root.key, p.x, p.y);
      var dx = p.x - x;
      if (Math.abs(dx) < EPS$$1) {
        collectAdjacentNodes(root, p, res);
      } else {
        goOverPredecessors(root.right, p, res);
      }
    }

    function goOverSuccessors(root, p, res) {
      if (!root) { return; }
      var x = getIntersectionXPoint(root.key, p.x, p.y);
      var dx = p.x - x;
      if (Math.abs(dx) < EPS$$1) {
        collectAdjacentNodes(root, p, res);
      } else {
        goOverSuccessors(root.left, p, res);
      }
    }

    function checkDuplicate() {
      var prev;
      status.forEach(function (node) {
        var current = node.key;

        if (prev) {
          if (samePoint(prev.from, current.from) && samePoint(prev.to, current.to)) {
            // Likely you have received error before during segment removal.
            onError('Duplicate key in the status! This may be caused by Floating Point rounding error');
          }
        }
        prev = current;
      });
    }

    function printStatus(prefix) {
      if ( prefix === void 0 ) prefix = '';

      // eslint-disable-next-line
      console.log(prefix, 'status line: ', lastPointX, lastPointY);
      status.forEach(function (node) {
        var x = getIntersectionXPoint(node.key, lastPointX, lastPointY);
        // eslint-disable-next-line
        console.log(x + ' ' + node.key.name);
      });
    }

    function insertSegments(interior, upper, sweepLinePos) {
      lastPointY = sweepLinePos.y;
      lastPointX = sweepLinePos.x;
      var key;

      for (var i = 0; i < interior.length; ++i) {
        key = interior[i];
        status.add(key);
      }
      for (i = 0; i < upper.length; ++i) {
        key = upper[i];
        status.add(key);
      }
    }

    function deleteSegments(lower, interior, sweepLinePos) {
      // I spent most of the time debugging this method. Depending on the
      // algorithm state we can run into situation when dynamic keys of the
      // `status` tree predict wrong branch, and thus we are not able to find
      // the segment that needs to be deleted. If that happens I'm trying to
      // use previous point and repeat the process. This may result in 
      // incorrect state. In that case I report an error. 
      var i;
      var prevCount = status._size;
      prevX = lastPointX;
      prevY = lastPointY;
      lastPointY = sweepLinePos.y;
      lastPointX = sweepLinePos.x;

      useBelow = true;
      for(i = 0; i < lower.length; ++i) {
        removeSegment(lower[i], sweepLinePos);
      }
      for(i = 0; i < interior.length; ++i) {
        removeSegment(interior[i], sweepLinePos);
      }
      useBelow = false;

      if (status._size !== prevCount - interior.length - lower.length) {
        // This can happen when rounding error occurs. You can try scaling your input
        onError('Segments were not removed from a tree properly. Precision error?');
      }
    }

    function removeSegment(key, sweepLinePos) {
      if (status.find(key)) {
        status.remove(key);
      } else {
        lastPointX = prevX;
        lastPointY = prevY;
        if (status.find(key)) {
          status.remove(key);
        }
        lastPointY = sweepLinePos.y;
        lastPointX = sweepLinePos.x;
      }
    }
  }

  /**
   * Represents a single event in the sweep-line algorithm
   */
  var SweepEvent = function SweepEvent(point, segment) {
    this.point = point;
    if (segment) { this.from = [segment]; }
  };

  /**
   * A point on a line
   * 
   * @typedef {Object} Point
   * @property {number} x coordinate
   * @property {number} y coordinate
   */


  /**
   * @typedef {Object} Segment 
   * @property {Point} from start of the segment
   * @property {Point} to end of the segment
   */

  /**
   * @typedef {function(point : Point, interior : Segment[], lower : Segment[], upper : Segment[])} ReportIntersectionCallback
   */

  /**
   * @typedef {Object} ISectOptions 
   * @property {ReportIntersectionCallback} onFound 
   */

   /**
    * @typedef {Object} ISectResult
    */

  // We use EMPTY array to avoid pressure on garbage collector. Need to be
  // very cautious to not mutate this array.
  var EMPTY = [];

  /**
   * Finds all intersections among given segments.
   * 
   * The algorithm follows "Computation Geometry, Algorithms and Applications" book
   * by Mark de Berg, Otfried Cheong, Marc van Kreveld, and Mark Overmars.
   * 
   * Line is swept top-down
   * 
   * @param {Segment[]} segments
   * @param {ISectOptions=} options
   * @returns {ISectResult}
   */
  function isect(segments, options) {
    var results = [];
    var reportIntersection = (options && options.onFound) || defaultIntersectionReporter;

    var onError = (options && options.onError) || defaultErrorReporter;

    var eventQueue = createEventQueue(byY);
    var sweepStatus = createSweepStatus(onError, EPS);
    var lower, interior, lastPoint;

    segments.forEach(addSegment);

    return {
      /**
       * Find all intersections synchronously.
       * 
       * @returns array of found intersections.
       */
      run: run,

      /**
       * Performs a single step in the sweep line algorithm
       * 
       * @returns true if there was something to process; False if no more work to do
       */
      step: step,

      // Methods below are low level API for fine-grained control.
      // Don't use it unless you understand this code thoroughly

      /**
       * Add segment into the 
       */
      addSegment: addSegment,

      /**
       * Direct access to event queue. Queue contains segment endpoints and
       * pending detected intersections.
       */
      eventQueue: eventQueue, 

      /**
       * Direct access to sweep line status. "Status" holds information about
       * all intersected segments.
       */
      sweepStatus: sweepStatus,

      /**
       * Access to results array. Works only when you use default onFound() handler
       */
      results: results
    }

    function run() {
      while (!eventQueue.isEmpty()) {
        var eventPoint = eventQueue.pop();
        if (handleEventPoint(eventPoint)) {
          // they decided to stop.
          return;
        }    }

      return results;
    }

    function step() {
      if (!eventQueue.isEmpty()) {
        var eventPoint = eventQueue.pop();
        handleEventPoint(eventPoint);
        // Note: we don't check results of `handleEventPoint()`
        // assumption is that client controls `step()` and thus they 
        // know better if they want to stop.
        return true;
      }
      return false;
    }

    function handleEventPoint(p) {
      lastPoint = p.point;
      var upper = p.from || EMPTY;

      lower = interior = undefined;
      // TODO: move lower/interior into sweep status method?

      sweepStatus.findSegmentsWithPoint(lastPoint, addLowerOrInterior);
      // if (segmentsWithPoint) {
      //   segmentsWithPoint.forEach()
      // } 

      if (!lower) { lower = EMPTY; }
      if (!interior) { interior = EMPTY; }

      var uLength = upper.length;
      var iLength = interior.length;
      var lLength = lower.length;
      var hasIntersection = uLength + iLength + lLength > 1;
      var hasPointIntersection = !hasIntersection && (uLength === 0 && lLength === 0 && iLength > 0);

      if (hasIntersection || hasPointIntersection) {
        p.isReported = true;
        if (reportIntersection(lastPoint, union(interior, union(lower, upper)))) {
          return true;
        }
      }

      sweepStatus.deleteSegments(lower, interior, lastPoint);
      sweepStatus.insertSegments(interior, upper, lastPoint);

      var sLeft, sRight;

      var hasNoCrossing = (uLength + iLength === 0);

      if (hasNoCrossing) {
        var leftRight = sweepStatus.getLeftRightPoint(lastPoint);
        sLeft = leftRight.left;
        if (!sLeft) { return; }

        sRight = leftRight.right;
        if (!sRight) { return; }

        findNewEvent(sLeft, sRight, p);
      } else {
        var boundarySegments = sweepStatus.getBoundarySegments(upper, interior);

        findNewEvent(boundarySegments.beforeLeft, boundarySegments.left, p);
        findNewEvent(boundarySegments.right, boundarySegments.afterRight, p);
      }

      return false;
    }

    function addLowerOrInterior(s) {
      if (samePoint(s.to, lastPoint)) {
        if (!lower) { lower = [s]; }
        else { lower.push(s); }
      } else if (!samePoint(s.from, lastPoint)) {
        if (!interior) { interior = [s]; }
        else { interior.push(s); }
      }
    }

    function findNewEvent(left, right, p) {
      if (!left || !right) { return; }

      var intersection = intersectSegments(left, right);
      if (!intersection) {
          return;
      }

      var dy = p.point.y - intersection.y;
      // TODO: should I add dy to intersection.y?
      if (dy < -EPS) {
        // this means intersection happened after the sweep line. 
        // We already processed it.
        return;
      }
      if (Math.abs(dy) < EPS && intersection.x <= p.point.x) {
        return;
      }

      // Need to adjust floating point for this special case,
      // since otherwise it gives rounding errors:
      roundNearZero(intersection);

      var current = eventQueue.find(intersection);

      if (current && current.isReported) {
        // We already reported this event. No need to add it one more time
        // TODO: Is this case even possible?
        onError('We already reported this event.');
        return;
      }

      if (!current) {
        var event = new SweepEvent(intersection);
        eventQueue.insert(event);
      }
    }

    function defaultIntersectionReporter(p, segments) {
      results.push({
        point: p, 
        segments: segments
      });
    }

    function addSegment(segment) {
      var from = segment.from;
      var to = segment.to;

      // Small numbers give more precision errors. Rounding them to 0.
      roundNearZero(from);
      roundNearZero(to);

      var dy = from.y - to.y;

      // Note: dy is much smaller then EPS on purpose. I found that higher
      // precision here does less good - getting way more rounding errors.
      if (Math.abs(dy) < 1e-5) {
        from.y = to.y;
        segment.dy = 0;
      }
      if ((from.y < to.y) || (
          (from.y === to.y) && (from.x > to.x))
        ) {
        var temp = from;
        from = segment.from = to; 
        to = segment.to = temp;
      }

      // We pre-compute some immutable properties of the segment
      // They are used quite often in the tree traversal, and pre-computation
      // gives significant boost:
      segment.dy = from.y - to.y;
      segment.dx = from.x - to.x;
      segment.angle = angle(segment.dy, segment.dx);

      var isPoint = segment.dy === segment.dx && segment.dy === 0;
      var prev = eventQueue.find(from);
      if (prev && !isPoint) {
        // this detects identical segments early. Without this check
        // the algorithm would break since sweep line has no means to
        // detect identical segments.
        var prevFrom = prev.data.from;
        if (prevFrom) {
          for (var i = 0; i < prevFrom.length; ++i) {
            var s = prevFrom[i];
            if (samePoint(s.to, to)) {
              reportIntersection(s.from, [s.from, s.to]);
              reportIntersection(s.to, [s.from, s.to]);
              return;
            }
          }
        }
      }

      if (!isPoint) {
        if (prev) {
          if (prev.data.from) { prev.data.from.push(segment); }
          else { prev.data.from = [segment]; }
        } else {
          var e = new SweepEvent(from, segment);
          eventQueue.insert(e);
        }
        var event = new SweepEvent(to);
        eventQueue.insert(event);
      } else {
        var event = new SweepEvent(to);
        eventQueue.insert(event);
      }
    } 
  }

  function roundNearZero(point) {
    if (Math.abs(point.x) < EPS) { point.x = 0; }
    if (Math.abs(point.y) < EPS) { point.y = 0; }
  }

  function defaultErrorReporter(errorMessage) {
    throw new Error(errorMessage);
  }

  function union(a, b) {
    if (!a) { return b; }
    if (!b) { return a; }

    return a.concat(b);
  }

  function byY(a, b) {
    // decreasing Y 
    var res = b.y - a.y;
    // TODO: This might mess up the status tree.
    if (Math.abs(res) < EPS) {
      // increasing x.
      res = a.x - b.x;
      if (Math.abs(res) < EPS) { res = 0; }
    }

    return res;
  }

  function intersectSegments$1(a, b) {
    // Note: this is almost the same as geom.intersectSegments()
    // The main difference is that we don't have a pre-computed
    // value for dx/dy on the segments.
    //  https://stackoverflow.com/a/1968345/125351
    var aStart = a.from, bStart = b.from;
    var p0_x = aStart.x, p0_y = aStart.y,
        p2_x = bStart.x, p2_y = bStart.y;

    var s1_x = a.from.x - a.to.x, s1_y = a.from.y - a.to.y, s2_x = b.from.x - b.to.x, s2_y = b.from.y - b.to.y;
    var div = s1_x * s2_y - s2_x * s1_y;

    var s = (s1_y * (p0_x - p2_x) - s1_x * (p0_y - p2_y)) / div;
    if (s < 0 || s > 1) { return; }

    var t = (s2_x * (p2_y - p0_y) + s2_y * (p0_x - p2_x)) / div;

    if (t >= 0 && t <= 1) {
      return {
        x: p0_x - (t * s1_x),
        y: p0_y - (t * s1_y)
      }
    }
  }

  /**
   * This is a brute force solution with O(n^2) performance.
   * (`n` is number of segments).
   * 
   * Use this when number of lines is low, and number of intersections
   * is high.
   */
  function brute(lines, options) {
    var results = [];
    var reportIntersection = (options && options.onFound) || 
                              defaultIntersectionReporter;
    var asyncState;

    return {
      /**
       * Execute brute force of the segment intersection search
       */
      run: run,
      /**
       * Access to results array. Works only when you use default onFound() handler
       */
      results: results,

      /**
       * Performs a single step in the brute force algorithm ()
       */
      step: step
    }

    function step() {
      if (!asyncState) {
        asyncState = {
          i: 0
        };
      }
      var test = lines[asyncState.i];
      for (var j = asyncState.i + 1; j < lines.length; ++j) {
        var other = lines[j];
        var pt = intersectSegments$1(test, other);
        if (pt) {
          if (reportIntersection(pt, [test, other])) {
            return;
          }
        }
      }
      asyncState.i += 1;
      return asyncState.i < lines.length;
    }

    function run() {
      for(var i = 0; i < lines.length; ++i) {
        var test = lines[i];
        for (var j = i + 1; j < lines.length; ++j) {
          var other = lines[j];
          var pt = intersectSegments$1(test, other);
          if (pt) {
            if (reportIntersection(pt, [test, other])) {
              return;
            }
          }
        }
      }
      return results;
    }

    function defaultIntersectionReporter(p, interior) {
      results.push({
        point: p, 
        segments: interior
      });
    }
  }

  var ARRAY_TYPES = [
      Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,
      Int32Array, Uint32Array, Float32Array, Float64Array
  ];

  var VERSION = 3; // serialized format version

  var Flatbush = function Flatbush(numItems, nodeSize, ArrayType, data) {
      var this$1 = this;

      if (numItems === undefined) { throw new Error('Missing required argument: numItems.'); }
      if (isNaN(numItems) || numItems <= 0) { throw new Error(("Unpexpected numItems value: " + numItems + ".")); }

      this.numItems = +numItems;
      this.nodeSize = Math.min(Math.max(+nodeSize || 16, 2), 65535);

      // calculate the total number of nodes in the R-tree to allocate space for
      // and the index of each tree level (used in search later)
      var n = numItems;
      var numNodes = n;
      this._levelBounds = [n * 4];
      do {
          n = Math.ceil(n / this$1.nodeSize);
          numNodes += n;
          this$1._levelBounds.push(numNodes * 4);
      } while (n !== 1);

      this.ArrayType = ArrayType || Float64Array;
      this.IndexArrayType = numNodes < 16384 ? Uint16Array : Uint32Array;

      var arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);
      var nodesByteSize = numNodes * 4 * this.ArrayType.BYTES_PER_ELEMENT;

      if (arrayTypeIndex < 0) {
          throw new Error(("Unexpected typed array class: " + ArrayType + "."));
      }

      if (data && (data instanceof ArrayBuffer)) {
          this.data = data;
          this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);
          this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);

          this._pos = numNodes * 4;
          this.minX = this._boxes[this._pos - 4];
          this.minY = this._boxes[this._pos - 3];
          this.maxX = this._boxes[this._pos - 2];
          this.maxY = this._boxes[this._pos - 1];

      } else {
          this.data = new ArrayBuffer(8 + nodesByteSize + numNodes * this.IndexArrayType.BYTES_PER_ELEMENT);
          this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);
          this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);
          this._pos = 0;
          this.minX = Infinity;
          this.minY = Infinity;
          this.maxX = -Infinity;
          this.maxY = -Infinity;

          new Uint8Array(this.data, 0, 2).set([0xfb, (VERSION << 4) + arrayTypeIndex]);
          new Uint16Array(this.data, 2, 1)[0] = nodeSize;
          new Uint32Array(this.data, 4, 1)[0] = numItems;
      }
  };

  Flatbush.from = function from (data) {
      if (!(data instanceof ArrayBuffer)) {
          throw new Error('Data must be an instance of ArrayBuffer.');
      }
      var ref = new Uint8Array(data, 0, 2);
          var magic = ref[0];
          var versionAndType = ref[1];
      if (magic !== 0xfb) {
          throw new Error('Data does not appear to be in a Flatbush format.');
      }
      if (versionAndType >> 4 !== VERSION) {
          throw new Error(("Got v" + (versionAndType >> 4) + " data when expected v" + VERSION + "."));
      }
      var ref$1 = new Uint16Array(data, 2, 1);
          var nodeSize = ref$1[0];
      var ref$2 = new Uint32Array(data, 4, 1);
          var numItems = ref$2[0];

      return new Flatbush(numItems, nodeSize, ARRAY_TYPES[versionAndType & 0x0f], data);
  };

  Flatbush.prototype.add = function add (minX, minY, maxX, maxY) {
      var index = this._pos >> 2;
      this._indices[index] = index;
      this._boxes[this._pos++] = minX;
      this._boxes[this._pos++] = minY;
      this._boxes[this._pos++] = maxX;
      this._boxes[this._pos++] = maxY;

      if (minX < this.minX) { this.minX = minX; }
      if (minY < this.minY) { this.minY = minY; }
      if (maxX > this.maxX) { this.maxX = maxX; }
      if (maxY > this.maxY) { this.maxY = maxY; }
  };

  Flatbush.prototype.finish = function finish () {
          var this$1 = this;

      if (this._pos >> 2 !== this.numItems) {
          throw new Error(("Added " + (this._pos >> 2) + " items when expected " + (this.numItems) + "."));
      }

      var width = this.maxX - this.minX;
      var height = this.maxY - this.minY;
      var hilbertValues = new Uint32Array(this.numItems);
      var hilbertMax = (1 << 16) - 1;

      // map item centers into Hilbert coordinate space and calculate Hilbert values
      for (var i = 0; i < this.numItems; i++) {
          var pos = 4 * i;
          var minX = this$1._boxes[pos++];
          var minY = this$1._boxes[pos++];
          var maxX = this$1._boxes[pos++];
          var maxY = this$1._boxes[pos++];
          var x = Math.floor(hilbertMax * ((minX + maxX) / 2 - this$1.minX) / width);
          var y = Math.floor(hilbertMax * ((minY + maxY) / 2 - this$1.minY) / height);
          hilbertValues[i] = hilbert(x, y);
      }

      // sort items by their Hilbert value (for packing later)
      sort$1(hilbertValues, this._boxes, this._indices, 0, this.numItems - 1);

      // generate nodes at each tree level, bottom-up
      for (var i$1 = 0, pos$1 = 0; i$1 < this._levelBounds.length - 1; i$1++) {
          var end = this$1._levelBounds[i$1];

          // generate a parent node for each block of consecutive <nodeSize> nodes
          while (pos$1 < end) {
              var nodeMinX = Infinity;
              var nodeMinY = Infinity;
              var nodeMaxX = -Infinity;
              var nodeMaxY = -Infinity;
              var nodeIndex = pos$1;

              // calculate bbox for the new node
              for (var i$2 = 0; i$2 < this.nodeSize && pos$1 < end; i$2++) {
                  var minX$1 = this$1._boxes[pos$1++];
                  var minY$1 = this$1._boxes[pos$1++];
                  var maxX$1 = this$1._boxes[pos$1++];
                  var maxY$1 = this$1._boxes[pos$1++];
                  if (minX$1 < nodeMinX) { nodeMinX = minX$1; }
                  if (minY$1 < nodeMinY) { nodeMinY = minY$1; }
                  if (maxX$1 > nodeMaxX) { nodeMaxX = maxX$1; }
                  if (maxY$1 > nodeMaxY) { nodeMaxY = maxY$1; }
              }

              // add the new node to the tree data
              this$1._indices[this$1._pos >> 2] = nodeIndex;
              this$1._boxes[this$1._pos++] = nodeMinX;
              this$1._boxes[this$1._pos++] = nodeMinY;
              this$1._boxes[this$1._pos++] = nodeMaxX;
              this$1._boxes[this$1._pos++] = nodeMaxY;
          }
      }
  };

  Flatbush.prototype.search = function search (minX, minY, maxX, maxY, filterFn) {
          var this$1 = this;

      if (this._pos !== this._boxes.length) {
          throw new Error('Data not yet indexed - call index.finish().');
      }

      var nodeIndex = this._boxes.length - 4;
      var level = this._levelBounds.length - 1;
      var queue = [];
      var results = [];

      while (nodeIndex !== undefined) {
          // find the end index of the node
          var end = Math.min(nodeIndex + this$1.nodeSize * 4, this$1._levelBounds[level]);

          // search through child nodes
          for (var pos = nodeIndex; pos < end; pos += 4) {
              var index = this$1._indices[pos >> 2];

              // check if node bbox intersects with query bbox
              if (maxX < this$1._boxes[pos]) { continue; } // maxX < nodeMinX
              if (maxY < this$1._boxes[pos + 1]) { continue; } // maxY < nodeMinY
              if (minX > this$1._boxes[pos + 2]) { continue; } // minX > nodeMaxX
              if (minY > this$1._boxes[pos + 3]) { continue; } // minY > nodeMaxY

              if (nodeIndex < this$1.numItems * 4) {
                  if (filterFn === undefined || filterFn(index)) {
                      results.push(index); // leaf item
                  }

              } else {
                  queue.push(index); // node; add it to the search queue
                  queue.push(level - 1);
              }
          }

          level = queue.pop();
          nodeIndex = queue.pop();
      }

      return results;
  };

  // custom quicksort that sorts bbox data alongside the hilbert values
  function sort$1(values, boxes, indices, left, right) {
      if (left >= right) { return; }

      var pivot = values[(left + right) >> 1];
      var i = left - 1;
      var j = right + 1;

      while (true) {
          do { i++; } while (values[i] < pivot);
          do { j--; } while (values[j] > pivot);
          if (i >= j) { break; }
          swap(values, boxes, indices, i, j);
      }

      sort$1(values, boxes, indices, left, j);
      sort$1(values, boxes, indices, j + 1, right);
  }

  // swap two values and two corresponding boxes
  function swap(values, boxes, indices, i, j) {
      var temp = values[i];
      values[i] = values[j];
      values[j] = temp;

      var k = 4 * i;
      var m = 4 * j;

      var a = boxes[k];
      var b = boxes[k + 1];
      var c = boxes[k + 2];
      var d = boxes[k + 3];
      boxes[k] = boxes[m];
      boxes[k + 1] = boxes[m + 1];
      boxes[k + 2] = boxes[m + 2];
      boxes[k + 3] = boxes[m + 3];
      boxes[m] = a;
      boxes[m + 1] = b;
      boxes[m + 2] = c;
      boxes[m + 3] = d;

      var e = indices[i];
      indices[i] = indices[j];
      indices[j] = e;
  }

  // Fast Hilbert curve algorithm by http://threadlocalmutex.com/
  // Ported from C++ https://github.com/rawrunprotected/hilbert_curves (public domain)
  function hilbert(x, y) {
      var a = x ^ y;
      var b = 0xFFFF ^ a;
      var c = 0xFFFF ^ (x | y);
      var d = x & (y ^ 0xFFFF);

      var A = a | (b >> 1);
      var B = (a >> 1) ^ a;
      var C = ((c >> 1) ^ (b & (d >> 1))) ^ c;
      var D = ((a & (c >> 1)) ^ (d >> 1)) ^ d;

      a = A; b = B; c = C; d = D;
      A = ((a & (a >> 2)) ^ (b & (b >> 2)));
      B = ((a & (b >> 2)) ^ (b & ((a ^ b) >> 2)));
      C ^= ((a & (c >> 2)) ^ (b & (d >> 2)));
      D ^= ((b & (c >> 2)) ^ ((a ^ b) & (d >> 2)));

      a = A; b = B; c = C; d = D;
      A = ((a & (a >> 4)) ^ (b & (b >> 4)));
      B = ((a & (b >> 4)) ^ (b & ((a ^ b) >> 4)));
      C ^= ((a & (c >> 4)) ^ (b & (d >> 4)));
      D ^= ((b & (c >> 4)) ^ ((a ^ b) & (d >> 4)));

      a = A; b = B; c = C; d = D;
      C ^= ((a & (c >> 8)) ^ (b & (d >> 8)));
      D ^= ((b & (c >> 8)) ^ ((a ^ b) & (d >> 8)));

      a = C ^ (C >> 1);
      b = D ^ (D >> 1);

      var i0 = x ^ y;
      var i1 = b | (0xFFFF ^ (i0 | a));

      i0 = (i0 | (i0 << 8)) & 0x00FF00FF;
      i0 = (i0 | (i0 << 4)) & 0x0F0F0F0F;
      i0 = (i0 | (i0 << 2)) & 0x33333333;
      i0 = (i0 | (i0 << 1)) & 0x55555555;

      i1 = (i1 | (i1 << 8)) & 0x00FF00FF;
      i1 = (i1 | (i1 << 4)) & 0x0F0F0F0F;
      i1 = (i1 | (i1 << 2)) & 0x33333333;
      i1 = (i1 | (i1 << 1)) & 0x55555555;

      return ((i1 << 1) | i0) >>> 0;
  }

  /**
   * This implementation is inspired by discussion here 
   * https://twitter.com/mourner/status/1049325199617921024 and 
   * here https://github.com/anvaka/isect/issues/1
   * 
   * It builds an index of all segments using static spatial index
   * and then for each segment it queries overlapping rectangles.
   */
  function bush(lines, options) {
    var results = [];
    var reportIntersection = (options && options.onFound) || 
                              defaultIntersectionReporter;
    var asyncState;

    var index = new Flatbush(lines.length);
    lines.forEach(addToIndex);
    index.finish();

    return {
      run: run,
      step: step,
      results: results,

      // undocumented, don't use unless you know what you are doing:
      checkIntersection: checkIntersection
    }

    function run() {
      for (var i = 0; i < lines.length; ++i) {
        if (checkIntersection(lines[i], i)) {
          return; // stop early
        }
      }
      return results;
    }

    function checkIntersection(currentSegment, currentId) {
      // sorry about code duplication.
      var minX = currentSegment.from.x; var maxX = currentSegment.to.x;
      var minY = currentSegment.from.y; var maxY = currentSegment.to.y;
      var t;
      if (minX > maxX) { t = minX; minX = maxX; maxX = t; }
      if (minY > maxY) { t = minY; minY = maxY; maxY = t; }

      var ids = index.search(minX, minY, maxX, maxY);

      for (var i = 0; i < ids.length; ++i) {
        var segmentIndex = ids[i];
        if (segmentIndex <= currentId) { continue; } // we have either reported it, or it is current.

        var otherSegment = lines[segmentIndex];
        var point = intersectSegments$1(otherSegment, currentSegment);

        if (point) {
          if (reportIntersection(point, [currentSegment, otherSegment])) {
            // stop early
            return true;
          }
        }
      }
    }

    function step() {
      if (!asyncState) {
        asyncState = {i: 0};
      }
      var test = lines[asyncState.i];
      checkIntersection(test, asyncState.i);
      asyncState.i += 1;
      return asyncState.i < lines.length;
    }


    function addToIndex(line) {
      var minX = line.from.x; var maxX = line.to.x;
      var minY = line.from.y; var maxY = line.to.y;
      var t;
      if (minX > maxX) { t = minX; minX = maxX; maxX = t; }
      if (minY > maxY) { t = minY; minY = maxY; maxY = t; }
      index.add(minX, minY, maxX, maxY);
    }

    function defaultIntersectionReporter(p, interior) {
      results.push({
        point: p, 
        segments: interior
      });
    }
  }

  exports.sweep = isect;
  exports.brute = brute;
  exports.bush = bush;

  Object.defineProperty(exports, '__esModule', { value: true });

})));


},{}],6:[function(require,module,exports){
/**
 * JSTS. See https://github.com/bjornharrtell/jsts
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EDLv1.txt
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EPLv1.txt
 * https://github.com/bjornharrtell/jsts/blob/master/LICENSE_LICENSE_ES6_COLLECTIONS.txt
 * @license
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t=t||self).jsts={})}(this,(function(t){"use strict";class e{constructor(){e.constructor_.apply(this,arguments)}static equalsWithTolerance(t,e,n){return Math.abs(t-e)<=n}getClass(){return e}get interfaces_(){return[]}}function n(t){this.message=t}function s(t,e){this.low=0|e,this.high=0|t}function i(){}function r(){}function o(){}function l(){}function a(){}function c(t){this.name="RuntimeException",this.message=t,this.stack=(new Error).stack,Error.call(this,t)}e.constructor_=function(){},s.toBinaryString=function(t){let e,n="";for(e=2147483648;e>0;e>>>=1)n+=(t.high&e)===e?"1":"0";for(e=2147483648;e>0;e>>>=1)n+=(t.low&e)===e?"1":"0";return n},i.isNaN=t=>Number.isNaN(t),i.isInfinite=t=>!Number.isFinite(t),i.MAX_VALUE=Number.MAX_VALUE,"function"==typeof Float64Array&&"function"==typeof Int32Array?function(){const t=new Float64Array(1),e=new Int32Array(t.buffer);i.doubleToLongBits=function(n){t[0]=n;let i=0|e[0],r=0|e[1];return 2146435072==(2146435072&r)&&0!=(1048575&r)&&0!==i&&(i=0,r=2146959360),new s(r,i)},i.longBitsToDouble=function(n){return e[0]=n.low,e[1]=n.high,t[0]}}():function(){const t=Math.log2,e=Math.floor,n=Math.pow,r=function(){for(let s=53;s>0;s--){const i=n(2,s)-1;if(e(t(i))+1===s)return i}return 0}();i.doubleToLongBits=function(i){let o,l,a,c,h,u,g,d,_;if(i<0||1/i===Number.NEGATIVE_INFINITY?(u=1<<31,i=-i):u=0,0===i)return _=0,d=u,new s(d,_);if(i===1/0)return _=0,d=2146435072|u,new s(d,_);if(i!=i)return _=0,d=2146959360,new s(d,_);if(c=0,_=0,o=e(i),o>1)if(o<=r)c=e(t(o)),c<=20?(_=0,d=o<<20-c&1048575):(a=c-20,l=n(2,a),_=o%l<<32-a,d=o/l&1048575);else for(a=o,_=0;l=a/2,a=e(l),0!==a;)c++,_>>>=1,_|=(1&d)<<31,d>>>=1,l!==a&&(d|=524288);if(g=c+1023,h=0===o,o=i-o,c<52&&0!==o)for(a=0;;){if(l=2*o,l>=1?(o=l-1,h?(g--,h=!1):(a<<=1,a|=1,c++)):(o=l,h?0==--g&&(c++,h=!1):(a<<=1,c++)),20===c)d|=a,a=0;else if(52===c){_|=a;break}if(1===l){c<20?d|=a<<20-c:c<52&&(_|=a<<52-c);break}}return d|=g<<20,d|=u,new s(d,_)},i.longBitsToDouble=function(t){let e,s,i,r,o;const l=t.high,a=t.low;for(i=l&1<<31?-1:1,r=((2146435072&l)>>20)-1023,o=0,s=1<<19,e=1;e<=20;e++)l&s&&(o+=n(2,-e)),s>>>=1;for(s=1<<31,e=21;e<=52;e++)a&s&&(o+=n(2,-e)),s>>>=1;if(-1023===r){if(0===o)return 0*i;r=-1022}else{if(1024===r)return 0===o?i/0:NaN;o+=1}return i*o*n(2,r)}}(),c.prototype=Object.create(Error.prototype),c.prototype.constructor=Error;class h extends c{constructor(){super(),h.constructor_.apply(this,arguments)}getClass(){return h}get interfaces_(){return[]}}h.constructor_=function(){if(0===arguments.length)c.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];c.constructor_.call(this,t)}};class u{constructor(){u.constructor_.apply(this,arguments)}static shouldNeverReachHere(){if(0===arguments.length)u.shouldNeverReachHere(null);else if(1===arguments.length){const t=arguments[0];throw new h("Should never reach here"+(null!==t?": "+t:""))}}static isTrue(){if(1===arguments.length){const t=arguments[0];u.isTrue(t,null)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(!t)throw null===e?new h:new h(e)}}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];u.equals(t,e,null)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(!e.equals(t))throw new h("Expected "+t+" but encountered "+e+(null!==n?": "+n:""))}}getClass(){return u}get interfaces_(){return[]}}u.constructor_=function(){};class g{constructor(){g.constructor_.apply(this,arguments)}static hashCode(){if(1===arguments.length&&"number"==typeof arguments[0]){const t=arguments[0],e=i.doubleToLongBits(t);return Math.trunc(e^e>>>32)}}setOrdinate(t,e){switch(t){case g.X:this.x=e;break;case g.Y:this.y=e;break;case g.Z:this.z=e;break;default:throw new n("Invalid ordinate index: "+t)}}equals2D(){if(1===arguments.length){const t=arguments[0];return this.x===t.x&&this.y===t.y}if(2===arguments.length){const t=arguments[0],n=arguments[1];return!!e.equalsWithTolerance(this.x,t.x,n)&&!!e.equalsWithTolerance(this.y,t.y,n)}}getOrdinate(t){switch(t){case g.X:return this.x;case g.Y:return this.y;case g.Z:return this.z}throw new n("Invalid ordinate index: "+t)}equals3D(t){return this.x===t.x&&this.y===t.y&&(this.z===t.z||i.isNaN(this.z)&&i.isNaN(t.z))}equals(t){return t instanceof g&&this.equals2D(t)}equalInZ(t,n){return e.equalsWithTolerance(this.z,t.z,n)}compareTo(t){const e=t;return this.x<e.x?-1:this.x>e.x?1:this.y<e.y?-1:this.y>e.y?1:0}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return u.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"),null;throw t}}copy(){return new g(this)}toString(){return"("+this.x+", "+this.y+", "+this.z+")"}distance3D(t){const e=this.x-t.x,n=this.y-t.y,s=this.z-t.z;return Math.sqrt(e*e+n*n+s*s)}distance(t){const e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)}hashCode(){let t=17;return t=37*t+g.hashCode(this.x),t=37*t+g.hashCode(this.y),t}setCoordinate(t){this.x=t.x,this.y=t.y,this.z=t.z}getClass(){return g}get interfaces_(){return[r,o,a]}}class d{constructor(){d.constructor_.apply(this,arguments)}static compare(t,e){return t<e?-1:t>e?1:i.isNaN(t)?i.isNaN(e)?0:-1:i.isNaN(e)?1:0}compare(t,e){const n=t,s=e,i=d.compare(n.x,s.x);if(0!==i)return i;const r=d.compare(n.y,s.y);return 0!==r?r:this._dimensionsToTest<=2?0:d.compare(n.z,s.z)}getClass(){return d}get interfaces_(){return[l]}}function _(t,e){return t.interfaces_&&t.interfaces_.indexOf(e)>-1}function f(){}function p(t){this.message=t||""}function m(){}function y(t){this.message=t||""}function x(){this.array_=[],arguments[0]instanceof f&&this.addAll(arguments[0])}d.constructor_=function(){if(this._dimensionsToTest=2,0===arguments.length)d.constructor_.call(this,2);else if(1===arguments.length){const t=arguments[0];if(2!==t&&3!==t)throw new n("only 2 or 3 dimensions may be specified");this._dimensionsToTest=t}},g.DimensionalComparator=d,g.constructor_=function(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)g.constructor_.call(this,0,0);else if(1===arguments.length){const t=arguments[0];g.constructor_.call(this,t.x,t.y,t.z)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];g.constructor_.call(this,t,e,g.NULL_ORDINATE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.x=t,this.y=e,this.z=n}},g.serialVersionUID=0x5cbf2c235c7e5800,g.NULL_ORDINATE=i.NaN,g.X=0,g.Y=1,g.Z=2,f.prototype.add=function(){},f.prototype.addAll=function(){},f.prototype.isEmpty=function(){},f.prototype.iterator=function(){},f.prototype.size=function(){},f.prototype.toArray=function(){},f.prototype.remove=function(){},p.prototype=new Error,p.prototype.name="IndexOutOfBoundsException",m.prototype=Object.create(f.prototype),m.prototype.constructor=m,m.prototype.get=function(){},m.prototype.set=function(){},m.prototype.isEmpty=function(){},y.prototype=new Error,y.prototype.name="NoSuchElementException",x.prototype=Object.create(m.prototype),x.prototype.constructor=x,x.prototype.ensureCapacity=function(){},x.prototype.interfaces_=[m,f],x.prototype.add=function(t){return 1===arguments.length?this.array_.push(t):this.array_.splice(arguments[0],0,arguments[1]),!0},x.prototype.clear=function(){this.array_=[]},x.prototype.addAll=function(t){for(let e=t.iterator();e.hasNext();)this.add(e.next());return!0},x.prototype.set=function(t,e){const n=this.array_[t];return this.array_[t]=e,n},x.prototype.iterator=function(){return new E(this)},x.prototype.get=function(t){if(t<0||t>=this.size())throw new p;return this.array_[t]},x.prototype.isEmpty=function(){return 0===this.array_.length},x.prototype.size=function(){return this.array_.length},x.prototype.toArray=function(){const t=[];for(let e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t},x.prototype.remove=function(t){let e=!1;for(let n=0,s=this.array_.length;n<s;n++)if(this.array_[n]===t){this.array_.splice(n,1),e=!0;break}return e},x.prototype.removeAll=function(t){for(let e=t.iterator();e.hasNext();)this.remove(e.next());return!0};const E=function(t){this.arrayList_=t,this.position_=0};E.prototype.next=function(){if(this.position_===this.arrayList_.size())throw new y;return this.arrayList_.get(this.position_++)},E.prototype.hasNext=function(){return this.position_<this.arrayList_.size()},E.prototype.set=function(t){return this.arrayList_.set(this.position_-1,t)},E.prototype.remove=function(){this.arrayList_.remove(this.arrayList_.get(this.position_))};class I extends x{constructor(){super(),I.constructor_.apply(this,arguments)}getCoordinate(t){return this.get(t)}addAll(){if(2===arguments.length&&"boolean"==typeof arguments[1]&&_(arguments[0],f)){const t=arguments[0],e=arguments[1];let n=!1;for(let s=t.iterator();s.hasNext();)this.add(s.next(),e),n=!0;return n}return super.addAll.apply(this,arguments)}clone(){const t=super.clone.call(this);for(let e=0;e<this.size();e++)t.add(e,this.get(e).clone());return t}toCoordinateArray(){return this.toArray(I.coordArrayType)}add(){if(1===arguments.length){const t=arguments[0];super.add.call(this,t)}else if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e,!0),!0}if(arguments[0]instanceof g&&"boolean"==typeof arguments[1]){const t=arguments[0];if(!arguments[1]&&this.size()>=1){if(this.get(this.size()-1).equals2D(t))return null}super.add.call(this,t)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return this.add(t,e),!0}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(arguments[2])for(let n=0;n<t.length;n++)this.add(t[n],e);else for(let n=t.length-1;n>=0;n--)this.add(t[n],e);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1];if(!arguments[2]){const n=this.size();if(n>0){if(t>0){if(this.get(t-1).equals2D(e))return null}if(t<n){if(this.get(t).equals2D(e))return null}}}super.add.call(this,t,e)}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];let i=1;n>s&&(i=-1);for(let r=n;r!==s;r+=i)this.add(t[r],e);return!0}}closeRing(){this.size()>0&&this.add(new g(this.get(0)),!1)}getClass(){return I}get interfaces_(){return[]}}I.constructor_=function(){if(0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.ensureCapacity(t.length),this.add(t,!0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.ensureCapacity(t.length),this.add(t,e)}},I.coordArrayType=new Array(0).fill(null);class N{constructor(){N.constructor_.apply(this,arguments)}static intersects(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return n.x>=(t.x<e.x?t.x:e.x)&&n.x<=(t.x>e.x?t.x:e.x)&&n.y>=(t.y<e.y?t.y:e.y)&&n.y<=(t.y>e.y?t.y:e.y)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];let i=Math.min(n.x,s.x),r=Math.max(n.x,s.x),o=Math.min(t.x,e.x),l=Math.max(t.x,e.x);return!(o>r)&&(!(l<i)&&(i=Math.min(n.y,s.y),r=Math.max(n.y,s.y),o=Math.min(t.y,e.y),l=Math.max(t.y,e.y),!(o>r)&&!(l<i)))}}getArea(){return this.getWidth()*this.getHeight()}equals(t){if(!(t instanceof N))return!1;const e=t;return this.isNull()?e.isNull():this._maxx===e.getMaxX()&&this._maxy===e.getMaxY()&&this._minx===e.getMinX()&&this._miny===e.getMinY()}intersection(t){if(this.isNull()||t.isNull()||!this.intersects(t))return new N;const e=this._minx>t._minx?this._minx:t._minx,n=this._miny>t._miny?this._miny:t._miny,s=this._maxx<t._maxx?this._maxx:t._maxx,i=this._maxy<t._maxy?this._maxy:t._maxy;return new N(e,s,n,i)}isNull(){return this._maxx<this._minx}getMaxX(){return this._maxx}covers(){if(1===arguments.length){if(arguments[0]instanceof g){const t=arguments[0];return this.covers(t.x,t.y)}if(arguments[0]instanceof N){const t=arguments[0];return!this.isNull()&&!t.isNull()&&(t.getMinX()>=this._minx&&t.getMaxX()<=this._maxx&&t.getMinY()>=this._miny&&t.getMaxY()<=this._maxy)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return!this.isNull()&&(t>=this._minx&&t<=this._maxx&&e>=this._miny&&e<=this._maxy)}}intersects(){if(1===arguments.length){if(arguments[0]instanceof N){const t=arguments[0];return!this.isNull()&&!t.isNull()&&!(t._minx>this._maxx||t._maxx<this._minx||t._miny>this._maxy||t._maxy<this._miny)}if(arguments[0]instanceof g){const t=arguments[0];return this.intersects(t.x,t.y)}}else if(2===arguments.length){if(arguments[0]instanceof g&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1];return!this.isNull()&&(!((t.x<e.x?t.x:e.x)>this._maxx)&&(!((t.x>e.x?t.x:e.x)<this._minx)&&(!((t.y<e.y?t.y:e.y)>this._maxy)&&!((t.y>e.y?t.y:e.y)<this._miny))))}if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return!this.isNull()&&!(t>this._maxx||t<this._minx||e>this._maxy||e<this._miny)}}}getMinY(){return this._miny}getMinX(){return this._minx}expandToInclude(){if(1===arguments.length){if(arguments[0]instanceof g){const t=arguments[0];this.expandToInclude(t.x,t.y)}else if(arguments[0]instanceof N){const t=arguments[0];if(t.isNull())return null;this.isNull()?(this._minx=t.getMinX(),this._maxx=t.getMaxX(),this._miny=t.getMinY(),this._maxy=t.getMaxY()):(t._minx<this._minx&&(this._minx=t._minx),t._maxx>this._maxx&&(this._maxx=t._maxx),t._miny<this._miny&&(this._miny=t._miny),t._maxy>this._maxy&&(this._maxy=t._maxy))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.isNull()?(this._minx=t,this._maxx=t,this._miny=e,this._maxy=e):(t<this._minx&&(this._minx=t),t>this._maxx&&(this._maxx=t),e<this._miny&&(this._miny=e),e>this._maxy&&(this._maxy=e))}}minExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t<e?t:e}getWidth(){return this.isNull()?0:this._maxx-this._minx}compareTo(t){const e=t;return this.isNull()?e.isNull()?0:-1:e.isNull()?1:this._minx<e._minx?-1:this._minx>e._minx?1:this._miny<e._miny?-1:this._miny>e._miny?1:this._maxx<e._maxx?-1:this._maxx>e._maxx?1:this._maxy<e._maxy?-1:this._maxy>e._maxy?1:0}translate(t,e){if(this.isNull())return null;this.init(this.getMinX()+t,this.getMaxX()+t,this.getMinY()+e,this.getMaxY()+e)}toString(){return"Env["+this._minx+" : "+this._maxx+", "+this._miny+" : "+this._maxy+"]"}setToNull(){this._minx=0,this._maxx=-1,this._miny=0,this._maxy=-1}getHeight(){return this.isNull()?0:this._maxy-this._miny}maxExtent(){if(this.isNull())return 0;const t=this.getWidth(),e=this.getHeight();return t>e?t:e}expandBy(){if(1===arguments.length){const t=arguments[0];this.expandBy(t,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.isNull())return null;this._minx-=t,this._maxx+=t,this._miny-=e,this._maxy+=e,(this._minx>this._maxx||this._miny>this._maxy)&&this.setToNull()}}contains(){if(1===arguments.length){if(arguments[0]instanceof N){const t=arguments[0];return this.covers(t)}if(arguments[0]instanceof g){const t=arguments[0];return this.covers(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.covers(t,e)}}centre(){return this.isNull()?null:new g((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)}init(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof g){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof N){const t=arguments[0];this._minx=t._minx,this._maxx=t._maxx,this._miny=t._miny,this._maxy=t._maxy}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];t<e?(this._minx=t,this._maxx=e):(this._minx=e,this._maxx=t),n<s?(this._miny=n,this._maxy=s):(this._miny=s,this._maxy=n)}}getMaxY(){return this._maxy}distance(t){if(this.intersects(t))return 0;let e=0;this._maxx<t._minx?e=t._minx-this._maxx:this._minx>t._maxx&&(e=this._minx-t._maxx);let n=0;return this._maxy<t._miny?n=t._miny-this._maxy:this._miny>t._maxy&&(n=this._miny-t._maxy),0===e?n:0===n?e:Math.sqrt(e*e+n*n)}hashCode(){let t=17;return t=37*t+g.hashCode(this._minx),t=37*t+g.hashCode(this._maxx),t=37*t+g.hashCode(this._miny),t=37*t+g.hashCode(this._maxy),t}getClass(){return N}get interfaces_(){return[r,a]}}function C(){}N.constructor_=function(){if(this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,0===arguments.length)this.init();else if(1===arguments.length){if(arguments[0]instanceof g){const t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof N){const t=arguments[0];this.init(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t.x,e.x,t.y,e.y)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.init(t,e,n,s)}},N.serialVersionUID=0x51845cd552189800;class S extends C{constructor(){super(),S.constructor_.apply(this,arguments)}getClass(){return S}get interfaces_(){return[]}}function w(t){this.str=t}function L(t){this.value=t}function T(){}S.constructor_=function(){C.constructor_.call(this,"Projective point not representable on the Cartesian plane.")},w.prototype.append=function(t){this.str+=t},w.prototype.setCharAt=function(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)},w.prototype.toString=function(t){return this.str},L.prototype.intValue=function(){return this.value},L.prototype.compareTo=function(t){return this.value<t?-1:this.value>t?1:0},L.isNaN=t=>Number.isNaN(t),T.isWhitespace=t=>t<=32&&t>=0||127===t,T.toUpperCase=t=>t.toUpperCase();class R{constructor(){R.constructor_.apply(this,arguments)}static sqr(t){return R.valueOf(t).selfMultiply(t)}static valueOf(){if("string"==typeof arguments[0]){const t=arguments[0];return R.parse(t)}if("number"==typeof arguments[0]){const t=arguments[0];return new R(t)}}static sqrt(t){return R.valueOf(t).sqrt()}static parse(t){let e=0;const n=t.length;for(;T.isWhitespace(t.charAt(e));)e++;let s=!1;if(e<n){const n=t.charAt(e);"-"!==n&&"+"!==n||(e++,"-"===n&&(s=!0))}const i=new R;let r=0,o=0,l=0;for(;!(e>=n);){const n=t.charAt(e);if(e++,T.isDigit(n)){const t=n-"0";i.selfMultiply(R.TEN),i.selfAdd(t),r++}else{if("."!==n){if("e"===n||"E"===n){const n=t.substring(e);try{l=L.parseInt(n)}catch(e){throw e instanceof NumberFormatException?new NumberFormatException("Invalid exponent "+n+" in string "+t):e}break}throw new NumberFormatException("Unexpected character '"+n+"' at position "+e+" in string "+t)}o=r}}let a=i;const c=r-o-l;if(0===c)a=i;else if(c>0){const t=R.TEN.pow(c);a=i.divide(t)}else if(c<0){const t=R.TEN.pow(-c);a=i.multiply(t)}return s?a.negate():a}static createNaN(){return new R(i.NaN,i.NaN)}static copy(t){return new R(t)}static magnitude(t){const e=Math.abs(t),n=Math.log(e)/Math.log(10);let s=Math.trunc(Math.floor(n));return 10*Math.pow(10,s)<=e&&(s+=1),s}static stringOfChar(t,e){const n=new w;for(let s=0;s<e;s++)n.append(t);return n.toString()}le(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<=t._lo}extractSignificantDigits(t,e){let n=this.abs(),s=R.magnitude(n._hi);const i=R.TEN.pow(s);n=n.divide(i),n.gt(R.TEN)?(n=n.divide(R.TEN),s+=1):n.lt(R.ONE)&&(n=n.multiply(R.TEN),s-=1);const r=s+1,o=new w,l=R.MAX_PRINT_DIGITS-1;for(let e=0;e<=l;e++){t&&e===r&&o.append(".");const s=Math.trunc(n._hi);if(s<0)break;let i=!1,a=0;s>9?(i=!0,a="9"):a="0"+s,o.append(a),n=n.subtract(R.valueOf(s)).multiply(R.TEN),i&&n.selfAdd(R.TEN);let c=!0;const h=R.magnitude(n._hi);if(h<0&&Math.abs(h)>=l-e&&(c=!1),!c)break}return e[0]=s,o.toString()}sqr(){return this.multiply(this)}doubleValue(){return this._hi+this._lo}subtract(){if(arguments[0]instanceof R){const t=arguments[0];return this.add(t.negate())}if("number"==typeof arguments[0]){const t=arguments[0];return this.add(-t)}}equals(){if(1===arguments.length&&arguments[0]instanceof R){const t=arguments[0];return this._hi===t._hi&&this._lo===t._lo}}isZero(){return 0===this._hi&&0===this._lo}selfSubtract(){if(arguments[0]instanceof R){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t._hi,-t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.isNaN()?this:this.selfAdd(-t,0)}}getSpecialNumberString(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null}min(t){return this.le(t)?this:t}selfDivide(){if(1===arguments.length){if(arguments[0]instanceof R){const t=arguments[0];return this.selfDivide(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfDivide(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null,a=null,c=null;return o=this._hi/t,l=R.SPLIT*o,n=l-o,c=R.SPLIT*t,n=l-n,s=o-n,i=c-t,a=o*t,i=c-i,r=t-i,c=n*i-a+n*r+s*i+s*r,l=(this._hi-a-c+this._lo-o*e)/t,c=o+l,this._hi=c,this._lo=o-c+l,this}}dump(){return"DD<"+this._hi+", "+this._lo+">"}divide(){if(arguments[0]instanceof R){const t=arguments[0];let e=null,n=null,s=null,i=null,r=null,o=null,l=null,a=null;return r=this._hi/t._hi,o=R.SPLIT*r,e=o-r,a=R.SPLIT*t._hi,e=o-e,n=r-e,s=a-t._hi,l=r*t._hi,s=a-s,i=t._hi-s,a=e*s-l+e*i+n*s+n*i,o=(this._hi-l-a+this._lo-r*t._lo)/t._hi,a=r+o,new R(a,r-a+o)}if("number"==typeof arguments[0]){const t=arguments[0];return i.isNaN(t)?R.createNaN():R.copy(this).selfDivide(t,0)}}ge(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>=t._lo}pow(t){if(0===t)return R.valueOf(1);let e=new R(this),n=R.valueOf(1),s=Math.abs(t);if(s>1)for(;s>0;)s%2==1&&n.selfMultiply(e),s/=2,s>0&&(e=e.sqr());else n=e;return t<0?n.reciprocal():n}ceil(){if(this.isNaN())return R.NaN;const t=Math.ceil(this._hi);let e=0;return t===this._hi&&(e=Math.ceil(this._lo)),new R(t,e)}compareTo(t){const e=t;return this._hi<e._hi?-1:this._hi>e._hi?1:this._lo<e._lo?-1:this._lo>e._lo?1:0}rint(){if(this.isNaN())return this;return this.add(.5).floor()}setValue(){if(arguments[0]instanceof R){const t=arguments[0];return this.init(t),this}if("number"==typeof arguments[0]){const t=arguments[0];return this.init(t),this}}max(t){return this.ge(t)?this:t}sqrt(){if(this.isZero())return R.valueOf(0);if(this.isNegative())return R.NaN;const t=1/Math.sqrt(this._hi),e=this._hi*t,n=R.valueOf(e),s=this.subtract(n.sqr())._hi*(.5*t);return n.add(s)}selfAdd(){if(1===arguments.length){if(arguments[0]instanceof R){const t=arguments[0];return this.selfAdd(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];let e=null,n=null,s=null,i=null,r=null,o=null;return s=this._hi+t,r=s-this._hi,i=s-r,i=t-r+(this._hi-i),o=i+this._lo,e=s+o,n=o+(s-e),this._hi=e+n,this._lo=n+(e-this._hi),this}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null,a=null,c=null;o=this._hi+t,i=this._lo+e,a=o-this._hi,c=i-this._lo,l=o-a,r=i-c,l=t-a+(this._hi-l),r=e-c+(this._lo-r),a=l+i,n=o+a,s=a+(o-n),a=r+s;const h=n+a,u=a+(n-h);return this._hi=h,this._lo=u,this}}selfMultiply(){if(1===arguments.length){if(arguments[0]instanceof R){const t=arguments[0];return this.selfMultiply(t._hi,t._lo)}if("number"==typeof arguments[0]){const t=arguments[0];return this.selfMultiply(t,0)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null,s=null,i=null,r=null,o=null,l=null;o=R.SPLIT*this._hi,n=o-this._hi,l=R.SPLIT*t,n=o-n,s=this._hi-n,i=l-t,o=this._hi*t,i=l-i,r=t-i,l=n*i-o+n*r+s*i+s*r+(this._hi*e+this._lo*t);const a=o+l;n=o-a;const c=l+n;return this._hi=a,this._lo=c,this}}selfSqr(){return this.selfMultiply(this)}floor(){if(this.isNaN())return R.NaN;const t=Math.floor(this._hi);let e=0;return t===this._hi&&(e=Math.floor(this._lo)),new R(t,e)}negate(){return this.isNaN()?this:new R(-this._hi,-this._lo)}clone(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return null;throw t}}multiply(){if(arguments[0]instanceof R){const t=arguments[0];return t.isNaN()?R.createNaN():R.copy(this).selfMultiply(t)}if("number"==typeof arguments[0]){const t=arguments[0];return i.isNaN(t)?R.createNaN():R.copy(this).selfMultiply(t,0)}}isNaN(){return i.isNaN(this._hi)}intValue(){return Math.trunc(this._hi)}toString(){const t=R.magnitude(this._hi);return t>=-3&&t<=20?this.toStandardNotation():this.toSciNotation()}toStandardNotation(){const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!0,e),s=e[0]+1;let i=n;if("."===n.charAt(0))i="0"+n;else if(s<0)i="0."+R.stringOfChar("0",-s)+n;else if(-1===n.indexOf(".")){const t=s-n.length;i=n+R.stringOfChar("0",t)+".0"}return this.isNegative()?"-"+i:i}reciprocal(){let t=null,e=null,n=null,s=null,i=null,r=null,o=null,l=null;i=1/this._hi,r=R.SPLIT*i,t=r-i,l=R.SPLIT*this._hi,t=r-t,e=i-t,n=l-this._hi,o=i*this._hi,n=l-n,s=this._hi-n,l=t*n-o+t*s+e*n+e*s,r=(1-o-l-i*this._lo)/this._hi;const a=i+r;return new R(a,i-a+r)}toSciNotation(){if(this.isZero())return R.SCI_NOT_ZERO;const t=this.getSpecialNumberString();if(null!==t)return t;const e=new Array(1).fill(null),n=this.extractSignificantDigits(!1,e),s=R.SCI_NOT_EXPONENT_CHAR+e[0];if("0"===n.charAt(0))throw new IllegalStateException("Found leading zero: "+n);let i="";n.length>1&&(i=n.substring(1));const r=n.charAt(0)+"."+i;return this.isNegative()?"-"+r+s:r+s}abs(){return this.isNaN()?R.NaN:this.isNegative()?this.negate():new R(this)}isPositive(){return this._hi>0||0===this._hi&&this._lo>0}lt(t){return this._hi<t._hi||this._hi===t._hi&&this._lo<t._lo}add(){if(arguments[0]instanceof R){const t=arguments[0];return R.copy(this).selfAdd(t)}if("number"==typeof arguments[0]){const t=arguments[0];return R.copy(this).selfAdd(t)}}init(){if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this._hi=t,this._lo=0}else if(arguments[0]instanceof R){const t=arguments[0];this._hi=t._hi,this._lo=t._lo}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._hi=t,this._lo=e}}gt(t){return this._hi>t._hi||this._hi===t._hi&&this._lo>t._lo}isNegative(){return this._hi<0||0===this._hi&&this._lo<0}trunc(){return this.isNaN()?R.NaN:this.isPositive()?this.floor():this.ceil()}signum(){return this._hi>0?1:this._hi<0?-1:this._lo>0?1:this._lo<0?-1:0}getClass(){return R}get interfaces_(){return[a,r,o]}}R.constructor_=function(){if(this._hi=0,this._lo=0,0===arguments.length)this.init(0);else if(1===arguments.length){if("number"==typeof arguments[0]){const t=arguments[0];this.init(t)}else if(arguments[0]instanceof R){const t=arguments[0];this.init(t)}else if("string"==typeof arguments[0]){const t=arguments[0];R.constructor_.call(this,R.parse(t))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.init(t,e)}},R.PI=new R(3.141592653589793,12246467991473532e-32),R.TWO_PI=new R(6.283185307179586,24492935982947064e-32),R.PI_2=new R(1.5707963267948966,6123233995736766e-32),R.E=new R(2.718281828459045,14456468917292502e-32),R.NaN=new R(i.NaN,i.NaN),R.EPS=123259516440783e-46,R.SPLIT=134217729,R.MAX_PRINT_DIGITS=32,R.TEN=R.valueOf(10),R.ONE=R.valueOf(1),R.SCI_NOT_EXPONENT_CHAR="E",R.SCI_NOT_ZERO="0.0E0";class P{constructor(){P.constructor_.apply(this,arguments)}static orientationIndex(t,e,n){const s=P.orientationIndexFilter(t,e,n);if(s<=1)return s;const i=R.valueOf(e.x).selfAdd(-t.x),r=R.valueOf(e.y).selfAdd(-t.y),o=R.valueOf(n.x).selfAdd(-e.x),l=R.valueOf(n.y).selfAdd(-e.y);return i.selfMultiply(l).selfSubtract(r.selfMultiply(o)).signum()}static signOfDet2x2(){if(arguments[3]instanceof R&&arguments[2]instanceof R&&arguments[0]instanceof R&&arguments[1]instanceof R){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return t.multiply(s).selfSubtract(e.multiply(n)).signum()}if("number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=R.valueOf(t),r=R.valueOf(e),o=R.valueOf(n),l=R.valueOf(s);return i.multiply(l).selfSubtract(r.multiply(o)).signum()}}static intersection(t,e,n,s){const i=R.valueOf(s.y).selfSubtract(n.y).selfMultiply(R.valueOf(e.x).selfSubtract(t.x)),r=R.valueOf(s.x).selfSubtract(n.x).selfMultiply(R.valueOf(e.y).selfSubtract(t.y)),o=i.subtract(r),l=R.valueOf(s.x).selfSubtract(n.x).selfMultiply(R.valueOf(t.y).selfSubtract(n.y)),a=R.valueOf(s.y).selfSubtract(n.y).selfMultiply(R.valueOf(t.x).selfSubtract(n.x)),c=l.subtract(a).selfDivide(o).doubleValue(),h=R.valueOf(t.x).selfAdd(R.valueOf(e.x).selfSubtract(t.x).selfMultiply(c)).doubleValue(),u=R.valueOf(e.x).selfSubtract(t.x).selfMultiply(R.valueOf(t.y).selfSubtract(n.y)),d=R.valueOf(e.y).selfSubtract(t.y).selfMultiply(R.valueOf(t.x).selfSubtract(n.x)),_=u.subtract(d).selfDivide(o).doubleValue(),f=R.valueOf(n.y).selfAdd(R.valueOf(s.y).selfSubtract(n.y).selfMultiply(_)).doubleValue();return new g(h,f)}static orientationIndexFilter(t,e,n){let s=null;const i=(t.x-n.x)*(e.y-n.y),r=(t.y-n.y)*(e.x-n.x),o=i-r;if(i>0){if(r<=0)return P.signum(o);s=i+r}else{if(!(i<0))return P.signum(o);if(r>=0)return P.signum(o);s=-i-r}const l=P.DP_SAFE_EPSILON*s;return o>=l||-o>=l?P.signum(o):2}static signum(t){return t>0?1:t<0?-1:0}getClass(){return P}get interfaces_(){return[]}}P.constructor_=function(){},P.DP_SAFE_EPSILON=1e-15;class v{constructor(){v.constructor_.apply(this,arguments)}static index(t,e,n){return P.orientationIndex(t,e,n)}static isCCW(t){const e=t.length-1;if(e<3)throw new n("Ring has fewer than 4 points, so orientation cannot be determined");let s=t[0],i=0;for(let n=1;n<=e;n++){const e=t[n];e.y>s.y&&(s=e,i=n)}let r=i;do{r-=1,r<0&&(r=e)}while(t[r].equals2D(s)&&r!==i);let o=i;do{o=(o+1)%e}while(t[o].equals2D(s)&&o!==i);const l=t[r],a=t[o];if(l.equals2D(s)||a.equals2D(s)||l.equals2D(a))return!1;const c=v.index(l,s,a);let h=null;return h=0===c?l.x>a.x:c>0,h}getClass(){return v}get interfaces_(){return[]}}function O(){}v.constructor_=function(){},v.CLOCKWISE=-1,v.RIGHT=v.CLOCKWISE,v.COUNTERCLOCKWISE=1,v.LEFT=v.COUNTERCLOCKWISE,v.COLLINEAR=0,v.STRAIGHT=v.COLLINEAR,O.arraycopy=(t,e,n,s,i)=>{let r=0;for(let o=e;o<e+i;o++)n[s+r]=t[o],r++},O.getProperty=t=>({"line.separator":"\n"}[t]);class b{constructor(){b.constructor_.apply(this,arguments)}static intersection(t,e,n,s){const r=t.y-e.y,o=e.x-t.x,l=t.x*e.y-e.x*t.y,a=n.y-s.y,c=s.x-n.x,h=n.x*s.y-s.x*n.y,u=r*c-a*o,d=(o*h-c*l)/u,_=(a*l-r*h)/u;if(i.isNaN(d)||i.isInfinite(d)||i.isNaN(_)||i.isInfinite(_))throw new S;return new g(d,_)}getY(){const t=this.y/this.w;if(i.isNaN(t)||i.isInfinite(t))throw new S;return t}getX(){const t=this.x/this.w;if(i.isNaN(t)||i.isInfinite(t))throw new S;return t}getCoordinate(){const t=new g;return t.x=this.getX(),t.y=this.getY(),t}getClass(){return b}get interfaces_(){return[]}}b.constructor_=function(){if(this.x=null,this.y=null,this.w=null,0===arguments.length)this.x=0,this.y=0,this.w=1;else if(1===arguments.length){const t=arguments[0];this.x=t.x,this.y=t.y,this.w=1}else if(2===arguments.length){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];this.x=t,this.y=e,this.w=1}else if(arguments[0]instanceof b&&arguments[1]instanceof b){const t=arguments[0],e=arguments[1];this.x=t.y*e.w-e.y*t.w,this.y=e.x*t.w-t.x*e.w,this.w=t.x*e.y-e.x*t.y}else if(arguments[0]instanceof g&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1];this.x=t.y-e.y,this.y=e.x-t.x,this.w=t.x*e.y-e.x*t.y}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.x=t,this.y=e,this.w=n}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=t.y-e.y,r=e.x-t.x,o=t.x*e.y-e.x*t.y,l=n.y-s.y,a=s.x-n.x,c=n.x*s.y-s.x*n.y;this.x=r*c-a*o,this.y=l*o-i*c,this.w=i*a-l*r}};class M{constructor(){M.constructor_.apply(this,arguments)}static log10(t){const e=Math.log(t);return i.isInfinite(e)||i.isNaN(e)?e:e/M.LOG_10}static min(t,e,n,s){let i=t;return e<i&&(i=e),n<i&&(i=n),s<i&&(i=s),i}static clamp(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];return t<e?e:t>n?n:t}}static wrap(t,e){return t<0?e- -t%e:t%e}static max(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];let s=t;return e>s&&(s=e),n>s&&(s=n),s}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];let i=t;return e>i&&(i=e),n>i&&(i=n),s>i&&(i=s),i}}static average(t,e){return(t+e)/2}getClass(){return M}get interfaces_(){return[]}}M.constructor_=function(){},M.LOG_10=Math.log(10);class D{constructor(){D.constructor_.apply(this,arguments)}static segmentToSegment(t,e,n,s){if(t.equals(e))return D.pointToSegment(t,n,s);if(n.equals(s))return D.pointToSegment(s,t,e);let i=!1;if(N.intersects(t,e,n,s)){const r=(e.x-t.x)*(s.y-n.y)-(e.y-t.y)*(s.x-n.x);if(0===r)i=!0;else{const o=(t.y-n.y)*(s.x-n.x)-(t.x-n.x)*(s.y-n.y),l=((t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y))/r,a=o/r;(a<0||a>1||l<0||l>1)&&(i=!0)}}else i=!0;return i?M.min(D.pointToSegment(t,n,s),D.pointToSegment(e,n,s),D.pointToSegment(n,t,e),D.pointToSegment(s,t,e)):0}static pointToSegment(t,e,n){if(e.x===n.x&&e.y===n.y)return t.distance(e);const s=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),i=((t.x-e.x)*(n.x-e.x)+(t.y-e.y)*(n.y-e.y))/s;if(i<=0)return t.distance(e);if(i>=1)return t.distance(n);const r=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/s;return Math.abs(r)*Math.sqrt(s)}static pointToLinePerpendicular(t,e,n){const s=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),i=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/s;return Math.abs(i)*Math.sqrt(s)}static pointToSegmentString(t,e){if(0===e.length)throw new n("Line array must contain at least one vertex");let s=t.distance(e[0]);for(let n=0;n<e.length-1;n++){const i=D.pointToSegment(t,e[n],e[n+1]);i<s&&(s=i)}return s}getClass(){return D}get interfaces_(){return[]}}D.constructor_=function(){};class A{constructor(){A.constructor_.apply(this,arguments)}setOrdinate(t,e,n){}size(){}getOrdinate(t,e){}getCoordinate(){}getCoordinateCopy(t){}getDimension(){}getX(t){}expandEnvelope(t){}copy(){}getY(t){}toCoordinateArray(){}getClass(){return A}get interfaces_(){return[o]}}A.constructor_=function(){},A.X=0,A.Y=1,A.Z=2,A.M=3;class F{constructor(){F.constructor_.apply(this,arguments)}create(){1===arguments.length&&(arguments[0]instanceof Array||_(arguments[0],A))}getClass(){return F}get interfaces_(){return[]}}F.constructor_=function(){};class G{constructor(){G.constructor_.apply(this,arguments)}filter(t){}getClass(){return G}get interfaces_(){return[]}}G.constructor_=function(){};class q{constructor(){q.constructor_.apply(this,arguments)}isGeometryCollection(){return this.getTypeCode()===q.TYPECODE_GEOMETRYCOLLECTION}getFactory(){return this._factory}getGeometryN(t){return this}getArea(){return 0}isRectangle(){return!1}equals(){if(arguments[0]instanceof q){const t=arguments[0];return null!==t&&this.equalsTopo(t)}if(arguments[0]instanceof Object){const t=arguments[0];if(!(t instanceof q))return!1;const e=t;return this.equalsExact(e)}}equalsExact(t){return this===t||this.equalsExact(t,0)}geometryChanged(){this.apply(q.geometryChangedFilter)}geometryChangedAction(){this._envelope=null}equalsNorm(t){return null!==t&&this.norm().equalsExact(t.norm())}getLength(){return 0}getNumGeometries(){return 1}compareTo(){let t;if(1===arguments.length){const e=arguments[0];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e)}if(2===arguments.length){const e=arguments[0],n=arguments[1];return t=e,this.getTypeCode()!==t.getTypeCode()?this.getTypeCode()-t.getTypeCode():this.isEmpty()&&t.isEmpty()?0:this.isEmpty()?-1:t.isEmpty()?1:this.compareToSameClass(e,n)}}getUserData(){return this._userData}getSRID(){return this._SRID}getEnvelope(){return this.getFactory().toGeometry(this.getEnvelopeInternal())}checkNotGeometryCollection(t){if(t.getTypeCode()===q.TYPECODE_GEOMETRYCOLLECTION)throw new n("This method does not support GeometryCollection arguments")}equal(t,e,n){return 0===n?t.equals(e):t.distance(e)<=n}norm(){const t=this.copy();return t.normalize(),t}getPrecisionModel(){return this._factory.getPrecisionModel()}getEnvelopeInternal(){return null===this._envelope&&(this._envelope=this.computeEnvelopeInternal()),new N(this._envelope)}setSRID(t){this._SRID=t}setUserData(t){this._userData=t}compare(t,e){const n=t.iterator(),s=e.iterator();for(;n.hasNext()&&s.hasNext();){const t=n.next(),e=s.next(),i=t.compareTo(e);if(0!==i)return i}return n.hasNext()?1:s.hasNext()?-1:0}hashCode(){return this.getEnvelopeInternal().hashCode()}isGeometryCollectionOrDerived(){return this.getTypeCode()===q.TYPECODE_GEOMETRYCOLLECTION||this.getTypeCode()===q.TYPECODE_MULTIPOINT||this.getTypeCode()===q.TYPECODE_MULTILINESTRING||this.getTypeCode()===q.TYPECODE_MULTIPOLYGON}get interfaces_(){return[o,r,a]}getClass(){return q}static hasNonEmptyElements(t){for(let e=0;e<t.length;e++)if(!t[e].isEmpty())return!0;return!1}static hasNullElements(t){for(let e=0;e<t.length;e++)if(null===t[e])return!0;return!1}}q.constructor_=function(t){t&&(this._envelope=null,this._userData=null,this._factory=t,this._SRID=t.getSRID())},q.serialVersionUID=0x799ea46522854c00,q.TYPECODE_POINT=0,q.TYPECODE_MULTIPOINT=1,q.TYPECODE_LINESTRING=2,q.TYPECODE_LINEARRING=3,q.TYPECODE_MULTILINESTRING=4,q.TYPECODE_POLYGON=5,q.TYPECODE_MULTIPOLYGON=6,q.TYPECODE_GEOMETRYCOLLECTION=7,q.TYPENAME_POINT="Point",q.TYPENAME_MULTIPOINT="MultiPoint",q.TYPENAME_LINESTRING="LineString",q.TYPENAME_LINEARRING="LinearRing",q.TYPENAME_MULTILINESTRING="MultiLineString",q.TYPENAME_POLYGON="Polygon",q.TYPENAME_MULTIPOLYGON="MultiPolygon",q.TYPENAME_GEOMETRYCOLLECTION="GeometryCollection",q.geometryChangedFilter={get interfaces_(){return[G]},filter(t){t.geometryChangedAction()}};class B{constructor(){B.constructor_.apply(this,arguments)}filter(t){}getClass(){return B}get interfaces_(){return[]}}B.constructor_=function(){};class V{constructor(){V.constructor_.apply(this,arguments)}isInBoundary(t){}getClass(){return V}get interfaces_(){return[]}}class z{constructor(){z.constructor_.apply(this,arguments)}isInBoundary(t){return t%2==1}getClass(){return z}get interfaces_(){return[V]}}z.constructor_=function(){};class Y{constructor(){Y.constructor_.apply(this,arguments)}isInBoundary(t){return t>0}getClass(){return Y}get interfaces_(){return[V]}}Y.constructor_=function(){};class U{constructor(){U.constructor_.apply(this,arguments)}isInBoundary(t){return t>1}getClass(){return U}get interfaces_(){return[V]}}U.constructor_=function(){};class k{constructor(){k.constructor_.apply(this,arguments)}isInBoundary(t){return 1===t}getClass(){return k}get interfaces_(){return[V]}}k.constructor_=function(){},V.Mod2BoundaryNodeRule=z,V.EndPointBoundaryNodeRule=Y,V.MultiValentEndPointBoundaryNodeRule=U,V.MonoValentEndPointBoundaryNodeRule=k,V.constructor_=function(){},V.MOD2_BOUNDARY_RULE=new z,V.ENDPOINT_BOUNDARY_RULE=new Y,V.MULTIVALENT_ENDPOINT_BOUNDARY_RULE=new U,V.MONOVALENT_ENDPOINT_BOUNDARY_RULE=new k,V.OGC_SFS_BOUNDARY_RULE=V.MOD2_BOUNDARY_RULE;class X{constructor(){X.constructor_.apply(this,arguments)}static isRing(t){return!(t.length<4)&&!!t[0].equals2D(t[t.length-1])}static ptNotInList(t,e){for(let n=0;n<t.length;n++){const s=t[n];if(X.indexOf(s,e)<0)return s}return null}static scroll(t,e){const n=X.indexOf(e,t);if(n<0)return null;const s=new Array(t.length).fill(null);O.arraycopy(t,n,s,0,t.length-n),O.arraycopy(t,0,s,t.length-n,n),O.arraycopy(s,0,t,0,t.length)}static equals(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(!t[n].equals(e[n]))return!1;return!0}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(let s=0;s<t.length;s++)if(0!==n.compare(t[s],e[s]))return!1;return!0}}static intersection(t,e){const n=new I;for(let s=0;s<t.length;s++)e.intersects(t[s])&&n.add(t[s],!0);return n.toCoordinateArray()}static hasRepeatedPoints(t){for(let e=1;e<t.length;e++)if(t[e-1].equals(t[e]))return!0;return!1}static removeRepeatedPoints(t){if(!X.hasRepeatedPoints(t))return t;return new I(t,!1).toCoordinateArray()}static reverse(t){const e=t.length-1,n=Math.trunc(e/2);for(let s=0;s<=n;s++){const n=t[s];t[s]=t[e-s],t[e-s]=n}}static removeNull(t){let e=0;for(let n=0;n<t.length;n++)null!==t[n]&&e++;const n=new Array(e).fill(null);if(0===e)return n;let s=0;for(let e=0;e<t.length;e++)null!==t[e]&&(n[s++]=t[e]);return n}static copyDeep(){if(1===arguments.length){const t=arguments[0],e=new Array(t.length).fill(null);for(let n=0;n<t.length;n++)e[n]=new g(t[n]);return e}if(5===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4];for(let r=0;r<i;r++)n[s+r]=new g(t[e+r])}}static isEqualReversed(t,e){for(let n=0;n<t.length;n++){const s=t[n],i=e[t.length-n-1];if(0!==s.compareTo(i))return!1}return!0}static envelope(t){const e=new N;for(let n=0;n<t.length;n++)e.expandToInclude(t[n]);return e}static toCoordinateArray(t){return t.toArray(X.coordArrayType)}static atLeastNCoordinatesOrNothing(t,e){return e.length>=t?e:[]}static indexOf(t,e){for(let n=0;n<e.length;n++)if(t.equals(e[n]))return n;return-1}static increasingDirection(t){for(let e=0;e<Math.trunc(t.length/2);e++){const n=t.length-1-e,s=t[e].compareTo(t[n]);if(0!==s)return s}return 1}static compare(t,e){let n=0;for(;n<t.length&&n<e.length;){const s=t[n].compareTo(e[n]);if(0!==s)return s;n++}return n<e.length?-1:n<t.length?1:0}static minCoordinate(t){let e=null;for(let n=0;n<t.length;n++)(null===e||e.compareTo(t[n])>0)&&(e=t[n]);return e}static extract(t,e,n){e=M.clamp(e,0,t.length);let s=(n=M.clamp(n,-1,t.length))-e+1;n<0&&(s=0),e>=t.length&&(s=0),n<e&&(s=0);const i=new Array(s).fill(null);if(0===s)return i;let r=0;for(let s=e;s<=n;s++)i[r++]=t[s];return i}getClass(){return X}get interfaces_(){return[]}}class H{constructor(){H.constructor_.apply(this,arguments)}compare(t,e){const n=t,s=e;return X.compare(n,s)}getClass(){return H}get interfaces_(){return[l]}}H.constructor_=function(){};class W{constructor(){W.constructor_.apply(this,arguments)}compare(t,e){const n=t,s=e;if(n.length<s.length)return-1;if(n.length>s.length)return 1;if(0===n.length)return 0;const i=X.compare(n,s);return X.isEqualReversed(n,s)?0:i}OLDcompare(t,e){const n=t,s=e;if(n.length<s.length)return-1;if(n.length>s.length)return 1;if(0===n.length)return 0;const i=X.increasingDirection(n),r=X.increasingDirection(s);let o=i>0?0:n.length-1,l=r>0?0:n.length-1;for(let t=0;t<n.length;t++){const t=n[o].compareTo(s[l]);if(0!==t)return t;o+=i,l+=r}return 0}getClass(){return W}get interfaces_(){return[l]}}function j(){}function K(){}function Z(t){this.message=t||""}function Q(){}function J(){this.array_=[],arguments[0]instanceof f&&this.addAll(arguments[0])}W.constructor_=function(){},X.ForwardComparator=H,X.BidirectionalComparator=W,X.constructor_=function(){},X.coordArrayType=new Array(0).fill(null),j.prototype.get=function(){},j.prototype.put=function(){},j.prototype.size=function(){},j.prototype.values=function(){},j.prototype.entrySet=function(){},K.prototype=new j,Z.prototype=new Error,Z.prototype.name="OperationNotSupported",Q.prototype=new f,Q.prototype.contains=function(){},J.prototype=new Q,J.prototype.contains=function(t){for(let e=0,n=this.array_.length;e<n;e++){if(this.array_[e]===t)return!0}return!1},J.prototype.add=function(t){return!this.contains(t)&&(this.array_.push(t),!0)},J.prototype.addAll=function(t){for(let e=t.iterator();e.hasNext();)this.add(e.next());return!0},J.prototype.remove=function(t){throw new Z},J.prototype.size=function(){return this.array_.length},J.prototype.isEmpty=function(){return 0===this.array_.length},J.prototype.toArray=function(){const t=[];for(let e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t},J.prototype.iterator=function(){return new $(this)};const $=function(t){this.hashSet_=t,this.position_=0};$.prototype.next=function(){if(this.position_===this.hashSet_.size())throw new y;return this.hashSet_.array_[this.position_++]},$.prototype.hasNext=function(){return this.position_<this.hashSet_.size()},$.prototype.remove=function(){throw new Z};function tt(t){return null==t?0:t.color}function et(t){return null==t?null:t.parent}function nt(t,e){null!==t&&(t.color=e)}function st(t){return null==t?null:t.left}function it(t){return null==t?null:t.right}function rt(){this.root_=null,this.size_=0}rt.prototype=new K,rt.prototype.get=function(t){for(var e=this.root_;null!==e;){var n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return e.value;e=e.right}}return null},rt.prototype.put=function(t,e){if(null===this.root_)return this.root_={key:t,value:e,left:null,right:null,parent:null,color:0,getValue(){return this.value},getKey(){return this.key}},this.size_=1,null;var n,s,i=this.root_;do{if(n=i,(s=t.compareTo(i.key))<0)i=i.left;else{if(!(s>0)){var r=i.value;return i.value=e,r}i=i.right}}while(null!==i);var o={key:t,left:null,right:null,value:e,parent:n,color:0,getValue(){return this.value},getKey(){return this.key}};return s<0?n.left=o:n.right=o,this.fixAfterInsertion(o),this.size_++,null},rt.prototype.fixAfterInsertion=function(t){let e;for(t.color=1;null!=t&&t!==this.root_&&1===t.parent.color;)et(t)===st(et(et(t)))?(e=it(et(et(t))),1===tt(e)?(nt(et(t),0),nt(e,0),nt(et(et(t)),1),t=et(et(t))):(t===it(et(t))&&(t=et(t),this.rotateLeft(t)),nt(et(t),0),nt(et(et(t)),1),this.rotateRight(et(et(t))))):(e=st(et(et(t))),1===tt(e)?(nt(et(t),0),nt(e,0),nt(et(et(t)),1),t=et(et(t))):(t===st(et(t))&&(t=et(t),this.rotateRight(t)),nt(et(t),0),nt(et(et(t)),1),this.rotateLeft(et(et(t)))));this.root_.color=0},rt.prototype.values=function(){var t=new x,e=this.getFirstEntry();if(null!==e)for(t.add(e.value);null!==(e=rt.successor(e));)t.add(e.value);return t},rt.prototype.entrySet=function(){var t=new J,e=this.getFirstEntry();if(null!==e)for(t.add(e);null!==(e=rt.successor(e));)t.add(e);return t},rt.prototype.rotateLeft=function(t){if(null!=t){var e=t.right;t.right=e.left,null!=e.left&&(e.left.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.left===t?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e}},rt.prototype.rotateRight=function(t){if(null!=t){var e=t.left;t.left=e.right,null!=e.right&&(e.right.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.right===t?t.parent.right=e:t.parent.left=e,e.right=t,t.parent=e}},rt.prototype.getFirstEntry=function(){var t=this.root_;if(null!=t)for(;null!=t.left;)t=t.left;return t},rt.successor=function(t){let e;if(null===t)return null;if(null!==t.right){for(e=t.right;null!==e.left;)e=e.left;return e}e=t.parent;for(var n=t;null!==e&&n===e.right;)n=e,e=e.parent;return e},rt.prototype.size=function(){return this.size_},rt.prototype.containsKey=function(t){for(var e=this.root_;null!==e;){var n=t.compareTo(e.key);if(n<0)e=e.left;else{if(!(n>0))return!0;e=e.right}}return!1};class ot{constructor(){ot.constructor_.apply(this,arguments)}getClass(){return ot}get interfaces_(){return[]}}function lt(){}function at(){this.array_=[],arguments[0]instanceof f&&this.addAll(arguments[0])}ot.constructor_=function(){},lt.prototype=new Q,at.prototype=new lt,at.prototype.contains=function(t){for(let e=0,n=this.array_.length;e<n;e++){if(0===this.array_[e].compareTo(t))return!0}return!1},at.prototype.add=function(t){if(this.contains(t))return!1;for(let e=0,n=this.array_.length;e<n;e++){if(1===this.array_[e].compareTo(t))return this.array_.splice(e,0,t),!0}return this.array_.push(t),!0},at.prototype.addAll=function(t){for(let e=t.iterator();e.hasNext();)this.add(e.next());return!0},at.prototype.remove=function(t){throw new Z},at.prototype.size=function(){return this.array_.length},at.prototype.isEmpty=function(){return 0===this.array_.length},at.prototype.toArray=function(){const t=[];for(let e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t},at.prototype.iterator=function(){return new ct(this)};const ct=function(t){this.treeSet_=t,this.position_=0};function ht(){}ct.prototype.next=function(){if(this.position_===this.treeSet_.size())throw new y;return this.treeSet_.array_[this.position_++]},ct.prototype.hasNext=function(){return this.position_<this.treeSet_.size()},ct.prototype.remove=function(){throw new Z},ht.sort=function(){const t=arguments[0];let e,n,s,i;if(1===arguments.length)i=function(t,e){return t.compareTo(e)},t.sort(i);else if(2===arguments.length)s=arguments[1],i=function(t,e){return s.compare(t,e)},t.sort(i);else if(3===arguments.length){n=t.slice(arguments[1],arguments[2]),n.sort();const s=t.slice(0,arguments[1]).concat(n,t.slice(arguments[2],t.length));for(t.splice(0,t.length),e=0;e<s.length;e++)t.push(s[e])}else if(4===arguments.length){n=t.slice(arguments[1],arguments[2]),s=arguments[3],i=function(t,e){return s.compare(t,e)},n.sort(i);const r=t.slice(0,arguments[1]).concat(n,t.slice(arguments[2],t.length));for(t.splice(0,t.length),e=0;e<r.length;e++)t.push(r[e])}},ht.asList=function(t){const e=new x;for(let n=0,s=t.length;n<s;n++)e.add(t[n]);return e};class ut{constructor(){ut.constructor_.apply(this,arguments)}static toDimensionSymbol(t){switch(t){case ut.FALSE:return ut.SYM_FALSE;case ut.TRUE:return ut.SYM_TRUE;case ut.DONTCARE:return ut.SYM_DONTCARE;case ut.P:return ut.SYM_P;case ut.L:return ut.SYM_L;case ut.A:return ut.SYM_A}throw new n("Unknown dimension value: "+t)}static toDimensionValue(t){switch(T.toUpperCase(t)){case ut.SYM_FALSE:return ut.FALSE;case ut.SYM_TRUE:return ut.TRUE;case ut.SYM_DONTCARE:return ut.DONTCARE;case ut.SYM_P:return ut.P;case ut.SYM_L:return ut.L;case ut.SYM_A:return ut.A}throw new n("Unknown dimension symbol: "+t)}getClass(){return ut}get interfaces_(){return[]}}ut.constructor_=function(){},ut.P=0,ut.L=1,ut.A=2,ut.FALSE=-1,ut.TRUE=-2,ut.DONTCARE=-3,ut.SYM_FALSE="F",ut.SYM_TRUE="T",ut.SYM_DONTCARE="*",ut.SYM_P="0",ut.SYM_L="1",ut.SYM_A="2";class gt{constructor(){gt.constructor_.apply(this,arguments)}filter(t){}getClass(){return gt}get interfaces_(){return[]}}gt.constructor_=function(){};class dt{constructor(){dt.constructor_.apply(this,arguments)}filter(t,e){}isDone(){}isGeometryChanged(){}getClass(){return dt}get interfaces_(){return[]}}dt.constructor_=function(){};class _t extends q{constructor(){super(),_t.constructor_.apply(this,arguments)}computeEnvelopeInternal(){const t=new N;for(let e=0;e<this._geometries.length;e++)t.expandToInclude(this._geometries[e].getEnvelopeInternal());return t}getGeometryN(t){return this._geometries[t]}getCoordinates(){const t=new Array(this.getNumPoints()).fill(null);let e=-1;for(let n=0;n<this._geometries.length;n++){const s=this._geometries[n].getCoordinates();for(let n=0;n<s.length;n++)e++,t[e]=s[n]}return t}getArea(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getArea();return t}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._geometries.length!==n._geometries.length)return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].equalsExact(n._geometries[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){for(let t=0;t<this._geometries.length;t++)this._geometries[t].normalize();ht.sort(this._geometries)}getCoordinate(){return this.isEmpty()?null:this._geometries[0].getCoordinate()}getBoundaryDimension(){let t=ut.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getBoundaryDimension());return t}getTypeCode(){return q.TYPECODE_GEOMETRYCOLLECTION}getDimension(){let t=ut.FALSE;for(let e=0;e<this._geometries.length;e++)t=Math.max(t,this._geometries[e].getDimension());return t}getLength(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getLength();return t}getNumPoints(){let t=0;for(let e=0;e<this._geometries.length;e++)t+=this._geometries[e].getNumPoints();return t}getNumGeometries(){return this._geometries.length}reverse(){const t=this._geometries.length,e=new Array(t).fill(null);for(let t=0;t<this._geometries.length;t++)e[t]=this._geometries[t].reverse();return this.getFactory().createGeometryCollection(e)}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=new at(ht.asList(this._geometries)),n=new at(ht.asList(t._geometries));return this.compare(e,n)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t,s=this.getNumGeometries(),i=n.getNumGeometries();let r=0;for(;r<s&&r<i;){const t=this.getGeometryN(r),s=n.getGeometryN(r),i=t.compareToSameClass(s,e);if(0!==i)return i;r++}return r<s?1:r<i?-1:0}}apply(){if(_(arguments[0],B)){const t=arguments[0];for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(_(arguments[0],dt)){const t=arguments[0];if(0===this._geometries.length)return null;for(let e=0;e<this._geometries.length&&(this._geometries[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(_(arguments[0],gt)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}else if(_(arguments[0],G)){const t=arguments[0];t.filter(this);for(let e=0;e<this._geometries.length;e++)this._geometries[e].apply(t)}}getBoundary(){return this.checkNotGeometryCollection(this),u.shouldNeverReachHere(),null}getGeometryType(){return q.TYPENAME_GEOMETRYCOLLECTION}copy(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new _t(t,this._factory)}isEmpty(){for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isEmpty())return!1;return!0}getClass(){return _t}get interfaces_(){return[]}}_t.constructor_=function(){if(this._geometries=null,0===arguments.length);else if(2===arguments.length){let t=arguments[0];const e=arguments[1];if(q.constructor_.call(this,e),null===t&&(t=[]),q.hasNullElements(t))throw new n("geometries must not contain null elements");this._geometries=t}},_t.serialVersionUID=-0x4f07bcb1f857d800;class ft extends _t{constructor(){super(),ft.constructor_.apply(this,arguments)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return this.isClosed()?ut.FALSE:0}isClosed(){if(this.isEmpty())return!1;for(let t=0;t<this._geometries.length;t++)if(!this._geometries[t].isClosed())return!1;return!0}getTypeCode(){return q.TYPECODE_MULTILINESTRING}getDimension(){return 1}reverse(){const t=this._geometries.length,e=new Array(t).fill(null);for(let n=0;n<this._geometries.length;n++)e[t-1-n]=this._geometries[n].reverse();return this.getFactory().createMultiLineString(e)}getBoundary(){return new pt(this).getBoundary()}getGeometryType(){return q.TYPENAME_MULTILINESTRING}copy(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new ft(t,this._factory)}getClass(){return ft}get interfaces_(){return[ot]}}ft.constructor_=function(){const t=arguments[0],e=arguments[1];_t.constructor_.call(this,t,e)},ft.serialVersionUID=0x7155d2ab4afa8000;class pt{constructor(){pt.constructor_.apply(this,arguments)}static getBoundary(){if(1===arguments.length){const t=arguments[0];return new pt(t).getBoundary()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return new pt(t,e).getBoundary()}}boundaryMultiLineString(t){if(this._geom.isEmpty())return this.getEmptyMultiPoint();const e=this.computeBoundaryCoordinates(t);return 1===e.length?this._geomFact.createPoint(e[0]):this._geomFact.createMultiPointFromCoords(e)}getBoundary(){return this._geom instanceof Tt?this.boundaryLineString(this._geom):this._geom instanceof ft?this.boundaryMultiLineString(this._geom):this._geom.getBoundary()}boundaryLineString(t){if(this._geom.isEmpty())return this.getEmptyMultiPoint();if(t.isClosed()){return this._bnRule.isInBoundary(2)?t.getStartPoint():this._geomFact.createMultiPoint()}return this._geomFact.createMultiPoint([t.getStartPoint(),t.getEndPoint()])}getEmptyMultiPoint(){return this._geomFact.createMultiPoint()}computeBoundaryCoordinates(t){const e=new x;this._endpointMap=new rt;for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);0!==n.getNumPoints()&&(this.addEndpoint(n.getCoordinateN(0)),this.addEndpoint(n.getCoordinateN(n.getNumPoints()-1)))}for(let t=this._endpointMap.entrySet().iterator();t.hasNext();){const n=t.next(),s=n.getValue().count;this._bnRule.isInBoundary(s)&&e.add(n.getKey())}return X.toCoordinateArray(e)}addEndpoint(t){let e=this._endpointMap.get(t);null===e&&(e=new mt,this._endpointMap.put(t,e)),e.count++}getClass(){return pt}get interfaces_(){return[]}}pt.constructor_=function(){if(this._geom=null,this._geomFact=null,this._bnRule=null,this._endpointMap=null,1===arguments.length){const t=arguments[0];pt.constructor_.call(this,t,V.MOD2_BOUNDARY_RULE)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geom=t,this._geomFact=t.getFactory(),this._bnRule=e}};class mt{constructor(){mt.constructor_.apply(this,arguments)}getClass(){return mt}get interfaces_(){return[]}}mt.constructor_=function(){this.count=null};class yt{constructor(){yt.constructor_.apply(this,arguments)}static ofLine(t){const e=t.size();if(e<=1)return 0;let n=0;const s=new g;t.getCoordinate(0,s);let i=s.x,r=s.y;for(let o=1;o<e;o++){t.getCoordinate(o,s);const e=s.x,l=s.y,a=e-i,c=l-r;n+=Math.sqrt(a*a+c*c),i=e,r=l}return n}getClass(){return yt}get interfaces_(){return[]}}function xt(){}function Et(){}function It(){}function Nt(){}function Ct(){}yt.constructor_=function(){};class St{constructor(){St.constructor_.apply(this,arguments)}static chars(t,e){const n=new Array(e).fill(null);for(let s=0;s<e;s++)n[s]=t;return new String(n)}static getStackTrace(){if(1===arguments.length){const t=arguments[0],e=new It,n=new xt(e);return t.printStackTrace(n),e.toString()}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n="";const s=new Ct(new Et(St.getStackTrace(t)));for(let t=0;t<e;t++)try{n+=s.readLine()+St.NEWLINE}catch(t){if(!(t instanceof Nt))throw t;u.shouldNeverReachHere()}return n}}static split(t,e){const n=e.length,s=new x;let i=""+t,r=i.indexOf(e);for(;r>=0;){const t=i.substring(0,r);s.add(t),i=i.substring(r+n),r=i.indexOf(e)}i.length>0&&s.add(i);const o=new Array(s.size()).fill(null);for(let t=0;t<o.length;t++)o[t]=s.get(t);return o}static toString(){if(1===arguments.length&&"number"==typeof arguments[0]){const t=arguments[0];return St.SIMPLE_ORDINATE_FORMAT.format(t)}}static spaces(t){return St.chars(" ",t)}getClass(){return St}get interfaces_(){return[]}}function wt(t){this.str=t}St.constructor_=function(){},St.NEWLINE=O.getProperty("line.separator"),St.SIMPLE_ORDINATE_FORMAT=new function(){}("0.#"),wt.prototype.append=function(t){this.str+=t},wt.prototype.setCharAt=function(t,e){this.str=this.str.substr(0,t)+e+this.str.substr(t+1)},wt.prototype.toString=function(t){return this.str};class Lt{constructor(){Lt.constructor_.apply(this,arguments)}static copyCoord(t,e,n,s){const i=Math.min(t.getDimension(),n.getDimension());for(let r=0;r<i;r++)n.setOrdinate(s,r,t.getOrdinate(e,r))}static isRing(t){const e=t.size();return 0===e||!(e<=3)&&(t.getOrdinate(0,A.X)===t.getOrdinate(e-1,A.X)&&t.getOrdinate(0,A.Y)===t.getOrdinate(e-1,A.Y))}static isEqual(t,e){const n=t.size();if(n!==e.size())return!1;const s=Math.min(t.getDimension(),e.getDimension());for(let r=0;r<n;r++)for(let n=0;n<s;n++){const s=t.getOrdinate(r,n),o=e.getOrdinate(r,n);if(t.getOrdinate(r,n)!==e.getOrdinate(r,n)&&(!i.isNaN(s)||!i.isNaN(o)))return!1}return!0}static extend(t,e,n){const s=t.create(n,e.getDimension()),i=e.size();if(Lt.copy(e,0,s,0,i),i>0)for(let t=i;t<n;t++)Lt.copy(e,i-1,s,t,1);return s}static reverse(t){const e=t.size()-1,n=Math.trunc(e/2);for(let s=0;s<=n;s++)Lt.swap(t,s,e-s)}static swap(t,e,n){if(e===n)return null;for(let s=0;s<t.getDimension();s++){const i=t.getOrdinate(e,s);t.setOrdinate(e,s,t.getOrdinate(n,s)),t.setOrdinate(n,s,i)}}static copy(t,e,n,s,i){for(let r=0;r<i;r++)Lt.copyCoord(t,e+r,n,s+r)}static toString(){if(1===arguments.length&&_(arguments[0],A)){const t=arguments[0],e=t.size();if(0===e)return"()";const n=t.getDimension(),s=new wt;s.append("(");for(let i=0;i<e;i++){i>0&&s.append(" ");for(let e=0;e<n;e++)e>0&&s.append(","),s.append(St.toString(t.getOrdinate(i,e)))}return s.append(")"),s.toString()}}static ensureValidRing(t,e){const n=e.size();return 0===n?e:n<=3?Lt.createClosedRing(t,e,4):e.getOrdinate(0,A.X)===e.getOrdinate(n-1,A.X)&&e.getOrdinate(0,A.Y)===e.getOrdinate(n-1,A.Y)?e:Lt.createClosedRing(t,e,n+1)}static createClosedRing(t,e,n){const s=t.create(n,e.getDimension()),i=e.size();Lt.copy(e,0,s,0,i);for(let t=i;t<n;t++)Lt.copy(e,0,s,t,1);return s}getClass(){return Lt}get interfaces_(){return[]}}Lt.constructor_=function(){};class Tt extends q{constructor(){super(),Tt.constructor_.apply(this,arguments)}computeEnvelopeInternal(){return this.isEmpty()?new N:this._points.expandEnvelope(new N)}isRing(){return this.isClosed()&&this.isSimple()}getCoordinates(){return this._points.toCoordinateArray()}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t;if(this._points.size()!==n._points.size())return!1;for(let t=0;t<this._points.size();t++)if(!this.equal(this._points.getCoordinate(t),n._points.getCoordinate(t),e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){for(let t=0;t<Math.trunc(this._points.size()/2);t++){const e=this._points.size()-1-t;if(!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))){if(this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e))>0){const t=this._points.copy();Lt.reverse(t),this._points=t}return null}}}getCoordinate(){return this.isEmpty()?null:this._points.getCoordinate(0)}getBoundaryDimension(){return this.isClosed()?ut.FALSE:0}isClosed(){return!this.isEmpty()&&this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))}getEndPoint(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)}getTypeCode(){return q.TYPECODE_LINESTRING}getDimension(){return 1}getLength(){return yt.ofLine(this._points)}getNumPoints(){return this._points.size()}reverse(){const t=this._points.copy();return Lt.reverse(t),this.getFactory().createLineString(t)}compareToSameClass(){if(1===arguments.length){const t=arguments[0];let e=0,n=0;for(;e<this._points.size()&&n<t._points.size();){const s=this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n));if(0!==s)return s;e++,n++}return e<this._points.size()?1:n<t._points.size()?-1:0}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._points,t._points)}}apply(){if(_(arguments[0],B)){const t=arguments[0];for(let e=0;e<this._points.size();e++)t.filter(this._points.getCoordinate(e))}else if(_(arguments[0],dt)){const t=arguments[0];if(0===this._points.size())return null;for(let e=0;e<this._points.size()&&(t.filter(this._points,e),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(_(arguments[0],gt)){arguments[0].filter(this)}else if(_(arguments[0],G)){arguments[0].filter(this)}}getBoundary(){return new pt(this).getBoundary()}isEquivalentClass(t){return t instanceof Tt}getCoordinateN(t){return this._points.getCoordinate(t)}getGeometryType(){return q.TYPENAME_LINESTRING}copy(){return new Tt(this._points.copy(),this._factory)}getCoordinateSequence(){return this._points}isEmpty(){return 0===this._points.size()}init(t){if(null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),1===t.size())throw new n("Invalid number of points in LineString (found "+t.size()+" - must be 0 or >= 2)");this._points=t}isCoordinate(t){for(let e=0;e<this._points.size();e++)if(this._points.getCoordinate(e).equals(t))return!0;return!1}getStartPoint(){return this.isEmpty()?null:this.getPointN(0)}getPointN(t){return this.getFactory().createPoint(this._points.getCoordinate(t))}getClass(){return Tt}get interfaces_(){return[ot]}}Tt.constructor_=function(){if(this._points=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];q.constructor_.call(this,e),this.init(t)}},Tt.serialVersionUID=0x2b2b51ba435c8e00;class Rt{constructor(){Rt.constructor_.apply(this,arguments)}getClass(){return Rt}get interfaces_(){return[]}}Rt.constructor_=function(){};class Pt extends q{constructor(){super(),Pt.constructor_.apply(this,arguments)}computeEnvelopeInternal(){if(this.isEmpty())return new N;const t=new N;return t.expandToInclude(this._coordinates.getX(0),this._coordinates.getY(0)),t}getCoordinates(){return this.isEmpty()?[]:[this.getCoordinate()]}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&(!(!this.isEmpty()||!t.isEmpty())||this.isEmpty()===t.isEmpty()&&this.equal(t.getCoordinate(),this.getCoordinate(),e))}return super.equalsExact.apply(this,arguments)}normalize(){}getCoordinate(){return 0!==this._coordinates.size()?this._coordinates.getCoordinate(0):null}getBoundaryDimension(){return ut.FALSE}getTypeCode(){return q.TYPECODE_POINT}getDimension(){return 0}getNumPoints(){return this.isEmpty()?0:1}reverse(){return this.copy()}getX(){if(null===this.getCoordinate())throw new IllegalStateException("getX called on empty Point");return this.getCoordinate().x}compareToSameClass(){if(1===arguments.length){const t=arguments[0];return this.getCoordinate().compareTo(t.getCoordinate())}if(2===arguments.length){const t=arguments[0];return arguments[1].compare(this._coordinates,t._coordinates)}}apply(){if(_(arguments[0],B)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this.getCoordinate())}else if(_(arguments[0],dt)){const t=arguments[0];if(this.isEmpty())return null;t.filter(this._coordinates,0),t.isGeometryChanged()&&this.geometryChanged()}else if(_(arguments[0],gt)){arguments[0].filter(this)}else if(_(arguments[0],G)){arguments[0].filter(this)}}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return q.TYPENAME_POINT}copy(){return new Pt(this._coordinates.copy(),this._factory)}getCoordinateSequence(){return this._coordinates}getY(){if(null===this.getCoordinate())throw new IllegalStateException("getY called on empty Point");return this.getCoordinate().y}isEmpty(){return 0===this._coordinates.size()}init(t){null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),u.isTrue(t.size()<=1),this._coordinates=t}isSimple(){return!0}getClass(){return Pt}get interfaces_(){return[Rt]}}Pt.constructor_=function(){this._coordinates=null;const t=arguments[0],e=arguments[1];q.constructor_.call(this,e),this.init(t)},Pt.serialVersionUID=0x44077bad161cbc00;class vt{constructor(){vt.constructor_.apply(this,arguments)}static ofRing(){if(arguments[0]instanceof Array){const t=arguments[0];return Math.abs(vt.ofRingSigned(t))}if(_(arguments[0],A)){const t=arguments[0];return Math.abs(vt.ofRingSigned(t))}}static ofRingSigned(){if(arguments[0]instanceof Array){const t=arguments[0];if(t.length<3)return 0;let e=0;const n=t[0].x;for(let s=1;s<t.length-1;s++){const i=t[s].x-n,r=t[s+1].y;e+=i*(t[s-1].y-r)}return e/2}if(_(arguments[0],A)){const t=arguments[0],e=t.size();if(e<3)return 0;const n=new g,s=new g,i=new g;t.getCoordinate(0,s),t.getCoordinate(1,i);const r=s.x;i.x-=r;let o=0;for(let l=1;l<e-1;l++)n.y=s.y,s.x=i.x,s.y=i.y,t.getCoordinate(l+1,i),i.x-=r,o+=s.x*(n.y-i.y);return o/2}}getClass(){return vt}get interfaces_(){return[]}}vt.constructor_=function(){};class Ot{constructor(){Ot.constructor_.apply(this,arguments)}getClass(){return Ot}get interfaces_(){return[]}}Ot.constructor_=function(){};class bt extends q{constructor(){super(),bt.constructor_.apply(this,arguments)}computeEnvelopeInternal(){return this._shell.getEnvelopeInternal()}getCoordinates(){if(this.isEmpty())return[];const t=new Array(this.getNumPoints()).fill(null);let e=-1;const n=this._shell.getCoordinates();for(let s=0;s<n.length;s++)e++,t[e]=n[s];for(let n=0;n<this._holes.length;n++){const s=this._holes[n].getCoordinates();for(let n=0;n<s.length;n++)e++,t[e]=s[n]}return t}getArea(){let t=0;t+=vt.ofRing(this._shell.getCoordinateSequence());for(let e=0;e<this._holes.length;e++)t-=vt.ofRing(this._holes[e].getCoordinateSequence());return t}isRectangle(){if(0!==this.getNumInteriorRing())return!1;if(null===this._shell)return!1;if(5!==this._shell.getNumPoints())return!1;const t=this._shell.getCoordinateSequence(),e=this.getEnvelopeInternal();for(let n=0;n<5;n++){const s=t.getX(n);if(s!==e.getMinX()&&s!==e.getMaxX())return!1;const i=t.getY(n);if(i!==e.getMinY()&&i!==e.getMaxY())return!1}let n=t.getX(0),s=t.getY(0);for(let e=1;e<=4;e++){const i=t.getX(e),r=t.getY(e);if(i!==n===(r!==s))return!1;n=i,s=r}return!0}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;const n=t,s=this._shell,i=n._shell;if(!s.equalsExact(i,e))return!1;if(this._holes.length!==n._holes.length)return!1;for(let t=0;t<this._holes.length;t++)if(!this._holes[t].equalsExact(n._holes[t],e))return!1;return!0}return super.equalsExact.apply(this,arguments)}normalize(){if(0===arguments.length){this.normalize(this._shell,!0);for(let t=0;t<this._holes.length;t++)this.normalize(this._holes[t],!1);ht.sort(this._holes)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(t.isEmpty())return null;const n=new Array(t.getCoordinates().length-1).fill(null);O.arraycopy(t.getCoordinates(),0,n,0,n.length);const s=X.minCoordinate(t.getCoordinates());X.scroll(n,s),O.arraycopy(n,0,t.getCoordinates(),0,n.length),t.getCoordinates()[n.length]=n[0],v.isCCW(t.getCoordinates())===e&&X.reverse(t.getCoordinates())}}getCoordinate(){return this._shell.getCoordinate()}getNumInteriorRing(){return this._holes.length}getBoundaryDimension(){return 1}getTypeCode(){return q.TYPECODE_POLYGON}getDimension(){return 2}getLength(){let t=0;t+=this._shell.getLength();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getLength();return t}getNumPoints(){let t=this._shell.getNumPoints();for(let e=0;e<this._holes.length;e++)t+=this._holes[e].getNumPoints();return t}reverse(){const t=this.copy();t._shell=this._shell.copy().reverse(),t._holes=new Array(this._holes.length).fill(null);for(let e=0;e<this._holes.length;e++)t._holes[e]=this._holes[e].copy().reverse();return t}convexHull(){return this.getExteriorRing().convexHull()}compareToSameClass(){if(1===arguments.length){const t=arguments[0],e=this._shell,n=t._shell;return e.compareToSameClass(n)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t,s=this._shell,i=n._shell,r=s.compareToSameClass(i,e);if(0!==r)return r;const o=this.getNumInteriorRing(),l=n.getNumInteriorRing();let a=0;for(;a<o&&a<l;){const t=this.getInteriorRingN(a),s=n.getInteriorRingN(a),i=t.compareToSameClass(s,e);if(0!==i)return i;a++}return a<o?1:a<l?-1:0}}apply(){if(_(arguments[0],B)){const t=arguments[0];this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}else if(_(arguments[0],dt)){const t=arguments[0];if(this._shell.apply(t),!t.isDone())for(let e=0;e<this._holes.length&&(this._holes[e].apply(t),!t.isDone());e++);t.isGeometryChanged()&&this.geometryChanged()}else if(_(arguments[0],gt)){arguments[0].filter(this)}else if(_(arguments[0],G)){const t=arguments[0];t.filter(this),this._shell.apply(t);for(let e=0;e<this._holes.length;e++)this._holes[e].apply(t)}}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new Array(this._holes.length+1).fill(null);t[0]=this._shell;for(let e=0;e<this._holes.length;e++)t[e+1]=this._holes[e];return t.length<=1?this.getFactory().createLinearRing(t[0].getCoordinateSequence()):this.getFactory().createMultiLineString(t)}getGeometryType(){return q.TYPENAME_POLYGON}copy(){const t=this._shell.copy(),e=new Array(this._holes.length).fill(null);for(let t=0;t<this._holes.length;t++)e[t]=this._holes[t].copy();return new bt(t,e,this._factory)}getExteriorRing(){return this._shell}isEmpty(){return this._shell.isEmpty()}getInteriorRingN(t){return this._holes[t]}getClass(){return bt}get interfaces_(){return[Ot]}}bt.constructor_=function(){this._shell=null,this._holes=null;let t=arguments[0],e=arguments[1];const s=arguments[2];if(q.constructor_.call(this,s),null===t&&(t=this.getFactory().createLinearRing()),null===e&&(e=[]),q.hasNullElements(e))throw new n("holes must not contain null elements");if(t.isEmpty()&&q.hasNonEmptyElements(e))throw new n("shell is empty but holes are not");this._shell=t,this._holes=e},bt.serialVersionUID=-0x307ffefd8dc97200;class Mt extends _t{constructor(){super(),Mt.constructor_.apply(this,arguments)}isValid(){return!0}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getCoordinate(){if(1===arguments.length&&Number.isInteger(arguments[0])){const t=arguments[0];return this._geometries[t].getCoordinate()}return super.getCoordinate.apply(this,arguments)}getBoundaryDimension(){return ut.FALSE}getTypeCode(){return q.TYPECODE_MULTIPOINT}getDimension(){return 0}getBoundary(){return this.getFactory().createGeometryCollection()}getGeometryType(){return q.TYPENAME_MULTIPOINT}copy(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new Mt(t,this._factory)}getClass(){return Mt}get interfaces_(){return[Rt]}}Mt.constructor_=function(){const t=arguments[0],e=arguments[1];_t.constructor_.call(this,t,e)},Mt.serialVersionUID=-0x6fb1ed4162e0fc00;class Dt extends Tt{constructor(){super(),Dt.constructor_.apply(this,arguments)}getBoundaryDimension(){return ut.FALSE}isClosed(){return!!this.isEmpty()||super.isClosed.call(this)}getTypeCode(){return q.TYPECODE_LINEARRING}reverse(){const t=this._points.copy();return Lt.reverse(t),this.getFactory().createLinearRing(t)}validateConstruction(){if(!this.isEmpty()&&!super.isClosed.call(this))throw new n("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<Dt.MINIMUM_VALID_SIZE)throw new n("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")}getGeometryType(){return q.TYPENAME_LINEARRING}copy(){return new Dt(this._points.copy(),this._factory)}getClass(){return Dt}get interfaces_(){return[]}}Dt.constructor_=function(){if(arguments[0]instanceof Array&&arguments[1]instanceof Ht){const t=arguments[0],e=arguments[1];Dt.constructor_.call(this,e.getCoordinateSequenceFactory().create(t),e)}else if(_(arguments[0],A)&&arguments[1]instanceof Ht){const t=arguments[0],e=arguments[1];Tt.constructor_.call(this,t,e),this.validateConstruction()}},Dt.MINIMUM_VALID_SIZE=4,Dt.serialVersionUID=-0x3b229e262367a600;class At extends _t{constructor(){super(),At.constructor_.apply(this,arguments)}equalsExact(){if(2===arguments.length&&"number"==typeof arguments[1]&&arguments[0]instanceof q){const t=arguments[0],e=arguments[1];return!!this.isEquivalentClass(t)&&super.equalsExact.call(this,t,e)}return super.equalsExact.apply(this,arguments)}getBoundaryDimension(){return 1}getTypeCode(){return q.TYPECODE_MULTIPOLYGON}getDimension(){return 2}reverse(){const t=this._geometries.length,e=new Array(t).fill(null);for(let t=0;t<this._geometries.length;t++)e[t]=this._geometries[t].reverse();return this.getFactory().createMultiPolygon(e)}getBoundary(){if(this.isEmpty())return this.getFactory().createMultiLineString();const t=new x;for(let e=0;e<this._geometries.length;e++){const n=this._geometries[e].getBoundary();for(let e=0;e<n.getNumGeometries();e++)t.add(n.getGeometryN(e))}const e=new Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(e))}getGeometryType(){return q.TYPENAME_MULTIPOLYGON}copy(){const t=new Array(this._geometries.length).fill(null);for(let e=0;e<t.length;e++)t[e]=this._geometries[e].copy();return new At(t,this._factory)}getClass(){return At}get interfaces_(){return[Ot]}}At.constructor_=function(){const t=arguments[0],e=arguments[1];_t.constructor_.call(this,t,e)},At.serialVersionUID=-0x7a5aa1369171980;class Ft{constructor(){Ft.constructor_.apply(this,arguments)}setCopyUserData(t){this._isUserDataCopied=t}edit(t,e){if(null===t)return null;const n=this.editInternal(t,e);return this._isUserDataCopied&&n.setUserData(t.getUserData()),n}editInternal(t,e){return null===this._factory&&(this._factory=t.getFactory()),t instanceof _t?this.editGeometryCollection(t,e):t instanceof bt?this.editPolygon(t,e):t instanceof Pt||t instanceof Tt?e.edit(t,this._factory):(u.shouldNeverReachHere("Unsupported Geometry class: "+t.getClass().getName()),null)}editGeometryCollection(t,e){const n=e.edit(t,this._factory),s=new x;for(let t=0;t<n.getNumGeometries();t++){const i=this.edit(n.getGeometryN(t),e);null===i||i.isEmpty()||s.add(i)}return n.getClass()===Mt?this._factory.createMultiPoint(s.toArray([])):n.getClass()===ft?this._factory.createMultiLineString(s.toArray([])):n.getClass()===At?this._factory.createMultiPolygon(s.toArray([])):this._factory.createGeometryCollection(s.toArray([]))}editPolygon(t,e){let n=e.edit(t,this._factory);if(null===n&&(n=this._factory.createPolygon()),n.isEmpty())return n;const s=this.edit(n.getExteriorRing(),e);if(null===s||s.isEmpty())return this._factory.createPolygon();const i=new x;for(let t=0;t<n.getNumInteriorRing();t++){const s=this.edit(n.getInteriorRingN(t),e);null===s||s.isEmpty()||i.add(s)}return this._factory.createPolygon(s,i.toArray([]))}getClass(){return Ft}get interfaces_(){return[]}}function Gt(){}Ft.GeometryEditorOperation=Gt;class qt{constructor(){qt.constructor_.apply(this,arguments)}edit(t,e){return t}getClass(){return qt}get interfaces_(){return[Gt]}}qt.constructor_=function(){};class Bt{constructor(){Bt.constructor_.apply(this,arguments)}edit(t,e){const n=this.edit(t.getCoordinates(),t);return t instanceof Dt?null===n?e.createLinearRing():e.createLinearRing(n):t instanceof Tt?null===n?e.createLineString():e.createLineString(n):t instanceof Pt?null===n||0===n.length?e.createPoint():e.createPoint(n[0]):t}getClass(){return Bt}get interfaces_(){return[Gt]}}Bt.constructor_=function(){};class Vt{constructor(){Vt.constructor_.apply(this,arguments)}edit(t,e){return t instanceof Dt?e.createLinearRing(this.edit(t.getCoordinateSequence(),t)):t instanceof Tt?e.createLineString(this.edit(t.getCoordinateSequence(),t)):t instanceof Pt?e.createPoint(this.edit(t.getCoordinateSequence(),t)):t}getClass(){return Vt}get interfaces_(){return[Gt]}}Vt.constructor_=function(){},Ft.NoOpGeometryOperation=qt,Ft.CoordinateOperation=Bt,Ft.CoordinateSequenceOperation=Vt,Ft.constructor_=function(){if(this._factory=null,this._isUserDataCopied=!1,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._factory=t}};class zt{constructor(){zt.constructor_.apply(this,arguments)}setOrdinate(t,e,s){switch(e){case A.X:this._coordinates[t].x=s;break;case A.Y:this._coordinates[t].y=s;break;case A.Z:this._coordinates[t].z=s;break;default:throw new n("invalid ordinateIndex")}}size(){return this._coordinates.length}getOrdinate(t,e){switch(e){case A.X:return this._coordinates[t].x;case A.Y:return this._coordinates[t].y;case A.Z:return this._coordinates[t].z}return i.NaN}getCoordinate(){if(1===arguments.length){const t=arguments[0];return this._coordinates[t]}if(2===arguments.length){const t=arguments[0],e=arguments[1];e.x=this._coordinates[t].x,e.y=this._coordinates[t].y,e.z=this._coordinates[t].z}}getCoordinateCopy(t){return new g(this._coordinates[t])}getDimension(){return this._dimension}getX(t){return this._coordinates[t].x}expandEnvelope(t){for(let e=0;e<this._coordinates.length;e++)t.expandToInclude(this._coordinates[e]);return t}copy(){const t=new Array(this.size()).fill(null);for(let e=0;e<this._coordinates.length;e++)t[e]=this._coordinates[e].copy();return new zt(t,this._dimension)}toString(){if(this._coordinates.length>0){const t=new wt(17*this._coordinates.length);t.append("("),t.append(this._coordinates[0]);for(let e=1;e<this._coordinates.length;e++)t.append(", "),t.append(this._coordinates[e]);return t.append(")"),t.toString()}return"()"}getY(t){return this._coordinates[t].y}toCoordinateArray(){return this._coordinates}getClass(){return zt}get interfaces_(){return[A,a]}}zt.constructor_=function(){if(this._dimension=3,this._coordinates=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];zt.constructor_.call(this,t,3)}else if(Number.isInteger(arguments[0])){const t=arguments[0];this._coordinates=new Array(t).fill(null);for(let e=0;e<t;e++)this._coordinates[e]=new g}else if(_(arguments[0],A)){const t=arguments[0];if(null===t)return this._coordinates=new Array(0).fill(null),null;this._dimension=t.getDimension(),this._coordinates=new Array(t.size()).fill(null);for(let e=0;e<this._coordinates.length;e++)this._coordinates[e]=t.getCoordinateCopy(e)}}else if(2===arguments.length)if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];this._coordinates=t,this._dimension=e,null===t&&(this._coordinates=new Array(0).fill(null))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];this._coordinates=new Array(t).fill(null),this._dimension=e;for(let e=0;e<t;e++)this._coordinates[e]=new g}},zt.serialVersionUID=-0xcb44a778db18e00;class Yt{constructor(){Yt.constructor_.apply(this,arguments)}static instance(){return Yt.instanceObject}readResolve(){return Yt.instance()}create(){if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return new zt(t)}if(_(arguments[0],A)){const t=arguments[0];return new zt(t)}}else if(2===arguments.length){const t=arguments[0];let e=arguments[1];return e>3&&(e=3),e<2?new zt(t):new zt(t,e)}}getClass(){return Yt}get interfaces_(){return[F,a]}}function Ut(){this.map_=new Map}Yt.constructor_=function(){},Yt.serialVersionUID=-0x38e49fa6cf6f2e00,Yt.instanceObject=new Yt,Ut.prototype=new j,Ut.prototype.get=function(t){return this.map_.get(t)||null},Ut.prototype.put=function(t,e){return this.map_.set(t,e),e},Ut.prototype.values=function(){const t=new x,e=this.map_.values();let n=e.next();for(;!n.done;)t.add(n.value),n=e.next();return t},Ut.prototype.entrySet=function(){const t=new J;return this.map_.entries().forEach(e=>t.add(e)),t},Ut.prototype.size=function(){return this.map_.size()};class kt{constructor(){kt.constructor_.apply(this,arguments)}static mostPrecise(t,e){return t.compareTo(e)>=0?t:e}equals(t){if(!(t instanceof kt))return!1;const e=t;return this._modelType===e._modelType&&this._scale===e._scale}compareTo(t){const e=t,n=this.getMaximumSignificantDigits(),s=e.getMaximumSignificantDigits();return new L(n).compareTo(new L(s))}getScale(){return this._scale}isFloating(){return this._modelType===kt.FLOATING||this._modelType===kt.FLOATING_SINGLE}getType(){return this._modelType}toString(){let t="UNKNOWN";return this._modelType===kt.FLOATING?t="Floating":this._modelType===kt.FLOATING_SINGLE?t="Floating-Single":this._modelType===kt.FIXED&&(t="Fixed (Scale="+this.getScale()+")"),t}makePrecise(){if("number"==typeof arguments[0]){const t=arguments[0];if(i.isNaN(t))return t;if(this._modelType===kt.FLOATING_SINGLE){return t}return this._modelType===kt.FIXED?Math.round(t*this._scale)/this._scale:t}if(arguments[0]instanceof g){const t=arguments[0];if(this._modelType===kt.FLOATING)return null;t.x=this.makePrecise(t.x),t.y=this.makePrecise(t.y)}}getMaximumSignificantDigits(){let t=16;return this._modelType===kt.FLOATING?t=16:this._modelType===kt.FLOATING_SINGLE?t=6:this._modelType===kt.FIXED&&(t=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),t}setScale(t){this._scale=Math.abs(t)}getClass(){return kt}get interfaces_(){return[a,r]}}class Xt{constructor(){Xt.constructor_.apply(this,arguments)}readResolve(){return Xt.nameToTypeMap.get(this._name)}toString(){return this._name}getClass(){return Xt}get interfaces_(){return[a]}}Xt.constructor_=function(){this._name=null;const t=arguments[0];this._name=t,Xt.nameToTypeMap.put(t,this)},Xt.serialVersionUID=-552860263173159e4,Xt.nameToTypeMap=new Ut,kt.Type=Xt,kt.constructor_=function(){if(this._modelType=null,this._scale=null,0===arguments.length)this._modelType=kt.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof Xt){const t=arguments[0];this._modelType=t,t===kt.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){const t=arguments[0];this._modelType=kt.FIXED,this.setScale(t)}else if(arguments[0]instanceof kt){const t=arguments[0];this._modelType=t._modelType,this._scale=t._scale}},kt.serialVersionUID=0x6bee6404e9a25c00,kt.FIXED=new Xt("FIXED"),kt.FLOATING=new Xt("FLOATING"),kt.FLOATING_SINGLE=new Xt("FLOATING SINGLE"),kt.maximumPreciseValue=9007199254740992;class Ht{constructor(){Ht.constructor_.apply(this,arguments)}static toMultiPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toGeometryArray(t){if(null===t)return null;const e=new Array(t.size()).fill(null);return t.toArray(e)}static getDefaultCoordinateSequenceFactory(){return Yt.instance()}static toMultiLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLineStringArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toMultiPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toLinearRingArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPointArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static toPolygonArray(t){const e=new Array(t.size()).fill(null);return t.toArray(e)}static createPointFromInternalCoord(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)}toGeometry(t){return t.isNull()?this.createPoint():t.getMinX()===t.getMaxX()&&t.getMinY()===t.getMaxY()?this.createPoint(new g(t.getMinX(),t.getMinY())):t.getMinX()===t.getMaxX()||t.getMinY()===t.getMaxY()?this.createLineString([new g(t.getMinX(),t.getMinY()),new g(t.getMaxX(),t.getMaxY())]):this.createPolygon(this.createLinearRing([new g(t.getMinX(),t.getMinY()),new g(t.getMinX(),t.getMaxY()),new g(t.getMaxX(),t.getMaxY()),new g(t.getMaxX(),t.getMinY()),new g(t.getMinX(),t.getMinY())]),null)}createLineString(){if(0===arguments.length)return this.createLineString(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLineString(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(_(arguments[0],A)){const t=arguments[0];return new Tt(t,this)}}}createMultiLineString(){if(0===arguments.length)return new ft(null,this);if(1===arguments.length){const t=arguments[0];return new ft(t,this)}}buildGeometry(t){let e=null,n=!1,s=!1;for(let i=t.iterator();i.hasNext();){const t=i.next(),r=t.getClass();null===e&&(e=r),r!==e&&(n=!0),t instanceof _t&&(s=!0)}if(null===e)return this.createGeometryCollection();if(n||s)return this.createGeometryCollection(Ht.toGeometryArray(t));const i=t.iterator().next();if(t.size()>1){if(i instanceof bt)return this.createMultiPolygon(Ht.toPolygonArray(t));if(i instanceof Tt)return this.createMultiLineString(Ht.toLineStringArray(t));if(i instanceof Pt)return this.createMultiPoint(Ht.toPointArray(t));u.shouldNeverReachHere("Unhandled class: "+i.getClass().getName())}return i}createMultiPointFromCoords(t){return this.createMultiPoint(null!==t?this.getCoordinateSequenceFactory().create(t):null)}createPoint(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof g){const t=arguments[0];return this.createPoint(null!==t?this.getCoordinateSequenceFactory().create([t]):null)}if(_(arguments[0],A)){const t=arguments[0];return new Pt(t,this)}}}getCoordinateSequenceFactory(){return this._coordinateSequenceFactory}createPolygon(){if(0===arguments.length)return this.createPolygon(null,null);if(1===arguments.length){if(_(arguments[0],A)){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Array){const t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Dt){const t=arguments[0];return this.createPolygon(t,null)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return new bt(t,e,this)}}getSRID(){return this._SRID}createGeometryCollection(){if(0===arguments.length)return new _t(null,this);if(1===arguments.length){const t=arguments[0];return new _t(t,this)}}createGeometry(t){return new Ft(this).edit(t,new Wt(this._coordinateSequenceFactory))}getPrecisionModel(){return this._precisionModel}createLinearRing(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return this.createLinearRing(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(_(arguments[0],A)){const t=arguments[0];return new Dt(t,this)}}}createMultiPolygon(){if(0===arguments.length)return new At(null,this);if(1===arguments.length){const t=arguments[0];return new At(t,this)}}createMultiPoint(){if(0===arguments.length)return new Mt(null,this);if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];return new Mt(t,this)}if(_(arguments[0],A)){const t=arguments[0];if(null===t)return this.createMultiPoint(new Array(0).fill(null));const e=new Array(t.size()).fill(null);for(let n=0;n<t.size();n++){const s=this.getCoordinateSequenceFactory().create(1,t.getDimension());Lt.copy(t,n,s,0,1),e[n]=this.createPoint(s)}return this.createMultiPoint(e)}}}getClass(){return Ht}get interfaces_(){return[a]}}class Wt extends Ft.CoordinateSequenceOperation{constructor(){super(),Wt.constructor_.apply(this,arguments)}edit(){if(2===arguments.length&&arguments[1]instanceof q&&_(arguments[0],A)){const t=arguments[0];return this.coordinateSequenceFactory.create(t)}return super.edit.apply(this,arguments)}getClass(){return Wt}get interfaces_(){return[]}}Wt.constructor_=function(){this.coordinateSequenceFactory=null;const t=arguments[0];this.coordinateSequenceFactory=t},Ht.CloneOp=Wt,Ht.constructor_=function(){if(this._precisionModel=null,this._coordinateSequenceFactory=null,this._SRID=null,0===arguments.length)Ht.constructor_.call(this,new kt,0);else if(1===arguments.length){if(_(arguments[0],F)){const t=arguments[0];Ht.constructor_.call(this,new kt,0,t)}else if(arguments[0]instanceof kt){const t=arguments[0];Ht.constructor_.call(this,t,0,Ht.getDefaultCoordinateSequenceFactory())}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Ht.constructor_.call(this,t,e,Ht.getDefaultCoordinateSequenceFactory())}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._precisionModel=t,this._coordinateSequenceFactory=n,this._SRID=e}},Ht.serialVersionUID=-0x5ea75f2051eeb400;const jt={typeStr:/^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,emptyTypeStr:/^\s*(\w+)\s*EMPTY\s*$/,spaces:/\s+/,parenComma:/\)\s*,\s*\(/,doubleParenComma:/\)\s*\)\s*,\s*\(\s*\(/,trimParens:/^\s*\(?(.*?)\)?\s*$/};class Kt{constructor(t){this.geometryFactory=t||new Ht,this.precisionModel=this.geometryFactory.getPrecisionModel()}read(t){var e,n,s;t=t.replace(/[\n\r]/g," ");var i=jt.typeStr.exec(t);if(-1!==t.search("EMPTY")&&((i=jt.emptyTypeStr.exec(t))[2]=void 0),i&&(n=i[1].toLowerCase(),s=i[2],Qt[n]&&(e=Qt[n].call(this,s))),void 0===e)throw new Error("Could not parse WKT "+t);return e}write(t){return this.extractGeometry(t)}extractGeometry(t){var e=t.getGeometryType().toLowerCase();if(!Zt[e])return null;var n=e.toUpperCase();return t.isEmpty()?n+" EMPTY":n+"("+Zt[e].call(this,t)+")"}}const Zt={coordinate(t){return this.precisionModel.makePrecise(t),t.x+" "+t.y},point(t){return Zt.coordinate.call(this,t._coordinates._coordinates[0])},multipoint(t){var e=[];for(let n=0,s=t._geometries.length;n<s;++n)e.push("("+Zt.point.call(this,t._geometries[n])+")");return e.join(",")},linestring(t){var e=[];for(let n=0,s=t._points._coordinates.length;n<s;++n)e.push(Zt.coordinate.call(this,t._points._coordinates[n]));return e.join(",")},linearring(t){var e=[];for(let n=0,s=t._points._coordinates.length;n<s;++n)e.push(Zt.coordinate.call(this,t._points._coordinates[n]));return e.join(",")},multilinestring(t){var e=[];for(let n=0,s=t._geometries.length;n<s;++n)e.push("("+Zt.linestring.call(this,t._geometries[n])+")");return e.join(",")},polygon(t){var e=[];e.push("("+Zt.linestring.call(this,t._shell)+")");for(let n=0,s=t._holes.length;n<s;++n)e.push("("+Zt.linestring.call(this,t._holes[n])+")");return e.join(",")},multipolygon(t){var e=[];for(let n=0,s=t._geometries.length;n<s;++n)e.push("("+Zt.polygon.call(this,t._geometries[n])+")");return e.join(",")},geometrycollection(t){var e=[];for(let n=0,s=t._geometries.length;n<s;++n)e.push(this.extractGeometry(t._geometries[n]));return e.join(",")}},Qt={coord(t){var e=t.trim().split(jt.spaces),n=new g(Number.parseFloat(e[0]),Number.parseFloat(e[1]));return this.precisionModel.makePrecise(n),n},point(t){return void 0===t?this.geometryFactory.createPoint():this.geometryFactory.createPoint(Qt.coord.call(this,t))},multipoint(t){if(void 0===t)return this.geometryFactory.createMultiPoint();var e,n=t.trim().split(","),s=[];for(let t=0,i=n.length;t<i;++t)e=n[t].replace(jt.trimParens,"$1"),s.push(Qt.point.call(this,e));return this.geometryFactory.createMultiPoint(s)},linestring(t){if(void 0===t)return this.geometryFactory.createLineString();var e=t.trim().split(","),n=[];for(let t=0,s=e.length;t<s;++t)n.push(Qt.coord.call(this,e[t]));return this.geometryFactory.createLineString(n)},linearring(t){if(void 0===t)return this.geometryFactory.createLinearRing();var e=t.trim().split(","),n=[];for(let t=0,s=e.length;t<s;++t)n.push(Qt.coord.call(this,e[t]));return this.geometryFactory.createLinearRing(n)},multilinestring(t){if(void 0===t)return this.geometryFactory.createMultiLineString();var e,n=t.trim().split(jt.parenComma),s=[];for(let t=0,i=n.length;t<i;++t)e=n[t].replace(jt.trimParens,"$1"),s.push(Qt.linestring.call(this,e));return this.geometryFactory.createMultiLineString(s)},polygon(t){if(void 0===t)return this.geometryFactory.createPolygon();var e,n,s,i,r=t.trim().split(jt.parenComma),o=[];for(let t=0,l=r.length;t<l;++t)e=r[t].replace(jt.trimParens,"$1"),n=Qt.linestring.call(this,e),s=this.geometryFactory.createLinearRing(n._points),0===t?i=s:o.push(s);return this.geometryFactory.createPolygon(i,o)},multipolygon(t){if(void 0===t)return this.geometryFactory.createMultiPolygon();var e,n=t.trim().split(jt.doubleParenComma),s=[];for(let t=0,i=n.length;t<i;++t)e=n[t].replace(jt.trimParens,"$1"),s.push(Qt.polygon.call(this,e));return this.geometryFactory.createMultiPolygon(s)},geometrycollection(t){if(void 0===t)return this.geometryFactory.createGeometryCollection();var e=(t=t.replace(/,\s*([A-Za-z])/g,"|$1")).trim().split("|"),n=[];for(let t=0,s=e.length;t<s;++t)n.push(this.read(e[t]));return this.geometryFactory.createGeometryCollection(n)}};class Jt{constructor(t){this.parser=new Kt(t)}write(t){return this.parser.write(t)}static toLineString(t,e){if(2!==arguments.length)throw new Error("Not implemented");return"LINESTRING ( "+t.x+" "+t.y+", "+e.x+" "+e.y+" )"}}class $t{constructor(){$t.constructor_.apply(this,arguments)}static computeEdgeDistance(t,e,n){const s=Math.abs(n.x-e.x),i=Math.abs(n.y-e.y);let r=-1;if(t.equals(e))r=0;else if(t.equals(n))r=s>i?s:i;else{const n=Math.abs(t.x-e.x),o=Math.abs(t.y-e.y);r=s>i?n:o,0!==r||t.equals(e)||(r=Math.max(n,o))}return u.isTrue(!(0===r&&!t.equals(e)),"Bad distance calculation"),r}static nonRobustComputeEdgeDistance(t,e,n){const s=t.x-e.x,i=t.y-e.y,r=Math.sqrt(s*s+i*i);return u.isTrue(!(0===r&&!t.equals(e)),"Invalid distance calculation"),r}getIndexAlongSegment(t,e){return this.computeIntLineIndex(),this._intLineIndex[t][e]}getTopologySummary(){const t=new wt;return this.isEndPoint()&&t.append(" endpoint"),this._isProper&&t.append(" proper"),this.isCollinear()&&t.append(" collinear"),t.toString()}computeIntersection(t,e,n,s){this._inputLines[0][0]=t,this._inputLines[0][1]=e,this._inputLines[1][0]=n,this._inputLines[1][1]=s,this._result=this.computeIntersect(t,e,n,s)}getIntersectionNum(){return this._result}computeIntLineIndex(){if(0===arguments.length)null===this._intLineIndex&&(this._intLineIndex=Array(2).fill().map(()=>Array(2)),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1===arguments.length){const t=arguments[0];this.getEdgeDistance(t,0)>this.getEdgeDistance(t,1)?(this._intLineIndex[t][0]=0,this._intLineIndex[t][1]=1):(this._intLineIndex[t][0]=1,this._intLineIndex[t][1]=0)}}isProper(){return this.hasIntersection()&&this._isProper}setPrecisionModel(t){this._precisionModel=t}isInteriorIntersection(){if(0===arguments.length)return!!this.isInteriorIntersection(0)||!!this.isInteriorIntersection(1);if(1===arguments.length){const t=arguments[0];for(let e=0;e<this._result;e++)if(!this._intPt[e].equals2D(this._inputLines[t][0])&&!this._intPt[e].equals2D(this._inputLines[t][1]))return!0;return!1}}getIntersection(t){return this._intPt[t]}isEndPoint(){return this.hasIntersection()&&!this._isProper}hasIntersection(){return this._result!==$t.NO_INTERSECTION}getEdgeDistance(t,e){return $t.computeEdgeDistance(this._intPt[e],this._inputLines[t][0],this._inputLines[t][1])}isCollinear(){return this._result===$t.COLLINEAR_INTERSECTION}toString(){return Jt.toLineString(this._inputLines[0][0],this._inputLines[0][1])+" - "+Jt.toLineString(this._inputLines[1][0],this._inputLines[1][1])+this.getTopologySummary()}getEndpoint(t,e){return this._inputLines[t][e]}isIntersection(t){for(let e=0;e<this._result;e++)if(this._intPt[e].equals2D(t))return!0;return!1}getIntersectionAlongSegment(t,e){return this.computeIntLineIndex(),this._intPt[this._intLineIndex[t][e]]}getClass(){return $t}get interfaces_(){return[]}}$t.constructor_=function(){this._result=null,this._inputLines=Array(2).fill().map(()=>Array(2)),this._intPt=new Array(2).fill(null),this._intLineIndex=null,this._isProper=null,this._pa=null,this._pb=null,this._precisionModel=null,this._intPt[0]=new g,this._intPt[1]=new g,this._pa=this._intPt[0],this._pb=this._intPt[1],this._result=0},$t.DONT_INTERSECT=0,$t.DO_INTERSECT=1,$t.COLLINEAR=2,$t.NO_INTERSECTION=0,$t.POINT_INTERSECTION=1,$t.COLLINEAR_INTERSECTION=2;class te extends $t{constructor(){super(),te.constructor_.apply(this,arguments)}static nearestEndpoint(t,e,n,s){let i=t,r=D.pointToSegment(t,n,s),o=D.pointToSegment(e,n,s);return o<r&&(r=o,i=e),o=D.pointToSegment(n,t,e),o<r&&(r=o,i=n),o=D.pointToSegment(s,t,e),o<r&&(r=o,i=s),i}isInSegmentEnvelopes(t){const e=new N(this._inputLines[0][0],this._inputLines[0][1]),n=new N(this._inputLines[1][0],this._inputLines[1][1]);return e.contains(t)&&n.contains(t)}computeIntersection(){if(3!==arguments.length)return super.computeIntersection.apply(this,arguments);{const t=arguments[0],e=arguments[1],n=arguments[2];if(this._isProper=!1,N.intersects(e,n,t)&&0===v.index(e,n,t)&&0===v.index(n,e,t))return this._isProper=!0,(t.equals(e)||t.equals(n))&&(this._isProper=!1),this._result=$t.POINT_INTERSECTION,null;this._result=$t.NO_INTERSECTION}}normalizeToMinimum(t,e,n,s,i){i.x=this.smallestInAbsValue(t.x,e.x,n.x,s.x),i.y=this.smallestInAbsValue(t.y,e.y,n.y,s.y),t.x-=i.x,t.y-=i.y,e.x-=i.x,e.y-=i.y,n.x-=i.x,n.y-=i.y,s.x-=i.x,s.y-=i.y}safeHCoordinateIntersection(t,e,n,s){let i=null;try{i=b.intersection(t,e,n,s)}catch(r){if(!(r instanceof S))throw r;i=te.nearestEndpoint(t,e,n,s)}return i}intersection(t,e,n,s){let i=this.intersectionWithNormalization(t,e,n,s);return this.isInSegmentEnvelopes(i)||(i=new g(te.nearestEndpoint(t,e,n,s))),null!==this._precisionModel&&this._precisionModel.makePrecise(i),i}smallestInAbsValue(t,e,n,s){let i=t,r=Math.abs(i);return Math.abs(e)<r&&(i=e,r=Math.abs(e)),Math.abs(n)<r&&(i=n,r=Math.abs(n)),Math.abs(s)<r&&(i=s),i}checkDD(t,e,n,s,i){const r=P.intersection(t,e,n,s),o=this.isInSegmentEnvelopes(r);O.out.println("DD in env = "+o+"  --------------------- "+r),i.distance(r)>1e-4&&O.out.println("Distance = "+i.distance(r))}intersectionWithNormalization(t,e,n,s){const i=new g(t),r=new g(e),o=new g(n),l=new g(s),a=new g;this.normalizeToEnvCentre(i,r,o,l,a);const c=this.safeHCoordinateIntersection(i,r,o,l);return c.x+=a.x,c.y+=a.y,c}computeCollinearIntersection(t,e,n,s){const i=N.intersects(t,e,n),r=N.intersects(t,e,s),o=N.intersects(n,s,t),l=N.intersects(n,s,e);return i&&r?(this._intPt[0]=n,this._intPt[1]=s,$t.COLLINEAR_INTERSECTION):o&&l?(this._intPt[0]=t,this._intPt[1]=e,$t.COLLINEAR_INTERSECTION):i&&o?(this._intPt[0]=n,this._intPt[1]=t,!n.equals(t)||r||l?$t.COLLINEAR_INTERSECTION:$t.POINT_INTERSECTION):i&&l?(this._intPt[0]=n,this._intPt[1]=e,!n.equals(e)||r||o?$t.COLLINEAR_INTERSECTION:$t.POINT_INTERSECTION):r&&o?(this._intPt[0]=s,this._intPt[1]=t,!s.equals(t)||i||l?$t.COLLINEAR_INTERSECTION:$t.POINT_INTERSECTION):r&&l?(this._intPt[0]=s,this._intPt[1]=e,!s.equals(e)||i||o?$t.COLLINEAR_INTERSECTION:$t.POINT_INTERSECTION):$t.NO_INTERSECTION}normalizeToEnvCentre(t,e,n,s,i){const r=t.x<e.x?t.x:e.x,o=t.y<e.y?t.y:e.y,l=t.x>e.x?t.x:e.x,a=t.y>e.y?t.y:e.y,c=n.x<s.x?n.x:s.x,h=n.y<s.y?n.y:s.y,u=n.x>s.x?n.x:s.x,g=n.y>s.y?n.y:s.y,d=((r>c?r:c)+(l<u?l:u))/2,_=((o>h?o:h)+(a<g?a:g))/2;i.x=d,i.y=_,t.x-=i.x,t.y-=i.y,e.x-=i.x,e.y-=i.y,n.x-=i.x,n.y-=i.y,s.x-=i.x,s.y-=i.y}computeIntersect(t,e,n,s){if(this._isProper=!1,!N.intersects(t,e,n,s))return $t.NO_INTERSECTION;const i=v.index(t,e,n),r=v.index(t,e,s);if(i>0&&r>0||i<0&&r<0)return $t.NO_INTERSECTION;const o=v.index(n,s,t),l=v.index(n,s,e);return o>0&&l>0||o<0&&l<0?$t.NO_INTERSECTION:0===i&&0===r&&0===o&&0===l?this.computeCollinearIntersection(t,e,n,s):(0===i||0===r||0===o||0===l?(this._isProper=!1,t.equals2D(n)||t.equals2D(s)?this._intPt[0]=t:e.equals2D(n)||e.equals2D(s)?this._intPt[0]=e:0===i?this._intPt[0]=new g(n):0===r?this._intPt[0]=new g(s):0===o?this._intPt[0]=new g(t):0===l&&(this._intPt[0]=new g(e))):(this._isProper=!0,this._intPt[0]=this.intersection(t,e,n,s)),$t.POINT_INTERSECTION)}getClass(){return te}get interfaces_(){return[]}}te.constructor_=function(){};class ee{constructor(){ee.constructor_.apply(this,arguments)}static midPoint(t,e){return new g((t.x+e.x)/2,(t.y+e.y)/2)}minX(){return Math.min(this.p0.x,this.p1.x)}orientationIndex(){if(arguments[0]instanceof ee){const t=arguments[0],e=v.index(this.p0,this.p1,t.p0),n=v.index(this.p0,this.p1,t.p1);return e>=0&&n>=0||e<=0&&n<=0?Math.max(e,n):0}if(arguments[0]instanceof g){const t=arguments[0];return v.index(this.p0,this.p1,t)}}toGeometry(t){return t.createLineString([this.p0,this.p1])}isVertical(){return this.p0.x===this.p1.x}equals(t){if(!(t instanceof ee))return!1;const e=t;return this.p0.equals(e.p0)&&this.p1.equals(e.p1)}intersection(t){const e=new te;return e.computeIntersection(this.p0,this.p1,t.p0,t.p1),e.hasIntersection()?e.getIntersection(0):null}project(){if(arguments[0]instanceof g){const t=arguments[0];if(t.equals(this.p0)||t.equals(this.p1))return new g(t);const e=this.projectionFactor(t),n=new g;return n.x=this.p0.x+e*(this.p1.x-this.p0.x),n.y=this.p0.y+e*(this.p1.y-this.p0.y),n}if(arguments[0]instanceof ee){const t=arguments[0],e=this.projectionFactor(t.p0),n=this.projectionFactor(t.p1);if(e>=1&&n>=1)return null;if(e<=0&&n<=0)return null;let s=this.project(t.p0);e<0&&(s=this.p0),e>1&&(s=this.p1);let i=this.project(t.p1);return n<0&&(i=this.p0),n>1&&(i=this.p1),new ee(s,i)}}normalize(){this.p1.compareTo(this.p0)<0&&this.reverse()}angle(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)}getCoordinate(t){return 0===t?this.p0:this.p1}distancePerpendicular(t){return D.pointToLinePerpendicular(t,this.p0,this.p1)}minY(){return Math.min(this.p0.y,this.p1.y)}midPoint(){return ee.midPoint(this.p0,this.p1)}projectionFactor(t){if(t.equals(this.p0))return 0;if(t.equals(this.p1))return 1;const e=this.p1.x-this.p0.x,n=this.p1.y-this.p0.y,s=e*e+n*n;return s<=0?i.NaN:((t.x-this.p0.x)*e+(t.y-this.p0.y)*n)/s}closestPoints(t){const e=this.intersection(t);if(null!==e)return[e,e];const n=new Array(2).fill(null);let s=i.MAX_VALUE,r=null;const o=this.closestPoint(t.p0);s=o.distance(t.p0),n[0]=o,n[1]=t.p0;const l=this.closestPoint(t.p1);r=l.distance(t.p1),r<s&&(s=r,n[0]=l,n[1]=t.p1);const a=t.closestPoint(this.p0);r=a.distance(this.p0),r<s&&(s=r,n[0]=this.p0,n[1]=a);const c=t.closestPoint(this.p1);return r=c.distance(this.p1),r<s&&(s=r,n[0]=this.p1,n[1]=c),n}closestPoint(t){const e=this.projectionFactor(t);return e>0&&e<1?this.project(t):this.p0.distance(t)<this.p1.distance(t)?this.p0:this.p1}maxX(){return Math.max(this.p0.x,this.p1.x)}getLength(){return this.p0.distance(this.p1)}compareTo(t){const e=t,n=this.p0.compareTo(e.p0);return 0!==n?n:this.p1.compareTo(e.p1)}reverse(){const t=this.p0;this.p0=this.p1,this.p1=t}equalsTopo(t){return this.p0.equals(t.p0)&&this.p1.equals(t.p1)||this.p0.equals(t.p1)&&this.p1.equals(t.p0)}lineIntersection(t){try{return b.intersection(this.p0,this.p1,t.p0,t.p1)}catch(t){if(!(t instanceof S))throw t}return null}maxY(){return Math.max(this.p0.y,this.p1.y)}pointAlongOffset(t,e){const n=this.p0.x+t*(this.p1.x-this.p0.x),s=this.p0.y+t*(this.p1.y-this.p0.y),i=this.p1.x-this.p0.x,r=this.p1.y-this.p0.y,o=Math.sqrt(i*i+r*r);let l=0,a=0;if(0!==e){if(o<=0)throw new IllegalStateException("Cannot compute offset from zero-length line segment");l=e*i/o,a=e*r/o}return new g(n-a,s+l)}setCoordinates(){if(1===arguments.length){const t=arguments[0];this.setCoordinates(t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.p0.x=t.x,this.p0.y=t.y,this.p1.x=e.x,this.p1.y=e.y}}segmentFraction(t){let e=this.projectionFactor(t);return e<0?e=0:(e>1||i.isNaN(e))&&(e=1),e}toString(){return"LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"}isHorizontal(){return this.p0.y===this.p1.y}distance(){if(arguments[0]instanceof ee){const t=arguments[0];return D.segmentToSegment(this.p0,this.p1,t.p0,t.p1)}if(arguments[0]instanceof g){const t=arguments[0];return D.pointToSegment(t,this.p0,this.p1)}}pointAlong(t){const e=new g;return e.x=this.p0.x+t*(this.p1.x-this.p0.x),e.y=this.p0.y+t*(this.p1.y-this.p0.y),e}hashCode(){let t=java.lang.Double.doubleToLongBits(this.p0.x);t^=31*java.lang.Double.doubleToLongBits(this.p0.y);const e=Math.trunc(t)^Math.trunc(t>>32);let n=java.lang.Double.doubleToLongBits(this.p1.x);return n^=31*java.lang.Double.doubleToLongBits(this.p1.y),e^(Math.trunc(n)^Math.trunc(n>>32))}getClass(){return ee}get interfaces_(){return[r,a]}}ee.constructor_=function(){if(this.p0=null,this.p1=null,0===arguments.length)ee.constructor_.call(this,new g,new g);else if(1===arguments.length){const t=arguments[0];ee.constructor_.call(this,t.p0,t.p1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.p0=t,this.p1=e}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];ee.constructor_.call(this,new g(t,e),new g(n,s))}},ee.serialVersionUID=0x2d2172135f411c00;class ne{constructor(){ne.constructor_.apply(this,arguments)}static toLocationSymbol(t){switch(t){case ne.EXTERIOR:return"e";case ne.BOUNDARY:return"b";case ne.INTERIOR:return"i";case ne.NONE:return"-"}throw new n("Unknown location value: "+t)}getClass(){return ne}get interfaces_(){return[]}}ne.constructor_=function(){},ne.INTERIOR=0,ne.BOUNDARY=1,ne.EXTERIOR=2,ne.NONE=-1;class se{constructor(){se.constructor_.apply(this,arguments)}static matches(){if(Number.isInteger(arguments[0])&&"string"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return e===ut.SYM_DONTCARE||(e===ut.SYM_TRUE&&(t>=0||t===ut.TRUE)||(e===ut.SYM_FALSE&&t===ut.FALSE||(e===ut.SYM_P&&t===ut.P||(e===ut.SYM_L&&t===ut.L||e===ut.SYM_A&&t===ut.A))))}if("string"==typeof arguments[0]&&"string"==typeof arguments[1]){const t=arguments[0],e=arguments[1];return new se(t).matches(e)}}static isTrue(t){return t>=0||t===ut.TRUE}isIntersects(){return!this.isDisjoint()}isCovers(){return(se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])||se.isTrue(this._matrix[ne.INTERIOR][ne.BOUNDARY])||se.isTrue(this._matrix[ne.BOUNDARY][ne.INTERIOR])||se.isTrue(this._matrix[ne.BOUNDARY][ne.BOUNDARY]))&&this._matrix[ne.EXTERIOR][ne.INTERIOR]===ut.FALSE&&this._matrix[ne.EXTERIOR][ne.BOUNDARY]===ut.FALSE}isCoveredBy(){return(se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])||se.isTrue(this._matrix[ne.INTERIOR][ne.BOUNDARY])||se.isTrue(this._matrix[ne.BOUNDARY][ne.INTERIOR])||se.isTrue(this._matrix[ne.BOUNDARY][ne.BOUNDARY]))&&this._matrix[ne.INTERIOR][ne.EXTERIOR]===ut.FALSE&&this._matrix[ne.BOUNDARY][ne.EXTERIOR]===ut.FALSE}set(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<t.length;e++){const n=Math.trunc(e/3),s=e%3;this._matrix[n][s]=ut.toDimensionValue(t.charAt(e))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._matrix[t][e]=n}}isContains(){return se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])&&this._matrix[ne.EXTERIOR][ne.INTERIOR]===ut.FALSE&&this._matrix[ne.EXTERIOR][ne.BOUNDARY]===ut.FALSE}setAtLeast(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<t.length;e++){const n=Math.trunc(e/3),s=e%3;this.setAtLeast(n,s,ut.toDimensionValue(t.charAt(e)))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._matrix[t][e]<n&&(this._matrix[t][e]=n)}}setAtLeastIfValid(t,e,n){t>=0&&e>=0&&this.setAtLeast(t,e,n)}isWithin(){return se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])&&this._matrix[ne.INTERIOR][ne.EXTERIOR]===ut.FALSE&&this._matrix[ne.BOUNDARY][ne.EXTERIOR]===ut.FALSE}isTouches(t,e){return t>e?this.isTouches(e,t):(t===ut.A&&e===ut.A||t===ut.L&&e===ut.L||t===ut.L&&e===ut.A||t===ut.P&&e===ut.A||t===ut.P&&e===ut.L)&&(this._matrix[ne.INTERIOR][ne.INTERIOR]===ut.FALSE&&(se.isTrue(this._matrix[ne.INTERIOR][ne.BOUNDARY])||se.isTrue(this._matrix[ne.BOUNDARY][ne.INTERIOR])||se.isTrue(this._matrix[ne.BOUNDARY][ne.BOUNDARY])))}isOverlaps(t,e){return t===ut.P&&e===ut.P||t===ut.A&&e===ut.A?se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])&&se.isTrue(this._matrix[ne.INTERIOR][ne.EXTERIOR])&&se.isTrue(this._matrix[ne.EXTERIOR][ne.INTERIOR]):t===ut.L&&e===ut.L&&(1===this._matrix[ne.INTERIOR][ne.INTERIOR]&&se.isTrue(this._matrix[ne.INTERIOR][ne.EXTERIOR])&&se.isTrue(this._matrix[ne.EXTERIOR][ne.INTERIOR]))}isEquals(t,e){return t===e&&(se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])&&this._matrix[ne.INTERIOR][ne.EXTERIOR]===ut.FALSE&&this._matrix[ne.BOUNDARY][ne.EXTERIOR]===ut.FALSE&&this._matrix[ne.EXTERIOR][ne.INTERIOR]===ut.FALSE&&this._matrix[ne.EXTERIOR][ne.BOUNDARY]===ut.FALSE)}toString(){const t=new wt("123456789");for(let e=0;e<3;e++)for(let n=0;n<3;n++)t.setCharAt(3*e+n,ut.toDimensionSymbol(this._matrix[e][n]));return t.toString()}setAll(t){for(let e=0;e<3;e++)for(let n=0;n<3;n++)this._matrix[e][n]=t}get(t,e){return this._matrix[t][e]}transpose(){let t=this._matrix[1][0];return this._matrix[1][0]=this._matrix[0][1],this._matrix[0][1]=t,t=this._matrix[2][0],this._matrix[2][0]=this._matrix[0][2],this._matrix[0][2]=t,t=this._matrix[2][1],this._matrix[2][1]=this._matrix[1][2],this._matrix[1][2]=t,this}matches(t){if(9!==t.length)throw new n("Should be length 9: "+t);for(let e=0;e<3;e++)for(let n=0;n<3;n++)if(!se.matches(this._matrix[e][n],t.charAt(3*e+n)))return!1;return!0}add(t){for(let e=0;e<3;e++)for(let n=0;n<3;n++)this.setAtLeast(e,n,t.get(e,n))}isDisjoint(){return this._matrix[ne.INTERIOR][ne.INTERIOR]===ut.FALSE&&this._matrix[ne.INTERIOR][ne.BOUNDARY]===ut.FALSE&&this._matrix[ne.BOUNDARY][ne.INTERIOR]===ut.FALSE&&this._matrix[ne.BOUNDARY][ne.BOUNDARY]===ut.FALSE}isCrosses(t,e){return t===ut.P&&e===ut.L||t===ut.P&&e===ut.A||t===ut.L&&e===ut.A?se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])&&se.isTrue(this._matrix[ne.INTERIOR][ne.EXTERIOR]):t===ut.L&&e===ut.P||t===ut.A&&e===ut.P||t===ut.A&&e===ut.L?se.isTrue(this._matrix[ne.INTERIOR][ne.INTERIOR])&&se.isTrue(this._matrix[ne.EXTERIOR][ne.INTERIOR]):t===ut.L&&e===ut.L&&0===this._matrix[ne.INTERIOR][ne.INTERIOR]}getClass(){return se}get interfaces_(){return[o]}}se.constructor_=function(){if(this._matrix=null,0===arguments.length)this._matrix=Array(3).fill().map(()=>Array(3)),this.setAll(ut.FALSE);else if(1===arguments.length)if("string"==typeof arguments[0]){const t=arguments[0];se.constructor_.call(this),this.set(t)}else if(arguments[0]instanceof se){const t=arguments[0];se.constructor_.call(this),this._matrix[ne.INTERIOR][ne.INTERIOR]=t._matrix[ne.INTERIOR][ne.INTERIOR],this._matrix[ne.INTERIOR][ne.BOUNDARY]=t._matrix[ne.INTERIOR][ne.BOUNDARY],this._matrix[ne.INTERIOR][ne.EXTERIOR]=t._matrix[ne.INTERIOR][ne.EXTERIOR],this._matrix[ne.BOUNDARY][ne.INTERIOR]=t._matrix[ne.BOUNDARY][ne.INTERIOR],this._matrix[ne.BOUNDARY][ne.BOUNDARY]=t._matrix[ne.BOUNDARY][ne.BOUNDARY],this._matrix[ne.BOUNDARY][ne.EXTERIOR]=t._matrix[ne.BOUNDARY][ne.EXTERIOR],this._matrix[ne.EXTERIOR][ne.INTERIOR]=t._matrix[ne.EXTERIOR][ne.INTERIOR],this._matrix[ne.EXTERIOR][ne.BOUNDARY]=t._matrix[ne.EXTERIOR][ne.BOUNDARY],this._matrix[ne.EXTERIOR][ne.EXTERIOR]=t._matrix[ne.EXTERIOR][ne.EXTERIOR]}};class ie{constructor(){ie.constructor_.apply(this,arguments)}static toDegrees(t){return 180*t/Math.PI}static normalize(t){for(;t>Math.PI;)t-=ie.PI_TIMES_2;for(;t<=-Math.PI;)t+=ie.PI_TIMES_2;return t}static angle(){if(1===arguments.length){const t=arguments[0];return Math.atan2(t.y,t.x)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=e.x-t.x,s=e.y-t.y;return Math.atan2(s,n)}}static isAcute(t,e,n){const s=t.x-e.x,i=t.y-e.y;return s*(n.x-e.x)+i*(n.y-e.y)>0}static isObtuse(t,e,n){const s=t.x-e.x,i=t.y-e.y;return s*(n.x-e.x)+i*(n.y-e.y)<0}static interiorAngle(t,e,n){const s=ie.angle(e,t),i=ie.angle(e,n);return Math.abs(i-s)}static normalizePositive(t){if(t<0){for(;t<0;)t+=ie.PI_TIMES_2;t>=ie.PI_TIMES_2&&(t=0)}else{for(;t>=ie.PI_TIMES_2;)t-=ie.PI_TIMES_2;t<0&&(t=0)}return t}static angleBetween(t,e,n){const s=ie.angle(e,t),i=ie.angle(e,n);return ie.diff(s,i)}static diff(t,e){let n=null;return n=t<e?e-t:t-e,n>Math.PI&&(n=2*Math.PI-n),n}static toRadians(t){return t*Math.PI/180}static getTurn(t,e){const n=Math.sin(e-t);return n>0?ie.COUNTERCLOCKWISE:n<0?ie.CLOCKWISE:ie.NONE}static angleBetweenOriented(t,e,n){const s=ie.angle(e,t),i=ie.angle(e,n)-s;return i<=-Math.PI?i+ie.PI_TIMES_2:i>Math.PI?i-ie.PI_TIMES_2:i}getClass(){return ie}get interfaces_(){return[]}}ie.constructor_=function(){},ie.PI_TIMES_2=2*Math.PI,ie.PI_OVER_2=Math.PI/2,ie.PI_OVER_4=Math.PI/4,ie.COUNTERCLOCKWISE=v.COUNTERCLOCKWISE,ie.CLOCKWISE=v.CLOCKWISE,ie.NONE=v.COLLINEAR;class re{constructor(){re.constructor_.apply(this,arguments)}static area(t,e,n){return Math.abs(((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2)}static signedArea(t,e,n){return((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2}static det(t,e,n,s){return t*s-e*n}static interpolateZ(t,e,n,s){const i=e.x,r=e.y,o=n.x-i,l=s.x-i,a=n.y-r,c=s.y-r,h=o*c-l*a,u=t.x-i,g=t.y-r,d=(c*u-l*g)/h,_=(-a*u+o*g)/h;return e.z+d*(n.z-e.z)+_*(s.z-e.z)}static longestSideLength(t,e,n){const s=t.distance(e),i=e.distance(n),r=n.distance(t);let o=s;return i>o&&(o=i),r>o&&(o=r),o}static isAcute(t,e,n){return!!ie.isAcute(t,e,n)&&(!!ie.isAcute(e,n,t)&&!!ie.isAcute(n,t,e))}static circumcentre(t,e,n){const s=n.x,i=n.y,r=t.x-s,o=t.y-i,l=e.x-s,a=e.y-i,c=2*re.det(r,o,l,a),h=re.det(o,r*r+o*o,a,l*l+a*a),u=re.det(r,r*r+o*o,l,l*l+a*a);return new g(s-h/c,i+u/c)}static perpendicularBisector(t,e){const n=e.x-t.x,s=e.y-t.y,i=new b(t.x+n/2,t.y+s/2,1),r=new b(t.x-s+n/2,t.y+n+s/2,1);return new b(i,r)}static angleBisector(t,e,n){const s=e.distance(t),i=s/(s+e.distance(n)),r=n.x-t.x,o=n.y-t.y;return new g(t.x+i*r,t.y+i*o)}static area3D(t,e,n){const s=e.x-t.x,i=e.y-t.y,r=e.z-t.z,o=n.x-t.x,l=n.y-t.y,a=n.z-t.z,c=i*a-r*l,h=r*o-s*a,u=s*l-i*o,g=c*c+h*h+u*u;return Math.sqrt(g)/2}static centroid(t,e,n){const s=(t.x+e.x+n.x)/3,i=(t.y+e.y+n.y)/3;return new g(s,i)}static inCentre(t,e,n){const s=e.distance(n),i=t.distance(n),r=t.distance(e),o=s+i+r,l=(s*t.x+i*e.x+r*n.x)/o,a=(s*t.y+i*e.y+r*n.y)/o;return new g(l,a)}area(){return re.area(this.p0,this.p1,this.p2)}signedArea(){return re.signedArea(this.p0,this.p1,this.p2)}interpolateZ(t){if(null===t)throw new n("Supplied point is null.");return re.interpolateZ(t,this.p0,this.p1,this.p2)}longestSideLength(){return re.longestSideLength(this.p0,this.p1,this.p2)}isAcute(){return re.isAcute(this.p0,this.p1,this.p2)}circumcentre(){return re.circumcentre(this.p0,this.p1,this.p2)}area3D(){return re.area3D(this.p0,this.p1,this.p2)}centroid(){return re.centroid(this.p0,this.p1,this.p2)}inCentre(){return re.inCentre(this.p0,this.p1,this.p2)}getClass(){return re}get interfaces_(){return[]}}re.constructor_=function(){this.p0=null,this.p1=null,this.p2=null;const t=arguments[0],e=arguments[1],n=arguments[2];this.p0=t,this.p1=e,this.p2=n};class oe extends C{constructor(){super(),oe.constructor_.apply(this,arguments)}getClass(){return oe}get interfaces_(){return[]}}oe.constructor_=function(){if(0===arguments.length)C.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];C.constructor_.call(this,t)}};class le{constructor(){le.constructor_.apply(this,arguments)}static translationInstance(t,e){const n=new le;return n.setToTranslation(t,e),n}static shearInstance(t,e){const n=new le;return n.setToShear(t,e),n}static reflectionInstance(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new le;return n.setToReflection(t,e),n}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new le;return i.setToReflection(t,e,n,s),i}}static rotationInstance(){if(1===arguments.length){const t=arguments[0];return le.rotationInstance(Math.sin(t),Math.cos(t))}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new le;return n.setToRotation(t,e),n}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return le.rotationInstance(Math.sin(t),Math.cos(t),e,n)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new le;return i.setToRotation(t,e,n,s),i}}static scaleInstance(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new le;return n.setToScale(t,e),n}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new le;return i.translate(-n,-s),i.scale(t,e),i.translate(n,s),i}}setToReflectionBasic(t,e,s,i){if(t===s&&e===i)throw new n("Reflection line points must be distinct");const r=s-t,o=i-e,l=Math.sqrt(r*r+o*o),a=o/l,c=r/l,h=2*a*c,u=c*c-a*a;return this._m00=u,this._m01=h,this._m02=0,this._m10=h,this._m11=-u,this._m12=0,this}getInverse(){const t=this.getDeterminant();if(0===t)throw new oe("Transformation is non-invertible");const e=this._m11/t,n=-this._m10/t,s=-this._m01/t,i=this._m00/t,r=(this._m01*this._m12-this._m02*this._m11)/t,o=(-this._m00*this._m12+this._m10*this._m02)/t;return new le(e,s,r,n,i,o)}compose(t){const e=t._m00*this._m00+t._m01*this._m10,n=t._m00*this._m01+t._m01*this._m11,s=t._m00*this._m02+t._m01*this._m12+t._m02,i=t._m10*this._m00+t._m11*this._m10,r=t._m10*this._m01+t._m11*this._m11,o=t._m10*this._m02+t._m11*this._m12+t._m12;return this._m00=e,this._m01=n,this._m02=s,this._m10=i,this._m11=r,this._m12=o,this}equals(t){if(null===t)return!1;if(!(t instanceof le))return!1;const e=t;return this._m00===e._m00&&this._m01===e._m01&&this._m02===e._m02&&this._m10===e._m10&&this._m11===e._m11&&this._m12===e._m12}setToScale(t,e){return this._m00=t,this._m01=0,this._m02=0,this._m10=0,this._m11=e,this._m12=0,this}isIdentity(){return 1===this._m00&&0===this._m01&&0===this._m02&&0===this._m10&&1===this._m11&&0===this._m12}scale(t,e){return this.compose(le.scaleInstance(t,e)),this}setToIdentity(){return this._m00=1,this._m01=0,this._m02=0,this._m10=0,this._m11=1,this._m12=0,this}isGeometryChanged(){return!0}setTransformation(){if(1===arguments.length){const t=arguments[0];return this._m00=t._m00,this._m01=t._m01,this._m02=t._m02,this._m10=t._m10,this._m11=t._m11,this._m12=t._m12,this}if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];return this._m00=t,this._m01=e,this._m02=n,this._m10=s,this._m11=i,this._m12=r,this}}setToRotation(){if(1===arguments.length){const t=arguments[0];return this.setToRotation(Math.sin(t),Math.cos(t)),this}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._m00=e,this._m01=-t,this._m02=0,this._m10=t,this._m11=e,this._m12=0,this}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return this.setToRotation(Math.sin(t),Math.cos(t),e,n),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return this._m00=e,this._m01=-t,this._m02=n-n*e+s*t,this._m10=t,this._m11=e,this._m12=s-n*t-s*e,this}}getMatrixEntries(){return[this._m00,this._m01,this._m02,this._m10,this._m11,this._m12]}filter(t,e){this.transform(t,e)}rotate(){if(1===arguments.length){const t=arguments[0];return this.compose(le.rotationInstance(t)),this}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.compose(le.rotationInstance(t,e)),this}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return this.compose(le.rotationInstance(t,e,n)),this}if(4===arguments.length){const t=arguments[0],e=arguments[1];return this.compose(le.rotationInstance(t,e)),this}}getDeterminant(){return this._m00*this._m11-this._m01*this._m10}composeBefore(t){const e=this._m00*t._m00+this._m01*t._m10,n=this._m00*t._m01+this._m01*t._m11,s=this._m00*t._m02+this._m01*t._m12+this._m02,i=this._m10*t._m00+this._m11*t._m10,r=this._m10*t._m01+this._m11*t._m11,o=this._m10*t._m02+this._m11*t._m12+this._m12;return this._m00=e,this._m01=n,this._m02=s,this._m10=i,this._m11=r,this._m12=o,this}setToShear(t,e){return this._m00=1,this._m01=t,this._m02=0,this._m10=e,this._m11=1,this._m12=0,this}isDone(){return!1}clone(){try{return null}catch(t){if(!(t instanceof C))throw t;u.shouldNeverReachHere()}return null}translate(t,e){return this.compose(le.translationInstance(t,e)),this}setToReflection(){if(2===arguments.length){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new n("Reflection vector must be non-zero");if(t===e)return this._m00=0,this._m01=1,this._m02=0,this._m10=1,this._m11=0,this._m12=0,this;const s=Math.sqrt(t*t+e*e),i=e/s,r=t/s;return this.rotate(-i,r),this.scale(1,-1),this.rotate(i,r),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],s=arguments[2],i=arguments[3];if(t===s&&e===i)throw new n("Reflection line points must be distinct");this.setToTranslation(-t,-e);const r=s-t,o=i-e,l=Math.sqrt(r*r+o*o),a=o/l,c=r/l;return this.rotate(-a,c),this.scale(1,-1),this.rotate(a,c),this.translate(t,e),this}}toString(){return"AffineTransformation[["+this._m00+", "+this._m01+", "+this._m02+"], ["+this._m10+", "+this._m11+", "+this._m12+"]]"}setToTranslation(t,e){return this._m00=1,this._m01=0,this._m02=t,this._m10=0,this._m11=1,this._m12=e,this}shear(t,e){return this.compose(le.shearInstance(t,e)),this}transform(){if(1===arguments.length){const t=arguments[0].copy();return t.apply(this),t}if(2===arguments.length){if(arguments[0]instanceof g&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],n=this._m00*t.x+this._m01*t.y+this._m02,s=this._m10*t.x+this._m11*t.y+this._m12;return e.x=n,e.y=s,e}if(_(arguments[0],A)&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=this._m00*t.getOrdinate(e,0)+this._m01*t.getOrdinate(e,1)+this._m02,s=this._m10*t.getOrdinate(e,0)+this._m11*t.getOrdinate(e,1)+this._m12;t.setOrdinate(e,0,n),t.setOrdinate(e,1,s)}}}reflect(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.compose(le.reflectionInstance(t,e)),this}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];return this.compose(le.reflectionInstance(t,e,n,s)),this}}getClass(){return le}get interfaces_(){return[o,dt]}}le.constructor_=function(){if(this._m00=null,this._m01=null,this._m02=null,this._m10=null,this._m11=null,this._m12=null,0===arguments.length)this.setToIdentity();else if(1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];this._m00=t[0],this._m01=t[1],this._m02=t[2],this._m10=t[3],this._m11=t[4],this._m12=t[5]}else if(arguments[0]instanceof le){const t=arguments[0];this.setTransformation(t)}}else if(6===arguments.length&&"number"==typeof arguments[5]&&"number"==typeof arguments[4]&&"number"==typeof arguments[3]&&"number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];this.setTransformation(t,e,n,s,i,r)}};class ae{constructor(){ae.constructor_.apply(this,arguments)}static solve(t,e){const s=e.length;if(t.length!==s||t[0].length!==s)throw new n("Matrix A is incorrectly sized");for(let n=0;n<s;n++){let i=n;for(let e=n+1;e<s;e++)Math.abs(t[e][n])>Math.abs(t[i][n])&&(i=e);if(0===t[i][n])return null;ae.swapRows(t,n,i),ae.swapRows(e,n,i);for(let i=n+1;i<s;i++){const r=t[i][n]/t[n][n];for(let e=s-1;e>=n;e--)t[i][e]-=t[n][e]*r;e[i]-=e[n]*r}}const i=new Array(s).fill(null);for(let n=s-1;n>=0;n--){let r=0;for(let e=n+1;e<s;e++)r+=t[n][e]*i[e];i[n]=(e[n]-r)/t[n][n]}return i}static swapRows(){if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];if(e===n)return null;for(let s=0;s<t[0].length;s++){const i=t[e][s];t[e][s]=t[n][s],t[n][s]=i}}else if(Number.isInteger(arguments[2])&&arguments[0]instanceof Array&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1],n=arguments[2];if(e===n)return null;const s=t[e];t[e]=t[n],t[n]=s}}getClass(){return ae}get interfaces_(){return[]}}ae.constructor_=function(){};class ce{constructor(){ce.constructor_.apply(this,arguments)}solve(t){const e=[[this._src0.x,this._src0.y,1],[this._src1.x,this._src1.y,1],[this._src2.x,this._src2.y,1]];return ae.solve(e,t)}compute(){const t=[this._dest0.x,this._dest1.x,this._dest2.x],e=this.solve(t);if(null===e)return!1;this._m00=e[0],this._m01=e[1],this._m02=e[2];const n=[this._dest0.y,this._dest1.y,this._dest2.y],s=this.solve(n);return null!==s&&(this._m10=s[0],this._m11=s[1],this._m12=s[2],!0)}getTransformation(){return this.compute()?new le(this._m00,this._m01,this._m02,this._m10,this._m11,this._m12):null}getClass(){return ce}get interfaces_(){return[]}}ce.constructor_=function(){this._src0=null,this._src1=null,this._src2=null,this._dest0=null,this._dest1=null,this._dest2=null,this._m00=null,this._m01=null,this._m02=null,this._m10=null,this._m11=null,this._m12=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];this._src0=t,this._src1=e,this._src2=n,this._dest0=s,this._dest1=i,this._dest2=r};class he{constructor(){he.constructor_.apply(this,arguments)}static createFromBaseLines(t,e,n,s){const i=new g(t.x+s.x-n.x,t.y+s.y-n.y),r=ie.angleBetweenOriented(e,t,i),o=e.distance(t),l=s.distance(n);if(0===o)return new le;const a=l/o,c=le.translationInstance(-t.x,-t.y);return c.rotate(r),c.scale(a,a),c.translate(n.x,n.y),c}static createFromControlVectors(){if(2===arguments.length){if(arguments[0]instanceof g&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],n=e.x-t.x,s=e.y-t.y;return le.translationInstance(n,s)}if(arguments[0]instanceof Array&&arguments[1]instanceof Array){const t=arguments[0],e=arguments[1];if(t.length!==e.length)throw new n("Src and Dest arrays are not the same length");if(t.length<=0)throw new n("Too few control points");if(t.length>3)throw new n("Too many control points");return 1===t.length?he.createFromControlVectors(t[0],e[0]):2===t.length?he.createFromControlVectors(t[0],t[1],e[0],e[1]):he.createFromControlVectors(t[0],t[1],t[2],e[0],e[1],e[2])}}else{if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new g(s.x-n.x,s.y-n.y),r=ie.angleBetweenOriented(e,t,i),o=e.distance(t),l=s.distance(n);if(0===o)return null;const a=l/o,c=le.translationInstance(-t.x,-t.y);return c.rotate(r),c.scale(a,a),c.translate(n.x,n.y),c}if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];return new ce(t,e,n,s,i,r).getTransformation()}}}getClass(){return he}get interfaces_(){return[]}}he.constructor_=function(){};class ue{constructor(){ue.constructor_.apply(this,arguments)}static getCoordinates(t){const e=new x;return t.apply(new ue(e)),e}filter(t){(t instanceof Tt||t instanceof Pt)&&this._coords.add(t.getCoordinate())}getClass(){return ue}get interfaces_(){return[G]}}ue.constructor_=function(){this._coords=null;const t=arguments[0];this._coords=t};class ge{constructor(){ge.constructor_.apply(this,arguments)}static map(t,e){return new ge(e).map(t)}map(t){const e=new x;for(let n=0;n<t.getNumGeometries();n++){const s=this._mapOp.map(t.getGeometryN(n));s.isEmpty()||e.add(s)}return t.getFactory().createGeometryCollection(Ht.toGeometryArray(e))}getClass(){return ge}get interfaces_(){return[]}}ge.constructor_=function(){this._mapOp=null;const t=arguments[0];this._mapOp=t};class de{constructor(){de.constructor_.apply(this,arguments)}static combine(){if(1===arguments.length){const t=arguments[0];return new de(t).combine()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return new de(de.createList(t,e)).combine()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return new de(de.createList(t,e,n)).combine()}}static extractFactory(t){return t.isEmpty()?null:t.iterator().next().getFactory()}static createList(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new x;return n.add(t),n.add(e),n}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=new x;return s.add(t),s.add(e),s.add(n),s}}extractElements(t,e){if(null===t)return null;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);this._skipEmpty&&s.isEmpty()||e.add(s)}}combine(){const t=new x;for(let e=this._inputGeoms.iterator();e.hasNext();){const n=e.next();this.extractElements(n,t)}return 0===t.size()?null!==this._geomFactory?this._geomFactory.createGeometryCollection():null:this._geomFactory.buildGeometry(t)}getClass(){return de}get interfaces_(){return[]}}de.constructor_=function(){this._geomFactory=null,this._skipEmpty=!1,this._inputGeoms=null;const t=arguments[0];this._geomFactory=de.extractFactory(t),this._inputGeoms=t};class _e{constructor(){_e.constructor_.apply(this,arguments)}static isOfType(t,e){return t.getGeometryType()===e||e===q.TYPENAME_LINESTRING&&t.getGeometryType()===q.TYPENAME_LINEARRING}static extract(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return _e.extract(t,e,new x)}if(3===arguments.length){if(_(arguments[2],m)&&arguments[0]instanceof q&&"string"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2];return t.getGeometryType()===e?n.add(t):t instanceof _t&&t.apply(new _e(e,n)),n}if(_(arguments[2],m)&&arguments[0]instanceof q&&arguments[1]instanceof Class){const t=arguments[0],e=arguments[1],n=arguments[2];return _e.extract(t,_e.toGeometryType(e),n)}}}filter(t){(null===this._geometryType||_e.isOfType(t,this._geometryType))&&this._comps.add(t)}getClass(){return _e}get interfaces_(){return[gt]}}_e.constructor_=function(){this._geometryType=null,this._comps=null;const t=arguments[0],e=arguments[1];this._geometryType=t,this._comps=e};class fe{constructor(){fe.constructor_.apply(this,arguments)}map(t){}getClass(){return fe}get interfaces_(){return[]}}fe.constructor_=function(){};class pe{constructor(){pe.constructor_.apply(this,arguments)}static map(){if(arguments[0]instanceof q&&_(arguments[1],fe)){const t=arguments[0],e=arguments[1],n=new x;for(let s=0;s<t.getNumGeometries();s++){const i=e.map(t.getGeometryN(s));null!==i&&n.add(i)}return t.getFactory().buildGeometry(n)}if(_(arguments[0],f)&&_(arguments[1],fe)){const t=arguments[0],e=arguments[1],n=new x;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=e.map(t);null!==i&&n.add(i)}return n}}getClass(){return pe}get interfaces_(){return[]}}pe.constructor_=function(){};class me{constructor(){me.constructor_.apply(this,arguments)}transformPoint(t,e){return this._factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(),t))}transformPolygon(t,e){let n=!0;const s=this.transformLinearRing(t.getExteriorRing(),t);null!==s&&s instanceof Dt&&!s.isEmpty()||(n=!1);const i=new x;for(let e=0;e<t.getNumInteriorRing();e++){const s=this.transformLinearRing(t.getInteriorRingN(e),t);null===s||s.isEmpty()||(s instanceof Dt||(n=!1),i.add(s))}if(n)return this._factory.createPolygon(s,i.toArray([]));{const t=new x;return null!==s&&t.add(s),t.addAll(i),this._factory.buildGeometry(t)}}createCoordinateSequence(t){return this._factory.getCoordinateSequenceFactory().create(t)}getInputGeometry(){return this._inputGeom}transformMultiLineString(t,e){const n=new x;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformLineString(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}transformCoordinates(t,e){return this.copy(t)}transformLineString(t,e){return this._factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(),t))}transformMultiPoint(t,e){const n=new x;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformPoint(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}transformMultiPolygon(t,e){const n=new x;for(let e=0;e<t.getNumGeometries();e++){const s=this.transformPolygon(t.getGeometryN(e),t);null!==s&&(s.isEmpty()||n.add(s))}return this._factory.buildGeometry(n)}copy(t){return t.copy()}transformGeometryCollection(t,e){const n=new x;for(let e=0;e<t.getNumGeometries();e++){const s=this.transform(t.getGeometryN(e));null!==s&&(this._pruneEmptyGeometry&&s.isEmpty()||n.add(s))}return this._preserveGeometryCollectionType?this._factory.createGeometryCollection(Ht.toGeometryArray(n)):this._factory.buildGeometry(n)}transform(t){if(this._inputGeom=t,this._factory=t.getFactory(),t instanceof Pt)return this.transformPoint(t,null);if(t instanceof Mt)return this.transformMultiPoint(t,null);if(t instanceof Dt)return this.transformLinearRing(t,null);if(t instanceof Tt)return this.transformLineString(t,null);if(t instanceof ft)return this.transformMultiLineString(t,null);if(t instanceof bt)return this.transformPolygon(t,null);if(t instanceof At)return this.transformMultiPolygon(t,null);if(t instanceof _t)return this.transformGeometryCollection(t,null);throw new n("Unknown Geometry subtype: "+t.getClass().getName())}transformLinearRing(t,e){const n=this.transformCoordinates(t.getCoordinateSequence(),t);if(null===n)return this._factory.createLinearRing(null);const s=n.size();return s>0&&s<4&&!this._preserveType?this._factory.createLineString(n):this._factory.createLinearRing(n)}getClass(){return me}get interfaces_(){return[]}}me.constructor_=function(){this._inputGeom=null,this._factory=null,this._pruneEmptyGeometry=!0,this._preserveGeometryCollectionType=!0,this._preserveCollections=!1,this._preserveType=!1};class ye{constructor(){ye.constructor_.apply(this,arguments)}static getGeometry(t){return t.getFactory().buildGeometry(ye.getLines(t))}static getLines(){if(1===arguments.length){const t=arguments[0];return ye.getLines(t,new x)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof Tt?e.add(t):t instanceof _t&&t.apply(new ye(e)),e}}filter(t){t instanceof Tt&&this._comps.add(t)}getClass(){return ye}get interfaces_(){return[gt]}}ye.constructor_=function(){this._comps=null;const t=arguments[0];this._comps=t};class xe{constructor(){xe.constructor_.apply(this,arguments)}static getGeometry(){if(1===arguments.length){const t=arguments[0];return t.getFactory().buildGeometry(xe.getLines(t))}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t.getFactory().buildGeometry(xe.getLines(t,e))}}static getLines(){if(1===arguments.length){const t=arguments[0];return xe.getLines(t,!1)}if(2===arguments.length){if(_(arguments[0],f)&&_(arguments[1],f)){const t=arguments[0],e=arguments[1];for(let n=t.iterator();n.hasNext();){const t=n.next();xe.getLines(t,e)}return e}if(arguments[0]instanceof q&&"boolean"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=new x;return t.apply(new xe(n,e)),n}if(arguments[0]instanceof q&&_(arguments[1],f)){const t=arguments[0],e=arguments[1];return t instanceof Tt?e.add(t):t.apply(new xe(e)),e}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&_(arguments[0],f)&&_(arguments[1],f)){const t=arguments[0],e=arguments[1],n=arguments[2];for(let s=t.iterator();s.hasNext();){const t=s.next();xe.getLines(t,e,n)}return e}if("boolean"==typeof arguments[2]&&arguments[0]instanceof q&&_(arguments[1],f)){const t=arguments[0],e=arguments[1],n=arguments[2];return t.apply(new xe(e,n)),e}}}filter(t){if(this._isForcedToLineString&&t instanceof Dt){const e=t.getFactory().createLineString(t.getCoordinateSequence());return this._lines.add(e),null}t instanceof Tt&&this._lines.add(t)}setForceToLineString(t){this._isForcedToLineString=t}getClass(){return xe}get interfaces_(){return[G]}}xe.constructor_=function(){if(this._lines=null,this._isForcedToLineString=!1,1===arguments.length){const t=arguments[0];this._lines=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._lines=t,this._isForcedToLineString=e}};const Ee={reverseOrder:function(){return{compare:(t,e)=>e.compareTo(t)}},min:function(t){return Ee.sort(t),t.get(0)},sort:function(t,e){const n=t.toArray();e?ht.sort(n,e):ht.sort(n);const s=t.iterator();for(let t=0,e=n.length;t<e;t++)s.next(),s.set(n[t])},singletonList:function(t){const e=new x;return e.add(t),e}};class Ie{constructor(){Ie.constructor_.apply(this,arguments)}static getPoints(){if(1===arguments.length){const t=arguments[0];return t instanceof Pt?Ee.singletonList(t):Ie.getPoints(t,new x)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof Pt?e.add(t):t instanceof _t&&t.apply(new Ie(e)),e}}filter(t){t instanceof Pt&&this._pts.add(t)}getClass(){return Ie}get interfaces_(){return[gt]}}Ie.constructor_=function(){this._pts=null;const t=arguments[0];this._pts=t};class Ne{constructor(){Ne.constructor_.apply(this,arguments)}static getPolygons(){if(1===arguments.length){const t=arguments[0];return Ne.getPolygons(t,new x)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t instanceof bt?e.add(t):t instanceof _t&&t.apply(new Ne(e)),e}}filter(t){t instanceof bt&&this._comps.add(t)}getClass(){return Ne}get interfaces_(){return[gt]}}Ne.constructor_=function(){this._comps=null;const t=arguments[0];this._comps=t};class Ce{constructor(){Ce.constructor_.apply(this,arguments)}applyTo(t){for(let e=0;e<t.getNumGeometries()&&!this._isDone;e++){const n=t.getGeometryN(e);if(n instanceof _t)this.applyTo(n);else if(this.visit(n),this.isDone())return this._isDone=!0,null}}getClass(){return Ce}get interfaces_(){return[]}}Ce.constructor_=function(){this._isDone=!1};class Se{constructor(){Se.constructor_.apply(this,arguments)}createSupercircle(t){const e=1/t,n=this._dim.getMinSize()/2,s=this._dim.getCentre(),i=Math.pow(n,t),r=n,o=Math.pow(i/2,e),l=Math.trunc(this._nPts/8),a=new Array(8*l+1).fill(null),c=o/l;for(let n=0;n<=l;n++){let o=0,h=r;if(0!==n){o=c*n;const s=Math.pow(o,t);h=Math.pow(i-s,e)}a[n]=this.coordTrans(o,h,s),a[2*l-n]=this.coordTrans(h,o,s),a[2*l+n]=this.coordTrans(h,-o,s),a[4*l-n]=this.coordTrans(o,-h,s),a[4*l+n]=this.coordTrans(-o,-h,s),a[6*l-n]=this.coordTrans(-h,-o,s),a[6*l+n]=this.coordTrans(-h,o,s),a[8*l-n]=this.coordTrans(-o,h,s)}a[a.length-1]=new g(a[0]);const h=this._geomFact.createLinearRing(a),u=this._geomFact.createPolygon(h);return this.rotate(u)}setNumPoints(t){this._nPts=t}setBase(t){this._dim.setBase(t)}setRotation(t){this._rotationAngle=t}setWidth(t){this._dim.setWidth(t)}createEllipse(){const t=this._dim.getEnvelope(),e=t.getWidth()/2,n=t.getHeight()/2,s=t.getMinX()+e,i=t.getMinY()+n,r=new Array(this._nPts+1).fill(null);let o=0;for(let t=0;t<this._nPts;t++){const l=t*(2*Math.PI/this._nPts),a=e*Math.cos(l)+s,c=n*Math.sin(l)+i;r[o++]=this.coord(a,c)}r[o]=new g(r[0]);const l=this._geomFact.createLinearRing(r),a=this._geomFact.createPolygon(l);return this.rotate(a)}coordTrans(t,e,n){return this.coord(t+n.x,e+n.y)}createSquircle(){return this.createSupercircle(4)}setEnvelope(t){this._dim.setEnvelope(t)}setCentre(t){this._dim.setCentre(t)}createArc(t,e){const n=this._dim.getEnvelope(),s=n.getWidth()/2,i=n.getHeight()/2,r=n.getMinX()+s,o=n.getMinY()+i;let l=e;(l<=0||l>2*Math.PI)&&(l=2*Math.PI);const a=l/(this._nPts-1),c=new Array(this._nPts).fill(null);let h=0;for(let e=0;e<this._nPts;e++){const n=t+e*a,l=s*Math.cos(n)+r,u=i*Math.sin(n)+o;c[h++]=this.coord(l,u)}const u=this._geomFact.createLineString(c);return this.rotate(u)}rotate(t){if(0!==this._rotationAngle){const e=le.rotationInstance(this._rotationAngle,this._dim.getCentre().x,this._dim.getCentre().y);t.apply(e)}return t}coord(t,e){const n=new g(t,e);return this._precModel.makePrecise(n),n}createArcPolygon(t,e){const n=this._dim.getEnvelope(),s=n.getWidth()/2,i=n.getHeight()/2,r=n.getMinX()+s,o=n.getMinY()+i;let l=e;(l<=0||l>2*Math.PI)&&(l=2*Math.PI);const a=l/(this._nPts-1),c=new Array(this._nPts+2).fill(null);let h=0;c[h++]=this.coord(r,o);for(let e=0;e<this._nPts;e++){const n=t+a*e,l=s*Math.cos(n)+r,u=i*Math.sin(n)+o;c[h++]=this.coord(l,u)}c[h++]=this.coord(r,o);const u=this._geomFact.createLinearRing(c),g=this._geomFact.createPolygon(u);return this.rotate(g)}createRectangle(){let t=null,e=0,n=Math.trunc(this._nPts/4);n<1&&(n=1);const s=this._dim.getEnvelope().getWidth()/n,i=this._dim.getEnvelope().getHeight()/n,r=new Array(4*n+1).fill(null),o=this._dim.getEnvelope();for(t=0;t<n;t++){const n=o.getMinX()+t*s,i=o.getMinY();r[e++]=this.coord(n,i)}for(t=0;t<n;t++){const n=o.getMaxX(),s=o.getMinY()+t*i;r[e++]=this.coord(n,s)}for(t=0;t<n;t++){const n=o.getMaxX()-t*s,i=o.getMaxY();r[e++]=this.coord(n,i)}for(t=0;t<n;t++){const n=o.getMinX(),s=o.getMaxY()-t*i;r[e++]=this.coord(n,s)}r[e++]=new g(r[0]);const l=this._geomFact.createLinearRing(r),a=this._geomFact.createPolygon(l);return this.rotate(a)}createCircle(){return this.createEllipse()}setHeight(t){this._dim.setHeight(t)}setSize(t){this._dim.setSize(t)}getClass(){return Se}get interfaces_(){return[]}}class we{constructor(){we.constructor_.apply(this,arguments)}setBase(t){this.base=t}setWidth(t){this.width=t}getBase(){return this.base}getWidth(){return this.width}setEnvelope(t){this.width=t.getWidth(),this.height=t.getHeight(),this.base=new g(t.getMinX(),t.getMinY()),this.centre=new g(t.centre())}setCentre(t){this.centre=t}getMinSize(){return Math.min(this.width,this.height)}getEnvelope(){return null!==this.base?new N(this.base.x,this.base.x+this.width,this.base.y,this.base.y+this.height):null!==this.centre?new N(this.centre.x-this.width/2,this.centre.x+this.width/2,this.centre.y-this.height/2,this.centre.y+this.height/2):new N(0,this.width,0,this.height)}getCentre(){return null===this.centre&&(this.centre=new g(this.base.x+this.width/2,this.base.y+this.height/2)),this.centre}getHeight(){return this.height}setHeight(t){this.height=t}setSize(t){this.height=t,this.width=t}getClass(){return we}get interfaces_(){return[]}}we.constructor_=function(){this.base=null,this.centre=null,this.width=null,this.height=null},Se.Dimensions=we,Se.constructor_=function(){if(this._geomFact=null,this._precModel=null,this._dim=new we,this._nPts=100,this._rotationAngle=0,0===arguments.length)Se.constructor_.call(this,new Ht);else if(1===arguments.length){const t=arguments[0];this._geomFact=t,this._precModel=t.getPrecisionModel()}};class Le extends Se{constructor(){super(),Le.constructor_.apply(this,arguments)}setNumArms(t){this._numArms=t}setArmLengthRatio(t){this._armLengthRatio=t}createSineStar(){const t=this._dim.getEnvelope(),e=t.getWidth()/2;let n=this._armLengthRatio;n<0&&(n=0),n>1&&(n=1);const s=n*e,i=(1-n)*e,r=t.getMinX()+e,o=t.getMinY()+e,l=new Array(this._nPts+1).fill(null);let a=0;for(let t=0;t<this._nPts;t++){const e=t/this._nPts*this._numArms,n=e-Math.floor(e),c=2*Math.PI*n,h=i+s*((Math.cos(c)+1)/2),u=t*(2*Math.PI/this._nPts),g=h*Math.cos(u)+r,d=h*Math.sin(u)+o;l[a++]=this.coord(g,d)}l[a]=new g(l[0]);const c=this._geomFact.createLinearRing(l);return this._geomFact.createPolygon(c)}getClass(){return Le}get interfaces_(){return[]}}Le.constructor_=function(){if(this._numArms=8,this._armLengthRatio=.5,0===arguments.length)Se.constructor_.call(this);else if(1===arguments.length){const t=arguments[0];Se.constructor_.call(this,t)}};var Te=Object.freeze({__proto__:null,AffineTransformation:le,AffineTransformationBuilder:ce,AffineTransformationFactory:he,ComponentCoordinateExtracter:ue,GeometryCollectionMapper:ge,GeometryCombiner:de,GeometryEditor:Ft,GeometryExtracter:_e,GeometryMapper:pe,GeometryTransformer:me,LineStringExtracter:ye,LinearComponentExtracter:xe,MapOp:fe,PointExtracter:Ie,PolygonExtracter:Ne,ShortCircuitedGeometryVisitor:Ce,SineStarFactory:Le}),Re=Object.freeze({__proto__:null,Coordinate:g,CoordinateList:I,Envelope:N,LineSegment:ee,GeometryFactory:Ht,Geometry:q,Point:Pt,LineString:Tt,LinearRing:Dt,Polygon:bt,GeometryCollection:_t,MultiPoint:Mt,MultiLineString:ft,MultiPolygon:At,Dimension:ut,IntersectionMatrix:se,PrecisionModel:kt,Location:ne,Triangle:re,util:Te});class Pe{constructor(){Pe.constructor_.apply(this,arguments)}getCoordinates(){return this._pt}getCoordinate(t){return this._pt[t]}setMinimum(){if(1===arguments.length){const t=arguments[0];this.setMinimum(t._pt[0],t._pt[1])}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isNull)return this.initialize(t,e),null;const n=t.distance(e);n<this._distance&&this.initialize(t,e,n)}}initialize(){if(0===arguments.length)this._isNull=!0;else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._pt[0].setCoordinate(t),this._pt[1].setCoordinate(e),this._distance=t.distance(e),this._isNull=!1}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._pt[0].setCoordinate(t),this._pt[1].setCoordinate(e),this._distance=n,this._isNull=!1}}toString(){return Jt.toLineString(this._pt[0],this._pt[1])}getDistance(){return this._distance}setMaximum(){if(1===arguments.length){const t=arguments[0];this.setMaximum(t._pt[0],t._pt[1])}else if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this._isNull)return this.initialize(t,e),null;const n=t.distance(e);n>this._distance&&this.initialize(t,e,n)}}getClass(){return Pe}get interfaces_(){return[]}}Pe.constructor_=function(){this._pt=[new g,new g],this._distance=i.NaN,this._isNull=!0};class ve{constructor(){ve.constructor_.apply(this,arguments)}static computeDistance(){if(arguments[2]instanceof Pe&&arguments[0]instanceof Tt&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],n=arguments[2],s=new ee,i=t.getCoordinates();for(let t=0;t<i.length-1;t++){s.setCoordinates(i[t],i[t+1]);const r=s.closestPoint(e);n.setMinimum(r,e)}}else if(arguments[2]instanceof Pe&&arguments[0]instanceof bt&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],n=arguments[2];ve.computeDistance(t.getExteriorRing(),e,n);for(let s=0;s<t.getNumInteriorRing();s++)ve.computeDistance(t.getInteriorRingN(s),e,n)}else if(arguments[2]instanceof Pe&&arguments[0]instanceof q&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],n=arguments[2];if(t instanceof Tt)ve.computeDistance(t,e,n);else if(t instanceof bt)ve.computeDistance(t,e,n);else if(t instanceof _t){const s=t;for(let t=0;t<s.getNumGeometries();t++){const i=s.getGeometryN(t);ve.computeDistance(i,e,n)}}else n.setMinimum(t.getCoordinate(),e)}else if(arguments[2]instanceof Pe&&arguments[0]instanceof ee&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],n=arguments[2],s=t.closestPoint(e);n.setMinimum(s,e)}}getClass(){return ve}get interfaces_(){return[]}}ve.constructor_=function(){};class Oe{constructor(){Oe.constructor_.apply(this,arguments)}static distance(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return new Oe(t,e).distance()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=new Oe(t,e);return s.setDensifyFraction(n),s.distance()}}getCoordinates(){return this._ptDist.getCoordinates()}setDensifyFraction(t){if(t>1||t<=0)throw new n("Fraction is not in range (0.0 - 1.0]");this._densifyFrac=t}compute(t,e){this.computeOrientedDistance(t,e,this._ptDist),this.computeOrientedDistance(e,t,this._ptDist)}distance(){return this.compute(this._g0,this._g1),this._ptDist.getDistance()}computeOrientedDistance(t,e,n){const s=new be(e);if(t.apply(s),n.setMaximum(s.getMaxPointDistance()),this._densifyFrac>0){const s=new Me(e,this._densifyFrac);t.apply(s),n.setMaximum(s.getMaxPointDistance())}}orientedDistance(){return this.computeOrientedDistance(this._g0,this._g1,this._ptDist),this._ptDist.getDistance()}getClass(){return Oe}get interfaces_(){return[]}}class be{constructor(){be.constructor_.apply(this,arguments)}filter(t){this._minPtDist.initialize(),ve.computeDistance(this._geom,t,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)}getMaxPointDistance(){return this._maxPtDist}getClass(){return be}get interfaces_(){return[B]}}be.constructor_=function(){this._maxPtDist=new Pe,this._minPtDist=new Pe,this._euclideanDist=new ve,this._geom=null;const t=arguments[0];this._geom=t};class Me{constructor(){Me.constructor_.apply(this,arguments)}filter(t,e){if(0===e)return null;const n=t.getCoordinate(e-1),s=t.getCoordinate(e),i=(s.x-n.x)/this._numSubSegs,r=(s.y-n.y)/this._numSubSegs;for(let t=0;t<this._numSubSegs;t++){const e=n.x+t*i,s=n.y+t*r,o=new g(e,s);this._minPtDist.initialize(),ve.computeDistance(this._geom,o,this._minPtDist),this._maxPtDist.setMaximum(this._minPtDist)}}isDone(){return!1}isGeometryChanged(){return!1}getMaxPointDistance(){return this._maxPtDist}getClass(){return Me}get interfaces_(){return[dt]}}Me.constructor_=function(){this._maxPtDist=new Pe,this._minPtDist=new Pe,this._geom=null,this._numSubSegs=0;const t=arguments[0],e=arguments[1];this._geom=t,this._numSubSegs=Math.trunc(Math.round(1/e))},Oe.MaxPointDistanceFilter=be,Oe.MaxDensifiedByFractionDistanceFilter=Me,Oe.constructor_=function(){this._g0=null,this._g1=null,this._ptDist=new Pe,this._densifyFrac=0;const t=arguments[0],e=arguments[1];this._g0=t,this._g1=e};var De=Object.freeze({__proto__:null,DiscreteHausdorffDistance:Oe,DistanceToPoint:ve,PointPairDistance:Pe});class Ae{constructor(){Ae.constructor_.apply(this,arguments)}visitItem(t){}getClass(){return Ae}get interfaces_(){return[]}}Ae.constructor_=function(){};class Fe{constructor(){Fe.constructor_.apply(this,arguments)}locate(t){}getClass(){return Fe}get interfaces_(){return[]}}Fe.constructor_=function(){};class Ge{constructor(){Ge.constructor_.apply(this,arguments)}getMin(){return this._min}intersects(t,e){return!(this._min>e||this._max<t)}getMax(){return this._max}toString(){return Jt.toLineString(new g(this._min,0),new g(this._max,0))}getClass(){return Ge}get interfaces_(){return[]}}class qe{constructor(){qe.constructor_.apply(this,arguments)}compare(t,e){const n=t,s=e,i=(n._min+n._max)/2,r=(s._min+s._max)/2;return i<r?-1:i>r?1:0}getClass(){return qe}get interfaces_(){return[l]}}qe.constructor_=function(){},Ge.NodeComparator=qe,Ge.constructor_=function(){this._min=i.POSITIVE_INFINITY,this._max=i.NEGATIVE_INFINITY};class Be extends Ge{constructor(){super(),Be.constructor_.apply(this,arguments)}query(t,e,n){if(!this.intersects(t,e))return null;n.visitItem(this._item)}getClass(){return Be}get interfaces_(){return[]}}Be.constructor_=function(){this._item=null;const t=arguments[0],e=arguments[1],n=arguments[2];this._min=t,this._max=e,this._item=n};class Ve extends Ge{constructor(){super(),Ve.constructor_.apply(this,arguments)}buildExtent(t,e){this._min=Math.min(t._min,e._min),this._max=Math.max(t._max,e._max)}query(t,e,n){if(!this.intersects(t,e))return null;null!==this._node1&&this._node1.query(t,e,n),null!==this._node2&&this._node2.query(t,e,n)}getClass(){return Ve}get interfaces_(){return[]}}Ve.constructor_=function(){this._node1=null,this._node2=null;const t=arguments[0],e=arguments[1];this._node1=t,this._node2=e,this.buildExtent(this._node1,this._node2)};class ze{constructor(){ze.constructor_.apply(this,arguments)}buildTree(){Ee.sort(this._leaves,new Ge.NodeComparator);let t=this._leaves,e=null,n=new x;for(;;){if(this.buildLevel(t,n),1===n.size())return n.get(0);e=t,t=n,n=e}}insert(t,e,n){if(null!==this._root)throw new IllegalStateException("Index cannot be added to once it has been queried");this._leaves.add(new Be(t,e,n))}query(t,e,n){this.init(),this._root.query(t,e,n)}buildRoot(){if(null!==this._root)return null;this._root=this.buildTree()}printNode(t){O.out.println(Jt.toLineString(new g(t._min,this._level),new g(t._max,this._level)))}init(){if(null!==this._root)return null;this.buildRoot()}buildLevel(t,e){this._level++,e.clear();for(let n=0;n<t.size();n+=2){const s=t.get(n);if(null===(n+1<t.size()?t.get(n):null))e.add(s);else{const s=new Ve(t.get(n),t.get(n+1));e.add(s)}}}getClass(){return ze}get interfaces_(){return[]}}ze.constructor_=function(){this._leaves=new x,this._root=null,this._level=0};class Ye{constructor(){Ye.constructor_.apply(this,arguments)}visitItem(t){this._items.add(t)}getItems(){return this._items}getClass(){return Ye}get interfaces_(){return[Ae]}}Ye.constructor_=function(){this._items=new x};class Ue{constructor(){Ue.constructor_.apply(this,arguments)}static locatePointInRing(){if(arguments[0]instanceof g&&_(arguments[1],A)){const t=arguments[0],e=arguments[1],n=new Ue(t),s=new g,i=new g;for(let t=1;t<e.size();t++)if(e.getCoordinate(t,s),e.getCoordinate(t-1,i),n.countSegment(s,i),n.isOnSegment())return n.getLocation();return n.getLocation()}if(arguments[0]instanceof g&&arguments[1]instanceof Array){const t=arguments[0],e=arguments[1],n=new Ue(t);for(let t=1;t<e.length;t++){const s=e[t],i=e[t-1];if(n.countSegment(s,i),n.isOnSegment())return n.getLocation()}return n.getLocation()}}countSegment(t,e){if(t.x<this._p.x&&e.x<this._p.x)return null;if(this._p.x===e.x&&this._p.y===e.y)return this._isPointOnSegment=!0,null;if(t.y===this._p.y&&e.y===this._p.y){let n=t.x,s=e.x;return n>s&&(n=e.x,s=t.x),this._p.x>=n&&this._p.x<=s&&(this._isPointOnSegment=!0),null}if(t.y>this._p.y&&e.y<=this._p.y||e.y>this._p.y&&t.y<=this._p.y){let n=v.index(t,e,this._p);if(n===v.COLLINEAR)return this._isPointOnSegment=!0,null;e.y<t.y&&(n=-n),n===v.LEFT&&this._crossingCount++}}isPointInPolygon(){return this.getLocation()!==ne.EXTERIOR}getLocation(){return this._isPointOnSegment?ne.BOUNDARY:this._crossingCount%2==1?ne.INTERIOR:ne.EXTERIOR}isOnSegment(){return this._isPointOnSegment}getClass(){return Ue}get interfaces_(){return[]}}Ue.constructor_=function(){this._p=null,this._crossingCount=0,this._isPointOnSegment=!1;const t=arguments[0];this._p=t};class ke{constructor(){ke.constructor_.apply(this,arguments)}locate(t){const e=new Ue(t),n=new Xe(e);return this._index.query(t.y,t.y,n),e.getLocation()}getClass(){return ke}get interfaces_(){return[Fe]}}class Xe{constructor(){Xe.constructor_.apply(this,arguments)}visitItem(t){const e=t;this._counter.countSegment(e.getCoordinate(0),e.getCoordinate(1))}getClass(){return Xe}get interfaces_(){return[Ae]}}Xe.constructor_=function(){this._counter=null;const t=arguments[0];this._counter=t};class He{constructor(){He.constructor_.apply(this,arguments)}init(t){for(let e=xe.getLines(t).iterator();e.hasNext();){const t=e.next().getCoordinates();this.addLine(t)}}addLine(t){for(let e=1;e<t.length;e++){const n=new ee(t[e-1],t[e]),s=Math.min(n.p0.y,n.p1.y),i=Math.max(n.p0.y,n.p1.y);this._index.insert(s,i,n)}}query(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new Ye;return this._index.query(t,e,n),n.getItems()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._index.query(t,e,n)}}getClass(){return He}get interfaces_(){return[]}}He.constructor_=function(){this._index=new ze;const t=arguments[0];this.init(t)},ke.SegmentVisitor=Xe,ke.IntervalIndexedGeometry=He,ke.constructor_=function(){this._index=null;const t=arguments[0];if(!(_(t,Ot)||t instanceof Dt))throw new n("Argument must be Polygonal or LinearRing");this._index=new He(t)};class We{constructor(){We.constructor_.apply(this,arguments)}static isOnLine(){if(arguments[0]instanceof g&&_(arguments[1],A)){const t=arguments[0],e=arguments[1],n=new te,s=new g,i=new g,r=e.size();for(let o=1;o<r;o++)if(e.getCoordinate(o-1,s),e.getCoordinate(o,i),n.computeIntersection(t,s,i),n.hasIntersection())return!0;return!1}if(arguments[0]instanceof g&&arguments[1]instanceof Array){const t=arguments[0],e=arguments[1],n=new te;for(let s=1;s<e.length;s++){const i=e[s-1],r=e[s];if(n.computeIntersection(t,i,r),n.hasIntersection())return!0}return!1}}static locateInRing(t,e){return Ue.locatePointInRing(t,e)}static isInRing(t,e){return We.locateInRing(t,e)!==ne.EXTERIOR}getClass(){return We}get interfaces_(){return[]}}function je(){}We.constructor_=function(){},je.prototype.hasNext=function(){},je.prototype.next=function(){},je.prototype.remove=function(){};class Ke{constructor(){Ke.constructor_.apply(this,arguments)}static isAtomic(t){return!(t instanceof _t)}next(){if(this._atStart)return this._atStart=!1,Ke.isAtomic(this._parent)&&this._index++,this._parent;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return this._subcollectionIterator.next();this._subcollectionIterator=null}if(this._index>=this._max)throw new y;const t=this._parent.getGeometryN(this._index++);return t instanceof _t?(this._subcollectionIterator=new Ke(t),this._subcollectionIterator.next()):t}remove(){throw new Z(this.getClass().getName())}hasNext(){if(this._atStart)return!0;if(null!==this._subcollectionIterator){if(this._subcollectionIterator.hasNext())return!0;this._subcollectionIterator=null}return!(this._index>=this._max)}getClass(){return Ke}get interfaces_(){return[je]}}Ke.constructor_=function(){this._parent=null,this._atStart=null,this._max=null,this._index=null,this._subcollectionIterator=null;const t=arguments[0];this._parent=t,this._atStart=!0,this._index=0,this._max=t.getNumGeometries()};class Ze{constructor(){Ze.constructor_.apply(this,arguments)}static locatePointInPolygon(t,e){if(e.isEmpty())return ne.EXTERIOR;const n=e.getExteriorRing(),s=Ze.locatePointInRing(t,n);if(s!==ne.INTERIOR)return s;for(let n=0;n<e.getNumInteriorRing();n++){const s=e.getInteriorRingN(n),i=Ze.locatePointInRing(t,s);if(i===ne.BOUNDARY)return ne.BOUNDARY;if(i===ne.INTERIOR)return ne.EXTERIOR}return ne.INTERIOR}static locatePointInRing(t,e){return e.getEnvelopeInternal().intersects(t)?We.locateInRing(t,e.getCoordinates()):ne.EXTERIOR}static containsPointInPolygon(t,e){return ne.EXTERIOR!==Ze.locatePointInPolygon(t,e)}static locateInGeometry(t,e){if(e instanceof bt)return Ze.locatePointInPolygon(t,e);if(e instanceof _t){const n=new Ke(e);for(;n.hasNext();){const s=n.next();if(s!==e){const e=Ze.locateInGeometry(t,s);if(e!==ne.EXTERIOR)return e}}}return ne.EXTERIOR}static locate(t,e){return e.isEmpty()?ne.EXTERIOR:Ze.locateInGeometry(t,e)}locate(t){return Ze.locate(t,this._geom)}getClass(){return Ze}get interfaces_(){return[Fe]}}Ze.constructor_=function(){this._geom=null;const t=arguments[0];this._geom=t};var Qe=Object.freeze({__proto__:null,IndexedPointInAreaLocator:ke,PointOnGeometryLocator:Fe,SimplePointInAreaLocator:Ze});class Je{constructor(){Je.constructor_.apply(this,arguments)}measure(t,e){}getClass(){return Je}get interfaces_(){return[]}}Je.constructor_=function(){};class $e{constructor(){$e.constructor_.apply(this,arguments)}measure(t,e){return t.intersection(e).getArea()/t.union(e).getArea()}getClass(){return $e}get interfaces_(){return[Je]}}$e.constructor_=function(){};class tn{constructor(){tn.constructor_.apply(this,arguments)}static diagonalSize(t){if(t.isNull())return 0;const e=t.getWidth(),n=t.getHeight();return Math.sqrt(e*e+n*n)}measure(t,e){const n=Oe.distance(t,e,tn.DENSIFY_FRACTION),s=new N(t.getEnvelopeInternal());return s.expandToInclude(e.getEnvelopeInternal()),1-n/tn.diagonalSize(s)}getClass(){return tn}get interfaces_(){return[Je]}}tn.constructor_=function(){},tn.DENSIFY_FRACTION=.25;class en{constructor(){en.constructor_.apply(this,arguments)}static combine(t,e){return Math.min(t,e)}getClass(){return en}get interfaces_(){return[]}}en.constructor_=function(){};var nn=Object.freeze({__proto__:null,AreaSimilarityMeasure:$e,HausdorffSimilarityMeasure:tn,SimilarityMeasure:Je,SimilarityMeasureCombiner:en});class sn{constructor(){sn.constructor_.apply(this,arguments)}static area2(t,e,n){return(e.x-t.x)*(n.y-t.y)-(n.x-t.x)*(e.y-t.y)}static centroid3(t,e,n,s){return s.x=t.x+e.x+n.x,s.y=t.y+e.y+n.y,null}static getCentroid(t){return new sn(t).getCentroid()}setAreaBasePoint(t){this._areaBasePt=t}addPoint(t){this._ptCount+=1,this._ptCentSum.x+=t.x,this._ptCentSum.y+=t.y}addLineSegments(t){let e=0;for(let n=0;n<t.length-1;n++){const s=t[n].distance(t[n+1]);if(0===s)continue;e+=s;const i=(t[n].x+t[n+1].x)/2;this._lineCentSum.x+=s*i;const r=(t[n].y+t[n+1].y)/2;this._lineCentSum.y+=s*r}this._totalLength+=e,0===e&&t.length>0&&this.addPoint(t[0])}addHole(t){const e=v.isCCW(t);for(let n=0;n<t.length-1;n++)this.addTriangle(this._areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)}getCentroid(){const t=new g;if(Math.abs(this._areasum2)>0)t.x=this._cg3.x/3/this._areasum2,t.y=this._cg3.y/3/this._areasum2;else if(this._totalLength>0)t.x=this._lineCentSum.x/this._totalLength,t.y=this._lineCentSum.y/this._totalLength;else{if(!(this._ptCount>0))return null;t.x=this._ptCentSum.x/this._ptCount,t.y=this._ptCentSum.y/this._ptCount}return t}addShell(t){t.length>0&&this.setAreaBasePoint(t[0]);const e=!v.isCCW(t);for(let n=0;n<t.length-1;n++)this.addTriangle(this._areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)}addTriangle(t,e,n,s){const i=s?1:-1;sn.centroid3(t,e,n,this._triangleCent3);const r=sn.area2(t,e,n);this._cg3.x+=i*r*this._triangleCent3.x,this._cg3.y+=i*r*this._triangleCent3.y,this._areasum2+=i*r}add(){if(arguments[0]instanceof bt){const t=arguments[0];this.addShell(t.getExteriorRing().getCoordinates());for(let e=0;e<t.getNumInteriorRing();e++)this.addHole(t.getInteriorRingN(e).getCoordinates())}else if(arguments[0]instanceof q){const t=arguments[0];if(t.isEmpty())return null;if(t instanceof Pt)this.addPoint(t.getCoordinate());else if(t instanceof Tt)this.addLineSegments(t.getCoordinates());else if(t instanceof bt){const e=t;this.add(e)}else if(t instanceof _t){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.add(e.getGeometryN(t))}}}getClass(){return sn}get interfaces_(){return[]}}function rn(t){this.message=t||""}function on(){this.array_=[]}sn.constructor_=function(){this._areaBasePt=null,this._triangleCent3=new g,this._areasum2=0,this._cg3=new g,this._lineCentSum=new g,this._totalLength=0,this._ptCount=0,this._ptCentSum=new g;const t=arguments[0];this._areaBasePt=null,this.add(t)},rn.prototype=new Error,rn.prototype.name="EmptyStackException",on.prototype=new m,on.prototype.add=function(t){return this.array_.push(t),!0},on.prototype.get=function(t){if(t<0||t>=this.size())throw new p;return this.array_[t]},on.prototype.push=function(t){return this.array_.push(t),t},on.prototype.pop=function(t){if(0===this.array_.length)throw new rn;return this.array_.pop()},on.prototype.peek=function(){if(0===this.array_.length)throw new rn;return this.array_[this.array_.length-1]},on.prototype.empty=function(){return 0===this.array_.length},on.prototype.isEmpty=function(){return this.empty()},on.prototype.search=function(t){return this.array_.indexOf(t)},on.prototype.size=function(){return this.array_.length},on.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;e<n;e++)t.push(this.array_[e]);return t};class ln{constructor(){ln.constructor_.apply(this,arguments)}static filterCoordinates(t){const e=new ln;for(let n=0;n<t.length;n++)e.filter(t[n]);return e.getCoordinates()}filter(t){this.treeSet.contains(t)||(this.list.add(t),this.treeSet.add(t))}getCoordinates(){const t=new Array(this.list.size()).fill(null);return this.list.toArray(t)}getClass(){return ln}get interfaces_(){return[B]}}ln.constructor_=function(){this.treeSet=new at,this.list=new x};class an{constructor(){an.constructor_.apply(this,arguments)}static extractCoordinates(t){const e=new ln;return t.apply(e),e.getCoordinates()}preSort(t){let e=null;for(let n=1;n<t.length;n++)(t[n].y<t[0].y||t[n].y===t[0].y&&t[n].x<t[0].x)&&(e=t[0],t[0]=t[n],t[n]=e);return ht.sort(t,1,t.length,new cn(t[0])),t}computeOctRing(t){const e=this.computeOctPts(t),n=new I;return n.add(e,!1),n.size()<3?null:(n.closeRing(),n.toCoordinateArray())}lineOrPolygon(t){if(3===(t=this.cleanRing(t)).length)return this._geomFactory.createLineString([t[0],t[1]]);const e=this._geomFactory.createLinearRing(t);return this._geomFactory.createPolygon(e)}cleanRing(t){u.equals(t[0],t[t.length-1]);const e=new x;let n=null;for(let s=0;s<=t.length-2;s++){const i=t[s],r=t[s+1];i.equals(r)||(null!==n&&this.isBetween(n,i,r)||(e.add(i),n=i))}e.add(t[t.length-1]);const s=new Array(e.size()).fill(null);return e.toArray(s)}isBetween(t,e,n){if(0!==v.index(t,e,n))return!1;if(t.x!==n.x){if(t.x<=e.x&&e.x<=n.x)return!0;if(n.x<=e.x&&e.x<=t.x)return!0}if(t.y!==n.y){if(t.y<=e.y&&e.y<=n.y)return!0;if(n.y<=e.y&&e.y<=t.y)return!0}return!1}reduce(t){const e=this.computeOctRing(t);if(null===e)return t;const n=new at;for(let t=0;t<e.length;t++)n.add(e[t]);for(let s=0;s<t.length;s++)We.isInRing(t[s],e)||n.add(t[s]);const s=X.toCoordinateArray(n);return s.length<3?this.padArray3(s):s}getConvexHull(){if(0===this._inputPts.length)return this._geomFactory.createGeometryCollection();if(1===this._inputPts.length)return this._geomFactory.createPoint(this._inputPts[0]);if(2===this._inputPts.length)return this._geomFactory.createLineString(this._inputPts);let t=this._inputPts;this._inputPts.length>50&&(t=this.reduce(this._inputPts));const e=this.preSort(t),n=this.grahamScan(e),s=this.toCoordinateArray(n);return this.lineOrPolygon(s)}padArray3(t){const e=new Array(3).fill(null);for(let n=0;n<e.length;n++)n<t.length?e[n]=t[n]:e[n]=t[0];return e}computeOctPts(t){const e=new Array(8).fill(null);for(let n=0;n<e.length;n++)e[n]=t[0];for(let n=1;n<t.length;n++)t[n].x<e[0].x&&(e[0]=t[n]),t[n].x-t[n].y<e[1].x-e[1].y&&(e[1]=t[n]),t[n].y>e[2].y&&(e[2]=t[n]),t[n].x+t[n].y>e[3].x+e[3].y&&(e[3]=t[n]),t[n].x>e[4].x&&(e[4]=t[n]),t[n].x-t[n].y>e[5].x-e[5].y&&(e[5]=t[n]),t[n].y<e[6].y&&(e[6]=t[n]),t[n].x+t[n].y<e[7].x+e[7].y&&(e[7]=t[n]);return e}toCoordinateArray(t){const e=new Array(t.size()).fill(null);for(let n=0;n<t.size();n++){const s=t.get(n);e[n]=s}return e}grahamScan(t){let e=null;const n=new on;n.push(t[0]),n.push(t[1]),n.push(t[2]);for(let s=3;s<t.length;s++){for(e=n.pop();!n.empty()&&v.index(n.peek(),e,t[s])>0;)e=n.pop();n.push(e),n.push(t[s])}return n.push(t[0]),n}getClass(){return an}get interfaces_(){return[]}}class cn{constructor(){cn.constructor_.apply(this,arguments)}static polarCompare(t,e,n){const s=e.x-t.x,i=e.y-t.y,r=n.x-t.x,o=n.y-t.y,l=v.index(t,e,n);if(l===v.COUNTERCLOCKWISE)return 1;if(l===v.CLOCKWISE)return-1;const a=s*s+i*i,c=r*r+o*o;return a<c?-1:a>c?1:0}compare(t,e){const n=t,s=e;return cn.polarCompare(this._origin,n,s)}getClass(){return cn}get interfaces_(){return[l]}}cn.constructor_=function(){this._origin=null;const t=arguments[0];this._origin=t},an.RadialComparator=cn,an.constructor_=function(){if(this._geomFactory=null,this._inputPts=null,1===arguments.length){const t=arguments[0];an.constructor_.call(this,an.extractCoordinates(t),t.getFactory())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputPts=ln.filterCoordinates(t),this._geomFactory=e}};class hn{constructor(){hn.constructor_.apply(this,arguments)}static centre(t){return new g(hn.avg(t.getMinX(),t.getMaxX()),hn.avg(t.getMinY(),t.getMaxY()))}static avg(t,e){return(t+e)/2}addPolygon(t){if(t.isEmpty())return null;let e=null,n=null;const s=this.horizontalBisector(t);if(0===s.getLength())n=0,e=s.getCoordinate();else{const i=s.intersection(t),r=this.widestGeometry(i);n=r.getEnvelopeInternal().getWidth(),e=hn.centre(r.getEnvelopeInternal())}(null===this._interiorPoint||n>this._maxWidth)&&(this._interiorPoint=e,this._maxWidth=n)}getInteriorPoint(){return this._interiorPoint}widestGeometry(){if(arguments[0]instanceof _t){const t=arguments[0];if(t.isEmpty())return t;let e=t.getGeometryN(0);for(let n=1;n<t.getNumGeometries();n++)t.getGeometryN(n).getEnvelopeInternal().getWidth()>e.getEnvelopeInternal().getWidth()&&(e=t.getGeometryN(n));return e}if(arguments[0]instanceof q){const t=arguments[0];return t instanceof _t?this.widestGeometry(t):t}}horizontalBisector(t){const e=t.getEnvelopeInternal(),n=un.getBisectorY(t);return this._factory.createLineString([new g(e.getMinX(),n),new g(e.getMaxX(),n)])}add(t){if(t instanceof bt)this.addPolygon(t);else if(t instanceof _t){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.add(e.getGeometryN(t))}}getClass(){return hn}get interfaces_(){return[]}}class un{constructor(){un.constructor_.apply(this,arguments)}static getBisectorY(t){return new un(t).getBisectorY()}updateInterval(t){t<=this._centreY?t>this._loY&&(this._loY=t):t>this._centreY&&t<this._hiY&&(this._hiY=t)}getBisectorY(){this.process(this._poly.getExteriorRing());for(let t=0;t<this._poly.getNumInteriorRing();t++)this.process(this._poly.getInteriorRingN(t));return hn.avg(this._hiY,this._loY)}process(t){const e=t.getCoordinateSequence();for(let t=0;t<e.size();t++){const n=e.getY(t);this.updateInterval(n)}}getClass(){return un}get interfaces_(){return[]}}un.constructor_=function(){this._poly=null,this._centreY=null,this._hiY=i.MAX_VALUE,this._loY=-i.MAX_VALUE;const t=arguments[0];this._poly=t,this._hiY=t.getEnvelopeInternal().getMaxY(),this._loY=t.getEnvelopeInternal().getMinY(),this._centreY=hn.avg(this._loY,this._hiY)},hn.SafeBisectorFinder=un,hn.constructor_=function(){this._factory=null,this._interiorPoint=null,this._maxWidth=0;const t=arguments[0];this._factory=t.getFactory(),this.add(t)};class gn{constructor(){gn.constructor_.apply(this,arguments)}addEndpoints(){if(arguments[0]instanceof q){const t=arguments[0];if(t instanceof Tt)this.addEndpoints(t.getCoordinates());else if(t instanceof _t){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.addEndpoints(e.getGeometryN(t))}}else if(arguments[0]instanceof Array){const t=arguments[0];this.add(t[0]),this.add(t[t.length-1])}}getInteriorPoint(){return this._interiorPoint}addInterior(){if(arguments[0]instanceof q){const t=arguments[0];if(t instanceof Tt)this.addInterior(t.getCoordinates());else if(t instanceof _t){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.addInterior(e.getGeometryN(t))}}else if(arguments[0]instanceof Array){const t=arguments[0];for(let e=1;e<t.length-1;e++)this.add(t[e])}}add(t){const e=t.distance(this._centroid);e<this._minDistance&&(this._interiorPoint=new g(t),this._minDistance=e)}getClass(){return gn}get interfaces_(){return[]}}gn.constructor_=function(){this._centroid=null,this._minDistance=i.MAX_VALUE,this._interiorPoint=null;const t=arguments[0];t.isEmpty()?this._centroid=new g:this._centroid=sn.getCentroid(t),this.addInterior(t),null===this._interiorPoint&&this.addEndpoints(t)};class dn{constructor(){dn.constructor_.apply(this,arguments)}getInteriorPoint(){return this._interiorPoint}add(){if(arguments[0]instanceof q){const t=arguments[0];if(t instanceof Pt)this.add(t.getCoordinate());else if(t instanceof _t){const e=t;for(let t=0;t<e.getNumGeometries();t++)this.add(e.getGeometryN(t))}}else if(arguments[0]instanceof g){const t=arguments[0],e=t.distance(this._centroid);e<this._minDistance&&(this._interiorPoint=new g(t),this._minDistance=e)}}getClass(){return dn}get interfaces_(){return[]}}dn.constructor_=function(){this._centroid=null,this._minDistance=i.MAX_VALUE,this._interiorPoint=null;const t=arguments[0];this._centroid=t.getCentroid().getCoordinate(),this.add(t)};class _n{constructor(){_n.constructor_.apply(this,arguments)}locateInPolygonRing(t,e){return e.getEnvelopeInternal().intersects(t)?We.locateInRing(t,e.getCoordinates()):ne.EXTERIOR}intersects(t,e){return this.locate(t,e)!==ne.EXTERIOR}updateLocationInfo(t){t===ne.INTERIOR&&(this._isIn=!0),t===ne.BOUNDARY&&this._numBoundaries++}computeLocation(t,e){if(e instanceof Pt&&this.updateLocationInfo(this.locateOnPoint(t,e)),e instanceof Tt)this.updateLocationInfo(this.locateOnLineString(t,e));else if(e instanceof bt)this.updateLocationInfo(this.locateInPolygon(t,e));else if(e instanceof ft){const n=e;for(let e=0;e<n.getNumGeometries();e++){const s=n.getGeometryN(e);this.updateLocationInfo(this.locateOnLineString(t,s))}}else if(e instanceof At){const n=e;for(let e=0;e<n.getNumGeometries();e++){const s=n.getGeometryN(e);this.updateLocationInfo(this.locateInPolygon(t,s))}}else if(e instanceof _t){const n=new Ke(e);for(;n.hasNext();){const s=n.next();s!==e&&this.computeLocation(t,s)}}}locateOnPoint(t,e){return e.getCoordinate().equals2D(t)?ne.INTERIOR:ne.EXTERIOR}locateOnLineString(t,e){if(!e.getEnvelopeInternal().intersects(t))return ne.EXTERIOR;const n=e.getCoordinateSequence();return e.isClosed()||!t.equals(n.getCoordinate(0))&&!t.equals(n.getCoordinate(n.size()-1))?We.isOnLine(t,n)?ne.INTERIOR:ne.EXTERIOR:ne.BOUNDARY}locateInPolygon(t,e){if(e.isEmpty())return ne.EXTERIOR;const n=e.getExteriorRing(),s=this.locateInPolygonRing(t,n);if(s===ne.EXTERIOR)return ne.EXTERIOR;if(s===ne.BOUNDARY)return ne.BOUNDARY;for(let n=0;n<e.getNumInteriorRing();n++){const s=e.getInteriorRingN(n),i=this.locateInPolygonRing(t,s);if(i===ne.INTERIOR)return ne.EXTERIOR;if(i===ne.BOUNDARY)return ne.BOUNDARY}return ne.INTERIOR}locate(t,e){return e.isEmpty()?ne.EXTERIOR:e instanceof Tt?this.locateOnLineString(t,e):e instanceof bt?this.locateInPolygon(t,e):(this._isIn=!1,this._numBoundaries=0,this.computeLocation(t,e),this._boundaryRule.isInBoundary(this._numBoundaries)?ne.BOUNDARY:this._numBoundaries>0||this._isIn?ne.INTERIOR:ne.EXTERIOR)}getClass(){return _n}get interfaces_(){return[]}}_n.constructor_=function(){if(this._boundaryRule=V.OGC_SFS_BOUNDARY_RULE,this._isIn=null,this._numBoundaries=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];if(null===t)throw new n("Rule must be non-null");this._boundaryRule=t}};class fn{constructor(){fn.constructor_.apply(this,arguments)}static pointWitMinAngleWithX(t,e){let n=i.MAX_VALUE,s=null;for(let i=0;i<t.length;i++){const r=t[i];if(r===e)continue;const o=r.x-e.x;let l=r.y-e.y;l<0&&(l=-l);const a=l/Math.sqrt(o*o+l*l);a<n&&(n=a,s=r)}return s}static lowestPoint(t){let e=t[0];for(let n=1;n<t.length;n++)t[n].y<e.y&&(e=t[n]);return e}static pointWithMinAngleWithSegment(t,e,n){let s=i.MAX_VALUE,r=null;for(let i=0;i<t.length;i++){const o=t[i];if(o===e)continue;if(o===n)continue;const l=ie.angleBetween(e,o,n);l<s&&(s=l,r=o)}return r}getRadius(){return this.compute(),this._radius}getDiameter(){switch(this.compute(),this._extremalPts.length){case 0:return this._input.getFactory().createLineString();case 1:return this._input.getFactory().createPoint(this._centre)}const t=this._extremalPts[0],e=this._extremalPts[1];return this._input.getFactory().createLineString([t,e])}getExtremalPoints(){return this.compute(),this._extremalPts}computeCirclePoints(){if(this._input.isEmpty())return this._extremalPts=new Array(0).fill(null),null;if(1===this._input.getNumPoints()){const t=this._input.getCoordinates();return this._extremalPts=[new g(t[0])],null}const t=this._input.convexHull().getCoordinates();let e=t;if(t[0].equals2D(t[t.length-1])&&(e=new Array(t.length-1).fill(null),X.copyDeep(t,0,e,0,t.length-1)),e.length<=2)return this._extremalPts=X.copyDeep(e),null;let n=fn.lowestPoint(e),s=fn.pointWitMinAngleWithX(e,n);for(let t=0;t<e.length;t++){const t=fn.pointWithMinAngleWithSegment(e,n,s);if(ie.isObtuse(n,t,s))return this._extremalPts=[new g(n),new g(s)],null;if(ie.isObtuse(t,n,s))n=t;else{if(!ie.isObtuse(t,s,n))return this._extremalPts=[new g(n),new g(s),new g(t)],null;s=t}}u.shouldNeverReachHere("Logic failure in Minimum Bounding Circle algorithm!")}compute(){if(null!==this._extremalPts)return null;this.computeCirclePoints(),this.computeCentre(),null!==this._centre&&(this._radius=this._centre.distance(this._extremalPts[0]))}getFarthestPoints(){switch(this.compute(),this._extremalPts.length){case 0:return this._input.getFactory().createLineString();case 1:return this._input.getFactory().createPoint(this._centre)}const t=this._extremalPts[0],e=this._extremalPts[this._extremalPts.length-1];return this._input.getFactory().createLineString([t,e])}getCircle(){if(this.compute(),null===this._centre)return this._input.getFactory().createPolygon();const t=this._input.getFactory().createPoint(this._centre);return 0===this._radius?t:t.buffer(this._radius)}getCentre(){return this.compute(),this._centre}computeCentre(){switch(this._extremalPts.length){case 0:this._centre=null;break;case 1:this._centre=this._extremalPts[0];break;case 2:this._centre=new g((this._extremalPts[0].x+this._extremalPts[1].x)/2,(this._extremalPts[0].y+this._extremalPts[1].y)/2);break;case 3:this._centre=re.circumcentre(this._extremalPts[0],this._extremalPts[1],this._extremalPts[2])}}getClass(){return fn}get interfaces_(){return[]}}fn.constructor_=function(){this._input=null,this._extremalPts=null,this._centre=null,this._radius=0;const t=arguments[0];this._input=t};class pn{constructor(){pn.constructor_.apply(this,arguments)}static nextIndex(t,e){return++e>=t.length&&(e=0),e}static computeC(t,e,n){return t*n.y-e*n.x}static getMinimumDiameter(t){return new pn(t).getDiameter()}static getMinimumRectangle(t){return new pn(t).getMinimumRectangle()}static computeSegmentForLine(t,e,n){let s=null,i=null;return Math.abs(e)>Math.abs(t)?(s=new g(0,n/e),i=new g(1,n/e-t/e)):(s=new g(n/t,0),i=new g(n/t-e/t,1)),new ee(s,i)}getWidthCoordinate(){return this.computeMinimumDiameter(),this._minWidthPt}getSupportingSegment(){return this.computeMinimumDiameter(),this._inputGeom.getFactory().createLineString([this._minBaseSeg.p0,this._minBaseSeg.p1])}getDiameter(){if(this.computeMinimumDiameter(),null===this._minWidthPt)return this._inputGeom.getFactory().createLineString();const t=this._minBaseSeg.project(this._minWidthPt);return this._inputGeom.getFactory().createLineString([t,this._minWidthPt])}computeWidthConvex(t){this._convexHullPts=t instanceof bt?t.getExteriorRing().getCoordinates():t.getCoordinates(),0===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=null,this._minBaseSeg=null):1===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=this._convexHullPts[0],this._minBaseSeg.p0=this._convexHullPts[0],this._minBaseSeg.p1=this._convexHullPts[0]):2===this._convexHullPts.length||3===this._convexHullPts.length?(this._minWidth=0,this._minWidthPt=this._convexHullPts[0],this._minBaseSeg.p0=this._convexHullPts[0],this._minBaseSeg.p1=this._convexHullPts[1]):this.computeConvexRingMinDiameter(this._convexHullPts)}computeConvexRingMinDiameter(t){this._minWidth=i.MAX_VALUE;let e=1;const n=new ee;for(let s=0;s<t.length-1;s++)n.p0=t[s],n.p1=t[s+1],e=this.findMaxPerpDistance(t,n,e)}computeMinimumDiameter(){if(null!==this._minWidthPt)return null;if(this._isConvex)this.computeWidthConvex(this._inputGeom);else{const t=new an(this._inputGeom).getConvexHull();this.computeWidthConvex(t)}}getLength(){return this.computeMinimumDiameter(),this._minWidth}findMaxPerpDistance(t,e,n){let s=e.distancePerpendicular(t[n]),i=s,r=n,o=r;for(;i>=s;)s=i,r=o,o=pn.nextIndex(t,r),i=e.distancePerpendicular(t[o]);return s<this._minWidth&&(this._minPtIndex=r,this._minWidth=s,this._minWidthPt=t[this._minPtIndex],this._minBaseSeg=new ee(e)),r}getMinimumRectangle(){if(this.computeMinimumDiameter(),0===this._minWidth)return this._minBaseSeg.p0.equals2D(this._minBaseSeg.p1)?this._inputGeom.getFactory().createPoint(this._minBaseSeg.p0):this._minBaseSeg.toGeometry(this._inputGeom.getFactory());const t=this._minBaseSeg.p1.x-this._minBaseSeg.p0.x,e=this._minBaseSeg.p1.y-this._minBaseSeg.p0.y;let n=i.MAX_VALUE,s=-i.MAX_VALUE,r=i.MAX_VALUE,o=-i.MAX_VALUE;for(let i=0;i<this._convexHullPts.length;i++){const l=pn.computeC(t,e,this._convexHullPts[i]);l>s&&(s=l),l<n&&(n=l);const a=pn.computeC(-e,t,this._convexHullPts[i]);a>o&&(o=a),a<r&&(r=a)}const l=pn.computeSegmentForLine(-t,-e,o),a=pn.computeSegmentForLine(-t,-e,r),c=pn.computeSegmentForLine(-e,t,s),h=pn.computeSegmentForLine(-e,t,n),u=c.lineIntersection(l),g=h.lineIntersection(l),d=h.lineIntersection(a),_=c.lineIntersection(a),f=this._inputGeom.getFactory().createLinearRing([u,g,d,_,u]);return this._inputGeom.getFactory().createPolygon(f)}getClass(){return pn}get interfaces_(){return[]}}pn.constructor_=function(){if(this._inputGeom=null,this._isConvex=null,this._convexHullPts=null,this._minBaseSeg=new ee,this._minWidthPt=null,this._minPtIndex=null,this._minWidth=0,1===arguments.length){const t=arguments[0];pn.constructor_.call(this,t,!1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputGeom=t,this._isConvex=e}};var mn=Object.freeze({__proto__:null,distance:De,locate:Qe,match:nn,Angle:ie,Area:vt,Centroid:sn,ConvexHull:an,Distance:D,InteriorPointArea:hn,InteriorPointLine:gn,InteriorPointPoint:dn,Length:yt,Orientation:v,PointLocation:We,PointLocator:_n,RobustLineIntersector:te,MinimumBoundingCircle:fn,MinimumDiameter:pn});class yn{constructor(){yn.constructor_.apply(this,arguments)}static densifyPoints(t,e,n){const s=new ee,i=new I;for(let r=0;r<t.length-1;r++){s.p0=t[r],s.p1=t[r+1],i.add(s.p0,!1);const o=s.getLength(),l=Math.trunc(o/e)+1;if(l>1){const t=o/l;for(let e=1;e<l;e++){const r=e*t/o,l=s.pointAlong(r);n.makePrecise(l),i.add(l,!1)}}}return i.add(t[t.length-1],!1),i.toCoordinateArray()}static densify(t,e){const n=new yn(t);return n.setDistanceTolerance(e),n.getResultGeometry()}getResultGeometry(){return new xn(this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<=0)throw new n("Tolerance must be positive");this._distanceTolerance=t}getClass(){return yn}get interfaces_(){return[]}}class xn extends me{constructor(){super(),xn.constructor_.apply(this,arguments)}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformPolygon(t,e){const n=super.transformPolygon.call(this,t,e);return e instanceof At?n:this.createValidArea(n)}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=yn.densifyPoints(n,this.distanceTolerance,e.getPrecisionModel());return e instanceof Tt&&1===s.length&&(s=new Array(0).fill(null)),this._factory.getCoordinateSequenceFactory().create(s)}createValidArea(t){return t.buffer(0)}getClass(){return xn}get interfaces_(){return[]}}xn.constructor_=function(){this.distanceTolerance=null;const t=arguments[0];this.distanceTolerance=t},yn.DensifyTransformer=xn,yn.constructor_=function(){this._inputGeom=null,this._distanceTolerance=null;const t=arguments[0];this._inputGeom=t};var En=Object.freeze({__proto__:null,Densifier:yn});class In{constructor(){In.constructor_.apply(this,arguments)}static isNorthern(t){return t===In.NE||t===In.NW}static isOpposite(t,e){if(t===e)return!1;return 2===(t-e+4)%4}static commonHalfPlane(t,e){if(t===e)return t;if(2===(t-e+4)%4)return-1;const n=t<e?t:e;return 0===n&&3===(t>e?t:e)?3:n}static isInHalfPlane(t,e){return e===In.SE?t===In.SE||t===In.SW:t===e||t===e+1}static quadrant(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new n("Cannot compute the quadrant for point ( "+t+", "+e+" )");return t>=0?e>=0?In.NE:In.SE:e>=0?In.NW:In.SW}if(arguments[0]instanceof g&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1];if(e.x===t.x&&e.y===t.y)throw new n("Cannot compute the quadrant for two identical points "+t);return e.x>=t.x?e.y>=t.y?In.NE:In.SE:e.y>=t.y?In.NW:In.SW}}getClass(){return In}get interfaces_(){return[]}}In.constructor_=function(){},In.NE=0,In.NW=1,In.SW=2,In.SE=3;class Nn{constructor(){Nn.constructor_.apply(this,arguments)}static init(t,e){if(null!==t._sym||null!==e._sym||null!==t._next||null!==e._next)throw new IllegalStateException("Edges are already initialized");return t.init(e),t}static create(t,e){const n=new Nn(t),s=new Nn(e);return n.init(s),n}find(t){let e=this;do{if(null===e)return null;if(e.dest().equals2D(t))return e;e=e.oNext()}while(e!==this);return null}dest(){return this._sym._orig}oNext(){return this._sym._next}insert(t){if(this.oNext()===this)return this.insertAfter(t),null;const e=this.compareTo(t);let n=this;do{const s=n.oNext();if(s.compareTo(t)!==e||s===this)return n.insertAfter(t),null;n=s}while(n!==this);u.shouldNeverReachHere()}insertAfter(t){u.equals(this._orig,t.orig());const e=this.oNext();this._sym.setNext(t),t.sym().setNext(e)}degree(){let t=0,e=this;do{t++,e=e.oNext()}while(e!==this);return t}equals(){if(2===arguments.length&&arguments[1]instanceof g&&arguments[0]instanceof g){const t=arguments[0],e=arguments[1];return this._orig.equals2D(t)&&this._sym._orig.equals(e)}}deltaY(){return this._sym._orig.y-this._orig.y}sym(){return this._sym}prev(){return this._sym.next()._sym}compareAngularDirection(t){const e=this.deltaX(),n=this.deltaY(),s=t.deltaX(),i=t.deltaY();if(e===s&&n===i)return 0;const r=In.quadrant(e,n),o=In.quadrant(s,i);return r>o?1:r<o?-1:v.index(t._orig,t.dest(),this.dest())}prevNode(){let t=this;for(;2===t.degree();)if(t=t.prev(),t===this)return null;return t}compareTo(t){const e=t;return this.compareAngularDirection(e)}next(){return this._next}setSym(t){this._sym=t}orig(){return this._orig}toString(){return"HE("+this._orig.x+" "+this._orig.y+", "+this._sym._orig.x+" "+this._sym._orig.y+")"}setNext(t){this._next=t}init(t){this.setSym(t),t.setSym(this),this.setNext(t),t.setNext(this)}deltaX(){return this._sym._orig.x-this._orig.x}getClass(){return Nn}get interfaces_(){return[]}}Nn.constructor_=function(){this._orig=null,this._sym=null,this._next=null;const t=arguments[0];this._orig=t};class Cn extends Nn{constructor(){super(),Cn.constructor_.apply(this,arguments)}static setMarkBoth(t,e){t.setMark(e),t.sym().setMark(e)}static isMarked(t){return t.isMarked()}static setMark(t,e){t.setMark(e)}static markBoth(t){t.mark(),t.sym().mark()}static mark(t){t.mark()}mark(){this._isMarked=!0}setMark(t){this._isMarked=t}isMarked(){return this._isMarked}getClass(){return Cn}get interfaces_(){return[]}}Cn.constructor_=function(){this._isMarked=!1;const t=arguments[0];Nn.constructor_.call(this,t)};class Sn{constructor(){Sn.constructor_.apply(this,arguments)}static isValidEdge(t,e){return 0!==e.compareTo(t)}insert(t,e,n){const s=this.create(t,e);null!==n?n.insert(s):this._vertexMap.put(t,s);const i=this._vertexMap.get(e);return null!==i?i.insert(s.sym()):this._vertexMap.put(e,s.sym()),s}create(t,e){const n=this.createEdge(t),s=this.createEdge(e);return Nn.init(n,s),n}createEdge(t){return new Nn(t)}addEdge(t,e){if(!Sn.isValidEdge(t,e))return null;const n=this._vertexMap.get(t);let s=null;if(null!==n&&(s=n.find(e)),null!==s)return s;return this.insert(t,e,n)}getVertexEdges(){return this._vertexMap.values()}findEdge(t,e){const n=this._vertexMap.get(t);return null===n?null:n.find(e)}getClass(){return Sn}get interfaces_(){return[]}}Sn.constructor_=function(){this._vertexMap=new Ut};class wn extends Cn{constructor(){super(),wn.constructor_.apply(this,arguments)}setStart(){this._isStart=!0}isStart(){return this._isStart}getClass(){return wn}get interfaces_(){return[]}}wn.constructor_=function(){this._isStart=!1;const t=arguments[0];Cn.constructor_.call(this,t)};class Ln extends Sn{constructor(){super(),Ln.constructor_.apply(this,arguments)}createEdge(t){return new wn(t)}getClass(){return Ln}get interfaces_(){return[]}}Ln.constructor_=function(){};class Tn{constructor(){Tn.constructor_.apply(this,arguments)}static dissolve(t){const e=new Tn;return e.add(t),e.getResult()}addLine(t){this._lines.add(this._factory.createLineString(t.toCoordinateArray()))}updateRingStartEdge(t){return t.isStart()||(t=t.sym()).isStart()?null===this._ringStartEdge?(this._ringStartEdge=t,null):void(t.orig().compareTo(this._ringStartEdge.orig())<0&&(this._ringStartEdge=t)):null}getResult(){return null===this._result&&this.computeResult(),this._result}process(t){let e=t.prevNode();null===e&&(e=t),this.stackEdges(e),this.buildLines()}buildRing(t){const e=new I;let n=t;for(e.add(n.orig().copy(),!1);2===n.sym().degree();){const s=n.next();if(s===t)break;e.add(s.orig().copy(),!1),n=s}e.add(n.dest().copy(),!1),this.addLine(e)}buildLine(t){const e=new I;let n=t;for(this._ringStartEdge=null,Cn.markBoth(n),e.add(n.orig().copy(),!1);2===n.sym().degree();){this.updateRingStartEdge(n);const s=n.next();if(s===t)return this.buildRing(this._ringStartEdge),null;e.add(s.orig().copy(),!1),n=s,Cn.markBoth(n)}e.add(n.dest().clone(),!1),this.stackEdges(n.sym()),this.addLine(e)}stackEdges(t){let e=t;do{Cn.isMarked(e)||this._nodeEdgeStack.add(e),e=e.oNext()}while(e!==t)}computeResult(){for(let t=this._graph.getVertexEdges().iterator();t.hasNext();){const e=t.next();Cn.isMarked(e)||this.process(e)}this._result=this._factory.buildGeometry(this._lines)}buildLines(){for(;!this._nodeEdgeStack.empty();){const t=this._nodeEdgeStack.pop();Cn.isMarked(t)||this.buildLine(t)}}add(){if(arguments[0]instanceof q){arguments[0].apply(new class{get interfaces_(){return[G]}filter(t){t instanceof Tt&&this.add(t)}})}else if(_(arguments[0],f)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof Tt){const t=arguments[0];null===this._factory&&(this._factory=t.getFactory());const e=t.getCoordinateSequence();let n=!1;for(let t=1;t<e.size();t++){const s=this._graph.addEdge(e.getCoordinate(t-1),e.getCoordinate(t));null!==s&&(n||(s.setStart(),n=!0))}}}getClass(){return Tn}get interfaces_(){return[]}}Tn.constructor_=function(){this._result=null,this._factory=null,this._graph=null,this._lines=new x,this._nodeEdgeStack=new on,this._ringStartEdge=null,this._graph=new Ln};var Rn=Object.freeze({__proto__:null,LineDissolver:Tn});class Pn{constructor(){Pn.constructor_.apply(this,arguments)}static opposite(t){return t===Pn.LEFT?Pn.RIGHT:t===Pn.RIGHT?Pn.LEFT:t}getClass(){return Pn}get interfaces_(){return[]}}Pn.constructor_=function(){},Pn.ON=0,Pn.LEFT=1,Pn.RIGHT=2;class vn{constructor(){vn.constructor_.apply(this,arguments)}computeIntersections(t,e){this.mce.computeIntersectsForChain(this.chainIndex,t.mce,t.chainIndex,e)}getClass(){return vn}get interfaces_(){return[]}}vn.constructor_=function(){this.mce=null,this.chainIndex=null;const t=arguments[0],e=arguments[1];this.mce=t,this.chainIndex=e};class On{constructor(){On.constructor_.apply(this,arguments)}isDelete(){return this._eventType===On.DELETE}setDeleteEventIndex(t){this._deleteEventIndex=t}getObject(){return this._obj}compareTo(t){const e=t;return this._xValue<e._xValue?-1:this._xValue>e._xValue?1:this._eventType<e._eventType?-1:this._eventType>e._eventType?1:0}getInsertEvent(){return this._insertEvent}isInsert(){return this._eventType===On.INSERT}isSameLabel(t){return null!==this._label&&this._label===t._label}getDeleteEventIndex(){return this._deleteEventIndex}getClass(){return On}get interfaces_(){return[r]}}On.constructor_=function(){if(this._label=null,this._xValue=null,this._eventType=null,this._insertEvent=null,this._deleteEventIndex=null,this._obj=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._eventType=On.DELETE,this._xValue=t,this._insertEvent=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._eventType=On.INSERT,this._label=t,this._xValue=e,this._obj=n}},On.INSERT=1,On.DELETE=2;class bn{constructor(){bn.constructor_.apply(this,arguments)}getClass(){return bn}get interfaces_(){return[]}}bn.constructor_=function(){};class Mn{constructor(){Mn.constructor_.apply(this,arguments)}static isAdjacentSegments(t,e){return 1===Math.abs(t-e)}isTrivialIntersection(t,e,n,s){if(t===n&&1===this._li.getIntersectionNum()){if(Mn.isAdjacentSegments(e,s))return!0;if(t.isClosed()){const n=t.getNumPoints()-1;if(0===e&&s===n||0===s&&e===n)return!0}}return!1}getProperIntersectionPoint(){return this._properIntersectionPoint}setIsDoneIfProperInt(t){this._isDoneWhenProperInt=t}hasProperInteriorIntersection(){return this._hasProperInterior}isBoundaryPointInternal(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next().getCoordinate();if(t.isIntersection(e))return!0}return!1}hasProperIntersection(){return this._hasProper}hasIntersection(){return this._hasIntersection}isDone(){return this._isDone}isBoundaryPoint(t,e){return null!==e&&(!!this.isBoundaryPointInternal(t,e[0])||!!this.isBoundaryPointInternal(t,e[1]))}setBoundaryNodes(t,e){this._bdyNodes=new Array(2).fill(null),this._bdyNodes[0]=t,this._bdyNodes[1]=e}addIntersections(t,e,n,s){if(t===n&&e===s)return null;this.numTests++;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this._recordIsolated&&(t.setIsolated(!1),n.setIsolated(!1)),this._numIntersections++,this.isTrivialIntersection(t,e,n,s)||(this._hasIntersection=!0,!this._includeProper&&this._li.isProper()||(t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1)),this._li.isProper()&&(this._properIntersectionPoint=this._li.getIntersection(0).copy(),this._hasProper=!0,this._isDoneWhenProperInt&&(this._isDone=!0),this.isBoundaryPoint(this._li,this._bdyNodes)||(this._hasProperInterior=!0))))}getClass(){return Mn}get interfaces_(){return[]}}Mn.constructor_=function(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._properIntersectionPoint=null,this._li=null,this._includeProper=null,this._recordIsolated=null,this._isSelfIntersection=null,this._numIntersections=0,this.numTests=0,this._bdyNodes=null,this._isDone=!1,this._isDoneWhenProperInt=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._li=t,this._includeProper=e,this._recordIsolated=n};class Dn extends bn{constructor(){super(),Dn.constructor_.apply(this,arguments)}prepareEvents(){Ee.sort(this.events);for(let t=0;t<this.events.size();t++){const e=this.events.get(t);e.isDelete()&&e.getInsertEvent().setDeleteEventIndex(t)}}computeIntersections(){if(1===arguments.length){const t=arguments[0];this.nOverlaps=0,this.prepareEvents();for(let e=0;e<this.events.size();e++){const n=this.events.get(e);if(n.isInsert()&&this.processOverlaps(e,n.getDeleteEventIndex(),n,t),t.isDone())break}}else if(3===arguments.length)if(arguments[2]instanceof Mn&&_(arguments[0],m)&&_(arguments[1],m)){const t=arguments[0],e=arguments[1],n=arguments[2];this.addEdges(t,t),this.addEdges(e,e),this.computeIntersections(n)}else if("boolean"==typeof arguments[2]&&_(arguments[0],m)&&arguments[1]instanceof Mn){const t=arguments[0],e=arguments[1];arguments[2]?this.addEdges(t,null):this.addEdges(t),this.computeIntersections(e)}}addEdge(t,e){const n=t.getMonotoneChainEdge(),s=n.getStartIndexes();for(let t=0;t<s.length-1;t++){const s=new vn(n,t),i=new On(e,n.getMinX(t),s);this.events.add(i),this.events.add(new On(n.getMaxX(t),i))}}processOverlaps(t,e,n,s){const i=n.getObject();for(let r=t;r<e;r++){const t=this.events.get(r);if(t.isInsert()){const e=t.getObject();n.isSameLabel(t)||(i.computeIntersections(e,s),this.nOverlaps++)}}}addEdges(){if(1===arguments.length){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.addEdge(e,e)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];for(let n=t.iterator();n.hasNext();){const t=n.next();this.addEdge(t,e)}}}getClass(){return Dn}get interfaces_(){return[]}}Dn.constructor_=function(){this.events=new x,this.nOverlaps=null};class An{constructor(){An.constructor_.apply(this,arguments)}setAllLocations(t){for(let e=0;e<this.location.length;e++)this.location[e]=t}isNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]!==ne.NONE)return!1;return!0}setAllLocationsIfNull(t){for(let e=0;e<this.location.length;e++)this.location[e]===ne.NONE&&(this.location[e]=t)}isLine(){return 1===this.location.length}merge(t){if(t.location.length>this.location.length){const t=new Array(3).fill(null);t[Pn.ON]=this.location[Pn.ON],t[Pn.LEFT]=ne.NONE,t[Pn.RIGHT]=ne.NONE,this.location=t}for(let e=0;e<this.location.length;e++)this.location[e]===ne.NONE&&e<t.location.length&&(this.location[e]=t.location[e])}getLocations(){return this.location}flip(){if(this.location.length<=1)return null;const t=this.location[Pn.LEFT];this.location[Pn.LEFT]=this.location[Pn.RIGHT],this.location[Pn.RIGHT]=t}toString(){const t=new w;return this.location.length>1&&t.append(ne.toLocationSymbol(this.location[Pn.LEFT])),t.append(ne.toLocationSymbol(this.location[Pn.ON])),this.location.length>1&&t.append(ne.toLocationSymbol(this.location[Pn.RIGHT])),t.toString()}setLocations(t,e,n){this.location[Pn.ON]=t,this.location[Pn.LEFT]=e,this.location[Pn.RIGHT]=n}get(t){return t<this.location.length?this.location[t]:ne.NONE}isArea(){return this.location.length>1}isAnyNull(){for(let t=0;t<this.location.length;t++)if(this.location[t]===ne.NONE)return!0;return!1}setLocation(){if(1===arguments.length){const t=arguments[0];this.setLocation(Pn.ON,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.location[t]=e}}init(t){this.location=new Array(t).fill(null),this.setAllLocations(ne.NONE)}isEqualOnSide(t,e){return this.location[e]===t.location[e]}allPositionsEqual(t){for(let e=0;e<this.location.length;e++)if(this.location[e]!==t)return!1;return!0}getClass(){return An}get interfaces_(){return[]}}An.constructor_=function(){if(this.location=null,1===arguments.length){if(arguments[0]instanceof Array){const t=arguments[0];this.init(t.length)}else if(Number.isInteger(arguments[0])){const t=arguments[0];this.init(1),this.location[Pn.ON]=t}else if(arguments[0]instanceof An){const t=arguments[0];if(this.init(t.location.length),null!==t)for(let e=0;e<this.location.length;e++)this.location[e]=t.location[e]}}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.init(3),this.location[Pn.ON]=t,this.location[Pn.LEFT]=e,this.location[Pn.RIGHT]=n}};class Fn{constructor(){Fn.constructor_.apply(this,arguments)}static toLineLabel(t){const e=new Fn(ne.NONE);for(let n=0;n<2;n++)e.setLocation(n,t.getLocation(n));return e}getGeometryCount(){let t=0;return this.elt[0].isNull()||t++,this.elt[1].isNull()||t++,t}setAllLocations(t,e){this.elt[t].setAllLocations(e)}isNull(t){return this.elt[t].isNull()}setAllLocationsIfNull(){if(1===arguments.length){const t=arguments[0];this.setAllLocationsIfNull(0,t),this.setAllLocationsIfNull(1,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[t].setAllLocationsIfNull(e)}}isLine(t){return this.elt[t].isLine()}merge(t){for(let e=0;e<2;e++)null===this.elt[e]&&null!==t.elt[e]?this.elt[e]=new An(t.elt[e]):this.elt[e].merge(t.elt[e])}flip(){this.elt[0].flip(),this.elt[1].flip()}getLocation(){if(1===arguments.length){const t=arguments[0];return this.elt[t].get(Pn.ON)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.elt[t].get(e)}}toString(){const t=new w;return null!==this.elt[0]&&(t.append("A:"),t.append(this.elt[0].toString())),null!==this.elt[1]&&(t.append(" B:"),t.append(this.elt[1].toString())),t.toString()}isArea(){if(0===arguments.length)return this.elt[0].isArea()||this.elt[1].isArea();if(1===arguments.length){const t=arguments[0];return this.elt[t].isArea()}}isAnyNull(t){return this.elt[t].isAnyNull()}setLocation(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[t].setLocation(Pn.ON,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.elt[t].setLocation(e,n)}}isEqualOnSide(t,e){return this.elt[0].isEqualOnSide(t.elt[0],e)&&this.elt[1].isEqualOnSide(t.elt[1],e)}allPositionsEqual(t,e){return this.elt[t].allPositionsEqual(e)}toLine(t){this.elt[t].isArea()&&(this.elt[t]=new An(this.elt[t].location[0]))}getClass(){return Fn}get interfaces_(){return[]}}Fn.constructor_=function(){if(this.elt=new Array(2).fill(null),1===arguments.length){if(Number.isInteger(arguments[0])){const t=arguments[0];this.elt[0]=new An(t),this.elt[1]=new An(t)}else if(arguments[0]instanceof Fn){const t=arguments[0];this.elt[0]=new An(t.elt[0]),this.elt[1]=new An(t.elt[1])}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.elt[0]=new An(ne.NONE),this.elt[1]=new An(ne.NONE),this.elt[t].setLocation(e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this.elt[0]=new An(t,e,n),this.elt[1]=new An(t,e,n)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.elt[0]=new An(ne.NONE,ne.NONE,ne.NONE),this.elt[1]=new An(ne.NONE,ne.NONE,ne.NONE),this.elt[t].setLocations(e,n,s)}};class Gn{constructor(){Gn.constructor_.apply(this,arguments)}getSegmentIndex(){return this.segmentIndex}getCoordinate(){return this.coord}print(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex),t.println(" dist = "+this.dist)}compareTo(t){const e=t;return this.compare(e.segmentIndex,e.dist)}isEndPoint(t){return 0===this.segmentIndex&&0===this.dist||this.segmentIndex===t}toString(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist}getDistance(){return this.dist}compare(t,e){return this.segmentIndex<t?-1:this.segmentIndex>t?1:this.dist<e?-1:this.dist>e?1:0}getClass(){return Gn}get interfaces_(){return[r]}}Gn.constructor_=function(){this.coord=null,this.segmentIndex=null,this.dist=null;const t=arguments[0],e=arguments[1],n=arguments[2];this.coord=new g(t),this.segmentIndex=e,this.dist=n};class qn{constructor(){qn.constructor_.apply(this,arguments)}print(t){t.println("Intersections:");for(let e=this.iterator();e.hasNext();){e.next().print(t)}}iterator(){return this._nodeMap.values().iterator()}addSplitEdges(t){this.addEndpoints();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next(),i=this.createSplitEdge(n,s);t.add(i),n=s}}addEndpoints(){const t=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[t],t,0)}createSplitEdge(t,e){let n=e.segmentIndex-t.segmentIndex+2;const s=this.edge.pts[e.segmentIndex],i=e.dist>0||!e.coord.equals2D(s);i||n--;const r=new Array(n).fill(null);let o=0;r[o++]=new g(t.coord);for(let n=t.segmentIndex+1;n<=e.segmentIndex;n++)r[o++]=this.edge.pts[n];return i&&(r[o]=e.coord),new Un(r,new Fn(this.edge._label))}add(t,e,n){const s=new Gn(t,e,n),i=this._nodeMap.get(s);return null!==i?i:(this._nodeMap.put(s,s),s)}isIntersection(t){for(let e=this.iterator();e.hasNext();){if(e.next().coord.equals(t))return!0}return!1}getClass(){return qn}get interfaces_(){return[]}}qn.constructor_=function(){this._nodeMap=new rt,this.edge=null;const t=arguments[0];this.edge=t};class Bn{constructor(){Bn.constructor_.apply(this,arguments)}static toIntArray(t){const e=new Array(t.size()).fill(null);for(let n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e}getChainStartIndices(t){let e=0;const n=new x;n.add(new L(e));do{const s=this.findChainEnd(t,e);n.add(new L(s)),e=s}while(e<t.length-1);return Bn.toIntArray(n)}findChainEnd(t,e){const n=In.quadrant(t[e],t[e+1]);let s=e+1;for(;s<t.length;){if(In.quadrant(t[s-1],t[s])!==n)break;s++}return s-1}getClass(){return Bn}get interfaces_(){return[]}}Bn.constructor_=function(){};class Vn{constructor(){Vn.constructor_.apply(this,arguments)}getCoordinates(){return this.pts}getMaxX(t){const e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e>n?e:n}getMinX(t){const e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e<n?e:n}computeIntersectsForChain(){if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.computeIntersectsForChain(this.startIndex[t],this.startIndex[t+1],e,e.startIndex[n],e.startIndex[n+1],s)}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];if(e-t==1&&i-s==1)return r.addIntersections(this.e,t,n.e,s),null;if(!this.overlaps(t,e,n,s,i))return null;const o=Math.trunc((t+e)/2),l=Math.trunc((s+i)/2);t<o&&(s<l&&this.computeIntersectsForChain(t,o,n,s,l,r),l<i&&this.computeIntersectsForChain(t,o,n,l,i,r)),o<e&&(s<l&&this.computeIntersectsForChain(o,e,n,s,l,r),l<i&&this.computeIntersectsForChain(o,e,n,l,i,r))}}overlaps(t,e,n,s,i){return N.intersects(this.pts[t],this.pts[e],n.pts[s],n.pts[i])}getStartIndexes(){return this.startIndex}computeIntersects(t,e){for(let n=0;n<this.startIndex.length-1;n++)for(let s=0;s<t.startIndex.length-1;s++)this.computeIntersectsForChain(n,t,s,e)}getClass(){return Vn}get interfaces_(){return[]}}Vn.constructor_=function(){this.e=null,this.pts=null,this.startIndex=null;const t=arguments[0];this.e=t,this.pts=t.getCoordinates();const e=new Bn;this.startIndex=e.getChainStartIndices(this.pts)};class zn{constructor(){zn.constructor_.apply(this,arguments)}static depthAtLocation(t){return t===ne.EXTERIOR?0:t===ne.INTERIOR?1:zn.NULL_VALUE}getDepth(t,e){return this._depth[t][e]}setDepth(t,e,n){this._depth[t][e]=n}isNull(){if(0===arguments.length){for(let t=0;t<2;t++)for(let e=0;e<3;e++)if(this._depth[t][e]!==zn.NULL_VALUE)return!1;return!0}if(1===arguments.length){const t=arguments[0];return this._depth[t][1]===zn.NULL_VALUE}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._depth[t][e]===zn.NULL_VALUE}}normalize(){for(let t=0;t<2;t++)if(!this.isNull(t)){let e=this._depth[t][1];this._depth[t][2]<e&&(e=this._depth[t][2]),e<0&&(e=0);for(let n=1;n<3;n++){let s=0;this._depth[t][n]>e&&(s=1),this._depth[t][n]=s}}}getDelta(t){return this._depth[t][Pn.RIGHT]-this._depth[t][Pn.LEFT]}getLocation(t,e){return this._depth[t][e]<=0?ne.EXTERIOR:ne.INTERIOR}toString(){return"A: "+this._depth[0][1]+","+this._depth[0][2]+" B: "+this._depth[1][1]+","+this._depth[1][2]}add(){if(1===arguments.length){const t=arguments[0];for(let e=0;e<2;e++)for(let n=1;n<3;n++){const s=t.getLocation(e,n);s!==ne.EXTERIOR&&s!==ne.INTERIOR||(this.isNull(e,n)?this._depth[e][n]=zn.depthAtLocation(s):this._depth[e][n]+=zn.depthAtLocation(s))}}else if(3===arguments.length){const t=arguments[0],e=arguments[1];arguments[2]===ne.INTERIOR&&this._depth[t][e]++}}getClass(){return zn}get interfaces_(){return[]}}zn.constructor_=function(){this._depth=Array(2).fill().map(()=>Array(3));for(let t=0;t<2;t++)for(let e=0;e<3;e++)this._depth[t][e]=zn.NULL_VALUE},zn.NULL_VALUE=-1;class Yn{constructor(){Yn.constructor_.apply(this,arguments)}setVisited(t){this._isVisited=t}setInResult(t){this._isInResult=t}isCovered(){return this._isCovered}isCoveredSet(){return this._isCoveredSet}setLabel(t){this._label=t}getLabel(){return this._label}setCovered(t){this._isCovered=t,this._isCoveredSet=!0}updateIM(t){u.isTrue(this._label.getGeometryCount()>=2,"found partial label"),this.computeIM(t)}isInResult(){return this._isInResult}isVisited(){return this._isVisited}getClass(){return Yn}get interfaces_(){return[]}}Yn.constructor_=function(){if(this._label=null,this._isInResult=!1,this._isCovered=!1,this._isCoveredSet=!1,this._isVisited=!1,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._label=t}};class Un extends Yn{constructor(){super(),Un.constructor_.apply(this,arguments)}static updateIM(){if(!(2===arguments.length&&arguments[1]instanceof se&&arguments[0]instanceof Fn))return super.updateIM.apply(this,arguments);{const t=arguments[0],e=arguments[1];e.setAtLeastIfValid(t.getLocation(0,Pn.ON),t.getLocation(1,Pn.ON),1),t.isArea()&&(e.setAtLeastIfValid(t.getLocation(0,Pn.LEFT),t.getLocation(1,Pn.LEFT),2),e.setAtLeastIfValid(t.getLocation(0,Pn.RIGHT),t.getLocation(1,Pn.RIGHT),2))}}getDepth(){return this._depth}getCollapsedEdge(){const t=new Array(2).fill(null);return t[0]=this.pts[0],t[1]=this.pts[1],new Un(t,Fn.toLineLabel(this._label))}isIsolated(){return this._isIsolated}getCoordinates(){return this.pts}setIsolated(t){this._isIsolated=t}setName(t){this._name=t}equals(t){if(!(t instanceof Un))return!1;const e=t;if(this.pts.length!==e.pts.length)return!1;let n=!0,s=!0,i=this.pts.length;for(let t=0;t<this.pts.length;t++)if(this.pts[t].equals2D(e.pts[t])||(n=!1),this.pts[t].equals2D(e.pts[--i])||(s=!1),!n&&!s)return!1;return!0}getCoordinate(){if(0===arguments.length)return this.pts.length>0?this.pts[0]:null;if(1===arguments.length){const t=arguments[0];return this.pts[t]}}print(t){t.print("edge "+this._name+": "),t.print("LINESTRING (");for(let e=0;e<this.pts.length;e++)e>0&&t.print(","),t.print(this.pts[e].x+" "+this.pts[e].y);t.print(")  "+this._label+" "+this._depthDelta)}computeIM(t){Un.updateIM(this._label,t)}isCollapsed(){return!!this._label.isArea()&&(3===this.pts.length&&!!this.pts[0].equals(this.pts[2]))}isClosed(){return this.pts[0].equals(this.pts[this.pts.length-1])}getMaximumSegmentIndex(){return this.pts.length-1}getDepthDelta(){return this._depthDelta}getNumPoints(){return this.pts.length}printReverse(t){t.print("edge "+this._name+": ");for(let e=this.pts.length-1;e>=0;e--)t.print(this.pts[e]+" ");t.println("")}getMonotoneChainEdge(){return null===this._mce&&(this._mce=new Vn(this)),this._mce}getEnvelope(){if(null===this._env){this._env=new N;for(let t=0;t<this.pts.length;t++)this._env.expandToInclude(this.pts[t])}return this._env}addIntersection(t,e,n,s){const i=new g(t.getIntersection(s));let r=e,o=t.getEdgeDistance(n,s);const l=r+1;if(l<this.pts.length){const t=this.pts[l];i.equals2D(t)&&(r=l,o=0)}this.eiList.add(i,r,o)}toString(){const t=new wt;t.append("edge "+this._name+": "),t.append("LINESTRING (");for(let e=0;e<this.pts.length;e++)e>0&&t.append(","),t.append(this.pts[e].x+" "+this.pts[e].y);return t.append(")  "+this._label+" "+this._depthDelta),t.toString()}isPointwiseEqual(t){if(this.pts.length!==t.pts.length)return!1;for(let e=0;e<this.pts.length;e++)if(!this.pts[e].equals2D(t.pts[e]))return!1;return!0}setDepthDelta(t){this._depthDelta=t}getEdgeIntersectionList(){return this.eiList}addIntersections(t,e,n){for(let s=0;s<t.getIntersectionNum();s++)this.addIntersection(t,e,n,s)}getClass(){return Un}get interfaces_(){return[]}}Un.constructor_=function(){if(this.pts=null,this._env=null,this.eiList=new qn(this),this._name=null,this._mce=null,this._isIsolated=!0,this._depth=new zn,this._depthDelta=0,1===arguments.length){const t=arguments[0];Un.constructor_.call(this,t,null)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.pts=t,this._label=e}};class kn extends Yn{constructor(){super(),kn.constructor_.apply(this,arguments)}isIncidentEdgeInResult(){for(let t=this.getEdges().getEdges().iterator();t.hasNext();){if(t.next().getEdge().isInResult())return!0}return!1}isIsolated(){return 1===this._label.getGeometryCount()}getCoordinate(){return this._coord}print(t){t.println("node "+this._coord+" lbl: "+this._label)}computeIM(t){}computeMergedLocation(t,e){let n=ne.NONE;if(n=this._label.getLocation(e),!t.isNull(e)){const s=t.getLocation(e);n!==ne.BOUNDARY&&(n=s)}return n}setLabel(){if(2!==arguments.length||!Number.isInteger(arguments[1])||!Number.isInteger(arguments[0]))return super.setLabel.apply(this,arguments);{const t=arguments[0],e=arguments[1];null===this._label?this._label=new Fn(t,e):this._label.setLocation(t,e)}}getEdges(){return this._edges}mergeLabel(){if(arguments[0]instanceof kn){const t=arguments[0];this.mergeLabel(t._label)}else if(arguments[0]instanceof Fn){const t=arguments[0];for(let e=0;e<2;e++){const n=this.computeMergedLocation(t,e);this._label.getLocation(e)===ne.NONE&&this._label.setLocation(e,n)}}}add(t){this._edges.insert(t),t.setNode(this)}setLabelBoundary(t){if(null===this._label)return null;let e=ne.NONE;null!==this._label&&(e=this._label.getLocation(t));let n=null;switch(e){case ne.BOUNDARY:n=ne.INTERIOR;break;case ne.INTERIOR:default:n=ne.BOUNDARY}this._label.setLocation(t,n)}getClass(){return kn}get interfaces_(){return[]}}kn.constructor_=function(){this._coord=null,this._edges=null;const t=arguments[0],e=arguments[1];this._coord=t,this._edges=e,this._label=new Fn(0,ne.NONE)};class Xn{constructor(){Xn.constructor_.apply(this,arguments)}find(t){return this.nodeMap.get(t)}addNode(){if(arguments[0]instanceof g){const t=arguments[0];let e=this.nodeMap.get(t);return null===e&&(e=this.nodeFact.createNode(t),this.nodeMap.put(t,e)),e}if(arguments[0]instanceof kn){const t=arguments[0],e=this.nodeMap.get(t.getCoordinate());return null===e?(this.nodeMap.put(t.getCoordinate(),t),t):(e.mergeLabel(t),e)}}print(t){for(let e=this.iterator();e.hasNext();){e.next().print(t)}}iterator(){return this.nodeMap.values().iterator()}values(){return this.nodeMap.values()}getBoundaryNodes(t){const e=new x;for(let n=this.iterator();n.hasNext();){const s=n.next();s.getLabel().getLocation(t)===ne.BOUNDARY&&e.add(s)}return e}add(t){const e=t.getCoordinate();this.addNode(e).add(t)}getClass(){return Xn}get interfaces_(){return[]}}Xn.constructor_=function(){this.nodeMap=new rt,this.nodeFact=null;const t=arguments[0];this.nodeFact=t};class Hn{constructor(){Hn.constructor_.apply(this,arguments)}compareDirection(t){return this._dx===t._dx&&this._dy===t._dy?0:this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:v.index(t._p0,t._p1,this._p1)}getDy(){return this._dy}getCoordinate(){return this._p0}setNode(t){this._node=t}print(t){const e=Math.atan2(this._dy,this._dx),n=this.getClass().getName(),s=n.lastIndexOf("."),i=n.substring(s+1);t.print("  "+i+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+e+"   "+this._label)}compareTo(t){const e=t;return this.compareDirection(e)}getDirectedCoordinate(){return this._p1}getDx(){return this._dx}getLabel(){return this._label}getEdge(){return this._edge}getQuadrant(){return this._quadrant}getNode(){return this._node}toString(){const t=Math.atan2(this._dy,this._dx),e=this.getClass().getName(),n=e.lastIndexOf(".");return"  "+e.substring(n+1)+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+t+"   "+this._label}computeLabel(t){}init(t,e){this._p0=t,this._p1=e,this._dx=e.x-t.x,this._dy=e.y-t.y,this._quadrant=In.quadrant(this._dx,this._dy),u.isTrue(!(0===this._dx&&0===this._dy),"EdgeEnd with identical endpoints found")}getClass(){return Hn}get interfaces_(){return[r]}}Hn.constructor_=function(){if(this._edge=null,this._label=null,this._node=null,this._p0=null,this._p1=null,this._dx=null,this._dy=null,this._quadrant=null,1===arguments.length){const t=arguments[0];this._edge=t}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];Hn.constructor_.call(this,t,e,n,null)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];Hn.constructor_.call(this,t),this.init(e,n),this._label=s}};class Wn extends c{constructor(){if(1===arguments.length){const t=arguments[0];super(t),c.call(this,t)}else{if(2!==arguments.length)throw Error();{const t=arguments[0],e=arguments[1];super(Wn.msgWithCoord(t,e)),this.name="TopologyException",this.pt=new g(e)}}}getCoordinate(){return this.pt}get interfaces_(){return[]}getClass(){return Wn}static msgWithCoord(t,e){return null!==e?t+" [ "+e+" ]":t}}class jn extends Hn{constructor(){super(),jn.constructor_.apply(this,arguments)}static depthFactor(t,e){return t===ne.EXTERIOR&&e===ne.INTERIOR?1:t===ne.INTERIOR&&e===ne.EXTERIOR?-1:0}getNextMin(){return this._nextMin}getDepth(t){return this._depth[t]}setVisited(t){this._isVisited=t}computeDirectedLabel(){this._label=new Fn(this._edge.getLabel()),this._isForward||this._label.flip()}getNext(){return this._next}setDepth(t,e){if(-999!==this._depth[t]&&this._depth[t]!==e)throw new Wn("assigned depths do not match",this.getCoordinate());this._depth[t]=e}isInteriorAreaEdge(){let t=!0;for(let e=0;e<2;e++)this._label.isArea(e)&&this._label.getLocation(e,Pn.LEFT)===ne.INTERIOR&&this._label.getLocation(e,Pn.RIGHT)===ne.INTERIOR||(t=!1);return t}setNextMin(t){this._nextMin=t}print(t){super.print.call(this,t),t.print(" "+this._depth[Pn.LEFT]+"/"+this._depth[Pn.RIGHT]),t.print(" ("+this.getDepthDelta()+")"),this._isInResult&&t.print(" inResult")}setMinEdgeRing(t){this._minEdgeRing=t}isLineEdge(){const t=this._label.isLine(0)||this._label.isLine(1),e=!this._label.isArea(0)||this._label.allPositionsEqual(0,ne.EXTERIOR),n=!this._label.isArea(1)||this._label.allPositionsEqual(1,ne.EXTERIOR);return t&&e&&n}setEdgeRing(t){this._edgeRing=t}getMinEdgeRing(){return this._minEdgeRing}getDepthDelta(){let t=this._edge.getDepthDelta();return this._isForward||(t=-t),t}setInResult(t){this._isInResult=t}getSym(){return this._sym}isForward(){return this._isForward}getEdge(){return this._edge}printEdge(t){this.print(t),t.print(" "),this._isForward?this._edge.print(t):this._edge.printReverse(t)}setSym(t){this._sym=t}setVisitedEdge(t){this.setVisited(t),this._sym.setVisited(t)}setEdgeDepths(t,e){let n=this.getEdge().getDepthDelta();this._isForward||(n=-n);let s=1;t===Pn.LEFT&&(s=-1);const i=Pn.opposite(t),r=e+n*s;this.setDepth(t,e),this.setDepth(i,r)}getEdgeRing(){return this._edgeRing}isInResult(){return this._isInResult}setNext(t){this._next=t}isVisited(){return this._isVisited}getClass(){return jn}get interfaces_(){return[]}}jn.constructor_=function(){this._isForward=null,this._isInResult=!1,this._isVisited=!1,this._sym=null,this._next=null,this._nextMin=null,this._edgeRing=null,this._minEdgeRing=null,this._depth=[0,-999,-999];const t=arguments[0],e=arguments[1];if(Hn.constructor_.call(this,t),this._isForward=e,e)this.init(t.getCoordinate(0),t.getCoordinate(1));else{const e=t.getNumPoints()-1;this.init(t.getCoordinate(e),t.getCoordinate(e-1))}this.computeDirectedLabel()};class Kn{constructor(){Kn.constructor_.apply(this,arguments)}createNode(t){return new kn(t,null)}getClass(){return Kn}get interfaces_(){return[]}}Kn.constructor_=function(){};class Zn{constructor(){Zn.constructor_.apply(this,arguments)}static linkResultDirectedEdges(t){for(let e=t.iterator();e.hasNext();){e.next().getEdges().linkResultDirectedEdges()}}printEdges(t){t.println("Edges:");for(let e=0;e<this._edges.size();e++){t.println("edge "+e+":");const n=this._edges.get(e);n.print(t),n.eiList.print(t)}}find(t){return this._nodes.find(t)}addNode(){if(arguments[0]instanceof kn){const t=arguments[0];return this._nodes.addNode(t)}if(arguments[0]instanceof g){const t=arguments[0];return this._nodes.addNode(t)}}getNodeIterator(){return this._nodes.iterator()}linkResultDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkResultDirectedEdges()}}debugPrintln(t){O.out.println(t)}isBoundaryNode(t,e){const n=this._nodes.find(e);if(null===n)return!1;const s=n.getLabel();return null!==s&&s.getLocation(t)===ne.BOUNDARY}linkAllDirectedEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().linkAllDirectedEdges()}}matchInSameDirection(t,e,n,s){return!!t.equals(n)&&(v.index(t,e,s)===v.COLLINEAR&&In.quadrant(t,e)===In.quadrant(n,s))}getEdgeEnds(){return this._edgeEndList}debugPrint(t){O.out.print(t)}getEdgeIterator(){return this._edges.iterator()}findEdgeInSameDirection(t,e){for(let n=0;n<this._edges.size();n++){const s=this._edges.get(n),i=s.getCoordinates();if(this.matchInSameDirection(t,e,i[0],i[1]))return s;if(this.matchInSameDirection(t,e,i[i.length-1],i[i.length-2]))return s}return null}insertEdge(t){this._edges.add(t)}findEdgeEnd(t){for(let e=this.getEdgeEnds().iterator();e.hasNext();){const n=e.next();if(n.getEdge()===t)return n}return null}addEdges(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._edges.add(t);const n=new jn(t,!0),s=new jn(t,!1);n.setSym(s),s.setSym(n),this.add(n),this.add(s)}}add(t){this._nodes.add(t),this._edgeEndList.add(t)}getNodes(){return this._nodes.values()}findEdge(t,e){for(let n=0;n<this._edges.size();n++){const s=this._edges.get(n),i=s.getCoordinates();if(t.equals(i[0])&&e.equals(i[1]))return s}return null}getClass(){return Zn}get interfaces_(){return[]}}Zn.constructor_=function(){if(this._edges=new x,this._nodes=null,this._edgeEndList=new x,0===arguments.length)this._nodes=new Xn(new Kn);else if(1===arguments.length){const t=arguments[0];this._nodes=new Xn(t)}};class Qn extends Zn{constructor(){super(),Qn.constructor_.apply(this,arguments)}static determineBoundary(t,e){return t.isInBoundary(e)?ne.BOUNDARY:ne.INTERIOR}insertBoundaryPoint(t,e){const n=this._nodes.addNode(e).getLabel();let s=1,i=ne.NONE;i=n.getLocation(t,Pn.ON),i===ne.BOUNDARY&&s++;const r=Qn.determineBoundary(this._boundaryNodeRule,s);n.setLocation(t,r)}computeSelfNodes(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.computeSelfNodes(t,e,!1)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=new Mn(t,!0,!1);s.setIsDoneIfProperInt(n);const i=this.createEdgeSetIntersector(),r=this._parentGeom instanceof Dt||this._parentGeom instanceof bt||this._parentGeom instanceof At,o=e||!r;return i.computeIntersections(this._edges,s,o),this.addSelfIntersectionNodes(this._argIndex),s}}computeSplitEdges(t){for(let e=this._edges.iterator();e.hasNext();){e.next().eiList.addSplitEdges(t)}}computeEdgeIntersections(t,e,n){const s=new Mn(e,n,!0);return s.setBoundaryNodes(this.getBoundaryNodes(),t.getBoundaryNodes()),this.createEdgeSetIntersector().computeIntersections(this._edges,t._edges,s),s}getGeometry(){return this._parentGeom}getBoundaryNodeRule(){return this._boundaryNodeRule}hasTooFewPoints(){return this._hasTooFewPoints}addPoint(){if(arguments[0]instanceof Pt){const t=arguments[0].getCoordinate();this.insertPoint(this._argIndex,t,ne.INTERIOR)}else if(arguments[0]instanceof g){const t=arguments[0];this.insertPoint(this._argIndex,t,ne.INTERIOR)}}addPolygon(t){this.addPolygonRing(t.getExteriorRing(),ne.EXTERIOR,ne.INTERIOR);for(let e=0;e<t.getNumInteriorRing();e++){const n=t.getInteriorRingN(e);this.addPolygonRing(n,ne.INTERIOR,ne.EXTERIOR)}}addEdge(t){this.insertEdge(t);const e=t.getCoordinates();this.insertPoint(this._argIndex,e[0],ne.BOUNDARY),this.insertPoint(this._argIndex,e[e.length-1],ne.BOUNDARY)}addLineString(t){const e=X.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return this._hasTooFewPoints=!0,this._invalidPoint=e[0],null;const n=new Un(e,new Fn(this._argIndex,ne.INTERIOR));this._lineEdgeMap.put(t,n),this.insertEdge(n),u.isTrue(e.length>=2,"found LineString with single point"),this.insertBoundaryPoint(this._argIndex,e[0]),this.insertBoundaryPoint(this._argIndex,e[e.length-1])}getInvalidPoint(){return this._invalidPoint}getBoundaryPoints(){const t=this.getBoundaryNodes(),e=new Array(t.size()).fill(null);let n=0;for(let s=t.iterator();s.hasNext();){const t=s.next();e[n++]=t.getCoordinate().copy()}return e}getBoundaryNodes(){return null===this._boundaryNodes&&(this._boundaryNodes=this._nodes.getBoundaryNodes(this._argIndex)),this._boundaryNodes}addSelfIntersectionNode(t,e,n){if(this.isBoundaryNode(t,e))return null;n===ne.BOUNDARY&&this._useBoundaryDeterminationRule?this.insertBoundaryPoint(t,e):this.insertPoint(t,e,n)}addPolygonRing(t,e,n){if(t.isEmpty())return null;const s=X.removeRepeatedPoints(t.getCoordinates());if(s.length<4)return this._hasTooFewPoints=!0,this._invalidPoint=s[0],null;let i=e,r=n;v.isCCW(s)&&(i=n,r=e);const o=new Un(s,new Fn(this._argIndex,ne.BOUNDARY,i,r));this._lineEdgeMap.put(t,o),this.insertEdge(o),this.insertPoint(this._argIndex,s[0],ne.BOUNDARY)}insertPoint(t,e,n){const s=this._nodes.addNode(e),i=s.getLabel();null===i?s._label=new Fn(t,n):i.setLocation(t,n)}createEdgeSetIntersector(){return new Dn}addSelfIntersectionNodes(t){for(let e=this._edges.iterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.eiList.iterator();e.hasNext();){const n=e.next();this.addSelfIntersectionNode(t,n.coord,s)}}}add(){if(!(1===arguments.length&&arguments[0]instanceof q))return super.add.apply(this,arguments);{const t=arguments[0];if(t.isEmpty())return null;if(t instanceof At&&(this._useBoundaryDeterminationRule=!1),t instanceof bt)this.addPolygon(t);else if(t instanceof Tt)this.addLineString(t);else if(t instanceof Pt)this.addPoint(t);else if(t instanceof Mt)this.addCollection(t);else if(t instanceof ft)this.addCollection(t);else if(t instanceof At)this.addCollection(t);else{if(!(t instanceof _t))throw new Z(t.getClass().getName());this.addCollection(t)}}}addCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);this.add(n)}}locate(t){return _(this._parentGeom,Ot)&&this._parentGeom.getNumGeometries()>50?(null===this._areaPtLocator&&(this._areaPtLocator=new ke(this._parentGeom)),this._areaPtLocator.locate(t)):this._ptLocator.locate(t,this._parentGeom)}findEdge(){if(1===arguments.length&&arguments[0]instanceof Tt){const t=arguments[0];return this._lineEdgeMap.get(t)}return super.findEdge.apply(this,arguments)}getClass(){return Qn}get interfaces_(){return[]}}Qn.constructor_=function(){if(this._parentGeom=null,this._lineEdgeMap=new Ut,this._boundaryNodeRule=null,this._useBoundaryDeterminationRule=!0,this._argIndex=null,this._boundaryNodes=null,this._hasTooFewPoints=!1,this._invalidPoint=null,this._areaPtLocator=null,this._ptLocator=new _n,2===arguments.length){const t=arguments[0],e=arguments[1];Qn.constructor_.call(this,t,e,V.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._argIndex=t,this._parentGeom=e,this._boundaryNodeRule=n,null!==e&&this.add(e)}};var Jn=Object.freeze({__proto__:null,GeometryGraph:Qn});class $n{constructor(){$n.constructor_.apply(this,arguments)}visit(t){}getClass(){return $n}get interfaces_(){return[]}}$n.constructor_=function(){};class ts{constructor(){ts.constructor_.apply(this,arguments)}isRepeated(){return this._count>1}getRight(){return this._right}getCoordinate(){return this._p}setLeft(t){this._left=t}getX(){return this._p.x}getData(){return this._data}getCount(){return this._count}getLeft(){return this._left}getY(){return this._p.y}increment(){this._count=this._count+1}setRight(t){this._right=t}getClass(){return ts}get interfaces_(){return[]}}ts.constructor_=function(){if(this._p=null,this._data=null,this._left=null,this._right=null,this._count=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._p=new g(t),this._left=null,this._right=null,this._count=1,this._data=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._p=new g(t,e),this._left=null,this._right=null,this._count=1,this._data=n}};class es{constructor(){es.constructor_.apply(this,arguments)}static toCoordinates(){if(1===arguments.length){const t=arguments[0];return es.toCoordinates(t,!1)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new I;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=e?t.getCount():1;for(let e=0;e<i;e++)n.add(t.getCoordinate(),!0)}return n.toCoordinateArray()}}insert(){if(1===arguments.length){const t=arguments[0];return this.insert(t,null)}if(2===arguments.length){const t=arguments[0],e=arguments[1];if(null===this._root)return this._root=new ts(t,e),this._root;if(this._tolerance>0){const e=this.findBestMatchNode(t);if(null!==e)return e.increment(),e}return this.insertExact(t,e)}}query(){if(1===arguments.length){const t=arguments[0],e=new x;return this.query(t,e),e}if(2===arguments.length)if(arguments[0]instanceof N&&_(arguments[1],m)){const t=arguments[0],e=arguments[1];this.queryNode(this._root,t,!0,new class{get interfaces_(){return[$n]}visit(t){e.add(t)}})}else if(arguments[0]instanceof N&&_(arguments[1],$n)){const t=arguments[0],e=arguments[1];this.queryNode(this._root,t,!0,e)}}queryNode(t,e,n,s){if(null===t)return null;let i=null,r=null,o=null;n?(i=e.getMinX(),r=e.getMaxX(),o=t.getX()):(i=e.getMinY(),r=e.getMaxY(),o=t.getY());const l=o<=r;i<o&&this.queryNode(t.getLeft(),e,!n,s),e.contains(t.getCoordinate())&&s.visit(t),l&&this.queryNode(t.getRight(),e,!n,s)}findBestMatchNode(t){const e=new ns(t,this._tolerance);return this.query(e.queryEnvelope(),e),e.getNode()}isEmpty(){return null===this._root}insertExact(t,e){let n=this._root,s=this._root,i=!0,r=!0;for(;null!==n;){if(null!==n){if(t.distance(n.getCoordinate())<=this._tolerance)return n.increment(),n}r=i?t.x<n.getX():t.y<n.getY(),s=n,n=r?n.getLeft():n.getRight(),i=!i}this._numberOfNodes=this._numberOfNodes+1;const o=new ts(t,e);return r?s.setLeft(o):s.setRight(o),o}getClass(){return es}get interfaces_(){return[]}}class ns{constructor(){ns.constructor_.apply(this,arguments)}visit(t){const e=this._p.distance(t.getCoordinate());if(!(e<=this._tolerance))return null;let n=!1;(null===this._matchNode||e<this._matchDist||null!==this._matchNode&&e===this._matchDist&&t.getCoordinate().compareTo(this._matchNode.getCoordinate())<1)&&(n=!0),n&&(this._matchNode=t,this._matchDist=e)}queryEnvelope(){const t=new N(this._p);return t.expandBy(this._tolerance),t}getNode(){return this._matchNode}getClass(){return ns}get interfaces_(){return[$n]}}ns.constructor_=function(){this._tolerance=null,this._matchNode=null,this._matchDist=0,this._p=null;const t=arguments[0],e=arguments[1];this._p=t,this._tolerance=e},es.BestMatchVisitor=ns,es.constructor_=function(){if(this._root=null,this._numberOfNodes=null,this._tolerance=null,0===arguments.length)es.constructor_.call(this,0);else if(1===arguments.length){const t=arguments[0];this._tolerance=t}};var ss=Object.freeze({__proto__:null,KdTree:es});class is{constructor(){is.constructor_.apply(this,arguments)}static getSubnodeIndex(t,e,n){let s=-1;return t.getMinX()>=e&&(t.getMinY()>=n&&(s=3),t.getMaxY()<=n&&(s=1)),t.getMaxX()<=e&&(t.getMinY()>=n&&(s=2),t.getMaxY()<=n&&(s=0)),s}hasChildren(){for(let t=0;t<4;t++)if(null!==this._subnode[t])return!0;return!1}isPrunable(){return!(this.hasChildren()||this.hasItems())}addAllItems(t){t.addAll(this._items);for(let e=0;e<4;e++)null!==this._subnode[e]&&this._subnode[e].addAllItems(t);return t}getNodeCount(){let t=0;for(let e=0;e<4;e++)null!==this._subnode[e]&&(t+=this._subnode[e].size());return t+1}size(){let t=0;for(let e=0;e<4;e++)null!==this._subnode[e]&&(t+=this._subnode[e].size());return t+this._items.size()}addAllItemsFromOverlapping(t,e){if(!this.isSearchMatch(t))return null;e.addAll(this._items);for(let n=0;n<4;n++)null!==this._subnode[n]&&this._subnode[n].addAllItemsFromOverlapping(t,e)}visitItems(t,e){for(let t=this._items.iterator();t.hasNext();)e.visitItem(t.next())}hasItems(){return!this._items.isEmpty()}remove(t,e){if(!this.isSearchMatch(t))return!1;let n=!1;for(let s=0;s<4;s++)if(null!==this._subnode[s]&&(n=this._subnode[s].remove(t,e),n)){this._subnode[s].isPrunable()&&(this._subnode[s]=null);break}return n||(n=this._items.remove(e),n)}visit(t,e){if(!this.isSearchMatch(t))return null;this.visitItems(t,e);for(let n=0;n<4;n++)null!==this._subnode[n]&&this._subnode[n].visit(t,e)}getItems(){return this._items}depth(){let t=0;for(let e=0;e<4;e++)if(null!==this._subnode[e]){const n=this._subnode[e].depth();n>t&&(t=n)}return t+1}isEmpty(){let t=!0;if(this._items.isEmpty()){for(let e=0;e<4;e++)if(null!==this._subnode[e]&&!this._subnode[e].isEmpty()){t=!1;break}}else t=!1;return t}add(t){this._items.add(t)}getClass(){return is}get interfaces_(){return[a]}}function rs(){}is.constructor_=function(){this._items=new x,this._subnode=new Array(4).fill(null)},rs.exponent=function(t){return function(t,e){let n,s,i,r;const o={32:{d:127,c:128,b:0,a:0},64:{d:32752,c:0,b:0,a:0}},l={32:8,64:11}[t];r||(n=e<0||1/e<0,isFinite(e)||(r=o[t],n&&(r.d+=1<<t/4-1),s=Math.pow(2,l)-1,i=0));if(!r){for(s={32:127,64:1023}[t],i=Math.abs(e);i>=2;)s++,i/=2;for(;i<1&&s>0;)s--,i*=2;s<=0&&(i/=2),32===t&&s>254&&(r={d:n?255:127,c:128,b:0,a:0},s=Math.pow(2,l)-1,i=0)}return s}(64,t)-1023},rs.powerOf2=function(t){return Math.pow(2,t)};class os{constructor(){os.constructor_.apply(this,arguments)}static computeQuadLevel(t){const e=t.getWidth(),n=t.getHeight(),s=e>n?e:n;return rs.exponent(s)+1}getLevel(){return this._level}computeKey(){if(1===arguments.length){const t=arguments[0];for(this._level=os.computeQuadLevel(t),this._env=new N,this.computeKey(this._level,t);!this._env.contains(t);)this._level+=1,this.computeKey(this._level,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=rs.powerOf2(t);this._pt.x=Math.floor(e.getMinX()/n)*n,this._pt.y=Math.floor(e.getMinY()/n)*n,this._env.init(this._pt.x,this._pt.x+n,this._pt.y,this._pt.y+n)}}getEnvelope(){return this._env}getCentre(){return new g((this._env.getMinX()+this._env.getMaxX())/2,(this._env.getMinY()+this._env.getMaxY())/2)}getPoint(){return this._pt}getClass(){return os}get interfaces_(){return[]}}os.constructor_=function(){this._pt=new g,this._level=0,this._env=null;const t=arguments[0];this.computeKey(t)};class ls extends is{constructor(){super(),ls.constructor_.apply(this,arguments)}static createNode(t){const e=new os(t);return new ls(e.getEnvelope(),e.getLevel())}static createExpanded(t,e){const n=new N(e);null!==t&&n.expandToInclude(t._env);const s=ls.createNode(n);return null!==t&&s.insertNode(t),s}find(t){const e=is.getSubnodeIndex(t,this._centrex,this._centrey);if(-1===e)return this;if(null!==this._subnode[e]){return this._subnode[e].find(t)}return this}isSearchMatch(t){return null!==t&&this._env.intersects(t)}getSubnode(t){return null===this._subnode[t]&&(this._subnode[t]=this.createSubnode(t)),this._subnode[t]}getEnvelope(){return this._env}getNode(t){const e=is.getSubnodeIndex(t,this._centrex,this._centrey);if(-1!==e){return this.getSubnode(e).getNode(t)}return this}createSubnode(t){let e=0,n=0,s=0,i=0;switch(t){case 0:e=this._env.getMinX(),n=this._centrex,s=this._env.getMinY(),i=this._centrey;break;case 1:e=this._centrex,n=this._env.getMaxX(),s=this._env.getMinY(),i=this._centrey;break;case 2:e=this._env.getMinX(),n=this._centrex,s=this._centrey,i=this._env.getMaxY();break;case 3:e=this._centrex,n=this._env.getMaxX(),s=this._centrey,i=this._env.getMaxY()}const r=new N(e,n,s,i);return new ls(r,this._level-1)}insertNode(t){u.isTrue(null===this._env||this._env.contains(t._env));const e=is.getSubnodeIndex(t._env,this._centrex,this._centrey);if(t._level===this._level-1)this._subnode[e]=t;else{const n=this.createSubnode(e);n.insertNode(t),this._subnode[e]=n}}getClass(){return ls}get interfaces_(){return[]}}ls.constructor_=function(){this._env=null,this._centrex=null,this._centrey=null,this._level=null;const t=arguments[0],e=arguments[1];this._env=t,this._level=e,this._centrex=(t.getMinX()+t.getMaxX())/2,this._centrey=(t.getMinY()+t.getMaxY())/2};class as{constructor(){as.constructor_.apply(this,arguments)}static isZeroWidth(t,e){const n=e-t;if(0===n)return!0;const s=n/Math.max(Math.abs(t),Math.abs(e));return rs.exponent(s)<=as.MIN_BINARY_EXPONENT}getClass(){return as}get interfaces_(){return[]}}as.constructor_=function(){},as.MIN_BINARY_EXPONENT=-50;class cs extends is{constructor(){super(),cs.constructor_.apply(this,arguments)}insert(t,e){const n=is.getSubnodeIndex(t,cs.origin.x,cs.origin.y);if(-1===n)return this.add(e),null;const s=this._subnode[n];if(null===s||!s.getEnvelope().contains(t)){const e=ls.createExpanded(s,t);this._subnode[n]=e}this.insertContained(this._subnode[n],t,e)}isSearchMatch(t){return!0}insertContained(t,e,n){u.isTrue(t.getEnvelope().contains(e));const s=as.isZeroWidth(e.getMinX(),e.getMaxX()),i=as.isZeroWidth(e.getMinY(),e.getMaxY());let r=null;r=s||i?t.find(e):t.getNode(e),r.add(n)}getClass(){return cs}get interfaces_(){return[]}}cs.constructor_=function(){},cs.origin=new g(0,0);class hs{constructor(){hs.constructor_.apply(this,arguments)}insert(t,e){}remove(t,e){}query(){}getClass(){return hs}get interfaces_(){return[]}}hs.constructor_=function(){};class us{constructor(){us.constructor_.apply(this,arguments)}static ensureExtent(t,e){let n=t.getMinX(),s=t.getMaxX(),i=t.getMinY(),r=t.getMaxY();return n!==s&&i!==r?t:(n===s&&(n-=e/2,s=n+e/2),i===r&&(i-=e/2,r=i+e/2),new N(n,s,i,r))}size(){return null!==this._root?this._root.size():0}insert(t,e){this.collectStats(t);const n=us.ensureExtent(t,this._minExtent);this._root.insert(n,e)}query(){if(1===arguments.length){const t=arguments[0],e=new Ye;return this.query(t,e),e.getItems()}if(2===arguments.length){const t=arguments[0],e=arguments[1];this._root.visit(t,e)}}queryAll(){const t=new x;return this._root.addAllItems(t),t}remove(t,e){const n=us.ensureExtent(t,this._minExtent);return this._root.remove(n,e)}collectStats(t){const e=t.getWidth();e<this._minExtent&&e>0&&(this._minExtent=e);const n=t.getHeight();n<this._minExtent&&n>0&&(this._minExtent=n)}depth(){return null!==this._root?this._root.depth():0}isEmpty(){return null===this._root||this._root.isEmpty()}getClass(){return us}get interfaces_(){return[hs,a]}}us.constructor_=function(){this._root=null,this._minExtent=1,this._root=new cs},us.serialVersionUID=-0x678b60c967a25400;var gs=Object.freeze({__proto__:null,Quadtree:us});class ds{constructor(){ds.constructor_.apply(this,arguments)}getBounds(){}getClass(){return ds}get interfaces_(){return[]}}ds.constructor_=function(){};class _s{constructor(){_s.constructor_.apply(this,arguments)}getItem(){return this._item}getBounds(){return this._bounds}getClass(){return _s}get interfaces_(){return[ds,a]}}_s.constructor_=function(){this._bounds=null,this._item=null;const t=arguments[0],e=arguments[1];this._bounds=t,this._item=e};class fs{constructor(){fs.constructor_.apply(this,arguments)}poll(){if(this.isEmpty())return null;const t=this._items.get(1);return this._items.set(1,this._items.get(this._size)),this._size-=1,this.reorder(1),t}size(){return this._size}reorder(t){let e=null;const n=this._items.get(t);for(;2*t<=this._size&&(e=2*t,e!==this._size&&this._items.get(e+1).compareTo(this._items.get(e))<0&&e++,this._items.get(e).compareTo(n)<0);t=e)this._items.set(t,this._items.get(e));this._items.set(t,n)}clear(){this._size=0,this._items.clear()}peek(){if(this.isEmpty())return null;return this._items.get(1)}isEmpty(){return 0===this._size}add(t){this._items.add(null),this._size+=1;let e=this._size;for(this._items.set(0,t);t.compareTo(this._items.get(Math.trunc(e/2)))<0;e/=2)this._items.set(e,this._items.get(Math.trunc(e/2)));this._items.set(e,t)}getClass(){return fs}get interfaces_(){return[]}}fs.constructor_=function(){this._size=null,this._items=null,this._size=0,this._items=new x,this._items.add(null)};class ps{constructor(){ps.constructor_.apply(this,arguments)}getLevel(){return this._level}size(){return this._childBoundables.size()}getChildBoundables(){return this._childBoundables}addChildBoundable(t){u.isTrue(null===this._bounds),this._childBoundables.add(t)}isEmpty(){return this._childBoundables.isEmpty()}getBounds(){return null===this._bounds&&(this._bounds=this.computeBounds()),this._bounds}getClass(){return ps}get interfaces_(){return[ds,a]}}ps.constructor_=function(){if(this._childBoundables=new x,this._bounds=null,this._level=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._level=t}},ps.serialVersionUID=0x5a1e55ec41369800;class ms{constructor(){ms.constructor_.apply(this,arguments)}static area(t){return t.getBounds().getArea()}static isComposite(t){return t instanceof ps}expandToQueue(t,e){const s=ms.isComposite(this._boundable1),i=ms.isComposite(this._boundable2);if(s&&i)return ms.area(this._boundable1)>ms.area(this._boundable2)?(this.expand(this._boundable1,this._boundable2,t,e),null):(this.expand(this._boundable2,this._boundable1,t,e),null);if(s)return this.expand(this._boundable1,this._boundable2,t,e),null;if(i)return this.expand(this._boundable2,this._boundable1,t,e),null;throw new n("neither boundable is composite")}isLeaves(){return!(ms.isComposite(this._boundable1)||ms.isComposite(this._boundable2))}compareTo(t){const e=t;return this._distance<e._distance?-1:this._distance>e._distance?1:0}expand(t,e,n,s){for(let i=t.getChildBoundables().iterator();i.hasNext();){const t=i.next(),r=new ms(t,e,this._itemDistance);r.getDistance()<s&&n.add(r)}}getBoundable(t){return 0===t?this._boundable1:this._boundable2}getDistance(){return this._distance}distance(){return this.isLeaves()?this._itemDistance.distance(this._boundable1,this._boundable2):this._boundable1.getBounds().distance(this._boundable2.getBounds())}getClass(){return ms}get interfaces_(){return[r]}}ms.constructor_=function(){this._boundable1=null,this._boundable2=null,this._distance=null,this._itemDistance=null;const t=arguments[0],e=arguments[1],n=arguments[2];this._boundable1=t,this._boundable2=e,this._itemDistance=n,this._distance=this.distance()};class ys{constructor(){ys.constructor_.apply(this,arguments)}static compareDoubles(t,e){return t>e?1:t<e?-1:0}queryInternal(){if(_(arguments[2],Ae)&&arguments[0]instanceof Object&&arguments[1]instanceof ps){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.getChildBoundables();for(let e=0;e<s.size();e++){const i=s.get(e);this.getIntersectsOp().intersects(i.getBounds(),t)&&(i instanceof ps?this.queryInternal(t,i,n):i instanceof _s?n.visitItem(i.getItem()):u.shouldNeverReachHere())}}else if(_(arguments[2],m)&&arguments[0]instanceof Object&&arguments[1]instanceof ps){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.getChildBoundables();for(let e=0;e<s.size();e++){const i=s.get(e);this.getIntersectsOp().intersects(i.getBounds(),t)&&(i instanceof ps?this.queryInternal(t,i,n):i instanceof _s?n.add(i.getItem()):u.shouldNeverReachHere())}}}getNodeCapacity(){return this._nodeCapacity}lastNode(t){return t.get(t.size()-1)}size(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.size(this._root));if(1===arguments.length){let t=0;for(let e=arguments[0].getChildBoundables().iterator();e.hasNext();){const n=e.next();n instanceof ps?t+=this.size(n):n instanceof _s&&(t+=1)}return t}}removeItem(t,e){let n=null;for(let s=t.getChildBoundables().iterator();s.hasNext();){const t=s.next();t instanceof _s&&t.getItem()===e&&(n=t)}return null!==n&&(t.getChildBoundables().remove(n),!0)}itemsTree(){if(0===arguments.length){this.build();const t=this.itemsTree(this._root);return null===t?new x:t}if(1===arguments.length){const t=arguments[0],e=new x;for(let n=t.getChildBoundables().iterator();n.hasNext();){const t=n.next();if(t instanceof ps){const n=this.itemsTree(t);null!==n&&e.add(n)}else t instanceof _s?e.add(t.getItem()):u.shouldNeverReachHere()}return e.size()<=0?null:e}}insert(t,e){u.isTrue(!this._built,"Cannot insert items into an STR packed R-tree after it has been built."),this._itemBoundables.add(new _s(t,e))}boundablesAtLevel(){if(1===arguments.length){const t=arguments[0],e=new x;return this.boundablesAtLevel(t,this._root,e),e}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(u.isTrue(t>-2),e.getLevel()===t)return n.add(e),null;for(let s=e.getChildBoundables().iterator();s.hasNext();){const e=s.next();e instanceof ps?this.boundablesAtLevel(t,e,n):(u.isTrue(e instanceof _s),-1===t&&n.add(e))}return null}}query(){if(1===arguments.length){const t=arguments[0];this.build();const e=new x;return this.isEmpty()||this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.queryInternal(t,this._root,e),e}if(2===arguments.length){const t=arguments[0],e=arguments[1];if(this.build(),this.isEmpty())return null;this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.queryInternal(t,this._root,e)}}build(){if(this._built)return null;this._root=this._itemBoundables.isEmpty()?this.createNode(0):this.createHigherLevels(this._itemBoundables,-1),this._itemBoundables=null,this._built=!0}getRoot(){return this.build(),this._root}remove(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return this.build(),!!this.getIntersectsOp().intersects(this._root.getBounds(),t)&&this.remove(t,this._root,e)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];let s=this.removeItem(e,n);if(s)return!0;let i=null;for(let r=e.getChildBoundables().iterator();r.hasNext();){const e=r.next();if(this.getIntersectsOp().intersects(e.getBounds(),t)&&(e instanceof ps&&(s=this.remove(t,e,n),s))){i=e;break}}return null!==i&&i.getChildBoundables().isEmpty()&&e.getChildBoundables().remove(i),s}}createHigherLevels(t,e){u.isTrue(!t.isEmpty());const n=this.createParentBoundables(t,e+1);return 1===n.size()?n.get(0):this.createHigherLevels(n,e+1)}depth(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.depth(this._root));if(1===arguments.length){let t=0;for(let e=arguments[0].getChildBoundables().iterator();e.hasNext();){const n=e.next();if(n instanceof ps){const e=this.depth(n);e>t&&(t=e)}}return t+1}}createParentBoundables(t,e){u.isTrue(!t.isEmpty());const n=new x;n.add(this.createNode(e));const s=new x(t);Ee.sort(s,this.getComparator());for(let t=s.iterator();t.hasNext();){const s=t.next();this.lastNode(n).getChildBoundables().size()===this.getNodeCapacity()&&n.add(this.createNode(e)),this.lastNode(n).addChildBoundable(s)}return n}isEmpty(){return this._built?this._root.isEmpty():this._itemBoundables.isEmpty()}getClass(){return ys}get interfaces_(){return[a]}}ys.IntersectsOp=function(){},ys.constructor_=function(){if(this._root=null,this._built=!1,this._itemBoundables=new x,this._nodeCapacity=null,0===arguments.length)ys.constructor_.call(this,ys.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){const t=arguments[0];u.isTrue(t>1,"Node capacity must be greater than 1"),this._nodeCapacity=t}},ys.serialVersionUID=-0x35ef64c82d4c5400,ys.DEFAULT_NODE_CAPACITY=10;class xs{constructor(){xs.constructor_.apply(this,arguments)}distance(t,e){}getClass(){return xs}get interfaces_(){return[]}}xs.constructor_=function(){};class Es extends ys{constructor(){super(),Es.constructor_.apply(this,arguments)}static centreX(t){return Es.avg(t.getMinX(),t.getMaxX())}static avg(t,e){return(t+e)/2}static getItems(t){const e=new Array(t.size()).fill(null);let n=0;for(;!t.isEmpty();){const s=t.poll();e[n]=s.getBoundable(0).getItem(),n++}return e}static centreY(t){return Es.avg(t.getMinY(),t.getMaxY())}createParentBoundablesFromVerticalSlices(t,e){u.isTrue(t.length>0);const n=new x;for(let s=0;s<t.length;s++)n.addAll(this.createParentBoundablesFromVerticalSlice(t[s],e));return n}createNode(t){return new Is(t)}size(){return 0===arguments.length?super.size.call(this):super.size.apply(this,arguments)}insert(){if(!(2===arguments.length&&arguments[1]instanceof Object&&arguments[0]instanceof N))return super.insert.apply(this,arguments);{const t=arguments[0],e=arguments[1];if(t.isNull())return null;super.insert.call(this,t,e)}}getIntersectsOp(){return Es.intersectsOp}verticalSlices(t,e){const n=Math.trunc(Math.ceil(t.size()/e)),s=new Array(e).fill(null),i=t.iterator();for(let t=0;t<e;t++){s[t]=new x;let e=0;for(;i.hasNext()&&e<n;){const n=i.next();s[t].add(n),e++}}return s}query(){if(1===arguments.length){const t=arguments[0];return super.query.call(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];super.query.call(this,t,e)}}getComparator(){return Es.yComparator}createParentBoundablesFromVerticalSlice(t,e){return super.createParentBoundables.call(this,t,e)}remove(){if(2===arguments.length&&arguments[1]instanceof Object&&arguments[0]instanceof N){const t=arguments[0],e=arguments[1];return super.remove.call(this,t,e)}return super.remove.apply(this,arguments)}depth(){return 0===arguments.length?super.depth.call(this):super.depth.apply(this,arguments)}createParentBoundables(t,e){u.isTrue(!t.isEmpty());const n=Math.trunc(Math.ceil(t.size()/this.getNodeCapacity())),s=new x(t);Ee.sort(s,Es.xComparator);const i=this.verticalSlices(s,Math.trunc(Math.ceil(Math.sqrt(n))));return this.createParentBoundablesFromVerticalSlices(i,e)}nearestNeighbour(){if(1===arguments.length){if(_(arguments[0],xs)){const t=arguments[0],e=new ms(this.getRoot(),this.getRoot(),t);return this.nearestNeighbour(e)}if(arguments[0]instanceof ms){const t=arguments[0];return this.nearestNeighbour(t,i.POSITIVE_INFINITY)}}else if(2===arguments.length){if(arguments[0]instanceof Es&&_(arguments[1],xs)){const t=arguments[0],e=arguments[1],n=new ms(this.getRoot(),t.getRoot(),e);return this.nearestNeighbour(n)}if(arguments[0]instanceof ms&&"number"==typeof arguments[1]){const t=arguments[0];let e=arguments[1],n=null;const s=new fs;for(s.add(t);!s.isEmpty()&&e>0;){const t=s.poll(),i=t.getDistance();if(i>=e)break;t.isLeaves()?(e=i,n=t):t.expandToQueue(s,e)}return[n.getBoundable(0).getItem(),n.getBoundable(1).getItem()]}if(arguments[0]instanceof ms&&Number.isInteger(arguments[1])){const t=arguments[0],e=arguments[1];return this.nearestNeighbour(t,i.POSITIVE_INFINITY,e)}}else if(3===arguments.length){if(_(arguments[2],xs)&&arguments[0]instanceof N&&arguments[1]instanceof Object){const t=arguments[0],e=arguments[1],n=arguments[2],s=new _s(t,e),i=new ms(this.getRoot(),s,n);return this.nearestNeighbour(i)[0]}if(Number.isInteger(arguments[2])&&arguments[0]instanceof ms&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2];let s=e;const i=new fs;i.add(t);const r=new fs;for(;!i.isEmpty()&&s>=0;){const t=i.poll(),e=t.getDistance();if(e>=s)break;if(t.isLeaves())if(r.size()<n)r.add(t);else{r.peek().getDistance()>e&&(r.poll(),r.add(t)),s=r.peek().getDistance()}else t.expandToQueue(i,s)}return Es.getItems(r)}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new _s(t,e),r=new ms(this.getRoot(),i,n);return this.nearestNeighbour(r,s)}}getClass(){return Es}get interfaces_(){return[hs,a]}}class Is extends ps{constructor(){super(),Is.constructor_.apply(this,arguments)}computeBounds(){let t=null;for(let e=this.getChildBoundables().iterator();e.hasNext();){const n=e.next();null===t?t=new N(n.getBounds()):t.expandToInclude(n.getBounds())}return t}getClass(){return Is}get interfaces_(){return[]}}Is.constructor_=function(){const t=arguments[0];ps.constructor_.call(this,t)},Es.STRtreeNode=Is,Es.constructor_=function(){if(0===arguments.length)Es.constructor_.call(this,Es.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){const t=arguments[0];ys.constructor_.call(this,t)}},Es.serialVersionUID=0x39920f7d5f261e0,Es.xComparator=new class{get interfaces_(){return[l]}compare(t,e){return ys.compareDoubles(Es.centreX(t.getBounds()),Es.centreX(e.getBounds()))}},Es.yComparator=new class{get interfaces_(){return[l]}compare(t,e){return ys.compareDoubles(Es.centreY(t.getBounds()),Es.centreY(e.getBounds()))}},Es.intersectsOp=new class{get interfaces_(){return[IntersectsOp]}intersects(t,e){return t.intersects(e)}},Es.DEFAULT_NODE_CAPACITY=10;var Ns=Object.freeze({__proto__:null,STRtree:Es}),Cs=Object.freeze({__proto__:null,kdtree:ss,quadtree:gs,strtree:Ns});const Ss=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"];class ws{constructor(t){this.geometryFactory=t||new Ht}read(t){let e;e="string"==typeof t?JSON.parse(t):t;const n=e.type;if(!Ls[n])throw new Error("Unknown GeoJSON type: "+e.type);return-1!==Ss.indexOf(n)?Ls[n].call(this,e.coordinates):"GeometryCollection"===n?Ls[n].call(this,e.geometries):Ls[n].call(this,e)}write(t){const e=t.getGeometryType();if(!Ts[e])throw new Error("Geometry is not supported");return Ts[e].call(this,t)}}const Ls={Feature:function(t){const e={};for(const n in t)e[n]=t[n];if(t.geometry){const n=t.geometry.type;if(!Ls[n])throw new Error("Unknown GeoJSON type: "+t.type);e.geometry=this.read(t.geometry)}return t.bbox&&(e.bbox=Ls.bbox.call(this,t.bbox)),e},FeatureCollection:function(t){const e={};if(t.features){e.features=[];for(let n=0;n<t.features.length;++n)e.features.push(this.read(t.features[n]))}return t.bbox&&(e.bbox=this.parse.bbox.call(this,t.bbox)),e},coordinates:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(new g(s[0],s[1]))}return e},bbox:function(t){return this.geometryFactory.createLinearRing([new g(t[0],t[1]),new g(t[2],t[1]),new g(t[2],t[3]),new g(t[0],t[3]),new g(t[0],t[1])])},Point:function(t){const e=new g(t[0],t[1]);return this.geometryFactory.createPoint(e)},MultiPoint:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(Ls.Point.call(this,t[n]));return this.geometryFactory.createMultiPoint(e)},LineString:function(t){const e=Ls.coordinates.call(this,t);return this.geometryFactory.createLineString(e)},MultiLineString:function(t){const e=[];for(let n=0;n<t.length;++n)e.push(Ls.LineString.call(this,t[n]));return this.geometryFactory.createMultiLineString(e)},Polygon:function(t){const e=Ls.coordinates.call(this,t[0]),n=this.geometryFactory.createLinearRing(e),s=[];for(let e=1;e<t.length;++e){const n=t[e],i=Ls.coordinates.call(this,n),r=this.geometryFactory.createLinearRing(i);s.push(r)}return this.geometryFactory.createPolygon(n,s)},MultiPolygon:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(Ls.Polygon.call(this,s))}return this.geometryFactory.createMultiPolygon(e)},GeometryCollection:function(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n];e.push(this.read(s))}return this.geometryFactory.createGeometryCollection(e)}},Ts={coordinate:function(t){return[t.x,t.y]},Point:function(t){return{type:"Point",coordinates:Ts.coordinate.call(this,t.getCoordinate())}},MultiPoint:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=Ts.Point.call(this,s);e.push(i.coordinates)}return{type:"MultiPoint",coordinates:e}},LineString:function(t){const e=[],n=t.getCoordinates();for(let t=0;t<n.length;++t){const s=n[t];e.push(Ts.coordinate.call(this,s))}return{type:"LineString",coordinates:e}},MultiLineString:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=Ts.LineString.call(this,s);e.push(i.coordinates)}return{type:"MultiLineString",coordinates:e}},Polygon:function(t){const e=[],n=Ts.LineString.call(this,t._shell);e.push(n.coordinates);for(let n=0;n<t._holes.length;++n){const s=t._holes[n],i=Ts.LineString.call(this,s);e.push(i.coordinates)}return{type:"Polygon",coordinates:e}},MultiPolygon:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=Ts.Polygon.call(this,s);e.push(i.coordinates)}return{type:"MultiPolygon",coordinates:e}},GeometryCollection:function(t){const e=[];for(let n=0;n<t._geometries.length;++n){const s=t._geometries[n],i=s.getGeometryType();e.push(Ts[i].call(this,s))}return{type:"GeometryCollection",geometries:e}}};function Rs(t){return[t.x,t.y]}var Ps=Object.freeze({__proto__:null,GeoJSONReader:class{constructor(t){this.parser=new ws(t||new Ht)}read(t){return this.parser.read(t)}},GeoJSONWriter:class{constructor(){this.parser=new ws(this.geometryFactory)}write(t){return this.parser.write(t)}},OL3Parser:class{constructor(t,e){this.geometryFactory=t||new Ht,this.ol=e||"undefined"!=typeof ol&&ol}inject(t,e,n,s,i,r,o,l){this.ol={geom:{Point:t,LineString:e,LinearRing:n,Polygon:s,MultiPoint:i,MultiLineString:r,MultiPolygon:o,GeometryCollection:l}}}read(t){const e=this.ol;return t instanceof e.geom.Point?this.convertFromPoint(t):t instanceof e.geom.LineString?this.convertFromLineString(t):t instanceof e.geom.LinearRing?this.convertFromLinearRing(t):t instanceof e.geom.Polygon?this.convertFromPolygon(t):t instanceof e.geom.MultiPoint?this.convertFromMultiPoint(t):t instanceof e.geom.MultiLineString?this.convertFromMultiLineString(t):t instanceof e.geom.MultiPolygon?this.convertFromMultiPolygon(t):t instanceof e.geom.GeometryCollection?this.convertFromCollection(t):void 0}convertFromPoint(t){const e=t.getCoordinates();return this.geometryFactory.createPoint(new g(e[0],e[1]))}convertFromLineString(t){return this.geometryFactory.createLineString(t.getCoordinates().map((function(t){return new g(t[0],t[1])})))}convertFromLinearRing(t){return this.geometryFactory.createLinearRing(t.getCoordinates().map((function(t){return new g(t[0],t[1])})))}convertFromPolygon(t){const e=t.getLinearRings();let n=null;const s=[];for(let t=0;t<e.length;t++){const i=this.convertFromLinearRing(e[t]);0===t?n=i:s.push(i)}return this.geometryFactory.createPolygon(n,s)}convertFromMultiPoint(t){const e=t.getPoints().map((function(t){return this.convertFromPoint(t)}),this);return this.geometryFactory.createMultiPoint(e)}convertFromMultiLineString(t){const e=t.getLineStrings().map((function(t){return this.convertFromLineString(t)}),this);return this.geometryFactory.createMultiLineString(e)}convertFromMultiPolygon(t){const e=t.getPolygons().map((function(t){return this.convertFromPolygon(t)}),this);return this.geometryFactory.createMultiPolygon(e)}convertFromCollection(t){const e=t.getGeometries().map((function(t){return this.read(t)}),this);return this.geometryFactory.createGeometryCollection(e)}write(t){return"Point"===t.getGeometryType()?this.convertToPoint(t.getCoordinate()):"LineString"===t.getGeometryType()?this.convertToLineString(t):"LinearRing"===t.getGeometryType()?this.convertToLinearRing(t):"Polygon"===t.getGeometryType()?this.convertToPolygon(t):"MultiPoint"===t.getGeometryType()?this.convertToMultiPoint(t):"MultiLineString"===t.getGeometryType()?this.convertToMultiLineString(t):"MultiPolygon"===t.getGeometryType()?this.convertToMultiPolygon(t):"GeometryCollection"===t.getGeometryType()?this.convertToCollection(t):void 0}convertToPoint(t){return new this.ol.geom.Point([t.x,t.y])}convertToLineString(t){const e=t._points._coordinates.map(Rs);return new this.ol.geom.LineString(e)}convertToLinearRing(t){const e=t._points._coordinates.map(Rs);return new this.ol.geom.LinearRing(e)}convertToPolygon(t){const e=[t._shell._points._coordinates.map(Rs)];for(let n=0;n<t._holes.length;n++)e.push(t._holes[n]._points._coordinates.map(Rs));return new this.ol.geom.Polygon(e)}convertToMultiPoint(t){return new this.ol.geom.MultiPoint(t.getCoordinates().map(Rs))}convertToMultiLineString(t){const e=[];for(let n=0;n<t._geometries.length;n++)e.push(this.convertToLineString(t._geometries[n]).getCoordinates());return new this.ol.geom.MultiLineString(e)}convertToMultiPolygon(t){const e=[];for(let n=0;n<t._geometries.length;n++)e.push(this.convertToPolygon(t._geometries[n]).getCoordinates());return new this.ol.geom.MultiPolygon(e)}convertToCollection(t){const e=[];for(let n=0;n<t._geometries.length;n++){const s=t._geometries[n];e.push(this.write(s))}return new this.ol.geom.GeometryCollection(e)}},WKTReader:class{constructor(t){this.parser=new Kt(t||new Ht)}read(t){return this.parser.read(t)}},WKTWriter:Jt});class vs{constructor(){vs.constructor_.apply(this,arguments)}static relativeSign(t,e){return t<e?-1:t>e?1:0}static compare(t,e,n){if(e.equals2D(n))return 0;const s=vs.relativeSign(e.x,n.x),i=vs.relativeSign(e.y,n.y);switch(t){case 0:return vs.compareValue(s,i);case 1:return vs.compareValue(i,s);case 2:return vs.compareValue(i,-s);case 3:return vs.compareValue(-s,i);case 4:return vs.compareValue(-s,-i);case 5:return vs.compareValue(-i,-s);case 6:return vs.compareValue(-i,s);case 7:return vs.compareValue(s,-i)}return u.shouldNeverReachHere("invalid octant value"),0}static compareValue(t,e){return t<0?-1:t>0?1:e<0?-1:e>0?1:0}getClass(){return vs}get interfaces_(){return[]}}vs.constructor_=function(){};class Os{constructor(){Os.constructor_.apply(this,arguments)}getCoordinate(){return this.coord}print(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex)}compareTo(t){const e=t;return this.segmentIndex<e.segmentIndex?-1:this.segmentIndex>e.segmentIndex?1:this.coord.equals2D(e.coord)?0:vs.compare(this._segmentOctant,this.coord,e.coord)}isEndPoint(t){return 0===this.segmentIndex&&!this._isInterior||this.segmentIndex===t}isInterior(){return this._isInterior}getClass(){return Os}get interfaces_(){return[r]}}Os.constructor_=function(){this._segString=null,this.coord=null,this.segmentIndex=null,this._segmentOctant=null,this._isInterior=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._segString=t,this.coord=new g(e),this.segmentIndex=n,this._segmentOctant=s,this._isInterior=!e.equals2D(t.getCoordinate(n))};class bs{constructor(){bs.constructor_.apply(this,arguments)}getSplitCoordinates(){const t=new I;this.addEndpoints();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next();this.addEdgeCoordinates(n,s,t),n=s}return t.toCoordinateArray()}addCollapsedNodes(){const t=new x;this.findCollapsesFromInsertedNodes(t),this.findCollapsesFromExistingVertices(t);for(let e=t.iterator();e.hasNext();){const t=e.next().intValue();this.add(this._edge.getCoordinate(t),t)}}print(t){t.println("Intersections:");for(let e=this.iterator();e.hasNext();){e.next().print(t)}}findCollapsesFromExistingVertices(t){for(let e=0;e<this._edge.size()-2;e++){const n=this._edge.getCoordinate(e),s=(this._edge.getCoordinate(e+1),this._edge.getCoordinate(e+2));n.equals2D(s)&&t.add(new L(e+1))}}addEdgeCoordinates(t,e,n){e.segmentIndex,t.segmentIndex;const s=this._edge.getCoordinate(e.segmentIndex),i=e.isInterior()||!e.coord.equals2D(s);n.add(new g(t.coord),!1);for(let s=t.segmentIndex+1;s<=e.segmentIndex;s++)n.add(this._edge.getCoordinate(s));i&&n.add(new g(e.coord))}iterator(){return this._nodeMap.values().iterator()}addSplitEdges(t){this.addEndpoints(),this.addCollapsedNodes();const e=this.iterator();let n=e.next();for(;e.hasNext();){const s=e.next(),i=this.createSplitEdge(n,s);t.add(i),n=s}}findCollapseIndex(t,e,n){if(!t.coord.equals2D(e.coord))return!1;let s=e.segmentIndex-t.segmentIndex;return e.isInterior()||s--,1===s&&(n[0]=t.segmentIndex+1,!0)}findCollapsesFromInsertedNodes(t){const e=new Array(1).fill(null),n=this.iterator();let s=n.next();for(;n.hasNext();){const i=n.next();this.findCollapseIndex(s,i,e)&&t.add(new L(e[0])),s=i}}getEdge(){return this._edge}addEndpoints(){const t=this._edge.size()-1;this.add(this._edge.getCoordinate(0),0),this.add(this._edge.getCoordinate(t),t)}createSplitEdge(t,e){let n=e.segmentIndex-t.segmentIndex+2;const s=this._edge.getCoordinate(e.segmentIndex),i=e.isInterior()||!e.coord.equals2D(s);i||n--;const r=new Array(n).fill(null);let o=0;r[o++]=new g(t.coord);for(let n=t.segmentIndex+1;n<=e.segmentIndex;n++)r[o++]=this._edge.getCoordinate(n);return i&&(r[o]=new g(e.coord)),new Fs(r,this._edge.getData())}add(t,e){const n=new Os(this._edge,t,e,this._edge.getSegmentOctant(e)),s=this._nodeMap.get(n);return null!==s?(u.isTrue(s.coord.equals2D(t),"Found equal nodes with different coordinates"),s):(this._nodeMap.put(n,n),n)}checkSplitEdgesCorrectness(t){const e=this._edge.getCoordinates(),n=t.get(0).getCoordinate(0);if(!n.equals2D(e[0]))throw new c("bad split edge start point at "+n);const s=t.get(t.size()-1).getCoordinates(),i=s[s.length-1];if(!i.equals2D(e[e.length-1]))throw new c("bad split edge end point at "+i)}getClass(){return bs}get interfaces_(){return[]}}bs.constructor_=function(){this._nodeMap=new rt,this._edge=null;const t=arguments[0];this._edge=t};class Ms{constructor(){Ms.constructor_.apply(this,arguments)}static octant(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new n("Cannot compute the octant for point ( "+t+", "+e+" )");const s=Math.abs(t),i=Math.abs(e);return t>=0?e>=0?s>=i?0:1:s>=i?7:6:e>=0?s>=i?3:2:s>=i?4:5}if(arguments[0]instanceof g&&arguments[1]instanceof g){const t=arguments[0],e=arguments[1],s=e.x-t.x,i=e.y-t.y;if(0===s&&0===i)throw new n("Cannot compute the octant for two identical points "+t);return Ms.octant(s,i)}}getClass(){return Ms}get interfaces_(){return[]}}Ms.constructor_=function(){};class Ds{constructor(){Ds.constructor_.apply(this,arguments)}getCoordinates(){}size(){}getCoordinate(t){}isClosed(){}setData(t){}getData(){}getClass(){return Ds}get interfaces_(){return[]}}Ds.constructor_=function(){};class As{constructor(){As.constructor_.apply(this,arguments)}addIntersection(t,e){}getClass(){return As}get interfaces_(){return[Ds]}}As.constructor_=function(){};class Fs{constructor(){Fs.constructor_.apply(this,arguments)}static getNodedSubstrings(){if(1===arguments.length){const t=arguments[0],e=new x;return Fs.getNodedSubstrings(t,e),e}if(2===arguments.length){const t=arguments[0],e=arguments[1];for(let n=t.iterator();n.hasNext();){n.next().getNodeList().addSplitEdges(e)}}}getCoordinates(){return this._pts}size(){return this._pts.length}getCoordinate(t){return this._pts[t]}isClosed(){return this._pts[0].equals(this._pts[this._pts.length-1])}getSegmentOctant(t){return t===this._pts.length-1?-1:this.safeOctant(this.getCoordinate(t),this.getCoordinate(t+1))}setData(t){this._data=t}safeOctant(t,e){return t.equals2D(e)?0:Ms.octant(t,e)}getData(){return this._data}addIntersection(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.addIntersectionNode(t,e)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[3],s=new g(t.getIntersection(n));this.addIntersection(s,e)}}toString(){return Jt.toLineString(new zt(this._pts))}getNodeList(){return this._nodeList}addIntersectionNode(t,e){let n=e;const s=n+1;if(s<this._pts.length){const e=this._pts[s];t.equals2D(e)&&(n=s)}return this._nodeList.add(t,n)}addIntersections(t,e,n){for(let s=0;s<t.getIntersectionNum();s++)this.addIntersection(t,e,n,s)}getClass(){return Fs}get interfaces_(){return[As]}}Fs.constructor_=function(){this._nodeList=new bs(this),this._pts=null,this._data=null;const t=arguments[0],e=arguments[1];this._pts=t,this._data=e};class Gs{constructor(){Gs.constructor_.apply(this,arguments)}overlap(){if(2===arguments.length);else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];t.getLineSegment(e,this._overlapSeg1),n.getLineSegment(s,this._overlapSeg2),this.overlap(this._overlapSeg1,this._overlapSeg2)}}getClass(){return Gs}get interfaces_(){return[]}}Gs.constructor_=function(){this._overlapSeg1=new ee,this._overlapSeg2=new ee};class qs{constructor(){qs.constructor_.apply(this,arguments)}getLineSegment(t,e){e.p0=this._pts[t],e.p1=this._pts[t+1]}computeSelect(t,e,n,s){const i=this._pts[e],r=this._pts[n];if(n-e==1)return s.select(this,e),null;if(!t.intersects(i,r))return null;const o=Math.trunc((e+n)/2);e<o&&this.computeSelect(t,e,o,s),o<n&&this.computeSelect(t,o,n,s)}getCoordinates(){const t=new Array(this._end-this._start+1).fill(null);let e=0;for(let n=this._start;n<=this._end;n++)t[e++]=this._pts[n];return t}computeOverlaps(){if(2===arguments.length){const t=arguments[0],e=arguments[1];this.computeOverlaps(this._start,this._end,t,t._start,t._end,e)}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];if(e-t==1&&i-s==1)return r.overlap(this,t,n,s),null;if(!this.overlaps(t,e,n,s,i))return null;const o=Math.trunc((t+e)/2),l=Math.trunc((s+i)/2);t<o&&(s<l&&this.computeOverlaps(t,o,n,s,l,r),l<i&&this.computeOverlaps(t,o,n,l,i,r)),o<e&&(s<l&&this.computeOverlaps(o,e,n,s,l,r),l<i&&this.computeOverlaps(o,e,n,l,i,r))}}setId(t){this._id=t}select(t,e){this.computeSelect(t,this._start,this._end,e)}getEnvelope(){if(null===this._env){const t=this._pts[this._start],e=this._pts[this._end];this._env=new N(t,e)}return this._env}overlaps(t,e,n,s,i){return N.intersects(this._pts[t],this._pts[e],n._pts[s],n._pts[i])}getEndIndex(){return this._end}getStartIndex(){return this._start}getContext(){return this._context}getId(){return this._id}getClass(){return qs}get interfaces_(){return[]}}qs.constructor_=function(){this._pts=null,this._start=null,this._end=null,this._env=null,this._context=null,this._id=null;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._pts=t,this._start=e,this._end=n,this._context=s};class Bs{constructor(){Bs.constructor_.apply(this,arguments)}static getChainStartIndices(t){let e=0;const n=new x;n.add(new L(e));do{const s=Bs.findChainEnd(t,e);n.add(new L(s)),e=s}while(e<t.length-1);return Bs.toIntArray(n)}static findChainEnd(t,e){let n=e;for(;n<t.length-1&&t[n].equals2D(t[n+1]);)n++;if(n>=t.length-1)return t.length-1;const s=In.quadrant(t[n],t[n+1]);let i=e+1;for(;i<t.length;){if(!t[i-1].equals2D(t[i])){if(In.quadrant(t[i-1],t[i])!==s)break}i++}return i-1}static getChains(){if(1===arguments.length){const t=arguments[0];return Bs.getChains(t,null)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=new x,s=Bs.getChainStartIndices(t);for(let i=0;i<s.length-1;i++){const r=new qs(t,s[i],s[i+1],e);n.add(r)}return n}}static toIntArray(t){const e=new Array(t.size()).fill(null);for(let n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e}getClass(){return Bs}get interfaces_(){return[]}}Bs.constructor_=function(){};class Vs{constructor(){Vs.constructor_.apply(this,arguments)}computeNodes(t){}getNodedSubstrings(){}getClass(){return Vs}get interfaces_(){return[]}}Vs.constructor_=function(){};class zs{constructor(){zs.constructor_.apply(this,arguments)}setSegmentIntersector(t){this._segInt=t}getClass(){return zs}get interfaces_(){return[Vs]}}zs.constructor_=function(){if(this._segInt=null,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.setSegmentIntersector(t)}};class Ys extends zs{constructor(){super(),Ys.constructor_.apply(this,arguments)}getMonotoneChains(){return this._monoChains}getNodedSubstrings(){return Fs.getNodedSubstrings(this._nodedSegStrings)}getIndex(){return this._index}add(t){for(let e=Bs.getChains(t.getCoordinates(),t).iterator();e.hasNext();){const t=e.next();t.setId(this._idCounter++),this._index.insert(t.getEnvelope(),t),this._monoChains.add(t)}}computeNodes(t){this._nodedSegStrings=t;for(let e=t.iterator();e.hasNext();)this.add(e.next());this.intersectChains()}intersectChains(){const t=new Us(this._segInt);for(let e=this._monoChains.iterator();e.hasNext();){const n=e.next();for(let e=this._index.query(n.getEnvelope()).iterator();e.hasNext();){const s=e.next();if(s.getId()>n.getId()&&(n.computeOverlaps(s,t),this._nOverlaps++),this._segInt.isDone())return null}}}getClass(){return Ys}get interfaces_(){return[]}}class Us extends Gs{constructor(){super(),Us.constructor_.apply(this,arguments)}overlap(){if(4!==arguments.length)return super.overlap.apply(this,arguments);{const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=t.getContext(),r=n.getContext();this._si.processIntersections(i,e,r,s)}}getClass(){return Us}get interfaces_(){return[]}}Us.constructor_=function(){this._si=null;const t=arguments[0];this._si=t},Ys.SegmentOverlapAction=Us,Ys.constructor_=function(){if(this._monoChains=new x,this._index=new Es,this._idCounter=0,this._nodedSegStrings=null,this._nOverlaps=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];zs.constructor_.call(this,t)}};class ks{constructor(){ks.constructor_.apply(this,arguments)}rescale(){if(_(arguments[0],f)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.rescale(e.getCoordinates())}}else if(arguments[0]instanceof Array){const t=arguments[0];let e=null,n=null;2===t.length&&(e=new g(t[0]),n=new g(t[1]));for(let e=0;e<t.length;e++)t[e].x=t[e].x/this._scaleFactor+this._offsetX,t[e].y=t[e].y/this._scaleFactor+this._offsetY;2===t.length&&t[0].equals2D(t[1])&&O.out.println(t)}}scale(){if(_(arguments[0],f)){const t=arguments[0],e=new x(t.size());for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new Fs(this.scale(t.getCoordinates()),t.getData()))}return e}if(arguments[0]instanceof Array){const t=arguments[0],e=new Array(t.length).fill(null);for(let n=0;n<t.length;n++)e[n]=new g(Math.round((t[n].x-this._offsetX)*this._scaleFactor),Math.round((t[n].y-this._offsetY)*this._scaleFactor),t[n].z);return X.removeRepeatedPoints(e)}}isIntegerPrecision(){return 1===this._scaleFactor}getNodedSubstrings(){const t=this._noder.getNodedSubstrings();return this._isScaled&&this.rescale(t),t}computeNodes(t){let e=t;this._isScaled&&(e=this.scale(t)),this._noder.computeNodes(e)}getClass(){return ks}get interfaces_(){return[Vs]}}ks.constructor_=function(){if(this._noder=null,this._scaleFactor=null,this._offsetX=null,this._offsetY=null,this._isScaled=!1,2===arguments.length){const t=arguments[0],e=arguments[1];ks.constructor_.call(this,t,e,0,0)}else if(4===arguments.length){const t=arguments[0],e=arguments[1];this._noder=t,this._scaleFactor=e,this._isScaled=!this.isIntegerPrecision()}};var Xs=Object.freeze({__proto__:null,MCIndexNoder:Ys,ScaledNoder:ks,SegmentString:Ds});class Hs{constructor(){Hs.constructor_.apply(this,arguments)}static isSimple(){if(1===arguments.length){const t=arguments[0];return new Hs(t).isSimple()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return new Hs(t,e).isSimple()}}isSimpleMultiPoint(t){if(t.isEmpty())return!0;const e=new at;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n).getCoordinate();if(e.contains(s))return this._nonSimpleLocation=s,!1;e.add(s)}return!0}isSimplePolygonal(t){for(let e=xe.getLines(t).iterator();e.hasNext();){const t=e.next();if(!this.isSimpleLinearGeometry(t))return!1}return!0}hasClosedEndpointIntersection(t){const e=new rt;for(let n=t.getEdgeIterator();n.hasNext();){const t=n.next(),s=(t.getMaximumSegmentIndex(),t.isClosed()),i=t.getCoordinate(0);this.addEndpoint(e,i,s);const r=t.getCoordinate(t.getNumPoints()-1);this.addEndpoint(e,r,s)}for(let t=e.values().iterator();t.hasNext();){const e=t.next();if(e.isClosed&&2!==e.degree)return this._nonSimpleLocation=e.getCoordinate(),!0}return!1}getNonSimpleLocation(){return this._nonSimpleLocation}isSimpleLinearGeometry(t){if(t.isEmpty())return!0;const e=new Qn(0,t),n=new te,s=e.computeSelfNodes(n,!0);return!s.hasIntersection()||(s.hasProperIntersection()?(this._nonSimpleLocation=s.getProperIntersectionPoint(),!1):!this.hasNonEndpointIntersection(e)&&(!this._isClosedEndpointsInInterior||!this.hasClosedEndpointIntersection(e)))}hasNonEndpointIntersection(t){for(let e=t.getEdgeIterator();e.hasNext();){const t=e.next(),n=t.getMaximumSegmentIndex();for(let e=t.getEdgeIntersectionList().iterator();e.hasNext();){const t=e.next();if(!t.isEndPoint(n))return this._nonSimpleLocation=t.getCoordinate(),!0}}return!1}addEndpoint(t,e,n){let s=t.get(e);null===s&&(s=new Ws(e),t.put(e,s)),s.addEndpoint(n)}computeSimple(t){return this._nonSimpleLocation=null,!!t.isEmpty()||(t instanceof Tt||t instanceof ft?this.isSimpleLinearGeometry(t):t instanceof Mt?this.isSimpleMultiPoint(t):_(t,Ot)?this.isSimplePolygonal(t):!(t instanceof _t)||this.isSimpleGeometryCollection(t))}isSimple(){return this._nonSimpleLocation=null,this.computeSimple(this._inputGeom)}isSimpleGeometryCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(!this.computeSimple(n))return!1}return!0}getClass(){return Hs}get interfaces_(){return[]}}class Ws{constructor(){Ws.constructor_.apply(this,arguments)}addEndpoint(t){this.degree++,this.isClosed|=t}getCoordinate(){return this.pt}getClass(){return Ws}get interfaces_(){return[]}}Ws.constructor_=function(){this.pt=null,this.isClosed=null,this.degree=null;const t=arguments[0];this.pt=t,this.isClosed=!1,this.degree=0},Hs.EndpointInfo=Ws,Hs.constructor_=function(){if(this._inputGeom=null,this._isClosedEndpointsInInterior=!0,this._nonSimpleLocation=null,1===arguments.length){const t=arguments[0];this._inputGeom=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._inputGeom=t,this._isClosedEndpointsInInterior=!e.isInBoundary(2)}};class js{constructor(){js.constructor_.apply(this,arguments)}static bufferDistanceError(t){const e=Math.PI/2/t;return 1-Math.cos(e/2)}getEndCapStyle(){return this._endCapStyle}isSingleSided(){return this._isSingleSided}setQuadrantSegments(t){this._quadrantSegments=t,0===this._quadrantSegments&&(this._joinStyle=js.JOIN_BEVEL),this._quadrantSegments<0&&(this._joinStyle=js.JOIN_MITRE,this._mitreLimit=Math.abs(this._quadrantSegments)),t<=0&&(this._quadrantSegments=1),this._joinStyle!==js.JOIN_ROUND&&(this._quadrantSegments=js.DEFAULT_QUADRANT_SEGMENTS)}getJoinStyle(){return this._joinStyle}setJoinStyle(t){this._joinStyle=t}setSimplifyFactor(t){this._simplifyFactor=t<0?0:t}getSimplifyFactor(){return this._simplifyFactor}getQuadrantSegments(){return this._quadrantSegments}setEndCapStyle(t){this._endCapStyle=t}getMitreLimit(){return this._mitreLimit}setMitreLimit(t){this._mitreLimit=t}setSingleSided(t){this._isSingleSided=t}getClass(){return js}get interfaces_(){return[]}}js.constructor_=function(){if(this._quadrantSegments=js.DEFAULT_QUADRANT_SEGMENTS,this._endCapStyle=js.CAP_ROUND,this._joinStyle=js.JOIN_ROUND,this._mitreLimit=js.DEFAULT_MITRE_LIMIT,this._isSingleSided=!1,this._simplifyFactor=js.DEFAULT_SIMPLIFY_FACTOR,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.setQuadrantSegments(t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.setQuadrantSegments(t),this.setEndCapStyle(e)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this.setQuadrantSegments(t),this.setEndCapStyle(e),this.setJoinStyle(n),this.setMitreLimit(s)}},js.CAP_ROUND=1,js.CAP_FLAT=2,js.CAP_SQUARE=3,js.JOIN_ROUND=1,js.JOIN_MITRE=2,js.JOIN_BEVEL=3,js.DEFAULT_QUADRANT_SEGMENTS=8,js.DEFAULT_MITRE_LIMIT=5,js.DEFAULT_SIMPLIFY_FACTOR=.01;class Ks{constructor(){Ks.constructor_.apply(this,arguments)}getCoordinate(){return this._minCoord}getRightmostSide(t,e){let n=this.getRightmostSideOfSegment(t,e);return n<0&&(n=this.getRightmostSideOfSegment(t,e-1)),n<0&&(this._minCoord=null,this.checkForRightmostCoordinate(t)),n}findRightmostEdgeAtVertex(){const t=this._minDe.getEdge().getCoordinates();u.isTrue(this._minIndex>0&&this._minIndex<t.length,"rightmost point expected to be interior vertex of edge");const e=t[this._minIndex-1],n=t[this._minIndex+1],s=v.index(this._minCoord,n,e);let i=!1;(e.y<this._minCoord.y&&n.y<this._minCoord.y&&s===v.COUNTERCLOCKWISE||e.y>this._minCoord.y&&n.y>this._minCoord.y&&s===v.CLOCKWISE)&&(i=!0),i&&(this._minIndex=this._minIndex-1)}getRightmostSideOfSegment(t,e){const n=t.getEdge().getCoordinates();if(e<0||e+1>=n.length)return-1;if(n[e].y===n[e+1].y)return-1;let s=Pn.LEFT;return n[e].y<n[e+1].y&&(s=Pn.RIGHT),s}getEdge(){return this._orientedDe}checkForRightmostCoordinate(t){const e=t.getEdge().getCoordinates();for(let n=0;n<e.length-1;n++)(null===this._minCoord||e[n].x>this._minCoord.x)&&(this._minDe=t,this._minIndex=n,this._minCoord=e[n])}findRightmostEdgeAtNode(){const t=this._minDe.getNode().getEdges();this._minDe=t.getRightmostEdge(),this._minDe.isForward()||(this._minDe=this._minDe.getSym(),this._minIndex=this._minDe.getEdge().getCoordinates().length-1)}findEdge(t){for(let e=t.iterator();e.hasNext();){const t=e.next();t.isForward()&&this.checkForRightmostCoordinate(t)}u.isTrue(0!==this._minIndex||this._minCoord.equals(this._minDe.getCoordinate()),"inconsistency in rightmost processing"),0===this._minIndex?this.findRightmostEdgeAtNode():this.findRightmostEdgeAtVertex(),this._orientedDe=this._minDe,this.getRightmostSide(this._minDe,this._minIndex)===Pn.LEFT&&(this._orientedDe=this._minDe.getSym())}getClass(){return Ks}get interfaces_(){return[]}}function Zs(){this.array_=[]}Ks.constructor_=function(){this._minIndex=-1,this._minCoord=null,this._minDe=null,this._orientedDe=null},Zs.prototype.addLast=function(t){this.array_.push(t)},Zs.prototype.removeFirst=function(){return this.array_.shift()},Zs.prototype.isEmpty=function(){return 0===this.array_.length};class Qs{constructor(){Qs.constructor_.apply(this,arguments)}clearVisitedEdges(){for(let t=this._dirEdgeList.iterator();t.hasNext();){t.next().setVisited(!1)}}getRightmostCoordinate(){return this._rightMostCoord}computeNodeDepth(t){let e=null;for(let n=t.getEdges().iterator();n.hasNext();){const t=n.next();if(t.isVisited()||t.getSym().isVisited()){e=t;break}}if(null===e)throw new Wn("unable to find edge to compute depths at "+t.getCoordinate());t.getEdges().computeDepths(e);for(let e=t.getEdges().iterator();e.hasNext();){const t=e.next();t.setVisited(!0),this.copySymDepths(t)}}computeDepth(t){this.clearVisitedEdges();const e=this._finder.getEdge();e.getNode(),e.getLabel();e.setEdgeDepths(Pn.RIGHT,t),this.copySymDepths(e),this.computeDepths(e)}create(t){this.addReachable(t),this._finder.findEdge(this._dirEdgeList),this._rightMostCoord=this._finder.getCoordinate()}findResultEdges(){for(let t=this._dirEdgeList.iterator();t.hasNext();){const e=t.next();e.getDepth(Pn.RIGHT)>=1&&e.getDepth(Pn.LEFT)<=0&&!e.isInteriorAreaEdge()&&e.setInResult(!0)}}computeDepths(t){const e=new J,n=new Zs,s=t.getNode();for(n.addLast(s),e.add(s),t.setVisited(!0);!n.isEmpty();){const t=n.removeFirst();e.add(t),this.computeNodeDepth(t);for(let s=t.getEdges().iterator();s.hasNext();){const t=s.next().getSym();if(t.isVisited())continue;const i=t.getNode();e.contains(i)||(n.addLast(i),e.add(i))}}}compareTo(t){const e=t;return this._rightMostCoord.x<e._rightMostCoord.x?-1:this._rightMostCoord.x>e._rightMostCoord.x?1:0}getEnvelope(){if(null===this._env){const t=new N;for(let e=this._dirEdgeList.iterator();e.hasNext();){const n=e.next().getEdge().getCoordinates();for(let e=0;e<n.length-1;e++)t.expandToInclude(n[e])}this._env=t}return this._env}addReachable(t){const e=new on;for(e.add(t);!e.empty();){const t=e.pop();this.add(t,e)}}copySymDepths(t){const e=t.getSym();e.setDepth(Pn.LEFT,t.getDepth(Pn.RIGHT)),e.setDepth(Pn.RIGHT,t.getDepth(Pn.LEFT))}add(t,e){t.setVisited(!0),this._nodes.add(t);for(let n=t.getEdges().iterator();n.hasNext();){const t=n.next();this._dirEdgeList.add(t);const s=t.getSym().getNode();s.isVisited()||e.push(s)}}getNodes(){return this._nodes}getDirectedEdges(){return this._dirEdgeList}getClass(){return Qs}get interfaces_(){return[r]}}Qs.constructor_=function(){this._finder=null,this._dirEdgeList=new x,this._nodes=new x,this._rightMostCoord=null,this._env=null,this._finder=new Ks};class Js{constructor(){Js.constructor_.apply(this,arguments)}computeRing(){if(null!==this._ring)return null;const t=new Array(this._pts.size()).fill(null);for(let e=0;e<this._pts.size();e++)t[e]=this._pts.get(e);this._ring=this._geometryFactory.createLinearRing(t),this._isHole=v.isCCW(this._ring.getCoordinates())}isIsolated(){return 1===this._label.getGeometryCount()}computePoints(t){this._startDe=t;let e=t,n=!0;do{if(null===e)throw new Wn("Found null DirectedEdge");if(e.getEdgeRing()===this)throw new Wn("Directed Edge visited twice during ring-building at "+e.getCoordinate());this._edges.add(e);const t=e.getLabel();u.isTrue(t.isArea()),this.mergeLabel(t),this.addPoints(e.getEdge(),e.isForward(),n),n=!1,this.setEdgeRing(e,this),e=this.getNext(e)}while(e!==this._startDe)}getLinearRing(){return this._ring}getCoordinate(t){return this._pts.get(t)}computeMaxNodeDegree(){this._maxNodeDegree=0;let t=this._startDe;do{const e=t.getNode().getEdges().getOutgoingDegree(this);e>this._maxNodeDegree&&(this._maxNodeDegree=e),t=this.getNext(t)}while(t!==this._startDe);this._maxNodeDegree*=2}addPoints(t,e,n){const s=t.getCoordinates();if(e){let t=1;n&&(t=0);for(let e=t;e<s.length;e++)this._pts.add(s[e])}else{let t=s.length-2;n&&(t=s.length-1);for(let e=t;e>=0;e--)this._pts.add(s[e])}}isHole(){return this._isHole}setInResult(){let t=this._startDe;do{t.getEdge().setInResult(!0),t=t.getNext()}while(t!==this._startDe)}containsPoint(t){const e=this.getLinearRing();if(!e.getEnvelopeInternal().contains(t))return!1;if(!We.isInRing(t,e.getCoordinates()))return!1;for(let e=this._holes.iterator();e.hasNext();){if(e.next().containsPoint(t))return!1}return!0}addHole(t){this._holes.add(t)}isShell(){return null===this._shell}getLabel(){return this._label}getEdges(){return this._edges}getMaxNodeDegree(){return this._maxNodeDegree<0&&this.computeMaxNodeDegree(),this._maxNodeDegree}getShell(){return this._shell}mergeLabel(){if(1===arguments.length){const t=arguments[0];this.mergeLabel(t,0),this.mergeLabel(t,1)}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getLocation(e,Pn.RIGHT);if(n===ne.NONE)return null;if(this._label.getLocation(e)===ne.NONE)return this._label.setLocation(e,n),null}}setShell(t){this._shell=t,null!==t&&t.addHole(this)}toPolygon(t){const e=new Array(this._holes.size()).fill(null);for(let t=0;t<this._holes.size();t++)e[t]=this._holes.get(t).getLinearRing();return t.createPolygon(this.getLinearRing(),e)}getClass(){return Js}get interfaces_(){return[]}}Js.constructor_=function(){if(this._startDe=null,this._maxNodeDegree=-1,this._edges=new x,this._pts=new x,this._label=new Fn(ne.NONE),this._ring=null,this._isHole=null,this._shell=null,this._holes=new x,this._geometryFactory=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geometryFactory=e,this.computePoints(t),this.computeRing()}};class $s extends Js{constructor(){super(),$s.constructor_.apply(this,arguments)}setEdgeRing(t,e){t.setMinEdgeRing(e)}getNext(t){return t.getNextMin()}getClass(){return $s}get interfaces_(){return[]}}$s.constructor_=function(){const t=arguments[0],e=arguments[1];Js.constructor_.call(this,t,e)};class ti extends Js{constructor(){super(),ti.constructor_.apply(this,arguments)}buildMinimalRings(){const t=new x;let e=this._startDe;do{if(null===e.getMinEdgeRing()){const n=new $s(e,this._geometryFactory);t.add(n)}e=e.getNext()}while(e!==this._startDe);return t}setEdgeRing(t,e){t.setEdgeRing(e)}linkDirectedEdgesForMinimalEdgeRings(){let t=this._startDe;do{t.getNode().getEdges().linkMinimalDirectedEdges(this),t=t.getNext()}while(t!==this._startDe)}getNext(t){return t.getNext()}getClass(){return ti}get interfaces_(){return[]}}ti.constructor_=function(){const t=arguments[0],e=arguments[1];Js.constructor_.call(this,t,e)};class ei{constructor(){ei.constructor_.apply(this,arguments)}sortShellsAndHoles(t,e,n){for(let s=t.iterator();s.hasNext();){const t=s.next();t.isHole()?n.add(t):e.add(t)}}computePolygons(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next().toPolygon(this._geometryFactory);e.add(t)}return e}placeFreeHoles(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();if(null===e.getShell()){const n=this.findEdgeRingContaining(e,t);if(null===n)throw new Wn("unable to assign hole to a shell",e.getCoordinate(0));e.setShell(n)}}}buildMinimalEdgeRings(t,e,n){const s=new x;for(let i=t.iterator();i.hasNext();){const t=i.next();if(t.getMaxNodeDegree()>2){t.linkDirectedEdgesForMinimalEdgeRings();const s=t.buildMinimalRings(),i=this.findShell(s);null!==i?(this.placePolygonHoles(i,s),e.add(i)):n.addAll(s)}else s.add(t)}return s}containsPoint(t){for(let e=this._shellList.iterator();e.hasNext();){if(e.next().containsPoint(t))return!0}return!1}buildMaximalEdgeRings(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next();if(t.isInResult()&&t.getLabel().isArea()&&null===t.getEdgeRing()){const n=new ti(t,this._geometryFactory);e.add(n),n.setInResult()}}return e}placePolygonHoles(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();e.isHole()&&e.setShell(t)}}getPolygons(){return this.computePolygons(this._shellList)}findEdgeRingContaining(t,e){const n=t.getLinearRing(),s=n.getEnvelopeInternal(),i=n.getCoordinateN(0);let r=null,o=null;for(let t=e.iterator();t.hasNext();){const e=t.next(),n=e.getLinearRing(),l=n.getEnvelopeInternal();null!==r&&(o=r.getLinearRing().getEnvelopeInternal());let a=!1;l.contains(s)&&We.isInRing(i,n.getCoordinates())&&(a=!0),a&&(null===r||o.contains(l))&&(r=e)}return r}findShell(t){let e=0,n=null;for(let s=t.iterator();s.hasNext();){const t=s.next();t.isHole()||(n=t,e++)}return u.isTrue(e<=1,"found two shells in MinimalEdgeRing list"),n}add(){if(1===arguments.length){const t=arguments[0];this.add(t.getEdgeEnds(),t.getNodes())}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Zn.linkResultDirectedEdges(e);const n=this.buildMaximalEdgeRings(t),s=new x,i=this.buildMinimalEdgeRings(n,this._shellList,s);this.sortShellsAndHoles(i,this._shellList,s),this.placeFreeHoles(this._shellList,s)}}getClass(){return ei}get interfaces_(){return[]}}ei.constructor_=function(){this._geometryFactory=null,this._shellList=new x;const t=arguments[0];this._geometryFactory=t};class ni{constructor(){ni.constructor_.apply(this,arguments)}static simplify(t,e){return new ni(t).simplify(e)}isDeletable(t,e,n,s){const i=this._inputLine[t],r=this._inputLine[e],o=this._inputLine[n];return!!this.isConcave(i,r,o)&&(!!this.isShallow(i,r,o,s)&&this.isShallowSampled(i,r,t,n,s))}deleteShallowConcavities(){let t=1;this._inputLine.length;let e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e),s=!1;for(;n<this._inputLine.length;){let i=!1;this.isDeletable(t,e,n,this._distanceTol)&&(this._isDeleted[e]=ni.DELETE,i=!0,s=!0),t=i?n:e,e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e)}return s}isShallowConcavity(t,e,n,s){return v.index(t,e,n)===this._angleOrientation&&D.pointToSegment(e,t,n)<s}isShallowSampled(t,e,n,s,i){let r=Math.trunc((s-n)/ni.NUM_PTS_TO_CHECK);r<=0&&(r=1);for(let o=n;o<s;o+=r)if(!this.isShallow(t,e,this._inputLine[o],i))return!1;return!0}isConcave(t,e,n){return v.index(t,e,n)===this._angleOrientation}simplify(t){this._distanceTol=Math.abs(t),t<0&&(this._angleOrientation=v.CLOCKWISE),this._isDeleted=new Array(this._inputLine.length).fill(null);let e=!1;do{e=this.deleteShallowConcavities()}while(e);return this.collapseLine()}findNextNonDeletedIndex(t){let e=t+1;for(;e<this._inputLine.length&&this._isDeleted[e]===ni.DELETE;)e++;return e}isShallow(t,e,n,s){return D.pointToSegment(e,t,n)<s}collapseLine(){const t=new I;for(let e=0;e<this._inputLine.length;e++)this._isDeleted[e]!==ni.DELETE&&t.add(this._inputLine[e]);return t.toCoordinateArray()}getClass(){return ni}get interfaces_(){return[]}}ni.constructor_=function(){this._inputLine=null,this._distanceTol=null,this._isDeleted=null,this._angleOrientation=v.COUNTERCLOCKWISE;const t=arguments[0];this._inputLine=t},ni.INIT=0,ni.DELETE=1,ni.KEEP=1,ni.NUM_PTS_TO_CHECK=10;class si{constructor(){si.constructor_.apply(this,arguments)}getCoordinates(){return this._ptList.toArray(si.COORDINATE_ARRAY_TYPE)}setPrecisionModel(t){this._precisionModel=t}addPt(t){const e=new g(t);if(this._precisionModel.makePrecise(e),this.isRedundant(e))return null;this._ptList.add(e)}reverse(){}addPts(t,e){if(e)for(let e=0;e<t.length;e++)this.addPt(t[e]);else for(let e=t.length-1;e>=0;e--)this.addPt(t[e])}isRedundant(t){if(this._ptList.size()<1)return!1;const e=this._ptList.get(this._ptList.size()-1);return t.distance(e)<this._minimimVertexDistance}toString(){return(new Ht).createLineString(this.getCoordinates()).toString()}closeRing(){if(this._ptList.size()<1)return null;const t=new g(this._ptList.get(0)),e=this._ptList.get(this._ptList.size()-1);let n=null;if(this._ptList.size()>=2&&this._ptList.get(this._ptList.size()-2),t.equals(e))return null;this._ptList.add(t)}setMinimumVertexDistance(t){this._minimimVertexDistance=t}getClass(){return si}get interfaces_(){return[]}}si.constructor_=function(){this._ptList=null,this._precisionModel=null,this._minimimVertexDistance=0,this._ptList=new x},si.COORDINATE_ARRAY_TYPE=new Array(0).fill(null);class ii{constructor(){ii.constructor_.apply(this,arguments)}addNextSegment(t,e){if(this._s0=this._s1,this._s1=this._s2,this._s2=t,this._seg0.setCoordinates(this._s0,this._s1),this.computeOffsetSegment(this._seg0,this._side,this._distance,this._offset0),this._seg1.setCoordinates(this._s1,this._s2),this.computeOffsetSegment(this._seg1,this._side,this._distance,this._offset1),this._s1.equals(this._s2))return null;const n=v.index(this._s0,this._s1,this._s2),s=n===v.CLOCKWISE&&this._side===Pn.LEFT||n===v.COUNTERCLOCKWISE&&this._side===Pn.RIGHT;0===n?this.addCollinear(e):s?this.addOutsideTurn(n,e):this.addInsideTurn(n,e)}addLineEndCap(t,e){const n=new ee(t,e),s=new ee;this.computeOffsetSegment(n,Pn.LEFT,this._distance,s);const i=new ee;this.computeOffsetSegment(n,Pn.RIGHT,this._distance,i);const r=e.x-t.x,o=e.y-t.y,l=Math.atan2(o,r);switch(this._bufParams.getEndCapStyle()){case js.CAP_ROUND:this._segList.addPt(s.p1),this.addDirectedFillet(e,l+Math.PI/2,l-Math.PI/2,v.CLOCKWISE,this._distance),this._segList.addPt(i.p1);break;case js.CAP_FLAT:this._segList.addPt(s.p1),this._segList.addPt(i.p1);break;case js.CAP_SQUARE:const t=new g;t.x=Math.abs(this._distance)*Math.cos(l),t.y=Math.abs(this._distance)*Math.sin(l);const n=new g(s.p1.x+t.x,s.p1.y+t.y),r=new g(i.p1.x+t.x,i.p1.y+t.y);this._segList.addPt(n),this._segList.addPt(r)}}getCoordinates(){return this._segList.getCoordinates()}addMitreJoin(t,e,n,s){let i=!0,r=null;try{r=b.intersection(e.p0,e.p1,n.p0,n.p1),(s<=0?1:r.distance(t)/Math.abs(s))>this._bufParams.getMitreLimit()&&(i=!1)}catch(t){if(!(t instanceof S))throw t;r=new g(0,0),i=!1}i?this._segList.addPt(r):this.addLimitedMitreJoin(e,n,s,this._bufParams.getMitreLimit())}addOutsideTurn(t,e){if(this._offset0.p1.distance(this._offset1.p0)<this._distance*ii.OFFSET_SEGMENT_SEPARATION_FACTOR)return this._segList.addPt(this._offset0.p1),null;this._bufParams.getJoinStyle()===js.JOIN_MITRE?this.addMitreJoin(this._s1,this._offset0,this._offset1,this._distance):this._bufParams.getJoinStyle()===js.JOIN_BEVEL?this.addBevelJoin(this._offset0,this._offset1):(e&&this._segList.addPt(this._offset0.p1),this.addCornerFillet(this._s1,this._offset0.p1,this._offset1.p0,t,this._distance),this._segList.addPt(this._offset1.p0))}createSquare(t){this._segList.addPt(new g(t.x+this._distance,t.y+this._distance)),this._segList.addPt(new g(t.x+this._distance,t.y-this._distance)),this._segList.addPt(new g(t.x-this._distance,t.y-this._distance)),this._segList.addPt(new g(t.x-this._distance,t.y+this._distance)),this._segList.closeRing()}addSegments(t,e){this._segList.addPts(t,e)}addFirstSegment(){this._segList.addPt(this._offset1.p0)}addCornerFillet(t,e,n,s,i){const r=e.x-t.x,o=e.y-t.y;let l=Math.atan2(o,r);const a=n.x-t.x,c=n.y-t.y,h=Math.atan2(c,a);s===v.CLOCKWISE?l<=h&&(l+=2*Math.PI):l>=h&&(l-=2*Math.PI),this._segList.addPt(e),this.addDirectedFillet(t,l,h,s,i),this._segList.addPt(n)}addLastSegment(){this._segList.addPt(this._offset1.p1)}initSideSegments(t,e,n){this._s1=t,this._s2=e,this._side=n,this._seg1.setCoordinates(t,e),this.computeOffsetSegment(this._seg1,n,this._distance,this._offset1)}addLimitedMitreJoin(t,e,n,s){const i=this._seg0.p1,r=ie.angle(i,this._seg0.p0),o=(ie.angle(i,this._seg1.p1),ie.angleBetweenOriented(this._seg0.p0,i,this._seg1.p1)/2),l=ie.normalize(r+o),a=ie.normalize(l+Math.PI),c=s*n,h=n-c*Math.abs(Math.sin(o)),u=i.x+c*Math.cos(a),d=i.y+c*Math.sin(a),_=new g(u,d),f=new ee(i,_),p=f.pointAlongOffset(1,h),m=f.pointAlongOffset(1,-h);this._side===Pn.LEFT?(this._segList.addPt(p),this._segList.addPt(m)):(this._segList.addPt(m),this._segList.addPt(p))}addDirectedFillet(t,e,n,s,i){const r=s===v.CLOCKWISE?-1:1,o=Math.abs(e-n),l=Math.trunc(o/this._filletAngleQuantum+.5);if(l<1)return null;let a=null,c=null;a=0,c=o/l;let h=0;const u=new g;for(;h<o;){const n=e+r*h;u.x=t.x+i*Math.cos(n),u.y=t.y+i*Math.sin(n),this._segList.addPt(u),h+=c}}computeOffsetSegment(t,e,n,s){const i=e===Pn.LEFT?1:-1,r=t.p1.x-t.p0.x,o=t.p1.y-t.p0.y,l=Math.sqrt(r*r+o*o),a=i*n*r/l,c=i*n*o/l;s.p0.x=t.p0.x-c,s.p0.y=t.p0.y+a,s.p1.x=t.p1.x-c,s.p1.y=t.p1.y+a}addInsideTurn(t,e){if(this._li.computeIntersection(this._offset0.p0,this._offset0.p1,this._offset1.p0,this._offset1.p1),this._li.hasIntersection())this._segList.addPt(this._li.getIntersection(0));else if(this._hasNarrowConcaveAngle=!0,this._offset0.p1.distance(this._offset1.p0)<this._distance*ii.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)this._segList.addPt(this._offset0.p1);else{if(this._segList.addPt(this._offset0.p1),this._closingSegLengthFactor>0){const t=new g((this._closingSegLengthFactor*this._offset0.p1.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset0.p1.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(t);const e=new g((this._closingSegLengthFactor*this._offset1.p0.x+this._s1.x)/(this._closingSegLengthFactor+1),(this._closingSegLengthFactor*this._offset1.p0.y+this._s1.y)/(this._closingSegLengthFactor+1));this._segList.addPt(e)}else this._segList.addPt(this._s1);this._segList.addPt(this._offset1.p0)}}createCircle(t){const e=new g(t.x+this._distance,t.y);this._segList.addPt(e),this.addDirectedFillet(t,0,2*Math.PI,-1,this._distance),this._segList.closeRing()}addBevelJoin(t,e){this._segList.addPt(t.p1),this._segList.addPt(e.p0)}init(t){this._distance=t,this._maxCurveSegmentError=t*(1-Math.cos(this._filletAngleQuantum/2)),this._segList=new si,this._segList.setPrecisionModel(this._precisionModel),this._segList.setMinimumVertexDistance(t*ii.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)}addCollinear(t){this._li.computeIntersection(this._s0,this._s1,this._s1,this._s2),this._li.getIntersectionNum()>=2&&(this._bufParams.getJoinStyle()===js.JOIN_BEVEL||this._bufParams.getJoinStyle()===js.JOIN_MITRE?(t&&this._segList.addPt(this._offset0.p1),this._segList.addPt(this._offset1.p0)):this.addCornerFillet(this._s1,this._offset0.p1,this._offset1.p0,v.CLOCKWISE,this._distance))}closeRing(){this._segList.closeRing()}hasNarrowConcaveAngle(){return this._hasNarrowConcaveAngle}getClass(){return ii}get interfaces_(){return[]}}ii.constructor_=function(){this._maxCurveSegmentError=0,this._filletAngleQuantum=null,this._closingSegLengthFactor=1,this._segList=null,this._distance=0,this._precisionModel=null,this._bufParams=null,this._li=null,this._s0=null,this._s1=null,this._s2=null,this._seg0=new ee,this._seg1=new ee,this._offset0=new ee,this._offset1=new ee,this._side=0,this._hasNarrowConcaveAngle=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._precisionModel=t,this._bufParams=e,this._li=new te,this._filletAngleQuantum=Math.PI/2/e.getQuadrantSegments(),e.getQuadrantSegments()>=8&&e.getJoinStyle()===js.JOIN_ROUND&&(this._closingSegLengthFactor=ii.MAX_CLOSING_SEG_LEN_FACTOR),this.init(n)},ii.OFFSET_SEGMENT_SEPARATION_FACTOR=.001,ii.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR=.001,ii.CURVE_VERTEX_SNAP_DISTANCE_FACTOR=1e-6,ii.MAX_CLOSING_SEG_LEN_FACTOR=80;class ri{constructor(){ri.constructor_.apply(this,arguments)}static copyCoordinates(t){const e=new Array(t.length).fill(null);for(let n=0;n<e.length;n++)e[n]=new g(t[n]);return e}getOffsetCurve(t,e){if(this._distance=e,0===e)return null;const n=e<0,s=Math.abs(e),i=this.getSegGen(s);t.length<=1?this.computePointCurve(t[0],i):this.computeOffsetCurve(t,n,i);const r=i.getCoordinates();return n&&X.reverse(r),r}computeSingleSidedBufferCurve(t,e,n){const s=this.simplifyTolerance(this._distance);if(e){n.addSegments(t,!0);const e=ni.simplify(t,-s),i=e.length-1;n.initSideSegments(e[i],e[i-1],Pn.LEFT),n.addFirstSegment();for(let t=i-2;t>=0;t--)n.addNextSegment(e[t],!0)}else{n.addSegments(t,!1);const e=ni.simplify(t,s),i=e.length-1;n.initSideSegments(e[0],e[1],Pn.LEFT),n.addFirstSegment();for(let t=2;t<=i;t++)n.addNextSegment(e[t],!0)}n.addLastSegment(),n.closeRing()}computeRingBufferCurve(t,e,n){let s=this.simplifyTolerance(this._distance);e===Pn.RIGHT&&(s=-s);const i=ni.simplify(t,s),r=i.length-1;n.initSideSegments(i[r-1],i[0],e);for(let t=1;t<=r;t++){const e=1!==t;n.addNextSegment(i[t],e)}n.closeRing()}computeLineBufferCurve(t,e){const n=this.simplifyTolerance(this._distance),s=ni.simplify(t,n),i=s.length-1;e.initSideSegments(s[0],s[1],Pn.LEFT);for(let t=2;t<=i;t++)e.addNextSegment(s[t],!0);e.addLastSegment(),e.addLineEndCap(s[i-1],s[i]);const r=ni.simplify(t,-n),o=r.length-1;e.initSideSegments(r[o],r[o-1],Pn.LEFT);for(let t=o-2;t>=0;t--)e.addNextSegment(r[t],!0);e.addLastSegment(),e.addLineEndCap(r[1],r[0]),e.closeRing()}computePointCurve(t,e){switch(this._bufParams.getEndCapStyle()){case js.CAP_ROUND:e.createCircle(t);break;case js.CAP_SQUARE:e.createSquare(t)}}getLineCurve(t,e){if(this._distance=e,e<0&&!this._bufParams.isSingleSided())return null;if(0===e)return null;const n=Math.abs(e),s=this.getSegGen(n);if(t.length<=1)this.computePointCurve(t[0],s);else if(this._bufParams.isSingleSided()){const n=e<0;this.computeSingleSidedBufferCurve(t,n,s)}else this.computeLineBufferCurve(t,s);return s.getCoordinates()}getBufferParameters(){return this._bufParams}simplifyTolerance(t){return t*this._bufParams.getSimplifyFactor()}getRingCurve(t,e,n){if(this._distance=n,t.length<=2)return this.getLineCurve(t,n);if(0===n)return ri.copyCoordinates(t);const s=this.getSegGen(n);return this.computeRingBufferCurve(t,e,s),s.getCoordinates()}computeOffsetCurve(t,e,n){const s=this.simplifyTolerance(this._distance);if(e){const e=ni.simplify(t,-s),i=e.length-1;n.initSideSegments(e[i],e[i-1],Pn.LEFT),n.addFirstSegment();for(let t=i-2;t>=0;t--)n.addNextSegment(e[t],!0)}else{const e=ni.simplify(t,s),i=e.length-1;n.initSideSegments(e[0],e[1],Pn.LEFT),n.addFirstSegment();for(let t=2;t<=i;t++)n.addNextSegment(e[t],!0)}n.addLastSegment()}getSegGen(t){return new ii(this._precisionModel,this._bufParams,t)}getClass(){return ri}get interfaces_(){return[]}}ri.constructor_=function(){this._distance=0,this._precisionModel=null,this._bufParams=null;const t=arguments[0],e=arguments[1];this._precisionModel=t,this._bufParams=e};class oi{constructor(){oi.constructor_.apply(this,arguments)}findStabbedSegments(){if(1===arguments.length){const t=arguments[0],e=new x;for(let n=this._subgraphs.iterator();n.hasNext();){const s=n.next(),i=s.getEnvelope();t.y<i.getMinY()||t.y>i.getMaxY()||this.findStabbedSegments(t,s.getDirectedEdges(),e)}return e}if(3===arguments.length)if(_(arguments[2],m)&&arguments[0]instanceof g&&arguments[1]instanceof jn){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.getEdge().getCoordinates();for(let i=0;i<s.length-1;i++){if(this._seg.p0=s[i],this._seg.p1=s[i+1],this._seg.p0.y>this._seg.p1.y&&this._seg.reverse(),Math.max(this._seg.p0.x,this._seg.p1.x)<t.x)continue;if(this._seg.isHorizontal())continue;if(t.y<this._seg.p0.y||t.y>this._seg.p1.y)continue;if(v.index(this._seg.p0,this._seg.p1,t)===v.RIGHT)continue;let r=e.getDepth(Pn.LEFT);this._seg.p0.equals(s[i])||(r=e.getDepth(Pn.RIGHT));const o=new li(this._seg,r);n.add(o)}}else if(_(arguments[2],m)&&arguments[0]instanceof g&&_(arguments[1],m)){const t=arguments[0],e=arguments[1],n=arguments[2];for(let s=e.iterator();s.hasNext();){const e=s.next();e.isForward()&&this.findStabbedSegments(t,e,n)}}}getDepth(t){const e=this.findStabbedSegments(t);return 0===e.size()?0:Ee.min(e)._leftDepth}getClass(){return oi}get interfaces_(){return[]}}class li{constructor(){li.constructor_.apply(this,arguments)}compareTo(t){const e=t;if(this._upwardSeg.minX()>=e._upwardSeg.maxX())return 1;if(this._upwardSeg.maxX()<=e._upwardSeg.minX())return-1;let n=this._upwardSeg.orientationIndex(e._upwardSeg);return 0!==n?n:(n=-1*e._upwardSeg.orientationIndex(this._upwardSeg),0!==n?n:this._upwardSeg.compareTo(e._upwardSeg))}compareX(t,e){const n=t.p0.compareTo(e.p0);return 0!==n?n:t.p1.compareTo(e.p1)}toString(){return this._upwardSeg.toString()}getClass(){return li}get interfaces_(){return[r]}}li.constructor_=function(){this._upwardSeg=null,this._leftDepth=null;const t=arguments[0],e=arguments[1];this._upwardSeg=new ee(t),this._leftDepth=e},oi.DepthSegment=li,oi.constructor_=function(){this._subgraphs=null,this._seg=new ee;const t=arguments[0];this._subgraphs=t};class ai{constructor(){ai.constructor_.apply(this,arguments)}addPoint(t){if(this._distance<=0)return null;const e=t.getCoordinates(),n=this._curveBuilder.getLineCurve(e,this._distance);this.addCurve(n,ne.EXTERIOR,ne.INTERIOR)}addPolygon(t){let e=this._distance,n=Pn.LEFT;this._distance<0&&(e=-this._distance,n=Pn.RIGHT);const s=t.getExteriorRing(),i=X.removeRepeatedPoints(s.getCoordinates());if(this._distance<0&&this.isErodedCompletely(s,this._distance))return null;if(this._distance<=0&&i.length<3)return null;this.addPolygonRing(i,e,n,ne.EXTERIOR,ne.INTERIOR);for(let s=0;s<t.getNumInteriorRing();s++){const i=t.getInteriorRingN(s),r=X.removeRepeatedPoints(i.getCoordinates());this._distance>0&&this.isErodedCompletely(i,-this._distance)||this.addPolygonRing(r,e,Pn.opposite(n),ne.INTERIOR,ne.EXTERIOR)}}isTriangleErodedCompletely(t,e){const n=new re(t[0],t[1],t[2]),s=n.inCentre();return D.pointToSegment(s,n.p0,n.p1)<Math.abs(e)}addLineString(t){if(this._distance<=0&&!this._curveBuilder.getBufferParameters().isSingleSided())return null;const e=X.removeRepeatedPoints(t.getCoordinates()),n=this._curveBuilder.getLineCurve(e,this._distance);this.addCurve(n,ne.EXTERIOR,ne.INTERIOR)}addCurve(t,e,n){if(null===t||t.length<2)return null;const s=new Fs(t,new Fn(0,ne.BOUNDARY,e,n));this._curveList.add(s)}getCurves(){return this.add(this._inputGeom),this._curveList}addPolygonRing(t,e,n,s,i){if(0===e&&t.length<Dt.MINIMUM_VALID_SIZE)return null;let r=s,o=i;t.length>=Dt.MINIMUM_VALID_SIZE&&v.isCCW(t)&&(r=i,o=s,n=Pn.opposite(n));const l=this._curveBuilder.getRingCurve(t,n,e);this.addCurve(l,r,o)}add(t){if(t.isEmpty())return null;if(t instanceof bt)this.addPolygon(t);else if(t instanceof Tt)this.addLineString(t);else if(t instanceof Pt)this.addPoint(t);else if(t instanceof Mt)this.addCollection(t);else if(t instanceof ft)this.addCollection(t);else if(t instanceof At)this.addCollection(t);else{if(!(t instanceof _t))throw new Z(t.getClass().getName());this.addCollection(t)}}isErodedCompletely(t,e){const n=t.getCoordinates();if(n.length<4)return e<0;if(4===n.length)return this.isTriangleErodedCompletely(n,e);const s=t.getEnvelopeInternal(),i=Math.min(s.getHeight(),s.getWidth());return e<0&&2*Math.abs(e)>i}addCollection(t){for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);this.add(n)}}getClass(){return ai}get interfaces_(){return[]}}ai.constructor_=function(){this._inputGeom=null,this._distance=null,this._curveBuilder=null,this._curveList=new x;const t=arguments[0],e=arguments[1],n=arguments[2];this._inputGeom=t,this._distance=e,this._curveBuilder=n};class ci{constructor(){ci.constructor_.apply(this,arguments)}getNextCW(t){this.getEdges();const e=this._edgeList.indexOf(t);let n=e-1;return 0===e&&(n=this._edgeList.size()-1),this._edgeList.get(n)}propagateSideLabels(t){let e=ne.NONE;for(let n=this.iterator();n.hasNext();){const s=n.next().getLabel();s.isArea(t)&&s.getLocation(t,Pn.LEFT)!==ne.NONE&&(e=s.getLocation(t,Pn.LEFT))}if(e===ne.NONE)return null;let n=e;for(let e=this.iterator();e.hasNext();){const s=e.next(),i=s.getLabel();if(i.getLocation(t,Pn.ON)===ne.NONE&&i.setLocation(t,Pn.ON,n),i.isArea(t)){const e=i.getLocation(t,Pn.LEFT),r=i.getLocation(t,Pn.RIGHT);if(r!==ne.NONE){if(r!==n)throw new Wn("side location conflict",s.getCoordinate());e===ne.NONE&&u.shouldNeverReachHere("found single null side (at "+s.getCoordinate()+")"),n=e}else u.isTrue(i.getLocation(t,Pn.LEFT)===ne.NONE,"found single null side"),i.setLocation(t,Pn.RIGHT,n),i.setLocation(t,Pn.LEFT,n)}}}getCoordinate(){const t=this.iterator();return t.hasNext()?t.next().getCoordinate():null}print(t){O.out.println("EdgeEndStar:   "+this.getCoordinate());for(let e=this.iterator();e.hasNext();){e.next().print(t)}}isAreaLabelsConsistent(t){return this.computeEdgeEndLabels(t.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0)}checkAreaLabelsConsistent(t){const e=this.getEdges();if(e.size()<=0)return!0;const n=e.size()-1,s=e.get(n).getLabel().getLocation(t,Pn.LEFT);u.isTrue(s!==ne.NONE,"Found unlabelled area edge");let i=s;for(let e=this.iterator();e.hasNext();){const n=e.next().getLabel();u.isTrue(n.isArea(t),"Found non-area edge");const s=n.getLocation(t,Pn.LEFT),r=n.getLocation(t,Pn.RIGHT);if(s===r)return!1;if(r!==i)return!1;i=s}return!0}findIndex(t){this.iterator();for(let e=0;e<this._edgeList.size();e++){if(this._edgeList.get(e)===t)return e}return-1}iterator(){return this.getEdges().iterator()}getEdges(){return null===this._edgeList&&(this._edgeList=new x(this._edgeMap.values())),this._edgeList}getLocation(t,e,n){return this._ptInAreaLocation[t]===ne.NONE&&(this._ptInAreaLocation[t]=Ze.locate(e,n[t].getGeometry())),this._ptInAreaLocation[t]}toString(){const t=new w;t.append("EdgeEndStar:   "+this.getCoordinate()),t.append("\n");for(let e=this.iterator();e.hasNext();){const n=e.next();t.append(n),t.append("\n")}return t.toString()}computeEdgeEndLabels(t){for(let e=this.iterator();e.hasNext();){e.next().computeLabel(t)}}computeLabelling(t){this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);const e=[!1,!1];for(let t=this.iterator();t.hasNext();){const n=t.next().getLabel();for(let t=0;t<2;t++)n.isLine(t)&&n.getLocation(t)===ne.BOUNDARY&&(e[t]=!0)}for(let n=this.iterator();n.hasNext();){const s=n.next(),i=s.getLabel();for(let n=0;n<2;n++)if(i.isAnyNull(n)){let r=ne.NONE;if(e[n])r=ne.EXTERIOR;else{const e=s.getCoordinate();r=this.getLocation(n,e,t)}i.setAllLocationsIfNull(n,r)}}}getDegree(){return this._edgeMap.size()}insertEdgeEnd(t,e){this._edgeMap.put(t,e),this._edgeList=null}getClass(){return ci}get interfaces_(){return[]}}ci.constructor_=function(){this._edgeMap=new rt,this._edgeList=null,this._ptInAreaLocation=[ne.NONE,ne.NONE]};class hi extends ci{constructor(){super(),hi.constructor_.apply(this,arguments)}linkResultDirectedEdges(){this.getResultAreaEdges();let t=null,e=null,n=this._SCANNING_FOR_INCOMING;for(let s=0;s<this._resultAreaEdgeList.size();s++){const i=this._resultAreaEdgeList.get(s),r=i.getSym();if(i.getLabel().isArea())switch(null===t&&i.isInResult()&&(t=i),n){case this._SCANNING_FOR_INCOMING:if(!r.isInResult())continue;e=r,n=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(!i.isInResult())continue;e.setNext(i),n=this._SCANNING_FOR_INCOMING}}if(n===this._LINKING_TO_OUTGOING){if(null===t)throw new Wn("no outgoing dirEdge found",this.getCoordinate());u.isTrue(t.isInResult(),"unable to link last incoming dirEdge"),e.setNext(t)}}insert(t){const e=t;this.insertEdgeEnd(e,e)}getRightmostEdge(){const t=this.getEdges(),e=t.size();if(e<1)return null;const n=t.get(0);if(1===e)return n;const s=t.get(e-1),i=n.getQuadrant(),r=s.getQuadrant();return In.isNorthern(i)&&In.isNorthern(r)?n:In.isNorthern(i)||In.isNorthern(r)?0!==n.getDy()?n:0!==s.getDy()?s:(u.shouldNeverReachHere("found two horizontal edges incident on node"),null):s}print(t){O.out.println("DirectedEdgeStar: "+this.getCoordinate());for(let e=this.iterator();e.hasNext();){const n=e.next();t.print("out "),n.print(t),t.println(),t.print("in "),n.getSym().print(t),t.println()}}getResultAreaEdges(){if(null!==this._resultAreaEdgeList)return this._resultAreaEdgeList;this._resultAreaEdgeList=new x;for(let t=this.iterator();t.hasNext();){const e=t.next();(e.isInResult()||e.getSym().isInResult())&&this._resultAreaEdgeList.add(e)}return this._resultAreaEdgeList}updateLabelling(t){for(let e=this.iterator();e.hasNext();){const n=e.next().getLabel();n.setAllLocationsIfNull(0,t.getLocation(0)),n.setAllLocationsIfNull(1,t.getLocation(1))}}linkAllDirectedEdges(){this.getEdges();let t=null,e=null;for(let n=this._edgeList.size()-1;n>=0;n--){const s=this._edgeList.get(n),i=s.getSym();null===e&&(e=i),null!==t&&i.setNext(t),t=s}e.setNext(t)}computeDepths(){if(1===arguments.length){const t=arguments[0],e=this.findIndex(t),n=t.getDepth(Pn.LEFT),s=t.getDepth(Pn.RIGHT),i=this.computeDepths(e+1,this._edgeList.size(),n);if(this.computeDepths(0,e,i)!==s)throw new Wn("depth mismatch at "+t.getCoordinate())}else if(3===arguments.length){const t=arguments[0],e=arguments[1];let n=arguments[2];for(let s=t;s<e;s++){const t=this._edgeList.get(s);t.setEdgeDepths(Pn.RIGHT,n),n=t.getDepth(Pn.LEFT)}return n}}mergeSymLabels(){for(let t=this.iterator();t.hasNext();){const e=t.next();e.getLabel().merge(e.getSym().getLabel())}}linkMinimalDirectedEdges(t){let e=null,n=null,s=this._SCANNING_FOR_INCOMING;for(let i=this._resultAreaEdgeList.size()-1;i>=0;i--){const r=this._resultAreaEdgeList.get(i),o=r.getSym();switch(null===e&&r.getEdgeRing()===t&&(e=r),s){case this._SCANNING_FOR_INCOMING:if(o.getEdgeRing()!==t)continue;n=o,s=this._LINKING_TO_OUTGOING;break;case this._LINKING_TO_OUTGOING:if(r.getEdgeRing()!==t)continue;n.setNextMin(r),s=this._SCANNING_FOR_INCOMING}}s===this._LINKING_TO_OUTGOING&&(u.isTrue(null!==e,"found null for first outgoing dirEdge"),u.isTrue(e.getEdgeRing()===t,"unable to link last incoming dirEdge"),n.setNextMin(e))}getOutgoingDegree(){if(0===arguments.length){let t=0;for(let e=this.iterator();e.hasNext();){e.next().isInResult()&&t++}return t}if(1===arguments.length){const t=arguments[0];let e=0;for(let n=this.iterator();n.hasNext();){n.next().getEdgeRing()===t&&e++}return e}}getLabel(){return this._label}findCoveredLineEdges(){let t=ne.NONE;for(let e=this.iterator();e.hasNext();){const n=e.next(),s=n.getSym();if(!n.isLineEdge()){if(n.isInResult()){t=ne.INTERIOR;break}if(s.isInResult()){t=ne.EXTERIOR;break}}}if(t===ne.NONE)return null;let e=t;for(let t=this.iterator();t.hasNext();){const n=t.next(),s=n.getSym();n.isLineEdge()?n.getEdge().setCovered(e===ne.INTERIOR):(n.isInResult()&&(e=ne.EXTERIOR),s.isInResult()&&(e=ne.INTERIOR))}}computeLabelling(t){super.computeLabelling.call(this,t),this._label=new Fn(ne.NONE);for(let t=this.iterator();t.hasNext();){const e=t.next().getEdge().getLabel();for(let t=0;t<2;t++){const n=e.getLocation(t);n!==ne.INTERIOR&&n!==ne.BOUNDARY||this._label.setLocation(t,ne.INTERIOR)}}}getClass(){return hi}get interfaces_(){return[]}}hi.constructor_=function(){this._resultAreaEdgeList=null,this._label=null,this._SCANNING_FOR_INCOMING=1,this._LINKING_TO_OUTGOING=2};class ui extends Kn{constructor(){super(),ui.constructor_.apply(this,arguments)}createNode(t){return new kn(t,new hi)}getClass(){return ui}get interfaces_(){return[]}}ui.constructor_=function(){};class gi{constructor(){gi.constructor_.apply(this,arguments)}static orientation(t){return 1===X.increasingDirection(t)}static compareOriented(t,e,n,s){const i=e?1:-1,r=s?1:-1,o=e?t.length:-1,l=s?n.length:-1;let a=e?0:t.length-1,c=s?0:n.length-1;for(;;){const e=t[a].compareTo(n[c]);if(0!==e)return e;a+=i,c+=r;const s=a===o,h=c===l;if(s&&!h)return-1;if(!s&&h)return 1;if(s&&h)return 0}}compareTo(t){const e=t;return gi.compareOriented(this._pts,this._orientation,e._pts,e._orientation)}getClass(){return gi}get interfaces_(){return[r]}}gi.constructor_=function(){this._pts=null,this._orientation=null;const t=arguments[0];this._pts=t,this._orientation=gi.orientation(t)};class di{constructor(){di.constructor_.apply(this,arguments)}print(t){t.print("MULTILINESTRING ( ");for(let e=0;e<this._edges.size();e++){const n=this._edges.get(e);e>0&&t.print(","),t.print("(");const s=n.getCoordinates();for(let e=0;e<s.length;e++)e>0&&t.print(","),t.print(s[e].x+" "+s[e].y);t.println(")")}t.print(")  ")}addAll(t){for(let e=t.iterator();e.hasNext();)this.add(e.next())}findEdgeIndex(t){for(let e=0;e<this._edges.size();e++)if(this._edges.get(e).equals(t))return e;return-1}iterator(){return this._edges.iterator()}getEdges(){return this._edges}get(t){return this._edges.get(t)}findEqualEdge(t){const e=new gi(t.getCoordinates());return this._ocaMap.get(e)}add(t){this._edges.add(t);const e=new gi(t.getCoordinates());this._ocaMap.put(e,t)}getClass(){return di}get interfaces_(){return[]}}di.constructor_=function(){this._edges=new x,this._ocaMap=new rt};class _i{constructor(){_i.constructor_.apply(this,arguments)}processIntersections(t,e,n,s){}isDone(){}getClass(){return _i}get interfaces_(){return[]}}_i.constructor_=function(){};class fi{constructor(){fi.constructor_.apply(this,arguments)}static isAdjacentSegments(t,e){return 1===Math.abs(t-e)}isTrivialIntersection(t,e,n,s){if(t===n&&1===this._li.getIntersectionNum()){if(fi.isAdjacentSegments(e,s))return!0;if(t.isClosed()){const n=t.size()-1;if(0===e&&s===n||0===s&&e===n)return!0}}return!1}getProperIntersectionPoint(){return this._properIntersectionPoint}hasProperInteriorIntersection(){return this._hasProperInterior}getLineIntersector(){return this._li}hasProperIntersection(){return this._hasProper}processIntersections(t,e,n,s){if(t===n&&e===s)return null;this.numTests++;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this.numIntersections++,this._li.isInteriorIntersection()&&(this.numInteriorIntersections++,this._hasInterior=!0),this.isTrivialIntersection(t,e,n,s)||(this._hasIntersection=!0,t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1),this._li.isProper()&&(this.numProperIntersections++,this._hasProper=!0,this._hasProperInterior=!0)))}hasIntersection(){return this._hasIntersection}isDone(){return!1}hasInteriorIntersection(){return this._hasInterior}getClass(){return fi}get interfaces_(){return[_i]}}fi.constructor_=function(){this._hasIntersection=!1,this._hasProper=!1,this._hasProperInterior=!1,this._hasInterior=!1,this._properIntersectionPoint=null,this._li=null,this._isSelfIntersection=null,this.numIntersections=0,this.numInteriorIntersections=0,this.numProperIntersections=0,this.numTests=0;const t=arguments[0];this._li=t};class pi{constructor(){pi.constructor_.apply(this,arguments)}static depthDelta(t){const e=t.getLocation(0,Pn.LEFT),n=t.getLocation(0,Pn.RIGHT);return e===ne.INTERIOR&&n===ne.EXTERIOR?1:e===ne.EXTERIOR&&n===ne.INTERIOR?-1:0}static convertSegStrings(t){const e=new Ht,n=new x;for(;t.hasNext();){const s=t.next(),i=e.createLineString(s.getCoordinates());n.add(i)}return e.buildGeometry(n)}setWorkingPrecisionModel(t){this._workingPrecisionModel=t}insertUniqueEdge(t){const e=this._edgeList.findEqualEdge(t);if(null!==e){const n=e.getLabel();let s=t.getLabel();e.isPointwiseEqual(t)||(s=new Fn(t.getLabel()),s.flip()),n.merge(s);const i=pi.depthDelta(s),r=e.getDepthDelta()+i;e.setDepthDelta(r)}else this._edgeList.add(t),t.setDepthDelta(pi.depthDelta(t.getLabel()))}buildSubgraphs(t,e){const n=new x;for(let s=t.iterator();s.hasNext();){const t=s.next(),i=t.getRightmostCoordinate(),r=new oi(n).getDepth(i);t.computeDepth(r),t.findResultEdges(),n.add(t),e.add(t.getDirectedEdges(),t.getNodes())}}createSubgraphs(t){const e=new x;for(let n=t.getNodes().iterator();n.hasNext();){const t=n.next();if(!t.isVisited()){const n=new Qs;n.create(t),e.add(n)}}return Ee.sort(e,Ee.reverseOrder()),e}createEmptyResultGeometry(){return this._geomFact.createPolygon()}getNoder(t){if(null!==this._workingNoder)return this._workingNoder;const e=new Ys,n=new te;return n.setPrecisionModel(t),e.setSegmentIntersector(new fi(n)),e}buffer(t,e){let n=this._workingPrecisionModel;null===n&&(n=t.getPrecisionModel()),this._geomFact=t.getFactory();const s=new ri(n,this._bufParams),i=new ai(t,e,s).getCurves();if(i.size()<=0)return this.createEmptyResultGeometry();this.computeNodedEdges(i,n),this._graph=new Zn(new ui),this._graph.addEdges(this._edgeList.getEdges());const r=this.createSubgraphs(this._graph),o=new ei(this._geomFact);this.buildSubgraphs(r,o);const l=o.getPolygons();return l.size()<=0?this.createEmptyResultGeometry():this._geomFact.buildGeometry(l)}computeNodedEdges(t,e){const n=this.getNoder(e);n.computeNodes(t);for(let t=n.getNodedSubstrings().iterator();t.hasNext();){const e=t.next(),n=e.getCoordinates();if(2===n.length&&n[0].equals2D(n[1]))continue;const s=e.getData(),i=new Un(e.getCoordinates(),new Fn(s));this.insertUniqueEdge(i)}}setNoder(t){this._workingNoder=t}getClass(){return pi}get interfaces_(){return[]}}pi.constructor_=function(){this._bufParams=null,this._workingPrecisionModel=null,this._workingNoder=null,this._geomFact=null,this._graph=null,this._edgeList=new di;const t=arguments[0];this._bufParams=t};class mi{constructor(){mi.constructor_.apply(this,arguments)}checkEndPtVertexIntersections(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next().getCoordinates();this.checkEndPtVertexIntersections(e[0],this._segStrings),this.checkEndPtVertexIntersections(e[e.length-1],this._segStrings)}else if(2===arguments.length){const t=arguments[0];for(let e=arguments[1].iterator();e.hasNext();){const n=e.next().getCoordinates();for(let e=1;e<n.length-1;e++)if(n[e].equals(t))throw new c("found endpt/interior pt intersection at index "+e+" :pt "+t)}}}checkInteriorIntersections(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next();for(let t=this._segStrings.iterator();t.hasNext();){const n=t.next();this.checkInteriorIntersections(e,n)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getCoordinates(),s=e.getCoordinates();for(let i=0;i<n.length-1;i++)for(let n=0;n<s.length-1;n++)this.checkInteriorIntersections(t,i,e,n)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];if(t===n&&e===s)return null;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];if(this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&(this._li.isProper()||this.hasInteriorIntersection(this._li,i,r)||this.hasInteriorIntersection(this._li,o,l)))throw new c("found non-noded intersection at "+i+"-"+r+" and "+o+"-"+l)}}checkValid(){this.checkEndPtVertexIntersections(),this.checkInteriorIntersections(),this.checkCollapses()}checkCollapses(){if(0===arguments.length)for(let t=this._segStrings.iterator();t.hasNext();){const e=t.next();this.checkCollapses(e)}else if(1===arguments.length){const t=arguments[0].getCoordinates();for(let e=0;e<t.length-2;e++)this.checkCollapse(t[e],t[e+1],t[e+2])}}hasInteriorIntersection(t,e,n){for(let s=0;s<t.getIntersectionNum();s++){const i=t.getIntersection(s);if(!i.equals(e)&&!i.equals(n))return!0}return!1}checkCollapse(t,e,n){if(t.equals(n))throw new c("found non-noded collapse at "+mi.fact.createLineString([t,e,n]))}getClass(){return mi}get interfaces_(){return[]}}mi.constructor_=function(){this._li=new te,this._segStrings=null;const t=arguments[0];this._segStrings=t},mi.fact=new Ht;class yi{constructor(){yi.constructor_.apply(this,arguments)}intersectsScaled(t,e){const n=Math.min(t.x,e.x),s=Math.max(t.x,e.x),i=Math.min(t.y,e.y),r=Math.max(t.y,e.y),o=this._maxx<n||this._minx>s||this._maxy<i||this._miny>r;if(o)return!1;const l=this.intersectsToleranceSquare(t,e);return u.isTrue(!(o&&l),"Found bad envelope test"),l}initCorners(t){this._minx=t.x-.5,this._maxx=t.x+.5,this._miny=t.y-.5,this._maxy=t.y+.5,this._corner[0]=new g(this._maxx,this._maxy),this._corner[1]=new g(this._minx,this._maxy),this._corner[2]=new g(this._minx,this._miny),this._corner[3]=new g(this._maxx,this._miny)}intersects(t,e){return 1===this._scaleFactor?this.intersectsScaled(t,e):(this.copyScaled(t,this._p0Scaled),this.copyScaled(e,this._p1Scaled),this.intersectsScaled(this._p0Scaled,this._p1Scaled))}scale(t){return Math.round(t*this._scaleFactor)}getCoordinate(){return this._originalPt}copyScaled(t,e){e.x=this.scale(t.x),e.y=this.scale(t.y)}getSafeEnvelope(){if(null===this._safeEnv){const t=yi.SAFE_ENV_EXPANSION_FACTOR/this._scaleFactor;this._safeEnv=new N(this._originalPt.x-t,this._originalPt.x+t,this._originalPt.y-t,this._originalPt.y+t)}return this._safeEnv}intersectsPixelClosure(t,e){return this._li.computeIntersection(t,e,this._corner[0],this._corner[1]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[1],this._corner[2]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[2],this._corner[3]),!!this._li.hasIntersection()||(this._li.computeIntersection(t,e,this._corner[3],this._corner[0]),!!this._li.hasIntersection())))}intersectsToleranceSquare(t,e){let n=!1,s=!1;return this._li.computeIntersection(t,e,this._corner[0],this._corner[1]),!!this._li.isProper()||(this._li.computeIntersection(t,e,this._corner[1],this._corner[2]),!!this._li.isProper()||(this._li.hasIntersection()&&(n=!0),this._li.computeIntersection(t,e,this._corner[2],this._corner[3]),!!this._li.isProper()||(this._li.hasIntersection()&&(s=!0),this._li.computeIntersection(t,e,this._corner[3],this._corner[0]),!!this._li.isProper()||(!(!n||!s)||(!!t.equals(this._pt)||!!e.equals(this._pt))))))}addSnappedNode(t,e){const n=t.getCoordinate(e),s=t.getCoordinate(e+1);return!!this.intersects(n,s)&&(t.addIntersection(this.getCoordinate(),e),!0)}getClass(){return yi}get interfaces_(){return[]}}yi.constructor_=function(){this._li=null,this._pt=null,this._originalPt=null,this._ptScaled=null,this._p0Scaled=null,this._p1Scaled=null,this._scaleFactor=null,this._minx=null,this._maxx=null,this._miny=null,this._maxy=null,this._corner=new Array(4).fill(null),this._safeEnv=null;const t=arguments[0],e=arguments[1],s=arguments[2];if(this._originalPt=t,this._pt=t,this._scaleFactor=e,this._li=s,e<=0)throw new n("Scale factor must be non-zero");1!==e&&(this._pt=new g(this.scale(t.x),this.scale(t.y)),this._p0Scaled=new g,this._p1Scaled=new g),this.initCorners(this._pt)},yi.SAFE_ENV_EXPANSION_FACTOR=.75;class xi{constructor(){xi.constructor_.apply(this,arguments)}select(){if(1===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];t.getLineSegment(e,this.selectedSegment),this.select(this.selectedSegment)}}getClass(){return xi}get interfaces_(){return[]}}xi.constructor_=function(){this.selectedSegment=new ee};class Ei{constructor(){Ei.constructor_.apply(this,arguments)}snap(){if(1===arguments.length){const t=arguments[0];return this.snap(t,null,-1)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=t.getSafeEnvelope(),i=new Ii(t,e,n);return this._index.query(s,new class{get interfaces_(){return[Ae]}visitItem(t){t.select(s,i)}}),i.isNodeAdded()}}getClass(){return Ei}get interfaces_(){return[]}}class Ii extends xi{constructor(){super(),Ii.constructor_.apply(this,arguments)}isNodeAdded(){return this._isNodeAdded}select(){if(!(2===arguments.length&&Number.isInteger(arguments[1])&&arguments[0]instanceof qs))return super.select.apply(this,arguments);{const t=arguments[0],e=arguments[1],n=t.getContext();if(null!==this._parentEdge&&n===this._parentEdge&&e===this._hotPixelVertexIndex)return null;this._isNodeAdded=this._hotPixel.addSnappedNode(n,e)}}getClass(){return Ii}get interfaces_(){return[]}}Ii.constructor_=function(){this._hotPixel=null,this._parentEdge=null,this._hotPixelVertexIndex=null,this._isNodeAdded=!1;const t=arguments[0],e=arguments[1],n=arguments[2];this._hotPixel=t,this._parentEdge=e,this._hotPixelVertexIndex=n},Ei.HotPixelSnapAction=Ii,Ei.constructor_=function(){this._index=null;const t=arguments[0];this._index=t};class Ni{constructor(){Ni.constructor_.apply(this,arguments)}processIntersections(t,e,n,s){if(t===n&&e===s)return null;const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];if(this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&this._li.isInteriorIntersection()){for(let t=0;t<this._li.getIntersectionNum();t++)this._interiorIntersections.add(this._li.getIntersection(t));t.addIntersections(this._li,e,0),n.addIntersections(this._li,s,1)}}isDone(){return!1}getInteriorIntersections(){return this._interiorIntersections}getClass(){return Ni}get interfaces_(){return[_i]}}Ni.constructor_=function(){this._li=null,this._interiorIntersections=null;const t=arguments[0];this._li=t,this._interiorIntersections=new x};class Ci{constructor(){Ci.constructor_.apply(this,arguments)}checkCorrectness(t){const e=Fs.getNodedSubstrings(t),n=new mi(e);try{n.checkValid()}catch(t){if(!(t instanceof C))throw t;t.printStackTrace()}}getNodedSubstrings(){return Fs.getNodedSubstrings(this._nodedSegStrings)}snapRound(t,e){const n=this.findInteriorIntersections(t,e);this.computeIntersectionSnaps(n),this.computeVertexSnaps(t)}findInteriorIntersections(t,e){const n=new Ni(e);return this._noder.setSegmentIntersector(n),this._noder.computeNodes(t),n.getInteriorIntersections()}computeVertexSnaps(){if(_(arguments[0],f)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.computeVertexSnaps(e)}}else if(arguments[0]instanceof Fs){const t=arguments[0],e=t.getCoordinates();for(let n=0;n<e.length;n++){const s=new yi(e[n],this._scaleFactor,this._li);this._pointSnapper.snap(s,t,n)&&t.addIntersection(e[n],n)}}}computeNodes(t){this._nodedSegStrings=t,this._noder=new Ys,this._pointSnapper=new Ei(this._noder.getIndex()),this.snapRound(t,this._li)}computeIntersectionSnaps(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=new yi(t,this._scaleFactor,this._li);this._pointSnapper.snap(n)}}getClass(){return Ci}get interfaces_(){return[Vs]}}Ci.constructor_=function(){this._pm=null,this._li=null,this._scaleFactor=null,this._noder=null,this._pointSnapper=null,this._nodedSegStrings=null;const t=arguments[0];this._pm=t,this._li=new te,this._li.setPrecisionModel(t),this._scaleFactor=t.getScale()};class Si{constructor(){Si.constructor_.apply(this,arguments)}static bufferOp(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return new Si(t).getResultGeometry(e)}if(3===arguments.length){if(Number.isInteger(arguments[2])&&arguments[0]instanceof q&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2],s=new Si(t);return s.setQuadrantSegments(n),s.getResultGeometry(e)}if(arguments[2]instanceof js&&arguments[0]instanceof q&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1],n=arguments[2];return new Si(t,n).getResultGeometry(e)}}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=new Si(t);return i.setQuadrantSegments(n),i.setEndCapStyle(s),i.getResultGeometry(e)}}static precisionScaleFactor(t,e,n){const s=t.getEnvelopeInternal(),i=M.max(Math.abs(s.getMaxX()),Math.abs(s.getMaxY()),Math.abs(s.getMinX()),Math.abs(s.getMinY()))+2*(e>0?e:0),r=n-Math.trunc(Math.log(i)/Math.log(10)+1);return Math.pow(10,r)}bufferFixedPrecision(t){const e=new ks(new Ci(new kt(1)),t.getScale()),n=new pi(this._bufParams);n.setWorkingPrecisionModel(t),n.setNoder(e),this._resultGeometry=n.buffer(this._argGeom,this._distance)}bufferReducedPrecision(){if(0===arguments.length){for(let t=Si.MAX_PRECISION_DIGITS;t>=0;t--){try{this.bufferReducedPrecision(t)}catch(t){if(!(t instanceof Wn))throw t;this._saveException=t}if(null!==this._resultGeometry)return null}throw this._saveException}if(1===arguments.length){const t=arguments[0],e=Si.precisionScaleFactor(this._argGeom,this._distance,t),n=new kt(e);this.bufferFixedPrecision(n)}}computeGeometry(){if(this.bufferOriginalPrecision(),null!==this._resultGeometry)return null;const t=this._argGeom.getFactory().getPrecisionModel();t.getType()===kt.FIXED?this.bufferFixedPrecision(t):this.bufferReducedPrecision()}setQuadrantSegments(t){this._bufParams.setQuadrantSegments(t)}bufferOriginalPrecision(){try{const t=new pi(this._bufParams);this._resultGeometry=t.buffer(this._argGeom,this._distance)}catch(t){if(!(t instanceof c))throw t;this._saveException=t}}getResultGeometry(t){return this._distance=t,this.computeGeometry(),this._resultGeometry}setEndCapStyle(t){this._bufParams.setEndCapStyle(t)}getClass(){return Si}get interfaces_(){return[]}}Si.constructor_=function(){if(this._argGeom=null,this._distance=null,this._bufParams=new js,this._resultGeometry=null,this._saveException=null,1===arguments.length){const t=arguments[0];this._argGeom=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._argGeom=t,this._bufParams=e}},Si.CAP_ROUND=js.CAP_ROUND,Si.CAP_BUTT=js.CAP_FLAT,Si.CAP_FLAT=js.CAP_FLAT,Si.CAP_SQUARE=js.CAP_SQUARE,Si.MAX_PRECISION_DIGITS=12;var wi=Object.freeze({__proto__:null,BufferOp:Si,BufferParameters:js});class Li{constructor(){Li.constructor_.apply(this,arguments)}isInsideArea(){return this._segIndex===Li.INSIDE_AREA}getCoordinate(){return this._pt}getGeometryComponent(){return this._component}getSegmentIndex(){return this._segIndex}getClass(){return Li}get interfaces_(){return[]}}Li.constructor_=function(){if(this._component=null,this._segIndex=null,this._pt=null,2===arguments.length){const t=arguments[0],e=arguments[1];Li.constructor_.call(this,t,Li.INSIDE_AREA,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._component=t,this._segIndex=e,this._pt=n}},Li.INSIDE_AREA=-1;class Ti{constructor(){Ti.constructor_.apply(this,arguments)}static getLocations(t){const e=new x;return t.apply(new Ti(e)),e}filter(t){(t instanceof Pt||t instanceof Tt||t instanceof bt)&&this._locations.add(new Li(t,0,t.getCoordinate()))}getClass(){return Ti}get interfaces_(){return[gt]}}Ti.constructor_=function(){this._locations=null;const t=arguments[0];this._locations=t};class Ri{constructor(){Ri.constructor_.apply(this,arguments)}static distance(t,e){return new Ri(t,e).distance()}static isWithinDistance(t,e,n){return!(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>n)&&new Ri(t,e,n).distance()<=n}static nearestPoints(t,e){return new Ri(t,e).nearestPoints()}computeContainmentDistance(){if(0===arguments.length){const t=new Array(2).fill(null);if(this.computeContainmentDistance(0,t),this._minDistance<=this._terminateDistance)return null;this.computeContainmentDistance(1,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this._geom[t];if(n.getDimension()<2)return null;const s=1-t,i=Ne.getPolygons(n);if(i.size()>0){const n=Ti.getLocations(this._geom[s]);if(this.computeContainmentDistance(n,i,e),this._minDistance<=this._terminateDistance)return this._minDistanceLocation[s]=e[0],this._minDistanceLocation[t]=e[1],null}}else if(3===arguments.length)if(arguments[2]instanceof Array&&_(arguments[0],m)&&_(arguments[1],m)){const t=arguments[0],e=arguments[1],n=arguments[2];for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++)if(this.computeContainmentDistance(i,e.get(t),n),this._minDistance<=this._terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof Li&&arguments[1]instanceof bt){const t=arguments[0],e=arguments[1],n=arguments[2],s=t.getCoordinate();if(ne.EXTERIOR!==this._ptLocator.locate(s,e))return this._minDistance=0,n[0]=t,n[1]=new Li(e,s),null}}computeMinDistanceLinesPoints(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t);if(this.computeMinDistance(i,s,n),this._minDistance<=this._terminateDistance)return null}}}computeFacetDistance(){const t=new Array(2).fill(null),e=xe.getLines(this._geom[0]),n=xe.getLines(this._geom[1]),s=Ie.getPoints(this._geom[0]),i=Ie.getPoints(this._geom[1]);return this.computeMinDistanceLines(e,n,t),this.updateMinDistance(t,!1),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(e,i,t),this.updateMinDistance(t,!1),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(n,s,t),this.updateMinDistance(t,!0),this._minDistance<=this._terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistancePoints(s,i,t),void this.updateMinDistance(t,!1))))}nearestLocations(){return this.computeMinDistance(),this._minDistanceLocation}updateMinDistance(t,e){if(null===t[0])return null;e?(this._minDistanceLocation[0]=t[1],this._minDistanceLocation[1]=t[0]):(this._minDistanceLocation[0]=t[0],this._minDistanceLocation[1]=t[1])}nearestPoints(){return this.computeMinDistance(),[this._minDistanceLocation[0].getCoordinate(),this._minDistanceLocation[1].getCoordinate()]}computeMinDistance(){if(0===arguments.length){if(null!==this._minDistanceLocation)return null;if(this._minDistanceLocation=new Array(2).fill(null),this.computeContainmentDistance(),this._minDistance<=this._terminateDistance)return null;this.computeFacetDistance()}else if(3===arguments.length)if(arguments[2]instanceof Array&&arguments[0]instanceof Tt&&arguments[1]instanceof Pt){const t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this._minDistance)return null;const s=t.getCoordinates(),i=e.getCoordinate();for(let r=0;r<s.length-1;r++){const o=D.pointToSegment(i,s[r],s[r+1]);if(o<this._minDistance){this._minDistance=o;const l=new ee(s[r],s[r+1]).closestPoint(i);n[0]=new Li(t,r,l),n[1]=new Li(e,0,i)}if(this._minDistance<=this._terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof Tt&&arguments[1]instanceof Tt){const t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this._minDistance)return null;const s=t.getCoordinates(),i=e.getCoordinates();for(let r=0;r<s.length-1;r++)for(let o=0;o<i.length-1;o++){const l=D.segmentToSegment(s[r],s[r+1],i[o],i[o+1]);if(l<this._minDistance){this._minDistance=l;const a=new ee(s[r],s[r+1]),c=new ee(i[o],i[o+1]),h=a.closestPoints(c);n[0]=new Li(t,r,h[0]),n[1]=new Li(e,o,h[1])}if(this._minDistance<=this._terminateDistance)return null}}}computeMinDistancePoints(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t),r=i.getCoordinate().distance(s.getCoordinate());if(r<this._minDistance&&(this._minDistance=r,n[0]=new Li(i,0,i.getCoordinate()),n[1]=new Li(s,0,s.getCoordinate())),this._minDistance<=this._terminateDistance)return null}}}distance(){if(null===this._geom[0]||null===this._geom[1])throw new n("null geometries are not supported");return this._geom[0].isEmpty()||this._geom[1].isEmpty()?0:(this.computeMinDistance(),this._minDistance)}computeMinDistanceLines(t,e,n){for(let s=0;s<t.size();s++){const i=t.get(s);for(let t=0;t<e.size();t++){const s=e.get(t);if(this.computeMinDistance(i,s,n),this._minDistance<=this._terminateDistance)return null}}}getClass(){return Ri}get interfaces_(){return[]}}Ri.constructor_=function(){if(this._geom=null,this._terminateDistance=0,this._ptLocator=new _n,this._minDistanceLocation=null,this._minDistance=i.MAX_VALUE,2===arguments.length){const t=arguments[0],e=arguments[1];Ri.constructor_.call(this,t,e,0)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._geom=new Array(2).fill(null),this._geom[0]=t,this._geom[1]=e,this._terminateDistance=n}};var Pi=Object.freeze({__proto__:null,DistanceOp:Ri});class vi{constructor(){vi.constructor_.apply(this,arguments)}getCoordinates(){if(null===this._coordinates){let t=0,e=0;const n=new I;for(let s=this._directedEdges.iterator();s.hasNext();){const i=s.next();i.getEdgeDirection()?t++:e++,n.add(i.getEdge().getLine().getCoordinates(),!1,i.getEdgeDirection())}this._coordinates=n.toCoordinateArray(),e>t&&X.reverse(this._coordinates)}return this._coordinates}toLineString(){return this._factory.createLineString(this.getCoordinates())}add(t){this._directedEdges.add(t)}getClass(){return vi}get interfaces_(){return[]}}vi.constructor_=function(){this._factory=null,this._directedEdges=new x,this._coordinates=null;const t=arguments[0];this._factory=t};class Oi{constructor(){Oi.constructor_.apply(this,arguments)}static getComponentWithVisitedState(t,e){for(;t.hasNext();){const n=t.next();if(n.isVisited()===e)return n}return null}static setVisited(t,e){for(;t.hasNext();){t.next().setVisited(e)}}static setMarked(t,e){for(;t.hasNext();){t.next().setMarked(e)}}setVisited(t){this._isVisited=t}isMarked(){return this._isMarked}setData(t){this._data=t}getData(){return this._data}setMarked(t){this._isMarked=t}getContext(){return this._data}isVisited(){return this._isVisited}setContext(t){this._data=t}getClass(){return Oi}get interfaces_(){return[]}}Oi.constructor_=function(){this._isMarked=!1,this._isVisited=!1,this._data=null};class bi extends Oi{constructor(){super(),bi.constructor_.apply(this,arguments)}static toEdges(t){const e=new x;for(let n=t.iterator();n.hasNext();)e.add(n.next()._parentEdge);return e}isRemoved(){return null===this._parentEdge}compareDirection(t){return this._quadrant>t._quadrant?1:this._quadrant<t._quadrant?-1:v.index(t._p0,t._p1,this._p1)}getCoordinate(){return this._from.getCoordinate()}print(t){const e=this.getClass().getName(),n=e.lastIndexOf("."),s=e.substring(n+1);t.print("  "+s+": "+this._p0+" - "+this._p1+" "+this._quadrant+":"+this._angle)}getDirectionPt(){return this._p1}getAngle(){return this._angle}compareTo(t){const e=t;return this.compareDirection(e)}getFromNode(){return this._from}getSym(){return this._sym}setEdge(t){this._parentEdge=t}remove(){this._sym=null,this._parentEdge=null}getEdge(){return this._parentEdge}getQuadrant(){return this._quadrant}setSym(t){this._sym=t}getToNode(){return this._to}getEdgeDirection(){return this._edgeDirection}getClass(){return bi}get interfaces_(){return[r]}}bi.constructor_=function(){if(this._parentEdge=null,this._from=null,this._to=null,this._p0=null,this._p1=null,this._sym=null,this._edgeDirection=null,this._quadrant=null,this._angle=null,0===arguments.length);else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._from=t,this._to=e,this._edgeDirection=s,this._p0=t.getCoordinate(),this._p1=n;const i=this._p1.x-this._p0.x,r=this._p1.y-this._p0.y;this._quadrant=In.quadrant(i,r),this._angle=Math.atan2(r,i)}};class Mi extends bi{constructor(){super(),Mi.constructor_.apply(this,arguments)}getNext(){return 2!==this.getToNode().getDegree()?null:this.getToNode().getOutEdges().getEdges().get(0)===this.getSym()?this.getToNode().getOutEdges().getEdges().get(1):(u.isTrue(this.getToNode().getOutEdges().getEdges().get(1)===this.getSym()),this.getToNode().getOutEdges().getEdges().get(0))}getClass(){return Mi}get interfaces_(){return[]}}Mi.constructor_=function(){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];bi.constructor_.call(this,t,e,n,s)};class Di extends Oi{constructor(){super(),Di.constructor_.apply(this,arguments)}isRemoved(){return null===this._dirEdge}setDirectedEdges(t,e){this._dirEdge=[t,e],t.setEdge(this),e.setEdge(this),t.setSym(e),e.setSym(t),t.getFromNode().addOutEdge(t),e.getFromNode().addOutEdge(e)}getDirEdge(){if(Number.isInteger(arguments[0])){const t=arguments[0];return this._dirEdge[t]}if(arguments[0]instanceof Fi){const t=arguments[0];return this._dirEdge[0].getFromNode()===t?this._dirEdge[0]:this._dirEdge[1].getFromNode()===t?this._dirEdge[1]:null}}remove(){this._dirEdge=null}getOppositeNode(t){return this._dirEdge[0].getFromNode()===t?this._dirEdge[0].getToNode():this._dirEdge[1].getFromNode()===t?this._dirEdge[1].getToNode():null}getClass(){return Di}get interfaces_(){return[]}}Di.constructor_=function(){if(this._dirEdge=null,0===arguments.length);else if(2===arguments.length){const t=arguments[0],e=arguments[1];this.setDirectedEdges(t,e)}};class Ai{constructor(){Ai.constructor_.apply(this,arguments)}getNextEdge(t){const e=this.getIndex(t);return this._outEdges.get(this.getIndex(e+1))}getCoordinate(){const t=this.iterator();return t.hasNext()?t.next().getCoordinate():null}iterator(){return this.sortEdges(),this._outEdges.iterator()}sortEdges(){this._sorted||(Ee.sort(this._outEdges),this._sorted=!0)}remove(t){this._outEdges.remove(t)}getEdges(){return this.sortEdges(),this._outEdges}getNextCWEdge(t){const e=this.getIndex(t);return this._outEdges.get(this.getIndex(e-1))}getIndex(){if(arguments[0]instanceof Di){const t=arguments[0];this.sortEdges();for(let e=0;e<this._outEdges.size();e++){if(this._outEdges.get(e).getEdge()===t)return e}return-1}if(arguments[0]instanceof bi){const t=arguments[0];this.sortEdges();for(let e=0;e<this._outEdges.size();e++){if(this._outEdges.get(e)===t)return e}return-1}if(Number.isInteger(arguments[0])){let t=arguments[0]%this._outEdges.size();return t<0&&(t+=this._outEdges.size()),t}}add(t){this._outEdges.add(t),this._sorted=!1}getDegree(){return this._outEdges.size()}getClass(){return Ai}get interfaces_(){return[]}}Ai.constructor_=function(){this._outEdges=new x,this._sorted=!1};class Fi extends Oi{constructor(){super(),Fi.constructor_.apply(this,arguments)}static getEdgesBetween(t,e){const n=new J(bi.toEdges(t.getOutEdges().getEdges())),s=bi.toEdges(e.getOutEdges().getEdges());return n.retainAll(s),n}isRemoved(){return null===this._pt}addOutEdge(t){this._deStar.add(t)}getCoordinate(){return this._pt}getOutEdges(){return this._deStar}remove(){if(0===arguments.length)this._pt=null;else if(1===arguments.length){const t=arguments[0];this._deStar.remove(t)}}getIndex(t){return this._deStar.getIndex(t)}getDegree(){return this._deStar.getDegree()}getClass(){return Fi}get interfaces_(){return[]}}Fi.constructor_=function(){if(this._pt=null,this._deStar=null,1===arguments.length){const t=arguments[0];Fi.constructor_.call(this,t,new Ai)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._pt=t,this._deStar=e}};class Gi extends Di{constructor(){super(),Gi.constructor_.apply(this,arguments)}getLine(){return this._line}getClass(){return Gi}get interfaces_(){return[]}}Gi.constructor_=function(){this._line=null;const t=arguments[0];this._line=t};class qi{constructor(){qi.constructor_.apply(this,arguments)}find(t){return this._nodeMap.get(t)}iterator(){return this._nodeMap.values().iterator()}remove(t){return this._nodeMap.remove(t)}values(){return this._nodeMap.values()}add(t){return this._nodeMap.put(t.getCoordinate(),t),t}getClass(){return qi}get interfaces_(){return[]}}qi.constructor_=function(){this._nodeMap=new rt};class Bi{constructor(){Bi.constructor_.apply(this,arguments)}findNodesOfDegree(t){const e=new x;for(let n=this.nodeIterator();n.hasNext();){const s=n.next();s.getDegree()===t&&e.add(s)}return e}dirEdgeIterator(){return this._dirEdges.iterator()}edgeIterator(){return this._edges.iterator()}remove(){if(arguments[0]instanceof Di){const t=arguments[0];this.remove(t.getDirEdge(0)),this.remove(t.getDirEdge(1)),this._edges.remove(t),t.remove()}else if(arguments[0]instanceof bi){const t=arguments[0],e=t.getSym();null!==e&&e.setSym(null),t.getFromNode().remove(t),t.remove(),this._dirEdges.remove(t)}else if(arguments[0]instanceof Fi){const t=arguments[0];for(let e=t.getOutEdges().getEdges().iterator();e.hasNext();){const t=e.next(),n=t.getSym();null!==n&&this.remove(n),this._dirEdges.remove(t);const s=t.getEdge();null!==s&&this._edges.remove(s)}this._nodeMap.remove(t.getCoordinate()),t.remove()}}findNode(t){return this._nodeMap.find(t)}getEdges(){return this._edges}nodeIterator(){return this._nodeMap.iterator()}contains(){if(arguments[0]instanceof Di){const t=arguments[0];return this._edges.contains(t)}if(arguments[0]instanceof bi){const t=arguments[0];return this._dirEdges.contains(t)}}add(){if(arguments[0]instanceof Fi){const t=arguments[0];this._nodeMap.add(t)}else if(arguments[0]instanceof Di){const t=arguments[0];this._edges.add(t),this.add(t.getDirEdge(0)),this.add(t.getDirEdge(1))}else if(arguments[0]instanceof bi){const t=arguments[0];this._dirEdges.add(t)}}getNodes(){return this._nodeMap.values()}getClass(){return Bi}get interfaces_(){return[]}}Bi.constructor_=function(){this._edges=new J,this._dirEdges=new J,this._nodeMap=new qi};class Vi extends Bi{constructor(){super(),Vi.constructor_.apply(this,arguments)}addEdge(t){if(t.isEmpty())return null;const e=X.removeRepeatedPoints(t.getCoordinates());if(e.length<=1)return null;const n=e[0],s=e[e.length-1],i=this.getNode(n),r=this.getNode(s),o=new Mi(i,r,e[1],!0),l=new Mi(r,i,e[e.length-2],!1),a=new Gi(t);a.setDirectedEdges(o,l),this.add(a)}getNode(t){let e=this.findNode(t);return null===e&&(e=new Fi(t),this.add(e)),e}getClass(){return Vi}get interfaces_(){return[]}}Vi.constructor_=function(){};class zi{constructor(){zi.constructor_.apply(this,arguments)}buildEdgeStringsForUnprocessedNodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next();e.isMarked()||(u.isTrue(2===e.getDegree()),this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}}buildEdgeStringsForNonDegree2Nodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next();2!==e.getDegree()&&(this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}}buildEdgeStringsForObviousStartNodes(){this.buildEdgeStringsForNonDegree2Nodes()}getMergedLineStrings(){return this.merge(),this._mergedLineStrings}buildEdgeStringsStartingAt(t){for(let e=t.getOutEdges().iterator();e.hasNext();){const t=e.next();t.getEdge().isMarked()||this._edgeStrings.add(this.buildEdgeStringStartingWith(t))}}merge(){if(null!==this._mergedLineStrings)return null;Oi.setMarked(this._graph.nodeIterator(),!1),Oi.setMarked(this._graph.edgeIterator(),!1),this._edgeStrings=new x,this.buildEdgeStringsForObviousStartNodes(),this.buildEdgeStringsForIsolatedLoops(),this._mergedLineStrings=new x;for(let t=this._edgeStrings.iterator();t.hasNext();){const e=t.next();this._mergedLineStrings.add(e.toLineString())}}addLineString(t){null===this._factory&&(this._factory=t.getFactory()),this._graph.addEdge(t)}buildEdgeStringStartingWith(t){const e=new vi(this._factory);let n=t;do{e.add(n),n.getEdge().setMarked(!0),n=n.getNext()}while(null!==n&&n!==t);return e}add(){if(arguments[0]instanceof q){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);n instanceof Tt&&this.addLineString(n)}}else if(_(arguments[0],f)){const t=arguments[0];this._mergedLineStrings=null;for(let e=t.iterator();e.hasNext();){const t=e.next();this.add(t)}}}buildEdgeStringsForIsolatedLoops(){this.buildEdgeStringsForUnprocessedNodes()}getClass(){return zi}get interfaces_(){return[]}}zi.constructor_=function(){this._graph=new Vi,this._mergedLineStrings=null,this._factory=null,this._edgeStrings=null};class Yi{constructor(){Yi.constructor_.apply(this,arguments)}dirEdgeIterator(){return this._dirEdges.iterator()}edgeIterator(){return this._edges.iterator()}getParent(){return this._parentGraph}nodeIterator(){return this._nodeMap.iterator()}contains(t){return this._edges.contains(t)}add(t){if(this._edges.contains(t))return null;this._edges.add(t),this._dirEdges.add(t.getDirEdge(0)),this._dirEdges.add(t.getDirEdge(1)),this._nodeMap.add(t.getDirEdge(0).getFromNode()),this._nodeMap.add(t.getDirEdge(1).getFromNode())}getClass(){return Yi}get interfaces_(){return[]}}Yi.constructor_=function(){this._parentGraph=null,this._edges=new J,this._dirEdges=new x,this._nodeMap=new qi;const t=arguments[0];this._parentGraph=t};class Ui{constructor(){Ui.constructor_.apply(this,arguments)}addReachable(t,e){const n=new on;for(n.add(t);!n.empty();){const t=n.pop();this.addEdges(t,n,e)}}findSubgraph(t){const e=new Yi(this._graph);return this.addReachable(t,e),e}getConnectedSubgraphs(){const t=new x;Oi.setVisited(this._graph.nodeIterator(),!1);for(let e=this._graph.edgeIterator();e.hasNext();){const n=e.next().getDirEdge(0).getFromNode();n.isVisited()||t.add(this.findSubgraph(n))}return t}addEdges(t,e,n){t.setVisited(!0);for(let s=t.getOutEdges().iterator();s.hasNext();){const t=s.next();n.add(t.getEdge());const i=t.getToNode();i.isVisited()||e.push(i)}}getClass(){return Ui}get interfaces_(){return[]}}Ui.constructor_=function(){this._graph=null;const t=arguments[0];this._graph=t};class ki{constructor(){ki.constructor_.apply(this,arguments)}static findUnvisitedBestOrientedDE(t){let e=null,n=null;for(let s=t.getOutEdges().iterator();s.hasNext();){const t=s.next();t.getEdge().isVisited()||(n=t,t.getEdgeDirection()&&(e=t))}return null!==e?e:n}static findLowestDegreeNode(t){let e=L.MAX_VALUE,n=null;for(let s=t.nodeIterator();s.hasNext();){const t=s.next();(null===n||t.getDegree()<e)&&(e=t.getDegree(),n=t)}return n}static isSequenced(t){if(!(t instanceof ft))return!0;const e=t,n=new at;let s=null;const i=new x;for(let t=0;t<e.getNumGeometries();t++){const r=e.getGeometryN(t),o=r.getCoordinateN(0),l=r.getCoordinateN(r.getNumPoints()-1);if(n.contains(o))return!1;if(n.contains(l))return!1;null!==s&&(o.equals(s)||(n.addAll(i),i.clear())),i.add(o),i.add(l),s=l}return!0}static reverse(t){const e=t.getCoordinates(),n=new Array(e.length).fill(null),s=e.length;for(let t=0;t<s;t++)n[s-1-t]=new g(e[t]);return t.getFactory().createLineString(n)}static sequence(t){const e=new ki;return e.add(t),e.getSequencedLineStrings()}addLine(t){null===this._factory&&(this._factory=t.getFactory()),this._graph.addEdge(t),this._lineCount++}hasSequence(t){let e=0;for(let n=t.nodeIterator();n.hasNext();){n.next().getDegree()%2==1&&e++}return e<=2}computeSequence(){if(this._isRun)return null;this._isRun=!0;const t=this.findSequences();if(null===t)return null;this._sequencedGeometry=this.buildSequencedGeometry(t),this._isSequenceable=!0;const e=this._sequencedGeometry.getNumGeometries();u.isTrue(this._lineCount===e,"Lines were missing from result"),u.isTrue(this._sequencedGeometry instanceof Tt||this._sequencedGeometry instanceof ft,"Result is not lineal")}findSequences(){const t=new x;for(let e=new Ui(this._graph).getConnectedSubgraphs().iterator();e.hasNext();){const n=e.next();if(!this.hasSequence(n))return null;{const e=this.findSequence(n);t.add(e)}}return t}addReverseSubpath(t,e,n){const s=t.getToNode();let i=null;for(;;){e.add(t.getSym()),t.getEdge().setVisited(!0),i=t.getFromNode();const n=ki.findUnvisitedBestOrientedDE(i);if(null===n)break;t=n.getSym()}n&&u.isTrue(i===s,"path not contiguous")}findSequence(t){Oi.setVisited(t.edgeIterator(),!1);const e=ki.findLowestDegreeNode(t).getOutEdges().iterator().next().getSym(),n=new Zs,s=n.listIterator();for(this.addReverseSubpath(e,s,!1);s.hasPrevious();){const t=s.previous(),e=ki.findUnvisitedBestOrientedDE(t.getFromNode());null!==e&&this.addReverseSubpath(e.getSym(),s,!0)}return this.orient(n)}reverse(t){const e=new Zs;for(let n=t.iterator();n.hasNext();){const t=n.next();e.addFirst(t.getSym())}return e}orient(t){const e=t.get(0),n=t.get(t.size()-1),s=e.getFromNode(),i=n.getToNode();let r=!1;if(1===s.getDegree()||1===i.getDegree()){let t=!1;1===n.getToNode().getDegree()&&!1===n.getEdgeDirection()&&(t=!0,r=!0),1===e.getFromNode().getDegree()&&!0===e.getEdgeDirection()&&(t=!0,r=!1),t||1===e.getFromNode().getDegree()&&(r=!0)}return r?this.reverse(t):t}buildSequencedGeometry(t){const e=new x;for(let n=t.iterator();n.hasNext();){for(let t=n.next().iterator();t.hasNext();){const n=t.next(),s=n.getEdge().getLine();let i=s;n.getEdgeDirection()||s.isClosed()||(i=ki.reverse(s)),e.add(i)}}return 0===e.size()?this._factory.createMultiLineString(new Array(0).fill(null)):this._factory.buildGeometry(e)}getSequencedLineStrings(){return this.computeSequence(),this._sequencedGeometry}isSequenceable(){return this.computeSequence(),this._isSequenceable}add(){if(_(arguments[0],f)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof q){arguments[0].apply(new class{get interfaces_(){return[G]}filter(t){t instanceof Tt&&this.addLine(t)}})}}getClass(){return ki}get interfaces_(){return[]}}ki.constructor_=function(){this._graph=new Vi,this._factory=new Ht,this._lineCount=0,this._isRun=!1,this._sequencedGeometry=null,this._isSequenceable=!1};var Xi=Object.freeze({__proto__:null,LineMerger:zi,LineSequencer:ki});class Hi{constructor(){Hi.constructor_.apply(this,arguments)}static isClosed(t){return!(t.length<=1)&&t[0].equals2D(t[t.length-1])}snapVertices(t,e){const n=this._isClosed?t.size()-1:t.size();for(let s=0;s<n;s++){const n=t.get(s),i=this.findSnapForVertex(n,e);null!==i&&(t.set(s,new g(i)),0===s&&this._isClosed&&t.set(t.size()-1,new g(i)))}}findSnapForVertex(t,e){for(let n=0;n<e.length;n++){if(t.equals2D(e[n]))return null;if(t.distance(e[n])<this._snapTolerance)return e[n]}return null}snapTo(t){const e=new I(this._srcPts);return this.snapVertices(e,t),this.snapSegments(e,t),e.toCoordinateArray()}snapSegments(t,e){if(0===e.length)return null;let n=e.length;e[0].equals2D(e[e.length-1])&&(n=e.length-1);for(let s=0;s<n;s++){const n=e[s],i=this.findSegmentIndexToSnap(n,t);i>=0&&t.add(i+1,new g(n),!1)}}findSegmentIndexToSnap(t,e){let n=i.MAX_VALUE,s=-1;for(let i=0;i<e.size()-1;i++){if(this._seg.p0=e.get(i),this._seg.p1=e.get(i+1),this._seg.p0.equals2D(t)||this._seg.p1.equals2D(t)){if(this._allowSnappingToSourceVertices)continue;return-1}const r=this._seg.distance(t);r<this._snapTolerance&&r<n&&(n=r,s=i)}return s}setAllowSnappingToSourceVertices(t){this._allowSnappingToSourceVertices=t}getClass(){return Hi}get interfaces_(){return[]}}Hi.constructor_=function(){if(this._snapTolerance=0,this._srcPts=null,this._seg=new ee,this._allowSnappingToSourceVertices=!1,this._isClosed=!1,arguments[0]instanceof Tt&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];Hi.constructor_.call(this,t.getCoordinates(),e)}else if(arguments[0]instanceof Array&&"number"==typeof arguments[1]){const t=arguments[0],e=arguments[1];this._srcPts=t,this._isClosed=Hi.isClosed(t),this._snapTolerance=e}};class Wi{constructor(){Wi.constructor_.apply(this,arguments)}static snap(t,e,n){const s=new Array(2).fill(null),i=new Wi(t);s[0]=i.snapTo(e,n);const r=new Wi(e);return s[1]=r.snapTo(s[0],n),s}static computeOverlaySnapTolerance(){if(1===arguments.length){const t=arguments[0];let e=Wi.computeSizeBasedSnapTolerance(t);const n=t.getPrecisionModel();if(n.getType()===kt.FIXED){const t=1/n.getScale()*2/1.415;t>e&&(e=t)}return e}if(2===arguments.length){const t=arguments[0],e=arguments[1];return Math.min(Wi.computeOverlaySnapTolerance(t),Wi.computeOverlaySnapTolerance(e))}}static computeSizeBasedSnapTolerance(t){const e=t.getEnvelopeInternal();return Math.min(e.getHeight(),e.getWidth())*Wi.SNAP_PRECISION_FACTOR}static snapToSelf(t,e,n){return new Wi(t).snapToSelf(e,n)}snapTo(t,e){const n=this.extractTargetCoordinates(t);return new ji(e,n).transform(this._srcGeom)}snapToSelf(t,e){const n=this.extractTargetCoordinates(this._srcGeom),s=new ji(t,n,!0).transform(this._srcGeom);let i=s;return e&&_(i,Ot)&&(i=s.buffer(0)),i}computeSnapTolerance(t){return this.computeMinimumSegmentLength(t)/10}extractTargetCoordinates(t){const e=new at,n=t.getCoordinates();for(let t=0;t<n.length;t++)e.add(n[t]);return e.toArray(new Array(0).fill(null))}computeMinimumSegmentLength(t){let e=i.MAX_VALUE;for(let n=0;n<t.length-1;n++){const s=t[n].distance(t[n+1]);s<e&&(e=s)}return e}getClass(){return Wi}get interfaces_(){return[]}}Wi.constructor_=function(){this._srcGeom=null;const t=arguments[0];this._srcGeom=t},Wi.SNAP_PRECISION_FACTOR=1e-9;class ji extends me{constructor(){super(),ji.constructor_.apply(this,arguments)}snapLine(t,e){const n=new Hi(t,this._snapTolerance);return n.setAllowSnappingToSourceVertices(this._isSelfSnap),n.snapTo(e)}transformCoordinates(t,e){const n=t.toCoordinateArray(),s=this.snapLine(n,this._snapPts);return this._factory.getCoordinateSequenceFactory().create(s)}getClass(){return ji}get interfaces_(){return[]}}ji.constructor_=function(){if(this._snapTolerance=null,this._snapPts=null,this._isSelfSnap=!1,2===arguments.length){const t=arguments[0],e=arguments[1];this._snapTolerance=t,this._snapPts=e}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._snapTolerance=t,this._snapPts=e,this._isSelfSnap=n}};var Ki=Object.freeze({__proto__:null,GeometrySnapper:Wi,LineStringSnapper:Hi});class Zi{constructor(){Zi.constructor_.apply(this,arguments)}getCoordinates(){return this._pts}size(){return this._pts.length}getCoordinate(t){return this._pts[t]}isClosed(){return this._pts[0].equals(this._pts[this._pts.length-1])}getSegmentOctant(t){return t===this._pts.length-1?-1:Ms.octant(this.getCoordinate(t),this.getCoordinate(t+1))}setData(t){this._data=t}getData(){return this._data}toString(){return Jt.toLineString(new zt(this._pts))}getClass(){return Zi}get interfaces_(){return[Ds]}}Zi.constructor_=function(){this._pts=null,this._data=null;const t=arguments[0],e=arguments[1];this._pts=t,this._data=e};class Qi{constructor(){Qi.constructor_.apply(this,arguments)}static createAllIntersectionsFinder(t){const e=new Qi(t);return e.setFindAllIntersections(!0),e}static createAnyIntersectionFinder(t){return new Qi(t)}static createIntersectionCounter(t){const e=new Qi(t);return e.setFindAllIntersections(!0),e.setKeepIntersections(!1),e}getInteriorIntersection(){return this._interiorIntersection}setCheckEndSegmentsOnly(t){this._isCheckEndSegmentsOnly=t}getIntersectionSegments(){return this._intSegments}count(){return this._intersectionCount}getIntersections(){return this._intersections}setFindAllIntersections(t){this._findAllIntersections=t}setKeepIntersections(t){this._keepIntersections=t}processIntersections(t,e,n,s){if(!this._findAllIntersections&&this.hasIntersection())return null;if(t===n&&e===s)return null;if(this._isCheckEndSegmentsOnly){if(!(this.isEndSegment(t,e)||this.isEndSegment(n,s)))return null}const i=t.getCoordinates()[e],r=t.getCoordinates()[e+1],o=n.getCoordinates()[s],l=n.getCoordinates()[s+1];this._li.computeIntersection(i,r,o,l),this._li.hasIntersection()&&this._li.isInteriorIntersection()&&(this._intSegments=new Array(4).fill(null),this._intSegments[0]=i,this._intSegments[1]=r,this._intSegments[2]=o,this._intSegments[3]=l,this._interiorIntersection=this._li.getIntersection(0),this._keepIntersections&&this._intersections.add(this._interiorIntersection),this._intersectionCount++)}isEndSegment(t,e){return 0===e||e>=t.size()-2}hasIntersection(){return null!==this._interiorIntersection}isDone(){return!this._findAllIntersections&&null!==this._interiorIntersection}getClass(){return Qi}get interfaces_(){return[_i]}}Qi.constructor_=function(){this._findAllIntersections=!1,this._isCheckEndSegmentsOnly=!1,this._li=null,this._interiorIntersection=null,this._intSegments=null,this._intersections=new x,this._intersectionCount=0,this._keepIntersections=!0;const t=arguments[0];this._li=t,this._interiorIntersection=null};class Ji{constructor(){Ji.constructor_.apply(this,arguments)}static computeIntersections(t){const e=new Ji(t);return e.setFindAllIntersections(!0),e.isValid(),e.getIntersections()}execute(){if(null!==this._segInt)return null;this.checkInteriorIntersections()}getIntersections(){return this._segInt.getIntersections()}isValid(){return this.execute(),this._isValid}setFindAllIntersections(t){this._findAllIntersections=t}checkInteriorIntersections(){this._isValid=!0,this._segInt=new Qi(this._li),this._segInt.setFindAllIntersections(this._findAllIntersections);const t=new Ys;if(t.setSegmentIntersector(this._segInt),t.computeNodes(this._segStrings),this._segInt.hasIntersection())return this._isValid=!1,null}checkValid(){if(this.execute(),!this._isValid)throw new Wn(this.getErrorMessage(),this._segInt.getInteriorIntersection())}getErrorMessage(){if(this._isValid)return"no intersections found";const t=this._segInt.getIntersectionSegments();return"found non-noded intersection between "+Jt.toLineString(t[0],t[1])+" and "+Jt.toLineString(t[2],t[3])}getClass(){return Ji}get interfaces_(){return[]}}Ji.constructor_=function(){this._li=new te,this._segStrings=null,this._findAllIntersections=!1,this._segInt=null,this._isValid=!0;const t=arguments[0];this._segStrings=t};class $i{constructor(){$i.constructor_.apply(this,arguments)}static toSegmentStrings(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new Zi(t.getCoordinates(),t))}return e}static checkValid(t){new $i(t).checkValid()}checkValid(){this._nv.checkValid()}getClass(){return $i}get interfaces_(){return[]}}$i.constructor_=function(){this._nv=null;const t=arguments[0];this._nv=new Ji($i.toSegmentStrings(t))};class tr{constructor(){tr.constructor_.apply(this,arguments)}collectLines(t){for(let e=this._op.getGraph().getEdgeEnds().iterator();e.hasNext();){const n=e.next();this.collectLineEdge(n,t,this._lineEdgesList),this.collectBoundaryTouchEdge(n,t,this._lineEdgesList)}}labelIsolatedLine(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._op.getArgGeometry(e));t.getLabel().setLocation(e,n)}build(t){return this.findCoveredLineEdges(),this.collectLines(t),this.buildLines(t),this._resultLineList}collectLineEdge(t,e,n){const s=t.getLabel(),i=t.getEdge();t.isLineEdge()&&(t.isVisited()||!cr.isResultOfOp(s,e)||i.isCovered()||(n.add(i),t.setVisitedEdge(!0)))}findCoveredLineEdges(){for(let t=this._op.getGraph().getNodes().iterator();t.hasNext();){t.next().getEdges().findCoveredLineEdges()}for(let t=this._op.getGraph().getEdgeEnds().iterator();t.hasNext();){const e=t.next(),n=e.getEdge();if(e.isLineEdge()&&!n.isCoveredSet()){const t=this._op.isCoveredByA(e.getCoordinate());n.setCovered(t)}}}labelIsolatedLines(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getLabel();t.isIsolated()&&(n.isNull(0)?this.labelIsolatedLine(t,0):this.labelIsolatedLine(t,1))}}buildLines(t){for(let t=this._lineEdgesList.iterator();t.hasNext();){const e=t.next(),n=(e.getLabel(),this._geometryFactory.createLineString(e.getCoordinates()));this._resultLineList.add(n),e.setInResult(!0)}}collectBoundaryTouchEdge(t,e,n){const s=t.getLabel();return t.isLineEdge()||t.isVisited()||t.isInteriorAreaEdge()||t.getEdge().isInResult()?null:(u.isTrue(!(t.isInResult()||t.getSym().isInResult())||!t.getEdge().isInResult()),void(cr.isResultOfOp(s,e)&&e===cr.INTERSECTION&&(n.add(t.getEdge()),t.setVisitedEdge(!0))))}getClass(){return tr}get interfaces_(){return[]}}tr.constructor_=function(){this._op=null,this._geometryFactory=null,this._ptLocator=null,this._lineEdgesList=new x,this._resultLineList=new x;const t=arguments[0],e=arguments[1],n=arguments[2];this._op=t,this._geometryFactory=e,this._ptLocator=n};class er{constructor(){er.constructor_.apply(this,arguments)}filterCoveredNodeToPoint(t){const e=t.getCoordinate();if(!this._op.isCoveredByLA(e)){const t=this._geometryFactory.createPoint(e);this._resultPointList.add(t)}}extractNonCoveredResultNodes(t){for(let e=this._op.getGraph().getNodes().iterator();e.hasNext();){const n=e.next();if(!n.isInResult()&&(!n.isIncidentEdgeInResult()&&(0===n.getEdges().getDegree()||t===cr.INTERSECTION))){const e=n.getLabel();cr.isResultOfOp(e,t)&&this.filterCoveredNodeToPoint(n)}}}build(t){return this.extractNonCoveredResultNodes(t),this._resultPointList}getClass(){return er}get interfaces_(){return[]}}er.constructor_=function(){this._op=null,this._geometryFactory=null,this._resultPointList=new x;const t=arguments[0],e=arguments[1];this._op=t,this._geometryFactory=e};class nr{constructor(){this._isFirst=!0,this._commonMantissaBitsCount=53,this._commonBits=new s,this._commonSignExp=null}getCommon(){return i.longBitsToDouble(this._commonBits)}add(t){const e=i.doubleToLongBits(t);return this._isFirst?(this._commonBits=e,this._commonSignExp=nr.signExpBits(this._commonBits),this._isFirst=!1,null):nr.signExpBits(e)!==this._commonSignExp?(this._commonBits.high=0,this._commonBits.low=0,null):(this._commonMantissaBitsCount=nr.numCommonMostSigMantissaBits(this._commonBits,e),void(this._commonBits=nr.zeroLowerBits(this._commonBits,64-(12+this._commonMantissaBitsCount))))}toString(){if(1===arguments.length){const t=arguments[0],e=i.longBitsToDouble(t),n="0000000000000000000000000000000000000000000000000000000000000000"+s.toBinaryString(t),r=n.substring(n.length-64);return r.substring(0,1)+"  "+r.substring(1,12)+"(exp) "+r.substring(12)+" [ "+e+" ]"}}getClass(){return nr}get interfaces_(){return[]}static getBit(t,e){const n=1<<e%32;return e<32?0!=(t.low&n)?1:0:0!=(t.high&n)?1:0}static signExpBits(t){return t.high>>>20}static zeroLowerBits(t,e){let n="low";if(e>32&&(t.low=0,e%=32,n="high"),e>0){const s=e<32?~((1<<e)-1):0;t[n]&=s}return t}static numCommonMostSigMantissaBits(t,e){let n=0;for(let s=52;s>=0;s--){if(nr.getBit(t,s)!==nr.getBit(e,s))return n;n++}return 52}}class sr{constructor(){sr.constructor_.apply(this,arguments)}addCommonBits(t){const e=new rr(this._commonCoord);t.apply(e),t.geometryChanged()}removeCommonBits(t){if(0===this._commonCoord.x&&0===this._commonCoord.y)return t;const e=new g(this._commonCoord);e.x=-e.x,e.y=-e.y;const n=new rr(e);return t.apply(n),t.geometryChanged(),t}getCommonCoordinate(){return this._commonCoord}add(t){t.apply(this._ccFilter),this._commonCoord=this._ccFilter.getCommonCoordinate()}getClass(){return sr}get interfaces_(){return[]}}class ir{constructor(){ir.constructor_.apply(this,arguments)}filter(t){this._commonBitsX.add(t.x),this._commonBitsY.add(t.y)}getCommonCoordinate(){return new g(this._commonBitsX.getCommon(),this._commonBitsY.getCommon())}getClass(){return ir}get interfaces_(){return[B]}}ir.constructor_=function(){this._commonBitsX=new nr,this._commonBitsY=new nr};class rr{constructor(){rr.constructor_.apply(this,arguments)}filter(t,e){const n=t.getOrdinate(e,0)+this.trans.x,s=t.getOrdinate(e,1)+this.trans.y;t.setOrdinate(e,0,n),t.setOrdinate(e,1,s)}isDone(){return!1}isGeometryChanged(){return!0}getClass(){return rr}get interfaces_(){return[dt]}}rr.constructor_=function(){this.trans=null;const t=arguments[0];this.trans=t},sr.CommonCoordinateFilter=ir,sr.Translater=rr,sr.constructor_=function(){this._commonCoord=null,this._ccFilter=new ir};class or{constructor(){or.constructor_.apply(this,arguments)}static overlayOp(t,e,n){return new or(t,e).getResultGeometry(n)}static union(t,e){return or.overlayOp(t,e,cr.UNION)}static intersection(t,e){return or.overlayOp(t,e,cr.INTERSECTION)}static symDifference(t,e){return or.overlayOp(t,e,cr.SYMDIFFERENCE)}static difference(t,e){return or.overlayOp(t,e,cr.DIFFERENCE)}selfSnap(t){return new Wi(t).snapTo(t,this._snapTolerance)}removeCommonBits(t){this._cbr=new sr,this._cbr.add(t[0]),this._cbr.add(t[1]);const e=new Array(2).fill(null);return e[0]=this._cbr.removeCommonBits(t[0].copy()),e[1]=this._cbr.removeCommonBits(t[1].copy()),e}prepareResult(t){return this._cbr.addCommonBits(t),t}getResultGeometry(t){const e=this.snap(this._geom),n=cr.overlayOp(e[0],e[1],t);return this.prepareResult(n)}checkValid(t){t.isValid()||O.out.println("Snapped geometry is invalid")}computeSnapTolerance(){this._snapTolerance=Wi.computeOverlaySnapTolerance(this._geom[0],this._geom[1])}snap(t){const e=this.removeCommonBits(t);return Wi.snap(e[0],e[1],this._snapTolerance)}getClass(){return or}get interfaces_(){return[]}}or.constructor_=function(){this._geom=new Array(2).fill(null),this._snapTolerance=null,this._cbr=null;const t=arguments[0],e=arguments[1];this._geom[0]=t,this._geom[1]=e,this.computeSnapTolerance()};class lr{constructor(){lr.constructor_.apply(this,arguments)}static overlayOp(t,e,n){return new lr(t,e).getResultGeometry(n)}static union(t,e){return lr.overlayOp(t,e,cr.UNION)}static intersection(t,e){return lr.overlayOp(t,e,cr.INTERSECTION)}static symDifference(t,e){return lr.overlayOp(t,e,cr.SYMDIFFERENCE)}static difference(t,e){return lr.overlayOp(t,e,cr.DIFFERENCE)}getResultGeometry(t){let e=null,n=!1,s=null;try{e=cr.overlayOp(this._geom[0],this._geom[1],t),!0&&(n=!0)}catch(t){if(!(t instanceof c))throw t;s=t}if(!n)try{e=or.overlayOp(this._geom[0],this._geom[1],t)}catch(t){throw t instanceof c?s:t}return e}getClass(){return lr}get interfaces_(){return[]}}lr.constructor_=function(){this._geom=new Array(2).fill(null);const t=arguments[0],e=arguments[1];this._geom[0]=t,this._geom[1]=e};class ar{constructor(){ar.constructor_.apply(this,arguments)}getArgGeometry(t){return this._arg[t].getGeometry()}setComputationPrecision(t){this._resultPrecisionModel=t,this._li.setPrecisionModel(this._resultPrecisionModel)}getClass(){return ar}get interfaces_(){return[]}}ar.constructor_=function(){if(this._li=new te,this._resultPrecisionModel=null,this._arg=null,1===arguments.length){const t=arguments[0];this.setComputationPrecision(t.getPrecisionModel()),this._arg=new Array(1).fill(null),this._arg[0]=new Qn(0,t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];ar.constructor_.call(this,t,e,V.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];t.getPrecisionModel().compareTo(e.getPrecisionModel())>=0?this.setComputationPrecision(t.getPrecisionModel()):this.setComputationPrecision(e.getPrecisionModel()),this._arg=new Array(2).fill(null),this._arg[0]=new Qn(0,t,n),this._arg[1]=new Qn(1,e,n)}};class cr extends ar{constructor(){super(),cr.constructor_.apply(this,arguments)}static overlayOp(t,e,n){return new cr(t,e).getResultGeometry(n)}static union(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return cr.createEmptyResult(cr.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}if(t.isGeometryCollection()||e.isGeometryCollection())throw new n("This method does not support GeometryCollection arguments");return lr.overlayOp(t,e,cr.UNION)}static intersection(t,e){if(t.isEmpty()||e.isEmpty())return cr.createEmptyResult(cr.INTERSECTION,t,e,t.getFactory());if(t.isGeometryCollection()){const n=e;return ge.map(t,new class{get interfaces_(){return[fe]}map(t){return cr.intersection(t,n)}})}return lr.overlayOp(t,e,cr.INTERSECTION)}static symDifference(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return cr.createEmptyResult(cr.SYMDIFFERENCE,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}if(t.isGeometryCollection()||e.isGeometryCollection())throw new n("This method does not support GeometryCollection arguments");return lr.overlayOp(t,e,cr.SYMDIFFERENCE)}static resultDimension(t,e,n){const s=e.getDimension(),i=n.getDimension();let r=-1;switch(t){case cr.INTERSECTION:r=Math.min(s,i);break;case cr.UNION:r=Math.max(s,i);break;case cr.DIFFERENCE:r=s;break;case cr.SYMDIFFERENCE:r=Math.max(s,i)}return r}static createEmptyResult(t,e,n,s){let i=null;switch(cr.resultDimension(t,e,n)){case-1:i=s.createGeometryCollection();break;case 0:i=s.createPoint();break;case 1:i=s.createLineString();break;case 2:i=s.createPolygon()}return i}static difference(t,e){if(t.isEmpty())return cr.createEmptyResult(cr.DIFFERENCE,t,e,t.getFactory());if(e.isEmpty())return t.copy();if(t.isGeometryCollection()||e.isGeometryCollection())throw new n("This method does not support GeometryCollection arguments");return lr.overlayOp(t,e,cr.DIFFERENCE)}static isResultOfOp(){if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getLocation(0),s=t.getLocation(1);return cr.isResultOfOp(n,s,e)}if(3===arguments.length){let t=arguments[0],e=arguments[1];const n=arguments[2];switch(t===ne.BOUNDARY&&(t=ne.INTERIOR),e===ne.BOUNDARY&&(e=ne.INTERIOR),n){case cr.INTERSECTION:return t===ne.INTERIOR&&e===ne.INTERIOR;case cr.UNION:return t===ne.INTERIOR||e===ne.INTERIOR;case cr.DIFFERENCE:return t===ne.INTERIOR&&e!==ne.INTERIOR;case cr.SYMDIFFERENCE:return t===ne.INTERIOR&&e!==ne.INTERIOR||t!==ne.INTERIOR&&e===ne.INTERIOR}return!1}}insertUniqueEdge(t){const e=this._edgeList.findEqualEdge(t);if(null!==e){const n=e.getLabel();let s=t.getLabel();e.isPointwiseEqual(t)||(s=new Fn(t.getLabel()),s.flip());const i=e.getDepth();i.isNull()&&i.add(n),i.add(s),n.merge(s)}else this._edgeList.add(t)}getGraph(){return this._graph}cancelDuplicateResultEdges(){for(let t=this._graph.getEdgeEnds().iterator();t.hasNext();){const e=t.next(),n=e.getSym();e.isInResult()&&n.isInResult()&&(e.setInResult(!1),n.setInResult(!1))}}isCoveredByLA(t){return!!this.isCovered(t,this._resultLineList)||!!this.isCovered(t,this._resultPolyList)}computeGeometry(t,e,n,s){const i=new x;return i.addAll(t),i.addAll(e),i.addAll(n),i.isEmpty()?cr.createEmptyResult(s,this._arg[0].getGeometry(),this._arg[1].getGeometry(),this._geomFact):this._geomFact.buildGeometry(i)}mergeSymLabels(){for(let t=this._graph.getNodes().iterator();t.hasNext();){t.next().getEdges().mergeSymLabels()}}isCovered(t,e){for(let n=e.iterator();n.hasNext();){const e=n.next();if(this._ptLocator.locate(t,e)!==ne.EXTERIOR)return!0}return!1}replaceCollapsedEdges(){const t=new x;for(let e=this._edgeList.iterator();e.hasNext();){const n=e.next();n.isCollapsed()&&(e.remove(),t.add(n.getCollapsedEdge()))}this._edgeList.addAll(t)}updateNodeLabelling(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next(),n=e.getEdges().getLabel();e.getLabel().merge(n)}}getResultGeometry(t){return this.computeOverlay(t),this._resultGeom}insertUniqueEdges(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertUniqueEdge(t)}}computeOverlay(t){this.copyPoints(0),this.copyPoints(1),this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1),this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!0);const e=new x;this._arg[0].computeSplitEdges(e),this._arg[1].computeSplitEdges(e),this.insertUniqueEdges(e),this.computeLabelsFromDepths(),this.replaceCollapsedEdges(),$i.checkValid(this._edgeList.getEdges()),this._graph.addEdges(this._edgeList.getEdges()),this.computeLabelling(),this.labelIncompleteNodes(),this.findResultAreaEdges(t),this.cancelDuplicateResultEdges();const n=new ei(this._geomFact);n.add(this._graph),this._resultPolyList=n.getPolygons();const s=new tr(this,this._geomFact,this._ptLocator);this._resultLineList=s.build(t);const i=new er(this,this._geomFact,this._ptLocator);this._resultPointList=i.build(t),this._resultGeom=this.computeGeometry(this._resultPointList,this._resultLineList,this._resultPolyList,t)}labelIncompleteNode(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._arg[e].getGeometry());t.getLabel().setLocation(e,n)}copyPoints(t){for(let e=this._arg[t].getNodeIterator();e.hasNext();){const n=e.next();this._graph.addNode(n.getCoordinate()).setLabel(t,n.getLabel().getLocation(t))}}findResultAreaEdges(t){for(let e=this._graph.getEdgeEnds().iterator();e.hasNext();){const n=e.next(),s=n.getLabel();s.isArea()&&!n.isInteriorAreaEdge()&&cr.isResultOfOp(s.getLocation(0,Pn.RIGHT),s.getLocation(1,Pn.RIGHT),t)&&n.setInResult(!0)}}computeLabelsFromDepths(){for(let t=this._edgeList.iterator();t.hasNext();){const e=t.next(),n=e.getLabel(),s=e.getDepth();if(!s.isNull()){s.normalize();for(let t=0;t<2;t++)n.isNull(t)||!n.isArea()||s.isNull(t)||(0===s.getDelta(t)?n.toLine(t):(u.isTrue(!s.isNull(t,Pn.LEFT),"depth of LEFT side has not been initialized"),n.setLocation(t,Pn.LEFT,s.getLocation(t,Pn.LEFT)),u.isTrue(!s.isNull(t,Pn.RIGHT),"depth of RIGHT side has not been initialized"),n.setLocation(t,Pn.RIGHT,s.getLocation(t,Pn.RIGHT))))}}}computeLabelling(){for(let t=this._graph.getNodes().iterator();t.hasNext();){t.next().getEdges().computeLabelling(this._arg)}this.mergeSymLabels(),this.updateNodeLabelling()}labelIncompleteNodes(){for(let t=this._graph.getNodes().iterator();t.hasNext();){const e=t.next(),n=e.getLabel();e.isIsolated()&&(n.isNull(0)?this.labelIncompleteNode(e,0):this.labelIncompleteNode(e,1)),e.getEdges().updateLabelling(n)}}isCoveredByA(t){return!!this.isCovered(t,this._resultPolyList)}getClass(){return cr}get interfaces_(){return[]}}cr.constructor_=function(){this._ptLocator=new _n,this._geomFact=null,this._resultGeom=null,this._graph=null,this._edgeList=new di,this._resultPolyList=new x,this._resultLineList=new x,this._resultPointList=new x;const t=arguments[0],e=arguments[1];ar.constructor_.call(this,t,e),this._graph=new Zn(new ui),this._geomFact=t.getFactory()},cr.INTERSECTION=1,cr.UNION=2,cr.DIFFERENCE=3,cr.SYMDIFFERENCE=4;var hr=Object.freeze({__proto__:null,snap:Ki,OverlayOp:cr});class ur extends bi{constructor(){super(),ur.constructor_.apply(this,arguments)}getNext(){return this._next}isInRing(){return null!==this._edgeRing}setRing(t){this._edgeRing=t}setLabel(t){this._label=t}getLabel(){return this._label}setNext(t){this._next=t}getRing(){return this._edgeRing}getClass(){return ur}get interfaces_(){return[]}}ur.constructor_=function(){this._edgeRing=null,this._next=null,this._label=-1;const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];bi.constructor_.call(this,t,e,n,s)};class gr extends Di{constructor(){super(),gr.constructor_.apply(this,arguments)}getLine(){return this._line}getClass(){return gr}get interfaces_(){return[]}}gr.constructor_=function(){this._line=null;const t=arguments[0];this._line=t};class dr{constructor(){dr.constructor_.apply(this,arguments)}static findDifferentPoint(t,e){for(let n=0;n<t.length;n++)if(!t[n].equals(e))return t[n];return null}visitInteriorRing(t,e){const n=t.getCoordinates(),s=n[0],i=dr.findDifferentPoint(n,s),r=e.findEdgeInSameDirection(s,i),o=e.findEdgeEnd(r);let l=null;o.getLabel().getLocation(0,Pn.RIGHT)===ne.INTERIOR?l=o:o.getSym().getLabel().getLocation(0,Pn.RIGHT)===ne.INTERIOR&&(l=o.getSym()),u.isTrue(null!==l,"unable to find dirEdge with Interior on RHS"),this.visitLinkedDirectedEdges(l)}visitShellInteriors(t,e){if(t instanceof bt){const n=t;this.visitInteriorRing(n.getExteriorRing(),e)}if(t instanceof At){const n=t;for(let t=0;t<n.getNumGeometries();t++){const s=n.getGeometryN(t);this.visitInteriorRing(s.getExteriorRing(),e)}}}getCoordinate(){return this._disconnectedRingcoord}setInteriorEdgesInResult(t){for(let e=t.getEdgeEnds().iterator();e.hasNext();){const t=e.next();t.getLabel().getLocation(0,Pn.RIGHT)===ne.INTERIOR&&t.setInResult(!0)}}visitLinkedDirectedEdges(t){const e=t;let n=t;do{u.isTrue(null!==n,"found null Directed Edge"),n.setVisited(!0),n=n.getNext()}while(n!==e)}buildEdgeRings(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next();if(t.isInResult()&&null===t.getEdgeRing()){const n=new ti(t,this._geometryFactory);n.linkDirectedEdgesForMinimalEdgeRings();const s=n.buildMinimalRings();e.addAll(s)}}return e}hasUnvisitedShellEdge(t){for(let e=0;e<t.size();e++){const n=t.get(e);if(n.isHole())continue;const s=n.getEdges();let i=s.get(0);if(i.getLabel().getLocation(0,Pn.RIGHT)===ne.INTERIOR)for(let t=0;t<s.size();t++)if(i=s.get(t),!i.isVisited())return this._disconnectedRingcoord=i.getCoordinate(),!0}return!1}isInteriorsConnected(){const t=new x;this._geomGraph.computeSplitEdges(t);const e=new Zn(new ui);e.addEdges(t),this.setInteriorEdgesInResult(e),e.linkResultDirectedEdges();const n=this.buildEdgeRings(e.getEdgeEnds());return this.visitShellInteriors(this._geomGraph.getGeometry(),e),!this.hasUnvisitedShellEdge(n)}getClass(){return dr}get interfaces_(){return[]}}dr.constructor_=function(){this._geometryFactory=new Ht,this._geomGraph=null,this._disconnectedRingcoord=null;const t=arguments[0];this._geomGraph=t};class _r{constructor(){_r.constructor_.apply(this,arguments)}createEdgeEndForNext(t,e,n,s){const i=n.segmentIndex+1;if(i>=t.getNumPoints()&&null===s)return null;let r=t.getCoordinate(i);null!==s&&s.segmentIndex===n.segmentIndex&&(r=s.coord);const o=new Hn(t,n.coord,r,new Fn(t.getLabel()));e.add(o)}createEdgeEndForPrev(t,e,n,s){let i=n.segmentIndex;if(0===n.dist){if(0===i)return null;i--}let r=t.getCoordinate(i);null!==s&&s.segmentIndex>=i&&(r=s.coord);const o=new Fn(t.getLabel());o.flip();const l=new Hn(t,n.coord,r,o);e.add(l)}computeEdgeEnds(){if(1===arguments.length){const t=arguments[0],e=new x;for(let n=t;n.hasNext();){const t=n.next();this.computeEdgeEnds(t,e)}return e}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getEdgeIntersectionList();n.addEndpoints();const s=n.iterator();let i=null,r=null;if(!s.hasNext())return null;let o=s.next();do{i=r,r=o,o=null,s.hasNext()&&(o=s.next()),null!==r&&(this.createEdgeEndForPrev(t,e,r,i),this.createEdgeEndForNext(t,e,r,o))}while(null!==r)}}getClass(){return _r}get interfaces_(){return[]}}_r.constructor_=function(){};class fr extends Hn{constructor(){super(),fr.constructor_.apply(this,arguments)}insert(t){this._edgeEnds.add(t)}print(t){t.println("EdgeEndBundle--\x3e Label: "+this._label);for(let e=this.iterator();e.hasNext();){e.next().print(t),t.println()}}iterator(){return this._edgeEnds.iterator()}getEdgeEnds(){return this._edgeEnds}computeLabelOn(t,e){let n=0,s=!1;for(let e=this.iterator();e.hasNext();){const i=e.next().getLabel().getLocation(t);i===ne.BOUNDARY&&n++,i===ne.INTERIOR&&(s=!0)}let i=ne.NONE;s&&(i=ne.INTERIOR),n>0&&(i=Qn.determineBoundary(e,n)),this._label.setLocation(t,i)}computeLabelSide(t,e){for(let n=this.iterator();n.hasNext();){const s=n.next();if(s.getLabel().isArea()){const n=s.getLabel().getLocation(t,e);if(n===ne.INTERIOR)return this._label.setLocation(t,e,ne.INTERIOR),null;n===ne.EXTERIOR&&this._label.setLocation(t,e,ne.EXTERIOR)}}}getLabel(){return this._label}computeLabelSides(t){this.computeLabelSide(t,Pn.LEFT),this.computeLabelSide(t,Pn.RIGHT)}updateIM(t){Un.updateIM(this._label,t)}computeLabel(t){let e=!1;for(let t=this.iterator();t.hasNext();){t.next().getLabel().isArea()&&(e=!0)}this._label=e?new Fn(ne.NONE,ne.NONE,ne.NONE):new Fn(ne.NONE);for(let n=0;n<2;n++)this.computeLabelOn(n,t),e&&this.computeLabelSides(n)}getClass(){return fr}get interfaces_(){return[]}}fr.constructor_=function(){if(this._edgeEnds=new x,1===arguments.length){const t=arguments[0];fr.constructor_.call(this,null,t)}else if(2===arguments.length){const t=arguments[1];Hn.constructor_.call(this,t.getEdge(),t.getCoordinate(),t.getDirectedCoordinate(),new Fn(t.getLabel())),this.insert(t)}};class pr extends ci{constructor(){super(),pr.constructor_.apply(this,arguments)}updateIM(t){for(let e=this.iterator();e.hasNext();){e.next().updateIM(t)}}insert(t){let e=this._edgeMap.get(t);null===e?(e=new fr(t),this.insertEdgeEnd(t,e)):e.insert(t)}getClass(){return pr}get interfaces_(){return[]}}pr.constructor_=function(){};class mr extends kn{constructor(){super(),mr.constructor_.apply(this,arguments)}updateIMFromEdges(t){this._edges.updateIM(t)}computeIM(t){t.setAtLeastIfValid(this._label.getLocation(0),this._label.getLocation(1),0)}getClass(){return mr}get interfaces_(){return[]}}mr.constructor_=function(){const t=arguments[0],e=arguments[1];kn.constructor_.call(this,t,e)};class yr extends Kn{constructor(){super(),yr.constructor_.apply(this,arguments)}createNode(t){return new mr(t,new pr)}getClass(){return yr}get interfaces_(){return[]}}yr.constructor_=function(){};class xr{constructor(){xr.constructor_.apply(this,arguments)}insertEdgeEnds(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._nodes.add(t)}}getNodeIterator(){return this._nodes.iterator()}copyNodesAndLabels(t,e){for(let n=t.getNodeIterator();n.hasNext();){const t=n.next();this._nodes.addNode(t.getCoordinate()).setLabel(e,t.getLabel().getLocation(e))}}build(t){this.computeIntersectionNodes(t,0),this.copyNodesAndLabels(t,0);const e=(new _r).computeEdgeEnds(t.getEdgeIterator());this.insertEdgeEnds(e)}computeIntersectionNodes(t,e){for(let n=t.getEdgeIterator();n.hasNext();){const t=n.next(),s=t.getLabel().getLocation(e);for(let n=t.getEdgeIntersectionList().iterator();n.hasNext();){const t=n.next(),i=this._nodes.addNode(t.coord);s===ne.BOUNDARY?i.setLabelBoundary(e):i.getLabel().isNull(e)&&i.setLabel(e,ne.INTERIOR)}}}getClass(){return xr}get interfaces_(){return[]}}xr.constructor_=function(){this._nodes=new Xn(new yr)};class Er{constructor(){Er.constructor_.apply(this,arguments)}isNodeEdgeAreaLabelsConsistent(){for(let t=this._nodeGraph.getNodeIterator();t.hasNext();){const e=t.next();if(!e.getEdges().isAreaLabelsConsistent(this._geomGraph))return this._invalidPoint=e.getCoordinate().copy(),!1}return!0}getInvalidPoint(){return this._invalidPoint}hasDuplicateRings(){for(let t=this._nodeGraph.getNodeIterator();t.hasNext();){for(let e=t.next().getEdges().iterator();e.hasNext();){const t=e.next();if(t.getEdgeEnds().size()>1)return this._invalidPoint=t.getEdge().getCoordinate(0),!0}}return!1}isNodeConsistentArea(){const t=this._geomGraph.computeSelfNodes(this._li,!0,!0);return t.hasProperIntersection()?(this._invalidPoint=t.getProperIntersectionPoint(),!1):(this._nodeGraph.build(this._geomGraph),this.isNodeEdgeAreaLabelsConsistent())}getClass(){return Er}get interfaces_(){return[]}}Er.constructor_=function(){this._li=new te,this._geomGraph=null,this._nodeGraph=new xr,this._invalidPoint=null;const t=arguments[0];this._geomGraph=t};class Ir{constructor(){Ir.constructor_.apply(this,arguments)}buildIndex(){this._index=new Es;for(let t=0;t<this._rings.size();t++){const e=this._rings.get(t),n=e.getEnvelopeInternal();this._index.insert(n,e)}}getNestedPoint(){return this._nestedPt}isNonNested(){this.buildIndex();for(let t=0;t<this._rings.size();t++){const e=this._rings.get(t),n=e.getCoordinates(),s=this._index.query(e.getEnvelopeInternal());for(let t=0;t<s.size();t++){const i=s.get(t),r=i.getCoordinates();if(e===i)continue;if(!e.getEnvelopeInternal().intersects(i.getEnvelopeInternal()))continue;const o=Cr.findPtNotNode(n,i,this._graph);if(null!==o&&We.isInRing(o,r))return this._nestedPt=o,!1}}return!0}add(t){this._rings.add(t),this._totalEnv.expandToInclude(t.getEnvelopeInternal())}getClass(){return Ir}get interfaces_(){return[]}}Ir.constructor_=function(){this._graph=null,this._rings=new x,this._totalEnv=new N,this._index=null,this._nestedPt=null;const t=arguments[0];this._graph=t};class Nr{constructor(){Nr.constructor_.apply(this,arguments)}getErrorType(){return this._errorType}getMessage(){return Nr.errMsg[this._errorType]}getCoordinate(){return this._pt}toString(){let t="";return null!==this._pt&&(t=" at or near point "+this._pt),this.getMessage()+t}getClass(){return Nr}get interfaces_(){return[]}}Nr.constructor_=function(){if(this._errorType=null,this._pt=null,1===arguments.length){const t=arguments[0];Nr.constructor_.call(this,t,null)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._errorType=t,null!==e&&(this._pt=e.copy())}},Nr.ERROR=0,Nr.REPEATED_POINT=1,Nr.HOLE_OUTSIDE_SHELL=2,Nr.NESTED_HOLES=3,Nr.DISCONNECTED_INTERIOR=4,Nr.SELF_INTERSECTION=5,Nr.RING_SELF_INTERSECTION=6,Nr.NESTED_SHELLS=7,Nr.DUPLICATE_RINGS=8,Nr.TOO_FEW_POINTS=9,Nr.INVALID_COORDINATE=10,Nr.RING_NOT_CLOSED=11,Nr.errMsg=["Topology Validation Error","Repeated Point","Hole lies outside shell","Holes are nested","Interior is disconnected","Self-intersection","Ring Self-intersection","Nested shells","Duplicate Rings","Too few distinct points in geometry component","Invalid Coordinate","Ring is not closed"];class Cr{constructor(){Cr.constructor_.apply(this,arguments)}static findPtNotNode(t,e,n){const s=n.findEdge(e).getEdgeIntersectionList();for(let e=0;e<t.length;e++){const n=t[e];if(!s.isIntersection(n))return n}return null}static isValid(){if(arguments[0]instanceof q){const t=arguments[0];return new Cr(t).isValid()}if(arguments[0]instanceof g){const t=arguments[0];return!i.isNaN(t.x)&&(!i.isInfinite(t.x)&&(!i.isNaN(t.y)&&!i.isInfinite(t.y)))}}checkInvalidCoordinates(){if(arguments[0]instanceof Array){const t=arguments[0];for(let e=0;e<t.length;e++)if(!Cr.isValid(t[e]))return this._validErr=new Nr(Nr.INVALID_COORDINATE,t[e]),null}else if(arguments[0]instanceof bt){const t=arguments[0];if(this.checkInvalidCoordinates(t.getExteriorRing().getCoordinates()),null!==this._validErr)return null;for(let e=0;e<t.getNumInteriorRing();e++)if(this.checkInvalidCoordinates(t.getInteriorRingN(e).getCoordinates()),null!==this._validErr)return null}}checkHolesNotNested(t,e){const n=new Ir(e);for(let e=0;e<t.getNumInteriorRing();e++){const s=t.getInteriorRingN(e);n.add(s)}n.isNonNested()||(this._validErr=new Nr(Nr.NESTED_HOLES,n.getNestedPoint()))}checkConsistentArea(t){const e=new Er(t);if(!e.isNodeConsistentArea())return this._validErr=new Nr(Nr.SELF_INTERSECTION,e.getInvalidPoint()),null;e.hasDuplicateRings()&&(this._validErr=new Nr(Nr.DUPLICATE_RINGS,e.getInvalidPoint()))}isValid(){return this.checkValid(this._parentGeometry),null===this._validErr}checkShellInsideHole(t,e,n){const s=t.getCoordinates(),i=e.getCoordinates(),r=Cr.findPtNotNode(s,e,n);if(null!==r){if(!We.isInRing(r,i))return r}const o=Cr.findPtNotNode(i,t,n);if(null!==o){return We.isInRing(o,s)?o:null}return u.shouldNeverReachHere("points in shell and hole appear to be equal"),null}checkNoSelfIntersectingRings(t){for(let e=t.getEdgeIterator();e.hasNext();){const t=e.next();if(this.checkNoSelfIntersectingRing(t.getEdgeIntersectionList()),null!==this._validErr)return null}}checkConnectedInteriors(t){const e=new dr(t);e.isInteriorsConnected()||(this._validErr=new Nr(Nr.DISCONNECTED_INTERIOR,e.getCoordinate()))}checkNoSelfIntersectingRing(t){const e=new at;let n=!0;for(let s=t.iterator();s.hasNext();){const t=s.next();if(n)n=!1;else{if(e.contains(t.coord))return this._validErr=new Nr(Nr.RING_SELF_INTERSECTION,t.coord),null;e.add(t.coord)}}}checkHolesInShell(t,e){const n=t.getExteriorRing(),s=new ke(n);for(let i=0;i<t.getNumInteriorRing();i++){const r=t.getInteriorRingN(i),o=Cr.findPtNotNode(r.getCoordinates(),n,e);if(null===o)return null;if(ne.EXTERIOR===s.locate(o))return this._validErr=new Nr(Nr.HOLE_OUTSIDE_SHELL,o),null}}checkTooFewPoints(t){if(t.hasTooFewPoints())return this._validErr=new Nr(Nr.TOO_FEW_POINTS,t.getInvalidPoint()),null}getValidationError(){return this.checkValid(this._parentGeometry),this._validErr}checkValid(){if(arguments[0]instanceof Pt){const t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof Mt){const t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof Dt){const t=arguments[0];if(this.checkInvalidCoordinates(t.getCoordinates()),null!==this._validErr)return null;if(this.checkClosedRing(t),null!==this._validErr)return null;const e=new Qn(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;const n=new te;e.computeSelfNodes(n,!0,!0),this.checkNoSelfIntersectingRings(e)}else if(arguments[0]instanceof Tt){const t=arguments[0];if(this.checkInvalidCoordinates(t.getCoordinates()),null!==this._validErr)return null;const e=new Qn(0,t);this.checkTooFewPoints(e)}else if(arguments[0]instanceof bt){const t=arguments[0];if(this.checkInvalidCoordinates(t),null!==this._validErr)return null;if(this.checkClosedRings(t),null!==this._validErr)return null;const e=new Qn(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;if(this.checkConsistentArea(e),null!==this._validErr)return null;if(!this._isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(e),null!==this._validErr))return null;if(this.checkHolesInShell(t,e),null!==this._validErr)return null;if(this.checkHolesNotNested(t,e),null!==this._validErr)return null;this.checkConnectedInteriors(e)}else if(arguments[0]instanceof At){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(this.checkInvalidCoordinates(n),null!==this._validErr)return null;if(this.checkClosedRings(n),null!==this._validErr)return null}const e=new Qn(0,t);if(this.checkTooFewPoints(e),null!==this._validErr)return null;if(this.checkConsistentArea(e),null!==this._validErr)return null;if(!this._isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(e),null!==this._validErr))return null;for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);if(this.checkHolesInShell(s,e),null!==this._validErr)return null}for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n);if(this.checkHolesNotNested(s,e),null!==this._validErr)return null}if(this.checkShellsNotNested(t,e),null!==this._validErr)return null;this.checkConnectedInteriors(e)}else if(arguments[0]instanceof _t){const t=arguments[0];for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(this.checkValid(n),null!==this._validErr)return null}}else if(arguments[0]instanceof q){const t=arguments[0];if(this._validErr=null,t.isEmpty())return null;if(t instanceof Pt)this.checkValid(t);else if(t instanceof Mt)this.checkValid(t);else if(t instanceof Dt)this.checkValid(t);else if(t instanceof Tt)this.checkValid(t);else if(t instanceof bt)this.checkValid(t);else if(t instanceof At)this.checkValid(t);else{if(!(t instanceof _t))throw new Z(t.getClass().getName());this.checkValid(t)}}}setSelfTouchingRingFormingHoleValid(t){this._isSelfTouchingRingFormingHoleValid=t}checkShellNotNested(t,e,n){const s=t.getCoordinates(),i=e.getExteriorRing(),r=i.getCoordinates(),o=Cr.findPtNotNode(s,i,n);if(null===o)return null;if(!We.isInRing(o,r))return null;if(e.getNumInteriorRing()<=0)return this._validErr=new Nr(Nr.NESTED_SHELLS,o),null;let l=null;for(let s=0;s<e.getNumInteriorRing();s++){const i=e.getInteriorRingN(s);if(l=this.checkShellInsideHole(t,i,n),null===l)return null}this._validErr=new Nr(Nr.NESTED_SHELLS,l)}checkClosedRings(t){if(this.checkClosedRing(t.getExteriorRing()),null!==this._validErr)return null;for(let e=0;e<t.getNumInteriorRing();e++)if(this.checkClosedRing(t.getInteriorRingN(e)),null!==this._validErr)return null}checkClosedRing(t){if(!t.isClosed()){let e=null;t.getNumPoints()>=1&&(e=t.getCoordinateN(0)),this._validErr=new Nr(Nr.RING_NOT_CLOSED,e)}}checkShellsNotNested(t,e){for(let n=0;n<t.getNumGeometries();n++){const s=t.getGeometryN(n).getExteriorRing();for(let i=0;i<t.getNumGeometries();i++){if(n===i)continue;const r=t.getGeometryN(i);if(this.checkShellNotNested(s,r,e),null!==this._validErr)return null}}}getClass(){return Cr}get interfaces_(){return[]}}Cr.constructor_=function(){this._parentGeometry=null,this._isSelfTouchingRingFormingHoleValid=!1,this._validErr=null;const t=arguments[0];this._parentGeometry=t};class Sr{constructor(){Sr.constructor_.apply(this,arguments)}static findDirEdgesInRing(t){let e=t;const n=new x;do{n.add(e),e=e.getNext(),u.isTrue(null!==e,"found null DE in ring"),u.isTrue(e===t||!e.isInRing(),"found DE already in ring")}while(e!==t);return n}static addEdge(t,e,n){if(e)for(let e=0;e<t.length;e++)n.add(t[e],!1);else for(let e=t.length-1;e>=0;e--)n.add(t[e],!1)}static findEdgeRingContaining(t,e){const n=t.getRing(),s=n.getEnvelopeInternal();let i=n.getCoordinateN(0),r=null,o=null;for(let t=e.iterator();t.hasNext();){const e=t.next(),l=e.getRing(),a=l.getEnvelopeInternal();if(a.equals(s))continue;if(!a.contains(s))continue;i=X.ptNotInList(n.getCoordinates(),l.getCoordinates());let c=!1;We.isInRing(i,l.getCoordinates())&&(c=!0),c&&(null===r||o.contains(a))&&(r=e,o=r.getRing().getEnvelopeInternal())}return r}isIncluded(){return this._isIncluded}getCoordinates(){if(null===this._ringPts){const t=new I;for(let e=this._deList.iterator();e.hasNext();){const n=e.next(),s=n.getEdge();Sr.addEdge(s.getLine().getCoordinates(),n.getEdgeDirection(),t)}this._ringPts=t.toCoordinateArray()}return this._ringPts}isIncludedSet(){return this._isIncludedSet}isValid(){return this.getCoordinates(),!(this._ringPts.length<=3)&&(this.getRing(),Cr.isValid(this._ring))}build(t){let e=t;do{this.add(e),e.setRing(this),e=e.getNext(),u.isTrue(null!==e,"found null DE in ring"),u.isTrue(e===t||!e.isInRing(),"found DE already in ring")}while(e!==t)}isOuterHole(){return!!this._isHole&&!this.hasShell()}getPolygon(){let t=null;if(null!==this._holes){t=new Array(this._holes.size()).fill(null);for(let e=0;e<this._holes.size();e++)t[e]=this._holes.get(e)}return this._factory.createPolygon(this._ring,t)}isHole(){return this._isHole}isProcessed(){return this._isProcessed}addHole(){if(arguments[0]instanceof Dt){const t=arguments[0];null===this._holes&&(this._holes=new x),this._holes.add(t)}else if(arguments[0]instanceof Sr){const t=arguments[0];t.setShell(this);const e=t.getRing();null===this._holes&&(this._holes=new x),this._holes.add(e)}}setIncluded(t){this._isIncluded=t,this._isIncludedSet=!0}getOuterHole(){if(this.isHole())return null;for(let t=0;t<this._deList.size();t++){const e=this._deList.get(t).getSym().getRing();if(e.isOuterHole())return e}return null}computeHole(){const t=this.getRing();this._isHole=v.isCCW(t.getCoordinates())}hasShell(){return null!==this._shell}isOuterShell(){return null!==this.getOuterHole()}getLineString(){return this.getCoordinates(),this._factory.createLineString(this._ringPts)}toString(){return Jt.toLineString(new zt(this.getCoordinates()))}getShell(){return this.isHole()?this._shell:this}add(t){this._deList.add(t)}getRing(){if(null!==this._ring)return this._ring;this.getCoordinates(),this._ringPts.length<3&&O.out.println(this._ringPts);try{this._ring=this._factory.createLinearRing(this._ringPts)}catch(t){if(!(t instanceof C))throw t;O.out.println(this._ringPts)}return this._ring}updateIncluded(){if(this.isHole())return null;for(let t=0;t<this._deList.size();t++){const e=this._deList.get(t).getSym().getRing().getShell();if(null!==e&&e.isIncludedSet())return this.setIncluded(!e.isIncluded()),null}}setShell(t){this._shell=t}setProcessed(t){this._isProcessed=t}getClass(){return Sr}get interfaces_(){return[]}}class wr{constructor(){wr.constructor_.apply(this,arguments)}compare(t,e){const n=e;return t.getRing().getEnvelope().compareTo(n.getRing().getEnvelope())}getClass(){return wr}get interfaces_(){return[l]}}wr.constructor_=function(){},Sr.EnvelopeComparator=wr,Sr.constructor_=function(){this._factory=null,this._deList=new x,this._lowestEdge=null,this._ring=null,this._ringPts=null,this._holes=null,this._shell=null,this._isHole=null,this._isProcessed=!1,this._isIncludedSet=!1,this._isIncluded=!1;const t=arguments[0];this._factory=t};class Lr extends Bi{constructor(){super(),Lr.constructor_.apply(this,arguments)}static findLabeledEdgeRings(t){const e=new x;let n=1;for(let s=t.iterator();s.hasNext();){const t=s.next();if(t.isMarked())continue;if(t.getLabel()>=0)continue;e.add(t);const i=Sr.findDirEdgesInRing(t);Lr.label(i,n),n++}return e}static getDegreeNonDeleted(t){let e=0;for(let n=t.getOutEdges().getEdges().iterator();n.hasNext();){n.next().isMarked()||e++}return e}static deleteAllEdges(t){for(let e=t.getOutEdges().getEdges().iterator();e.hasNext();){const t=e.next();t.setMarked(!0);const n=t.getSym();null!==n&&n.setMarked(!0)}}static label(t,e){for(let n=t.iterator();n.hasNext();){n.next().setLabel(e)}}static computeNextCWEdges(t){let e=null,n=null;for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){const t=s.next();if(!t.isMarked()){if(null===e&&(e=t),null!==n){n.getSym().setNext(t)}n=t}}if(null!==n){n.getSym().setNext(e)}}static computeNextCCWEdges(t,e){let n=null,s=null;const i=t.getOutEdges().getEdges();for(let t=i.size()-1;t>=0;t--){const r=i.get(t),o=r.getSym();let l=null;r.getLabel()===e&&(l=r);let a=null;o.getLabel()===e&&(a=o),null===l&&null===a||(null!==a&&(s=a),null!==l&&(null!==s&&(s.setNext(l),s=null),null===n&&(n=l)))}null!==s&&(u.isTrue(null!==n),s.setNext(n))}static getDegree(t,e){let n=0;for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){s.next().getLabel()===e&&n++}return n}static findIntersectionNodes(t,e){let n=t,s=null;do{const i=n.getFromNode();Lr.getDegree(i,e)>1&&(null===s&&(s=new x),s.add(i)),n=n.getNext(),u.isTrue(null!==n,"found null DE in ring"),u.isTrue(n===t||!n.isInRing(),"found DE already in ring")}while(n!==t);return s}findEdgeRing(t){const e=new Sr(this._factory);return e.build(t),e}computeDepthParity(){if(0===arguments.length)for(;;)return null}computeNextCWEdges(){for(let t=this.nodeIterator();t.hasNext();){const e=t.next();Lr.computeNextCWEdges(e)}}addEdge(t){if(t.isEmpty())return null;const e=X.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return null;const n=e[0],s=e[e.length-1],i=this.getNode(n),r=this.getNode(s),o=new ur(i,r,e[1],!0),l=new ur(r,i,e[e.length-2],!1),a=new gr(t);a.setDirectedEdges(o,l),this.add(a)}deleteCutEdges(){this.computeNextCWEdges(),Lr.findLabeledEdgeRings(this._dirEdges);const t=new x;for(let e=this._dirEdges.iterator();e.hasNext();){const n=e.next();if(n.isMarked())continue;const s=n.getSym();if(n.getLabel()===s.getLabel()){n.setMarked(!0),s.setMarked(!0);const e=n.getEdge();t.add(e.getLine())}}return t}getEdgeRings(){this.computeNextCWEdges(),Lr.label(this._dirEdges,-1);const t=Lr.findLabeledEdgeRings(this._dirEdges);this.convertMaximalToMinimalEdgeRings(t);const e=new x;for(let t=this._dirEdges.iterator();t.hasNext();){const n=t.next();if(n.isMarked())continue;if(n.isInRing())continue;const s=this.findEdgeRing(n);e.add(s)}return e}getNode(t){let e=this.findNode(t);return null===e&&(e=new Fi(t),this.add(e)),e}convertMaximalToMinimalEdgeRings(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getLabel(),s=Lr.findIntersectionNodes(t,n);if(null!==s)for(let t=s.iterator();t.hasNext();){const e=t.next();Lr.computeNextCCWEdges(e,n)}}}deleteDangles(){const t=this.findNodesOfDegree(1),e=new J,n=new on;for(let e=t.iterator();e.hasNext();)n.push(e.next());for(;!n.isEmpty();){const t=n.pop();Lr.deleteAllEdges(t);for(let s=t.getOutEdges().getEdges().iterator();s.hasNext();){const t=s.next();t.setMarked(!0);const i=t.getSym();null!==i&&i.setMarked(!0);const r=t.getEdge();e.add(r.getLine());const o=t.getToNode();1===Lr.getDegreeNonDeleted(o)&&n.push(o)}}return e}getClass(){return Lr}get interfaces_(){return[]}}Lr.constructor_=function(){this._factory=null;const t=arguments[0];this._factory=t};class Tr{constructor(){Tr.constructor_.apply(this,arguments)}static findOuterShells(t){for(let e=t.iterator();e.hasNext();){const t=e.next(),n=t.getOuterHole();null===n||n.isProcessed()||(t.setIncluded(!0),n.setProcessed(!0))}}static extractPolygons(t,e){const n=new x;for(let s=t.iterator();s.hasNext();){const t=s.next();(e||t.isIncluded())&&n.add(t.getPolygon())}return n}static assignHolesToShells(t,e){for(let n=t.iterator();n.hasNext();){const t=n.next();Tr.assignHoleToShell(t,e)}}static assignHoleToShell(t,e){const n=Sr.findEdgeRingContaining(t,e);null!==n&&n.addHole(t)}static findDisjointShells(t){Tr.findOuterShells(t);let e=null;do{e=!1;for(let n=t.iterator();n.hasNext();){const t=n.next();t.isIncludedSet()||(t.updateIncluded(),t.isIncludedSet()||(e=!0))}}while(e)}getGeometry(){return null===this._geomFactory&&(this._geomFactory=new Ht),this.polygonize(),this._extractOnlyPolygonal?this._geomFactory.buildGeometry(this._polyList):this._geomFactory.createGeometryCollection(Ht.toGeometryArray(this._polyList))}getInvalidRingLines(){return this.polygonize(),this._invalidRingLines}findValidRings(t,e,n){for(let s=t.iterator();s.hasNext();){const t=s.next();t.isValid()?e.add(t):n.add(t.getLineString())}}polygonize(){if(null!==this._polyList)return null;if(this._polyList=new x,null===this._graph)return null;this._dangles=this._graph.deleteDangles(),this._cutEdges=this._graph.deleteCutEdges();const t=this._graph.getEdgeRings();let e=new x;this._invalidRingLines=new x,this._isCheckingRingsValid?this.findValidRings(t,e,this._invalidRingLines):e=t,this.findShellsAndHoles(e),Tr.assignHolesToShells(this._holeList,this._shellList),Ee.sort(this._shellList,new Sr.EnvelopeComparator);let n=!0;this._extractOnlyPolygonal&&(Tr.findDisjointShells(this._shellList),n=!1),this._polyList=Tr.extractPolygons(this._shellList,n)}getDangles(){return this.polygonize(),this._dangles}getCutEdges(){return this.polygonize(),this._cutEdges}getPolygons(){return this.polygonize(),this._polyList}add(){if(_(arguments[0],f)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.add(e)}}else if(arguments[0]instanceof Tt){const t=arguments[0];this._geomFactory=t.getFactory(),null===this._graph&&(this._graph=new Lr(this._geomFactory)),this._graph.addEdge(t)}else if(arguments[0]instanceof q){arguments[0].apply(this._lineStringAdder)}}setCheckRingsValid(t){this._isCheckingRingsValid=t}findShellsAndHoles(t){this._holeList=new x,this._shellList=new x;for(let e=t.iterator();e.hasNext();){const t=e.next();t.computeHole(),t.isHole()?this._holeList.add(t):this._shellList.add(t)}}getClass(){return Tr}get interfaces_(){return[]}}class Rr{constructor(){Rr.constructor_.apply(this,arguments)}filter(t){t instanceof Tt&&this.p.add(t)}getClass(){return Rr}get interfaces_(){return[G]}}Rr.constructor_=function(){this.p=null;const t=arguments[0];this.p=t},Tr.LineStringAdder=Rr,Tr.constructor_=function(){if(this._lineStringAdder=new Rr(this),this._graph=null,this._dangles=new x,this._cutEdges=new x,this._invalidRingLines=new x,this._holeList=null,this._shellList=null,this._polyList=null,this._isCheckingRingsValid=!0,this._extractOnlyPolygonal=null,this._geomFactory=null,0===arguments.length)Tr.constructor_.call(this,!1);else if(1===arguments.length){const t=arguments[0];this._extractOnlyPolygonal=t}};var Pr=Object.freeze({__proto__:null,Polygonizer:Tr});class vr{constructor(){vr.constructor_.apply(this,arguments)}insertEdgeEnds(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this._nodes.add(t)}}computeProperIntersectionIM(t,e){const n=this._arg[0].getGeometry().getDimension(),s=this._arg[1].getGeometry().getDimension(),i=t.hasProperIntersection(),r=t.hasProperInteriorIntersection();2===n&&2===s?i&&e.setAtLeast("212101212"):2===n&&1===s?(i&&e.setAtLeast("FFF0FFFF2"),r&&e.setAtLeast("1FFFFF1FF")):1===n&&2===s?(i&&e.setAtLeast("F0FFFFFF2"),r&&e.setAtLeast("1F1FFFFFF")):1===n&&1===s&&r&&e.setAtLeast("0FFFFFFFF")}labelIsolatedEdges(t,e){for(let n=this._arg[t].getEdgeIterator();n.hasNext();){const t=n.next();t.isIsolated()&&(this.labelIsolatedEdge(t,e,this._arg[e].getGeometry()),this._isolatedEdges.add(t))}}labelIsolatedEdge(t,e,n){if(n.getDimension()>0){const s=this._ptLocator.locate(t.getCoordinate(),n);t.getLabel().setAllLocations(e,s)}else t.getLabel().setAllLocations(e,ne.EXTERIOR)}computeIM(){const t=new se;if(t.set(ne.EXTERIOR,ne.EXTERIOR,2),!this._arg[0].getGeometry().getEnvelopeInternal().intersects(this._arg[1].getGeometry().getEnvelopeInternal()))return this.computeDisjointIM(t),t;this._arg[0].computeSelfNodes(this._li,!1),this._arg[1].computeSelfNodes(this._li,!1);const e=this._arg[0].computeEdgeIntersections(this._arg[1],this._li,!1);this.computeIntersectionNodes(0),this.computeIntersectionNodes(1),this.copyNodesAndLabels(0),this.copyNodesAndLabels(1),this.labelIsolatedNodes(),this.computeProperIntersectionIM(e,t);const n=new _r,s=n.computeEdgeEnds(this._arg[0].getEdgeIterator());this.insertEdgeEnds(s);const i=n.computeEdgeEnds(this._arg[1].getEdgeIterator());return this.insertEdgeEnds(i),this.labelNodeEdges(),this.labelIsolatedEdges(0,1),this.labelIsolatedEdges(1,0),this.updateIM(t),t}labelNodeEdges(){for(let t=this._nodes.iterator();t.hasNext();){t.next().getEdges().computeLabelling(this._arg)}}copyNodesAndLabels(t){for(let e=this._arg[t].getNodeIterator();e.hasNext();){const n=e.next();this._nodes.addNode(n.getCoordinate()).setLabel(t,n.getLabel().getLocation(t))}}labelIntersectionNodes(t){for(let e=this._arg[t].getEdgeIterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.getEdgeIntersectionList().iterator();e.hasNext();){const n=e.next(),i=this._nodes.find(n.coord);i.getLabel().isNull(t)&&(s===ne.BOUNDARY?i.setLabelBoundary(t):i.setLabel(t,ne.INTERIOR))}}}labelIsolatedNode(t,e){const n=this._ptLocator.locate(t.getCoordinate(),this._arg[e].getGeometry());t.getLabel().setAllLocations(e,n)}computeIntersectionNodes(t){for(let e=this._arg[t].getEdgeIterator();e.hasNext();){const n=e.next(),s=n.getLabel().getLocation(t);for(let e=n.getEdgeIntersectionList().iterator();e.hasNext();){const n=e.next(),i=this._nodes.addNode(n.coord);s===ne.BOUNDARY?i.setLabelBoundary(t):i.getLabel().isNull(t)&&i.setLabel(t,ne.INTERIOR)}}}labelIsolatedNodes(){for(let t=this._nodes.iterator();t.hasNext();){const e=t.next(),n=e.getLabel();u.isTrue(n.getGeometryCount()>0,"node with empty label found"),e.isIsolated()&&(n.isNull(0)?this.labelIsolatedNode(e,0):this.labelIsolatedNode(e,1))}}updateIM(t){for(let e=this._isolatedEdges.iterator();e.hasNext();){e.next().updateIM(t)}for(let e=this._nodes.iterator();e.hasNext();){const n=e.next();n.updateIM(t),n.updateIMFromEdges(t)}}computeDisjointIM(t){const e=this._arg[0].getGeometry();e.isEmpty()||(t.set(ne.INTERIOR,ne.EXTERIOR,e.getDimension()),t.set(ne.BOUNDARY,ne.EXTERIOR,e.getBoundaryDimension()));const n=this._arg[1].getGeometry();n.isEmpty()||(t.set(ne.EXTERIOR,ne.INTERIOR,n.getDimension()),t.set(ne.EXTERIOR,ne.BOUNDARY,n.getBoundaryDimension()))}getClass(){return vr}get interfaces_(){return[]}}vr.constructor_=function(){this._li=new te,this._ptLocator=new _n,this._arg=null,this._nodes=new Xn(new yr),this._im=null,this._isolatedEdges=new x,this._invalidPoint=null;const t=arguments[0];this._arg=t};class Or{constructor(){Or.constructor_.apply(this,arguments)}static contains(t,e){return new Or(t).contains(e)}isContainedInBoundary(t){if(t instanceof bt)return!1;if(t instanceof Pt)return this.isPointContainedInBoundary(t);if(t instanceof Tt)return this.isLineStringContainedInBoundary(t);for(let e=0;e<t.getNumGeometries();e++){const n=t.getGeometryN(e);if(!this.isContainedInBoundary(n))return!1}return!0}isLineSegmentContainedInBoundary(t,e){if(t.equals(e))return this.isPointContainedInBoundary(t);if(t.x===e.x){if(t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX())return!0}else if(t.y===e.y&&(t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()))return!0;return!1}isLineStringContainedInBoundary(t){const e=t.getCoordinateSequence(),n=new g,s=new g;for(let t=0;t<e.size()-1;t++)if(e.getCoordinate(t,n),e.getCoordinate(t+1,s),!this.isLineSegmentContainedInBoundary(n,s))return!1;return!0}isPointContainedInBoundary(){if(arguments[0]instanceof Pt){const t=arguments[0];return this.isPointContainedInBoundary(t.getCoordinate())}if(arguments[0]instanceof g){const t=arguments[0];return t.x===this._rectEnv.getMinX()||t.x===this._rectEnv.getMaxX()||t.y===this._rectEnv.getMinY()||t.y===this._rectEnv.getMaxY()}}contains(t){return!!this._rectEnv.contains(t.getEnvelopeInternal())&&!this.isContainedInBoundary(t)}getClass(){return Or}get interfaces_(){return[]}}Or.constructor_=function(){this._rectEnv=null;const t=arguments[0];this._rectEnv=t.getEnvelopeInternal()};class br{constructor(){br.constructor_.apply(this,arguments)}intersects(t,e){const n=new N(t,e);if(!this._rectEnv.intersects(n))return!1;if(this._rectEnv.intersects(t))return!0;if(this._rectEnv.intersects(e))return!0;if(t.compareTo(e)>0){const n=t;t=e,e=n}let s=!1;return e.y>t.y&&(s=!0),s?this._li.computeIntersection(t,e,this._diagDown0,this._diagDown1):this._li.computeIntersection(t,e,this._diagUp0,this._diagUp1),!!this._li.hasIntersection()}getClass(){return br}get interfaces_(){return[]}}br.constructor_=function(){this._li=new te,this._rectEnv=null,this._diagUp0=null,this._diagUp1=null,this._diagDown0=null,this._diagDown1=null;const t=arguments[0];this._rectEnv=t,this._diagUp0=new g(t.getMinX(),t.getMinY()),this._diagUp1=new g(t.getMaxX(),t.getMaxY()),this._diagDown0=new g(t.getMinX(),t.getMaxY()),this._diagDown1=new g(t.getMaxX(),t.getMinY())};class Mr{constructor(){Mr.constructor_.apply(this,arguments)}static intersects(t,e){return new Mr(t).intersects(e)}intersects(t){if(!this._rectEnv.intersects(t.getEnvelopeInternal()))return!1;const e=new Dr(this._rectEnv);if(e.applyTo(t),e.intersects())return!0;const n=new Ar(this._rectangle);if(n.applyTo(t),n.containsPoint())return!0;const s=new Fr(this._rectangle);return s.applyTo(t),!!s.intersects()}getClass(){return Mr}get interfaces_(){return[]}}Mr.constructor_=function(){this._rectangle=null,this._rectEnv=null;const t=arguments[0];this._rectangle=t,this._rectEnv=t.getEnvelopeInternal()};class Dr extends Ce{constructor(){super(),Dr.constructor_.apply(this,arguments)}isDone(){return!0===this._intersects}visit(t){const e=t.getEnvelopeInternal();return this._rectEnv.intersects(e)?this._rectEnv.contains(e)||e.getMinX()>=this._rectEnv.getMinX()&&e.getMaxX()<=this._rectEnv.getMaxX()||e.getMinY()>=this._rectEnv.getMinY()&&e.getMaxY()<=this._rectEnv.getMaxY()?(this._intersects=!0,null):void 0:null}intersects(){return this._intersects}getClass(){return Dr}get interfaces_(){return[]}}Dr.constructor_=function(){this._rectEnv=null,this._intersects=!1;const t=arguments[0];this._rectEnv=t};class Ar extends Ce{constructor(){super(),Ar.constructor_.apply(this,arguments)}isDone(){return!0===this._containsPoint}visit(t){if(!(t instanceof bt))return null;const e=t.getEnvelopeInternal();if(!this._rectEnv.intersects(e))return null;const n=new g;for(let s=0;s<4;s++)if(this._rectSeq.getCoordinate(s,n),e.contains(n)&&Ze.containsPointInPolygon(n,t))return this._containsPoint=!0,null}containsPoint(){return this._containsPoint}getClass(){return Ar}get interfaces_(){return[]}}Ar.constructor_=function(){this._rectSeq=null,this._rectEnv=null,this._containsPoint=!1;const t=arguments[0];this._rectSeq=t.getExteriorRing().getCoordinateSequence(),this._rectEnv=t.getEnvelopeInternal()};class Fr extends Ce{constructor(){super(),Fr.constructor_.apply(this,arguments)}intersects(){return this._hasIntersection}isDone(){return!0===this._hasIntersection}visit(t){const e=t.getEnvelopeInternal();if(!this._rectEnv.intersects(e))return null;const n=xe.getLines(t);this.checkIntersectionWithLineStrings(n)}checkIntersectionWithLineStrings(t){for(let e=t.iterator();e.hasNext();){const t=e.next();if(this.checkIntersectionWithSegments(t),this._hasIntersection)return null}}checkIntersectionWithSegments(t){const e=t.getCoordinateSequence();for(let t=1;t<e.size();t++)if(e.getCoordinate(t-1,this._p0),e.getCoordinate(t,this._p1),this._rectIntersector.intersects(this._p0,this._p1))return this._hasIntersection=!0,null}getClass(){return Fr}get interfaces_(){return[]}}Fr.constructor_=function(){this._rectEnv=null,this._rectIntersector=null,this._hasIntersection=!1,this._p0=new g,this._p1=new g;const t=arguments[0];this._rectEnv=t.getEnvelopeInternal(),this._rectIntersector=new br(this._rectEnv)};class Gr extends ar{constructor(){super(),Gr.constructor_.apply(this,arguments)}static covers(t,e){return!(2===e.getDimension()&&t.getDimension()<2)&&(!(1===e.getDimension()&&t.getDimension()<1&&e.getLength()>0)&&(!!t.getEnvelopeInternal().covers(e.getEnvelopeInternal())&&(!!t.isRectangle()||new Gr(t,e).getIntersectionMatrix().isCovers())))}static intersects(t,e){if(!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal()))return!1;if(t.isRectangle())return Mr.intersects(t,e);if(e.isRectangle())return Mr.intersects(e,t);if(t.isGeometryCollection()||e.isGeometryCollection()){for(let n=0;n<t.getNumGeometries();n++)for(let s=0;s<e.getNumGeometries();s++)if(t.getGeometryN(n).intersects(e.getGeometryN(s)))return!0;return!1}return new Gr(t,e).getIntersectionMatrix().isIntersects()}static touches(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Gr(t,e).getIntersectionMatrix().isTouches(t.getDimension(),e.getDimension())}static equalsTopo(t,e){return!!t.getEnvelopeInternal().equals(e.getEnvelopeInternal())&&Gr.relate(t,e).isEquals(t.getDimension(),e.getDimension())}static relate(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return new Gr(t,e).getIntersectionMatrix()}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return new Gr(t,e,n).getIntersectionMatrix()}}static overlaps(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Gr(t,e).getIntersectionMatrix().isOverlaps(t.getDimension(),e.getDimension())}static crosses(t,e){return!!t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())&&new Gr(t,e).getIntersectionMatrix().isCrosses(t.getDimension(),e.getDimension())}static contains(t,e){return!(2===e.getDimension()&&t.getDimension()<2)&&(!(1===e.getDimension()&&t.getDimension()<1&&e.getLength()>0)&&(!!t.getEnvelopeInternal().contains(e.getEnvelopeInternal())&&(t.isRectangle()?Or.contains(t,e):new Gr(t,e).getIntersectionMatrix().isContains())))}getIntersectionMatrix(){return this._relate.computeIM()}getClass(){return Gr}get interfaces_(){return[]}}Gr.constructor_=function(){if(this._relate=null,2===arguments.length){const t=arguments[0],e=arguments[1];ar.constructor_.call(this,t,e),this._relate=new vr(this._arg)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];ar.constructor_.call(this,t,e,n),this._relate=new vr(this._arg)}};var qr=Object.freeze({__proto__:null,RelateOp:Gr});class Br{constructor(){Br.constructor_.apply(this,arguments)}static union(t,e){return new Br(t,e).union()}union(){const t=new _n,e=new at;for(let n=0;n<this._pointGeom.getNumGeometries();n++){const s=this._pointGeom.getGeometryN(n).getCoordinate();t.locate(s,this._otherGeom)===ne.EXTERIOR&&e.add(s)}if(0===e.size())return this._otherGeom;let n=null;const s=X.toCoordinateArray(e);return n=1===s.length?this._geomFact.createPoint(s[0]):this._geomFact.createMultiPointFromCoords(s),de.combine(n,this._otherGeom)}getClass(){return Br}get interfaces_(){return[]}}Br.constructor_=function(){this._pointGeom=null,this._otherGeom=null,this._geomFact=null;const t=arguments[0],e=arguments[1];this._pointGeom=t,this._otherGeom=e,this._geomFact=e.getFactory()};class Vr{constructor(){Vr.constructor_.apply(this,arguments)}static restrictToPolygons(t){if(_(t,Ot))return t;const e=Ne.getPolygons(t);return 1===e.size()?e.get(0):t.getFactory().createMultiPolygon(Ht.toPolygonArray(e))}static getGeometry(t,e){return e>=t.size()?null:t.get(e)}static union(t){return new Vr(t).union()}reduceToGeometries(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next();let s=null;_(t,m)?s=this.unionTree(t):t instanceof q&&(s=t),e.add(s)}return e}extractByEnvelope(t,e,n){const s=new x;for(let i=0;i<e.getNumGeometries();i++){const r=e.getGeometryN(i);r.getEnvelopeInternal().intersects(t)?s.add(r):n.add(r)}return this._geomFactory.buildGeometry(s)}unionOptimized(t,e){const n=t.getEnvelopeInternal(),s=e.getEnvelopeInternal();if(!n.intersects(s)){return de.combine(t,e)}if(t.getNumGeometries()<=1&&e.getNumGeometries()<=1)return this.unionActual(t,e);const i=n.intersection(s);return this.unionUsingEnvelopeIntersection(t,e,i)}union(){if(null===this._inputPolys)throw new IllegalStateException("union() method cannot be called twice");if(this._inputPolys.isEmpty())return null;this._geomFactory=this._inputPolys.iterator().next().getFactory();const t=new Es(Vr.STRTREE_NODE_CAPACITY);for(let e=this._inputPolys.iterator();e.hasNext();){const n=e.next();t.insert(n.getEnvelopeInternal(),n)}this._inputPolys=null;const e=t.itemsTree();return this.unionTree(e)}binaryUnion(){if(1===arguments.length){const t=arguments[0];return this.binaryUnion(t,0,t.size())}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];if(n-e<=1){const n=Vr.getGeometry(t,e);return this.unionSafe(n,null)}if(n-e==2)return this.unionSafe(Vr.getGeometry(t,e),Vr.getGeometry(t,e+1));{const s=Math.trunc((n+e)/2),i=this.binaryUnion(t,e,s),r=this.binaryUnion(t,s,n);return this.unionSafe(i,r)}}}repeatedUnion(t){let e=null;for(let n=t.iterator();n.hasNext();){const t=n.next();e=null===e?t.copy():e.union(t)}return e}unionSafe(t,e){return null===t&&null===e?null:null===t?e.copy():null===e?t.copy():this.unionOptimized(t,e)}unionActual(t,e){return Vr.restrictToPolygons(t.union(e))}unionTree(t){const e=this.reduceToGeometries(t);return this.binaryUnion(e)}unionUsingEnvelopeIntersection(t,e,n){const s=new x,i=this.extractByEnvelope(n,t,s),r=this.extractByEnvelope(n,e,s),o=this.unionActual(i,r);return s.add(o),de.combine(s)}bufferUnion(){if(1===arguments.length){const t=arguments[0];return t.get(0).getFactory().buildGeometry(t).buffer(0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return t.getFactory().createGeometryCollection([t,e]).buffer(0)}}getClass(){return Vr}get interfaces_(){return[]}}Vr.constructor_=function(){this._inputPolys=null,this._geomFactory=null;const t=arguments[0];this._inputPolys=t,null===this._inputPolys&&(this._inputPolys=new x)},Vr.STRTREE_NODE_CAPACITY=4;class zr{constructor(){zr.constructor_.apply(this,arguments)}static union(){if(1===arguments.length){if(_(arguments[0],f)){const t=arguments[0];return new zr(t).union()}if(arguments[0]instanceof q){const t=arguments[0];return new zr(t).union()}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];return new zr(t,e).union()}}unionNoOpt(t){const e=this._geomFact.createPoint();return lr.overlayOp(t,e,cr.UNION)}unionWithNull(t,e){return null===t&&null===e?null:null===e?t:null===t?e:t.union(e)}extract(){if(_(arguments[0],f)){for(let t=arguments[0].iterator();t.hasNext();){const e=t.next();this.extract(e)}}else if(arguments[0]instanceof q){const t=arguments[0];null===this._geomFact&&(this._geomFact=t.getFactory()),_e.extract(t,q.TYPENAME_POLYGON,this._polygons),_e.extract(t,q.TYPENAME_LINESTRING,this._lines),_e.extract(t,q.TYPENAME_POINT,this._points)}}union(){if(null===this._geomFact)return null;let t=null;if(this._points.size()>0){const e=this._geomFact.buildGeometry(this._points);t=this.unionNoOpt(e)}let e=null;if(this._lines.size()>0){const t=this._geomFact.buildGeometry(this._lines);e=this.unionNoOpt(t)}let n=null;this._polygons.size()>0&&(n=Vr.union(this._polygons));const s=this.unionWithNull(e,n);let i=null;return i=null===t?s:null===s?t:Br.union(t,s),null===i?this._geomFact.createGeometryCollection():i}getClass(){return zr}get interfaces_(){return[]}}zr.constructor_=function(){if(this._polygons=new x,this._lines=new x,this._points=new x,this._geomFact=null,1===arguments.length){if(_(arguments[0],f)){const t=arguments[0];this.extract(t)}else if(arguments[0]instanceof q){const t=arguments[0];this.extract(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._geomFact=e,this.extract(t)}};var Yr=Object.freeze({__proto__:null,UnaryUnionOp:zr}),Ur=Object.freeze({__proto__:null,IsValidOp:Cr,ConsistentAreaTester:Er}),kr=Object.freeze({__proto__:null,BoundaryOp:pt,IsSimpleOp:Hs,buffer:wi,distance:Pi,linemerge:Xi,overlay:hr,polygonize:Pr,relate:qr,union:Yr,valid:Ur});class Xr extends Ft.CoordinateOperation{constructor(){super(),Xr.constructor_.apply(this,arguments)}edit(){if(2===arguments.length&&arguments[1]instanceof q&&arguments[0]instanceof Array){const t=arguments[0],e=arguments[1];if(0===t.length)return null;const n=new Array(t.length).fill(null);for(let e=0;e<t.length;e++){const s=new g(t[e]);this._targetPM.makePrecise(s),n[e]=s}const s=new I(n,!1).toCoordinateArray();let i=0;e instanceof Tt&&(i=2),e instanceof Dt&&(i=4);let r=n;return this._removeCollapsed&&(r=null),s.length<i?r:s}return super.edit.apply(this,arguments)}getClass(){return Xr}get interfaces_(){return[]}}Xr.constructor_=function(){this._targetPM=null,this._removeCollapsed=!0;const t=arguments[0],e=arguments[1];this._targetPM=t,this._removeCollapsed=e};class Hr{constructor(){Hr.constructor_.apply(this,arguments)}static reduce(t,e){return new Hr(e).reduce(t)}static reducePointwise(t,e){const n=new Hr(e);return n.setPointwise(!0),n.reduce(t)}fixPolygonalTopology(t){let e=t;this._changePrecisionModel||(e=this.changePM(t,this._targetPM));const n=Si.bufferOp(e,0);let s=n;return this._changePrecisionModel||(s=t.getFactory().createGeometry(n)),s}reducePointwise(t){let e=null;if(this._changePrecisionModel){const n=this.createFactory(t.getFactory(),this._targetPM);e=new Ft(n)}else e=new Ft;let n=this._removeCollapsed;return t.getDimension()>=2&&(n=!0),e.edit(t,new Xr(this._targetPM,n))}changePM(t,e){return this.createEditor(t.getFactory(),e).edit(t,new Ft.NoOpGeometryOperation)}setRemoveCollapsedComponents(t){this._removeCollapsed=t}createFactory(t,e){return new Ht(e,t.getSRID(),t.getCoordinateSequenceFactory())}setChangePrecisionModel(t){this._changePrecisionModel=t}reduce(t){const e=this.reducePointwise(t);return this._isPointwise?e:_(e,Ot)?Cr.isValid(e)?e:this.fixPolygonalTopology(e):e}setPointwise(t){this._isPointwise=t}createEditor(t,e){if(t.getPrecisionModel()===e)return new Ft;const n=this.createFactory(t,e);return new Ft(n)}getClass(){return Hr}get interfaces_(){return[]}}Hr.constructor_=function(){this._targetPM=null,this._removeCollapsed=!0,this._changePrecisionModel=!1,this._isPointwise=!1;const t=arguments[0];this._targetPM=t};var Wr=Object.freeze({__proto__:null,GeometryPrecisionReducer:Hr});class jr{constructor(){jr.constructor_.apply(this,arguments)}static simplify(t,e){const n=new jr(t);return n.setDistanceTolerance(e),n.simplify()}simplifySection(t,e){if(t+1===e)return null;this._seg.p0=this._pts[t],this._seg.p1=this._pts[e];let n=-1,s=t;for(let i=t+1;i<e;i++){const t=this._seg.distance(this._pts[i]);t>n&&(n=t,s=i)}if(n<=this._distanceTolerance)for(let n=t+1;n<e;n++)this._usePt[n]=!1;else this.simplifySection(t,s),this.simplifySection(s,e)}setDistanceTolerance(t){this._distanceTolerance=t}simplify(){this._usePt=new Array(this._pts.length).fill(null);for(let t=0;t<this._pts.length;t++)this._usePt[t]=!0;this.simplifySection(0,this._pts.length-1);const t=new I;for(let e=0;e<this._pts.length;e++)this._usePt[e]&&t.add(new g(this._pts[e]));return t.toCoordinateArray()}getClass(){return jr}get interfaces_(){return[]}}jr.constructor_=function(){this._pts=null,this._usePt=null,this._distanceTolerance=null,this._seg=new ee;const t=arguments[0];this._pts=t};class Kr{constructor(){Kr.constructor_.apply(this,arguments)}static simplify(t,e){const n=new Kr(t);return n.setDistanceTolerance(e),n.getResultGeometry()}setEnsureValid(t){this._isEnsureValidTopology=t}getResultGeometry(){return this._inputGeom.isEmpty()?this._inputGeom.copy():new Zr(this._isEnsureValidTopology,this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new n("Tolerance must be non-negative");this._distanceTolerance=t}getClass(){return Kr}get interfaces_(){return[]}}class Zr extends me{constructor(){super(),Zr.constructor_.apply(this,arguments)}transformPolygon(t,e){if(t.isEmpty())return null;const n=super.transformPolygon.call(this,t,e);return e instanceof At?n:this.createValidArea(n)}createValidArea(t){return this._isEnsureValidTopology?t.buffer(0):t}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=null;return s=0===n.length?new Array(0).fill(null):jr.simplify(n,this._distanceTolerance),this._factory.getCoordinateSequenceFactory().create(s)}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformLinearRing(t,e){const n=e instanceof bt,s=super.transformLinearRing.call(this,t,e);return!n||s instanceof Dt?s:null}getClass(){return Zr}get interfaces_(){return[]}}Zr.constructor_=function(){this._isEnsureValidTopology=!0,this._distanceTolerance=null;const t=arguments[0],e=arguments[1];this._isEnsureValidTopology=t,this._distanceTolerance=e},Kr.DPTransformer=Zr,Kr.constructor_=function(){this._inputGeom=null,this._distanceTolerance=null,this._isEnsureValidTopology=!0;const t=arguments[0];this._inputGeom=t};class Qr extends ee{constructor(){super(),Qr.constructor_.apply(this,arguments)}getIndex(){return this._index}getParent(){return this._parent}getClass(){return Qr}get interfaces_(){return[]}}Qr.constructor_=function(){if(this._parent=null,this._index=null,2===arguments.length){const t=arguments[0],e=arguments[1];Qr.constructor_.call(this,t,e,null,-1)}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];ee.constructor_.call(this,t,e),this._parent=n,this._index=s}};class Jr{constructor(){Jr.constructor_.apply(this,arguments)}static extractCoordinates(t){const e=new Array(t.size()+1).fill(null);let n=null;for(let s=0;s<t.size();s++)n=t.get(s),e[s]=n.p0;return e[e.length-1]=n.p1,e}addToResult(t){this._resultSegs.add(t)}asLineString(){return this._parentLine.getFactory().createLineString(Jr.extractCoordinates(this._resultSegs))}getResultSize(){const t=this._resultSegs.size();return 0===t?0:t+1}getParent(){return this._parentLine}getSegment(t){return this._segs[t]}getParentCoordinates(){return this._parentLine.getCoordinates()}getMinimumSize(){return this._minimumSize}asLinearRing(){return this._parentLine.getFactory().createLinearRing(Jr.extractCoordinates(this._resultSegs))}getSegments(){return this._segs}init(){const t=this._parentLine.getCoordinates();this._segs=new Array(t.length-1).fill(null);for(let e=0;e<t.length-1;e++){const n=new Qr(t[e],t[e+1],this._parentLine,e);this._segs[e]=n}}getResultCoordinates(){return Jr.extractCoordinates(this._resultSegs)}getClass(){return Jr}get interfaces_(){return[]}}Jr.constructor_=function(){if(this._parentLine=null,this._segs=null,this._resultSegs=new x,this._minimumSize=null,1===arguments.length){const t=arguments[0];Jr.constructor_.call(this,t,2)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._parentLine=t,this._minimumSize=e,this.init()}};class $r{constructor(){$r.constructor_.apply(this,arguments)}remove(t){this._index.remove(new N(t.p0,t.p1),t)}add(){if(arguments[0]instanceof Jr){const t=arguments[0].getSegments();for(let e=0;e<t.length;e++){const n=t[e];this.add(n)}}else if(arguments[0]instanceof ee){const t=arguments[0];this._index.insert(new N(t.p0,t.p1),t)}}query(t){const e=new N(t.p0,t.p1),n=new to(t);return this._index.query(e,n),n.getItems()}getClass(){return $r}get interfaces_(){return[]}}$r.constructor_=function(){this._index=new us};class to{constructor(){to.constructor_.apply(this,arguments)}visitItem(t){const e=t;N.intersects(e.p0,e.p1,this._querySeg.p0,this._querySeg.p1)&&this._items.add(t)}getItems(){return this._items}getClass(){return to}get interfaces_(){return[Ae]}}to.constructor_=function(){this._querySeg=null,this._items=new x;const t=arguments[0];this._querySeg=t};class eo{constructor(){eo.constructor_.apply(this,arguments)}static isInLineSection(t,e,n){if(n.getParent()!==t.getParent())return!1;const s=n.getIndex();return s>=e[0]&&s<e[1]}flatten(t,e){const n=this._linePts[t],s=this._linePts[e],i=new ee(n,s);return this.remove(this._line,t,e),this._outputIndex.add(i),i}hasBadIntersection(t,e,n){return!!this.hasBadOutputIntersection(n)||!!this.hasBadInputIntersection(t,e,n)}setDistanceTolerance(t){this._distanceTolerance=t}simplifySection(t,e,n){n+=1;const s=new Array(2).fill(null);if(t+1===e){const e=this._line.getSegment(t);return this._line.addToResult(e),null}let i=!0;if(this._line.getResultSize()<this._line.getMinimumSize()){n+1<this._line.getMinimumSize()&&(i=!1)}const r=new Array(1).fill(null),o=this.findFurthestPoint(this._linePts,t,e,r);r[0]>this._distanceTolerance&&(i=!1);const l=new ee;if(l.p0=this._linePts[t],l.p1=this._linePts[e],s[0]=t,s[1]=e,this.hasBadIntersection(this._line,s,l)&&(i=!1),i){const n=this.flatten(t,e);return this._line.addToResult(n),null}this.simplifySection(t,o,n),this.simplifySection(o,e,n)}hasBadOutputIntersection(t){for(let e=this._outputIndex.query(t).iterator();e.hasNext();){const n=e.next();if(this.hasInteriorIntersection(n,t))return!0}return!1}findFurthestPoint(t,e,n,s){const i=new ee;i.p0=t[e],i.p1=t[n];let r=-1,o=e;for(let s=e+1;s<n;s++){const e=t[s],n=i.distance(e);n>r&&(r=n,o=s)}return s[0]=r,o}simplify(t){this._line=t,this._linePts=t.getParentCoordinates(),this.simplifySection(0,this._linePts.length-1,0)}remove(t,e,n){for(let s=e;s<n;s++){const e=t.getSegment(s);this._inputIndex.remove(e)}}hasInteriorIntersection(t,e){return this._li.computeIntersection(t.p0,t.p1,e.p0,e.p1),this._li.isInteriorIntersection()}hasBadInputIntersection(t,e,n){for(let s=this._inputIndex.query(n).iterator();s.hasNext();){const i=s.next();if(this.hasInteriorIntersection(i,n)){if(eo.isInLineSection(t,e,i))continue;return!0}}return!1}getClass(){return eo}get interfaces_(){return[]}}eo.constructor_=function(){this._li=new te,this._inputIndex=new $r,this._outputIndex=new $r,this._line=null,this._linePts=null,this._distanceTolerance=0;const t=arguments[0],e=arguments[1];this._inputIndex=t,this._outputIndex=e};class no{constructor(){no.constructor_.apply(this,arguments)}setDistanceTolerance(t){this._distanceTolerance=t}simplify(t){for(let e=t.iterator();e.hasNext();)this._inputIndex.add(e.next());for(let e=t.iterator();e.hasNext();){const t=new eo(this._inputIndex,this._outputIndex);t.setDistanceTolerance(this._distanceTolerance),t.simplify(e.next())}}getClass(){return no}get interfaces_(){return[]}}no.constructor_=function(){this._inputIndex=new $r,this._outputIndex=new $r,this._distanceTolerance=0};class so{constructor(){so.constructor_.apply(this,arguments)}static simplify(t,e){const n=new so(t);return n.setDistanceTolerance(e),n.getResultGeometry()}getResultGeometry(){if(this._inputGeom.isEmpty())return this._inputGeom.copy();return this._linestringMap=new Ut,this._inputGeom.apply(new ro(this)),this._lineSimplifier.simplify(this._linestringMap.values()),new io(this._linestringMap).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new n("Tolerance must be non-negative");this._lineSimplifier.setDistanceTolerance(t)}getClass(){return so}get interfaces_(){return[]}}class io extends me{constructor(){super(),io.constructor_.apply(this,arguments)}transformCoordinates(t,e){if(0===t.size())return null;if(e instanceof Tt){const t=this._linestringMap.get(e);return this.createCoordinateSequence(t.getResultCoordinates())}return super.transformCoordinates.call(this,t,e)}getClass(){return io}get interfaces_(){return[]}}io.constructor_=function(){this._linestringMap=null;const t=arguments[0];this._linestringMap=t};class ro{constructor(){ro.constructor_.apply(this,arguments)}filter(t){if(t instanceof Tt){const e=t;if(e.isEmpty())return null;const n=e.isClosed()?4:2,s=new Jr(e,n);this.tps._linestringMap.put(e,s)}}getClass(){return ro}get interfaces_(){return[G]}}ro.constructor_=function(){this.tps=null;const t=arguments[0];this.tps=t},so.LineStringTransformer=io,so.LineStringMapBuilderFilter=ro,so.constructor_=function(){this._inputGeom=null,this._lineSimplifier=new no,this._linestringMap=null;const t=arguments[0];this._inputGeom=t};class oo{constructor(){oo.constructor_.apply(this,arguments)}static simplify(t,e){return new oo(t,e).simplify()}simplifyVertex(t){let e=t,n=e.getArea(),s=null;for(;null!==e;){const t=e.getArea();t<n&&(n=t,s=e),e=e._next}return null!==s&&n<this._tolerance&&s.remove(),t.isLive()?n:-1}simplify(){const t=lo.buildLine(this._pts);let e=this._tolerance;do{e=this.simplifyVertex(t)}while(e<this._tolerance);const n=t.getCoordinates();return n.length<2?[n[0],new g(n[0])]:n}getClass(){return oo}get interfaces_(){return[]}}class lo{constructor(){lo.constructor_.apply(this,arguments)}static buildLine(t){let e=null,n=null;for(let s=0;s<t.length;s++){const i=new lo(t[s]);null===e&&(e=i),i.setPrev(n),null!==n&&(n.setNext(i),n.updateArea()),n=i}return e}getCoordinates(){const t=new I;let e=this;do{t.add(e._pt,!1),e=e._next}while(null!==e);return t.toCoordinateArray()}getArea(){return this._area}updateArea(){if(null===this._prev||null===this._next)return this._area=lo.MAX_AREA,null;this._area=Math.abs(re.area(this._prev._pt,this._pt,this._next._pt))}remove(){const t=this._prev,e=this._next;let n=null;return null!==this._prev&&(this._prev.setNext(e),this._prev.updateArea(),n=this._prev),null!==this._next&&(this._next.setPrev(t),this._next.updateArea(),null===n&&(n=this._next)),this._isLive=!1,n}isLive(){return this._isLive}setPrev(t){this._prev=t}setNext(t){this._next=t}getClass(){return lo}get interfaces_(){return[]}}lo.constructor_=function(){this._pt=null,this._prev=null,this._next=null,this._area=lo.MAX_AREA,this._isLive=!0;const t=arguments[0];this._pt=t},lo.MAX_AREA=i.MAX_VALUE,oo.VWVertex=lo,oo.constructor_=function(){this._pts=null,this._tolerance=null;const t=arguments[0],e=arguments[1];this._pts=t,this._tolerance=e*e};class ao{constructor(){ao.constructor_.apply(this,arguments)}static simplify(t,e){const n=new ao(t);return n.setDistanceTolerance(e),n.getResultGeometry()}setEnsureValid(t){this._isEnsureValidTopology=t}getResultGeometry(){return this._inputGeom.isEmpty()?this._inputGeom.copy():new co(this._isEnsureValidTopology,this._distanceTolerance).transform(this._inputGeom)}setDistanceTolerance(t){if(t<0)throw new n("Tolerance must be non-negative");this._distanceTolerance=t}getClass(){return ao}get interfaces_(){return[]}}class co extends me{constructor(){super(),co.constructor_.apply(this,arguments)}transformPolygon(t,e){if(t.isEmpty())return null;const n=super.transformPolygon.call(this,t,e);return e instanceof At?n:this.createValidArea(n)}createValidArea(t){return this._isEnsureValidTopology?t.buffer(0):t}transformCoordinates(t,e){const n=t.toCoordinateArray();let s=null;return s=0===n.length?new Array(0).fill(null):oo.simplify(n,this._distanceTolerance),this._factory.getCoordinateSequenceFactory().create(s)}transformMultiPolygon(t,e){const n=super.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)}transformLinearRing(t,e){const n=e instanceof bt,s=super.transformLinearRing.call(this,t,e);return!n||s instanceof Dt?s:null}getClass(){return co}get interfaces_(){return[]}}co.constructor_=function(){this._isEnsureValidTopology=!0,this._distanceTolerance=null;const t=arguments[0],e=arguments[1];this._isEnsureValidTopology=t,this._distanceTolerance=e},ao.VWTransformer=co,ao.constructor_=function(){this._inputGeom=null,this._distanceTolerance=null,this._isEnsureValidTopology=!0;const t=arguments[0];this._inputGeom=t};var ho=Object.freeze({__proto__:null,DouglasPeuckerSimplifier:Kr,TopologyPreservingSimplifier:so,VWSimplifier:ao});class uo{constructor(){uo.constructor_.apply(this,arguments)}static pointAlongReverse(t,e){const n=new g;return n.x=t.p1.x-e*(t.p1.x-t.p0.x),n.y=t.p1.y-e*(t.p1.y-t.p0.y),n}splitAt(){if(1===arguments.length){const t=arguments[0],e=this._minimumLen/this._segLen;if(t.distance(this._seg.p0)<this._minimumLen)return this._splitPt=this._seg.pointAlong(e),null;if(t.distance(this._seg.p1)<this._minimumLen)return this._splitPt=uo.pointAlongReverse(this._seg,e),null;this._splitPt=t}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this.getConstrainedLength(t)/this._segLen;e.equals2D(this._seg.p0)?this._splitPt=this._seg.pointAlong(n):this._splitPt=uo.pointAlongReverse(this._seg,n)}}setMinimumLength(t){this._minimumLen=t}getConstrainedLength(t){return t<this._minimumLen?this._minimumLen:t}getSplitPoint(){return this._splitPt}getClass(){return uo}get interfaces_(){return[]}}uo.constructor_=function(){this._seg=null,this._segLen=null,this._splitPt=null,this._minimumLen=0;const t=arguments[0];this._seg=t,this._segLen=t.getLength()};class go{constructor(){go.constructor_.apply(this,arguments)}findSplitPoint(t,e){}getClass(){return go}get interfaces_(){return[]}}go.constructor_=function(){};class _o{constructor(){_o.constructor_.apply(this,arguments)}static projectedSplitPoint(t,e){return t.getLineSegment().project(e)}findSplitPoint(t,e){const n=t.getLineSegment(),s=n.getLength()/2,i=new uo(n),r=_o.projectedSplitPoint(t,e);let o=2*r.distance(e)*.8;return o>s&&(o=s),i.setMinimumLength(o),i.splitAt(r),i.getSplitPoint()}getClass(){return _o}get interfaces_(){return[go]}}_o.constructor_=function(){};class fo{constructor(){fo.constructor_.apply(this,arguments)}static triArea(t,e,n){return(e.x-t.x)*(n.y-t.y)-(e.y-t.y)*(n.x-t.x)}static isInCircleDDNormalized(t,e,n,s){const i=R.valueOf(t.x).selfSubtract(s.x),r=R.valueOf(t.y).selfSubtract(s.y),o=R.valueOf(e.x).selfSubtract(s.x),l=R.valueOf(e.y).selfSubtract(s.y),a=R.valueOf(n.x).selfSubtract(s.x),c=R.valueOf(n.y).selfSubtract(s.y),h=i.multiply(l).selfSubtract(o.multiply(r)),u=o.multiply(c).selfSubtract(a.multiply(l)),g=a.multiply(r).selfSubtract(i.multiply(c)),d=i.multiply(i).selfAdd(r.multiply(r)),_=o.multiply(o).selfAdd(l.multiply(l)),f=a.multiply(a).selfAdd(c.multiply(c));return d.selfMultiply(u).selfAdd(_.selfMultiply(g)).selfAdd(f.selfMultiply(h)).doubleValue()>0}static checkRobustInCircle(t,e,n,s){const i=fo.isInCircleNonRobust(t,e,n,s),r=fo.isInCircleDDSlow(t,e,n,s),o=fo.isInCircleCC(t,e,n,s),l=re.circumcentre(t,e,n);O.out.println("p radius diff a = "+Math.abs(s.distance(l)-t.distance(l))/t.distance(l)),i===r&&i===o||(O.out.println("inCircle robustness failure (double result = "+i+", DD result = "+r+", CC result = "+o+")"),O.out.println(Jt.toLineString(new zt([t,e,n,s]))),O.out.println("Circumcentre = "+Jt.toPoint(l)+" radius = "+t.distance(l)),O.out.println("p radius diff a = "+Math.abs(s.distance(l)/t.distance(l)-1)),O.out.println("p radius diff b = "+Math.abs(s.distance(l)/e.distance(l)-1)),O.out.println("p radius diff c = "+Math.abs(s.distance(l)/n.distance(l)-1)),O.out.println())}static isInCircleDDFast(t,e,n,s){const i=R.sqr(t.x).selfAdd(R.sqr(t.y)).selfMultiply(fo.triAreaDDFast(e,n,s)),r=R.sqr(e.x).selfAdd(R.sqr(e.y)).selfMultiply(fo.triAreaDDFast(t,n,s)),o=R.sqr(n.x).selfAdd(R.sqr(n.y)).selfMultiply(fo.triAreaDDFast(t,e,s)),l=R.sqr(s.x).selfAdd(R.sqr(s.y)).selfMultiply(fo.triAreaDDFast(t,e,n));return i.selfSubtract(r).selfAdd(o).selfSubtract(l).doubleValue()>0}static isInCircleCC(t,e,n,s){const i=re.circumcentre(t,e,n),r=t.distance(i);return s.distance(i)-r<=0}static isInCircleNormalized(t,e,n,s){const i=t.x-s.x,r=t.y-s.y,o=e.x-s.x,l=e.y-s.y,a=n.x-s.x,c=n.y-s.y;return(i*i+r*r)*(o*c-a*l)+(o*o+l*l)*(a*r-i*c)+(a*a+c*c)*(i*l-o*r)>0}static isInCircleDDSlow(t,e,n,s){const i=R.valueOf(s.x),r=R.valueOf(s.y),o=R.valueOf(t.x),l=R.valueOf(t.y),a=R.valueOf(e.x),c=R.valueOf(e.y),h=R.valueOf(n.x),u=R.valueOf(n.y),g=o.multiply(o).add(l.multiply(l)).multiply(fo.triAreaDDSlow(a,c,h,u,i,r)),d=a.multiply(a).add(c.multiply(c)).multiply(fo.triAreaDDSlow(o,l,h,u,i,r)),_=h.multiply(h).add(u.multiply(u)).multiply(fo.triAreaDDSlow(o,l,a,c,i,r)),f=i.multiply(i).add(r.multiply(r)).multiply(fo.triAreaDDSlow(o,l,a,c,h,u));return g.subtract(d).add(_).subtract(f).doubleValue()>0}static isInCircleNonRobust(t,e,n,s){return(t.x*t.x+t.y*t.y)*fo.triArea(e,n,s)-(e.x*e.x+e.y*e.y)*fo.triArea(t,n,s)+(n.x*n.x+n.y*n.y)*fo.triArea(t,e,s)-(s.x*s.x+s.y*s.y)*fo.triArea(t,e,n)>0}static isInCircleRobust(t,e,n,s){return fo.isInCircleNormalized(t,e,n,s)}static triAreaDDSlow(t,e,n,s,i,r){return n.subtract(t).multiply(r.subtract(e)).subtract(s.subtract(e).multiply(i.subtract(t)))}static triAreaDDFast(t,e,n){const s=R.valueOf(e.x).selfSubtract(t.x).selfMultiply(R.valueOf(n.y).selfSubtract(t.y)),i=R.valueOf(e.y).selfSubtract(t.y).selfMultiply(R.valueOf(n.x).selfSubtract(t.x));return s.selfSubtract(i)}getClass(){return fo}get interfaces_(){return[]}}fo.constructor_=function(){};class po{constructor(){po.constructor_.apply(this,arguments)}static interpolateZ(){if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=e.distance(n),i=t.distance(e),r=n.z-e.z;return e.z+r*(i/s)}if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=e.x,r=e.y,o=n.x-i,l=s.x-i,a=n.y-r,c=s.y-r,h=o*c-l*a,u=t.x-i,g=t.y-r,d=(c*u-l*g)/h,_=(-a*u+o*g)/h;return e.z+d*(n.z-e.z)+_*(s.z-e.z)}}circleCenter(t,e){const n=new po(this.getX(),this.getY()),s=this.bisector(n,t),i=this.bisector(t,e),r=new b(s,i);let o=null;try{o=new po(r.getX(),r.getY())}catch(s){if(!(s instanceof S))throw s;O.err.println("a: "+n+"  b: "+t+"  c: "+e),O.err.println(s)}return o}dot(t){return this._p.x*t.getX()+this._p.y*t.getY()}magn(){return Math.sqrt(this._p.x*this._p.x+this._p.y*this._p.y)}getZ(){return this._p.z}bisector(t,e){const n=e.getX()-t.getX(),s=e.getY()-t.getY(),i=new b(t.getX()+n/2,t.getY()+s/2,1),r=new b(t.getX()-s+n/2,t.getY()+n+s/2,1);return new b(i,r)}equals(){if(1===arguments.length){const t=arguments[0];return this._p.x===t.getX()&&this._p.y===t.getY()}if(2===arguments.length){const t=arguments[0],e=arguments[1];return this._p.distance(t.getCoordinate())<e}}getCoordinate(){return this._p}isInCircle(t,e,n){return fo.isInCircleRobust(t._p,e._p,n._p,this._p)}interpolateZValue(t,e,n){const s=t.getX(),i=t.getY(),r=e.getX()-s,o=n.getX()-s,l=e.getY()-i,a=n.getY()-i,c=r*a-o*l,h=this.getX()-s,u=this.getY()-i,g=(a*h-o*u)/c,d=(-l*h+r*u)/c;return t.getZ()+g*(e.getZ()-t.getZ())+d*(n.getZ()-t.getZ())}midPoint(t){const e=(this._p.x+t.getX())/2,n=(this._p.y+t.getY())/2,s=(this._p.z+t.getZ())/2;return new po(e,n,s)}rightOf(t){return this.isCCW(t.dest(),t.orig())}isCCW(t,e){return(t._p.x-this._p.x)*(e._p.y-this._p.y)-(t._p.y-this._p.y)*(e._p.x-this._p.x)>0}getX(){return this._p.x}crossProduct(t){return this._p.x*t.getY()-this._p.y*t.getX()}setZ(t){this._p.z=t}times(t){return new po(t*this._p.x,t*this._p.y)}cross(){return new po(this._p.y,-this._p.x)}leftOf(t){return this.isCCW(t.orig(),t.dest())}toString(){return"POINT ("+this._p.x+" "+this._p.y+")"}sub(t){return new po(this._p.x-t.getX(),this._p.y-t.getY())}getY(){return this._p.y}classify(t,e){const n=e.sub(t),s=this.sub(t),i=n.crossProduct(s);return i>0?po.LEFT:i<0?po.RIGHT:n.getX()*s.getX()<0||n.getY()*s.getY()<0?po.BEHIND:n.magn()<s.magn()?po.BEYOND:t.equals(this)?po.ORIGIN:e.equals(this)?po.DESTINATION:po.BETWEEN}sum(t){return new po(this._p.x+t.getX(),this._p.y+t.getY())}distance(t,e){return Math.sqrt(Math.pow(e.getX()-t.getX(),2)+Math.pow(e.getY()-t.getY(),2))}circumRadiusRatio(t,e){const n=this.circleCenter(t,e),s=this.distance(n,t);let i=this.distance(this,t),r=this.distance(t,e);return r<i&&(i=r),r=this.distance(e,this),r<i&&(i=r),s/i}getClass(){return po}get interfaces_(){return[]}}po.constructor_=function(){if(this._p=null,1===arguments.length){const t=arguments[0];this._p=new g(t)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];this._p=new g(t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._p=new g(t,e,n)}},po.LEFT=0,po.RIGHT=1,po.BEYOND=2,po.BEHIND=3,po.BETWEEN=4,po.ORIGIN=5,po.DESTINATION=6;class mo extends po{constructor(){super(),mo.constructor_.apply(this,arguments)}getConstraint(){return this._constraint}setOnConstraint(t){this._isOnConstraint=t}merge(t){t._isOnConstraint&&(this._isOnConstraint=!0,this._constraint=t._constraint)}isOnConstraint(){return this._isOnConstraint}setConstraint(t){this._isOnConstraint=!0,this._constraint=t}getClass(){return mo}get interfaces_(){return[]}}mo.constructor_=function(){this._isOnConstraint=null,this._constraint=null;const t=arguments[0];po.constructor_.call(this,t)};class yo{constructor(){yo.constructor_.apply(this,arguments)}static makeEdge(t,e){const n=new yo,s=new yo,i=new yo,r=new yo;n._rot=s,s._rot=i,i._rot=r,r._rot=n,n.setNext(n),s.setNext(r),i.setNext(i),r.setNext(s);const o=n;return o.setOrig(t),o.setDest(e),o}static swap(t){const e=t.oPrev(),n=t.sym().oPrev();yo.splice(t,e),yo.splice(t.sym(),n),yo.splice(t,e.lNext()),yo.splice(t.sym(),n.lNext()),t.setOrig(e.dest()),t.setDest(n.dest())}static splice(t,e){const n=t.oNext().rot(),s=e.oNext().rot(),i=e.oNext(),r=t.oNext(),o=s.oNext(),l=n.oNext();t.setNext(i),e.setNext(r),n.setNext(o),s.setNext(l)}static connect(t,e){const n=yo.makeEdge(t.dest(),e.orig());return yo.splice(n,t.lNext()),yo.splice(n.sym(),e),n}equalsNonOriented(t){return!!this.equalsOriented(t)||!!this.equalsOriented(t.sym())}toLineSegment(){return new ee(this._vertex.getCoordinate(),this.dest().getCoordinate())}dest(){return this.sym().orig()}oNext(){return this._next}equalsOriented(t){return!(!this.orig().getCoordinate().equals2D(t.orig().getCoordinate())||!this.dest().getCoordinate().equals2D(t.dest().getCoordinate()))}dNext(){return this.sym().oNext().sym()}lPrev(){return this._next.sym()}rPrev(){return this.sym().oNext()}rot(){return this._rot}oPrev(){return this._rot._next._rot}sym(){return this._rot._rot}setOrig(t){this._vertex=t}lNext(){return this.invRot().oNext().rot()}getLength(){return this.orig().getCoordinate().distance(this.dest().getCoordinate())}invRot(){return this._rot.sym()}setDest(t){this.sym().setOrig(t)}setData(t){this._data=t}getData(){return this._data}delete(){this._rot=null}orig(){return this._vertex}rNext(){return this._rot._next.invRot()}toString(){const t=this._vertex.getCoordinate(),e=this.dest().getCoordinate();return Jt.toLineString(t,e)}isLive(){return null!==this._rot}getPrimary(){return this.orig().getCoordinate().compareTo(this.dest().getCoordinate())<=0?this:this.sym()}dPrev(){return this.invRot().oNext().invRot()}setNext(t){this._next=t}getClass(){return yo}get interfaces_(){return[]}}yo.constructor_=function(){this._rot=null,this._vertex=null,this._next=null,this._data=null};class xo{constructor(){xo.constructor_.apply(this,arguments)}insertSite(t){let e=this._subdiv.locate(t);if(this._subdiv.isVertexOfEdge(e,t))return e;this._subdiv.isOnEdge(e,t.getCoordinate())&&(e=e.oPrev(),this._subdiv.delete(e.oNext()));let n=this._subdiv.makeEdge(e.orig(),t);yo.splice(n,e);const s=n;do{n=this._subdiv.connect(e,n.sym()),e=n.oPrev()}while(e.lNext()!==s);for(;;){const i=e.oPrev();if(i.dest().rightOf(e)&&t.isInCircle(e.orig(),i.dest(),e.dest()))yo.swap(e),e=e.oPrev();else{if(e.oNext()===s)return n;e=e.oNext().lPrev()}}}insertSites(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertSite(t)}}getClass(){return xo}get interfaces_(){return[]}}xo.constructor_=function(){this._subdiv=null,this._isUsingTolerance=!1;const t=arguments[0];this._subdiv=t,this._isUsingTolerance=t.getTolerance()>0};class Eo{constructor(){Eo.constructor_.apply(this,arguments)}locate(t){}getClass(){return Eo}get interfaces_(){return[]}}Eo.constructor_=function(){};class Io{constructor(){Io.constructor_.apply(this,arguments)}init(){this._lastEdge=this.findEdge()}locate(t){this._lastEdge.isLive()||this.init();const e=this._subdiv.locateFromEdge(t,this._lastEdge);return this._lastEdge=e,e}findEdge(){return this._subdiv.getEdges().iterator().next()}getClass(){return Io}get interfaces_(){return[Eo]}}Io.constructor_=function(){this._subdiv=null,this._lastEdge=null;const t=arguments[0];this._subdiv=t,this.init()};class No extends c{constructor(){super(),No.constructor_.apply(this,arguments)}static msgWithSpatial(t,e){return null!==e?t+" [ "+e+" ]":t}getSegment(){return this._seg}getClass(){return No}get interfaces_(){return[]}}No.constructor_=function(){if(this._seg=null,1===arguments.length){if("string"==typeof arguments[0]){const t=arguments[0];c.constructor_.call(this,t)}else if(arguments[0]instanceof ee){const t=arguments[0];c.constructor_.call(this,"Locate failed to converge (at edge: "+t+").  Possible causes include invalid Subdivision topology or very close sites"),this._seg=new ee(t)}}else if(2===arguments.length){const t=arguments[0],e=arguments[1];c.constructor_.call(this,No.msgWithSpatial(t,e)),this._seg=new ee(e)}};class Co{constructor(){Co.constructor_.apply(this,arguments)}visit(t){}getClass(){return Co}get interfaces_(){return[]}}Co.constructor_=function(){};class So{constructor(){So.constructor_.apply(this,arguments)}static getTriangleEdges(t,e){if(e[0]=t,e[1]=e[0].lNext(),e[2]=e[1].lNext(),e[2].lNext()!==e[0])throw new n("Edges do not form a triangle")}getTriangleVertices(t){const e=new To;return this.visitTriangles(e,t),e.getTriangleVertices()}isFrameVertex(t){return!!t.equals(this._frameVertex[0])||(!!t.equals(this._frameVertex[1])||!!t.equals(this._frameVertex[2]))}isVertexOfEdge(t,e){return!(!e.equals(t.orig(),this._tolerance)&&!e.equals(t.dest(),this._tolerance))}connect(t,e){const n=yo.connect(t,e);return this._quadEdges.add(n),n}getVoronoiCellPolygon(t,e){const n=new x,s=t;do{const e=t.rot().orig().getCoordinate();n.add(e),t=t.oPrev()}while(t!==s);const i=new I;i.addAll(n,!1),i.closeRing(),i.size()<4&&(O.out.println(i),i.add(i.get(i.size()-1),!0));const r=i.toCoordinateArray(),o=e.createPolygon(e.createLinearRing(r)),l=s.orig();return o.setUserData(l.getCoordinate()),o}setLocator(t){this._locator=t}initSubdiv(){const t=this.makeEdge(this._frameVertex[0],this._frameVertex[1]),e=this.makeEdge(this._frameVertex[1],this._frameVertex[2]);yo.splice(t.sym(),e);const n=this.makeEdge(this._frameVertex[2],this._frameVertex[0]);return yo.splice(e.sym(),n),yo.splice(n.sym(),t),t}isFrameBorderEdge(t){const e=new Array(3).fill(null);So.getTriangleEdges(t,e);const n=new Array(3).fill(null);So.getTriangleEdges(t.sym(),n);const s=t.lNext().dest();if(this.isFrameVertex(s))return!0;const i=t.sym().lNext().dest();return!!this.isFrameVertex(i)}makeEdge(t,e){const n=yo.makeEdge(t,e);return this._quadEdges.add(n),n}visitTriangles(t,e){this._visitedKey++;const n=new on;n.push(this._startingEdge);const s=new J;for(;!n.empty();){const i=n.pop();if(!s.contains(i)){const r=this.fetchTriangleToVisit(i,n,e,s);null!==r&&t.visit(r)}}}isFrameEdge(t){return!(!this.isFrameVertex(t.orig())&&!this.isFrameVertex(t.dest()))}isOnEdge(t,e){return this._seg.setCoordinates(t.orig().getCoordinate(),t.dest().getCoordinate()),this._seg.distance(e)<this._edgeCoincidenceTolerance}getEnvelope(){return new N(this._frameEnv)}createFrame(t){const e=t.getWidth(),n=t.getHeight();let s=0;s=e>n?10*e:10*n,this._frameVertex[0]=new po((t.getMaxX()+t.getMinX())/2,t.getMaxY()+s),this._frameVertex[1]=new po(t.getMinX()-s,t.getMinY()-s),this._frameVertex[2]=new po(t.getMaxX()+s,t.getMinY()-s),this._frameEnv=new N(this._frameVertex[0].getCoordinate(),this._frameVertex[1].getCoordinate()),this._frameEnv.expandToInclude(this._frameVertex[2].getCoordinate())}getTriangleCoordinates(t){const e=new Ro;return this.visitTriangles(e,t),e.getTriangles()}getVertices(t){const e=new J;for(let n=this._quadEdges.iterator();n.hasNext();){const s=n.next(),i=s.orig();!t&&this.isFrameVertex(i)||e.add(i);const r=s.dest();!t&&this.isFrameVertex(r)||e.add(r)}return e}fetchTriangleToVisit(t,e,n,s){let i=t,r=0,o=!1;do{this._triEdges[r]=i,this.isFrameEdge(i)&&(o=!0);const t=i.sym();s.contains(t)||e.push(t),s.add(i),r++,i=i.lNext()}while(i!==t);return o&&!n?null:this._triEdges}getEdges(){if(0===arguments.length)return this._quadEdges;if(1===arguments.length){const t=arguments[0],e=this.getPrimaryEdges(!1),n=new Array(e.size()).fill(null);let s=0;for(let i=e.iterator();i.hasNext();){const e=i.next();n[s++]=t.createLineString([e.orig().getCoordinate(),e.dest().getCoordinate()])}return t.createMultiLineString(n)}}getVertexUniqueEdges(t){const e=new x,n=new J;for(let s=this._quadEdges.iterator();s.hasNext();){const i=s.next(),r=i.orig();n.contains(r)||(n.add(r),!t&&this.isFrameVertex(r)||e.add(i));const o=i.sym(),l=o.orig();n.contains(l)||(n.add(l),!t&&this.isFrameVertex(l)||e.add(o))}return e}getTriangleEdges(t){const e=new Lo;return this.visitTriangles(e,t),e.getTriangleEdges()}getPrimaryEdges(t){this._visitedKey++;const e=new x,n=new on;n.push(this._startingEdge);const s=new J;for(;!n.empty();){const i=n.pop();if(!s.contains(i)){const r=i.getPrimary();!t&&this.isFrameEdge(r)||e.add(r),n.push(i.oNext()),n.push(i.sym().oNext()),s.add(i),s.add(i.sym())}}return e}delete(t){yo.splice(t,t.oPrev()),yo.splice(t.sym(),t.sym().oPrev());const e=t.sym(),n=t.rot(),s=t.rot().sym();this._quadEdges.remove(t),this._quadEdges.remove(e),this._quadEdges.remove(n),this._quadEdges.remove(s),t.delete(),e.delete(),n.delete(),s.delete()}locateFromEdge(t,e){let n=0;const s=this._quadEdges.size();let i=e;for(;;){if(n++,n>s)throw new No(i.toLineSegment());if(t.equals(i.orig())||t.equals(i.dest()))break;if(t.rightOf(i))i=i.sym();else if(t.rightOf(i.oNext())){if(t.rightOf(i.dPrev()))break;i=i.dPrev()}else i=i.oNext()}return i}getTolerance(){return this._tolerance}getVoronoiCellPolygons(t){this.visitTriangles(new wo,!0);const e=new x;for(let n=this.getVertexUniqueEdges(!1).iterator();n.hasNext();){const s=n.next();e.add(this.getVoronoiCellPolygon(s,t))}return e}getVoronoiDiagram(t){const e=this.getVoronoiCellPolygons(t);return t.createGeometryCollection(Ht.toGeometryArray(e))}getTriangles(t){const e=this.getTriangleCoordinates(!1),n=new Array(e.size()).fill(null);let s=0;for(let i=e.iterator();i.hasNext();){const e=i.next();n[s++]=t.createPolygon(t.createLinearRing(e))}return t.createGeometryCollection(n)}insertSite(t){let e=this.locate(t);if(t.equals(e.orig(),this._tolerance)||t.equals(e.dest(),this._tolerance))return e;let n=this.makeEdge(e.orig(),t);yo.splice(n,e);const s=n;do{n=this.connect(e,n.sym()),e=n.oPrev()}while(e.lNext()!==s);return s}locate(){if(1===arguments.length){if(arguments[0]instanceof po){const t=arguments[0];return this._locator.locate(t)}if(arguments[0]instanceof g){const t=arguments[0];return this._locator.locate(new po(t))}}else if(2===arguments.length){const t=arguments[0],e=arguments[1],n=this._locator.locate(new po(t));if(null===n)return null;let s=n;n.dest().getCoordinate().equals2D(t)&&(s=n.sym());let i=s;do{if(i.dest().getCoordinate().equals2D(e))return i;i=i.oNext()}while(i!==s);return null}}getClass(){return So}get interfaces_(){return[]}}class wo{constructor(){wo.constructor_.apply(this,arguments)}visit(t){const e=t[0].orig().getCoordinate(),n=t[1].orig().getCoordinate(),s=t[2].orig().getCoordinate(),i=re.circumcentre(e,n,s),r=new po(i);for(let e=0;e<3;e++)t[e].rot().setOrig(r)}getClass(){return wo}get interfaces_(){return[Co]}}wo.constructor_=function(){};class Lo{constructor(){Lo.constructor_.apply(this,arguments)}getTriangleEdges(){return this._triList}visit(t){this._triList.add(t)}getClass(){return Lo}get interfaces_(){return[Co]}}Lo.constructor_=function(){this._triList=new x};class To{constructor(){To.constructor_.apply(this,arguments)}visit(t){this._triList.add([t[0].orig(),t[1].orig(),t[2].orig()])}getTriangleVertices(){return this._triList}getClass(){return To}get interfaces_(){return[Co]}}To.constructor_=function(){this._triList=new x};class Ro{constructor(){Ro.constructor_.apply(this,arguments)}checkTriangleSize(t){let e="";t.length>=2?e=Jt.toLineString(t[0],t[1]):t.length>=1&&(e=Jt.toPoint(t[0]))}visit(t){this._coordList.clear();for(let e=0;e<3;e++){const n=t[e].orig();this._coordList.add(n.getCoordinate())}if(this._coordList.size()>0){this._coordList.closeRing();const t=this._coordList.toCoordinateArray();if(4!==t.length)return null;this._triCoords.add(t)}}getTriangles(){return this._triCoords}getClass(){return Ro}get interfaces_(){return[Co]}}Ro.constructor_=function(){this._coordList=new I,this._triCoords=new x},So.TriangleCircumcentreVisitor=wo,So.TriangleEdgesListVisitor=Lo,So.TriangleVertexListVisitor=To,So.TriangleCoordinatesVisitor=Ro,So.constructor_=function(){this._visitedKey=0,this._quadEdges=new x,this._startingEdge=null,this._tolerance=null,this._edgeCoincidenceTolerance=null,this._frameVertex=new Array(3).fill(null),this._frameEnv=null,this._locator=null,this._seg=new ee,this._triEdges=new Array(3).fill(null);const t=arguments[0],e=arguments[1];this._tolerance=e,this._edgeCoincidenceTolerance=e/So.EDGE_COINCIDENCE_TOL_FACTOR,this.createFrame(t),this._startingEdge=this.initSubdiv(),this._locator=new Io(this)},So.EDGE_COINCIDENCE_TOL_FACTOR=1e3;class Po{constructor(){Po.constructor_.apply(this,arguments)}getLineSegment(){return this._ls}getEndZ(){return this._ls.getCoordinate(1).z}getStartZ(){return this._ls.getCoordinate(0).z}intersection(t){return this._ls.intersection(t.getLineSegment())}getStart(){return this._ls.getCoordinate(0)}getEnd(){return this._ls.getCoordinate(1)}getEndY(){return this._ls.getCoordinate(1).y}getStartX(){return this._ls.getCoordinate(0).x}equalsTopo(t){return this._ls.equalsTopo(t.getLineSegment())}getStartY(){return this._ls.getCoordinate(0).y}setData(t){this._data=t}getData(){return this._data}getEndX(){return this._ls.getCoordinate(1).x}toString(){return this._ls.toString()}getClass(){return Po}get interfaces_(){return[]}}Po.constructor_=function(){if(this._ls=null,this._data=null,2===arguments.length){const t=arguments[0],e=arguments[1];this._ls=new ee(t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._ls=new ee(t,e),this._data=n}else if(6===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5];Po.constructor_.call(this,new g(t,e,n),new g(s,i,r))}else if(7===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3],i=arguments[4],r=arguments[5],o=arguments[6];Po.constructor_.call(this,new g(t,e,n),new g(s,i,r),o)}};class vo{constructor(){vo.constructor_.apply(this,arguments)}static computeVertexEnvelope(t){const e=new N;for(let n=t.iterator();n.hasNext();){const t=n.next();e.expandToInclude(t.getCoordinate())}return e}getInitialVertices(){return this._initialVertices}getKDT(){return this._kdt}enforceConstraints(){this.addConstraintVertices();let t=0,e=0;do{e=this.enforceGabriel(this._segments),t++}while(e>0&&t<vo.MAX_SPLIT_ITER)}insertSites(t){for(let e=t.iterator();e.hasNext();){const t=e.next();this.insertSite(t)}}getVertexFactory(){return this._vertexFactory}getPointArray(){const t=new Array(this._initialVertices.size()+this._segVertices.size()).fill(null);let e=0;for(let n=this._initialVertices.iterator();n.hasNext();){const s=n.next();t[e++]=s.getCoordinate()}for(let n=this._segVertices.iterator();n.hasNext();){const s=n.next();t[e++]=s.getCoordinate()}return t}setConstraints(t,e){this._segments=t,this._segVertices=e}computeConvexHull(){const t=new Ht,e=this.getPointArray(),n=new an(e,t);this._convexHull=n.getConvexHull()}addConstraintVertices(){this.computeConvexHull(),this.insertSites(this._segVertices)}findNonGabrielPoint(t){const e=t.getStart(),n=t.getEnd(),s=new g((e.x+n.x)/2,(e.y+n.y)/2),r=e.distance(s),o=new N(s);o.expandBy(r);const l=this._kdt.query(o);let a=null,c=i.MAX_VALUE;for(let t=l.iterator();t.hasNext();){const i=t.next().getCoordinate();if(i.equals2D(e)||i.equals2D(n))continue;const o=s.distance(i);if(o<r){const t=o;(null===a||t<c)&&(a=i,c=t)}}return a}getConstraintSegments(){return this._segments}setSplitPointFinder(t){this._splitFinder=t}getConvexHull(){return this._convexHull}getTolerance(){return this._tolerance}enforceGabriel(t){const e=new x;let n=0;const s=new x;for(let i=t.iterator();i.hasNext();){const t=i.next(),r=this.findNonGabrielPoint(t);if(null===r)continue;this._splitPt=this._splitFinder.findSplitPoint(t,r);const o=this.createVertex(this._splitPt,t);this.insertSite(o).getCoordinate().equals2D(this._splitPt);const l=new Po(t.getStartX(),t.getStartY(),t.getStartZ(),o.getX(),o.getY(),o.getZ(),t.getData()),a=new Po(o.getX(),o.getY(),o.getZ(),t.getEndX(),t.getEndY(),t.getEndZ(),t.getData());e.add(l),e.add(a),s.add(t),n+=1}return t.removeAll(s),t.addAll(e),n}createVertex(){if(1===arguments.length){const t=arguments[0];let e=null;return e=null!==this._vertexFactory?this._vertexFactory.createVertex(t,null):new mo(t),e}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=null;return n=null!==this._vertexFactory?this._vertexFactory.createVertex(t,e):new mo(t),n.setOnConstraint(!0),n}}getSubdivision(){return this._subdiv}computeBoundingBox(){const t=vo.computeVertexEnvelope(this._initialVertices),e=vo.computeVertexEnvelope(this._segVertices),n=new N(t);n.expandToInclude(e);const s=.2*n.getWidth(),i=.2*n.getHeight(),r=Math.max(s,i);this._computeAreaEnv=new N(n),this._computeAreaEnv.expandBy(r)}setVertexFactory(t){this._vertexFactory=t}formInitialDelaunay(){this.computeBoundingBox(),this._subdiv=new So(this._computeAreaEnv,this._tolerance),this._subdiv.setLocator(new Io(this._subdiv)),this._incDel=new xo(this._subdiv),this.insertSites(this._initialVertices)}insertSite(){if(arguments[0]instanceof mo){const t=arguments[0],e=this._kdt.insert(t.getCoordinate(),t);if(e.isRepeated()){const n=e.getData();return n.merge(t),n}return this._incDel.insertSite(t),t}if(arguments[0]instanceof g){const t=arguments[0];this.insertSite(this.createVertex(t))}}getClass(){return vo}get interfaces_(){return[]}}vo.constructor_=function(){this._initialVertices=null,this._segVertices=null,this._segments=new x,this._subdiv=null,this._incDel=null,this._convexHull=null,this._splitFinder=new _o,this._kdt=null,this._vertexFactory=null,this._computeAreaEnv=null,this._splitPt=null,this._tolerance=null;const t=arguments[0],e=arguments[1];this._initialVertices=new x(t),this._tolerance=e,this._kdt=new es(e)},vo.MAX_SPLIT_ITER=99;class Oo{constructor(){Oo.constructor_.apply(this,arguments)}static extractUniqueCoordinates(t){if(null===t)return new I;const e=t.getCoordinates();return Oo.unique(e)}static envelope(t){const e=new N;for(let n=t.iterator();n.hasNext();){const t=n.next();e.expandToInclude(t)}return e}static unique(t){const e=X.copyDeep(t);return ht.sort(e),new I(e,!1)}static toVertices(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next();e.add(new po(t))}return e}create(){if(null!==this._subdiv)return null;const t=Oo.envelope(this._siteCoords),e=Oo.toVertices(this._siteCoords);this._subdiv=new So(t,this._tolerance),new xo(this._subdiv).insertSites(e)}setTolerance(t){this._tolerance=t}setSites(){if(arguments[0]instanceof q){const t=arguments[0];this._siteCoords=Oo.extractUniqueCoordinates(t)}else if(_(arguments[0],f)){const t=arguments[0];this._siteCoords=Oo.unique(X.toCoordinateArray(t))}}getEdges(t){return this.create(),this._subdiv.getEdges(t)}getSubdivision(){return this.create(),this._subdiv}getTriangles(t){return this.create(),this._subdiv.getTriangles(t)}getClass(){return Oo}get interfaces_(){return[]}}Oo.constructor_=function(){this._siteCoords=null,this._tolerance=0,this._subdiv=null};class bo{constructor(){bo.constructor_.apply(this,arguments)}static createConstraintSegments(){if(1===arguments.length){const t=arguments[0],e=xe.getLines(t),n=new x;for(let t=e.iterator();t.hasNext();){const e=t.next();bo.createConstraintSegments(e,n)}return n}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.getCoordinates();for(let t=1;t<n.length;t++)e.add(new Po(n[t-1],n[t]))}}createSiteVertices(t){const e=new x;for(let n=t.iterator();n.hasNext();){const t=n.next();this._constraintVertexMap.containsKey(t)||e.add(new mo(t))}return e}create(){if(null!==this._subdiv)return null;const t=Oo.envelope(this._siteCoords);let e=new x;null!==this._constraintLines&&(t.expandToInclude(this._constraintLines.getEnvelopeInternal()),this.createVertices(this._constraintLines),e=bo.createConstraintSegments(this._constraintLines));const n=this.createSiteVertices(this._siteCoords),s=new vo(n,this._tolerance);s.setConstraints(e,new x(this._constraintVertexMap.values())),s.formInitialDelaunay(),s.enforceConstraints(),this._subdiv=s.getSubdivision()}setTolerance(t){this._tolerance=t}setConstraints(t){this._constraintLines=t}setSites(t){this._siteCoords=Oo.extractUniqueCoordinates(t)}getEdges(t){return this.create(),this._subdiv.getEdges(t)}getSubdivision(){return this.create(),this._subdiv}getTriangles(t){return this.create(),this._subdiv.getTriangles(t)}createVertices(t){const e=t.getCoordinates();for(let t=0;t<e.length;t++){const n=new mo(e[t]);this._constraintVertexMap.put(e[t],n)}}getClass(){return bo}get interfaces_(){return[]}}bo.constructor_=function(){this._siteCoords=null,this._constraintLines=null,this._tolerance=0,this._subdiv=null,this._constraintVertexMap=new rt};class Mo{constructor(){Mo.constructor_.apply(this,arguments)}static clipGeometryCollection(t,e){const n=t.getFactory().toGeometry(e),s=new x;for(let i=0;i<t.getNumGeometries();i++){const r=t.getGeometryN(i);let o=null;e.contains(r.getEnvelopeInternal())?o=r:e.intersects(r.getEnvelopeInternal())&&(o=n.intersection(r),o.setUserData(r.getUserData())),null===o||o.isEmpty()||s.add(o)}return t.getFactory().createGeometryCollection(Ht.toGeometryArray(s))}create(){if(null!==this._subdiv)return null;const t=Oo.envelope(this._siteCoords);this._diagramEnv=t;const e=Math.max(this._diagramEnv.getWidth(),this._diagramEnv.getHeight());this._diagramEnv.expandBy(e),null!==this._clipEnv&&this._diagramEnv.expandToInclude(this._clipEnv);const n=Oo.toVertices(this._siteCoords);this._subdiv=new So(t,this._tolerance),new xo(this._subdiv).insertSites(n)}getDiagram(t){this.create();const e=this._subdiv.getVoronoiDiagram(t);return Mo.clipGeometryCollection(e,this._diagramEnv)}setTolerance(t){this._tolerance=t}setSites(){if(arguments[0]instanceof q){const t=arguments[0];this._siteCoords=Oo.extractUniqueCoordinates(t)}else if(_(arguments[0],f)){const t=arguments[0];this._siteCoords=Oo.unique(X.toCoordinateArray(t))}}setClipEnvelope(t){this._clipEnv=t}getSubdivision(){return this.create(),this._subdiv}getClass(){return Mo}get interfaces_(){return[]}}Mo.constructor_=function(){this._siteCoords=null,this._tolerance=0,this._subdiv=null,this._clipEnv=null,this._diagramEnv=null};var Do=Object.freeze({__proto__:null,Vertex:po}),Ao=Object.freeze({__proto__:null,ConformingDelaunayTriangulationBuilder:bo,DelaunayTriangulationBuilder:Oo,VoronoiDiagramBuilder:Mo,quadedge:Do});class Fo{constructor(){Fo.constructor_.apply(this,arguments)}static getEndLocation(t){const e=new Fo;return e.setToEnd(t),e}static pointAlongSegmentByFraction(t,e,n){if(n<=0)return t;if(n>=1)return e;const s=(e.x-t.x)*n+t.x,i=(e.y-t.y)*n+t.y,r=(e.z-t.z)*n+t.z;return new g(s,i,r)}static compareLocationValues(t,e,n,s,i,r){return t<s?-1:t>s?1:e<i?-1:e>i?1:n<r?-1:n>r?1:0}getSegmentIndex(){return this._segmentIndex}getComponentIndex(){return this._componentIndex}isEndpoint(t){const e=t.getGeometryN(this._componentIndex).getNumPoints()-1;return this._segmentIndex>=e||this._segmentIndex===e&&this._segmentFraction>=1}isValid(t){if(this._componentIndex<0||this._componentIndex>=t.getNumGeometries())return!1;const e=t.getGeometryN(this._componentIndex);return!(this._segmentIndex<0||this._segmentIndex>e.getNumPoints())&&((this._segmentIndex!==e.getNumPoints()||0===this._segmentFraction)&&!(this._segmentFraction<0||this._segmentFraction>1))}normalize(){this._segmentFraction<0&&(this._segmentFraction=0),this._segmentFraction>1&&(this._segmentFraction=1),this._componentIndex<0&&(this._componentIndex=0,this._segmentIndex=0,this._segmentFraction=0),this._segmentIndex<0&&(this._segmentIndex=0,this._segmentFraction=0),1===this._segmentFraction&&(this._segmentFraction=0,this._segmentIndex+=1)}toLowest(t){const e=t.getGeometryN(this._componentIndex).getNumPoints()-1;return this._segmentIndex<e?this:new Fo(this._componentIndex,e,1,!1)}getCoordinate(t){const e=t.getGeometryN(this._componentIndex),n=e.getCoordinateN(this._segmentIndex);if(this._segmentIndex>=e.getNumPoints()-1)return n;const s=e.getCoordinateN(this._segmentIndex+1);return Fo.pointAlongSegmentByFraction(n,s,this._segmentFraction)}getSegmentFraction(){return this._segmentFraction}getSegment(t){const e=t.getGeometryN(this._componentIndex),n=e.getCoordinateN(this._segmentIndex);if(this._segmentIndex>=e.getNumPoints()-1){const t=e.getCoordinateN(e.getNumPoints()-2);return new ee(t,n)}const s=e.getCoordinateN(this._segmentIndex+1);return new ee(n,s)}clamp(t){if(this._componentIndex>=t.getNumGeometries())return this.setToEnd(t),null;if(this._segmentIndex>=t.getNumPoints()){const e=t.getGeometryN(this._componentIndex);this._segmentIndex=e.getNumPoints()-1,this._segmentFraction=1}}setToEnd(t){this._componentIndex=t.getNumGeometries()-1;const e=t.getGeometryN(this._componentIndex);this._segmentIndex=e.getNumPoints()-1,this._segmentFraction=1}compareTo(t){const e=t;return this._componentIndex<e._componentIndex?-1:this._componentIndex>e._componentIndex?1:this._segmentIndex<e._segmentIndex?-1:this._segmentIndex>e._segmentIndex?1:this._segmentFraction<e._segmentFraction?-1:this._segmentFraction>e._segmentFraction?1:0}copy(){return new Fo(this._componentIndex,this._segmentIndex,this._segmentFraction)}toString(){return"LinearLoc["+this._componentIndex+", "+this._segmentIndex+", "+this._segmentFraction+"]"}isOnSameSegment(t){return this._componentIndex===t._componentIndex&&(this._segmentIndex===t._segmentIndex||(t._segmentIndex-this._segmentIndex==1&&0===t._segmentFraction||this._segmentIndex-t._segmentIndex==1&&0===this._segmentFraction))}snapToVertex(t,e){if(this._segmentFraction<=0||this._segmentFraction>=1)return null;const n=this.getSegmentLength(t),s=this._segmentFraction*n,i=n-s;s<=i&&s<e?this._segmentFraction=0:i<=s&&i<e&&(this._segmentFraction=1)}compareLocationValues(t,e,n){return this._componentIndex<t?-1:this._componentIndex>t?1:this._segmentIndex<e?-1:this._segmentIndex>e?1:this._segmentFraction<n?-1:this._segmentFraction>n?1:0}getSegmentLength(t){const e=t.getGeometryN(this._componentIndex);let n=this._segmentIndex;this._segmentIndex>=e.getNumPoints()-1&&(n=e.getNumPoints()-2);const s=e.getCoordinateN(n),i=e.getCoordinateN(n+1);return s.distance(i)}isVertex(){return this._segmentFraction<=0||this._segmentFraction>=1}getClass(){return Fo}get interfaces_(){return[r]}}Fo.constructor_=function(){if(this._componentIndex=0,this._segmentIndex=0,this._segmentFraction=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this._componentIndex=t._componentIndex,this._segmentIndex=t._segmentIndex,this._segmentFraction=t._segmentFraction}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Fo.constructor_.call(this,0,t,e)}else if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];this._componentIndex=t,this._segmentIndex=e,this._segmentFraction=n,this.normalize()}else if(4===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2],s=arguments[3];this._componentIndex=t,this._segmentIndex=e,this._segmentFraction=n,s&&this.normalize()}};class Go{constructor(){Go.constructor_.apply(this,arguments)}static segmentEndVertexIndex(t){return t.getSegmentFraction()>0?t.getSegmentIndex()+1:t.getSegmentIndex()}getComponentIndex(){return this._componentIndex}getLine(){return this._currentLine}getVertexIndex(){return this._vertexIndex}getSegmentEnd(){return this._vertexIndex<this.getLine().getNumPoints()-1?this._currentLine.getCoordinateN(this._vertexIndex+1):null}next(){if(!this.hasNext())return null;this._vertexIndex++,this._vertexIndex>=this._currentLine.getNumPoints()&&(this._componentIndex++,this.loadCurrentLine(),this._vertexIndex=0)}loadCurrentLine(){if(this._componentIndex>=this._numLines)return this._currentLine=null,null;this._currentLine=this._linearGeom.getGeometryN(this._componentIndex)}getSegmentStart(){return this._currentLine.getCoordinateN(this._vertexIndex)}isEndOfLine(){return!(this._componentIndex>=this._numLines)&&!(this._vertexIndex<this._currentLine.getNumPoints()-1)}hasNext(){return!(this._componentIndex>=this._numLines)&&!(this._componentIndex===this._numLines-1&&this._vertexIndex>=this._currentLine.getNumPoints())}getClass(){return Go}get interfaces_(){return[]}}Go.constructor_=function(){if(this._linearGeom=null,this._numLines=null,this._currentLine=null,this._componentIndex=0,this._vertexIndex=0,1===arguments.length){const t=arguments[0];Go.constructor_.call(this,t,0,0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];Go.constructor_.call(this,t,e.getComponentIndex(),Go.segmentEndVertexIndex(e))}else if(3===arguments.length){const t=arguments[0],e=arguments[1],s=arguments[2];if(!_(t,ot))throw new n("Lineal geometry is required");this._linearGeom=t,this._numLines=t.getNumGeometries(),this._componentIndex=e,this._vertexIndex=s,this.loadCurrentLine()}};class qo{constructor(){qo.constructor_.apply(this,arguments)}static indexOf(t,e){return new qo(t).indexOf(e)}static indexOfAfter(t,e,n){return new qo(t).indexOfAfter(e,n)}indexOf(t){return this.indexOfFromStart(t,null)}indexOfFromStart(t,e){let n=i.MAX_VALUE,s=0,r=0,o=-1;const l=new ee;for(let i=new Go(this._linearGeom);i.hasNext();i.next())if(!i.isEndOfLine()){l.p0=i.getSegmentStart(),l.p1=i.getSegmentEnd();const a=l.distance(t),c=l.segmentFraction(t),h=i.getComponentIndex(),u=i.getVertexIndex();a<n&&(null===e||e.compareLocationValues(h,u,c)<0)&&(s=h,r=u,o=c,n=a)}return n===i.MAX_VALUE?new Fo(e):new Fo(s,r,o)}indexOfAfter(t,e){if(null===e)return this.indexOf(t);const n=Fo.getEndLocation(this._linearGeom);if(n.compareTo(e)<=0)return n;const s=this.indexOfFromStart(t,e);return u.isTrue(s.compareTo(e)>=0,"computed location is before specified minimum location"),s}getClass(){return qo}get interfaces_(){return[]}}qo.constructor_=function(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t};class Bo{constructor(){Bo.constructor_.apply(this,arguments)}static indicesOf(t,e){return new Bo(t).indicesOf(e)}indicesOf(t){const e=t.getGeometryN(0).getCoordinateN(0),n=t.getGeometryN(t.getNumGeometries()-1),s=n.getCoordinateN(n.getNumPoints()-1),i=new qo(this._linearGeom),r=new Array(2).fill(null);return r[0]=i.indexOf(e),0===t.getLength()?r[1]=r[0].copy():r[1]=i.indexOfAfter(s,r[0]),r}getClass(){return Bo}get interfaces_(){return[]}}Bo.constructor_=function(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t};class Vo{constructor(){Vo.constructor_.apply(this,arguments)}getGeometry(){return this.endLine(),this._geomFact.buildGeometry(this._lines)}getLastCoordinate(){return this._lastPt}endLine(){if(null===this._coordList)return null;if(this._ignoreInvalidLines&&this._coordList.size()<2)return this._coordList=null,null;const t=this._coordList.toCoordinateArray();let e=t;this._fixInvalidLines&&(e=this.validCoordinateSequence(t)),this._coordList=null;let s=null;try{s=this._geomFact.createLineString(e)}catch(t){if(!(t instanceof n))throw t;if(!this._ignoreInvalidLines)throw t}null!==s&&this._lines.add(s)}setFixInvalidLines(t){this._fixInvalidLines=t}add(){if(1===arguments.length){const t=arguments[0];this.add(t,!0)}else if(2===arguments.length){const t=arguments[0],e=arguments[1];null===this._coordList&&(this._coordList=new I),this._coordList.add(t,e),this._lastPt=t}}setIgnoreInvalidLines(t){this._ignoreInvalidLines=t}validCoordinateSequence(t){if(t.length>=2)return t;return[t[0],t[0]]}getClass(){return Vo}get interfaces_(){return[]}}Vo.constructor_=function(){this._geomFact=null,this._lines=new x,this._coordList=null,this._ignoreInvalidLines=!1,this._fixInvalidLines=!1,this._lastPt=null;const t=arguments[0];this._geomFact=t};class zo{constructor(){zo.constructor_.apply(this,arguments)}static extract(t,e,n){return new zo(t).extract(e,n)}computeLinear(t,e){const n=new Vo(this._line.getFactory());n.setFixInvalidLines(!0),t.isVertex()||n.add(t.getCoordinate(this._line));for(let s=new Go(this._line,t);s.hasNext()&&!(e.compareLocationValues(s.getComponentIndex(),s.getVertexIndex(),0)<0);s.next()){const t=s.getSegmentStart();n.add(t),s.isEndOfLine()&&n.endLine()}return e.isVertex()||n.add(e.getCoordinate(this._line)),n.getGeometry()}computeLine(t,e){const n=this._line.getCoordinates(),s=new I;let i=t.getSegmentIndex();t.getSegmentFraction()>0&&(i+=1);let r=e.getSegmentIndex();1===e.getSegmentFraction()&&(r+=1),r>=n.length&&(r=n.length-1),t.isVertex()||s.add(t.getCoordinate(this._line));for(let t=i;t<=r;t++)s.add(n[t]);e.isVertex()||s.add(e.getCoordinate(this._line)),s.size()<=0&&s.add(t.getCoordinate(this._line));let o=s.toCoordinateArray();return o.length<=1&&(o=[o[0],o[0]]),this._line.getFactory().createLineString(o)}extract(t,e){return e.compareTo(t)<0?this.reverse(this.computeLinear(e,t)):this.computeLinear(t,e)}reverse(t){return t instanceof Tt||t instanceof ft?t.reverse():(u.shouldNeverReachHere("non-linear geometry encountered"),null)}getClass(){return zo}get interfaces_(){return[]}}zo.constructor_=function(){this._line=null;const t=arguments[0];this._line=t};class Yo{constructor(){Yo.constructor_.apply(this,arguments)}clampIndex(t){const e=t.copy();return e.clamp(this._linearGeom),e}project(t){return qo.indexOf(this._linearGeom,t)}checkGeometryType(){if(!(this._linearGeom instanceof Tt||this._linearGeom instanceof ft))throw new n("Input geometry must be linear")}extractPoint(){if(1===arguments.length){return arguments[0].getCoordinate(this._linearGeom)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=t.toLowest(this._linearGeom);return n.getSegment(this._linearGeom).pointAlongOffset(n.getSegmentFraction(),e)}}isValidIndex(t){return t.isValid(this._linearGeom)}getEndIndex(){return Fo.getEndLocation(this._linearGeom)}getStartIndex(){return new Fo}indexOfAfter(t,e){return qo.indexOfAfter(this._linearGeom,t,e)}extractLine(t,e){return zo.extract(this._linearGeom,t,e)}indexOf(t){return qo.indexOf(this._linearGeom,t)}indicesOf(t){return Bo.indicesOf(this._linearGeom,t)}getClass(){return Yo}get interfaces_(){return[]}}Yo.constructor_=function(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t,this.checkGeometryType()};class Uo{constructor(){Uo.constructor_.apply(this,arguments)}static indexOf(t,e){return new Uo(t).indexOf(e)}static indexOfAfter(t,e,n){return new Uo(t).indexOfAfter(e,n)}indexOf(t){return this.indexOfFromStart(t,-1)}indexOfFromStart(t,e){let n=i.MAX_VALUE,s=e,r=0;const o=new ee,l=new Go(this._linearGeom);for(;l.hasNext();){if(!l.isEndOfLine()){o.p0=l.getSegmentStart(),o.p1=l.getSegmentEnd();const i=o.distance(t),a=this.segmentNearestMeasure(o,t,r);i<n&&a>e&&(s=a,n=i),r+=o.getLength()}l.next()}return s}indexOfAfter(t,e){if(e<0)return this.indexOf(t);const n=this._linearGeom.getLength();if(n<e)return n;const s=this.indexOfFromStart(t,e);return u.isTrue(s>=e,"computed index is before specified minimum index"),s}segmentNearestMeasure(t,e,n){const s=t.projectionFactor(e);return s<=0?n:s<=1?n+s*t.getLength():n+t.getLength()}getClass(){return Uo}get interfaces_(){return[]}}Uo.constructor_=function(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t};class ko{constructor(){ko.constructor_.apply(this,arguments)}static getLength(t,e){return new ko(t).getLength(e)}static getLocation(){if(2===arguments.length){const t=arguments[0],e=arguments[1];return new ko(t).getLocation(e)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return new ko(t).getLocation(e,n)}}getLength(t){let e=0;const n=new Go(this._linearGeom);for(;n.hasNext();){if(!n.isEndOfLine()){const s=n.getSegmentStart(),i=n.getSegmentEnd().distance(s);if(t.getComponentIndex()===n.getComponentIndex()&&t.getSegmentIndex()===n.getVertexIndex())return e+i*t.getSegmentFraction();e+=i}n.next()}return e}resolveHigher(t){if(!t.isEndpoint(this._linearGeom))return t;let e=t.getComponentIndex();if(e>=this._linearGeom.getNumGeometries()-1)return t;do{e++}while(e<this._linearGeom.getNumGeometries()-1&&0===this._linearGeom.getGeometryN(e).getLength());return new Fo(e,0,0)}getLocation(){if(1===arguments.length){const t=arguments[0];return this.getLocation(t,!0)}if(2===arguments.length){const t=arguments[0],e=arguments[1];let n=t;if(t<0){n=this._linearGeom.getLength()+t}const s=this.getLocationForward(n);return e?s:this.resolveHigher(s)}}getLocationForward(t){if(t<=0)return new Fo;let e=0;const n=new Go(this._linearGeom);for(;n.hasNext();){if(n.isEndOfLine()){if(e===t){const t=n.getComponentIndex(),e=n.getVertexIndex();return new Fo(t,e,0)}}else{const s=n.getSegmentStart(),i=n.getSegmentEnd().distance(s);if(e+i>t){const s=(t-e)/i,r=n.getComponentIndex(),o=n.getVertexIndex();return new Fo(r,o,s)}e+=i}n.next()}return Fo.getEndLocation(this._linearGeom)}getClass(){return ko}get interfaces_(){return[]}}ko.constructor_=function(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t};class Xo{constructor(){Xo.constructor_.apply(this,arguments)}clampIndex(t){const e=this.positiveIndex(t),n=this.getStartIndex();if(e<n)return n;const s=this.getEndIndex();return e>s?s:e}locationOf(){if(1===arguments.length){const t=arguments[0];return ko.getLocation(this._linearGeom,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return ko.getLocation(this._linearGeom,t,e)}}project(t){return Uo.indexOf(this._linearGeom,t)}positiveIndex(t){return t>=0?t:this._linearGeom.getLength()+t}extractPoint(){if(1===arguments.length){const t=arguments[0];return ko.getLocation(this._linearGeom,t).getCoordinate(this._linearGeom)}if(2===arguments.length){const t=arguments[0],e=arguments[1],n=ko.getLocation(this._linearGeom,t).toLowest(this._linearGeom);return n.getSegment(this._linearGeom).pointAlongOffset(n.getSegmentFraction(),e)}}isValidIndex(t){return t>=this.getStartIndex()&&t<=this.getEndIndex()}getEndIndex(){return this._linearGeom.getLength()}getStartIndex(){return 0}indexOfAfter(t,e){return Uo.indexOfAfter(this._linearGeom,t,e)}extractLine(t,e){new Yo(this._linearGeom);const n=this.clampIndex(t),s=this.clampIndex(e),i=n===s,r=this.locationOf(n,i),o=this.locationOf(s);return zo.extract(this._linearGeom,r,o)}indexOf(t){return Uo.indexOf(this._linearGeom,t)}indicesOf(t){const e=Bo.indicesOf(this._linearGeom,t);return[ko.getLength(this._linearGeom,e[0]),ko.getLength(this._linearGeom,e[1])]}getClass(){return Xo}get interfaces_(){return[]}}Xo.constructor_=function(){this._linearGeom=null;const t=arguments[0];this._linearGeom=t};var Ho=Object.freeze({__proto__:null,LengthIndexedLine:Xo,LengthLocationMap:ko,LinearGeometryBuilder:Vo,LinearIterator:Go,LinearLocation:Fo,LocationIndexedLine:Yo});class Wo{constructor(){Wo.constructor_.apply(this,arguments)}static transform(t,e){const n=new x;for(let s=t.iterator();s.hasNext();)n.add(e.execute(s.next()));return n}static select(t,e){const n=new x;for(let s=t.iterator();s.hasNext();){const t=s.next();Boolean.TRUE.equals(e.execute(t))&&n.add(t)}return n}static apply(t,e){for(let n=t.iterator();n.hasNext();)e.execute(n.next())}getClass(){return Wo}get interfaces_(){return[]}}Wo.Function=function(){},Wo.constructor_=function(){};class jo{constructor(){jo.constructor_.apply(this,arguments)}filter(t){this.pts[this.n++]=t}getCoordinates(){return this.pts}getClass(){return jo}get interfaces_(){return[B]}}jo.constructor_=function(){this.pts=null,this.n=0;const t=arguments[0];this.pts=new Array(t).fill(null)};class Ko{constructor(){Ko.constructor_.apply(this,arguments)}filter(t){this._n++}getCount(){return this._n}getClass(){return Ko}get interfaces_(){return[B]}}Ko.constructor_=function(){this._n=0};class Zo{constructor(){Zo.constructor_.apply(this,arguments)}count(t){const e=this._counts.get(t);return null===e?0:e.count()}add(t){const e=this._counts.get(t);null===e?this._counts.put(t,new Qo(1)):e.increment()}getClass(){return Zo}get interfaces_(){return[]}}class Qo{constructor(){Qo.constructor_.apply(this,arguments)}count(){return this.count}increment(){this.count++}getClass(){return Qo}get interfaces_(){return[]}}Qo.constructor_=function(){if(this.count=0,0===arguments.length);else if(1===arguments.length){const t=arguments[0];this.count=t}},Zo.Counter=Qo,Zo.constructor_=function(){this._counts=new Ut};var Jo=Object.freeze({__proto__:null,CollectionUtil:Wo,CoordinateArrayFilter:jo,CoordinateCountFilter:Ko,GeometricShapeFactory:Se,NumberUtil:e,ObjectCounter:Zo,PriorityQueue:fs,StringUtil:St,UniqueCoordinateArrayFilter:ln});class $o{get interfaces_(){return[]}getClass(){return $o}static union(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return cr.createEmptyResult(cr.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),lr.overlayOp(t,e,cr.UNION)}}q.prototype.equalsTopo=function(t){return!!this.getEnvelopeInternal().equals(t.getEnvelopeInternal())&&Gr.relate(this,t).isEquals(this.getDimension(),t.getDimension())},q.prototype.union=function(){if(0===arguments.length)return zr.union(this);if(1===arguments.length){const t=arguments[0];return $o.union(this,t)}},q.prototype.isValid=function(){return Cr.isValid(this)},q.prototype.intersection=function(t){return cr.intersection(this,t)},q.prototype.covers=function(t){return Gr.covers(this,t)},q.prototype.coveredBy=function(t){return Gr.covers(t,this)},q.prototype.touches=function(t){return Gr.touches(this,t)},q.prototype.intersects=function(t){return Gr.intersects(this,t)},q.prototype.within=function(t){return Gr.contains(t,this)},q.prototype.overlaps=function(t){return Gr.overlaps(this,t)},q.prototype.disjoint=function(t){return Gr.disjoint(this,t)},q.prototype.crosses=function(t){return Gr.crosses(this,t)},q.prototype.buffer=function(){if(1===arguments.length){const t=arguments[0];return Si.bufferOp(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return Si.bufferOp(this,t,e)}if(3===arguments.length){const t=arguments[0],e=arguments[1],n=arguments[2];return Si.bufferOp(this,t,e,n)}},q.prototype.convexHull=function(){return new an(this).getConvexHull()},q.prototype.relate=function(...t){if(1===arguments.length){const t=arguments[0];return Gr.relate(this,t)}if(2===arguments.length){const t=arguments[0],e=arguments[1];return Gr.relate(this,t).matches(e)}},q.prototype.getCentroid=function(){if(this.isEmpty())return this._factory.createPoint();const t=sn.getCentroid(this);return this.createPointFromInternalCoord(t,this)},q.prototype.getInteriorPoint=function(){if(this.isEmpty())return this._factory.createPoint();let t=null;const e=this.getDimension();t=0===e?new dn(this):1===e?new gn(this):new hn(this);const n=t.getInteriorPoint();return this.createPointFromInternalCoord(n,this)},q.prototype.symDifference=function(t){return cr.symDifference(this,t)},q.prototype.createPointFromInternalCoord=function(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)},q.prototype.toText=function(){return(new Jt).write(this)},q.prototype.toString=function(){this.toText()},q.prototype.contains=function(t){return Gr.contains(this,t)},q.prototype.difference=function(t){return cr.difference(this,t)},q.prototype.isSimple=function(){return new Hs(this).isSimple()},q.prototype.isWithinDistance=function(t,e){return!(this.getEnvelopeInternal().distance(t.getEnvelopeInternal())>e)&&Ri.isWithinDistance(this,t,e)},q.prototype.distance=function(t){return Ri.distance(this,t)},q.prototype.isEquivalentClass=function(t){return this.getClass()===t.getClass()};t.algorithm=mn,t.densify=En,t.dissolve=Rn,t.geom=Re,t.geomgraph=Jn,t.index=Cs,t.io=Ps,t.linearref=Ho,t.noding=Xs,t.operation=kr,t.precision=Wr,t.simplify=ho,t.triangulate=Ao,t.util=Jo,t.version="2.1.2 (83b5aee)",Object.defineProperty(t,"__esModule",{value:!0})}));

},{}],7:[function(require,module,exports){
/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (typeof define === 'function' && define.amd) {
        define(definition);
    } else if (typeof module === 'object' && module.exports) {
        module.exports = definition();
    } else {
        root.log = definition();
    }
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";
    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (
        /Trident\/|MSIE /.test(window.navigator.userAgent)
    );

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Trace() doesn't print the message in IE, so for that case we need to wrap it
    function traceForIE() {
        if (console.log) {
            if (console.log.apply) {
                console.log.apply(console, arguments);
            } else {
                // In old IE, native console methods themselves don't have apply().
                Function.prototype.apply.apply(console.log, [console, arguments]);
            }
        }
        if (console.trace) console.trace();
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (methodName === 'trace' && isIE) {
            return traceForIE;
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    return defaultLogger;
}));

},{}],8:[function(require,module,exports){
(function (process){
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":10}],9:[function(require,module,exports){
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(factory());
}(this, (function () { 'use strict';

/**
 * Checks, if polygon is simple. Polygon is simple, when its edges don't cross each other.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @returns {boolean} true if Polygon is simple
 */
function IsSimple (polygon) {
  var p = polygon;
  var n = p.length >> 1;
  if (n < 4) return true
  var a1 = Point();
  var a2 = Point();
  var b1 = Point();
  var b2 = Point();
  var c = Point();

  for (var i = 0; i < n; i++) {
    a1.x = p[2 * i];
    a1.y = p[2 * i + 1];
    if (i == n - 1) {
      a2.x = p[0];
      a2.y = p[1];
    } else {
      a2.x = p[2 * i + 2];
      a2.y = p[2 * i + 3];
    }

    for (var j = 0; j < n; j++) {
      if (Math.abs(i - j) < 2) continue
      if (j == n - 1 && i == 0) continue
      if (i == n - 1 && j == 0) continue

      b1.x = p[2 * j];
      b1.y = p[2 * j + 1];
      if (j == n - 1) {
        b2.x = p[0];
        b2.y = p[1];
      } else {
        b2.x = p[2 * j + 2];
        b2.y = p[2 * j + 3];
      }

      if (GetLineIntersection(a1, a2, b1, b2, c) != null) return false
    }
  }
  return true
}
module.exports.IsSimple = IsSimple;

/**
 * Checks, if polygon is convex. Polygon is convex, when each inner angle is <= 180Â°.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @returns {boolean}
 */
function IsConvex (polygon) {
  var p = polygon;
  if (p.length < 6) return true
  var l = p.length - 4;
  for (var i = 0; i < l; i += 2) {
    if (!convex(p[i], p[i + 1], p[i + 2], p[i + 3], p[i + 4], p[i + 5])) return false
  }
  if (!convex(p[l], p[l + 1], p[l + 2], p[l + 3], p[0], p[1])) return false
  if (!convex(p[l + 2], p[l + 3], p[0], p[1], p[2], p[3])) return false
  return true
}
module.exports.IsConvex = IsConvex;

/**
 * Returns the area of polygon.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @returns {number}
 */
function GetArea (polygon) {
  var p = polygon;
  if (p.length < 6) return 0
  var l = p.length - 2;
  var sum = 0;
  for (var i = 0; i < l; i += 2) {
    sum += (p[i + 2] - p[i]) * (p[i + 1] + p[i + 3]);
  }
  sum += (p[0] - p[l]) * (p[l + 1] + p[1]);
  return -sum * 0.5
}
module.exports.GetArea = GetArea;

/**
 * Returns the Axis-aligned Bounding Box of polygon
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @returns {AABB}
 * @example
 * //={x:0, y:0, width:0, height:0}
 */
function GetAABB (polygon) {
  var p = polygon;
  var minx = Infinity;
  var miny = Infinity;
  var maxx = -minx;
  var maxy = -miny;
  for (var i = 0; i < p.length; i += 2) {
    minx = Math.min(minx, p[i]);
    maxx = Math.max(maxx, p[i]);
    miny = Math.min(miny, p[i + 1]);
    maxy = Math.max(maxy, p[i + 1]);
  }
  return {x: minx, y: miny, width: maxx - minx, height: maxy - miny}
}
module.exports.GetAABB = GetAABB;

/**
 * Computes the triangulation. Output array is array of triangles (triangle = 3 indices of polygon vertices).
 *
 * Works with simple polygons only.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @returns {number[]} array of triangles (triangle = 3 indices of polygon vertices)
 * @example
 * var ids = PolyK.Triangulate([0, 0, 1, 0, 1, 1, 0, 1]);
 * //=[0, 1, 2, 0, 2, 3]
 */
function Triangulate (polygon) {
  var p = polygon;
  var n = p.length >> 1;
  if (n < 3) return []
  var tgs = [];
  var avl = [];
  for (var i = 0; i < n; i++) { avl.push(i); }

  var i = 0;
  var al = n;
  while (al > 3) {
    var i0 = avl[(i + 0) % al];
    var i1 = avl[(i + 1) % al];
    var i2 = avl[(i + 2) % al];

    var ax = p[2 * i0];
    var ay = p[2 * i0 + 1];
    var bx = p[2 * i1];
    var by = p[2 * i1 + 1];
    var cx = p[2 * i2];
    var cy = p[2 * i2 + 1];

    var earFound = false;
    if (convex(ax, ay, bx, by, cx, cy)) {
      earFound = true;
      for (var j = 0; j < al; j++) {
        var vi = avl[j];
        if (vi == i0 || vi == i1 || vi == i2) continue
        if (PointInTriangle(p[2 * vi], p[2 * vi + 1], ax, ay, bx, by, cx, cy)) {
          earFound = false;
          break
        }
      }
    }
    if (earFound) {
      tgs.push(i0, i1, i2);
      avl.splice((i + 1) % al, 1);
      al--;
      i = 0;
    } else if (i++ > 3 * al) break    // no convex angles :(
  }
  tgs.push(avl[0], avl[1], avl[2]);
  return tgs
}
module.exports.Triangulate = Triangulate;

/**
 * Slices the polygon with line segment A-B, defined by [ax,ay] and [bx,by]. A, B must not lay inside a polygon. Returns an array of polygons.
 *
 * Works with simple polygons only.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @param {number} startX Start Coordinate [x]
 * @param {number} startY Start Coordinate [y]
 * @param {number} endX End Coordinate [x]
 * @param {number} endY End Coordinate [y]
 * @returns {number[][]} Array of Polygon
 */
function Slice (polygon, startX, startY, endX, endY) {
  var p = polygon;
  var ax = startX;
  var ay = startY;
  var bx = endX;
  var by = endY;
  if (ContainsPoint(p, ax, ay) || ContainsPoint(p, bx, by)) {
    return [p.slice(0)]
  }

  var a = Point(ax, ay);
  var b = Point(bx, by);
  var iscs = [];  // intersections
  var ps = [];  // points
  for (var i = 0; i < p.length; i += 2) {
    ps.push(Point(p[i], p[i + 1]));
  }
  for (var i = 0; i < ps.length; i++) {
    var isc = Point(0, 0);
    isc = GetLineIntersection(a, b, ps[i], ps[(i + 1) % ps.length], isc);
    var fisc = iscs[0];
    var lisc = iscs[iscs.length - 1];
    // && (isc.x!=ps[i].x || isc.y!=ps[i].y) )
    if (isc && (fisc == null || distance(isc, fisc) > 1e-10) && (lisc == null || distance(isc, lisc) > 1e-10)) {
      isc.flag = true;
      iscs.push(isc);
      ps.splice(i + 1, 0, isc);
      i++;
    }
  }

  if (iscs.length < 2) return [p.slice(0)]
  var comp = function (u, v) { return distance(a, u) - distance(a, v) };
  iscs.sort(comp);

  var pgs = [];
  var dir = 0;
  while (iscs.length > 0) {
    // var n = ps.length // is assigned a value but never used. (no-unused-vars)
    var i0 = iscs[0];
    var i1 = iscs[1];
    // if(i0.x==i1.x && i0.y==i1.y) { iscs.splice(0,2); continue;}
    var index0 = ps.indexOf(i0);
    var index1 = ps.indexOf(i1);
    var solved = false;

    if (firstWithFlag(ps, index0) === index1) {
      solved = true;
    } else {
      i0 = iscs[1];
      i1 = iscs[0];
      index0 = ps.indexOf(i0);
      index1 = ps.indexOf(i1);
      if (firstWithFlag(ps, index0) === index1) solved = true;
    }
    if (solved) {
      dir--;
      var pgn = getPoints(ps, index0, index1);
      pgs.push(pgn);
      ps = getPoints(ps, index1, index0);
      i0.flag = i1.flag = false;
      iscs.splice(0, 2);
      if (iscs.length == 0) pgs.push(ps);
    } else {
      dir++;
      iscs.reverse();
    }
    if (dir > 1) break
  }
  var result = [];
  for (var i = 0; i < pgs.length; i++) {
    var pg = pgs[i];
    var npg = [];
    for (var j = 0; j < pg.length; j++) { npg.push(pg[j].x, pg[j].y); }
    result.push(npg);
  }
  return result
}
module.exports.Slice = Slice;

/**
 * Checks, if polygon contains [x, y].
 *
 * Works with simple polygons only.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @param {number} pointX Coordinate [x]
 * @param {number} pointY Coordinate [y]
 * @returns {boolean} depth
 */
function ContainsPoint (polygon, pointX, pointY) {
  var p = polygon;
  var px = pointX;
  var py = pointY;
  var n = p.length >> 1;
  var ax;
  var ay = p[2 * n - 3] - py;
  var bx = p[2 * n - 2] - px;
  var by = p[2 * n - 1] - py;

  // var lup = by > ay;
  for (var i = 0; i < n; i++) {
    ax = bx;
    ay = by;
    bx = p[2 * i] - px;
    by = p[2 * i + 1] - py;
    if (ay === by) continue
    var lup = by > ay;
  }

  var depth = 0;
  for (var i = 0; i < n; i++) {
    ax = bx;
    ay = by;
    bx = p[2 * i] - px;
    by = p[2 * i + 1] - py;
    if (ay < 0 && by < 0) continue  // both "up" or both "down"
    if (ay > 0 && by > 0) continue  // both "up" or both "down"
    if (ax < 0 && bx < 0) continue   // both points on the left

    if (ay === by && Math.min(ax, bx) <= 0) return true
    if (ay === by) continue

    var lx = ax + (bx - ax) * (-ay) / (by - ay);
    if (lx === 0) return true      // point on edge
    if (lx > 0) depth++;
    if (ay === 0 && lup && by > ay) depth--;  // hit vertex, both up
    if (ay === 0 && !lup && by < ay) depth--; // hit vertex, both down
    lup = by > ay;
  }
  return (depth & 1) === 1
}
module.exports.ContainsPoint = ContainsPoint;

/**
 * Finds the closest point of polygon, which lays on ray defined by [x,y] (origin) and [dx,dy] (direction).
 *
 * "dist" is the distance of the polygon point, "edge" is the number of the edge, on which intersection occurs, "norm" is the normal in that place, "refl" is reflected direction.
 *
 * Works with simple polygons only.
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @param {number} originX Origin [x]
 * @param {number} originY Origin [y]
 * @param {number} directionX Direction [x]
 * @param {number} directionY Direction [y]
 * @returns {Raycast}
 * @example
 * //={dist:0, edge:0, norm:{x:0, y:0}, refl:{x:0, y:0}}
 */
function Raycast (polygon, originX, originY, directionX, directionY, isc) {
  var p = polygon;
  var x = originX;
  var y = originY;
  var dx = directionX;
  var dy = directionY;
  var l = p.length - 2;
  var empty = emptyPoints();
  var a1 = empty[0];
  var a2 = empty[1];
  var b1 = empty[2];
  var b2 = empty[3];
  var c = empty[4];
  a1.x = x;
  a1.y = y;
  a2.x = x + dx;
  a2.y = y + dy;

  if (isc === null || isc === undefined) {
    isc = {dist: 0, edge: 0, norm: {x: 0, y: 0}, refl: {x: 0, y: 0}};
  }
  isc.dist = Infinity;

  var nisc;
  for (var i = 0; i < l; i += 2) {
    b1.x = p[i];
    b1.y = p[i + 1];
    b2.x = p[i + 2];
    b2.y = p[i + 3];
    nisc = RayLineIntersection(a1, a2, b1, b2, c);
    if (nisc) {
      isc = updateISC(dx, dy, a1, b1, b2, c, i / 2, isc);
    }
  }
  b1.x = b2.x;
  b1.y = b2.y;
  b2.x = p[0];
  b2.y = p[1];
  nisc = RayLineIntersection(a1, a2, b1, b2, c);
  if (nisc) {
    isc = updateISC(dx, dy, a1, b1, b2, c, (p.length / 2) - 1, isc);
  }

  return (isc.dist !== Infinity) ? isc : null
}
module.exports.Raycast = Raycast;

/**
 * Finds the point on polygon edges, which is closest to [x,y]. Returns an object in this format
 *
 * "dist" is the distance of the polygon point, "edge" is the number of the closest edge, "point" is the closest point on that edge, "norm" is the normal from "point" to [x,y].
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 * @param {number} x Coordinate [x]
 * @param {number} y Coordinate [y]
 * @returns {ClosestEdge}
 * @example
 * //={dist:0, edge:0, point:{x:0, y:0}, norm:{x:0, y:0}}
 */
function ClosestEdge (polygon, x, y, isc) {
  var p = polygon;
  var l = p.length - 2;
  var empty = emptyPoints();
  var a1 = empty[0];
  var b1 = empty[2];
  var b2 = empty[3];
  // var c = tp[4] // is assigned a value but never used.
  a1.x = x;
  a1.y = y;

  if (isc == null) {
    isc = {dist: 0, edge: 0, point: {x: 0, y: 0}, norm: {x: 0, y: 0}};
  }
  isc.dist = Infinity;

  for (var i = 0; i < l; i += 2) {
    b1.x = p[i];
    b1.y = p[i + 1];
    b2.x = p[i + 2];
    b2.y = p[i + 3];
    isc = pointLineDist(a1, b1, b2, i >> 1, isc);
  }
  b1.x = b2.x;
  b1.y = b2.y;
  b2.x = p[0];
  b2.y = p[1];
  isc = pointLineDist(a1, b1, b2, l >> 1, isc);

  var idst = 1 / isc.dist;
  isc.norm.x = (x - isc.point.x) * idst;
  isc.norm.y = (y - isc.point.y) * idst;
  return isc
}
module.exports.ClosestEdge = ClosestEdge;

/**
 * Reverse
 *
 * @param {number[]} polygon [x1, y1, x2, y2...]
 */
function Reverse (polygon) {
  var p = polygon;
  var np = [];
  for (var j = p.length - 2; j >= 0; j -= 2) { np.push(p[j], p[j + 1]); }
  return np
}
module.exports.Reverse = Reverse;

/**
 * Point Line Distance
 *
 * @private
 * @param {Point} p
 * @param {Point} a
 * @param {Point} b
 * @param {??} edge
 * @param {??} isc
 * @returns {??} ISC
 */
function pointLineDist (p, a, b, edge, isc) {
  var x = p.x;
  var y = p.y;
  var x1 = a.x;
  var y1 = a.y;
  var x2 = b.x;
  var y2 = b.y;

  var A = x - x1;
  var B = y - y1;
  var C = x2 - x1;
  var D = y2 - y1;

  var dot = A * C + B * D;
  var lenSq = C * C + D * D;
  var param = dot / lenSq;

  var xx;
  var yy;

  if (param < 0 || (x1 == x2 && y1 == y2)) {
    xx = x1;
    yy = y1;
  } else if (param > 1) {
    xx = x2;
    yy = y2;
  } else {
    xx = x1 + param * C;
    yy = y1 + param * D;
  }

  var dx = x - xx;
  var dy = y - yy;
  var dst = Math.sqrt(dx * dx + dy * dy);
  if (dst < isc.dist) {
    isc.dist = dst;
    isc.edge = edge;
    isc.point.x = xx;
    isc.point.y = yy;
  }
  return isc
}

/**
 * Update ISC
 *
 * @private
 * @param {number} dx
 * @param {number} dy
 * @param {Point} a1
 * @param {Point} b1
 * @param {Point} b2
 * @param {Point} c
 * @param {??} edge
 * @param {??} isc
 * @returns {??}
 */
function updateISC (dx, dy, a1, b1, b2, c, edge, isc) {
  var nrl = distance(a1, c);
  if (nrl < isc.dist) {
    var ibl = 1 / distance(b1, b2);
    var nx = -(b2.y - b1.y) * ibl;
    var ny = (b2.x - b1.x) * ibl;
    var ddot = 2 * (dx * nx + dy * ny);
    isc.dist = nrl;
    isc.norm.x = nx;
    isc.norm.y = ny;
    isc.refl.x = -ddot * nx + dx;
    isc.refl.y = -ddot * ny + dy;
    isc.edge = edge;
  }
  return isc
}

/**
 * Get Points
 *
 * @private
 * @param {number[]} points
 * @param {number} index0
 * @param {number} index1
 * @returns {number[]} points
 */
function getPoints (points, index0, index1) {
  var n = points.length;
  var result = [];
  if (index1 < index0) index1 += n;
  for (var i = index0; i <= index1; i++) { result.push(points[i % n]); }
  return result
}

/**
 * First With Flag
 *
 * @private
 * @param {Point[]} points
 * @param {number} index
 * @returns {number}
 */
function firstWithFlag (points, index) {
  var n = points.length;
  while (true) {
    index = (index + 1) % n;
    if (points[index].flag) {
      return index
    }
  }
}

/**
 * Point in Triangle
 *
 * @private
 * @param {number} px
 * @param {number} py
 * @param {number} ax
 * @param {number} ay
 * @param {number} bx
 * @param {number} by
 * @param {number} cx
 * @param {number} cy
 * @returns {boolean}
 */
function PointInTriangle (px, py, ax, ay, bx, by, cx, cy) {
  var v0x = cx - ax;
  var v0y = cy - ay;
  var v1x = bx - ax;
  var v1y = by - ay;
  var v2x = px - ax;
  var v2y = py - ay;

  var dot00 = v0x * v0x + v0y * v0y;
  var dot01 = v0x * v1x + v0y * v1y;
  var dot02 = v0x * v2x + v0y * v2y;
  var dot11 = v1x * v1x + v1y * v1y;
  var dot12 = v1x * v2x + v1y * v2y;

  var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
  var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
  var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

  // Check if point is in triangle
  return (u >= 0) && (v >= 0) && (u + v < 1)
}

/**
 * RayLine Intersection
 *
 * @private
 * @param {Point} a1
 * @param {Point} a2
 * @param {Point} b1
 * @param {Point} b2
 * @param {Point} c
 */
function RayLineIntersection (a1, a2, b1, b2, c) {
  var dax = (a1.x - a2.x);
  var dbx = (b1.x - b2.x);
  var day = (a1.y - a2.y);
  var dby = (b1.y - b2.y);

  var Den = dax * dby - day * dbx;
  if (Den == 0) return null  // parallel

  var A = (a1.x * a2.y - a1.y * a2.x);
  var B = (b1.x * b2.y - b1.y * b2.x);

  var I = c;
  var iDen = 1 / Den;
  I.x = (A * dbx - dax * B) * iDen;
  I.y = (A * dby - day * B) * iDen;

  if (!InRectangle(I, b1, b2)) return null
  if ((day > 0 && I.y > a1.y) || (day < 0 && I.y < a1.y)) return null
  if ((dax > 0 && I.x > a1.x) || (dax < 0 && I.x < a1.x)) return null
  return I
}

/**
 * Get Line Intersection
 *
 * @private
 * @param {Point} a1
 * @param {Point} a2
 * @param {Point} b1
 * @param {Point} b2
 * @param {Point} c
 * @returns {Point}
 */
function GetLineIntersection (a1, a2, b1, b2, c) {
  var dax = (a1.x - a2.x);
  var dbx = (b1.x - b2.x);
  var day = (a1.y - a2.y);
  var dby = (b1.y - b2.y);

  var Den = dax * dby - day * dbx;

  if (Den === 0) { return null } // parallel

  var A = (a1.x * a2.y - a1.y * a2.x);
  var B = (b1.x * b2.y - b1.y * b2.x);

  var I = c;
  I.x = (A * dbx - dax * B) / Den;
  I.y = (A * dby - day * B) / Den;

  if (InRectangle(I, a1, a2) && InRectangle(I, b1, b2)) {
    return I
  }
  return null
}

/**
 * In Rectangle
 *
 * @private
 * @param {Point} a
 * @param {Point} b
 * @param {Point} c
 * @return {boolean}
 */
function InRectangle (a, b, c) {
  var minx = Math.min(b.x, c.x);
  var maxx = Math.max(b.x, c.x);
  var miny = Math.min(b.y, c.y);
  var maxy = Math.max(b.y, c.y);

  if (minx === maxx) { return (miny <= a.y && a.y <= maxy) }
  if (miny === maxy) { return (minx <= a.x && a.x <= maxx) }

  // return (minx <= a.x && a.x <= maxx && miny <= a.y && a.y <= maxy)
  return (minx <= a.x + 1e-10 && a.x - 1e-10 <= maxx && miny <= a.y + 1e-10 && a.y - 1e-10 <= maxy)
}

/**
 * Convex
 *
 * @private
 * @param {Point} ax
 * @param {Point} ay
 * @param {Point} bx
 * @param {Point} by
 * @param {Point} cx
 * @param {Point} cy
 * @returns {boolean}
 */
function convex (ax, ay, bx, by, cx, cy) {
  return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0
}

/**
 * Point
 *
 * @private
 * @param {number} x
 * @param {number} y
 * @returns {Point}
 */
function Point (x, y) {
  return {
    x: x,
    y: y,
    flag: false,
    toString: function () { return 'Point [' + x + ', ' + y + ']' }
  }
}

/**
 * Distance
 *
 * @private
 * @param {Point} a
 * @param {Point} b
 * @returns {number}
 */
function distance (a, b) {
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  return Math.sqrt(dx * dx + dy * dy)
}

/**
 * Creates an array of empty Points
 *
 * @private
 * @param {number} [num=10] Number of points
 * @returns {Point[]}
 */
function emptyPoints (num) {
  num = num || 10;
  var container = [];
  for (var i = 0; i < num; i++) { container.push(Point(0, 0)); }
  return container
}

})));


},{}],10:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],11:[function(require,module,exports){
"use strict";
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */var t=function(e,n){return(t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])})(e,n)};function e(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}function n(){for(var t=0,e=0,n=arguments.length;e<n;e++)t+=arguments[e].length;var r=Array(t),a=0;for(e=0;e<n;e++)for(var o=arguments[e],s=0,h=o.length;s<h;s++,a++)r[a]=o[s];return r}function r(t,e,n){if(t&&t.length){var r=e[0],a=e[1],o=Math.PI/180*n,s=Math.cos(o),h=Math.sin(o);t.forEach((function(t){var e=t[0],n=t[1];t[0]=(e-r)*s-(n-a)*h+r,t[1]=(e-r)*h+(n-a)*s+a}))}}function a(t){var e=t[0],n=t[1];return Math.sqrt(Math.pow(e[0]-n[0],2)+Math.pow(e[1]-n[1],2))}function o(t,e){var a=[0,0],o=Math.round(e.hachureAngle+90);o&&r(t,a,o);var s=function(t,e){var r=n(t);r[0].join(",")!==r[r.length-1].join(",")&&r.push([r[0][0],r[0][1]]);var a=[];if(r&&r.length>2){var o=e.hachureGap;o<0&&(o=4*e.strokeWidth),o=Math.max(o,.1);for(var s=[],h=0;h<r.length-1;h++){var i=r[h],u=r[h+1];if(i[1]!==u[1]){var p=Math.min(i[1],u[1]);s.push({ymin:p,ymax:Math.max(i[1],u[1]),x:p===i[1]?i[0]:u[0],islope:(u[0]-i[0])/(u[1]-i[1])})}}if(s.sort((function(t,e){return t.ymin<e.ymin?-1:t.ymin>e.ymin?1:t.x<e.x?-1:t.x>e.x?1:t.ymax===e.ymax?0:(t.ymax-e.ymax)/Math.abs(t.ymax-e.ymax)})),!s.length)return a;for(var c=[],l=s[0].ymin;c.length||s.length;){if(s.length){var f=-1;for(h=0;h<s.length&&!(s[h].ymin>l);h++)f=h;s.splice(0,f+1).forEach((function(t){c.push({s:l,edge:t})}))}if((c=c.filter((function(t){return!(t.edge.ymax<=l)}))).sort((function(t,e){return t.edge.x===e.edge.x?0:(t.edge.x-e.edge.x)/Math.abs(t.edge.x-e.edge.x)})),c.length>1)for(h=0;h<c.length;h+=2){var d=h+1;if(d>=c.length)break;var g=c[h].edge,y=c[d].edge;a.push([[Math.round(g.x),l],[Math.round(y.x),l]])}l+=o,c.forEach((function(t){t.edge.x=t.edge.x+o*t.edge.islope}))}}return a}(t,e);return o&&(r(t,a,-o),function(t,e,n){var a=[];t.forEach((function(t){return a.push.apply(a,t)})),r(a,e,n)}(s,a,-o)),s}var s=function(){function t(t){this.helper=t}return t.prototype.fillPolygon=function(t,e){return this._fillPolygon(t,e)},t.prototype._fillPolygon=function(t,e,n){void 0===n&&(n=!1);var r=o(t,e);return{type:"fillSketch",ops:this.renderLines(r,e,n)}},t.prototype.renderLines=function(t,e,n){for(var r=[],a=null,o=0,s=t;o<s.length;o++){var h=s[o];r.push.apply(r,this.helper.doubleLineOps(h[0][0],h[0][1],h[1][0],h[1][1],e)),n&&a&&r.push.apply(r,this.helper.doubleLineOps(a[0],a[1],h[0][0],h[0][1],e)),a=h[1]}return r},t}(),h=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return e(n,t),n.prototype.fillPolygon=function(t,e){return this._fillPolygon(t,e,!0)},n}(s),i=function(t){function n(){return null!==t&&t.apply(this,arguments)||this}return e(n,t),n.prototype.fillPolygon=function(t,e){var n=this._fillPolygon(t,e),r=Object.assign({},e,{hachureAngle:e.hachureAngle+90}),a=this._fillPolygon(t,r);return n.ops=n.ops.concat(a.ops),n},n}(s),u=function(){function t(t){this.helper=t}return t.prototype.fillPolygon=function(t,e){var n=o(t,e=Object.assign({},e,{curveStepCount:4,hachureAngle:0,roughness:1}));return this.dotsOnLines(n,e)},t.prototype.dotsOnLines=function(t,e){var n=[],r=e.hachureGap;r<0&&(r=4*e.strokeWidth),r=Math.max(r,.1);var o=e.fillWeight;o<0&&(o=e.strokeWidth/2);for(var s=r/4,h=0,i=t;h<i.length;h++)for(var u=i[h],p=a(u),c=p/r,l=Math.ceil(c)-1,f=p-l*r,d=(u[0][0]+u[1][0])/2-r/4,g=Math.min(u[0][1],u[1][1]),y=0;y<l;y++){var v=g+f+y*r,M=this.helper.randOffsetWithRange(d-s,d+s,e),k=this.helper.randOffsetWithRange(v-s,v+s,e),b=this.helper.ellipse(M,k,o,o,e);n.push.apply(n,b.ops)}return{type:"fillSketch",ops:n}},t}(),p=function(){function t(t){this.helper=t}return t.prototype.fillPolygon=function(t,e){var n=o(t,e);return{type:"fillSketch",ops:this.dashedLine(n,e)}},t.prototype.dashedLine=function(t,e){var n=this,r=e.dashOffset<0?e.hachureGap<0?4*e.strokeWidth:e.hachureGap:e.dashOffset,o=e.dashGap<0?e.hachureGap<0?4*e.strokeWidth:e.hachureGap:e.dashGap,s=[];return t.forEach((function(t){var h=a(t),i=Math.floor(h/(r+o)),u=(h+o-i*(r+o))/2,p=t[0],c=t[1];p[0]>c[0]&&(p=t[1],c=t[0]);for(var l=Math.atan((c[1]-p[1])/(c[0]-p[0])),f=0;f<i;f++){var d=f*(r+o),g=d+r,y=[p[0]+d*Math.cos(l)+u*Math.cos(l),p[1]+d*Math.sin(l)+u*Math.sin(l)],v=[p[0]+g*Math.cos(l)+u*Math.cos(l),p[1]+g*Math.sin(l)+u*Math.sin(l)];s.push.apply(s,n.helper.doubleLineOps(y[0],y[1],v[0],v[1],e))}})),s},t}(),c=function(){function t(t){this.helper=t}return t.prototype.fillPolygon=function(t,e){var n=e.hachureGap<0?4*e.strokeWidth:e.hachureGap,r=e.zigzagOffset<0?n:e.zigzagOffset,a=o(t,e=Object.assign({},e,{hachureGap:n+r}));return{type:"fillSketch",ops:this.zigzagLines(a,r,e)}},t.prototype.zigzagLines=function(t,e,r){var o=this,s=[];return t.forEach((function(t){var h=a(t),i=Math.round(h/(2*e)),u=t[0],p=t[1];u[0]>p[0]&&(u=t[1],p=t[0]);for(var c=Math.atan((p[1]-u[1])/(p[0]-u[0])),l=0;l<i;l++){var f=2*l*e,d=2*(l+1)*e,g=Math.sqrt(2*Math.pow(e,2)),y=[u[0]+f*Math.cos(c),u[1]+f*Math.sin(c)],v=[u[0]+d*Math.cos(c),u[1]+d*Math.sin(c)],M=[y[0]+g*Math.cos(c+Math.PI/4),y[1]+g*Math.sin(c+Math.PI/4)];s.push.apply(s,n(o.helper.doubleLineOps(y[0],y[1],M[0],M[1],r),o.helper.doubleLineOps(M[0],M[1],v[0],v[1],r)))}})),s},t}(),l={};var f=function(){function t(t){this.seed=t}return t.prototype.next=function(){return this.seed?(Math.pow(2,31)-1&(this.seed=Math.imul(48271,this.seed)))/Math.pow(2,31):Math.random()},t}();const d={A:7,a:7,C:6,c:6,H:1,h:1,L:2,l:2,M:2,m:2,Q:4,q:4,S:4,s:4,T:2,t:2,V:1,v:1,Z:0,z:0};function g(t,e){return t.type===e}function y(t){const e=[],n=function(t){const e=new Array;for(;""!==t;)if(t.match(/^([ \t\r\n,]+)/))t=t.substr(RegExp.$1.length);else if(t.match(/^([aAcChHlLmMqQsStTvVzZ])/))e[e.length]={type:0,text:RegExp.$1},t=t.substr(RegExp.$1.length);else{if(!t.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/))return[];e[e.length]={type:1,text:""+parseFloat(RegExp.$1)},t=t.substr(RegExp.$1.length)}return e[e.length]={type:2,text:""},e}(t);let r="BOD",a=0,o=n[a];for(;!g(o,2);){let s=0;const h=[];if("BOD"===r){if("M"!==o.text&&"m"!==o.text)return y("M0,0"+t);a++,s=d[o.text],r=o.text}else g(o,1)?s=d[r]:(a++,s=d[o.text],r=o.text);if(!(a+s<n.length))throw new Error("Path data ended short");for(let t=a;t<a+s;t++){const e=n[t];if(!g(e,1))throw new Error("Param not a number: "+r+","+e.text);h[h.length]=+e.text}if("number"!=typeof d[r])throw new Error("Bad segment: "+r);{const t={key:r,data:h};e.push(t),a+=s,o=n[a],"M"===r&&(r="L"),"m"===r&&(r="l")}}return e}function v(t){let e=0,n=0,r=0,a=0;const o=[];for(const{key:s,data:h}of t)switch(s){case"M":o.push({key:"M",data:[...h]}),[e,n]=h,[r,a]=h;break;case"m":e+=h[0],n+=h[1],o.push({key:"M",data:[e,n]}),r=e,a=n;break;case"L":o.push({key:"L",data:[...h]}),[e,n]=h;break;case"l":e+=h[0],n+=h[1],o.push({key:"L",data:[e,n]});break;case"C":o.push({key:"C",data:[...h]}),e=h[4],n=h[5];break;case"c":{const t=h.map((t,r)=>r%2?t+n:t+e);o.push({key:"C",data:t}),e=t[4],n=t[5];break}case"Q":o.push({key:"Q",data:[...h]}),e=h[2],n=h[3];break;case"q":{const t=h.map((t,r)=>r%2?t+n:t+e);o.push({key:"Q",data:t}),e=t[2],n=t[3];break}case"A":o.push({key:"A",data:[...h]}),e=h[5],n=h[6];break;case"a":e+=h[5],n+=h[6],o.push({key:"A",data:[h[0],h[1],h[2],h[3],h[4],e,n]});break;case"H":o.push({key:"H",data:[...h]}),e=h[0];break;case"h":e+=h[0],o.push({key:"H",data:[e]});break;case"V":o.push({key:"V",data:[...h]}),n=h[0];break;case"v":n+=h[0],o.push({key:"V",data:[n]});break;case"S":o.push({key:"S",data:[...h]}),e=h[2],n=h[3];break;case"s":{const t=h.map((t,r)=>r%2?t+n:t+e);o.push({key:"S",data:t}),e=t[2],n=t[3];break}case"T":o.push({key:"T",data:[...h]}),e=h[0],n=h[1];break;case"t":e+=h[0],n+=h[1],o.push({key:"T",data:[e,n]});break;case"Z":case"z":o.push({key:"Z",data:[]}),e=r,n=a}return o}function M(t){const e=[];let n="",r=0,a=0,o=0,s=0,h=0,i=0;for(const{key:u,data:p}of t){switch(u){case"M":e.push({key:"M",data:[...p]}),[r,a]=p,[o,s]=p;break;case"C":e.push({key:"C",data:[...p]}),r=p[4],a=p[5],h=p[2],i=p[3];break;case"L":e.push({key:"L",data:[...p]}),[r,a]=p;break;case"H":r=p[0],e.push({key:"L",data:[r,a]});break;case"V":a=p[0],e.push({key:"L",data:[r,a]});break;case"S":{let t=0,o=0;"C"===n||"S"===n?(t=r+(r-h),o=a+(a-i)):(t=r,o=a),e.push({key:"C",data:[t,o,...p]}),h=p[0],i=p[1],r=p[2],a=p[3];break}case"T":{const[t,o]=p;let s=0,u=0;"Q"===n||"T"===n?(s=r+(r-h),u=a+(a-i)):(s=r,u=a);const c=r+2*(s-r)/3,l=a+2*(u-a)/3,f=t+2*(s-t)/3,d=o+2*(u-o)/3;e.push({key:"C",data:[c,l,f,d,t,o]}),h=s,i=u,r=t,a=o;break}case"Q":{const[t,n,o,s]=p,u=r+2*(t-r)/3,c=a+2*(n-a)/3,l=o+2*(t-o)/3,f=s+2*(n-s)/3;e.push({key:"C",data:[u,c,l,f,o,s]}),h=t,i=n,r=o,a=s;break}case"A":{const t=Math.abs(p[0]),n=Math.abs(p[1]),o=p[2],s=p[3],h=p[4],i=p[5],u=p[6];if(0===t||0===n)e.push({key:"C",data:[r,a,i,u,i,u]}),r=i,a=u;else if(r!==i||a!==u){b(r,a,i,u,t,n,o,s,h).forEach((function(t){e.push({key:"C",data:t})})),r=i,a=u}break}case"Z":e.push({key:"Z",data:[]}),r=o,a=s}n=u}return e}function k(t,e,n){return[t*Math.cos(n)-e*Math.sin(n),t*Math.sin(n)+e*Math.cos(n)]}function b(t,e,n,r,a,o,s,h,i,u){const p=(c=s,Math.PI*c/180);var c;let l=[],f=0,d=0,g=0,y=0;if(u)[f,d,g,y]=u;else{[t,e]=k(t,e,-p),[n,r]=k(n,r,-p);const s=(t-n)/2,u=(e-r)/2;let c=s*s/(a*a)+u*u/(o*o);c>1&&(c=Math.sqrt(c),a*=c,o*=c);const l=a*a,v=o*o,M=l*v-l*u*u-v*s*s,b=l*u*u+v*s*s,m=(h===i?-1:1)*Math.sqrt(Math.abs(M/b));g=m*a*u/o+(t+n)/2,y=m*-o*s/a+(e+r)/2,f=Math.asin(parseFloat(((e-y)/o).toFixed(9))),d=Math.asin(parseFloat(((r-y)/o).toFixed(9))),t<g&&(f=Math.PI-f),n<g&&(d=Math.PI-d),f<0&&(f=2*Math.PI+f),d<0&&(d=2*Math.PI+d),i&&f>d&&(f-=2*Math.PI),!i&&d>f&&(d-=2*Math.PI)}let v=d-f;if(Math.abs(v)>120*Math.PI/180){const t=d,e=n,h=r;d=i&&d>f?f+120*Math.PI/180*1:f+120*Math.PI/180*-1,l=b(n=g+a*Math.cos(d),r=y+o*Math.sin(d),e,h,a,o,s,0,i,[d,t,g,y])}v=d-f;const M=Math.cos(f),m=Math.sin(f),w=Math.cos(d),P=Math.sin(d),x=Math.tan(v/4),O=4/3*a*x,S=4/3*o*x,T=[t,e],_=[t+O*m,e-S*M],C=[n+O*P,r-S*w],W=[n,r];if(_[0]=2*T[0]-_[0],_[1]=2*T[1]-_[1],u)return[_,C,W].concat(l);{l=[_,C,W].concat(l);const t=[];for(let e=0;e<l.length;e+=3){const n=k(l[e][0],l[e][1],p),r=k(l[e+1][0],l[e+1][1],p),a=k(l[e+2][0],l[e+2][1],p);t.push([n[0],n[1],r[0],r[1],a[0],a[1]])}return t}}var m={randOffset:function(t,e){return E(t,e)},randOffsetWithRange:function(t,e,n){return L(t,e,n)},ellipse:function(t,e,n,r,a){var o=O(n,r,a);return S(t,e,a,o).opset},doubleLineOps:function(t,e,n,r,a){return z(t,e,n,r,a)}};function w(t,e,n,r,a){return{type:"path",ops:z(t,e,n,r,a)}}function P(t,e,n){var r=(t||[]).length;if(r>2){for(var a=[],o=0;o<r-1;o++)a.push.apply(a,z(t[o][0],t[o][1],t[o+1][0],t[o+1][1],n));return e&&a.push.apply(a,z(t[r-1][0],t[r-1][1],t[0][0],t[0][1],n)),{type:"path",ops:a}}return 2===r?w(t[0][0],t[0][1],t[1][0],t[1][1],n):{type:"path",ops:[]}}function x(t,e,n,r,a){return function(t,e){return P(t,!0,e)}([[t,e],[t+n,e],[t+n,e+r],[t,e+r]],a)}function O(t,e,n){var r=Math.sqrt(2*Math.PI*Math.sqrt((Math.pow(t/2,2)+Math.pow(e/2,2))/2)),a=Math.max(n.curveStepCount,n.curveStepCount/Math.sqrt(200)*r),o=2*Math.PI/a,s=Math.abs(t/2),h=Math.abs(e/2),i=1-n.curveFitting;return{increment:o,rx:s+=E(s*i,n),ry:h+=E(h*i,n)}}function S(t,e,n,r){var a=G(r.increment,t,e,r.rx,r.ry,1,r.increment*L(.1,L(.4,1,n),n),n),o=a[0],s=a[1],h=G(r.increment,t,e,r.rx,r.ry,1.5,0,n)[0],i=q(o,null,n),u=q(h,null,n);return{estimatedPoints:s,opset:{type:"path",ops:i.concat(u)}}}function T(t,e,r,a,o,s,h,i,u){var p=t,c=e,l=Math.abs(r/2),f=Math.abs(a/2);l+=E(.01*l,u),f+=E(.01*f,u);for(var d=o,g=s;d<0;)d+=2*Math.PI,g+=2*Math.PI;g-d>2*Math.PI&&(d=0,g=2*Math.PI);var y=2*Math.PI/u.curveStepCount,v=Math.min(y/2,(g-d)/2),M=j(v,p,c,l,f,d,g,1,u),k=j(v,p,c,l,f,d,g,1.5,u),b=M.concat(k);return h&&(i?b.push.apply(b,n(z(p,c,p+l*Math.cos(d),c+f*Math.sin(d),u),z(p,c,p+l*Math.cos(g),c+f*Math.sin(g),u))):b.push({op:"lineTo",data:[p,c]},{op:"lineTo",data:[p+l*Math.cos(d),c+f*Math.sin(d)]})),{type:"path",ops:b}}function _(t,e){for(var n=M(v(y(t))),r=[],a=[0,0],o=[0,0],s=function(t,n){switch(t){case"M":var s=1*(e.maxRandomnessOffset||0);r.push({op:"move",data:n.map((function(t){return t+E(s,e)}))}),o=[n[0],n[1]],a=[n[0],n[1]];break;case"L":r.push.apply(r,z(o[0],o[1],n[0],n[1],e)),o=[n[0],n[1]];break;case"C":var h=n[0],i=n[1],u=n[2],p=n[3],c=n[4],l=n[5];r.push.apply(r,function(t,e,n,r,a,o,s,h){for(var i=[],u=[h.maxRandomnessOffset||1,(h.maxRandomnessOffset||1)+.3],p=[0,0],c=0;c<2;c++)0===c?i.push({op:"move",data:[s[0],s[1]]}):i.push({op:"move",data:[s[0]+E(u[0],h),s[1]+E(u[0],h)]}),p=[a+E(u[c],h),o+E(u[c],h)],i.push({op:"bcurveTo",data:[t+E(u[c],h),e+E(u[c],h),n+E(u[c],h),r+E(u[c],h),p[0],p[1]]});return i}(h,i,u,p,c,l,o,e)),o=[c,l];break;case"Z":r.push.apply(r,z(o[0],o[1],a[0],a[1],e)),o=[a[0],a[1]]}},h=0,i=n;h<i.length;h++){var u=i[h];s(u.key,u.data)}return{type:"path",ops:r}}function C(t,e){var n=[];if(t.length){var r=e.maxRandomnessOffset||0,a=t.length;if(a>2){n.push({op:"move",data:[t[0][0]+E(r,e),t[0][1]+E(r,e)]});for(var o=1;o<a;o++)n.push({op:"lineTo",data:[t[o][0]+E(r,e),t[o][1]+E(r,e)]})}}return{type:"fillPath",ops:n}}function W(t,e){return function(t,e){var n=t.fillStyle||"hachure";if(!l[n])switch(n){case"zigzag":l[n]||(l[n]=new h(e));break;case"cross-hatch":l[n]||(l[n]=new i(e));break;case"dots":l[n]||(l[n]=new u(e));break;case"dashed":l[n]||(l[n]=new p(e));break;case"zigzag-line":l[n]||(l[n]=new c(e));break;case"hachure":default:l[n="hachure"]||(l[n]=new s(e))}return l[n]}(e,m).fillPolygon(t,e)}function I(t){return t.randomizer||(t.randomizer=new f(t.seed||0)),t.randomizer.next()}function L(t,e,n,r){return void 0===r&&(r=1),n.roughness*r*(I(n)*(e-t)+t)}function E(t,e,n){return void 0===n&&(n=1),L(-t,t,e,n)}function z(t,e,n,r,a){var o=A(t,e,n,r,a,!0,!1),s=A(t,e,n,r,a,!0,!0);return o.concat(s)}function A(t,e,n,r,a,o,s){var h=Math.pow(t-n,2)+Math.pow(e-r,2),i=Math.sqrt(h),u=1;u=i<200?1:i>500?.4:-.0016668*i+1.233334;var p=a.maxRandomnessOffset||0;p*p*100>h&&(p=i/10);var c=p/2,l=.2+.2*I(a),f=a.bowing*a.maxRandomnessOffset*(r-e)/200,d=a.bowing*a.maxRandomnessOffset*(t-n)/200;f=E(f,a,u),d=E(d,a,u);var g=[],y=function(){return E(c,a,u)},v=function(){return E(p,a,u)};return o&&(s?g.push({op:"move",data:[t+y(),e+y()]}):g.push({op:"move",data:[t+E(p,a,u),e+E(p,a,u)]})),s?g.push({op:"bcurveTo",data:[f+t+(n-t)*l+y(),d+e+(r-e)*l+y(),f+t+2*(n-t)*l+y(),d+e+2*(r-e)*l+y(),n+y(),r+y()]}):g.push({op:"bcurveTo",data:[f+t+(n-t)*l+v(),d+e+(r-e)*l+v(),f+t+2*(n-t)*l+v(),d+e+2*(r-e)*l+v(),n+v(),r+v()]}),g}function R(t,e,n){var r=[];r.push([t[0][0]+E(e,n),t[0][1]+E(e,n)]),r.push([t[0][0]+E(e,n),t[0][1]+E(e,n)]);for(var a=1;a<t.length;a++)r.push([t[a][0]+E(e,n),t[a][1]+E(e,n)]),a===t.length-1&&r.push([t[a][0]+E(e,n),t[a][1]+E(e,n)]);return q(r,null,n)}function q(t,e,n){var r=t.length,a=[];if(r>3){var o=[],s=1-n.curveTightness;a.push({op:"move",data:[t[1][0],t[1][1]]});for(var h=1;h+2<r;h++){var i=t[h];o[0]=[i[0],i[1]],o[1]=[i[0]+(s*t[h+1][0]-s*t[h-1][0])/6,i[1]+(s*t[h+1][1]-s*t[h-1][1])/6],o[2]=[t[h+1][0]+(s*t[h][0]-s*t[h+2][0])/6,t[h+1][1]+(s*t[h][1]-s*t[h+2][1])/6],o[3]=[t[h+1][0],t[h+1][1]],a.push({op:"bcurveTo",data:[o[1][0],o[1][1],o[2][0],o[2][1],o[3][0],o[3][1]]})}if(e&&2===e.length){var u=n.maxRandomnessOffset;a.push({op:"lineTo",data:[e[0]+E(u,n),e[1]+E(u,n)]})}}else 3===r?(a.push({op:"move",data:[t[1][0],t[1][1]]}),a.push({op:"bcurveTo",data:[t[1][0],t[1][1],t[2][0],t[2][1],t[2][0],t[2][1]]})):2===r&&a.push.apply(a,z(t[0][0],t[0][1],t[1][0],t[1][1],n));return a}function G(t,e,n,r,a,o,s,h){var i=[],u=[],p=E(.5,h)-Math.PI/2;u.push([E(o,h)+e+.9*r*Math.cos(p-t),E(o,h)+n+.9*a*Math.sin(p-t)]);for(var c=p;c<2*Math.PI+p-.01;c+=t){var l=[E(o,h)+e+r*Math.cos(c),E(o,h)+n+a*Math.sin(c)];i.push(l),u.push(l)}return u.push([E(o,h)+e+r*Math.cos(p+2*Math.PI+.5*s),E(o,h)+n+a*Math.sin(p+2*Math.PI+.5*s)]),u.push([E(o,h)+e+.98*r*Math.cos(p+s),E(o,h)+n+.98*a*Math.sin(p+s)]),u.push([E(o,h)+e+.9*r*Math.cos(p+.5*s),E(o,h)+n+.9*a*Math.sin(p+.5*s)]),[u,i]}function j(t,e,n,r,a,o,s,h,i){var u=o+E(.1,i),p=[];p.push([E(h,i)+e+.9*r*Math.cos(u-t),E(h,i)+n+.9*a*Math.sin(u-t)]);for(var c=u;c<=s;c+=t)p.push([E(h,i)+e+r*Math.cos(c),E(h,i)+n+a*Math.sin(c)]);return p.push([e+r*Math.cos(s),n+a*Math.sin(s)]),p.push([e+r*Math.cos(s),n+a*Math.sin(s)]),q(p,null,i)}function Z(t){return[...t]}function D(t,e){return Math.pow(t[0]-e[0],2)+Math.pow(t[1]-e[1],2)}function F(t,e,n){const r=D(e,n);if(0===r)return D(t,e);let a=((t[0]-e[0])*(n[0]-e[0])+(t[1]-e[1])*(n[1]-e[1]))/r;return a=Math.max(0,Math.min(1,a)),D(t,Q(e,n,a))}function Q(t,e,n){return[t[0]+(e[0]-t[0])*n,t[1]+(e[1]-t[1])*n]}function H(t,e,n,r){const a=r||[];if(function(t,e){const n=t[e+0],r=t[e+1],a=t[e+2],o=t[e+3];let s=3*r[0]-2*n[0]-o[0];s*=s;let h=3*r[1]-2*n[1]-o[1];h*=h;let i=3*a[0]-2*o[0]-n[0];i*=i;let u=3*a[1]-2*o[1]-n[1];return u*=u,s<i&&(s=i),h<u&&(h=u),s+h}(t,e)<n){const n=t[e+0];if(a.length){(o=a[a.length-1],s=n,Math.sqrt(D(o,s)))>1&&a.push(n)}else a.push(n);a.push(t[e+3])}else{const r=.5,o=t[e+0],s=t[e+1],h=t[e+2],i=t[e+3],u=Q(o,s,r),p=Q(s,h,r),c=Q(h,i,r),l=Q(u,p,r),f=Q(p,c,r),d=Q(l,f,r);H([o,u,l,d],0,n,a),H([d,f,c,i],0,n,a)}var o,s;return a}function N(t,e){return V(t,0,t.length,e)}function V(t,e,n,r,a){const o=a||[],s=t[e],h=t[n-1];let i=0,u=1;for(let r=e+1;r<n-1;++r){const e=F(t[r],s,h);e>i&&(i=e,u=r)}return Math.sqrt(i)>r?(V(t,e,u+1,r,o),V(t,u,n,r,o)):(o.length||o.push(s),o.push(h)),o}function $(t,e=.15,n){const r=[],a=(t.length-1)/3;for(let n=0;n<a;n++){H(t,3*n,e,r)}return n&&n>0?V(r,0,r.length,n):r}var B="none",J=function(){function t(t){this.defaultOptions={maxRandomnessOffset:2,roughness:1,bowing:1,stroke:"#000",strokeWidth:1,curveTightness:0,curveFitting:.95,curveStepCount:9,fillStyle:"hachure",fillWeight:-1,hachureAngle:-41,hachureGap:-1,dashOffset:-1,dashGap:-1,zigzagOffset:-1,seed:0,combineNestedSvgPaths:!1},this.config=t||{},this.config.options&&(this.defaultOptions=this._o(this.config.options))}return t.newSeed=function(){return Math.floor(Math.random()*Math.pow(2,31))},t.prototype._o=function(t){return t?Object.assign({},this.defaultOptions,t):this.defaultOptions},t.prototype._d=function(t,e,n){return{shape:t,sets:e||[],options:n||this.defaultOptions}},t.prototype.line=function(t,e,n,r,a){var o=this._o(a);return this._d("line",[w(t,e,n,r,o)],o)},t.prototype.rectangle=function(t,e,n,r,a){var o=this._o(a),s=[],h=x(t,e,n,r,o);if(o.fill){var i=[[t,e],[t+n,e],[t+n,e+r],[t,e+r]];"solid"===o.fillStyle?s.push(C(i,o)):s.push(W(i,o))}return o.stroke!==B&&s.push(h),this._d("rectangle",s,o)},t.prototype.ellipse=function(t,e,n,r,a){var o=this._o(a),s=[],h=O(n,r,o),i=S(t,e,o,h);if(o.fill)if("solid"===o.fillStyle){var u=S(t,e,o,h).opset;u.type="fillPath",s.push(u)}else s.push(W(i.estimatedPoints,o));return o.stroke!==B&&s.push(i.opset),this._d("ellipse",s,o)},t.prototype.circle=function(t,e,n,r){var a=this.ellipse(t,e,n,n,r);return a.shape="circle",a},t.prototype.linearPath=function(t,e){var n=this._o(e);return this._d("linearPath",[P(t,!1,n)],n)},t.prototype.arc=function(t,e,n,r,a,o,s,h){void 0===s&&(s=!1);var i=this._o(h),u=[],p=T(t,e,n,r,a,o,s,!0,i);if(s&&i.fill)if("solid"===i.fillStyle){var c=T(t,e,n,r,a,o,!0,!1,i);c.type="fillPath",u.push(c)}else u.push(function(t,e,n,r,a,o,s){var h=t,i=e,u=Math.abs(n/2),p=Math.abs(r/2);u+=E(.01*u,s),p+=E(.01*p,s);for(var c=a,l=o;c<0;)c+=2*Math.PI,l+=2*Math.PI;l-c>2*Math.PI&&(c=0,l=2*Math.PI);for(var f=(l-c)/s.curveStepCount,d=[],g=c;g<=l;g+=f)d.push([h+u*Math.cos(g),i+p*Math.sin(g)]);return d.push([h+u*Math.cos(l),i+p*Math.sin(l)]),d.push([h,i]),W(d,s)}(t,e,n,r,a,o,i));return i.stroke!==B&&u.push(p),this._d("arc",u,i)},t.prototype.curve=function(t,e){var n=this._o(e),r=[],a=function(t,e){var n=R(t,1*(1+.2*e.roughness),e),r=R(t,1.5*(1+.22*e.roughness),e);return{type:"path",ops:n.concat(r)}}(t,n);if(n.fill&&n.fill!==B&&t.length>=3){var o=$(function(t,e=0){const n=t.length;if(n<3)throw new Error("A curve must have at least three points.");const r=[];if(3===n)r.push(Z(t[0]),Z(t[1]),Z(t[2]),Z(t[2]));else{const n=[];n.push(t[0],t[0]);for(let e=1;e<t.length;e++)n.push(t[e]),e===t.length-1&&n.push(t[e]);const a=[],o=1-e;r.push(Z(n[0]));for(let t=1;t+2<n.length;t++){const e=n[t];a[0]=[e[0],e[1]],a[1]=[e[0]+(o*n[t+1][0]-o*n[t-1][0])/6,e[1]+(o*n[t+1][1]-o*n[t-1][1])/6],a[2]=[n[t+1][0]+(o*n[t][0]-o*n[t+2][0])/6,n[t+1][1]+(o*n[t][1]-o*n[t+2][1])/6],a[3]=[n[t+1][0],n[t+1][1]],r.push(a[1],a[2],a[3])}}return r}(t),10,(1+n.roughness)/2);"solid"===n.fillStyle?r.push(C(o,n)):r.push(W(o,n))}return n.stroke!==B&&r.push(a),this._d("curve",r,n)},t.prototype.polygon=function(t,e){var n=this._o(e),r=[],a=P(t,!0,n);return n.fill&&("solid"===n.fillStyle?r.push(C(t,n)):r.push(W(t,n))),n.stroke!==B&&r.push(a),this._d("polygon",r,n)},t.prototype.path=function(t,e){var n=this._o(e),r=[];if(!t)return this._d("path",r,n);t=(t||"").replace(/\n/g," ").replace(/(-\s)/g,"-").replace("/(ss)/g"," ");var a=n.fill&&"transparent"!==n.fill&&n.fill!==B,o=n.stroke!==B,s=!!(n.simplification&&n.simplification<1),h=function(t,e,n){const r=M(v(y(t))),a=[];let o=[],s=[0,0],h=[];const i=()=>{h.length>=4&&o.push(...$(h,e)),h=[]},u=()=>{i(),o.length&&(a.push(o),o=[])};for(const{key:t,data:e}of r)switch(t){case"M":u(),s=[e[0],e[1]],o.push(s);break;case"L":i(),o.push([e[0],e[1]]);break;case"C":if(!h.length){const t=o.length?o[o.length-1]:s;h.push([t[0],t[1]])}h.push([e[0],e[1]]),h.push([e[2],e[3]]),h.push([e[4],e[5]]);break;case"Z":i(),o.push([s[0],s[1]])}if(u(),!n)return a;const p=[];for(const t of a){const e=N(t,n);e.length&&p.push(e)}return p}(t,1,s?4-4*n.simplification:(1+n.roughness)/2);if(a)if(n.combineNestedSvgPaths){var i=[];h.forEach((function(t){return i.push.apply(i,t)})),"solid"===n.fillStyle?r.push(C(i,n)):r.push(W(i,n))}else h.forEach((function(t){"solid"===n.fillStyle?r.push(C(t,n)):r.push(W(t,n))}));return o&&(s?h.forEach((function(t){r.push(P(t,!1,n))})):r.push(_(t,n))),this._d("path",r,n)},t.prototype.opsToPath=function(t){for(var e="",n=0,r=t.ops;n<r.length;n++){var a=r[n],o=a.data;switch(a.op){case"move":e+="M"+o[0]+" "+o[1]+" ";break;case"bcurveTo":e+="C"+o[0]+" "+o[1]+", "+o[2]+" "+o[3]+", "+o[4]+" "+o[5]+" ";break;case"lineTo":e+="L"+o[0]+" "+o[1]+" "}}return e.trim()},t.prototype.toPaths=function(t){for(var e=t.sets||[],n=t.options||this.defaultOptions,r=[],a=0,o=e;a<o.length;a++){var s=o[a],h=null;switch(s.type){case"path":h={d:this.opsToPath(s),stroke:n.stroke,strokeWidth:n.strokeWidth,fill:B};break;case"fillPath":h={d:this.opsToPath(s),stroke:B,strokeWidth:0,fill:n.fill||B};break;case"fillSketch":h=this.fillSketch(s,n)}h&&r.push(h)}return r},t.prototype.fillSketch=function(t,e){var n=e.fillWeight;return n<0&&(n=e.strokeWidth/2),{d:this.opsToPath(t),stroke:e.fill||B,strokeWidth:n,fill:B}},t}(),K=function(){function t(t,e){this.canvas=t,this.ctx=this.canvas.getContext("2d"),this.gen=new J(e)}return t.prototype.draw=function(t){for(var e=t.sets||[],n=t.options||this.getDefaultOptions(),r=this.ctx,a=0,o=e;a<o.length;a++){var s=o[a];switch(s.type){case"path":r.save(),r.strokeStyle="none"===n.stroke?"transparent":n.stroke,r.lineWidth=n.strokeWidth,this._drawToContext(r,s),r.restore();break;case"fillPath":r.save(),r.fillStyle=n.fill||"";var h="curve"===t.shape||"polygon"===t.shape?"evenodd":"nonzero";this._drawToContext(r,s,h),r.restore();break;case"fillSketch":this.fillSketch(r,s,n)}}},t.prototype.fillSketch=function(t,e,n){var r=n.fillWeight;r<0&&(r=n.strokeWidth/2),t.save(),t.strokeStyle=n.fill||"",t.lineWidth=r,this._drawToContext(t,e),t.restore()},t.prototype._drawToContext=function(t,e,n){void 0===n&&(n="nonzero"),t.beginPath();for(var r=0,a=e.ops;r<a.length;r++){var o=a[r],s=o.data;switch(o.op){case"move":t.moveTo(s[0],s[1]);break;case"bcurveTo":t.bezierCurveTo(s[0],s[1],s[2],s[3],s[4],s[5]);break;case"lineTo":t.lineTo(s[0],s[1])}}"fillPath"===e.type?t.fill(n):t.stroke()},Object.defineProperty(t.prototype,"generator",{get:function(){return this.gen},enumerable:!0,configurable:!0}),t.prototype.getDefaultOptions=function(){return this.gen.defaultOptions},t.prototype.line=function(t,e,n,r,a){var o=this.gen.line(t,e,n,r,a);return this.draw(o),o},t.prototype.rectangle=function(t,e,n,r,a){var o=this.gen.rectangle(t,e,n,r,a);return this.draw(o),o},t.prototype.ellipse=function(t,e,n,r,a){var o=this.gen.ellipse(t,e,n,r,a);return this.draw(o),o},t.prototype.circle=function(t,e,n,r){var a=this.gen.circle(t,e,n,r);return this.draw(a),a},t.prototype.linearPath=function(t,e){var n=this.gen.linearPath(t,e);return this.draw(n),n},t.prototype.polygon=function(t,e){var n=this.gen.polygon(t,e);return this.draw(n),n},t.prototype.arc=function(t,e,n,r,a,o,s,h){void 0===s&&(s=!1);var i=this.gen.arc(t,e,n,r,a,o,s,h);return this.draw(i),i},t.prototype.curve=function(t,e){var n=this.gen.curve(t,e);return this.draw(n),n},t.prototype.path=function(t,e){var n=this.gen.path(t,e);return this.draw(n),n},t}(),U="http://www.w3.org/2000/svg",X=function(){function t(t,e){this.svg=t,this.gen=new J(e)}return t.prototype.draw=function(t){for(var e=t.sets||[],n=t.options||this.getDefaultOptions(),r=this.svg.ownerDocument||window.document,a=r.createElementNS(U,"g"),o=0,s=e;o<s.length;o++){var h=s[o],i=null;switch(h.type){case"path":(i=r.createElementNS(U,"path")).setAttribute("d",this.opsToPath(h)),i.style.stroke=n.stroke,i.style.strokeWidth=n.strokeWidth+"",i.style.fill="none";break;case"fillPath":(i=r.createElementNS(U,"path")).setAttribute("d",this.opsToPath(h)),i.style.stroke="none",i.style.strokeWidth="0",i.style.fill=n.fill||"";break;case"fillSketch":i=this.fillSketch(r,h,n)}i&&a.appendChild(i)}return a},t.prototype.fillSketch=function(t,e,n){var r=n.fillWeight;r<0&&(r=n.strokeWidth/2);var a=t.createElementNS(U,"path");return a.setAttribute("d",this.opsToPath(e)),a.style.stroke=n.fill||"",a.style.strokeWidth=r+"",a.style.fill="none",a},Object.defineProperty(t.prototype,"generator",{get:function(){return this.gen},enumerable:!0,configurable:!0}),t.prototype.getDefaultOptions=function(){return this.gen.defaultOptions},t.prototype.opsToPath=function(t){return this.gen.opsToPath(t)},t.prototype.line=function(t,e,n,r,a){var o=this.gen.line(t,e,n,r,a);return this.draw(o)},t.prototype.rectangle=function(t,e,n,r,a){var o=this.gen.rectangle(t,e,n,r,a);return this.draw(o)},t.prototype.ellipse=function(t,e,n,r,a){var o=this.gen.ellipse(t,e,n,r,a);return this.draw(o)},t.prototype.circle=function(t,e,n,r){var a=this.gen.circle(t,e,n,r);return this.draw(a)},t.prototype.linearPath=function(t,e){var n=this.gen.linearPath(t,e);return this.draw(n)},t.prototype.polygon=function(t,e){var n=this.gen.polygon(t,e);return this.draw(n)},t.prototype.arc=function(t,e,n,r,a,o,s,h){void 0===s&&(s=!1);var i=this.gen.arc(t,e,n,r,a,o,s,h);return this.draw(i)},t.prototype.curve=function(t,e){var n=this.gen.curve(t,e);return this.draw(n)},t.prototype.path=function(t,e){var n=this.gen.path(t,e);return this.draw(n)},t}(),Y={canvas:function(t,e){return new K(t,e)},svg:function(t,e){return new X(t,e)},generator:function(t){return new J(t)},newSeed:function(){return J.newSeed()}};module.exports=Y;

},{}],12:[function(require,module,exports){
/*
 * A fast javascript implementation of simplex noise by Jonas Wagner

Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.
Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).
With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
Better rank ordering method by Stefan Gustavson in 2012.


 Copyright (c) 2018 Jonas Wagner

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */
(function() {
  'use strict';

  var F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
  var G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
  var F3 = 1.0 / 3.0;
  var G3 = 1.0 / 6.0;
  var F4 = (Math.sqrt(5.0) - 1.0) / 4.0;
  var G4 = (5.0 - Math.sqrt(5.0)) / 20.0;

  function SimplexNoise(randomOrSeed) {
    var random;
    if (typeof randomOrSeed == 'function') {
      random = randomOrSeed;
    }
    else if (randomOrSeed) {
      random = alea(randomOrSeed);
    } else {
      random = Math.random;
    }
    this.p = buildPermutationTable(random);
    this.perm = new Uint8Array(512);
    this.permMod12 = new Uint8Array(512);
    for (var i = 0; i < 512; i++) {
      this.perm[i] = this.p[i & 255];
      this.permMod12[i] = this.perm[i] % 12;
    }

  }
  SimplexNoise.prototype = {
    grad3: new Float32Array([1, 1, 0,
      -1, 1, 0,
      1, -1, 0,

      -1, -1, 0,
      1, 0, 1,
      -1, 0, 1,

      1, 0, -1,
      -1, 0, -1,
      0, 1, 1,

      0, -1, 1,
      0, 1, -1,
      0, -1, -1]),
    grad4: new Float32Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1,
      0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1,
      1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1,
      -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1,
      1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1,
      -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1,
      1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0,
      -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]),
    noise2D: function(xin, yin) {
      var permMod12 = this.permMod12;
      var perm = this.perm;
      var grad3 = this.grad3;
      var n0 = 0; // Noise contributions from the three corners
      var n1 = 0;
      var n2 = 0;
      // Skew the input space to determine which simplex cell we're in
      var s = (xin + yin) * F2; // Hairy factor for 2D
      var i = Math.floor(xin + s);
      var j = Math.floor(yin + s);
      var t = (i + j) * G2;
      var X0 = i - t; // Unskew the cell origin back to (x,y) space
      var Y0 = j - t;
      var x0 = xin - X0; // The x,y distances from the cell origin
      var y0 = yin - Y0;
      // For the 2D case, the simplex shape is an equilateral triangle.
      // Determine which simplex we are in.
      var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
      if (x0 > y0) {
        i1 = 1;
        j1 = 0;
      } // lower triangle, XY order: (0,0)->(1,0)->(1,1)
      else {
        i1 = 0;
        j1 = 1;
      } // upper triangle, YX order: (0,0)->(0,1)->(1,1)
      // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
      // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
      // c = (3-sqrt(3))/6
      var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
      var y1 = y0 - j1 + G2;
      var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
      var y2 = y0 - 1.0 + 2.0 * G2;
      // Work out the hashed gradient indices of the three simplex corners
      var ii = i & 255;
      var jj = j & 255;
      // Calculate the contribution from the three corners
      var t0 = 0.5 - x0 * x0 - y0 * y0;
      if (t0 >= 0) {
        var gi0 = permMod12[ii + perm[jj]] * 3;
        t0 *= t0;
        n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0); // (x,y) of grad3 used for 2D gradient
      }
      var t1 = 0.5 - x1 * x1 - y1 * y1;
      if (t1 >= 0) {
        var gi1 = permMod12[ii + i1 + perm[jj + j1]] * 3;
        t1 *= t1;
        n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1);
      }
      var t2 = 0.5 - x2 * x2 - y2 * y2;
      if (t2 >= 0) {
        var gi2 = permMod12[ii + 1 + perm[jj + 1]] * 3;
        t2 *= t2;
        n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2);
      }
      // Add contributions from each corner to get the final noise value.
      // The result is scaled to return values in the interval [-1,1].
      return 70.0 * (n0 + n1 + n2);
    },
    // 3D simplex noise
    noise3D: function(xin, yin, zin) {
      var permMod12 = this.permMod12;
      var perm = this.perm;
      var grad3 = this.grad3;
      var n0, n1, n2, n3; // Noise contributions from the four corners
      // Skew the input space to determine which simplex cell we're in
      var s = (xin + yin + zin) * F3; // Very nice and simple skew factor for 3D
      var i = Math.floor(xin + s);
      var j = Math.floor(yin + s);
      var k = Math.floor(zin + s);
      var t = (i + j + k) * G3;
      var X0 = i - t; // Unskew the cell origin back to (x,y,z) space
      var Y0 = j - t;
      var Z0 = k - t;
      var x0 = xin - X0; // The x,y,z distances from the cell origin
      var y0 = yin - Y0;
      var z0 = zin - Z0;
      // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
      // Determine which simplex we are in.
      var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
      var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
      if (x0 >= y0) {
        if (y0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i2 = 1;
          j2 = 1;
          k2 = 0;
        } // X Y Z order
        else if (x0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i2 = 1;
          j2 = 0;
          k2 = 1;
        } // X Z Y order
        else {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i2 = 1;
          j2 = 0;
          k2 = 1;
        } // Z X Y order
      }
      else { // x0<y0
        if (y0 < z0) {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i2 = 0;
          j2 = 1;
          k2 = 1;
        } // Z Y X order
        else if (x0 < z0) {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i2 = 0;
          j2 = 1;
          k2 = 1;
        } // Y Z X order
        else {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i2 = 1;
          j2 = 1;
          k2 = 0;
        } // Y X Z order
      }
      // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
      // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
      // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
      // c = 1/6.
      var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
      var y1 = y0 - j1 + G3;
      var z1 = z0 - k1 + G3;
      var x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords
      var y2 = y0 - j2 + 2.0 * G3;
      var z2 = z0 - k2 + 2.0 * G3;
      var x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords
      var y3 = y0 - 1.0 + 3.0 * G3;
      var z3 = z0 - 1.0 + 3.0 * G3;
      // Work out the hashed gradient indices of the four simplex corners
      var ii = i & 255;
      var jj = j & 255;
      var kk = k & 255;
      // Calculate the contribution from the four corners
      var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
      if (t0 < 0) n0 = 0.0;
      else {
        var gi0 = permMod12[ii + perm[jj + perm[kk]]] * 3;
        t0 *= t0;
        n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0 + grad3[gi0 + 2] * z0);
      }
      var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
      if (t1 < 0) n1 = 0.0;
      else {
        var gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]] * 3;
        t1 *= t1;
        n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1 + grad3[gi1 + 2] * z1);
      }
      var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
      if (t2 < 0) n2 = 0.0;
      else {
        var gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]] * 3;
        t2 *= t2;
        n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2 + grad3[gi2 + 2] * z2);
      }
      var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
      if (t3 < 0) n3 = 0.0;
      else {
        var gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]] * 3;
        t3 *= t3;
        n3 = t3 * t3 * (grad3[gi3] * x3 + grad3[gi3 + 1] * y3 + grad3[gi3 + 2] * z3);
      }
      // Add contributions from each corner to get the final noise value.
      // The result is scaled to stay just inside [-1,1]
      return 32.0 * (n0 + n1 + n2 + n3);
    },
    // 4D simplex noise, better simplex rank ordering method 2012-03-09
    noise4D: function(x, y, z, w) {
      var perm = this.perm;
      var grad4 = this.grad4;

      var n0, n1, n2, n3, n4; // Noise contributions from the five corners
      // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
      var s = (x + y + z + w) * F4; // Factor for 4D skewing
      var i = Math.floor(x + s);
      var j = Math.floor(y + s);
      var k = Math.floor(z + s);
      var l = Math.floor(w + s);
      var t = (i + j + k + l) * G4; // Factor for 4D unskewing
      var X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
      var Y0 = j - t;
      var Z0 = k - t;
      var W0 = l - t;
      var x0 = x - X0; // The x,y,z,w distances from the cell origin
      var y0 = y - Y0;
      var z0 = z - Z0;
      var w0 = w - W0;
      // For the 4D case, the simplex is a 4D shape I won't even try to describe.
      // To find out which of the 24 possible simplices we're in, we need to
      // determine the magnitude ordering of x0, y0, z0 and w0.
      // Six pair-wise comparisons are performed between each possible pair
      // of the four coordinates, and the results are used to rank the numbers.
      var rankx = 0;
      var ranky = 0;
      var rankz = 0;
      var rankw = 0;
      if (x0 > y0) rankx++;
      else ranky++;
      if (x0 > z0) rankx++;
      else rankz++;
      if (x0 > w0) rankx++;
      else rankw++;
      if (y0 > z0) ranky++;
      else rankz++;
      if (y0 > w0) ranky++;
      else rankw++;
      if (z0 > w0) rankz++;
      else rankw++;
      var i1, j1, k1, l1; // The integer offsets for the second simplex corner
      var i2, j2, k2, l2; // The integer offsets for the third simplex corner
      var i3, j3, k3, l3; // The integer offsets for the fourth simplex corner
      // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
      // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
      // impossible. Only the 24 indices which have non-zero entries make any sense.
      // We use a thresholding to set the coordinates in turn from the largest magnitude.
      // Rank 3 denotes the largest coordinate.
      i1 = rankx >= 3 ? 1 : 0;
      j1 = ranky >= 3 ? 1 : 0;
      k1 = rankz >= 3 ? 1 : 0;
      l1 = rankw >= 3 ? 1 : 0;
      // Rank 2 denotes the second largest coordinate.
      i2 = rankx >= 2 ? 1 : 0;
      j2 = ranky >= 2 ? 1 : 0;
      k2 = rankz >= 2 ? 1 : 0;
      l2 = rankw >= 2 ? 1 : 0;
      // Rank 1 denotes the second smallest coordinate.
      i3 = rankx >= 1 ? 1 : 0;
      j3 = ranky >= 1 ? 1 : 0;
      k3 = rankz >= 1 ? 1 : 0;
      l3 = rankw >= 1 ? 1 : 0;
      // The fifth corner has all coordinate offsets = 1, so no need to compute that.
      var x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords
      var y1 = y0 - j1 + G4;
      var z1 = z0 - k1 + G4;
      var w1 = w0 - l1 + G4;
      var x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords
      var y2 = y0 - j2 + 2.0 * G4;
      var z2 = z0 - k2 + 2.0 * G4;
      var w2 = w0 - l2 + 2.0 * G4;
      var x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords
      var y3 = y0 - j3 + 3.0 * G4;
      var z3 = z0 - k3 + 3.0 * G4;
      var w3 = w0 - l3 + 3.0 * G4;
      var x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords
      var y4 = y0 - 1.0 + 4.0 * G4;
      var z4 = z0 - 1.0 + 4.0 * G4;
      var w4 = w0 - 1.0 + 4.0 * G4;
      // Work out the hashed gradient indices of the five simplex corners
      var ii = i & 255;
      var jj = j & 255;
      var kk = k & 255;
      var ll = l & 255;
      // Calculate the contribution from the five corners
      var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
      if (t0 < 0) n0 = 0.0;
      else {
        var gi0 = (perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32) * 4;
        t0 *= t0;
        n0 = t0 * t0 * (grad4[gi0] * x0 + grad4[gi0 + 1] * y0 + grad4[gi0 + 2] * z0 + grad4[gi0 + 3] * w0);
      }
      var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
      if (t1 < 0) n1 = 0.0;
      else {
        var gi1 = (perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32) * 4;
        t1 *= t1;
        n1 = t1 * t1 * (grad4[gi1] * x1 + grad4[gi1 + 1] * y1 + grad4[gi1 + 2] * z1 + grad4[gi1 + 3] * w1);
      }
      var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
      if (t2 < 0) n2 = 0.0;
      else {
        var gi2 = (perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32) * 4;
        t2 *= t2;
        n2 = t2 * t2 * (grad4[gi2] * x2 + grad4[gi2 + 1] * y2 + grad4[gi2 + 2] * z2 + grad4[gi2 + 3] * w2);
      }
      var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
      if (t3 < 0) n3 = 0.0;
      else {
        var gi3 = (perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32) * 4;
        t3 *= t3;
        n3 = t3 * t3 * (grad4[gi3] * x3 + grad4[gi3 + 1] * y3 + grad4[gi3 + 2] * z3 + grad4[gi3 + 3] * w3);
      }
      var t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
      if (t4 < 0) n4 = 0.0;
      else {
        var gi4 = (perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32) * 4;
        t4 *= t4;
        n4 = t4 * t4 * (grad4[gi4] * x4 + grad4[gi4 + 1] * y4 + grad4[gi4 + 2] * z4 + grad4[gi4 + 3] * w4);
      }
      // Sum up and scale the result to cover the range [-1,1]
      return 27.0 * (n0 + n1 + n2 + n3 + n4);
    }
  };

  function buildPermutationTable(random) {
    var i;
    var p = new Uint8Array(256);
    for (i = 0; i < 256; i++) {
      p[i] = i;
    }
    for (i = 0; i < 255; i++) {
      var r = i + ~~(random() * (256 - i));
      var aux = p[i];
      p[i] = p[r];
      p[r] = aux;
    }
    return p;
  }
  SimplexNoise._buildPermutationTable = buildPermutationTable;

  function alea() {
    // Johannes BaagÃ¸e <baagoe@baagoe.com>, 2010
    var s0 = 0;
    var s1 = 0;
    var s2 = 0;
    var c = 1;

    var mash = masher();
    s0 = mash(' ');
    s1 = mash(' ');
    s2 = mash(' ');

    for (var i = 0; i < arguments.length; i++) {
      s0 -= mash(arguments[i]);
      if (s0 < 0) {
        s0 += 1;
      }
      s1 -= mash(arguments[i]);
      if (s1 < 0) {
        s1 += 1;
      }
      s2 -= mash(arguments[i]);
      if (s2 < 0) {
        s2 += 1;
      }
    }
    mash = null;
    return function() {
      var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32
      s0 = s1;
      s1 = s2;
      return s2 = t - (c = t | 0);
    };
  }
  function masher() {
    var n = 0xefc8249d;
    return function(data) {
      data = data.toString();
      for (var i = 0; i < data.length; i++) {
        n += data.charCodeAt(i);
        var h = 0.02519603282416938 * n;
        n = h >>> 0;
        h -= n;
        h *= n;
        n = h >>> 0;
        h -= n;
        n += h * 0x100000000; // 2^32
      }
      return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
    };
  }

  // amd
  if (typeof define !== 'undefined' && define.amd) define(function() {return SimplexNoise;});
  // common js
  if (typeof exports !== 'undefined') exports.SimplexNoise = SimplexNoise;
  // browser
  else if (typeof window !== 'undefined') window.SimplexNoise = SimplexNoise;
  // nodejs
  if (typeof module !== 'undefined') {
    module.exports = SimplexNoise;
  }

})();

},{}],13:[function(require,module,exports){
/*
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

(function () { 'use strict';

// to suit your point format, run search/replace for '.x' and '.y';
// for 3D version, see 3d branch (configurability would draw significant performance overhead)

// square distance between 2 points
function getSqDist(p1, p2) {

    var dx = p1.x - p2.x,
        dy = p1.y - p2.y;

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2) {

    var x = p1.x,
        y = p1.y,
        dx = p2.x - x,
        dy = p2.y - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2.x;
            y = p2.y;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p.x - x;
    dy = p.y - y;

    return dx * dx + dy * dy;
}
// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance) {

    var prevPoint = points[0],
        newPoints = [prevPoint],
        point;

    for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified) {
    var maxSqDist = sqTolerance,
        index;

    for (var i = first + 1; i < last; i++) {
        var sqDist = getSqSegDist(points[i], points[first], points[last]);

        if (sqDist > maxSqDist) {
            index = i;
            maxSqDist = sqDist;
        }
    }

    if (maxSqDist > sqTolerance) {
        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
        simplified.push(points[index]);
        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
    }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance) {
    var last = points.length - 1;

    var simplified = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
function simplify(points, tolerance, highestQuality) {

    if (points.length <= 2) return points;

    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}

// export as AMD module / Node module / browser or worker variable
if (typeof define === 'function' && define.amd) define(function() { return simplify; });
else if (typeof module !== 'undefined') {
    module.exports = simplify;
    module.exports.default = simplify;
} else if (typeof self !== 'undefined') self.simplify = simplify;
else window.simplify = simplify;

})();

},{}],14:[function(require,module,exports){
(function (process){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var map_generator_1 = require("./map_generator");
/**
 * Main entry point for the map generator script
 * Uses a fixed input path for the JSON configuration file and generates a map with separate SVG elements
 */


function main() {
  // Use a fixed input path for the configuration file
  var configPath = 'C:\\APP\\CODE\\MapGenerator\\src\\testinput\\input.json';
  console.log("Using configuration file: " + configPath);

  try {
    // Create and run the map generator
    var mapGenerator = new map_generator_1.MapGenerator(configPath);
    mapGenerator.generate()["catch"](function (err) {
      console.error("Error generating map:", err);
      process.exit(1);
    });
  } catch (err) {
    console.error("Error initializing map generator:", err);
    process.exit(1);
  }
}

exports.main = main; // Call the main function when the script is executed

main();

}).call(this,require('_process'))

},{"./map_generator":15,"_process":10}],15:[function(require,module,exports){
(function (process){
"use strict";

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

var __values = void 0 && (void 0).__values || function (o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var fs = require("fs");

var path = require("path");

var tensor_field_gui_1 = require("./ts/ui/tensor_field_gui");

var main_gui_1 = require("./ts/ui/main_gui");

var domain_controller_1 = require("./ts/ui/domain_controller");

var drag_controller_1 = require("./ts/ui/drag_controller");

var style_1 = require("./ts/ui/style");

var svg_js_1 = require("@svgdotjs/svg.js");
/**
 * Map Generator class that generates a map from a JSON configuration file
 * and exports separate SVG files for different map elements with unique IDs
 */


var MapGenerator =
/** @class */
function () {
  function MapGenerator(configPath) {
    var e_1, _a;

    var _b, _c, _d, _e, _f, _g, _h, _j;

    this.domainController = domain_controller_1["default"].getInstance();
    this.dragController = new drag_controller_1["default"](null); // No GUI
    // Read and parse the configuration file

    var configData = fs.readFileSync(configPath, 'utf8');
    this.config = JSON.parse(configData); // Set up the domain controller

    if (this.config.zoom && this.config.zoom.zoom) {
      this.domainController.zoom = this.config.zoom.zoom;
    } // Create a canvas element


    this.canvas = document.createElement('canvas');
    this.canvas.width = 1440;
    this.canvas.height = 900; // Set up the tensor field

    var noiseParamsPlaceholder = {
      globalNoise: false,
      noiseSizePark: 20,
      noiseAnglePark: 90,
      noiseSizeGlobal: 30,
      noiseAngleGlobal: 20
    };
    this.tensorField = new tensor_field_gui_1["default"](null, this.dragController, ((_b = this.config.options) === null || _b === void 0 ? void 0 : _b.drawCenter) || false, noiseParamsPlaceholder); // Configure tensor field based on config

    if (this.config.tensorField) {
      this.tensorField.smooth = this.config.tensorField.smooth || false; // Add grids and radials if specified

      if (this.config.tensorField.grids && this.config.tensorField.grids.length > 0) {
        try {
          for (var _k = __values(this.config.tensorField.grids), _l = _k.next(); !_l.done; _l = _k.next()) {
            var grid = _l.value; // Add grid with parameters from config
            // This would need to be implemented based on the actual grid parameters
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (_l && !_l.done && (_a = _k["return"])) _a.call(_k);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      } else {
        // Use recommended setup if no grids specified
        this.tensorField.setRecommended();
      }
    } else {
      // Use recommended setup if no tensor field config
      this.tensorField.setRecommended();
    } // Set up the main GUI


    this.mainGui = new main_gui_1["default"](null, this.tensorField, function () {}); // Configure map parameters based on config

    if (this.config.map) {
      // Set animation parameters
      this.mainGui.animate = this.config.map.animate !== undefined ? this.config.map.animate : true;
      this.mainGui.animationSpeed = this.config.map.animateSpeed || 30; // Configure water parameters

      if (this.config.map.water) {
        var waterParams = this.mainGui.coastline.params;

        if (this.config.map.water.simplifyTolerance !== undefined) {
          waterParams.simplifyTolerance = this.config.map.water.simplifyTolerance;
        }

        if (this.config.map.water.coastline) {
          waterParams.coastNoise.noiseEnabled = this.config.map.water.coastline.noiseEnabled !== undefined ? this.config.map.water.coastline.noiseEnabled : true;
          waterParams.coastNoise.noiseSize = this.config.map.water.coastline.noiseSize || 30;
          waterParams.coastNoise.noiseAngle = this.config.map.water.coastline.noiseAngle || 20;
        }

        if (this.config.map.water.river) {
          waterParams.riverNoise.noiseEnabled = this.config.map.water.river.noiseEnabled !== undefined ? this.config.map.water.river.noiseEnabled : true;
          waterParams.riverNoise.noiseSize = this.config.map.water.river.noiseSize || 30;
          waterParams.riverNoise.noiseAngle = this.config.map.water.river.noiseAngle || 20;
        }

        if (this.config.map.water.devParams) {
          if (this.config.map.water.devParams.dsep !== undefined) waterParams.dsep = this.config.map.water.devParams.dsep;
          if (this.config.map.water.devParams.dtest !== undefined) waterParams.dtest = this.config.map.water.devParams.dtest;
          if (this.config.map.water.devParams.pathIterations !== undefined) waterParams.pathIterations = this.config.map.water.devParams.pathIterations;
          if (this.config.map.water.devParams.seedTries !== undefined) waterParams.seedTries = this.config.map.water.devParams.seedTries;
          if (this.config.map.water.devParams.dstep !== undefined) waterParams.dstep = this.config.map.water.devParams.dstep;
          if (this.config.map.water.devParams.dlookahead !== undefined) waterParams.dlookahead = this.config.map.water.devParams.dlookahead;
          if (this.config.map.water.devParams.dcirclejoin !== undefined) waterParams.dcirclejoin = this.config.map.water.devParams.dcirclejoin;
          if (this.config.map.water.devParams.joinangle !== undefined) waterParams.joinangle = this.config.map.water.devParams.joinangle;
        }
      } // Configure road parameters


      if (this.config.map.main) {
        var mainParams = this.mainGui.mainRoads.params;
        if (this.config.map.main.dsep !== undefined) mainParams.dsep = this.config.map.main.dsep;
        if (this.config.map.main.dtest !== undefined) mainParams.dtest = this.config.map.main.dtest;

        if (this.config.map.main.devParams) {
          if (this.config.map.main.devParams.pathIterations !== undefined) mainParams.pathIterations = this.config.map.main.devParams.pathIterations;
          if (this.config.map.main.devParams.seedTries !== undefined) mainParams.seedTries = this.config.map.main.devParams.seedTries;
          if (this.config.map.main.devParams.dstep !== undefined) mainParams.dstep = this.config.map.main.devParams.dstep;
          if (this.config.map.main.devParams.dlookahead !== undefined) mainParams.dlookahead = this.config.map.main.devParams.dlookahead;
          if (this.config.map.main.devParams.dcirclejoin !== undefined) mainParams.dcirclejoin = this.config.map.main.devParams.dcirclejoin;
          if (this.config.map.main.devParams.joinangle !== undefined) mainParams.joinangle = this.config.map.main.devParams.joinangle;
          if (this.config.map.main.devParams.simplifyTolerance !== undefined) mainParams.simplifyTolerance = this.config.map.main.devParams.simplifyTolerance;
          if (this.config.map.main.devParams.collideEarly !== undefined) mainParams.collideEarly = this.config.map.main.devParams.collideEarly;
        }
      } // Configure major road parameters


      if (this.config.map.major) {
        var majorParams = this.mainGui.majorRoads.params;
        if (this.config.map.major.dsep !== undefined) majorParams.dsep = this.config.map.major.dsep;
        if (this.config.map.major.dtest !== undefined) majorParams.dtest = this.config.map.major.dtest;

        if (this.config.map.major.devParams) {
          if (this.config.map.major.devParams.pathIterations !== undefined) majorParams.pathIterations = this.config.map.major.devParams.pathIterations;
          if (this.config.map.major.devParams.seedTries !== undefined) majorParams.seedTries = this.config.map.major.devParams.seedTries;
          if (this.config.map.major.devParams.dstep !== undefined) majorParams.dstep = this.config.map.major.devParams.dstep;
          if (this.config.map.major.devParams.dlookahead !== undefined) majorParams.dlookahead = this.config.map.major.devParams.dlookahead;
          if (this.config.map.major.devParams.dcirclejoin !== undefined) majorParams.dcirclejoin = this.config.map.major.devParams.dcirclejoin;
          if (this.config.map.major.devParams.joinangle !== undefined) majorParams.joinangle = this.config.map.major.devParams.joinangle;
          if (this.config.map.major.devParams.simplifyTolerance !== undefined) majorParams.simplifyTolerance = this.config.map.major.devParams.simplifyTolerance;
          if (this.config.map.major.devParams.collideEarly !== undefined) majorParams.collideEarly = this.config.map.major.devParams.collideEarly;
        }
      } // Configure minor road parameters


      if (this.config.map.minor) {
        var minorParams = this.mainGui.minorRoads.params;
        if (this.config.map.minor.dsep !== undefined) minorParams.dsep = this.config.map.minor.dsep;
        if (this.config.map.minor.dtest !== undefined) minorParams.dtest = this.config.map.minor.dtest;

        if (this.config.map.minor.devParams) {
          if (this.config.map.minor.devParams.pathIterations !== undefined) minorParams.pathIterations = this.config.map.minor.devParams.pathIterations;
          if (this.config.map.minor.devParams.seedTries !== undefined) minorParams.seedTries = this.config.map.minor.devParams.seedTries;
          if (this.config.map.minor.devParams.dstep !== undefined) minorParams.dstep = this.config.map.minor.devParams.dstep;
          if (this.config.map.minor.devParams.dlookahead !== undefined) minorParams.dlookahead = this.config.map.minor.devParams.dlookahead;
          if (this.config.map.minor.devParams.dcirclejoin !== undefined) minorParams.dcirclejoin = this.config.map.minor.devParams.dcirclejoin;
          if (this.config.map.minor.devParams.joinangle !== undefined) minorParams.joinangle = this.config.map.minor.devParams.joinangle;
          if (this.config.map.minor.devParams.simplifyTolerance !== undefined) minorParams.simplifyTolerance = this.config.map.minor.devParams.simplifyTolerance;
          if (this.config.map.minor.devParams.collideEarly !== undefined) minorParams.collideEarly = this.config.map.minor.devParams.collideEarly;
        }
      } // Configure park parameters


      if (this.config.map.parks) {
        this.mainGui.clusterBigParks = this.config.map.parks.clusterBigParks !== undefined ? this.config.map.parks.clusterBigParks : false;
        this.mainGui.numBigParks = this.config.map.parks.numBigParks || 2;
        this.mainGui.numSmallParks = this.config.map.parks.numSmallParks || 0;
      } // Configure building parameters


      if (this.config.map.buildings) {
        var buildingParams = this.mainGui.buildings.params;
        if (this.config.map.buildings.minArea !== undefined) buildingParams.minArea = this.config.map.buildings.minArea;
        if (this.config.map.buildings.shrinkSpacing !== undefined) buildingParams.shrinkSpacing = this.config.map.buildings.shrinkSpacing;
        if (this.config.map.buildings.chanceNoDivide !== undefined) buildingParams.chanceNoDivide = this.config.map.buildings.chanceNoDivide;
      }
    } // Set up the style
    // Use default color scheme based on the style.colourScheme value


    var colourSchemeName = ((_c = this.config.style) === null || _c === void 0 ? void 0 : _c.colourScheme) || "default"; // Create a proper ColourScheme object

    var colourScheme = {
      bgColour: "#ffffff",
      seaColour: "#77aaff",
      minorRoadColour: "#ffffff",
      zoomBuildings: ((_d = this.config.style) === null || _d === void 0 ? void 0 : _d.zoomBuildings) || false,
      buildingModels: ((_e = this.config.style) === null || _e === void 0 ? void 0 : _e.buildingModels) || false,
      showFrame: ((_f = this.config.style) === null || _f === void 0 ? void 0 : _f.showFrame) || false
    }; // Set camera properties on the domain controller

    if (((_g = this.config.style) === null || _g === void 0 ? void 0 : _g.cameraX) !== undefined) {
      this.domainController.cameraX = this.config.style.cameraX;
    }

    if (((_h = this.config.style) === null || _h === void 0 ? void 0 : _h.cameraY) !== undefined) {
      this.domainController.cameraY = this.config.style.cameraY;
    }

    if (((_j = this.config.style) === null || _j === void 0 ? void 0 : _j.orthographic) !== undefined) {
      this.domainController.orthographic = this.config.style.orthographic;
    }

    this.style = new style_1.DefaultStyle(this.canvas, this.dragController, colourScheme, false); // Set high DPI if specified

    if (this.config.options && this.config.options.highDPI) {
      this.style.canvasScale = 2;
    }
  }
  /**
   * Generate the map and export separate SVG files for different map elements
   * Each element will have a unique ID and be exported as a separate SVG element
   * @param customOutputDir Optional custom output directory path
   */


  MapGenerator.prototype.generate = function (customOutputDir) {
    var _a;

    return __awaiter(this, void 0, void 0, function () {
      var outputDir, err_1;
      return __generator(this, function (_b) {
        switch (_b.label) {
          case 0:
            console.log("Generating map...");
            _b.label = 1;

          case 1:
            _b.trys.push([1, 4,, 5]); // Generate the map


            return [4
            /*yield*/
            , this.mainGui.generateEverything()];

          case 2:
            // Generate the map
            _b.sent();

            outputDir = void 0;

            if (customOutputDir) {
              outputDir = customOutputDir;
            } else if ((_a = this.config.output) === null || _a === void 0 ? void 0 : _a.directory) {
              outputDir = this.config.output.directory;
            } else {
              // Default output directory
              outputDir = path.join(process.cwd(), 'output');
            } // Create output directory if it doesn't exist


            try {
              if (!fs.existsSync(outputDir)) {
                fs.mkdirSync(outputDir, {
                  recursive: true
                });
              }
            } catch (err) {
              console.error("Error creating output directory " + outputDir + ":", err); // Fallback to current directory

              outputDir = process.cwd();
              console.log("Falling back to current directory: " + outputDir);
            } // Export SVG files with separate elements


            return [4
            /*yield*/
            , Promise.all([this.exportCoastline(outputDir), this.exportRiver(outputDir), this.exportRoads(outputDir), this.exportParks(outputDir), this.exportBuildings(outputDir)])];

          case 3:
            // Export SVG files with separate elements
            _b.sent();

            console.log("Map generation complete. SVG files exported to:", outputDir);
            return [3
            /*break*/
            , 5];

          case 4:
            err_1 = _b.sent();
            console.error("Error during map generation:", err_1);
            throw err_1;

          case 5:
            return [2
            /*return*/
            ];
        }
      });
    });
  };
  /**
   * Export coastline as an SVG file with unique ID and styling
   * @param outputDir The directory to export the SVG file to
   */


  MapGenerator.prototype.exportCoastline = function (outputDir) {
    return __awaiter(this, void 0, void 0, function () {
      var coastline, svgElement, svgDoc, serializer, source, filePath;
      return __generator(this, function (_a) {
        coastline = this.mainGui.coastlinePolygon;
        if (!coastline || coastline.length === 0) return [2
        /*return*/
        ];

        try {
          svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
          svgElement.setAttribute("width", "1440");
          svgElement.setAttribute("height", "900");
          svgElement.setAttribute("viewBox", "0 0 1440 900");
          svgElement.setAttribute("version", "1.1");
          svgDoc = svg_js_1.SVG(svgElement); // Draw coastline with unique ID and styling

          this.drawPolygonToSVG(svgDoc, coastline, "coastline", "#77aaff", // Fill color (sea blue)
          "#ffffff", // Stroke color (white)
          2 // Stroke width
          );
          serializer = new XMLSerializer();
          source = serializer.serializeToString(svgElement); // Add XML declaration

          source = '<?xml version="1.0" standalone="no"?>\r\n' + source;
          filePath = path.join(outputDir, "coastline.svg");
          fs.writeFileSync(filePath, source);
          console.log("Exported coastline.svg");
        } catch (err) {
          console.error("Error exporting coastline.svg:", err);
        }

        return [2
        /*return*/
        ];
      });
    });
  };
  /**
   * Export river as an SVG file with unique ID and styling
   * @param outputDir The directory to export the SVG file to
   */


  MapGenerator.prototype.exportRiver = function (outputDir) {
    return __awaiter(this, void 0, void 0, function () {
      var river, svgElement, svgDoc, serializer, source, filePath;
      return __generator(this, function (_a) {
        river = this.mainGui.riverPolygon;
        if (!river || river.length === 0) return [2
        /*return*/
        ];

        try {
          svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
          svgElement.setAttribute("width", "1440");
          svgElement.setAttribute("height", "900");
          svgElement.setAttribute("viewBox", "0 0 1440 900");
          svgElement.setAttribute("version", "1.1");
          svgDoc = svg_js_1.SVG(svgElement); // Draw river with unique ID and styling

          this.drawPolygonToSVG(svgDoc, river, "river", "#77aaff", // Fill color (river blue)
          "#5588dd", // Stroke color (darker blue)
          1 // Stroke width
          );
          serializer = new XMLSerializer();
          source = serializer.serializeToString(svgElement); // Add XML declaration

          source = '<?xml version="1.0" standalone="no"?>\r\n' + source;
          filePath = path.join(outputDir, "river.svg");
          fs.writeFileSync(filePath, source);
          console.log("Exported river.svg");
        } catch (err) {
          console.error("Error exporting river.svg:", err);
        }

        return [2
        /*return*/
        ];
      });
    });
  };
  /**
   * Export roads as SVG files with unique IDs for each road
   */


  MapGenerator.prototype.exportRoads = function (outputDir) {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            // Export main roads
            return [4
            /*yield*/
            , this.exportRoadType(this.mainGui.mainRoadPolygons, "main_roads", outputDir)];

          case 1:
            // Export main roads
            _a.sent(); // Export major roads


            return [4
            /*yield*/
            , this.exportRoadType(this.mainGui.majorRoadPolygons, "major_roads", outputDir)];

          case 2:
            // Export major roads
            _a.sent(); // Export minor roads


            return [4
            /*yield*/
            , this.exportRoadType(this.mainGui.minorRoadPolygons, "minor_roads", outputDir)];

          case 3:
            // Export minor roads
            _a.sent();

            return [2
            /*return*/
            ];
        }
      });
    });
  };
  /**
   * Export a specific type of road as an SVG file with unique IDs and styling for each road
   * @param roads The road polygons to export
   * @param typeName The type of road (main_roads, major_roads, minor_roads)
   * @param outputDir The directory to export the SVG file to
   */


  MapGenerator.prototype.exportRoadType = function (roads, typeName, outputDir) {
    return __awaiter(this, void 0, void 0, function () {
      var svgElement, svgDoc, strokeColor, strokeWidth, i, serializer, source, filePath;
      return __generator(this, function (_a) {
        if (!roads || roads.length === 0) return [2
        /*return*/
        ];

        try {
          svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
          svgElement.setAttribute("width", "1440");
          svgElement.setAttribute("height", "900");
          svgElement.setAttribute("viewBox", "0 0 1440 900");
          svgElement.setAttribute("version", "1.1");
          svgDoc = svg_js_1.SVG(svgElement);
          strokeColor = '#ffffff';
          strokeWidth = 1;

          if (typeName === 'main_roads') {
            strokeColor = '#ffffff';
            strokeWidth = 3;
          } else if (typeName === 'major_roads') {
            strokeColor = '#ffffff';
            strokeWidth = 2;
          } else {
            strokeColor = '#eeeeee';
            strokeWidth = 1;
          } // Draw each road with a unique ID and styling


          for (i = 0; i < roads.length; i++) {
            this.drawPolygonToSVG(svgDoc, roads[i], typeName + "_" + i, 'none', // No fill for roads
            strokeColor, // Stroke color based on road type
            strokeWidth // Stroke width based on road type
            );
          }

          serializer = new XMLSerializer();
          source = serializer.serializeToString(svgElement); // Add XML declaration

          source = '<?xml version="1.0" standalone="no"?>\r\n' + source;
          filePath = path.join(outputDir, typeName + ".svg");
          fs.writeFileSync(filePath, source);
          console.log("Exported " + typeName + ".svg with " + roads.length + " roads");
        } catch (err) {
          console.error("Error exporting " + typeName + ".svg:", err);
        }

        return [2
        /*return*/
        ];
      });
    });
  };
  /**
   * Export parks as an SVG file with unique IDs and styling for each park
   * @param outputDir The directory to export the SVG file to
   */


  MapGenerator.prototype.exportParks = function (outputDir) {
    return __awaiter(this, void 0, void 0, function () {
      var parks, svgElement, svgDoc, i, serializer, source, filePath;
      return __generator(this, function (_a) {
        parks = this.style.parks;
        if (!parks || parks.length === 0) return [2
        /*return*/
        ];

        try {
          svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
          svgElement.setAttribute("width", "1440");
          svgElement.setAttribute("height", "900");
          svgElement.setAttribute("viewBox", "0 0 1440 900");
          svgElement.setAttribute("version", "1.1");
          svgDoc = svg_js_1.SVG(svgElement); // Draw each park with a unique ID and styling

          for (i = 0; i < parks.length; i++) {
            this.drawPolygonToSVG(svgDoc, parks[i], "park_" + i, '#88cc88', // Fill color (park green)
            '#66aa66', // Stroke color (darker green)
            1 // Stroke width
            );
          }

          serializer = new XMLSerializer();
          source = serializer.serializeToString(svgElement); // Add XML declaration

          source = '<?xml version="1.0" standalone="no"?>\r\n' + source;
          filePath = path.join(outputDir, "parks.svg");
          fs.writeFileSync(filePath, source);
          console.log("Exported parks.svg with " + parks.length + " parks");
        } catch (err) {
          console.error("Error exporting parks.svg:", err);
        }

        return [2
        /*return*/
        ];
      });
    });
  };
  /**
   * Export buildings as an SVG file with unique IDs and styling for each building
   * @param outputDir The directory to export the SVG file to
   */


  MapGenerator.prototype.exportBuildings = function (outputDir) {
    return __awaiter(this, void 0, void 0, function () {
      var blocks, svgElement, svgDoc, i, hue, saturation, lightness, fillColor, serializer, source, filePath, err_2;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            _a.trys.push([0, 2,, 3]);

            return [4
            /*yield*/
            , this.mainGui.getBlocks()];

          case 1:
            blocks = _a.sent();
            if (!blocks || blocks.length === 0) return [2
            /*return*/
            ];
            svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
            svgElement.setAttribute("width", "1440");
            svgElement.setAttribute("height", "900");
            svgElement.setAttribute("viewBox", "0 0 1440 900");
            svgElement.setAttribute("version", "1.1");
            svgDoc = svg_js_1.SVG(svgElement); // Draw each building with a unique ID and styling

            for (i = 0; i < blocks.length; i++) {
              hue = 30 + Math.floor(Math.random() * 10);
              saturation = 10 + Math.floor(Math.random() * 10);
              lightness = 85 + Math.floor(Math.random() * 10);
              fillColor = "hsl(" + hue + ", " + saturation + "%, " + lightness + "%)";
              this.drawPolygonToSVG(svgDoc, blocks[i], "building_" + i, fillColor, // Fill color (building beige with slight variation)
              '#cccccc', // Stroke color (light gray)
              0.5 // Stroke width
              );
            }

            serializer = new XMLSerializer();
            source = serializer.serializeToString(svgElement); // Add XML declaration

            source = '<?xml version="1.0" standalone="no"?>\r\n' + source;
            filePath = path.join(outputDir, "buildings.svg");
            fs.writeFileSync(filePath, source);
            console.log("Exported buildings.svg with " + blocks.length + " buildings");
            return [3
            /*break*/
            , 3];

          case 2:
            err_2 = _a.sent();
            console.error("Error exporting buildings.svg:", err_2);
            return [3
            /*break*/
            , 3];

          case 3:
            return [2
            /*return*/
            ];
        }
      });
    });
  };
  /**
   * Draw a polygon to an SVG document with a unique ID and styling
   * @param svgDoc The SVG document to draw to
   * @param polygon The polygon to draw
   * @param id The unique ID for the polygon
   * @param fillColor Optional fill color (default: none)
   * @param strokeColor Optional stroke color (default: #000)
   * @param strokeWidth Optional stroke width (default: 1)
   */


  MapGenerator.prototype.drawPolygonToSVG = function (svgDoc, polygon, id, fillColor, strokeColor, strokeWidth) {
    if (fillColor === void 0) {
      fillColor = 'none';
    }

    if (strokeColor === void 0) {
      strokeColor = '#000';
    }

    if (strokeWidth === void 0) {
      strokeWidth = 1;
    }

    if (polygon.length < 2) return; // Create path data with proper formatting

    var pathData = "M " + polygon[0].x.toFixed(2) + " " + polygon[0].y.toFixed(2);

    for (var i = 1; i < polygon.length; i++) {
      pathData += " L " + polygon[i].x.toFixed(2) + " " + polygon[i].y.toFixed(2);
    }

    pathData += " Z"; // Close path
    // Add path to SVG with unique ID and styling

    svgDoc.path(pathData).fill(fillColor).stroke({
      width: strokeWidth,
      color: strokeColor
    }).attr('id', id).attr('data-type', id.split('_')[0]); // Add data-type attribute for easier selection
  };

  return MapGenerator;
}();

exports.MapGenerator = MapGenerator;

}).call(this,require('_process'))

},{"./ts/ui/domain_controller":29,"./ts/ui/drag_controller":30,"./ts/ui/main_gui":31,"./ts/ui/style":33,"./ts/ui/tensor_field_gui":34,"@svgdotjs/svg.js":1,"_process":10,"fs":2,"path":8}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log = require("loglevel");

var Vector =
/** @class */
function () {
  function Vector(x, y) {
    this.x = x;
    this.y = y;
  }

  Vector.zeroVector = function () {
    return new Vector(0, 0);
  };

  Vector.fromScalar = function (s) {
    return new Vector(s, s);
  };
  /**
   * -pi to pi
   */


  Vector.angleBetween = function (v1, v2) {
    // -2pi to 2pi
    var angleBetween = v1.angle() - v2.angle();

    if (angleBetween > Math.PI) {
      angleBetween -= 2 * Math.PI;
    } else if (angleBetween <= -Math.PI) {
      angleBetween += 2 * Math.PI;
    }

    return angleBetween;
  };
  /**
   * Tests whether a point lies to the left of a line
   * @param  {Vector} linePoint     Point on the line
   * @param  {Vector} lineDirection
   * @param  {Vector} point
   * @return {Vector}               true if left, false otherwise
   */


  Vector.isLeft = function (linePoint, lineDirection, point) {
    var perpendicularVector = new Vector(lineDirection.y, -lineDirection.x);
    return point.clone().sub(linePoint).dot(perpendicularVector) < 0;
  };

  Vector.prototype.add = function (v) {
    this.x += v.x;
    this.y += v.y;
    return this;
  };
  /**
   * Angle in radians to positive x-axis between -pi and pi
   */


  Vector.prototype.angle = function () {
    return Math.atan2(this.y, this.x);
  };

  Vector.prototype.clone = function () {
    return new Vector(this.x, this.y);
  };

  Vector.prototype.copy = function (v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  };

  Vector.prototype.cross = function (v) {
    return this.x * v.y - this.y * v.x;
  };

  Vector.prototype.distanceTo = function (v) {
    return Math.sqrt(this.distanceToSquared(v));
  };

  Vector.prototype.distanceToSquared = function (v) {
    var dx = this.x - v.x;
    var dy = this.y - v.y;
    return dx * dx + dy * dy;
  };

  Vector.prototype.divide = function (v) {
    if (v.x === 0 || v.y === 0) {
      log.warn("Division by zero");
      return this;
    }

    this.x /= v.x;
    this.y /= v.y;
    return this;
  };

  Vector.prototype.divideScalar = function (s) {
    if (s === 0) {
      log.warn("Division by zero");
      return this;
    }

    return this.multiplyScalar(1 / s);
  };

  Vector.prototype.dot = function (v) {
    return this.x * v.x + this.y * v.y;
  };

  Vector.prototype.equals = function (v) {
    return v.x === this.x && v.y === this.y;
  };

  Vector.prototype.length = function () {
    return Math.sqrt(this.lengthSq());
  };

  Vector.prototype.lengthSq = function () {
    return this.x * this.x + this.y * this.y;
  };

  Vector.prototype.multiply = function (v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  };

  Vector.prototype.multiplyScalar = function (s) {
    this.x *= s;
    this.y *= s;
    return this;
  };

  Vector.prototype.negate = function () {
    return this.multiplyScalar(-1);
  };

  Vector.prototype.normalize = function () {
    var l = this.length();

    if (l === 0) {
      log.warn("Zero Vector");
      return this;
    }

    return this.divideScalar(this.length());
  };
  /**
   * Angle in radians
   */


  Vector.prototype.rotateAround = function (center, angle) {
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    var x = this.x - center.x;
    var y = this.y - center.y;
    this.x = x * cos - y * sin + center.x;
    this.y = x * sin + y * cos + center.y;
    return this;
  };

  Vector.prototype.set = function (v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  };

  Vector.prototype.setX = function (x) {
    this.x = x;
    return this;
  };

  Vector.prototype.setY = function (y) {
    this.y = y;
    return this;
  };

  Vector.prototype.setLength = function (length) {
    return this.normalize().multiplyScalar(length);
  };

  Vector.prototype.sub = function (v) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
  };

  return Vector;
}();

exports["default"] = Vector;

},{"loglevel":7}],17:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tensor_1 = require("./tensor");

;
/**
 * Grid or Radial field to be combined with others to create the tensor field
 */

var BasisField =
/** @class */
function () {
  function BasisField(centre, _size, _decay) {
    this._size = _size;
    this._decay = _decay;
    this._centre = centre.clone();
  }

  Object.defineProperty(BasisField.prototype, "centre", {
    get: function get() {
      return this._centre.clone();
    },
    set: function set(centre) {
      this._centre.copy(centre);
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(BasisField.prototype, "decay", {
    set: function set(decay) {
      this._decay = decay;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(BasisField.prototype, "size", {
    set: function set(size) {
      this._size = size;
    },
    enumerable: true,
    configurable: true
  });

  BasisField.prototype.dragStartListener = function () {
    this.setFolder();
  };

  BasisField.prototype.dragMoveListener = function (delta) {
    // Delta assumed to be in world space (only relevant when zoomed)
    this._centre.add(delta);
  };

  BasisField.prototype.getWeightedTensor = function (point, smooth) {
    return this.getTensor(point).scale(this.getTensorWeight(point, smooth));
  };

  BasisField.prototype.setFolder = function () {
    if (this.parentFolder.__folders) {
      for (var folderName in this.parentFolder.__folders) {
        this.parentFolder.__folders[folderName].close();
      }

      this.folder.open();
    }
  };

  BasisField.prototype.removeFolderFromParent = function () {
    if (this.parentFolder.__folders && Object.values(this.parentFolder.__folders).indexOf(this.folder) >= 0) {
      this.parentFolder.removeFolder(this.folder);
    }
  };
  /**
   * Creates a folder and adds it to the GUI to control params
   */


  BasisField.prototype.setGui = function (parent, folder) {
    this.parentFolder = parent;
    this.folder = folder;
    folder.add(this._centre, 'x');
    folder.add(this._centre, 'y');
    folder.add(this, '_size');
    folder.add(this, '_decay', -50, 50);
  };
  /**
   * Interpolates between (0 and 1)^decay
   */


  BasisField.prototype.getTensorWeight = function (point, smooth) {
    var normDistanceToCentre = point.clone().sub(this._centre).length() / this._size;

    if (smooth) {
      return Math.pow(normDistanceToCentre, -this._decay);
    } // Stop (** 0) turning weight into 1, filling screen even when outside 'size'


    if (this._decay === 0 && normDistanceToCentre >= 1) {
      return 0;
    }

    return Math.pow(Math.max(0, 1 - normDistanceToCentre), this._decay);
  };

  BasisField.folderNameIndex = 0;
  return BasisField;
}();

exports.BasisField = BasisField;

var Grid =
/** @class */
function (_super) {
  __extends(Grid, _super);

  function Grid(centre, size, decay, _theta) {
    var _this = _super.call(this, centre, size, decay) || this;

    _this._theta = _theta;
    _this.FOLDER_NAME = "Grid " + Grid.folderNameIndex++;
    _this.FIELD_TYPE = 1
    /* Grid */
    ;
    return _this;
  }

  Object.defineProperty(Grid.prototype, "theta", {
    set: function set(theta) {
      this._theta = theta;
    },
    enumerable: true,
    configurable: true
  });

  Grid.prototype.setGui = function (parent, folder) {
    var _this = this;

    _super.prototype.setGui.call(this, parent, folder); // GUI in degrees, convert to rads


    var thetaProp = {
      theta: this._theta * 180 / Math.PI
    };
    var thetaController = folder.add(thetaProp, 'theta', -90, 90);
    thetaController.onChange(function (theta) {
      return _this._theta = theta * (Math.PI / 180);
    });
  };

  Grid.prototype.getTensor = function (point) {
    var cos = Math.cos(2 * this._theta);
    var sin = Math.sin(2 * this._theta);
    return new tensor_1["default"](1, [cos, sin]);
  };

  return Grid;
}(BasisField);

exports.Grid = Grid;

var Radial =
/** @class */
function (_super) {
  __extends(Radial, _super);

  function Radial(centre, size, decay) {
    var _this = _super.call(this, centre, size, decay) || this;

    _this.FOLDER_NAME = "Radial " + Radial.folderNameIndex++;
    _this.FIELD_TYPE = 0
    /* Radial */
    ;
    return _this;
  }

  Radial.prototype.getTensor = function (point) {
    var t = point.clone().sub(this._centre);
    var t1 = Math.pow(t.y, 2) - Math.pow(t.x, 2);
    var t2 = -2 * t.x * t.y;
    return new tensor_1["default"](1, [t1, t2]);
  };

  return Radial;
}(BasisField);

exports.Radial = Radial;

},{"./tensor":24}],18:[function(require,module,exports){
"use strict";

var __values = void 0 && (void 0).__values || function (o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

var __read = void 0 && (void 0).__read || function (o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
};

var __spread = void 0 && (void 0).__spread || function () {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read(arguments[i]));
  }

  return ar;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log = require("loglevel");

var isect = require("isect");

var d3 = require("d3-quadtree");

var vector_1 = require("../vector");
/**
 * Node located along any intersection or point along the simplified road polylines
 */


var Node =
/** @class */
function () {
  function Node(value, neighbors) {
    if (neighbors === void 0) {
      neighbors = new Set();
    }

    this.value = value;
    this.neighbors = neighbors;
    this.segments = new Set();
  }

  Node.prototype.addSegment = function (segment) {
    this.segments.add(segment);
  };

  Node.prototype.addNeighbor = function (node) {
    if (node !== this) {
      this.neighbors.add(node);
      node.neighbors.add(this);
    }
  };

  return Node;
}();

exports.Node = Node;

var Graph =
/** @class */
function () {
  /**
   * Create a graph from a set of streamlines
   * Finds all intersections, and creates a list of Nodes
   */
  function Graph(streamlines, dstep, deleteDangling) {
    var e_1, _a, e_2, _b, e_3, _c, e_4, _d, e_5, _e, e_6, _f;

    if (deleteDangling === void 0) {
      deleteDangling = false;
    }

    var intersections = isect.bush(this.streamlinesToSegment(streamlines)).run();
    var quadtree = d3.quadtree().x(function (n) {
      return n.value.x;
    }).y(function (n) {
      return n.value.y;
    });
    var nodeAddRadius = 0.001;

    try {
      // Add all segment start and endpoints
      for (var streamlines_1 = __values(streamlines), streamlines_1_1 = streamlines_1.next(); !streamlines_1_1.done; streamlines_1_1 = streamlines_1.next()) {
        var streamline = streamlines_1_1.value;

        for (var i = 0; i < streamline.length; i++) {
          var node = new Node(streamline[i]);

          if (i > 0) {
            node.addSegment(this.vectorsToSegment(streamline[i - 1], streamline[i]));
          }

          if (i < streamline.length - 1) {
            node.addSegment(this.vectorsToSegment(streamline[i], streamline[i + 1]));
          }

          this.fuzzyAddToQuadtree(quadtree, node, nodeAddRadius);
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (streamlines_1_1 && !streamlines_1_1.done && (_a = streamlines_1["return"])) _a.call(streamlines_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }

    try {
      // Add all intersections
      for (var intersections_1 = __values(intersections), intersections_1_1 = intersections_1.next(); !intersections_1_1.done; intersections_1_1 = intersections_1.next()) {
        var intersection = intersections_1_1.value;
        var node = new Node(new vector_1["default"](intersection.point.x, intersection.point.y));

        try {
          for (var _g = (e_3 = void 0, __values(intersection.segments)), _h = _g.next(); !_h.done; _h = _g.next()) {
            var s = _h.value;
            node.addSegment(s);
          }
        } catch (e_3_1) {
          e_3 = {
            error: e_3_1
          };
        } finally {
          try {
            if (_h && !_h.done && (_c = _g["return"])) _c.call(_g);
          } finally {
            if (e_3) throw e_3.error;
          }
        }

        this.fuzzyAddToQuadtree(quadtree, node, nodeAddRadius);
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (intersections_1_1 && !intersections_1_1.done && (_b = intersections_1["return"])) _b.call(intersections_1);
      } finally {
        if (e_2) throw e_2.error;
      }
    }

    try {
      // For each simplified streamline, build list of nodes in order along streamline
      for (var streamlines_2 = __values(streamlines), streamlines_2_1 = streamlines_2.next(); !streamlines_2_1.done; streamlines_2_1 = streamlines_2.next()) {
        var streamline = streamlines_2_1.value;

        for (var i = 0; i < streamline.length - 1; i++) {
          var nodesAlongSegment = this.getNodesAlongSegment(this.vectorsToSegment(streamline[i], streamline[i + 1]), quadtree, nodeAddRadius, dstep);

          if (nodesAlongSegment.length > 1) {
            for (var j = 0; j < nodesAlongSegment.length - 1; j++) {
              nodesAlongSegment[j].addNeighbor(nodesAlongSegment[j + 1]);
            }
          } else {
            log.error("Error Graph.js: segment with less than 2 nodes");
          }
        }
      }
    } catch (e_4_1) {
      e_4 = {
        error: e_4_1
      };
    } finally {
      try {
        if (streamlines_2_1 && !streamlines_2_1.done && (_d = streamlines_2["return"])) _d.call(streamlines_2);
      } finally {
        if (e_4) throw e_4.error;
      }
    }

    try {
      for (var _j = __values(quadtree.data()), _k = _j.next(); !_k.done; _k = _j.next()) {
        var n = _k.value;

        if (deleteDangling) {
          this.deleteDanglingNodes(n, quadtree);
        }

        n.adj = Array.from(n.neighbors);
      }
    } catch (e_5_1) {
      e_5 = {
        error: e_5_1
      };
    } finally {
      try {
        if (_k && !_k.done && (_e = _j["return"])) _e.call(_j);
      } finally {
        if (e_5) throw e_5.error;
      }
    }

    this.nodes = quadtree.data();
    this.intersections = [];

    try {
      for (var intersections_2 = __values(intersections), intersections_2_1 = intersections_2.next(); !intersections_2_1.done; intersections_2_1 = intersections_2.next()) {
        var i = intersections_2_1.value;
        this.intersections.push(new vector_1["default"](i.point.x, i.point.y));
      }
    } catch (e_6_1) {
      e_6 = {
        error: e_6_1
      };
    } finally {
      try {
        if (intersections_2_1 && !intersections_2_1.done && (_f = intersections_2["return"])) _f.call(intersections_2);
      } finally {
        if (e_6) throw e_6.error;
      }
    }
  }
  /**
   * Remove dangling edges from graph to facilitate polygon finding
   */


  Graph.prototype.deleteDanglingNodes = function (n, quadtree) {
    var e_7, _a;

    if (n.neighbors.size === 1) {
      quadtree.remove(n);

      try {
        for (var _b = __values(n.neighbors), _c = _b.next(); !_c.done; _c = _b.next()) {
          var neighbor = _c.value;
          neighbor.neighbors["delete"](n);
          this.deleteDanglingNodes(neighbor, quadtree);
        }
      } catch (e_7_1) {
        e_7 = {
          error: e_7_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
        } finally {
          if (e_7) throw e_7.error;
        }
      }
    }
  };
  /**
   * Given a segment, step along segment and find all nodes along it
   */


  Graph.prototype.getNodesAlongSegment = function (segment, quadtree, radius, step) {
    // Walk dstep along each streamline, adding nodes within dstep/2
    // and connected to this streamline (fuzzy - nodeAddRadius) to list, removing from
    // quadtree and adding them all back at the end
    var e_8, _a;

    var _this = this;

    var foundNodes = [];
    var nodesAlongSegment = [];
    var start = new vector_1["default"](segment.from.x, segment.from.y);
    var end = new vector_1["default"](segment.to.x, segment.to.y);
    var differenceVector = end.clone().sub(start);
    step = Math.min(step, differenceVector.length() / 2); // Min of 2 step along vector

    var steps = Math.ceil(differenceVector.length() / step);
    var differenceVectorLength = differenceVector.length();

    for (var i = 0; i <= steps; i++) {
      var currentPoint = start.clone().add(differenceVector.clone().multiplyScalar(i / steps)); // Order nodes, not by 'closeness', but by dot product

      var nodesToAdd = [];
      var closestNode = quadtree.find(currentPoint.x, currentPoint.y, radius + step / 2);

      while (closestNode !== undefined) {
        quadtree.remove(closestNode);
        foundNodes.push(closestNode);
        var nodeOnSegment = false;

        try {
          for (var _b = (e_8 = void 0, __values(closestNode.segments)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var s = _c.value;

            if (this.fuzzySegmentsEqual(s, segment)) {
              nodeOnSegment = true;
              break;
            }
          }
        } catch (e_8_1) {
          e_8 = {
            error: e_8_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
          } finally {
            if (e_8) throw e_8.error;
          }
        }

        if (nodeOnSegment) {
          nodesToAdd.push(closestNode);
        }

        closestNode = quadtree.find(currentPoint.x, currentPoint.y, radius + step / 2);
      }

      nodesToAdd.sort(function (first, second) {
        return _this.dotProductToSegment(first, start, differenceVector) - _this.dotProductToSegment(second, start, differenceVector);
      });
      nodesAlongSegment.push.apply(nodesAlongSegment, __spread(nodesToAdd));
    }

    quadtree.addAll(foundNodes);
    return nodesAlongSegment;
  };

  Graph.prototype.fuzzySegmentsEqual = function (s1, s2, tolerance) {
    if (tolerance === void 0) {
      tolerance = 0.0001;
    } // From


    if (s1.from.x - s2.from.x > tolerance) {
      return false;
    }

    if (s1.from.y - s2.from.y > tolerance) {
      return false;
    } // To


    if (s1.to.x - s2.to.x > tolerance) {
      return false;
    }

    if (s1.to.y - s2.to.y > tolerance) {
      return false;
    }

    return true;
  };

  Graph.prototype.dotProductToSegment = function (node, start, differenceVector) {
    var dotVector = node.value.clone().sub(start);
    return differenceVector.dot(dotVector);
  };

  Graph.prototype.fuzzyAddToQuadtree = function (quadtree, node, radius) {
    var e_9, _a, e_10, _b; // Only add if there isn't a node within radius
    // Remember to check for double radius when querying tree, or point might be missed


    var existingNode = quadtree.find(node.value.x, node.value.y, radius);

    if (existingNode === undefined) {
      quadtree.add(node);
    } else {
      try {
        for (var _c = __values(node.neighbors), _d = _c.next(); !_d.done; _d = _c.next()) {
          var neighbor = _d.value;
          existingNode.addNeighbor(neighbor);
        }
      } catch (e_9_1) {
        e_9 = {
          error: e_9_1
        };
      } finally {
        try {
          if (_d && !_d.done && (_a = _c["return"])) _a.call(_c);
        } finally {
          if (e_9) throw e_9.error;
        }
      }

      try {
        for (var _e = __values(node.segments), _f = _e.next(); !_f.done; _f = _e.next()) {
          var segment = _f.value;
          existingNode.addSegment(segment);
        }
      } catch (e_10_1) {
        e_10 = {
          error: e_10_1
        };
      } finally {
        try {
          if (_f && !_f.done && (_b = _e["return"])) _b.call(_e);
        } finally {
          if (e_10) throw e_10.error;
        }
      }
    }
  };

  Graph.prototype.streamlinesToSegment = function (streamlines) {
    var e_11, _a;

    var out = [];

    try {
      for (var streamlines_3 = __values(streamlines), streamlines_3_1 = streamlines_3.next(); !streamlines_3_1.done; streamlines_3_1 = streamlines_3.next()) {
        var s = streamlines_3_1.value;

        for (var i = 0; i < s.length - 1; i++) {
          out.push(this.vectorsToSegment(s[i], s[i + 1]));
        }
      }
    } catch (e_11_1) {
      e_11 = {
        error: e_11_1
      };
    } finally {
      try {
        if (streamlines_3_1 && !streamlines_3_1.done && (_a = streamlines_3["return"])) _a.call(streamlines_3);
      } finally {
        if (e_11) throw e_11.error;
      }
    }

    return out;
  };

  Graph.prototype.vectorsToSegment = function (v1, v2) {
    return {
      from: v1,
      to: v2
    };
  };

  return Graph;
}();

exports["default"] = Graph;

},{"../vector":37,"d3-quadtree":3,"isect":5,"loglevel":7}],19:[function(require,module,exports){
"use strict";

var __values = void 0 && (void 0).__values || function (o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var vector_1 = require("../vector");
/**
 * Cartesian grid accelerated data structure
 * Grid of cells, each containing a list of vectors
 */


var GridStorage =
/** @class */
function () {
  /**
   * worldDimensions assumes origin of 0,0
   * @param {number} dsep Separation distance between samples
   */
  function GridStorage(worldDimensions, origin, dsep) {
    this.worldDimensions = worldDimensions;
    this.origin = origin;
    this.dsep = dsep;
    this.dsepSq = this.dsep * this.dsep;
    this.gridDimensions = worldDimensions.clone().divideScalar(this.dsep);
    this.grid = [];

    for (var x = 0; x < this.gridDimensions.x; x++) {
      this.grid.push([]);

      for (var y = 0; y < this.gridDimensions.y; y++) {
        this.grid[x].push([]);
      }
    }
  }
  /**
   * Add all samples from another grid to this one
   */


  GridStorage.prototype.addAll = function (gridStorage) {
    var e_1, _a, e_2, _b, e_3, _c;

    try {
      for (var _d = __values(gridStorage.grid), _e = _d.next(); !_e.done; _e = _d.next()) {
        var row = _e.value;

        try {
          for (var row_1 = (e_2 = void 0, __values(row)), row_1_1 = row_1.next(); !row_1_1.done; row_1_1 = row_1.next()) {
            var cell = row_1_1.value;

            try {
              for (var cell_1 = (e_3 = void 0, __values(cell)), cell_1_1 = cell_1.next(); !cell_1_1.done; cell_1_1 = cell_1.next()) {
                var sample = cell_1_1.value;
                this.addSample(sample);
              }
            } catch (e_3_1) {
              e_3 = {
                error: e_3_1
              };
            } finally {
              try {
                if (cell_1_1 && !cell_1_1.done && (_c = cell_1["return"])) _c.call(cell_1);
              } finally {
                if (e_3) throw e_3.error;
              }
            }
          }
        } catch (e_2_1) {
          e_2 = {
            error: e_2_1
          };
        } finally {
          try {
            if (row_1_1 && !row_1_1.done && (_b = row_1["return"])) _b.call(row_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_e && !_e.done && (_a = _d["return"])) _a.call(_d);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
  };

  GridStorage.prototype.addPolyline = function (line) {
    var e_4, _a;

    try {
      for (var line_1 = __values(line), line_1_1 = line_1.next(); !line_1_1.done; line_1_1 = line_1.next()) {
        var v = line_1_1.value;
        this.addSample(v);
      }
    } catch (e_4_1) {
      e_4 = {
        error: e_4_1
      };
    } finally {
      try {
        if (line_1_1 && !line_1_1.done && (_a = line_1["return"])) _a.call(line_1);
      } finally {
        if (e_4) throw e_4.error;
      }
    }
  };
  /**
   * Does not enforce separation
   * Does not clone
   */


  GridStorage.prototype.addSample = function (v, coords) {
    if (!coords) {
      coords = this.getSampleCoords(v);
    }

    this.grid[coords.x][coords.y].push(v);
  };
  /**
   * Tests whether v is at least d away from samples
   * Performance very important - this is called at every integration step
   * @param dSq=this.dsepSq squared test distance
   * Could be dtest if we are integrating a streamline
   */


  GridStorage.prototype.isValidSample = function (v, dSq) {
    // Code duplication with this.getNearbyPoints but much slower when calling
    // this.getNearbyPoints due to array creation in that method
    if (dSq === void 0) {
      dSq = this.dsepSq;
    }

    var coords = this.getSampleCoords(v); // Check samples in 9 cells in 3x3 grid

    for (var x = -1; x <= 1; x++) {
      for (var y = -1; y <= 1; y++) {
        var cell = coords.clone().add(new vector_1["default"](x, y));

        if (!this.vectorOutOfBounds(cell, this.gridDimensions)) {
          if (!this.vectorFarFromVectors(v, this.grid[cell.x][cell.y], dSq)) {
            return false;
          }
        }
      }
    }

    return true;
  };
  /**
   * Test whether v is at least d away from vectors
   * Performance very important - this is called at every integration step
   * @param {number}   dSq     squared test distance
   */


  GridStorage.prototype.vectorFarFromVectors = function (v, vectors, dSq) {
    var e_5, _a;

    try {
      for (var vectors_1 = __values(vectors), vectors_1_1 = vectors_1.next(); !vectors_1_1.done; vectors_1_1 = vectors_1.next()) {
        var sample = vectors_1_1.value;

        if (sample !== v) {
          var distanceSq = sample.distanceToSquared(v);

          if (distanceSq < dSq) {
            return false;
          }
        }
      }
    } catch (e_5_1) {
      e_5 = {
        error: e_5_1
      };
    } finally {
      try {
        if (vectors_1_1 && !vectors_1_1.done && (_a = vectors_1["return"])) _a.call(vectors_1);
      } finally {
        if (e_5) throw e_5.error;
      }
    }

    return true;
  };
  /**
   * Returns points in cells surrounding v
   * Results include v, if it exists in the grid
   * @param {number} returns samples (kind of) closer than distance - returns all samples in
   * cells so approximation (square to approximate circle)
   */


  GridStorage.prototype.getNearbyPoints = function (v, distance) {
    var e_6, _a;

    var radius = Math.ceil(distance / this.dsep - 0.5);
    var coords = this.getSampleCoords(v);
    var out = [];

    for (var x = -1 * radius; x <= 1 * radius; x++) {
      for (var y = -1 * radius; y <= 1 * radius; y++) {
        var cell = coords.clone().add(new vector_1["default"](x, y));

        if (!this.vectorOutOfBounds(cell, this.gridDimensions)) {
          try {
            for (var _b = (e_6 = void 0, __values(this.grid[cell.x][cell.y])), _c = _b.next(); !_c.done; _c = _b.next()) {
              var v2 = _c.value;
              out.push(v2);
            }
          } catch (e_6_1) {
            e_6 = {
              error: e_6_1
            };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
            } finally {
              if (e_6) throw e_6.error;
            }
          }
        }
      }
    }

    return out;
  };

  GridStorage.prototype.worldToGrid = function (v) {
    return v.clone().sub(this.origin);
  };

  GridStorage.prototype.gridToWorld = function (v) {
    return v.clone().add(this.origin);
  };

  GridStorage.prototype.vectorOutOfBounds = function (gridV, bounds) {
    return gridV.x < 0 || gridV.y < 0 || gridV.x >= bounds.x || gridV.y >= bounds.y;
  };
  /**
   * @return {Vector}   Cell coords corresponding to vector
   * Performance important - called at every integration step
   */


  GridStorage.prototype.getSampleCoords = function (worldV) {
    var v = this.worldToGrid(worldV);

    if (this.vectorOutOfBounds(v, this.worldDimensions)) {
      // log.error("Tried to access out-of-bounds sample in grid");
      return vector_1["default"].zeroVector();
    }

    return new vector_1["default"](Math.floor(v.x / this.dsep), Math.floor(v.y / this.dsep));
  };

  return GridStorage;
}();

exports["default"] = GridStorage;

},{"../vector":37}],20:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var vector_1 = require("../vector");

var FieldIntegrator =
/** @class */
function () {
  function FieldIntegrator(field) {
    this.field = field;
  }

  FieldIntegrator.prototype.sampleFieldVector = function (point, major) {
    var tensor = this.field.samplePoint(point);
    if (major) return tensor.getMajor();
    return tensor.getMinor();
  };

  FieldIntegrator.prototype.onLand = function (point) {
    return this.field.onLand(point);
  };

  return FieldIntegrator;
}();

exports["default"] = FieldIntegrator;

var EulerIntegrator =
/** @class */
function (_super) {
  __extends(EulerIntegrator, _super);

  function EulerIntegrator(field, params) {
    var _this = _super.call(this, field) || this;

    _this.params = params;
    return _this;
  }

  EulerIntegrator.prototype.integrate = function (point, major) {
    return this.sampleFieldVector(point, major).multiplyScalar(this.params.dstep);
  };

  return EulerIntegrator;
}(FieldIntegrator);

exports.EulerIntegrator = EulerIntegrator;

var RK4Integrator =
/** @class */
function (_super) {
  __extends(RK4Integrator, _super);

  function RK4Integrator(field, params) {
    var _this = _super.call(this, field) || this;

    _this.params = params;
    return _this;
  }

  RK4Integrator.prototype.integrate = function (point, major) {
    var k1 = this.sampleFieldVector(point, major);
    var k23 = this.sampleFieldVector(point.clone().add(vector_1["default"].fromScalar(this.params.dstep / 2)), major);
    var k4 = this.sampleFieldVector(point.clone().add(vector_1["default"].fromScalar(this.params.dstep)), major);
    return k1.add(k23.multiplyScalar(4)).add(k4).multiplyScalar(this.params.dstep / 6);
  };

  return RK4Integrator;
}(FieldIntegrator);

exports.RK4Integrator = RK4Integrator;

},{"../vector":37}],21:[function(require,module,exports){
"use strict";

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

var __values = void 0 && (void 0).__values || function (o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

var __read = void 0 && (void 0).__read || function (o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
};

var __spread = void 0 && (void 0).__spread || function () {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read(arguments[i]));
  }

  return ar;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log = require("loglevel");

var polygon_util_1 = require("./polygon_util");
/**
 * Finds polygons in a graph, used for finding lots and parks
 */


var PolygonFinder =
/** @class */
function () {
  function PolygonFinder(nodes, params, tensorField) {
    this.nodes = nodes;
    this.params = params;
    this.tensorField = tensorField;
    this._polygons = [];
    this._shrunkPolygons = [];
    this._dividedPolygons = [];
    this.toShrink = [];
    this.toDivide = [];
  }

  Object.defineProperty(PolygonFinder.prototype, "polygons", {
    get: function get() {
      if (this._dividedPolygons.length > 0) {
        return this._dividedPolygons;
      }

      if (this._shrunkPolygons.length > 0) {
        return this._shrunkPolygons;
      }

      return this._polygons;
    },
    enumerable: true,
    configurable: true
  });

  PolygonFinder.prototype.reset = function () {
    this.toShrink = [];
    this.toDivide = [];
    this._polygons = [];
    this._shrunkPolygons = [];
    this._dividedPolygons = [];
  };

  PolygonFinder.prototype.update = function () {
    var change = false;

    if (this.toShrink.length > 0) {
      var resolve = this.toShrink.length === 1;

      if (this.stepShrink(this.toShrink.pop())) {
        change = true;
      }

      if (resolve) this.resolveShrink();
    }

    if (this.toDivide.length > 0) {
      var resolve = this.toDivide.length === 1;

      if (this.stepDivide(this.toDivide.pop())) {
        change = true;
      }

      if (resolve) this.resolveDivide();
    }

    return change;
  };
  /**
   * Properly shrink polygon so the edges are all the same distance from the road
   */


  PolygonFinder.prototype.shrink = function (animate) {
    if (animate === void 0) {
      animate = false;
    }

    return __awaiter(this, void 0, void 0, function () {
      var _this = this;

      return __generator(this, function (_a) {
        return [2
        /*return*/
        , new Promise(function (resolve) {
          var e_1, _a;

          if (_this._polygons.length === 0) {
            _this.findPolygons();
          }

          if (animate) {
            if (_this._polygons.length === 0) {
              resolve();
              return;
            }

            _this.toShrink = _this._polygons.slice();
            _this.resolveShrink = resolve;
          } else {
            _this._shrunkPolygons = [];

            try {
              for (var _b = __values(_this._polygons), _c = _b.next(); !_c.done; _c = _b.next()) {
                var p = _c.value;

                _this.stepShrink(p);
              }
            } catch (e_1_1) {
              e_1 = {
                error: e_1_1
              };
            } finally {
              try {
                if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
              } finally {
                if (e_1) throw e_1.error;
              }
            }

            resolve();
          }
        })];
      });
    });
  };

  PolygonFinder.prototype.stepShrink = function (polygon) {
    var shrunk = polygon_util_1["default"].resizeGeometry(polygon, -this.params.shrinkSpacing);

    if (shrunk.length > 0) {
      this._shrunkPolygons.push(shrunk);

      return true;
    }

    return false;
  };

  PolygonFinder.prototype.divide = function (animate) {
    if (animate === void 0) {
      animate = false;
    }

    return __awaiter(this, void 0, void 0, function () {
      var _this = this;

      return __generator(this, function (_a) {
        return [2
        /*return*/
        , new Promise(function (resolve) {
          var e_2, _a;

          if (_this._polygons.length === 0) {
            _this.findPolygons();
          }

          var polygons = _this._polygons;

          if (_this._shrunkPolygons.length > 0) {
            polygons = _this._shrunkPolygons;
          }

          if (animate) {
            if (polygons.length === 0) {
              resolve();
              return;
            }

            _this.toDivide = polygons.slice();
            _this.resolveDivide = resolve;
          } else {
            _this._dividedPolygons = [];

            try {
              for (var polygons_1 = __values(polygons), polygons_1_1 = polygons_1.next(); !polygons_1_1.done; polygons_1_1 = polygons_1.next()) {
                var p = polygons_1_1.value;

                _this.stepDivide(p);
              }
            } catch (e_2_1) {
              e_2 = {
                error: e_2_1
              };
            } finally {
              try {
                if (polygons_1_1 && !polygons_1_1.done && (_a = polygons_1["return"])) _a.call(polygons_1);
              } finally {
                if (e_2) throw e_2.error;
              }
            }

            resolve();
          }
        })];
      });
    });
  };

  PolygonFinder.prototype.stepDivide = function (polygon) {
    var _a; // TODO need to filter shrunk polygons using aspect ratio, area 
    // this skips the filter in PolygonUtil.subdividePolygon


    if (this.params.chanceNoDivide > 0 && Math.random() < this.params.chanceNoDivide) {
      this._dividedPolygons.push(polygon);

      return true;
    }

    var divided = polygon_util_1["default"].subdividePolygon(polygon, this.params.minArea);

    if (divided.length > 0) {
      (_a = this._dividedPolygons).push.apply(_a, __spread(divided));

      return true;
    }

    return false;
  };

  PolygonFinder.prototype.findPolygons = function () {
    // Node
    // x, y, value (Vector2), adj (list of node refs)
    // Gonna edit adj for now
    var e_3, _a, e_4, _b; // Walk a clockwise path until polygon found or limit reached
    // When we find a polygon, mark all edges as traversed (in particular direction)
    // Each edge separates two polygons
    // If edge already traversed in this direction, this polygon has already been found


    this._shrunkPolygons = [];
    this._dividedPolygons = [];
    var polygons = [];

    try {
      for (var _c = __values(this.nodes), _d = _c.next(); !_d.done; _d = _c.next()) {
        var node = _d.value;
        if (node.adj.length < 2) continue;

        try {
          for (var _e = (e_4 = void 0, __values(node.adj)), _f = _e.next(); !_f.done; _f = _e.next()) {
            var nextNode = _f.value;
            var polygon = this.recursiveWalk([node, nextNode]);

            if (polygon !== null && polygon.length < this.params.maxLength) {
              this.removePolygonAdjacencies(polygon);
              polygons.push(polygon.map(function (n) {
                return n.value.clone();
              }));
            }
          }
        } catch (e_4_1) {
          e_4 = {
            error: e_4_1
          };
        } finally {
          try {
            if (_f && !_f.done && (_b = _e["return"])) _b.call(_e);
          } finally {
            if (e_4) throw e_4.error;
          }
        }
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (_d && !_d.done && (_a = _c["return"])) _a.call(_c);
      } finally {
        if (e_3) throw e_3.error;
      }
    }

    this._polygons = this.filterPolygonsByWater(polygons);
  };

  PolygonFinder.prototype.filterPolygonsByWater = function (polygons) {
    var e_5, _a;

    var out = [];

    try {
      for (var polygons_2 = __values(polygons), polygons_2_1 = polygons_2.next(); !polygons_2_1.done; polygons_2_1 = polygons_2.next()) {
        var p = polygons_2_1.value;
        var averagePoint = polygon_util_1["default"].averagePoint(p);
        if (this.tensorField.onLand(averagePoint) && !this.tensorField.inParks(averagePoint)) out.push(p);
      }
    } catch (e_5_1) {
      e_5 = {
        error: e_5_1
      };
    } finally {
      try {
        if (polygons_2_1 && !polygons_2_1.done && (_a = polygons_2["return"])) _a.call(polygons_2);
      } finally {
        if (e_5) throw e_5.error;
      }
    }

    return out;
  };

  PolygonFinder.prototype.removePolygonAdjacencies = function (polygon) {
    for (var i = 0; i < polygon.length; i++) {
      var current = polygon[i];
      var next = polygon[(i + 1) % polygon.length];
      var index = current.adj.indexOf(next);

      if (index >= 0) {
        current.adj.splice(index, 1);
      } else {
        log.error("PolygonFinder - node not in adj");
      }
    }
  };

  PolygonFinder.prototype.recursiveWalk = function (visited, count) {
    if (count === void 0) {
      count = 0;
    }

    if (count >= this.params.maxLength) return null; // TODO backtracking to find polygons with dead end roads inside them

    var nextNode = this.getRightmostNode(visited[visited.length - 2], visited[visited.length - 1]);

    if (nextNode === null) {
      return null; // Currently ignores polygons with dead end inside
    }

    var visitedIndex = visited.indexOf(nextNode);

    if (visitedIndex >= 0) {
      return visited.slice(visitedIndex);
    } else {
      visited.push(nextNode);
      return this.recursiveWalk(visited, count++);
    }
  };

  PolygonFinder.prototype.getRightmostNode = function (nodeFrom, nodeTo) {
    var e_6, _a; // We want to turn right at every junction


    if (nodeTo.adj.length === 0) return null;
    var backwardsDifferenceVector = nodeFrom.value.clone().sub(nodeTo.value);
    var transformAngle = Math.atan2(backwardsDifferenceVector.y, backwardsDifferenceVector.x);
    var rightmostNode = null;
    var smallestTheta = Math.PI * 2;

    try {
      for (var _b = __values(nodeTo.adj), _c = _b.next(); !_c.done; _c = _b.next()) {
        var nextNode = _c.value;

        if (nextNode !== nodeFrom) {
          var nextVector = nextNode.value.clone().sub(nodeTo.value);
          var nextAngle = Math.atan2(nextVector.y, nextVector.x) - transformAngle;

          if (nextAngle < 0) {
            nextAngle += Math.PI * 2;
          }

          if (nextAngle < smallestTheta) {
            smallestTheta = nextAngle;
            rightmostNode = nextNode;
          }
        }
      }
    } catch (e_6_1) {
      e_6 = {
        error: e_6_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
      } finally {
        if (e_6) throw e_6.error;
      }
    }

    return rightmostNode;
  };

  return PolygonFinder;
}();

exports["default"] = PolygonFinder;

},{"./polygon_util":22,"loglevel":7}],22:[function(require,module,exports){
"use strict";

var __values = void 0 && (void 0).__values || function (o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

var __read = void 0 && (void 0).__read || function (o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
};

var __spread = void 0 && (void 0).__spread || function () {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read(arguments[i]));
  }

  return ar;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log = require("loglevel");

var PolyK = require("polyk");

var vector_1 = require("../vector");

var jsts = require("jsts");

var PolygonUtil =
/** @class */
function () {
  function PolygonUtil() {}
  /**
   * Slices rectangle by line, returning smallest polygon
   */


  PolygonUtil.sliceRectangle = function (origin, worldDimensions, p1, p2) {
    var rectangle = [origin.x, origin.y, origin.x + worldDimensions.x, origin.y, origin.x + worldDimensions.x, origin.y + worldDimensions.y, origin.x, origin.y + worldDimensions.y];
    var sliced = PolyK.Slice(rectangle, p1.x, p1.y, p2.x, p2.y).map(function (p) {
      return PolygonUtil.polygonArrayToPolygon(p);
    });
    var minArea = PolygonUtil.calcPolygonArea(sliced[0]);

    if (sliced.length > 1 && PolygonUtil.calcPolygonArea(sliced[1]) < minArea) {
      return sliced[1];
    }

    return sliced[0];
  };
  /**
   * Used to create sea polygon
   */


  PolygonUtil.lineRectanglePolygonIntersection = function (origin, worldDimensions, line) {
    var jstsLine = PolygonUtil.lineToJts(line);
    var bounds = [origin, new vector_1["default"](origin.x + worldDimensions.x, origin.y), new vector_1["default"](origin.x + worldDimensions.x, origin.y + worldDimensions.y), new vector_1["default"](origin.x, origin.y + worldDimensions.y)];
    var boundingPoly = PolygonUtil.polygonToJts(bounds);
    var union = boundingPoly.getExteriorRing().union(jstsLine);
    var polygonizer = new jsts.operation.polygonize.Polygonizer();
    polygonizer.add(union);
    var polygons = polygonizer.getPolygons();
    var smallestArea = Infinity;
    var smallestPoly;

    for (var i = polygons.iterator(); i.hasNext();) {
      var polygon = i.next();
      var area = polygon.getArea();

      if (area < smallestArea) {
        smallestArea = area;
        smallestPoly = polygon;
      }
    }

    if (!smallestPoly) return [];
    return smallestPoly.getCoordinates().map(function (c) {
      return new vector_1["default"](c.x, c.y);
    });
  };

  PolygonUtil.calcPolygonArea = function (polygon) {
    var total = 0;

    for (var i = 0; i < polygon.length; i++) {
      var addX = polygon[i].x;
      var addY = polygon[i == polygon.length - 1 ? 0 : i + 1].y;
      var subX = polygon[i == polygon.length - 1 ? 0 : i + 1].x;
      var subY = polygon[i].y;
      total += addX * addY * 0.5;
      total -= subX * subY * 0.5;
    }

    return Math.abs(total);
  };
  /**
   * Recursively divide a polygon by its longest side until the minArea stopping condition is met
   */


  PolygonUtil.subdividePolygon = function (p, minArea) {
    var e_1, _a;

    var area = PolygonUtil.calcPolygonArea(p);

    if (area < 0.5 * minArea) {
      return [];
    }

    var divided = []; // Array of polygons

    var longestSideLength = 0;
    var longestSide = [p[0], p[1]];
    var perimeter = 0;

    for (var i = 0; i < p.length; i++) {
      var sideLength = p[i].clone().sub(p[(i + 1) % p.length]).length();
      perimeter += sideLength;

      if (sideLength > longestSideLength) {
        longestSideLength = sideLength;
        longestSide = [p[i], p[(i + 1) % p.length]];
      }
    } // Shape index
    // Using rectangle ratio of 1:4 as limit
    // if (area / perimeter * perimeter < 0.04) {


    if (area / (perimeter * perimeter) < 0.04) {
      return [];
    }

    if (area < 2 * minArea) {
      return [p];
    } // Between 0.4 and 0.6


    var deviation = Math.random() * 0.2 + 0.4;
    var averagePoint = longestSide[0].clone().add(longestSide[1]).multiplyScalar(deviation);
    var differenceVector = longestSide[0].clone().sub(longestSide[1]);
    var perpVector = new vector_1["default"](differenceVector.y, -1 * differenceVector.x).normalize().multiplyScalar(100);
    var bisect = [averagePoint.clone().add(perpVector), averagePoint.clone().sub(perpVector)]; // Array of polygons

    try {
      var sliced = PolyK.Slice(PolygonUtil.polygonToPolygonArray(p), bisect[0].x, bisect[0].y, bisect[1].x, bisect[1].y);

      try {
        // Recursive call
        for (var sliced_1 = __values(sliced), sliced_1_1 = sliced_1.next(); !sliced_1_1.done; sliced_1_1 = sliced_1.next()) {
          var s = sliced_1_1.value;
          divided.push.apply(divided, __spread(PolygonUtil.subdividePolygon(PolygonUtil.polygonArrayToPolygon(s), minArea)));
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (sliced_1_1 && !sliced_1_1.done && (_a = sliced_1["return"])) _a.call(sliced_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }

      return divided;
    } catch (error) {
      log.error(error);
      return [];
    }
  };
  /**
   * Shrink or expand polygon
   */


  PolygonUtil.resizeGeometry = function (geometry, spacing, isPolygon) {
    if (isPolygon === void 0) {
      isPolygon = true;
    }

    try {
      var jstsGeometry = isPolygon ? PolygonUtil.polygonToJts(geometry) : PolygonUtil.lineToJts(geometry);
      var resized = jstsGeometry.buffer(spacing, undefined, jsts.operation.buffer.BufferParameters.CAP_FLAT);

      if (!resized.isSimple()) {
        return [];
      }

      return resized.getCoordinates().map(function (c) {
        return new vector_1["default"](c.x, c.y);
      });
    } catch (error) {
      log.error(error);
      return [];
    }
  };

  PolygonUtil.averagePoint = function (polygon) {
    var e_2, _a;

    if (polygon.length === 0) return vector_1["default"].zeroVector();
    var sum = vector_1["default"].zeroVector();

    try {
      for (var polygon_1 = __values(polygon), polygon_1_1 = polygon_1.next(); !polygon_1_1.done; polygon_1_1 = polygon_1.next()) {
        var v = polygon_1_1.value;
        sum.add(v);
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (polygon_1_1 && !polygon_1_1.done && (_a = polygon_1["return"])) _a.call(polygon_1);
      } finally {
        if (e_2) throw e_2.error;
      }
    }

    return sum.divideScalar(polygon.length);
  };

  PolygonUtil.insidePolygon = function (point, polygon) {
    // ray-casting algorithm based on
    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
    if (polygon.length === 0) {
      return false;
    }

    var inside = false;

    for (var i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
      var xi = polygon[i].x,
          yi = polygon[i].y;
      var xj = polygon[j].x,
          yj = polygon[j].y;
      var intersect = yi > point.y != yj > point.y && point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi;
      if (intersect) inside = !inside;
    }

    return inside;
  };

  PolygonUtil.pointInRectangle = function (point, origin, dimensions) {
    return point.x >= origin.x && point.y >= origin.y && point.x <= dimensions.x && point.y <= dimensions.y;
  };

  PolygonUtil.lineToJts = function (line) {
    var coords = line.map(function (v) {
      return new jsts.geom.Coordinate(v.x, v.y);
    });
    return PolygonUtil.geometryFactory.createLineString(coords);
  };

  PolygonUtil.polygonToJts = function (polygon) {
    var geoInput = polygon.map(function (v) {
      return new jsts.geom.Coordinate(v.x, v.y);
    });
    geoInput.push(geoInput[0]); // Create loop

    return PolygonUtil.geometryFactory.createPolygon(PolygonUtil.geometryFactory.createLinearRing(geoInput), []);
  };
  /**
   * [ v.x, v.y, v.x, v.y ]...
   */


  PolygonUtil.polygonToPolygonArray = function (p) {
    var e_3, _a;

    var outP = [];

    try {
      for (var p_1 = __values(p), p_1_1 = p_1.next(); !p_1_1.done; p_1_1 = p_1.next()) {
        var v = p_1_1.value;
        outP.push(v.x);
        outP.push(v.y);
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (p_1_1 && !p_1_1.done && (_a = p_1["return"])) _a.call(p_1);
      } finally {
        if (e_3) throw e_3.error;
      }
    }

    return outP;
  };
  /**
   * [ v.x, v.y, v.x, v.y ]...
   */


  PolygonUtil.polygonArrayToPolygon = function (p) {
    var outP = [];

    for (var i = 0; i < p.length / 2; i++) {
      outP.push(new vector_1["default"](p[2 * i], p[2 * i + 1]));
    }

    return outP;
  };

  PolygonUtil.geometryFactory = new jsts.geom.GeometryFactory();
  return PolygonUtil;
}();

exports["default"] = PolygonUtil;

},{"../vector":37,"jsts":6,"loglevel":7,"polyk":9}],23:[function(require,module,exports){
"use strict";

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

var __values = void 0 && (void 0).__values || function (o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

var __read = void 0 && (void 0).__read || function (o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
};

var __spread = void 0 && (void 0).__spread || function () {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read(arguments[i]));
  }

  return ar;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log = require("loglevel");

var simplify = require("simplify-js");

var vector_1 = require("../vector");

var grid_storage_1 = require("./grid_storage");
/**
 * Creates polylines that make up the roads by integrating the tensor field
 * See the paper 'Interactive Procedural Street Modeling' for a thorough explanation
 */


var StreamlineGenerator =
/** @class */
function () {
  /**
   * Uses world-space coordinates
   */
  function StreamlineGenerator(integrator, origin, worldDimensions, params) {
    this.integrator = integrator;
    this.origin = origin;
    this.worldDimensions = worldDimensions;
    this.params = params;
    this.SEED_AT_ENDPOINTS = false;
    this.NEAR_EDGE = 3; // Sample near edge

    this.candidateSeedsMajor = [];
    this.candidateSeedsMinor = [];
    this.streamlinesDone = true;
    this.lastStreamlineMajor = true;
    this.allStreamlines = [];
    this.streamlinesMajor = [];
    this.streamlinesMinor = [];
    this.allStreamlinesSimple = []; // Reduced vertex count

    if (params.dstep > params.dsep) {
      log.error("STREAMLINE SAMPLE DISTANCE BIGGER THAN DSEP");
    } // Enforce test < sep


    params.dtest = Math.min(params.dtest, params.dsep); // Needs to be less than circlejoin

    this.dcollideselfSq = Math.pow(params.dcirclejoin / 2, 2);
    this.nStreamlineStep = Math.floor(params.dcirclejoin / params.dstep);
    this.nStreamlineLookBack = 2 * this.nStreamlineStep;
    this.majorGrid = new grid_storage_1["default"](this.worldDimensions, this.origin, params.dsep);
    this.minorGrid = new grid_storage_1["default"](this.worldDimensions, this.origin, params.dsep);
    this.setParamsSq();
  }

  StreamlineGenerator.prototype.clearStreamlines = function () {
    this.allStreamlinesSimple = [];
    this.streamlinesMajor = [];
    this.streamlinesMinor = [];
    this.allStreamlines = [];
  };
  /**
   * Edits streamlines
   */


  StreamlineGenerator.prototype.joinDanglingStreamlines = function () {
    var e_1, _a, e_2, _b, e_3, _c, e_4, _d, e_5, _e;

    try {
      // TODO do in update method
      for (var _f = __values([true, false]), _g = _f.next(); !_g.done; _g = _f.next()) {
        var major = _g.value;

        try {
          for (var _h = (e_2 = void 0, __values(this.streamlines(major))), _j = _h.next(); !_j.done; _j = _h.next()) {
            var streamline = _j.value; // Ignore circles

            if (streamline[0].equals(streamline[streamline.length - 1])) {
              continue;
            }

            var newStart = this.getBestNextPoint(streamline[0], streamline[4], streamline);

            if (newStart !== null) {
              try {
                for (var _k = (e_3 = void 0, __values(this.pointsBetween(streamline[0], newStart, this.params.dstep))), _l = _k.next(); !_l.done; _l = _k.next()) {
                  var p = _l.value;
                  streamline.unshift(p);
                  this.grid(major).addSample(p);
                }
              } catch (e_3_1) {
                e_3 = {
                  error: e_3_1
                };
              } finally {
                try {
                  if (_l && !_l.done && (_c = _k["return"])) _c.call(_k);
                } finally {
                  if (e_3) throw e_3.error;
                }
              }
            }

            var newEnd = this.getBestNextPoint(streamline[streamline.length - 1], streamline[streamline.length - 4], streamline);

            if (newEnd !== null) {
              try {
                for (var _m = (e_4 = void 0, __values(this.pointsBetween(streamline[streamline.length - 1], newEnd, this.params.dstep))), _o = _m.next(); !_o.done; _o = _m.next()) {
                  var p = _o.value;
                  streamline.push(p);
                  this.grid(major).addSample(p);
                }
              } catch (e_4_1) {
                e_4 = {
                  error: e_4_1
                };
              } finally {
                try {
                  if (_o && !_o.done && (_d = _m["return"])) _d.call(_m);
                } finally {
                  if (e_4) throw e_4.error;
                }
              }
            }
          }
        } catch (e_2_1) {
          e_2 = {
            error: e_2_1
          };
        } finally {
          try {
            if (_j && !_j.done && (_b = _h["return"])) _b.call(_h);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_g && !_g.done && (_a = _f["return"])) _a.call(_f);
      } finally {
        if (e_1) throw e_1.error;
      }
    } // Reset simplified streamlines


    this.allStreamlinesSimple = [];

    try {
      for (var _p = __values(this.allStreamlines), _q = _p.next(); !_q.done; _q = _p.next()) {
        var s = _q.value;
        this.allStreamlinesSimple.push(this.simplifyStreamline(s));
      }
    } catch (e_5_1) {
      e_5 = {
        error: e_5_1
      };
    } finally {
      try {
        if (_q && !_q.done && (_e = _p["return"])) _e.call(_p);
      } finally {
        if (e_5) throw e_5.error;
      }
    }
  };
  /**
   * Returns array of points from v1 to v2 such that they are separated by at most dsep
   * not including v1
   */


  StreamlineGenerator.prototype.pointsBetween = function (v1, v2, dstep) {
    var d = v1.distanceTo(v2);
    var nPoints = Math.floor(d / dstep);
    if (nPoints === 0) return [];
    var stepVector = v2.clone().sub(v1);
    var out = [];
    var i = 1;
    var next = v1.clone().add(stepVector.clone().multiplyScalar(i / nPoints));

    for (i = 1; i <= nPoints; i++) {
      if (this.integrator.integrate(next, true).lengthSq() > 0.001) {
        // Test for degenerate point
        out.push(next);
      } else {
        return out;
      }

      next = v1.clone().add(stepVector.clone().multiplyScalar(i / nPoints));
    }

    return out;
  };
  /**
   * Gets next best point to join streamline
   * returns null if there are no good candidates
   */


  StreamlineGenerator.prototype.getBestNextPoint = function (point, previousPoint, streamline) {
    var e_6, _a;

    var nearbyPoints = this.majorGrid.getNearbyPoints(point, this.params.dlookahead);
    nearbyPoints.push.apply(nearbyPoints, __spread(this.minorGrid.getNearbyPoints(point, this.params.dlookahead)));
    var direction = point.clone().sub(previousPoint);
    var closestSample = null;
    var closestDistance = Infinity;

    try {
      for (var nearbyPoints_1 = __values(nearbyPoints), nearbyPoints_1_1 = nearbyPoints_1.next(); !nearbyPoints_1_1.done; nearbyPoints_1_1 = nearbyPoints_1.next()) {
        var sample = nearbyPoints_1_1.value;

        if (!sample.equals(point) && !sample.equals(previousPoint)) {
          // && !streamline.includes(sample)) {
          var differenceVector = sample.clone().sub(point);

          if (differenceVector.dot(direction) < 0) {
            // Backwards
            continue;
          } // Acute angle between vectors (agnostic of CW, ACW)


          var distanceToSample = point.distanceToSquared(sample);

          if (distanceToSample < 2 * this.paramsSq.dstep) {
            closestSample = sample;
            break;
          }

          var angleBetween = Math.abs(vector_1["default"].angleBetween(direction, differenceVector)); // Filter by angle

          if (angleBetween < this.params.joinangle && distanceToSample < closestDistance) {
            closestDistance = distanceToSample;
            closestSample = sample;
          }
        }
      }
    } catch (e_6_1) {
      e_6 = {
        error: e_6_1
      };
    } finally {
      try {
        if (nearbyPoints_1_1 && !nearbyPoints_1_1.done && (_a = nearbyPoints_1["return"])) _a.call(nearbyPoints_1);
      } finally {
        if (e_6) throw e_6.error;
      }
    } // TODO is reimplement simplify-js to preserve intersection points
    //  - this is the primary reason polygons aren't found
    // If trying to find intersections in the simplified graph
    // prevent ends getting pulled away from simplified lines


    if (closestSample !== null) {
      closestSample = closestSample.clone().add(direction.setLength(this.params.simplifyTolerance * 4));
    }

    return closestSample;
  };
  /**
   * Assumes s has already generated
   */


  StreamlineGenerator.prototype.addExistingStreamlines = function (s) {
    this.majorGrid.addAll(s.majorGrid);
    this.minorGrid.addAll(s.minorGrid);
  };

  StreamlineGenerator.prototype.setGrid = function (s) {
    this.majorGrid = s.majorGrid;
    this.minorGrid = s.minorGrid;
  };
  /**
   * returns true if state updates
   */


  StreamlineGenerator.prototype.update = function () {
    if (!this.streamlinesDone) {
      this.lastStreamlineMajor = !this.lastStreamlineMajor;

      if (!this.createStreamline(this.lastStreamlineMajor)) {
        this.streamlinesDone = true;
        this.resolve();
      }

      return true;
    }

    return false;
  };
  /**
   * All at once - will freeze if dsep small
   */


  StreamlineGenerator.prototype.createAllStreamlines = function (animate) {
    if (animate === void 0) {
      animate = false;
    }

    return __awaiter(this, void 0, void 0, function () {
      var _this = this;

      return __generator(this, function (_a) {
        return [2
        /*return*/
        , new Promise(function (resolve) {
          _this.resolve = resolve;
          _this.streamlinesDone = false;

          if (!animate) {
            var major = true;

            while (_this.createStreamline(major)) {
              major = !major;
            }
          }
        }).then(function () {
          return _this.joinDanglingStreamlines();
        })];
      });
    });
  };

  StreamlineGenerator.prototype.simplifyStreamline = function (streamline) {
    var e_7, _a;

    var simplified = [];

    try {
      for (var _b = __values(simplify(streamline, this.params.simplifyTolerance)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var point = _c.value;
        simplified.push(new vector_1["default"](point.x, point.y));
      }
    } catch (e_7_1) {
      e_7 = {
        error: e_7_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
      } finally {
        if (e_7) throw e_7.error;
      }
    }

    return simplified;
  };
  /**
   * Finds seed and creates a streamline from that point
   * Pushes new candidate seeds to queue
   * @return {Vector[]} returns false if seed isn't found within params.seedTries
   */


  StreamlineGenerator.prototype.createStreamline = function (major) {
    var seed = this.getSeed(major);

    if (seed === null) {
      return false;
    }

    var streamline = this.integrateStreamline(seed, major);

    if (this.validStreamline(streamline)) {
      this.grid(major).addPolyline(streamline);
      this.streamlines(major).push(streamline);
      this.allStreamlines.push(streamline);
      this.allStreamlinesSimple.push(this.simplifyStreamline(streamline)); // Add candidate seeds

      if (!streamline[0].equals(streamline[streamline.length - 1])) {
        this.candidateSeeds(!major).push(streamline[0]);
        this.candidateSeeds(!major).push(streamline[streamline.length - 1]);
      }
    }

    return true;
  };

  StreamlineGenerator.prototype.validStreamline = function (s) {
    return s.length > 5;
  };

  StreamlineGenerator.prototype.setParamsSq = function () {
    this.paramsSq = Object.assign({}, this.params);

    for (var p in this.paramsSq) {
      if (typeof this.paramsSq[p] === "number") {
        this.paramsSq[p] *= this.paramsSq[p];
      }
    }
  };

  StreamlineGenerator.prototype.samplePoint = function () {
    // TODO better seeding scheme
    return new vector_1["default"](Math.random() * this.worldDimensions.x, Math.random() * this.worldDimensions.y).add(this.origin);
  };
  /**
   * Tries this.candidateSeeds first, then samples using this.samplePoint
   */


  StreamlineGenerator.prototype.getSeed = function (major) {
    // Candidate seeds first
    if (this.SEED_AT_ENDPOINTS && this.candidateSeeds(major).length > 0) {
      while (this.candidateSeeds(major).length > 0) {
        var seed_1 = this.candidateSeeds(major).pop();

        if (this.isValidSample(major, seed_1, this.paramsSq.dsep)) {
          return seed_1;
        }
      }
    }

    var seed = this.samplePoint();
    var i = 0;

    while (!this.isValidSample(major, seed, this.paramsSq.dsep)) {
      if (i >= this.params.seedTries) {
        return null;
      }

      seed = this.samplePoint();
      i++;
    }

    return seed;
  };

  StreamlineGenerator.prototype.isValidSample = function (major, point, dSq, bothGrids) {
    if (bothGrids === void 0) {
      bothGrids = false;
    } // dSq = dSq * point.distanceToSquared(Vector.zeroVector());


    var gridValid = this.grid(major).isValidSample(point, dSq);

    if (bothGrids) {
      gridValid = gridValid && this.grid(!major).isValidSample(point, dSq);
    }

    return this.integrator.onLand(point) && gridValid;
  };

  StreamlineGenerator.prototype.candidateSeeds = function (major) {
    return major ? this.candidateSeedsMajor : this.candidateSeedsMinor;
  };

  StreamlineGenerator.prototype.streamlines = function (major) {
    return major ? this.streamlinesMajor : this.streamlinesMinor;
  };

  StreamlineGenerator.prototype.grid = function (major) {
    return major ? this.majorGrid : this.minorGrid;
  };

  StreamlineGenerator.prototype.pointInBounds = function (v) {
    return v.x >= this.origin.x && v.y >= this.origin.y && v.x < this.worldDimensions.x + this.origin.x && v.y < this.worldDimensions.y + this.origin.y;
  };
  /**
   * Didn't end up using - bit expensive, used streamlineTurned instead
   * Stops spirals from forming
   * uses 0.5 dcirclejoin so that circles are still joined up
   * testSample is candidate to pushed on end of streamlineForwards
   * returns true if streamline collides with itself
   */


  StreamlineGenerator.prototype.doesStreamlineCollideSelf = function (testSample, streamlineForwards, streamlineBackwards) {
    // Streamline long enough
    if (streamlineForwards.length > this.nStreamlineLookBack) {
      // Forwards check
      for (var i = 0; i < streamlineForwards.length - this.nStreamlineLookBack; i += this.nStreamlineStep) {
        if (testSample.distanceToSquared(streamlineForwards[i]) < this.dcollideselfSq) {
          return true;
        }
      } // Backwards check


      for (var i = 0; i < streamlineBackwards.length; i += this.nStreamlineStep) {
        if (testSample.distanceToSquared(streamlineBackwards[i]) < this.dcollideselfSq) {
          return true;
        }
      }
    }

    return false;
  };
  /**
   * Tests whether streamline has turned through greater than 180 degrees
   */


  StreamlineGenerator.prototype.streamlineTurned = function (seed, originalDir, point, direction) {
    if (originalDir.dot(direction) < 0) {
      // TODO optimise
      var perpendicularVector = new vector_1["default"](originalDir.y, -originalDir.x);
      var isLeft = point.clone().sub(seed).dot(perpendicularVector) < 0;
      var directionUp = direction.dot(perpendicularVector) > 0;
      return isLeft === directionUp;
    }

    return false;
  };
  /**
   * // TODO this doesn't work well - consider something disallowing one direction (F/B) to turn more than 180 deg
   * One step of the streamline integration process
   */


  StreamlineGenerator.prototype.streamlineIntegrationStep = function (params, major, collideBoth) {
    if (params.valid) {
      params.streamline.push(params.previousPoint);
      var nextDirection = this.integrator.integrate(params.previousPoint, major); // Stop at degenerate point

      if (nextDirection.lengthSq() < 0.01) {
        params.valid = false;
        return;
      } // Make sure we travel in the same direction


      if (nextDirection.dot(params.previousDirection) < 0) {
        nextDirection.negate();
      }

      var nextPoint = params.previousPoint.clone().add(nextDirection); // Visualise stopping points
      // if (this.streamlineTurned(params.seed, params.originalDir, nextPoint, nextDirection)) {
      //     params.valid = false;
      //     params.streamline.push(Vector.zeroVector());
      // }

      if (this.pointInBounds(nextPoint) && this.isValidSample(major, nextPoint, this.paramsSq.dtest, collideBoth) && !this.streamlineTurned(params.seed, params.originalDir, nextPoint, nextDirection)) {
        params.previousPoint = nextPoint;
        params.previousDirection = nextDirection;
      } else {
        // One more step
        params.streamline.push(nextPoint);
        params.valid = false;
      }
    }
  };
  /**
   * By simultaneously integrating in both directions we reduce the impact of circles not joining
   * up as the error matches at the join
   */


  StreamlineGenerator.prototype.integrateStreamline = function (seed, major) {
    var _a;

    var count = 0;
    var pointsEscaped = false; // True once two integration fronts have moved dlookahead away
    // Whether or not to test validity using both grid storages
    // (Collide with both major and minor)

    var collideBoth = Math.random() < this.params.collideEarly;
    var d = this.integrator.integrate(seed, major);
    var forwardParams = {
      seed: seed,
      originalDir: d,
      streamline: [seed],
      previousDirection: d,
      previousPoint: seed.clone().add(d),
      valid: true
    };
    forwardParams.valid = this.pointInBounds(forwardParams.previousPoint);
    var negD = d.clone().negate();
    var backwardParams = {
      seed: seed,
      originalDir: negD,
      streamline: [],
      previousDirection: negD,
      previousPoint: seed.clone().add(negD),
      valid: true
    };
    backwardParams.valid = this.pointInBounds(backwardParams.previousPoint);

    while (count < this.params.pathIterations && (forwardParams.valid || backwardParams.valid)) {
      this.streamlineIntegrationStep(forwardParams, major, collideBoth);
      this.streamlineIntegrationStep(backwardParams, major, collideBoth); // Join up circles

      var sqDistanceBetweenPoints = forwardParams.previousPoint.distanceToSquared(backwardParams.previousPoint);

      if (!pointsEscaped && sqDistanceBetweenPoints > this.paramsSq.dcirclejoin) {
        pointsEscaped = true;
      }

      if (pointsEscaped && sqDistanceBetweenPoints <= this.paramsSq.dcirclejoin) {
        forwardParams.streamline.push(forwardParams.previousPoint);
        forwardParams.streamline.push(backwardParams.previousPoint);
        backwardParams.streamline.push(backwardParams.previousPoint);
        break;
      }

      count++;
    }

    (_a = backwardParams.streamline.reverse()).push.apply(_a, __spread(forwardParams.streamline));

    return backwardParams.streamline;
  };

  return StreamlineGenerator;
}();

exports["default"] = StreamlineGenerator;

},{"../vector":37,"./grid_storage":19,"loglevel":7,"simplify-js":13}],24:[function(require,module,exports){
"use strict";

var __read = void 0 && (void 0).__read || function (o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
};

var __spread = void 0 && (void 0).__spread || function () {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read(arguments[i]));
  }

  return ar;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var vector_1 = require("../vector");

var Tensor =
/** @class */
function () {
  function Tensor(r, matrix) {
    this.r = r;
    this.matrix = matrix; // Represent the matrix as a 2 element list
    // [ 0, 1
    //   1, -0 ]

    this.oldTheta = false;
    this._theta = this.calculateTheta();
  }

  Tensor.fromAngle = function (angle) {
    return new Tensor(1, [Math.cos(angle * 4), Math.sin(angle * 4)]);
  };

  Tensor.fromVector = function (vector) {
    var t1 = Math.pow(vector.x, 2) - Math.pow(vector.y, 2);
    var t2 = 2 * vector.x * vector.y;
    var t3 = Math.pow(t1, 2) - Math.pow(t2, 2);
    var t4 = 2 * t1 * t2;
    return new Tensor(1, [t3, t4]);
  };

  Object.defineProperty(Tensor, "zero", {
    get: function get() {
      return new Tensor(0, [0, 0]);
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Tensor.prototype, "theta", {
    get: function get() {
      if (this.oldTheta) {
        this._theta = this.calculateTheta();
        this.oldTheta = false;
      }

      return this._theta;
    },
    enumerable: true,
    configurable: true
  });

  Tensor.prototype.add = function (tensor, smooth) {
    var _this = this;

    this.matrix = this.matrix.map(function (v, i) {
      return v * _this.r + tensor.matrix[i] * tensor.r;
    });

    if (smooth) {
      this.r = Math.hypot.apply(Math, __spread(this.matrix));
      this.matrix = this.matrix.map(function (v) {
        return v / _this.r;
      });
    } else {
      this.r = 2;
    }

    this.oldTheta = true;
    return this;
  };

  Tensor.prototype.scale = function (s) {
    this.r *= s;
    this.oldTheta = true;
    return this;
  }; // Radians


  Tensor.prototype.rotate = function (theta) {
    if (theta === 0) {
      return this;
    }

    var newTheta = this.theta + theta;

    if (newTheta < Math.PI) {
      newTheta += Math.PI;
    }

    if (newTheta >= Math.PI) {
      newTheta -= Math.PI;
    }

    this.matrix[0] = Math.cos(2 * newTheta) * this.r;
    this.matrix[1] = Math.sin(2 * newTheta) * this.r;
    this._theta = newTheta;
    return this;
  };

  Tensor.prototype.getMajor = function () {
    // Degenerate case
    if (this.r === 0) {
      return vector_1["default"].zeroVector();
    }

    return new vector_1["default"](Math.cos(this.theta), Math.sin(this.theta));
  };

  Tensor.prototype.getMinor = function () {
    // Degenerate case
    if (this.r === 0) {
      return vector_1["default"].zeroVector();
    }

    var angle = this.theta + Math.PI / 2;
    return new vector_1["default"](Math.cos(angle), Math.sin(angle));
  };

  Tensor.prototype.calculateTheta = function () {
    if (this.r === 0) {
      return 0;
    }

    return Math.atan2(this.matrix[1] / this.r, this.matrix[0] / this.r) / 2;
  };

  return Tensor;
}();

exports["default"] = Tensor;

},{"../vector":37}],25:[function(require,module,exports){
"use strict";

var __values = void 0 && (void 0).__values || function (o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

Object.defineProperty(exports, "__esModule", {
  value: true
}); // import * as noise from 'noisejs';

var SimplexNoise = require("simplex-noise");

var tensor_1 = require("./tensor");

var basis_field_1 = require("./basis_field");

var polygon_util_1 = require("./polygon_util");
/**
 * Combines basis fields
 * Noise added when sampling a point in a park
 */


var TensorField =
/** @class */
function () {
  function TensorField(noiseParams) {
    this.noiseParams = noiseParams;
    this.basisFields = [];
    this.parks = [];
    this.sea = [];
    this.river = [];
    this.ignoreRiver = false;
    this.smooth = false;
    this.noise = new SimplexNoise();
  }
  /**
   * Used when integrating coastline and river
   */


  TensorField.prototype.enableGlobalNoise = function (angle, size) {
    this.noiseParams.globalNoise = true;
    this.noiseParams.noiseAngleGlobal = angle;
    this.noiseParams.noiseSizeGlobal = size;
  };

  TensorField.prototype.disableGlobalNoise = function () {
    this.noiseParams.globalNoise = false;
  };

  TensorField.prototype.addGrid = function (centre, size, decay, theta) {
    var grid = new basis_field_1.Grid(centre, size, decay, theta);
    this.addField(grid);
  };

  TensorField.prototype.addRadial = function (centre, size, decay) {
    var radial = new basis_field_1.Radial(centre, size, decay);
    this.addField(radial);
  };

  TensorField.prototype.addField = function (field) {
    this.basisFields.push(field);
  };

  TensorField.prototype.removeField = function (field) {
    var index = this.basisFields.indexOf(field);

    if (index > -1) {
      this.basisFields.splice(index, 1);
    }
  };

  TensorField.prototype.reset = function () {
    this.basisFields = [];
    this.parks = [];
    this.sea = [];
    this.river = [];
  };

  TensorField.prototype.getCentrePoints = function () {
    return this.basisFields.map(function (field) {
      return field.centre;
    });
  };

  TensorField.prototype.getBasisFields = function () {
    return this.basisFields;
  };

  TensorField.prototype.samplePoint = function (point) {
    var _this = this;

    if (!this.onLand(point)) {
      // Degenerate point
      return tensor_1["default"].zero;
    } // Default field is a grid


    if (this.basisFields.length === 0) {
      return new tensor_1["default"](1, [0, 0]);
    }

    var tensorAcc = tensor_1["default"].zero;
    this.basisFields.forEach(function (field) {
      return tensorAcc.add(field.getWeightedTensor(point, _this.smooth), _this.smooth);
    }); // Add rotational noise for parks - range -pi/2 to pi/2

    if (this.parks.some(function (p) {
      return polygon_util_1["default"].insidePolygon(point, p);
    })) {
      // TODO optimise insidePolygon e.g. distance
      tensorAcc.rotate(this.getRotationalNoise(point, this.noiseParams.noiseSizePark, this.noiseParams.noiseAnglePark));
    }

    if (this.noiseParams.globalNoise) {
      tensorAcc.rotate(this.getRotationalNoise(point, this.noiseParams.noiseSizeGlobal, this.noiseParams.noiseAngleGlobal));
    }

    return tensorAcc;
  };
  /**
   * Noise Angle is in degrees
   */


  TensorField.prototype.getRotationalNoise = function (point, noiseSize, noiseAngle) {
    return this.noise.noise2D(point.x / noiseSize, point.y / noiseSize) * noiseAngle * Math.PI / 180;
  };

  TensorField.prototype.onLand = function (point) {
    var inSea = polygon_util_1["default"].insidePolygon(point, this.sea);

    if (this.ignoreRiver) {
      return !inSea;
    }

    return !inSea && !polygon_util_1["default"].insidePolygon(point, this.river);
  };

  TensorField.prototype.inParks = function (point) {
    var e_1, _a;

    try {
      for (var _b = __values(this.parks), _c = _b.next(); !_c.done; _c = _b.next()) {
        var p = _c.value;
        if (polygon_util_1["default"].insidePolygon(point, p)) return true;
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }

    return false;
  };

  return TensorField;
}();

exports["default"] = TensorField;

},{"./basis_field":17,"./polygon_util":22,"./tensor":24,"simplex-noise":12}],26:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __read = void 0 && (void 0).__read || function (o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
};

var __spread = void 0 && (void 0).__spread || function () {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read(arguments[i]));
  }

  return ar;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log = require("loglevel");

var streamlines_1 = require("./streamlines");

var polygon_util_1 = require("./polygon_util");
/**
 * Integrates polylines to create coastline and river, with controllable noise
 */


var WaterGenerator =
/** @class */
function (_super) {
  __extends(WaterGenerator, _super);

  function WaterGenerator(integrator, origin, worldDimensions, params, tensorField) {
    var _this = _super.call(this, integrator, origin, worldDimensions, params) || this;

    _this.params = params;
    _this.tensorField = tensorField;
    _this.TRIES = 100;
    _this.coastlineMajor = true;
    _this._coastline = []; // Noisy line

    _this._seaPolygon = []; // Uses screen rectangle and simplified road

    _this._riverPolygon = []; // Simplified

    _this._riverSecondaryRoad = [];
    return _this;
  }

  Object.defineProperty(WaterGenerator.prototype, "coastline", {
    get: function get() {
      return this._coastline;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(WaterGenerator.prototype, "seaPolygon", {
    get: function get() {
      return this._seaPolygon;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(WaterGenerator.prototype, "riverPolygon", {
    get: function get() {
      return this._riverPolygon;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(WaterGenerator.prototype, "riverSecondaryRoad", {
    get: function get() {
      return this._riverSecondaryRoad;
    },
    enumerable: true,
    configurable: true
  });

  WaterGenerator.prototype.createCoast = function () {
    var coastStreamline;
    var seed;
    var major;

    if (this.params.coastNoise.noiseEnabled) {
      this.tensorField.enableGlobalNoise(this.params.coastNoise.noiseAngle, this.params.coastNoise.noiseSize);
    }

    for (var i = 0; i < this.TRIES; i++) {
      major = Math.random() < 0.5;
      seed = this.getSeed(major);
      coastStreamline = this.extendStreamline(this.integrateStreamline(seed, major));

      if (this.reachesEdges(coastStreamline)) {
        break;
      }
    }

    this.tensorField.disableGlobalNoise();
    this._coastline = coastStreamline;
    this.coastlineMajor = major;
    var road = this.simplifyStreamline(coastStreamline);
    this._seaPolygon = this.getSeaPolygon(road);
    this.allStreamlinesSimple.push(road);
    this.tensorField.sea = this._seaPolygon; // Create intermediate samples

    var complex = this.complexifyStreamline(road);
    this.grid(major).addPolyline(complex);
    this.streamlines(major).push(complex);
    this.allStreamlines.push(complex);
  };

  WaterGenerator.prototype.createRiver = function () {
    var _this = this;

    var riverStreamline;
    var seed; // Need to ignore sea when integrating for edge check

    var oldSea = this.tensorField.sea;
    this.tensorField.sea = [];

    if (this.params.riverNoise.noiseEnabled) {
      this.tensorField.enableGlobalNoise(this.params.riverNoise.noiseAngle, this.params.riverNoise.noiseSize);
    }

    for (var i = 0; i < this.TRIES; i++) {
      seed = this.getSeed(!this.coastlineMajor);
      riverStreamline = this.extendStreamline(this.integrateStreamline(seed, !this.coastlineMajor));

      if (this.reachesEdges(riverStreamline)) {
        break;
      } else if (i === this.TRIES - 1) {
        log.error('Failed to find river reaching edge');
      }
    }

    this.tensorField.sea = oldSea;
    this.tensorField.disableGlobalNoise(); // Create river roads

    var expandedNoisy = this.complexifyStreamline(polygon_util_1["default"].resizeGeometry(riverStreamline, this.params.riverSize, false));
    this._riverPolygon = polygon_util_1["default"].resizeGeometry(riverStreamline, this.params.riverSize - this.params.riverBankSize, false); // Make sure riverPolygon[0] is off screen

    var firstOffScreen = expandedNoisy.findIndex(function (v) {
      return _this.vectorOffScreen(v);
    });

    for (var i = 0; i < firstOffScreen; i++) {
      expandedNoisy.push(expandedNoisy.shift());
    } // Create river roads


    var riverSplitPoly = this.getSeaPolygon(riverStreamline);
    var road1 = expandedNoisy.filter(function (v) {
      return !polygon_util_1["default"].insidePolygon(v, _this._seaPolygon) && !_this.vectorOffScreen(v) && polygon_util_1["default"].insidePolygon(v, riverSplitPoly);
    });
    var road1Simple = this.simplifyStreamline(road1);
    var road2 = expandedNoisy.filter(function (v) {
      return !polygon_util_1["default"].insidePolygon(v, _this._seaPolygon) && !_this.vectorOffScreen(v) && !polygon_util_1["default"].insidePolygon(v, riverSplitPoly);
    });
    var road2Simple = this.simplifyStreamline(road2);
    if (road1.length === 0 || road2.length === 0) return;

    if (road1[0].distanceToSquared(road2[0]) < road1[0].distanceToSquared(road2[road2.length - 1])) {
      road2Simple.reverse();
    }

    this.tensorField.river = road1Simple.concat(road2Simple); // Road 1

    this.allStreamlinesSimple.push(road1Simple);
    this._riverSecondaryRoad = road2Simple;
    this.grid(!this.coastlineMajor).addPolyline(road1);
    this.grid(!this.coastlineMajor).addPolyline(road2);
    this.streamlines(!this.coastlineMajor).push(road1);
    this.streamlines(!this.coastlineMajor).push(road2);
    this.allStreamlines.push(road1);
    this.allStreamlines.push(road2);
  };
  /**
   * Assumes simplified
   * Used for adding river roads
   */


  WaterGenerator.prototype.manuallyAddStreamline = function (s, major) {
    this.allStreamlinesSimple.push(s); // Create intermediate samples

    var complex = this.complexifyStreamline(s);
    this.grid(major).addPolyline(complex);
    this.streamlines(major).push(complex);
    this.allStreamlines.push(complex);
  };
  /**
   * Might reverse input array
   */


  WaterGenerator.prototype.getSeaPolygon = function (polyline) {
    // const seaPolygon = PolygonUtil.sliceRectangle(this.origin, this.worldDimensions,
    //     polyline[0], polyline[polyline.length - 1]);
    // // Replace the longest side with coastline
    // let longestIndex = 0;
    // let longestLength = 0;
    // for (let i = 0; i < seaPolygon.length; i++) {
    //     const next = (i + 1) % seaPolygon.length;
    //     const d = seaPolygon[i].distanceToSquared(seaPolygon[next]);
    //     if (d > longestLength) {
    //         longestLength = d;
    //         longestIndex = i;
    //     }
    // }
    // const insertBackwards = seaPolygon[longestIndex].distanceToSquared(polyline[0]) > seaPolygon[longestIndex].distanceToSquared(polyline[polyline.length - 1]);
    // if (insertBackwards) {
    //     polyline.reverse();
    // }
    // seaPolygon.splice((longestIndex + 1) % seaPolygon.length, 0, ...polyline);
    return polygon_util_1["default"].lineRectanglePolygonIntersection(this.origin, this.worldDimensions, polyline); // return PolygonUtil.boundPolyToScreen(this.origin, this.worldDimensions, seaPolygon);
  };
  /**
   * Insert samples in streamline until separated by dstep
   */


  WaterGenerator.prototype.complexifyStreamline = function (s) {
    var out = [];

    for (var i = 0; i < s.length - 1; i++) {
      out.push.apply(out, __spread(this.complexifyStreamlineRecursive(s[i], s[i + 1])));
    }

    return out;
  };

  WaterGenerator.prototype.complexifyStreamlineRecursive = function (v1, v2) {
    if (v1.distanceToSquared(v2) <= this.paramsSq.dstep) {
      return [v1, v2];
    }

    var d = v2.clone().sub(v1);
    var halfway = v1.clone().add(d.multiplyScalar(0.5));
    var complex = this.complexifyStreamlineRecursive(v1, halfway);
    complex.push.apply(complex, __spread(this.complexifyStreamlineRecursive(halfway, v2)));
    return complex;
  };
  /**
   * Mutates streamline
   */


  WaterGenerator.prototype.extendStreamline = function (streamline) {
    streamline.unshift(streamline[0].clone().add(streamline[0].clone().sub(streamline[1]).setLength(this.params.dstep * 5)));
    streamline.push(streamline[streamline.length - 1].clone().add(streamline[streamline.length - 1].clone().sub(streamline[streamline.length - 2]).setLength(this.params.dstep * 5)));
    return streamline;
  };

  WaterGenerator.prototype.reachesEdges = function (streamline) {
    return this.vectorOffScreen(streamline[0]) && this.vectorOffScreen(streamline[streamline.length - 1]);
  };

  WaterGenerator.prototype.vectorOffScreen = function (v) {
    var toOrigin = v.clone().sub(this.origin);
    return toOrigin.x <= 0 || toOrigin.y <= 0 || toOrigin.x >= this.worldDimensions.x || toOrigin.y >= this.worldDimensions.y;
  };

  return WaterGenerator;
}(streamlines_1["default"]);

exports["default"] = WaterGenerator;

},{"./polygon_util":22,"./streamlines":23,"loglevel":7}],27:[function(require,module,exports){
"use strict";

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

var __values = void 0 && (void 0).__values || function (o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var domain_controller_1 = require("./domain_controller");

var graph_1 = require("../impl/graph");

var polygon_finder_1 = require("../impl/polygon_finder");
/**
 * Pseudo 3D buildings
 */


var BuildingModels =
/** @class */
function () {
  function BuildingModels(lots) {
    var e_1, _a;

    this.domainController = domain_controller_1["default"].getInstance();
    this._buildingModels = [];

    try {
      for (var lots_1 = __values(lots), lots_1_1 = lots_1.next(); !lots_1_1.done; lots_1_1 = lots_1.next()) {
        var lot = lots_1_1.value;

        this._buildingModels.push({
          height: Math.random() * 20 + 20,
          lotWorld: lot,
          lotScreen: [],
          roof: [],
          sides: []
        });
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (lots_1_1 && !lots_1_1.done && (_a = lots_1["return"])) _a.call(lots_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }

    this._buildingModels.sort(function (a, b) {
      return a.height - b.height;
    });
  }

  Object.defineProperty(BuildingModels.prototype, "buildingModels", {
    get: function get() {
      return this._buildingModels;
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Recalculated when the camera moves
   */

  BuildingModels.prototype.setBuildingProjections = function () {
    var e_2, _a;

    var _this = this;

    var d = 1000 / this.domainController.zoom;
    var cameraPos = this.domainController.getCameraPosition();

    var _loop_1 = function _loop_1(b) {
      b.lotScreen = b.lotWorld.map(function (v) {
        return _this.domainController.worldToScreen(v.clone());
      });
      b.roof = b.lotScreen.map(function (v) {
        return _this.heightVectorToScreen(v, b.height, d, cameraPos);
      });
      b.sides = this_1.getBuildingSides(b);
    };

    var this_1 = this;

    try {
      for (var _b = __values(this._buildingModels), _c = _b.next(); !_c.done; _c = _b.next()) {
        var b = _c.value;

        _loop_1(b);
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b["return"])) _a.call(_b);
      } finally {
        if (e_2) throw e_2.error;
      }
    }
  };

  BuildingModels.prototype.heightVectorToScreen = function (v, h, d, camera) {
    var scale = d / (d - h); // 0.1

    if (this.domainController.orthographic) {
      var diff = this.domainController.cameraDirection.multiplyScalar(-h * scale);
      return v.clone().add(diff);
    } else {
      return v.clone().sub(camera).multiplyScalar(scale).add(camera);
    }
  };
  /**
   * Get sides of buildings by joining corresponding edges between the roof and ground
   */


  BuildingModels.prototype.getBuildingSides = function (b) {
    var polygons = [];

    for (var i = 0; i < b.lotScreen.length; i++) {
      var next = (i + 1) % b.lotScreen.length;
      polygons.push([b.lotScreen[i], b.lotScreen[next], b.roof[next], b.roof[i]]);
    }

    return polygons;
  };

  return BuildingModels;
}();
/**
 * Finds building lots and optionally pseudo3D buildings
 */


var Buildings =
/** @class */
function () {
  function Buildings(tensorField, folder, redraw, dstep, _animate) {
    var _this = this;

    this.tensorField = tensorField;
    this.redraw = redraw;
    this.dstep = dstep;
    this._animate = _animate;
    this.allStreamlines = [];
    this.domainController = domain_controller_1["default"].getInstance();

    this.preGenerateCallback = function () {};

    this.postGenerateCallback = function () {};

    this._models = new BuildingModels([]);
    this._blocks = [];
    this.buildingParams = {
      maxLength: 20,
      minArea: 50,
      shrinkSpacing: 4,
      chanceNoDivide: 0.05
    };
    folder.add({
      'AddBuildings': function AddBuildings() {
        return _this.generate(_this._animate);
      }
    }, 'AddBuildings');
    folder.add(this.buildingParams, 'minArea');
    folder.add(this.buildingParams, 'shrinkSpacing');
    folder.add(this.buildingParams, 'chanceNoDivide');
    this.polygonFinder = new polygon_finder_1["default"]([], this.buildingParams, this.tensorField);
  }

  Object.defineProperty(Buildings.prototype, "animate", {
    set: function set(v) {
      this._animate = v;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Buildings.prototype, "lots", {
    get: function get() {
      var _this = this;

      return this.polygonFinder.polygons.map(function (p) {
        return p.map(function (v) {
          return _this.domainController.worldToScreen(v.clone());
        });
      });
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Only used when creating the 3D model to 'fake' the roads
   */

  Buildings.prototype.getBlocks = function () {
    var _this = this;

    var g = new graph_1["default"](this.allStreamlines, this.dstep, true);
    var blockParams = Object.assign({}, this.buildingParams);
    blockParams.shrinkSpacing = blockParams.shrinkSpacing / 2;
    var polygonFinder = new polygon_finder_1["default"](g.nodes, blockParams, this.tensorField);
    polygonFinder.findPolygons();
    return polygonFinder.shrink(false).then(function () {
      return polygonFinder.polygons.map(function (p) {
        return p.map(function (v) {
          return _this.domainController.worldToScreen(v.clone());
        });
      });
    });
  };

  Object.defineProperty(Buildings.prototype, "models", {
    get: function get() {
      this._models.setBuildingProjections();

      return this._models.buildingModels;
    },
    enumerable: true,
    configurable: true
  });

  Buildings.prototype.setAllStreamlines = function (s) {
    this.allStreamlines = s;
  };

  Buildings.prototype.reset = function () {
    this.polygonFinder.reset();
    this._models = new BuildingModels([]);
  };

  Buildings.prototype.update = function () {
    return this.polygonFinder.update();
  };
  /**
   * Finds blocks, shrinks and divides them to create building lots
   */


  Buildings.prototype.generate = function (animate) {
    return __awaiter(this, void 0, void 0, function () {
      var g;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            this.preGenerateCallback();
            this._models = new BuildingModels([]);
            g = new graph_1["default"](this.allStreamlines, this.dstep, true);
            this.polygonFinder = new polygon_finder_1["default"](g.nodes, this.buildingParams, this.tensorField);
            this.polygonFinder.findPolygons();
            return [4
            /*yield*/
            , this.polygonFinder.shrink(animate)];

          case 1:
            _a.sent();

            return [4
            /*yield*/
            , this.polygonFinder.divide(animate)];

          case 2:
            _a.sent();

            this.redraw();
            this._models = new BuildingModels(this.polygonFinder.polygons);
            this.postGenerateCallback();
            return [2
            /*return*/
            ];
        }
      });
    });
  };

  Buildings.prototype.setPreGenerateCallback = function (callback) {
    this.preGenerateCallback = callback;
  };

  Buildings.prototype.setPostGenerateCallback = function (callback) {
    this.postGenerateCallback = callback;
  };

  return Buildings;
}();

exports["default"] = Buildings;

},{"../impl/graph":18,"../impl/polygon_finder":21,"./domain_controller":29}],28:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var svg_js_1 = require("@svgdotjs/svg.js");

var util_1 = require("../util");
/**
 * Thin wrapper around HTML canvas, abstracts drawing functions so we can use the RoughJS canvas or the default one
 */


var CanvasWrapper =
/** @class */
function () {
  function CanvasWrapper(canvas, _scale, resizeToWindow) {
    var _this = this;

    if (_scale === void 0) {
      _scale = 1;
    }

    if (resizeToWindow === void 0) {
      resizeToWindow = true;
    }

    this.canvas = canvas;
    this._scale = _scale;
    this.needsUpdate = false;
    this.setDimensions();
    this.resizeCanvas();

    if (resizeToWindow) {
      window.addEventListener('resize', function () {
        _this.setDimensions();

        _this.resizeCanvas();
      });
    }
  }

  CanvasWrapper.prototype.appendSvgNode = function (node) {
    if (this.svgNode) {
      this.svgNode.appendChild(node);
    }
  };

  CanvasWrapper.prototype.createSVG = function (svgElement) {
    this.svgNode = svgElement;
  };

  CanvasWrapper.prototype.setDimensions = function () {
    this._width = window.innerWidth * this._scale;
    this._height = window.innerHeight * this._scale;
  };

  Object.defineProperty(CanvasWrapper.prototype, "width", {
    get: function get() {
      return this._width;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(CanvasWrapper.prototype, "height", {
    get: function get() {
      return this._height;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(CanvasWrapper.prototype, "canvasScale", {
    get: function get() {
      return this._scale;
    },
    set: function set(s) {
      this._scale = s;
      this.setDimensions();
      this.resizeCanvas();
    },
    enumerable: true,
    configurable: true
  });

  CanvasWrapper.prototype.zoomVectors = function (vs) {
    var _this = this;

    if (this._scale === 1) return vs;
    return vs.map(function (v) {
      return v.clone().multiplyScalar(_this._scale);
    });
  };

  CanvasWrapper.prototype.resizeCanvas = function () {
    this.canvas.width = this._width;
    this.canvas.height = this._height;
    this.needsUpdate = true;
  };

  return CanvasWrapper;
}();

exports["default"] = CanvasWrapper;

var DefaultCanvasWrapper =
/** @class */
function (_super) {
  __extends(DefaultCanvasWrapper, _super);

  function DefaultCanvasWrapper(canvas, scale, resizeToWindow) {
    if (scale === void 0) {
      scale = 1;
    }

    if (resizeToWindow === void 0) {
      resizeToWindow = true;
    }

    var _this = _super.call(this, canvas, scale, resizeToWindow) || this;

    _this.ctx = canvas.getContext("2d");
    _this.ctx.fillStyle = 'black';

    _this.ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

    return _this;
  }

  DefaultCanvasWrapper.prototype.createSVG = function (svgElement) {
    _super.prototype.createSVG.call(this, svgElement);

    this.svg = svg_js_1.SVG(svgElement);
  };

  DefaultCanvasWrapper.prototype.setFillStyle = function (colour) {
    this.ctx.fillStyle = colour;
  };

  DefaultCanvasWrapper.prototype.clearCanvas = function () {
    if (this.svgNode) {
      // Expanded to cover whole drawn area
      var startW = window.innerWidth * (util_1["default"].DRAW_INFLATE_AMOUNT - 1) / 2;
      var startH = window.innerHeight * (util_1["default"].DRAW_INFLATE_AMOUNT - 1) / 2;
      this.drawRectangle(-startW, -startH, window.innerWidth * util_1["default"].DRAW_INFLATE_AMOUNT, window.innerHeight * util_1["default"].DRAW_INFLATE_AMOUNT);
    } else {
      this.drawRectangle(0, 0, window.innerWidth, window.innerHeight);
    }
  };

  DefaultCanvasWrapper.prototype.drawFrame = function (left, right, up, down) {
    this.drawRectangle(0, 0, this._width / this._scale, up);
    this.drawRectangle(0, 0, left, this._height / this._scale);
    this.drawRectangle(this._width / this._scale - right, 0, right, this._height / this._scale);
    this.drawRectangle(0, this._height / this._scale - down, this._width / this._scale, down);
  };

  DefaultCanvasWrapper.prototype.drawCityName = function () {
    var fontSize = 50 * this._scale;
    this.ctx.font = "small-caps " + fontSize + "px Verdana";
    this.ctx.textAlign = "center";
    this.ctx.fillText("san francisco", this._width / 2, this._height - (80 * this._scale - fontSize));
  };

  DefaultCanvasWrapper.prototype.drawRectangle = function (x, y, width, height) {
    if (this._scale !== 1) {
      x *= this._scale;
      y *= this._scale;
      width *= this._scale;
      height *= this._scale;
    }

    this.ctx.fillRect(x, y, width, height);

    if (this.svg) {
      this.svg.rect({
        fill: this.ctx.fillStyle,
        'fill-opacity': 1,
        stroke: this.ctx.strokeStyle,
        'stroke-width': this.ctx.lineWidth,
        x: x,
        y: y,
        width: width,
        height: height
      });
    }
  };

  DefaultCanvasWrapper.prototype.drawPolygon = function (polygon) {
    if (polygon.length === 0) {
      return;
    }

    polygon = this.zoomVectors(polygon);
    this.ctx.beginPath();
    this.ctx.moveTo(polygon[0].x, polygon[0].y);

    for (var i = 1; i < polygon.length; i++) {
      this.ctx.lineTo(polygon[i].x, polygon[i].y);
    }

    this.ctx.lineTo(polygon[0].x, polygon[0].y);
    this.ctx.fill();
    this.ctx.stroke();

    if (this.svg) {
      var vectorArray = polygon.map(function (v) {
        return [v.x, v.y];
      });
      vectorArray.push(vectorArray[0]);
      this.svg.polyline(vectorArray).attr({
        fill: this.ctx.fillStyle,
        'fill-opacity': 1,
        stroke: this.ctx.strokeStyle,
        'stroke-width': this.ctx.lineWidth
      });
    }
  };

  DefaultCanvasWrapper.prototype.drawCircle = function (centre, radius) {
    var TAU = 2 * Math.PI;
    this.ctx.beginPath();
    this.ctx.arc(centre.x, centre.y, radius, 0, TAU);
    this.ctx.fill();
  };

  DefaultCanvasWrapper.prototype.drawSquare = function (centre, radius) {
    this.drawRectangle(centre.x - radius, centre.y - radius, 2 * radius, 2 * radius);
  };

  DefaultCanvasWrapper.prototype.setLineWidth = function (width) {
    if (this._scale !== 1) {
      width *= this._scale;
    }

    this.ctx.lineWidth = width;
  };

  DefaultCanvasWrapper.prototype.setStrokeStyle = function (colour) {
    this.ctx.strokeStyle = colour;
  };

  DefaultCanvasWrapper.prototype.drawPolyline = function (line) {
    if (line.length < 2) {
      return;
    }

    line = this.zoomVectors(line);
    this.ctx.beginPath();
    this.ctx.moveTo(line[0].x, line[0].y);

    for (var i = 1; i < line.length; i++) {
      this.ctx.lineTo(line[i].x, line[i].y);
    }

    this.ctx.stroke();

    if (this.svg) {
      var vectorArray = line.map(function (v) {
        return [v.x, v.y];
      });
      this.svg.polyline(vectorArray).attr({
        'fill-opacity': 0,
        stroke: this.ctx.strokeStyle,
        'stroke-width': this.ctx.lineWidth
      });
    }
  };

  return DefaultCanvasWrapper;
}(CanvasWrapper);

exports.DefaultCanvasWrapper = DefaultCanvasWrapper;

var RoughCanvasWrapper =
/** @class */
function (_super) {
  __extends(RoughCanvasWrapper, _super);

  function RoughCanvasWrapper(canvas, scale, resizeToWindow) {
    if (scale === void 0) {
      scale = 1;
    }

    if (resizeToWindow === void 0) {
      resizeToWindow = true;
    }

    var _this = _super.call(this, canvas, scale, resizeToWindow) || this;

    _this.r = require('roughjs/bundled/rough.cjs');
    _this.options = {
      roughness: 1,
      bowing: 1,
      stroke: '#000000',
      strokeWidth: 1,
      fill: '#000000',
      fillStyle: 'solid'
    };
    _this.rc = _this.r.canvas(canvas);
    return _this;
  }

  RoughCanvasWrapper.prototype.createSVG = function (svgElement) {
    _super.prototype.createSVG.call(this, svgElement);

    this.rc = this.r.svg(this.svgNode);
  };

  RoughCanvasWrapper.prototype.drawFrame = function (left, right, up, down) {};

  RoughCanvasWrapper.prototype.setOptions = function (options) {
    if (options.strokeWidth) {
      options.strokeWidth *= this._scale;
    }

    Object.assign(this.options, options);
  };

  RoughCanvasWrapper.prototype.clearCanvas = function () {
    if (this.svgNode) {
      // Expanded to cover whole drawn area
      var startW = window.innerWidth * (util_1["default"].DRAW_INFLATE_AMOUNT - 1) / 2;
      var startH = window.innerHeight * (util_1["default"].DRAW_INFLATE_AMOUNT - 1) / 2;
      this.drawRectangle(-startW, -startH, window.innerWidth * util_1["default"].DRAW_INFLATE_AMOUNT, window.innerHeight * util_1["default"].DRAW_INFLATE_AMOUNT);
    } else {
      this.drawRectangle(0, 0, window.innerWidth, window.innerHeight);
    }
  };

  RoughCanvasWrapper.prototype.drawRectangle = function (x, y, width, height) {
    if (this._scale !== 1) {
      x *= this._scale;
      y *= this._scale;
      width *= this._scale;
      height *= this._scale;
    }

    this.appendSvgNode(this.rc.rectangle(x, y, width, height, this.options));
  };

  RoughCanvasWrapper.prototype.drawPolygon = function (polygon) {
    var _this = this;

    if (polygon.length === 0) {
      return;
    }

    if (this._scale !== 1) {
      polygon = polygon.map(function (v) {
        return v.clone().multiplyScalar(_this._scale);
      });
    }

    this.appendSvgNode(this.rc.polygon(polygon.map(function (v) {
      return [v.x, v.y];
    }), this.options));
  };

  RoughCanvasWrapper.prototype.drawSquare = function (centre, radius) {
    var prevStroke = this.options.stroke;
    this.options.stroke = 'none';
    this.drawRectangle(centre.x - radius, centre.y - radius, 2 * radius, 2 * radius);
    this.options.stroke = prevStroke;
  };

  RoughCanvasWrapper.prototype.drawPolyline = function (line) {
    var _this = this;

    if (line.length < 2) {
      return;
    }

    if (this._scale !== 1) {
      line = line.map(function (v) {
        return v.clone().multiplyScalar(_this._scale);
      });
    }

    this.appendSvgNode(this.rc.linearPath(line.map(function (v) {
      return [v.x, v.y];
    }), this.options));
  };

  return RoughCanvasWrapper;
}(CanvasWrapper);

exports.RoughCanvasWrapper = RoughCanvasWrapper;

},{"../util":36,"@svgdotjs/svg.js":1,"roughjs/bundled/rough.cjs":11}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var vector_1 = require("../vector");

var util_1 = require("../util");
/**
 * Singleton
 * Controls panning and zooming
 */


var DomainController =
/** @class */
function () {
  function DomainController() {
    var _this = this;

    this.ZOOM_SPEED = 0.96;
    this.SCROLL_DELAY = 100; // Location of screen origin in world space

    this._origin = vector_1["default"].zeroVector(); // Screen-space width and height

    this._screenDimensions = vector_1["default"].zeroVector(); // Ratio of screen pixels to world pixels

    this._zoom = 1;

    this.zoomCallback = function () {};

    this.lastScrolltime = -this.SCROLL_DELAY;
    this.refreshedAfterScroll = false;
    this._cameraDirection = vector_1["default"].zeroVector();
    this._orthographic = false; // Set after pan or zoom

    this.moved = false;
    this.setScreenDimensions();
    window.addEventListener('resize', function () {
      return _this.setScreenDimensions();
    });
    window.addEventListener('wheel', function (e) {
      if (e.target.id === util_1["default"].CANVAS_ID) {
        _this.lastScrolltime = Date.now();
        _this.refreshedAfterScroll = false;
        var delta = e.deltaY; // TODO scale by value of delta

        if (delta > 0) {
          _this.zoom = _this._zoom * _this.ZOOM_SPEED;
        } else {
          _this.zoom = _this._zoom / _this.ZOOM_SPEED;
        }
      }
    });
  }

  Object.defineProperty(DomainController.prototype, "isScrolling", {
    /**
     * Used to stop drawing buildings while scrolling for certain styles
     * to keep the framerate up
     */
    get: function get() {
      return Date.now() - this.lastScrolltime < this.SCROLL_DELAY;
    },
    enumerable: true,
    configurable: true
  });

  DomainController.prototype.setScreenDimensions = function () {
    this.moved = true;

    this._screenDimensions.setX(window.innerWidth);

    this._screenDimensions.setY(window.innerHeight);
  };

  DomainController.getInstance = function () {
    if (!DomainController.instance) {
      DomainController.instance = new DomainController();
    }

    return DomainController.instance;
  };
  /**
   * @param {Vector} delta in world space
   */


  DomainController.prototype.pan = function (delta) {
    this.moved = true;

    this._origin.sub(delta);
  };

  Object.defineProperty(DomainController.prototype, "origin", {
    /**
     * Screen origin in world space
     */
    get: function get() {
      return this._origin.clone();
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(DomainController.prototype, "zoom", {
    get: function get() {
      return this._zoom;
    },
    set: function set(z) {
      if (z >= 0.3 && z <= 20) {
        this.moved = true;
        var oldWorldSpaceMidpoint = this.origin.add(this.worldDimensions.divideScalar(2));
        this._zoom = z;
        var newWorldSpaceMidpoint = this.origin.add(this.worldDimensions.divideScalar(2));
        this.pan(newWorldSpaceMidpoint.sub(oldWorldSpaceMidpoint));
        this.zoomCallback();
      }
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(DomainController.prototype, "screenDimensions", {
    get: function get() {
      return this._screenDimensions.clone();
    },
    set: function set(v) {
      this.moved = true;

      this._screenDimensions.copy(v);
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(DomainController.prototype, "worldDimensions", {
    /**
     * @return {Vector} world-space w/h visible on screen
     */
    get: function get() {
      return this.screenDimensions.divideScalar(this._zoom);
    },
    enumerable: true,
    configurable: true
  });

  DomainController.prototype.onScreen = function (v) {
    var screenSpace = this.worldToScreen(v.clone());
    return screenSpace.x >= 0 && screenSpace.y >= 0 && screenSpace.x <= this.screenDimensions.x && screenSpace.y <= this.screenDimensions.y;
  };

  Object.defineProperty(DomainController.prototype, "orthographic", {
    get: function get() {
      return this._orthographic;
    },
    set: function set(v) {
      this._orthographic = v;
      this.moved = true;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(DomainController.prototype, "cameraDirection", {
    get: function get() {
      return this._cameraDirection.clone();
    },
    set: function set(v) {
      this._cameraDirection = v; // Screen update

      this.moved = true;
    },
    enumerable: true,
    configurable: true
  });

  DomainController.prototype.getCameraPosition = function () {
    var centre = new vector_1["default"](this._screenDimensions.x / 2, this._screenDimensions.y / 2);

    if (this._orthographic) {
      return centre.add(centre.clone().multiply(this._cameraDirection).multiplyScalar(100));
    }

    return centre.add(centre.clone().multiply(this._cameraDirection)); // this.screenDimensions.divideScalar(2);
  };

  DomainController.prototype.setZoomUpdate = function (callback) {
    this.zoomCallback = callback;
  };
  /**
   * Edits vector
   */


  DomainController.prototype.zoomToWorld = function (v) {
    return v.divideScalar(this._zoom);
  };
  /**
   * Edits vector
   */


  DomainController.prototype.zoomToScreen = function (v) {
    return v.multiplyScalar(this._zoom);
  };
  /**
   * Edits vector
   */


  DomainController.prototype.screenToWorld = function (v) {
    return this.zoomToWorld(v).add(this._origin);
  };
  /**
   * Edits vector
   */


  DomainController.prototype.worldToScreen = function (v) {
    return this.zoomToScreen(v.sub(this._origin));
  };

  return DomainController;
}();

exports["default"] = DomainController;

},{"../util":36,"../vector":37}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var interactjs_1 = require("interactjs");

var util_1 = require("../util");

var Vector_1 = require("../Vector");

var domain_controller_1 = require("./domain_controller");
/**
* Register multiple centre points
* Closest one to mouse click will be selected to drag
* Up to caller to actually move their centre point via callback
*/


var DragController =
/** @class */
function () {
  function DragController(gui) {
    this.gui = gui; // How close to drag handle pointer needs to be

    this.MIN_DRAG_DISTANCE = 50;
    this.draggables = [];
    this.currentlyDragging = null; // Tensor field

    this._isDragging = false;
    this.disabled = false;
    this.domainController = domain_controller_1["default"].getInstance();
    interactjs_1["default"]("#" + util_1["default"].CANVAS_ID).draggable({
      onstart: this.dragStart.bind(this),
      onmove: this.dragMove.bind(this),
      onend: this.dragEnd.bind(this),
      cursorChecker: this.getCursor.bind(this)
    });
  }

  DragController.prototype.setDragDisabled = function (disable) {
    this.disabled = disable;
  };
  /**
   * Change cursor style
   */


  DragController.prototype.getCursor = function (action, interactable, element, interacting) {
    if (interacting) return 'grabbing';
    return 'grab';
  };

  DragController.prototype.dragStart = function (event) {
    var _this = this;

    this._isDragging = true; // Transform screen space to world space

    var origin = this.domainController.screenToWorld(new Vector_1["default"](event.x0, event.y0));
    var closestDistance = Infinity;
    this.draggables.forEach(function (draggable) {
      var d = draggable.getCentre().distanceTo(origin);

      if (d < closestDistance) {
        closestDistance = d;
        _this.currentlyDragging = draggable;
      }
    }); // Zoom screen size to world size for consistent drag distance while zoomed in

    var scaledDragDistance = this.MIN_DRAG_DISTANCE / this.domainController.zoom;

    if (closestDistance > scaledDragDistance) {
      this.currentlyDragging = null;
    } else {
      this.currentlyDragging.startListener();
    }
  };

  DragController.prototype.dragMove = function (event) {
    var delta = new Vector_1["default"](event.delta.x, event.delta.y);
    this.domainController.zoomToWorld(delta);

    if (!this.disabled && this.currentlyDragging !== null) {
      // Drag field
      this.currentlyDragging.moveListener(delta);
    } else {
      // Move map
      this.domainController.pan(delta);
    }
  };

  DragController.prototype.dragEnd = function () {
    this._isDragging = false;
    this.domainController.pan(Vector_1["default"].zeroVector()); // Triggers canvas update

    this.currentlyDragging = null;
    util_1["default"].updateGui(this.gui);
  };

  Object.defineProperty(DragController.prototype, "isDragging", {
    get: function get() {
      return this._isDragging;
    },
    enumerable: true,
    configurable: true
  });
  /**
   * @param {(() => Vector)} Gets centre point
   * @param {((v: Vector) => void)} Called on move with delta vector
   * @param {(() => void)} Called on start
   * @returns {(() => void)} Function to deregister callback
   */

  DragController.prototype.register = function (getCentre, onMove, onStart) {
    var _this = this;

    var draggable = {
      getCentre: getCentre,
      moveListener: onMove,
      startListener: onStart
    };
    this.draggables.push(draggable);
    return function () {
      var index = _this.draggables.indexOf(draggable);

      if (index >= 0) {
        _this.draggables.splice(index, 1);
      }
    }.bind(this);
  };

  return DragController;
}();

exports["default"] = DragController;

},{"../Vector":16,"../util":36,"./domain_controller":29,"interactjs":4}],31:[function(require,module,exports){
"use strict";

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

var __read = void 0 && (void 0).__read || function (o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
};

var __spread = void 0 && (void 0).__spread || function () {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read(arguments[i]));
  }

  return ar;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var domain_controller_1 = require("./domain_controller");

var integrator_1 = require("../impl/integrator");

var graph_1 = require("../impl/graph");

var road_gui_1 = require("./road_gui");

var water_gui_1 = require("./water_gui");

var polygon_finder_1 = require("../impl/polygon_finder");

var style_1 = require("./style");

var buildings_1 = require("./buildings");

var polygon_util_1 = require("../impl/polygon_util");
/**
 * Handles Map folder, glues together impl
 */


var MainGUI =
/** @class */
function () {
  function MainGUI(guiFolder, tensorField, closeTensorFolder) {
    var _this = this;

    this.guiFolder = guiFolder;
    this.tensorField = tensorField;
    this.closeTensorFolder = closeTensorFolder;
    this.numBigParks = 2;
    this.numSmallParks = 0;
    this.clusterBigParks = false;
    this.domainController = domain_controller_1["default"].getInstance();
    this.intersections = [];
    this.bigParks = [];
    this.smallParks = [];
    this.animate = true;
    this.animationSpeed = 30;
    this.minorParams = {
      dsep: 20,
      dtest: 15,
      dstep: 1,
      dlookahead: 40,
      dcirclejoin: 5,
      joinangle: 0.1,
      pathIterations: 1000,
      seedTries: 300,
      simplifyTolerance: 0.5,
      collideEarly: 0
    };
    this.redraw = true;
    guiFolder.add(this, 'generateEverything'); // guiFolder.add(this, 'simpleBenchMark');

    var animateController = guiFolder.add(this, 'animate');
    guiFolder.add(this, 'animationSpeed');
    this.coastlineParams = Object.assign({
      coastNoise: {
        noiseEnabled: true,
        noiseSize: 30,
        noiseAngle: 20
      },
      riverNoise: {
        noiseEnabled: true,
        noiseSize: 30,
        noiseAngle: 20
      },
      riverBankSize: 10,
      riverSize: 30
    }, this.minorParams);
    this.coastlineParams.pathIterations = 10000;
    this.coastlineParams.simplifyTolerance = 10;
    this.majorParams = Object.assign({}, this.minorParams);
    this.majorParams.dsep = 100;
    this.majorParams.dtest = 30;
    this.majorParams.dlookahead = 200;
    this.majorParams.collideEarly = 0;
    this.mainParams = Object.assign({}, this.minorParams);
    this.mainParams.dsep = 400;
    this.mainParams.dtest = 200;
    this.mainParams.dlookahead = 500;
    this.mainParams.collideEarly = 0;
    var integrator = new integrator_1.RK4Integrator(tensorField, this.minorParams);

    var redraw = function redraw() {
      return _this.redraw = true;
    };

    this.coastline = new water_gui_1["default"](tensorField, this.coastlineParams, integrator, this.guiFolder, closeTensorFolder, 'Water', redraw).initFolder();
    this.mainRoads = new road_gui_1["default"](this.mainParams, integrator, this.guiFolder, closeTensorFolder, 'Main', redraw).initFolder();
    this.majorRoads = new road_gui_1["default"](this.majorParams, integrator, this.guiFolder, closeTensorFolder, 'Major', redraw, this.animate).initFolder();
    this.minorRoads = new road_gui_1["default"](this.minorParams, integrator, this.guiFolder, closeTensorFolder, 'Minor', redraw, this.animate).initFolder();
    var parks = guiFolder.addFolder('Parks');
    parks.add({
      Generate: function Generate() {
        _this.buildings.reset();

        _this.addParks();

        _this.redraw = true;
      }
    }, 'Generate');
    parks.add(this, 'clusterBigParks');
    parks.add(this, 'numBigParks');
    parks.add(this, 'numSmallParks');
    var buildingsFolder = guiFolder.addFolder('Buildings');
    this.buildings = new buildings_1["default"](tensorField, buildingsFolder, redraw, this.minorParams.dstep, this.animate);
    this.buildings.setPreGenerateCallback(function () {
      var allStreamlines = [];
      allStreamlines.push.apply(allStreamlines, __spread(_this.mainRoads.allStreamlines));
      allStreamlines.push.apply(allStreamlines, __spread(_this.majorRoads.allStreamlines));
      allStreamlines.push.apply(allStreamlines, __spread(_this.minorRoads.allStreamlines));
      allStreamlines.push.apply(allStreamlines, __spread(_this.coastline.streamlinesWithSecondaryRoad));

      _this.buildings.setAllStreamlines(allStreamlines);
    });
    animateController.onChange(function (b) {
      _this.majorRoads.animate = b;
      _this.minorRoads.animate = b;
      _this.buildings.animate = b;
    });
    this.minorRoads.setExistingStreamlines([this.coastline, this.mainRoads, this.majorRoads]);
    this.majorRoads.setExistingStreamlines([this.coastline, this.mainRoads]);
    this.mainRoads.setExistingStreamlines([this.coastline]);
    this.coastline.setPreGenerateCallback(function () {
      _this.mainRoads.clearStreamlines();

      _this.majorRoads.clearStreamlines();

      _this.minorRoads.clearStreamlines();

      _this.bigParks = [];
      _this.smallParks = [];

      _this.buildings.reset();

      tensorField.parks = [];
      tensorField.sea = [];
      tensorField.river = [];
    });
    this.mainRoads.setPreGenerateCallback(function () {
      _this.majorRoads.clearStreamlines();

      _this.minorRoads.clearStreamlines();

      _this.bigParks = [];
      _this.smallParks = [];

      _this.buildings.reset();

      tensorField.parks = [];
      tensorField.ignoreRiver = true;
    });
    this.mainRoads.setPostGenerateCallback(function () {
      tensorField.ignoreRiver = false;
    });
    this.majorRoads.setPreGenerateCallback(function () {
      _this.minorRoads.clearStreamlines();

      _this.bigParks = [];
      _this.smallParks = [];

      _this.buildings.reset();

      tensorField.parks = [];
      tensorField.ignoreRiver = true;
    });
    this.majorRoads.setPostGenerateCallback(function () {
      tensorField.ignoreRiver = false;

      _this.addParks();

      _this.redraw = true;
    });
    this.minorRoads.setPreGenerateCallback(function () {
      _this.buildings.reset();

      _this.smallParks = [];
      tensorField.parks = _this.bigParks;
    });
    this.minorRoads.setPostGenerateCallback(function () {
      _this.addParks();
    });
  }

  MainGUI.prototype.addParks = function () {
    var _a, _b, _c;

    var g = new graph_1["default"](this.majorRoads.allStreamlines.concat(this.mainRoads.allStreamlines).concat(this.minorRoads.allStreamlines), this.minorParams.dstep);
    this.intersections = g.intersections;
    var p = new polygon_finder_1["default"](g.nodes, {
      maxLength: 20,
      minArea: 80,
      shrinkSpacing: 4,
      chanceNoDivide: 1
    }, this.tensorField);
    p.findPolygons();
    var polygons = p.polygons;

    if (this.minorRoads.allStreamlines.length === 0) {
      // Big parks
      this.bigParks = [];
      this.smallParks = [];

      if (polygons.length > this.numBigParks) {
        if (this.clusterBigParks) {
          // Group in adjacent polygons 
          var parkIndex = Math.floor(Math.random() * (polygons.length - this.numBigParks));

          for (var i = parkIndex; i < parkIndex + this.numBigParks; i++) {
            this.bigParks.push(polygons[i]);
          }
        } else {
          for (var i = 0; i < this.numBigParks; i++) {
            var parkIndex = Math.floor(Math.random() * polygons.length);
            this.bigParks.push(polygons[parkIndex]);
          }
        }
      } else {
        (_a = this.bigParks).push.apply(_a, __spread(polygons));
      }
    } else {
      // Small parks
      this.smallParks = [];

      for (var i = 0; i < this.numSmallParks; i++) {
        var parkIndex = Math.floor(Math.random() * polygons.length);
        this.smallParks.push(polygons[parkIndex]);
      }
    }

    this.tensorField.parks = [];

    (_b = this.tensorField.parks).push.apply(_b, __spread(this.bigParks));

    (_c = this.tensorField.parks).push.apply(_c, __spread(this.smallParks));
  };

  MainGUI.prototype.generateEverything = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            this.coastline.generateRoads();
            return [4
            /*yield*/
            , this.mainRoads.generateRoads()];

          case 1:
            _a.sent();

            return [4
            /*yield*/
            , this.majorRoads.generateRoads(this.animate)];

          case 2:
            _a.sent();

            return [4
            /*yield*/
            , this.minorRoads.generateRoads(this.animate)];

          case 3:
            _a.sent();

            this.redraw = true;
            return [4
            /*yield*/
            , this.buildings.generate(this.animate)];

          case 4:
            _a.sent();

            return [2
            /*return*/
            ];
        }
      });
    });
  };

  MainGUI.prototype.update = function () {
    var continueUpdate = true;
    var start = performance.now();

    while (continueUpdate && performance.now() - start < this.animationSpeed) {
      var minorChanged = this.minorRoads.update();
      var majorChanged = this.majorRoads.update();
      var mainChanged = this.mainRoads.update();
      var buildingsChanged = this.buildings.update();
      continueUpdate = minorChanged || majorChanged || mainChanged || buildingsChanged;
    }

    this.redraw = this.redraw || continueUpdate;
  };

  MainGUI.prototype.draw = function (style, forceDraw, customCanvas) {
    var _a, _b;

    var _this = this;

    if (forceDraw === void 0) {
      forceDraw = false;
    }

    if (!style.needsUpdate && !forceDraw && !this.redraw && !this.domainController.moved) {
      return;
    }

    style.needsUpdate = false;
    this.domainController.moved = false;
    this.redraw = false;
    style.seaPolygon = this.coastline.seaPolygon;
    style.coastline = this.coastline.coastline;
    style.river = this.coastline.river;
    style.lots = this.buildings.lots;

    if (style instanceof style_1.DefaultStyle && style.showBuildingModels || style instanceof style_1.RoughStyle) {
      style.buildingModels = this.buildings.models;
    }

    style.parks = [];

    (_a = style.parks).push.apply(_a, __spread(this.bigParks.map(function (p) {
      return p.map(function (v) {
        return _this.domainController.worldToScreen(v.clone());
      });
    })));

    (_b = style.parks).push.apply(_b, __spread(this.smallParks.map(function (p) {
      return p.map(function (v) {
        return _this.domainController.worldToScreen(v.clone());
      });
    })));

    style.minorRoads = this.minorRoads.roads;
    style.majorRoads = this.majorRoads.roads;
    style.mainRoads = this.mainRoads.roads;
    style.coastlineRoads = this.coastline.roads;
    style.secondaryRiver = this.coastline.secondaryRiver;
    style.draw(customCanvas);
  };

  MainGUI.prototype.roadsEmpty = function () {
    return this.majorRoads.roadsEmpty() && this.minorRoads.roadsEmpty() && this.mainRoads.roadsEmpty() && this.coastline.roadsEmpty();
  };

  Object.defineProperty(MainGUI.prototype, "seaPolygon", {
    // OBJ Export methods
    get: function get() {
      return this.coastline.seaPolygon;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MainGUI.prototype, "riverPolygon", {
    get: function get() {
      return this.coastline.river;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MainGUI.prototype, "buildingModels", {
    get: function get() {
      return this.buildings.models;
    },
    enumerable: true,
    configurable: true
  });

  MainGUI.prototype.getBlocks = function () {
    return this.buildings.getBlocks();
  };

  Object.defineProperty(MainGUI.prototype, "minorRoadPolygons", {
    get: function get() {
      var _this = this;

      return this.minorRoads.roads.map(function (r) {
        return polygon_util_1["default"].resizeGeometry(r, 1 * _this.domainController.zoom, false);
      });
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MainGUI.prototype, "majorRoadPolygons", {
    get: function get() {
      var _this = this;

      return this.majorRoads.roads.concat([this.coastline.secondaryRiver]).map(function (r) {
        return polygon_util_1["default"].resizeGeometry(r, 2 * _this.domainController.zoom, false);
      });
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MainGUI.prototype, "mainRoadPolygons", {
    get: function get() {
      var _this = this;

      return this.mainRoads.roads.concat(this.coastline.roads).map(function (r) {
        return polygon_util_1["default"].resizeGeometry(r, 2.5 * _this.domainController.zoom, false);
      });
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(MainGUI.prototype, "coastlinePolygon", {
    get: function get() {
      return polygon_util_1["default"].resizeGeometry(this.coastline.coastline, 15 * this.domainController.zoom, false);
    },
    enumerable: true,
    configurable: true
  });
  return MainGUI;
}();

exports["default"] = MainGUI;

},{"../impl/graph":18,"../impl/integrator":20,"../impl/polygon_finder":21,"../impl/polygon_util":22,"./buildings":27,"./domain_controller":29,"./road_gui":32,"./style":33,"./water_gui":35}],32:[function(require,module,exports){
"use strict";

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};

var __values = void 0 && (void 0).__values || function (o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var domain_controller_1 = require("./domain_controller");

var util_1 = require("../util");

var streamlines_1 = require("../impl/streamlines");
/**
 * Handles creation of roads
 */


var RoadGUI =
/** @class */
function () {
  function RoadGUI(params, integrator, guiFolder, closeTensorFolder, folderName, redraw, _animate) {
    var _this = this;

    if (_animate === void 0) {
      _animate = false;
    }

    this.params = params;
    this.integrator = integrator;
    this.guiFolder = guiFolder;
    this.closeTensorFolder = closeTensorFolder;
    this.folderName = folderName;
    this.redraw = redraw;
    this._animate = _animate;
    this.existingStreamlines = [];
    this.domainController = domain_controller_1["default"].getInstance();

    this.preGenerateCallback = function () {};

    this.postGenerateCallback = function () {};

    this.streamlinesInProgress = false;
    this.streamlines = new streamlines_1["default"](this.integrator, this.domainController.origin, this.domainController.worldDimensions, this.params); // Update path iterations based on window size

    this.setPathIterations();
    window.addEventListener('resize', function () {
      return _this.setPathIterations();
    });
  }

  RoadGUI.prototype.initFolder = function () {
    var _this = this;

    var roadGUI = {
      Generate: function Generate() {
        return _this.generateRoads(_this._animate).then(function () {
          return _this.redraw();
        });
      },
      JoinDangling: function JoinDangling() {
        _this.streamlines.joinDanglingStreamlines();

        _this.redraw();
      }
    };
    var folder = this.guiFolder.addFolder(this.folderName);
    folder.add(roadGUI, 'Generate'); // folder.add(roadGUI, 'JoinDangling');

    var paramsFolder = folder.addFolder('Params');
    paramsFolder.add(this.params, 'dsep');
    paramsFolder.add(this.params, 'dtest');
    var devParamsFolder = paramsFolder.addFolder('Dev');
    this.addDevParamsToFolder(this.params, devParamsFolder);
    return this;
  };

  Object.defineProperty(RoadGUI.prototype, "animate", {
    set: function set(b) {
      this._animate = b;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(RoadGUI.prototype, "allStreamlines", {
    get: function get() {
      return this.streamlines.allStreamlinesSimple;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(RoadGUI.prototype, "roads", {
    get: function get() {
      var _this = this; // For drawing not generation, probably fine to leave map


      return this.streamlines.allStreamlinesSimple.map(function (s) {
        return s.map(function (v) {
          return _this.domainController.worldToScreen(v.clone());
        });
      });
    },
    enumerable: true,
    configurable: true
  });

  RoadGUI.prototype.roadsEmpty = function () {
    return this.streamlines.allStreamlinesSimple.length === 0;
  };

  RoadGUI.prototype.setExistingStreamlines = function (existingStreamlines) {
    this.existingStreamlines = existingStreamlines;
  };

  RoadGUI.prototype.setPreGenerateCallback = function (callback) {
    this.preGenerateCallback = callback;
  };

  RoadGUI.prototype.setPostGenerateCallback = function (callback) {
    this.postGenerateCallback = callback;
  };

  RoadGUI.prototype.clearStreamlines = function () {
    this.streamlines.clearStreamlines();
  };

  RoadGUI.prototype.generateRoads = function (animate) {
    if (animate === void 0) {
      animate = false;
    }

    return __awaiter(this, void 0, void 0, function () {
      var _a, _b, s;

      var e_1, _c;

      var _this = this;

      return __generator(this, function (_d) {
        this.preGenerateCallback();
        this.domainController.zoom = this.domainController.zoom / util_1["default"].DRAW_INFLATE_AMOUNT;
        this.streamlines = new streamlines_1["default"](this.integrator, this.domainController.origin, this.domainController.worldDimensions, Object.assign({}, this.params));
        this.domainController.zoom = this.domainController.zoom * util_1["default"].DRAW_INFLATE_AMOUNT;

        try {
          for (_a = __values(this.existingStreamlines), _b = _a.next(); !_b.done; _b = _a.next()) {
            s = _b.value;
            this.streamlines.addExistingStreamlines(s.streamlines);
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (_b && !_b.done && (_c = _a["return"])) _c.call(_a);
          } finally {
            if (e_1) throw e_1.error;
          }
        }

        this.closeTensorFolder();
        this.redraw();
        return [2
        /*return*/
        , this.streamlines.createAllStreamlines(animate).then(function () {
          return _this.postGenerateCallback();
        })];
      });
    });
  };
  /**
   * Returns true if streamlines changes
   */


  RoadGUI.prototype.update = function () {
    return this.streamlines.update();
  };

  RoadGUI.prototype.addDevParamsToFolder = function (params, folder) {
    folder.add(params, 'pathIterations');
    folder.add(params, 'seedTries');
    folder.add(params, 'dstep');
    folder.add(params, 'dlookahead');
    folder.add(params, 'dcirclejoin');
    folder.add(params, 'joinangle');
    folder.add(params, 'simplifyTolerance');
    folder.add(params, 'collideEarly');
  };
  /**
   * Sets path iterations so that a road can cover the screen
   */


  RoadGUI.prototype.setPathIterations = function () {
    var max = 1.5 * Math.max(window.innerWidth, window.innerHeight);
    this.params.pathIterations = max / this.params.dstep;
    util_1["default"].updateGui(this.guiFolder);
  };

  return RoadGUI;
}();

exports["default"] = RoadGUI;

},{"../impl/streamlines":23,"../util":36,"./domain_controller":29}],33:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __values = void 0 && (void 0).__values || function (o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log = require("loglevel");

var canvas_wrapper_1 = require("./canvas_wrapper");

var util_1 = require("../util");

var domain_controller_1 = require("./domain_controller");
/**
 * Controls how screen-space data is drawn
 */


var Style =
/** @class */
function () {
  function Style(dragController, colourScheme) {
    this.dragController = dragController;
    this.colourScheme = colourScheme;
    this.domainController = domain_controller_1["default"].getInstance(); // Polygons

    this.seaPolygon = [];
    this.lots = [];
    this.buildingModels = [];
    this.parks = []; // Polylines

    this.coastline = [];
    this.river = [];
    this.secondaryRiver = [];
    this.minorRoads = [];
    this.majorRoads = [];
    this.mainRoads = [];
    this.coastlineRoads = [];
    if (!colourScheme.bgColour) log.error("ColourScheme Error - bgColour not defined");
    if (!colourScheme.seaColour) log.error("ColourScheme Error - seaColour not defined");
    if (!colourScheme.minorRoadColour) log.error("ColourScheme Error - minorRoadColour not defined"); // Default colourscheme cascade

    if (!colourScheme.bgColourIn) colourScheme.bgColourIn = colourScheme.bgColour;
    if (!colourScheme.buildingColour) colourScheme.buildingColour = colourScheme.bgColour;
    if (!colourScheme.buildingStroke) colourScheme.buildingStroke = colourScheme.bgColour;
    if (!colourScheme.grassColour) colourScheme.grassColour = colourScheme.bgColour;
    if (!colourScheme.minorRoadOutline) colourScheme.minorRoadOutline = colourScheme.minorRoadColour;
    if (!colourScheme.majorRoadColour) colourScheme.majorRoadColour = colourScheme.minorRoadColour;
    if (!colourScheme.majorRoadOutline) colourScheme.majorRoadOutline = colourScheme.minorRoadOutline;
    if (!colourScheme.mainRoadColour) colourScheme.mainRoadColour = colourScheme.majorRoadColour;
    if (!colourScheme.mainRoadOutline) colourScheme.mainRoadOutline = colourScheme.majorRoadOutline;
    if (!colourScheme.outlineSize) colourScheme.outlineSize = 1;
    if (!colourScheme.zoomBuildings) colourScheme.zoomBuildings = false;
    if (!colourScheme.buildingModels) colourScheme.buildingModels = false;
    if (!colourScheme.minorWidth) colourScheme.minorWidth = 2;
    if (!colourScheme.majorWidth) colourScheme.majorWidth = 4;
    if (!colourScheme.mainWidth) colourScheme.mainWidth = 5;
    if (!colourScheme.mainWidth) colourScheme.mainWidth = 5;
    if (!colourScheme.frameColour) colourScheme.frameColour = colourScheme.bgColour;
    if (!colourScheme.frameTextColour) colourScheme.frameTextColour = colourScheme.minorRoadOutline;

    if (!colourScheme.buildingSideColour) {
      var parsedRgb = util_1["default"].parseCSSColor(colourScheme.buildingColour).map(function (v) {
        return Math.max(0, v - 40);
      });

      if (parsedRgb) {
        colourScheme.buildingSideColour = "rgb(" + parsedRgb[0] + "," + parsedRgb[1] + "," + parsedRgb[2] + ")";
      } else {
        colourScheme.buildingSideColour = colourScheme.buildingColour;
      }
    }
  }

  Style.prototype.update = function () {};

  Object.defineProperty(Style.prototype, "zoomBuildings", {
    set: function set(b) {
      this.colourScheme.zoomBuildings = b;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Style.prototype, "showBuildingModels", {
    get: function get() {
      return this.colourScheme.buildingModels;
    },
    set: function set(b) {
      this.colourScheme.buildingModels = b;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Style.prototype, "canvasScale", {
    set: function set(scale) {
      this.canvas.canvasScale = scale;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Style.prototype, "needsUpdate", {
    get: function get() {
      return this.canvas.needsUpdate;
    },
    set: function set(n) {
      this.canvas.needsUpdate = n;
    },
    enumerable: true,
    configurable: true
  });
  return Style;
}();

exports["default"] = Style;

var DefaultStyle =
/** @class */
function (_super) {
  __extends(DefaultStyle, _super);

  function DefaultStyle(c, dragController, colourScheme, heightmap) {
    if (heightmap === void 0) {
      heightmap = false;
    }

    var _this = _super.call(this, dragController, colourScheme) || this;

    _this.heightmap = heightmap;
    _this.canvas = _this.createCanvasWrapper(c, 1, true);
    return _this;
  }

  DefaultStyle.prototype.createCanvasWrapper = function (c, scale, resizeToWindow) {
    if (scale === void 0) {
      scale = 1;
    }

    if (resizeToWindow === void 0) {
      resizeToWindow = true;
    }

    return new canvas_wrapper_1.DefaultCanvasWrapper(c, scale, resizeToWindow);
  };

  DefaultStyle.prototype.draw = function (canvas) {
    var e_1, _a, e_2, _b, e_3, _c, e_4, _d, e_5, _e, e_6, _f, e_7, _g, e_8, _h, e_9, _j, e_10, _k, e_11, _l, e_12, _m, e_13, _o, e_14, _p;

    if (canvas === void 0) {
      canvas = this.canvas;
    }

    var bgColour;

    if (this.colourScheme.zoomBuildings) {
      bgColour = this.domainController.zoom >= 2 ? this.colourScheme.bgColourIn : this.colourScheme.bgColour;
    } else {
      bgColour = this.colourScheme.bgColour;
    }

    canvas.setFillStyle(bgColour);
    canvas.clearCanvas(); // Sea

    canvas.setFillStyle(this.colourScheme.seaColour);
    canvas.setStrokeStyle(this.colourScheme.seaColour);
    canvas.setLineWidth(0.1);
    canvas.drawPolygon(this.seaPolygon); // Coastline

    canvas.setStrokeStyle(bgColour);
    canvas.setLineWidth(30 * this.domainController.zoom);
    canvas.drawPolyline(this.coastline); // Parks

    canvas.setLineWidth(1);
    canvas.setFillStyle(this.colourScheme.grassColour);

    try {
      for (var _q = __values(this.parks), _r = _q.next(); !_r.done; _r = _q.next()) {
        var p = _r.value;
        canvas.drawPolygon(p);
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_r && !_r.done && (_a = _q["return"])) _a.call(_q);
      } finally {
        if (e_1) throw e_1.error;
      }
    } // River


    canvas.setFillStyle(this.colourScheme.seaColour);
    canvas.setStrokeStyle(this.colourScheme.seaColour);
    canvas.setLineWidth(1);
    canvas.drawPolygon(this.river); // Road outline

    canvas.setStrokeStyle(this.colourScheme.minorRoadOutline);
    canvas.setLineWidth(this.colourScheme.outlineSize + this.colourScheme.minorWidth * this.domainController.zoom);

    try {
      for (var _s = __values(this.minorRoads), _t = _s.next(); !_t.done; _t = _s.next()) {
        var s = _t.value;
        canvas.drawPolyline(s);
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (_t && !_t.done && (_b = _s["return"])) _b.call(_s);
      } finally {
        if (e_2) throw e_2.error;
      }
    }

    canvas.setStrokeStyle(this.colourScheme.majorRoadOutline);
    canvas.setLineWidth(this.colourScheme.outlineSize + this.colourScheme.majorWidth * this.domainController.zoom);

    try {
      for (var _u = __values(this.majorRoads), _v = _u.next(); !_v.done; _v = _u.next()) {
        var s = _v.value;
        canvas.drawPolyline(s);
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (_v && !_v.done && (_c = _u["return"])) _c.call(_u);
      } finally {
        if (e_3) throw e_3.error;
      }
    }

    canvas.drawPolyline(this.secondaryRiver);
    canvas.setStrokeStyle(this.colourScheme.mainRoadOutline);
    canvas.setLineWidth(this.colourScheme.outlineSize + this.colourScheme.mainWidth * this.domainController.zoom);

    try {
      for (var _w = __values(this.mainRoads), _x = _w.next(); !_x.done; _x = _w.next()) {
        var s = _x.value;
        canvas.drawPolyline(s);
      }
    } catch (e_4_1) {
      e_4 = {
        error: e_4_1
      };
    } finally {
      try {
        if (_x && !_x.done && (_d = _w["return"])) _d.call(_w);
      } finally {
        if (e_4) throw e_4.error;
      }
    }

    try {
      for (var _y = __values(this.coastlineRoads), _z = _y.next(); !_z.done; _z = _y.next()) {
        var s = _z.value;
        canvas.drawPolyline(s);
      }
    } catch (e_5_1) {
      e_5 = {
        error: e_5_1
      };
    } finally {
      try {
        if (_z && !_z.done && (_e = _y["return"])) _e.call(_y);
      } finally {
        if (e_5) throw e_5.error;
      }
    } // Road inline


    canvas.setStrokeStyle(this.colourScheme.minorRoadColour);
    canvas.setLineWidth(this.colourScheme.minorWidth * this.domainController.zoom);

    try {
      for (var _0 = __values(this.minorRoads), _1 = _0.next(); !_1.done; _1 = _0.next()) {
        var s = _1.value;
        canvas.drawPolyline(s);
      }
    } catch (e_6_1) {
      e_6 = {
        error: e_6_1
      };
    } finally {
      try {
        if (_1 && !_1.done && (_f = _0["return"])) _f.call(_0);
      } finally {
        if (e_6) throw e_6.error;
      }
    }

    canvas.setStrokeStyle(this.colourScheme.majorRoadColour);
    canvas.setLineWidth(this.colourScheme.majorWidth * this.domainController.zoom);

    try {
      for (var _2 = __values(this.majorRoads), _3 = _2.next(); !_3.done; _3 = _2.next()) {
        var s = _3.value;
        canvas.drawPolyline(s);
      }
    } catch (e_7_1) {
      e_7 = {
        error: e_7_1
      };
    } finally {
      try {
        if (_3 && !_3.done && (_g = _2["return"])) _g.call(_2);
      } finally {
        if (e_7) throw e_7.error;
      }
    }

    canvas.drawPolyline(this.secondaryRiver);
    canvas.setStrokeStyle(this.colourScheme.mainRoadColour);
    canvas.setLineWidth(this.colourScheme.mainWidth * this.domainController.zoom);

    try {
      for (var _4 = __values(this.mainRoads), _5 = _4.next(); !_5.done; _5 = _4.next()) {
        var s = _5.value;
        canvas.drawPolyline(s);
      }
    } catch (e_8_1) {
      e_8 = {
        error: e_8_1
      };
    } finally {
      try {
        if (_5 && !_5.done && (_h = _4["return"])) _h.call(_4);
      } finally {
        if (e_8) throw e_8.error;
      }
    }

    try {
      for (var _6 = __values(this.coastlineRoads), _7 = _6.next(); !_7.done; _7 = _6.next()) {
        var s = _7.value;
        canvas.drawPolyline(s);
      }
    } catch (e_9_1) {
      e_9 = {
        error: e_9_1
      };
    } finally {
      try {
        if (_7 && !_7.done && (_j = _6["return"])) _j.call(_6);
      } finally {
        if (e_9) throw e_9.error;
      }
    }

    canvas.setLineWidth(1);

    if (this.heightmap) {
      var _loop_1 = function _loop_1(b) {
        // Colour based on height
        var parsedRgb = util_1["default"].parseCSSColor(this_1.colourScheme.bgColour).map(function (v) {
          return Math.min(255, v + b.height * 3.5);
        });
        canvas.setFillStyle("rgb(" + parsedRgb[0] + "," + parsedRgb[1] + "," + parsedRgb[2] + ")");
        canvas.setStrokeStyle("rgb(" + parsedRgb[0] + "," + parsedRgb[1] + "," + parsedRgb[2] + ")");
        canvas.drawPolygon(b.lotScreen);
      };

      var this_1 = this;

      try {
        for (var _8 = __values(this.buildingModels), _9 = _8.next(); !_9.done; _9 = _8.next()) {
          var b = _9.value;

          _loop_1(b);
        }
      } catch (e_10_1) {
        e_10 = {
          error: e_10_1
        };
      } finally {
        try {
          if (_9 && !_9.done && (_k = _8["return"])) _k.call(_8);
        } finally {
          if (e_10) throw e_10.error;
        }
      }
    } else {
      // Buildings
      if (!this.colourScheme.zoomBuildings || this.domainController.zoom >= 2) {
        canvas.setFillStyle(this.colourScheme.buildingColour);
        canvas.setStrokeStyle(this.colourScheme.buildingStroke);

        try {
          for (var _10 = __values(this.lots), _11 = _10.next(); !_11.done; _11 = _10.next()) {
            var b = _11.value;
            canvas.drawPolygon(b);
          }
        } catch (e_11_1) {
          e_11 = {
            error: e_11_1
          };
        } finally {
          try {
            if (_11 && !_11.done && (_l = _10["return"])) _l.call(_10);
          } finally {
            if (e_11) throw e_11.error;
          }
        }
      } // Pseudo-3D


      if (this.colourScheme.buildingModels && (!this.colourScheme.zoomBuildings || this.domainController.zoom >= 2.5)) {
        canvas.setFillStyle(this.colourScheme.buildingSideColour);
        canvas.setStrokeStyle(this.colourScheme.buildingSideColour);

        try {
          // This is a cheap approximation that often creates visual artefacts
          // Draws building sides, then rooves instead of properly clipping polygons etc.
          for (var _12 = __values(this.buildingModels), _13 = _12.next(); !_13.done; _13 = _12.next()) {
            var b = _13.value;

            try {
              for (var _14 = (e_13 = void 0, __values(b.sides)), _15 = _14.next(); !_15.done; _15 = _14.next()) {
                var s = _15.value;
                canvas.drawPolygon(s);
              }
            } catch (e_13_1) {
              e_13 = {
                error: e_13_1
              };
            } finally {
              try {
                if (_15 && !_15.done && (_o = _14["return"])) _o.call(_14);
              } finally {
                if (e_13) throw e_13.error;
              }
            }
          }
        } catch (e_12_1) {
          e_12 = {
            error: e_12_1
          };
        } finally {
          try {
            if (_13 && !_13.done && (_m = _12["return"])) _m.call(_12);
          } finally {
            if (e_12) throw e_12.error;
          }
        }

        canvas.setFillStyle(this.colourScheme.buildingColour);
        canvas.setStrokeStyle(this.colourScheme.buildingStroke);

        try {
          for (var _16 = __values(this.buildingModels), _17 = _16.next(); !_17.done; _17 = _16.next()) {
            var b = _17.value;
            canvas.drawPolygon(b.roof);
          }
        } catch (e_14_1) {
          e_14 = {
            error: e_14_1
          };
        } finally {
          try {
            if (_17 && !_17.done && (_p = _16["return"])) _p.call(_16);
          } finally {
            if (e_14) throw e_14.error;
          }
        }
      }
    }

    if (this.showFrame) {
      canvas.setFillStyle(this.colourScheme.frameColour);
      canvas.setStrokeStyle(this.colourScheme.frameColour);
      canvas.drawFrame(30, 30, 30, 30); // canvas.setFillStyle(this.colourScheme.frameTextColour);
      // canvas.drawCityName();
    }
  };

  return DefaultStyle;
}(Style);

exports.DefaultStyle = DefaultStyle;

var RoughStyle =
/** @class */
function (_super) {
  __extends(RoughStyle, _super);

  function RoughStyle(c, dragController, colourScheme) {
    var _this = _super.call(this, dragController, colourScheme) || this;

    _this.dragging = false;
    _this.canvas = _this.createCanvasWrapper(c, 1, true);
    return _this;
  }

  RoughStyle.prototype.createCanvasWrapper = function (c, scale, resizeToWindow) {
    if (scale === void 0) {
      scale = 1;
    }

    if (resizeToWindow === void 0) {
      resizeToWindow = true;
    }

    return new canvas_wrapper_1.RoughCanvasWrapper(c, scale, resizeToWindow);
  };

  RoughStyle.prototype.update = function () {
    var dragging = this.dragController.isDragging || this.domainController.isScrolling;
    if (!dragging && this.dragging) this.canvas.needsUpdate = true;
    this.dragging = dragging;
  };

  RoughStyle.prototype.draw = function (canvas) {
    var e_15, _a, e_16, _b, e_17, _c, e_18, _d, e_19, _e;

    if (canvas === void 0) {
      canvas = this.canvas;
    }

    canvas.setOptions({
      fill: this.colourScheme.bgColour,
      roughness: 1,
      bowing: 1,
      fillStyle: 'solid',
      stroke: "none"
    });
    canvas.clearCanvas(); // Sea

    canvas.setOptions({
      roughness: 0,
      fillWeight: 1,
      fill: this.colourScheme.seaColour,
      fillStyle: 'solid',
      stroke: "none",
      strokeWidth: 1
    });
    canvas.drawPolygon(this.seaPolygon);
    canvas.setOptions({
      stroke: this.colourScheme.bgColour,
      strokeWidth: 30
    });
    canvas.drawPolyline(this.coastline);
    canvas.setOptions({
      roughness: 0,
      fillWeight: 1,
      fill: this.colourScheme.seaColour,
      fillStyle: 'solid',
      stroke: "none",
      strokeWidth: 1
    });
    canvas.drawPolygon(this.river); // Parks

    canvas.setOptions({
      fill: this.colourScheme.grassColour
    });
    this.parks.forEach(function (p) {
      return canvas.drawPolygon(p);
    }); // Roads

    canvas.setOptions({
      stroke: this.colourScheme.minorRoadColour,
      strokeWidth: 1,
      fill: 'none'
    });
    this.minorRoads.forEach(function (s) {
      return canvas.drawPolyline(s);
    });
    canvas.setOptions({
      strokeWidth: 2,
      stroke: this.colourScheme.majorRoadColour
    });
    this.majorRoads.forEach(function (s) {
      return canvas.drawPolyline(s);
    });
    canvas.drawPolyline(this.secondaryRiver);
    canvas.setOptions({
      strokeWidth: 3,
      stroke: this.colourScheme.mainRoadColour
    });
    this.mainRoads.forEach(function (s) {
      return canvas.drawPolyline(s);
    });
    this.coastlineRoads.forEach(function (s) {
      return canvas.drawPolyline(s);
    }); // Buildings

    if (!this.dragging) {
      // Lots
      if (!this.colourScheme.zoomBuildings || this.domainController.zoom >= 2) {
        // Lots
        canvas.setOptions({
          roughness: 1.2,
          stroke: this.colourScheme.buildingStroke,
          strokeWidth: 1,
          fill: ''
        });

        try {
          for (var _f = __values(this.lots), _g = _f.next(); !_g.done; _g = _f.next()) {
            var b = _g.value;
            canvas.drawPolygon(b);
          }
        } catch (e_15_1) {
          e_15 = {
            error: e_15_1
          };
        } finally {
          try {
            if (_g && !_g.done && (_a = _f["return"])) _a.call(_f);
          } finally {
            if (e_15) throw e_15.error;
          }
        }
      } // Pseudo-3D


      if (this.colourScheme.buildingModels && (!this.colourScheme.zoomBuildings || this.domainController.zoom >= 2.5)) {
        // Pseudo-3D
        canvas.setOptions({
          roughness: 1.2,
          stroke: this.colourScheme.buildingStroke,
          strokeWidth: 1,
          fill: this.colourScheme.buildingSideColour
        }); // TODO this can be hugely improved

        var allSidesDistances = [];
        var camera = this.domainController.getCameraPosition();

        try {
          for (var _h = __values(this.buildingModels), _j = _h.next(); !_j.done; _j = _h.next()) {
            var b = _j.value;

            try {
              for (var _k = (e_17 = void 0, __values(b.sides)), _l = _k.next(); !_l.done; _l = _k.next()) {
                var s = _l.value;
                var averagePoint = s[0].clone().add(s[1]).divideScalar(2);
                allSidesDistances.push([averagePoint.distanceToSquared(camera), s]);
              }
            } catch (e_17_1) {
              e_17 = {
                error: e_17_1
              };
            } finally {
              try {
                if (_l && !_l.done && (_c = _k["return"])) _c.call(_k);
              } finally {
                if (e_17) throw e_17.error;
              }
            }
          }
        } catch (e_16_1) {
          e_16 = {
            error: e_16_1
          };
        } finally {
          try {
            if (_j && !_j.done && (_b = _h["return"])) _b.call(_h);
          } finally {
            if (e_16) throw e_16.error;
          }
        }

        allSidesDistances.sort(function (a, b) {
          return b[0] - a[0];
        });

        try {
          for (var allSidesDistances_1 = __values(allSidesDistances), allSidesDistances_1_1 = allSidesDistances_1.next(); !allSidesDistances_1_1.done; allSidesDistances_1_1 = allSidesDistances_1.next()) {
            var p = allSidesDistances_1_1.value;
            canvas.drawPolygon(p[1]);
          }
        } catch (e_18_1) {
          e_18 = {
            error: e_18_1
          };
        } finally {
          try {
            if (allSidesDistances_1_1 && !allSidesDistances_1_1.done && (_d = allSidesDistances_1["return"])) _d.call(allSidesDistances_1);
          } finally {
            if (e_18) throw e_18.error;
          }
        }

        canvas.setOptions({
          roughness: 1.2,
          stroke: this.colourScheme.buildingStroke,
          strokeWidth: 1,
          fill: this.colourScheme.buildingColour
        });

        try {
          for (var _m = __values(this.buildingModels), _o = _m.next(); !_o.done; _o = _m.next()) {
            var b = _o.value;
            canvas.drawPolygon(b.roof);
          }
        } catch (e_19_1) {
          e_19 = {
            error: e_19_1
          };
        } finally {
          try {
            if (_o && !_o.done && (_e = _m["return"])) _e.call(_m);
          } finally {
            if (e_19) throw e_19.error;
          }
        }
      }
    }
  };

  return RoughStyle;
}(Style);

exports.RoughStyle = RoughStyle;

},{"../util":36,"./canvas_wrapper":28,"./domain_controller":29,"loglevel":7}],34:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var domain_controller_1 = require("./domain_controller");

var tensor_field_1 = require("../impl/tensor_field");

var util_1 = require("../util");

var vector_1 = require("../vector");
/**
 * Extension of TensorField that handles interaction with dat.GUI
 */


var TensorFieldGUI =
/** @class */
function (_super) {
  __extends(TensorFieldGUI, _super);

  function TensorFieldGUI(guiFolder, dragController, drawCentre, noiseParams) {
    var _this = _super.call(this, noiseParams) || this;

    _this.guiFolder = guiFolder;
    _this.dragController = dragController;
    _this.drawCentre = drawCentre;
    _this.TENSOR_LINE_DIAMETER = 20;
    _this.TENSOR_SPAWN_SCALE = 0.7; // How much to shrink worldDimensions to find spawn point

    _this.domainController = domain_controller_1["default"].getInstance(); // For custom naming of gui buttons

    var tensorFieldGuiObj = {
      reset: function reset() {
        return _this.reset();
      },
      setRecommended: function setRecommended() {
        return _this.setRecommended();
      },
      addRadial: function addRadial() {
        return _this.addRadialRandom();
      },
      addGrid: function addGrid() {
        return _this.addGridRandom();
      }
    };

    _this.guiFolder.add(tensorFieldGuiObj, 'reset');

    _this.guiFolder.add(_this, 'smooth');

    _this.guiFolder.add(tensorFieldGuiObj, 'setRecommended');

    _this.guiFolder.add(tensorFieldGuiObj, 'addRadial');

    _this.guiFolder.add(tensorFieldGuiObj, 'addGrid');

    return _this;
  }
  /**
   * 4 Grids, one radial
   */


  TensorFieldGUI.prototype.setRecommended = function () {
    this.reset();
    var size = this.domainController.worldDimensions.multiplyScalar(this.TENSOR_SPAWN_SCALE);
    var newOrigin = this.domainController.worldDimensions.multiplyScalar((1 - this.TENSOR_SPAWN_SCALE) / 2).add(this.domainController.origin);
    this.addGridAtLocation(newOrigin);
    this.addGridAtLocation(newOrigin.clone().add(size));
    this.addGridAtLocation(newOrigin.clone().add(new vector_1["default"](size.x, 0)));
    this.addGridAtLocation(newOrigin.clone().add(new vector_1["default"](0, size.y)));
    this.addRadialRandom();
  };

  TensorFieldGUI.prototype.addRadialRandom = function () {
    var width = this.domainController.worldDimensions.x;
    this.addRadial(this.randomLocation(), util_1["default"].randomRange(width / 10, width / 5), // Size
    util_1["default"].randomRange(50)); // Decay
  };

  TensorFieldGUI.prototype.addGridRandom = function () {
    this.addGridAtLocation(this.randomLocation());
  };

  TensorFieldGUI.prototype.addGridAtLocation = function (location) {
    var width = this.domainController.worldDimensions.x;
    this.addGrid(location, util_1["default"].randomRange(width / 4, width), // Size
    util_1["default"].randomRange(50), // Decay
    util_1["default"].randomRange(Math.PI / 2));
  };
  /**
   * World-space random location for tensor field spawn
   * Sampled from middle of screen (shrunk rectangle)
   */


  TensorFieldGUI.prototype.randomLocation = function () {
    var size = this.domainController.worldDimensions.multiplyScalar(this.TENSOR_SPAWN_SCALE);
    var location = new vector_1["default"](Math.random(), Math.random()).multiply(size);
    var newOrigin = this.domainController.worldDimensions.multiplyScalar((1 - this.TENSOR_SPAWN_SCALE) / 2);
    return location.add(this.domainController.origin).add(newOrigin);
  };

  TensorFieldGUI.prototype.getCrossLocations = function () {
    // Gets grid of points for vector field vis in world space
    var diameter = this.TENSOR_LINE_DIAMETER / this.domainController.zoom;
    var worldDimensions = this.domainController.worldDimensions;
    var nHor = Math.ceil(worldDimensions.x / diameter) + 1; // Prevent pop-in

    var nVer = Math.ceil(worldDimensions.y / diameter) + 1;
    var originX = diameter * Math.floor(this.domainController.origin.x / diameter);
    var originY = diameter * Math.floor(this.domainController.origin.y / diameter);
    var out = [];

    for (var x = 0; x <= nHor; x++) {
      for (var y = 0; y <= nVer; y++) {
        out.push(new vector_1["default"](originX + x * diameter, originY + y * diameter));
      }
    }

    return out;
  };

  TensorFieldGUI.prototype.getTensorLine = function (point, tensorV) {
    var transformedPoint = this.domainController.worldToScreen(point.clone());
    var diff = tensorV.multiplyScalar(this.TENSOR_LINE_DIAMETER / 2); // Assumes normalised

    var start = transformedPoint.clone().sub(diff);
    var end = transformedPoint.clone().add(diff);
    return [start, end];
  };

  TensorFieldGUI.prototype.draw = function (canvas) {
    var _this = this; // Draw tensor field


    canvas.setFillStyle('black');
    canvas.clearCanvas();
    canvas.setStrokeStyle('white');
    canvas.setLineWidth(1);
    var tensorPoints = this.getCrossLocations();
    tensorPoints.forEach(function (p) {
      var t = _this.samplePoint(p);

      canvas.drawPolyline(_this.getTensorLine(p, t.getMajor()));
      canvas.drawPolyline(_this.getTensorLine(p, t.getMinor()));
    }); // Draw centre points of fields

    if (this.drawCentre) {
      canvas.setFillStyle('red');
      this.getBasisFields().forEach(function (field) {
        return field.FIELD_TYPE === 1
        /* Grid */
        ? canvas.drawSquare(_this.domainController.worldToScreen(field.centre), 7) : canvas.drawCircle(_this.domainController.worldToScreen(field.centre), 7);
      });
    }
  };

  TensorFieldGUI.prototype.addField = function (field) {
    var _this = this;

    _super.prototype.addField.call(this, field);

    var folder = this.guiFolder.addFolder("" + field.FOLDER_NAME); // Function to deregister from drag controller

    var deregisterDrag = this.dragController.register(function () {
      return field.centre;
    }, field.dragMoveListener.bind(field), field.dragStartListener.bind(field));
    var removeFieldObj = {
      remove: function remove() {
        return _this.removeFieldGUI(field, deregisterDrag);
      }
    }; // Give dat gui removeField button

    folder.add(removeFieldObj, 'remove');
    field.setGui(this.guiFolder, folder);
  };

  TensorFieldGUI.prototype.removeFieldGUI = function (field, deregisterDrag) {
    _super.prototype.removeField.call(this, field);

    field.removeFolderFromParent(); // Deregister from drag controller

    deregisterDrag();
  };

  TensorFieldGUI.prototype.reset = function () {
    // TODO kind of hacky - calling remove callbacks from gui object, should store callbacks
    // in addfield and call them (requires making sure they're idempotent)
    for (var fieldFolderName in this.guiFolder.__folders) {
      var fieldFolder = this.guiFolder.__folders[fieldFolderName];

      fieldFolder.__controllers[0].initialValue();
    }

    _super.prototype.reset.call(this);
  };

  return TensorFieldGUI;
}(tensor_field_1["default"]);

exports["default"] = TensorFieldGUI;

},{"../impl/tensor_field":25,"../util":36,"../vector":37,"./domain_controller":29}],35:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var util_1 = require("../util");

var water_generator_1 = require("../impl/water_generator");

var road_gui_1 = require("./road_gui");
/**
 * Handles generation of river and coastline
 */


var WaterGUI =
/** @class */
function (_super) {
  __extends(WaterGUI, _super);

  function WaterGUI(tensorField, params, integrator, guiFolder, closeTensorFolder, folderName, redraw) {
    var _this = _super.call(this, params, integrator, guiFolder, closeTensorFolder, folderName, redraw) || this;

    _this.tensorField = tensorField;
    _this.params = params;
    _this.streamlines = new water_generator_1["default"](_this.integrator, _this.domainController.origin, _this.domainController.worldDimensions, Object.assign({}, _this.params), _this.tensorField);
    return _this;
  }

  WaterGUI.prototype.initFolder = function () {
    var _this = this;

    var folder = this.guiFolder.addFolder(this.folderName);
    folder.add({
      Generate: function Generate() {
        return _this.generateRoads();
      }
    }, 'Generate');
    var coastParamsFolder = folder.addFolder('CoastParams');
    coastParamsFolder.add(this.params.coastNoise, 'noiseEnabled');
    coastParamsFolder.add(this.params.coastNoise, 'noiseSize');
    coastParamsFolder.add(this.params.coastNoise, 'noiseAngle');
    var riverParamsFolder = folder.addFolder('RiverParams');
    riverParamsFolder.add(this.params.riverNoise, 'noiseEnabled');
    riverParamsFolder.add(this.params.riverNoise, 'noiseSize');
    riverParamsFolder.add(this.params.riverNoise, 'noiseAngle');
    folder.add(this.params, 'simplifyTolerance');
    var devParamsFolder = folder.addFolder('Dev');
    this.addDevParamsToFolder(this.params, devParamsFolder);
    return this;
  };

  WaterGUI.prototype.generateRoads = function () {
    this.preGenerateCallback();
    this.domainController.zoom = this.domainController.zoom / util_1["default"].DRAW_INFLATE_AMOUNT;
    this.streamlines = new water_generator_1["default"](this.integrator, this.domainController.origin, this.domainController.worldDimensions, Object.assign({}, this.params), this.tensorField);
    this.domainController.zoom = this.domainController.zoom * util_1["default"].DRAW_INFLATE_AMOUNT;
    this.streamlines.createCoast();
    this.streamlines.createRiver();
    this.closeTensorFolder();
    this.redraw();
    this.postGenerateCallback();
    return new Promise(function (resolve) {
      return resolve();
    });
  };

  Object.defineProperty(WaterGUI.prototype, "streamlinesWithSecondaryRoad", {
    /**
     * Secondary road runs along other side of river
     */
    get: function get() {
      var withSecondary = this.streamlines.allStreamlinesSimple.slice();
      withSecondary.push(this.streamlines.riverSecondaryRoad);
      return withSecondary;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(WaterGUI.prototype, "river", {
    get: function get() {
      var _this = this;

      return this.streamlines.riverPolygon.map(function (v) {
        return _this.domainController.worldToScreen(v.clone());
      });
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(WaterGUI.prototype, "secondaryRiver", {
    get: function get() {
      var _this = this;

      return this.streamlines.riverSecondaryRoad.map(function (v) {
        return _this.domainController.worldToScreen(v.clone());
      });
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(WaterGUI.prototype, "coastline", {
    get: function get() {
      var _this = this; // Use unsimplified noisy streamline as coastline
      // Visual only, no road logic performed using this


      return this.streamlines.coastline.map(function (v) {
        return _this.domainController.worldToScreen(v.clone());
      });
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(WaterGUI.prototype, "seaPolygon", {
    get: function get() {
      var _this = this;

      return this.streamlines.seaPolygon.map(function (v) {
        return _this.domainController.worldToScreen(v.clone());
      });
    },
    enumerable: true,
    configurable: true
  });

  WaterGUI.prototype.addDevParamsToFolder = function (params, folder) {
    folder.add(params, 'dsep');
    folder.add(params, 'dtest');
    folder.add(params, 'pathIterations');
    folder.add(params, 'seedTries');
    folder.add(params, 'dstep');
    folder.add(params, 'dlookahead');
    folder.add(params, 'dcirclejoin');
    folder.add(params, 'joinangle');
  };

  return WaterGUI;
}(road_gui_1["default"]);

exports["default"] = WaterGUI;

},{"../impl/water_generator":26,"../util":36,"./road_gui":32}],36:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var Util =
/** @class */
function () {
  function Util() {} // Refresh dat.GUI values


  Util.updateGui = function (gui) {
    if (gui.__controllers) {
      gui.__controllers.forEach(function (c) {
        return c.updateDisplay();
      });
    }

    if (gui.__folders) {
      for (var folderName in gui.__folders) {
        this.updateGui(gui.__folders[folderName]);
      }
    }
  };

  Util.removeAllFolders = function (gui) {
    if (gui.__folders) {
      for (var folderName in gui.__folders) {
        gui.removeFolder(gui.__folders[folderName]);
      }
    }
  };

  Util.randomRange = function (max, min) {
    if (min === void 0) {
      min = 0;
    }

    return Math.random() * (max - min) + min;
  };

  Util.clamp_css_byte = function (i) {
    i = Math.round(i); // Seems to be what Chrome does (vs truncation).

    return i < 0 ? 0 : i > 255 ? 255 : i;
  };

  Util.clamp_css_float = function (f) {
    return f < 0 ? 0 : f > 1 ? 1 : f;
  };

  Util.parse_css_int = function (str) {
    if (str[str.length - 1] === '%') return Util.clamp_css_byte(parseFloat(str) / 100 * 255);
    return Util.clamp_css_byte(parseInt(str));
  };

  Util.parse_css_float = function (str) {
    if (str[str.length - 1] === '%') return Util.clamp_css_float(parseFloat(str) / 100);
    return Util.clamp_css_float(parseFloat(str));
  };

  Util.css_hue_to_rgb = function (m1, m2, h) {
    if (h < 0) h += 1;else if (h > 1) h -= 1;
    if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
    if (h * 2 < 1) return m2;
    if (h * 3 < 2) return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    return m1;
  };

  Util.parseCSSColor = function (css_str) {
    // Remove all whitespace, not compliant, but should just be more accepting.
    var str = css_str.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.

    if (str in Util.kCSSColorTable) return Util.kCSSColorTable[str].slice(); // dup.
    // #abc and #abc123 syntax.

    if (str[0] === '#') {
      if (str.length === 4) {
        var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.

        if (!(iv >= 0 && iv <= 0xfff)) return null; // Covers NaN.

        return [(iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1];
      } else if (str.length === 7) {
        var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.

        if (!(iv >= 0 && iv <= 0xffffff)) return null; // Covers NaN.

        return [(iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1];
      }

      return null;
    }

    var op = str.indexOf('('),
        ep = str.indexOf(')');

    if (op !== -1 && ep + 1 === str.length) {
      var fname = str.substr(0, op);
      var params = str.substr(op + 1, ep - (op + 1)).split(',');
      var alpha = 1; // To allow case fallthrough.

      switch (fname) {
        case 'rgba':
          if (params.length !== 4) return null;
          alpha = Util.parse_css_float(params.pop());
        // Fall through.

        case 'rgb':
          if (params.length !== 3) return null;
          return [Util.parse_css_int(params[0]), Util.parse_css_int(params[1]), Util.parse_css_int(params[2]), alpha];

        case 'hsla':
          if (params.length !== 4) return null;
          alpha = Util.parse_css_float(params.pop());
        // Fall through.

        case 'hsl':
          if (params.length !== 3) return null;
          var h = (parseFloat(params[0]) % 360 + 360) % 360 / 360; // 0 .. 1
          // NOTE(deanm): According to the CSS spec s/l should only be
          // percentages, but we don't bother and let float or percentage.

          var s = Util.parse_css_float(params[1]);
          var l = Util.parse_css_float(params[2]);
          var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
          var m1 = l * 2 - m2;
          return [Util.clamp_css_byte(Util.css_hue_to_rgb(m1, m2, h + 1 / 3) * 255), Util.clamp_css_byte(Util.css_hue_to_rgb(m1, m2, h) * 255), Util.clamp_css_byte(Util.css_hue_to_rgb(m1, m2, h - 1 / 3) * 255), alpha];

        default:
          return null;
      }
    }

    return null;
  }; // Must match style.css and index.html


  Util.CANVAS_ID = 'map-canvas';
  Util.IMG_CANVAS_ID = 'img-canvas';
  Util.SVG_ID = 'map-svg'; // How far to integrate streamlines beyond screen - for making buildings reach the edge

  Util.DRAW_INFLATE_AMOUNT = 1.2; // CSS colour parser
  // (c) Dean McNamee <dean@gmail.com>, 2012.
  //
  // https://github.com/deanm/css-color-parser-js
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to
  // deal in the Software without restriction, including without limitation the
  // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
  // sell copies of the Software, and to permit persons to whom the Software is
  // furnished to do so, subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  // IN THE SOFTWARE.
  // http://www.w3.org/TR/css3-color/

  Util.kCSSColorTable = {
    "transparent": [0, 0, 0, 0],
    "aliceblue": [240, 248, 255, 1],
    "antiquewhite": [250, 235, 215, 1],
    "aqua": [0, 255, 255, 1],
    "aquamarine": [127, 255, 212, 1],
    "azure": [240, 255, 255, 1],
    "beige": [245, 245, 220, 1],
    "bisque": [255, 228, 196, 1],
    "black": [0, 0, 0, 1],
    "blanchedalmond": [255, 235, 205, 1],
    "blue": [0, 0, 255, 1],
    "blueviolet": [138, 43, 226, 1],
    "brown": [165, 42, 42, 1],
    "burlywood": [222, 184, 135, 1],
    "cadetblue": [95, 158, 160, 1],
    "chartreuse": [127, 255, 0, 1],
    "chocolate": [210, 105, 30, 1],
    "coral": [255, 127, 80, 1],
    "cornflowerblue": [100, 149, 237, 1],
    "cornsilk": [255, 248, 220, 1],
    "crimson": [220, 20, 60, 1],
    "cyan": [0, 255, 255, 1],
    "darkblue": [0, 0, 139, 1],
    "darkcyan": [0, 139, 139, 1],
    "darkgoldenrod": [184, 134, 11, 1],
    "darkgray": [169, 169, 169, 1],
    "darkgreen": [0, 100, 0, 1],
    "darkgrey": [169, 169, 169, 1],
    "darkkhaki": [189, 183, 107, 1],
    "darkmagenta": [139, 0, 139, 1],
    "darkolivegreen": [85, 107, 47, 1],
    "darkorange": [255, 140, 0, 1],
    "darkorchid": [153, 50, 204, 1],
    "darkred": [139, 0, 0, 1],
    "darksalmon": [233, 150, 122, 1],
    "darkseagreen": [143, 188, 143, 1],
    "darkslateblue": [72, 61, 139, 1],
    "darkslategray": [47, 79, 79, 1],
    "darkslategrey": [47, 79, 79, 1],
    "darkturquoise": [0, 206, 209, 1],
    "darkviolet": [148, 0, 211, 1],
    "deeppink": [255, 20, 147, 1],
    "deepskyblue": [0, 191, 255, 1],
    "dimgray": [105, 105, 105, 1],
    "dimgrey": [105, 105, 105, 1],
    "dodgerblue": [30, 144, 255, 1],
    "firebrick": [178, 34, 34, 1],
    "floralwhite": [255, 250, 240, 1],
    "forestgreen": [34, 139, 34, 1],
    "fuchsia": [255, 0, 255, 1],
    "gainsboro": [220, 220, 220, 1],
    "ghostwhite": [248, 248, 255, 1],
    "gold": [255, 215, 0, 1],
    "goldenrod": [218, 165, 32, 1],
    "gray": [128, 128, 128, 1],
    "green": [0, 128, 0, 1],
    "greenyellow": [173, 255, 47, 1],
    "grey": [128, 128, 128, 1],
    "honeydew": [240, 255, 240, 1],
    "hotpink": [255, 105, 180, 1],
    "indianred": [205, 92, 92, 1],
    "indigo": [75, 0, 130, 1],
    "ivory": [255, 255, 240, 1],
    "khaki": [240, 230, 140, 1],
    "lavender": [230, 230, 250, 1],
    "lavenderblush": [255, 240, 245, 1],
    "lawngreen": [124, 252, 0, 1],
    "lemonchiffon": [255, 250, 205, 1],
    "lightblue": [173, 216, 230, 1],
    "lightcoral": [240, 128, 128, 1],
    "lightcyan": [224, 255, 255, 1],
    "lightgoldenrodyellow": [250, 250, 210, 1],
    "lightgray": [211, 211, 211, 1],
    "lightgreen": [144, 238, 144, 1],
    "lightgrey": [211, 211, 211, 1],
    "lightpink": [255, 182, 193, 1],
    "lightsalmon": [255, 160, 122, 1],
    "lightseagreen": [32, 178, 170, 1],
    "lightskyblue": [135, 206, 250, 1],
    "lightslategray": [119, 136, 153, 1],
    "lightslategrey": [119, 136, 153, 1],
    "lightsteelblue": [176, 196, 222, 1],
    "lightyellow": [255, 255, 224, 1],
    "lime": [0, 255, 0, 1],
    "limegreen": [50, 205, 50, 1],
    "linen": [250, 240, 230, 1],
    "magenta": [255, 0, 255, 1],
    "maroon": [128, 0, 0, 1],
    "mediumaquamarine": [102, 205, 170, 1],
    "mediumblue": [0, 0, 205, 1],
    "mediumorchid": [186, 85, 211, 1],
    "mediumpurple": [147, 112, 219, 1],
    "mediumseagreen": [60, 179, 113, 1],
    "mediumslateblue": [123, 104, 238, 1],
    "mediumspringgreen": [0, 250, 154, 1],
    "mediumturquoise": [72, 209, 204, 1],
    "mediumvioletred": [199, 21, 133, 1],
    "midnightblue": [25, 25, 112, 1],
    "mintcream": [245, 255, 250, 1],
    "mistyrose": [255, 228, 225, 1],
    "moccasin": [255, 228, 181, 1],
    "navajowhite": [255, 222, 173, 1],
    "navy": [0, 0, 128, 1],
    "oldlace": [253, 245, 230, 1],
    "olive": [128, 128, 0, 1],
    "olivedrab": [107, 142, 35, 1],
    "orange": [255, 165, 0, 1],
    "orangered": [255, 69, 0, 1],
    "orchid": [218, 112, 214, 1],
    "palegoldenrod": [238, 232, 170, 1],
    "palegreen": [152, 251, 152, 1],
    "paleturquoise": [175, 238, 238, 1],
    "palevioletred": [219, 112, 147, 1],
    "papayawhip": [255, 239, 213, 1],
    "peachpuff": [255, 218, 185, 1],
    "peru": [205, 133, 63, 1],
    "pink": [255, 192, 203, 1],
    "plum": [221, 160, 221, 1],
    "powderblue": [176, 224, 230, 1],
    "purple": [128, 0, 128, 1],
    "rebeccapurple": [102, 51, 153, 1],
    "red": [255, 0, 0, 1],
    "rosybrown": [188, 143, 143, 1],
    "royalblue": [65, 105, 225, 1],
    "saddlebrown": [139, 69, 19, 1],
    "salmon": [250, 128, 114, 1],
    "sandybrown": [244, 164, 96, 1],
    "seagreen": [46, 139, 87, 1],
    "seashell": [255, 245, 238, 1],
    "sienna": [160, 82, 45, 1],
    "silver": [192, 192, 192, 1],
    "skyblue": [135, 206, 235, 1],
    "slateblue": [106, 90, 205, 1],
    "slategray": [112, 128, 144, 1],
    "slategrey": [112, 128, 144, 1],
    "snow": [255, 250, 250, 1],
    "springgreen": [0, 255, 127, 1],
    "steelblue": [70, 130, 180, 1],
    "tan": [210, 180, 140, 1],
    "teal": [0, 128, 128, 1],
    "thistle": [216, 191, 216, 1],
    "tomato": [255, 99, 71, 1],
    "turquoise": [64, 224, 208, 1],
    "violet": [238, 130, 238, 1],
    "wheat": [245, 222, 179, 1],
    "white": [255, 255, 255, 1],
    "whitesmoke": [245, 245, 245, 1],
    "yellow": [255, 255, 0, 1],
    "yellowgreen": [154, 205, 50, 1]
  };
  return Util;
}();

exports["default"] = Util;

},{}],37:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var log = require("loglevel");

var Vector =
/** @class */
function () {
  function Vector(x, y) {
    this.x = x;
    this.y = y;
  }

  Vector.zeroVector = function () {
    return new Vector(0, 0);
  };

  Vector.fromScalar = function (s) {
    return new Vector(s, s);
  };
  /**
   * -pi to pi
   */


  Vector.angleBetween = function (v1, v2) {
    // -2pi to 2pi
    var angleBetween = v1.angle() - v2.angle();

    if (angleBetween > Math.PI) {
      angleBetween -= 2 * Math.PI;
    } else if (angleBetween <= -Math.PI) {
      angleBetween += 2 * Math.PI;
    }

    return angleBetween;
  };
  /**
   * Tests whether a point lies to the left of a line
   * @param  {Vector} linePoint     Point on the line
   * @param  {Vector} lineDirection
   * @param  {Vector} point
   * @return {Vector}               true if left, false otherwise
   */


  Vector.isLeft = function (linePoint, lineDirection, point) {
    var perpendicularVector = new Vector(lineDirection.y, -lineDirection.x);
    return point.clone().sub(linePoint).dot(perpendicularVector) < 0;
  };

  Vector.prototype.add = function (v) {
    this.x += v.x;
    this.y += v.y;
    return this;
  };
  /**
   * Angle in radians to positive x-axis between -pi and pi
   */


  Vector.prototype.angle = function () {
    return Math.atan2(this.y, this.x);
  };

  Vector.prototype.clone = function () {
    return new Vector(this.x, this.y);
  };

  Vector.prototype.copy = function (v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  };

  Vector.prototype.cross = function (v) {
    return this.x * v.y - this.y * v.x;
  };

  Vector.prototype.distanceTo = function (v) {
    return Math.sqrt(this.distanceToSquared(v));
  };

  Vector.prototype.distanceToSquared = function (v) {
    var dx = this.x - v.x;
    var dy = this.y - v.y;
    return dx * dx + dy * dy;
  };

  Vector.prototype.divide = function (v) {
    if (v.x === 0 || v.y === 0) {
      log.warn("Division by zero");
      return this;
    }

    this.x /= v.x;
    this.y /= v.y;
    return this;
  };

  Vector.prototype.divideScalar = function (s) {
    if (s === 0) {
      log.warn("Division by zero");
      return this;
    }

    return this.multiplyScalar(1 / s);
  };

  Vector.prototype.dot = function (v) {
    return this.x * v.x + this.y * v.y;
  };

  Vector.prototype.equals = function (v) {
    return v.x === this.x && v.y === this.y;
  };

  Vector.prototype.length = function () {
    return Math.sqrt(this.lengthSq());
  };

  Vector.prototype.lengthSq = function () {
    return this.x * this.x + this.y * this.y;
  };

  Vector.prototype.multiply = function (v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  };

  Vector.prototype.multiplyScalar = function (s) {
    this.x *= s;
    this.y *= s;
    return this;
  };

  Vector.prototype.negate = function () {
    return this.multiplyScalar(-1);
  };

  Vector.prototype.normalize = function () {
    var l = this.length();

    if (l === 0) {
      log.warn("Zero Vector");
      return this;
    }

    return this.divideScalar(this.length());
  };
  /**
   * Angle in radians
   */


  Vector.prototype.rotateAround = function (center, angle) {
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    var x = this.x - center.x;
    var y = this.y - center.y;
    this.x = x * cos - y * sin + center.x;
    this.y = x * sin + y * cos + center.y;
    return this;
  };

  Vector.prototype.set = function (v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  };

  Vector.prototype.setX = function (x) {
    this.x = x;
    return this;
  };

  Vector.prototype.setY = function (y) {
    this.y = y;
    return this;
  };

  Vector.prototype.setLength = function (length) {
    return this.normalize().multiplyScalar(length);
  };

  Vector.prototype.sub = function (v) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
  };

  return Vector;
}();

exports["default"] = Vector;

},{"loglevel":7}]},{},[14])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQtc3RvcmUuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi10by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91aWQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZGVuLWtleXMuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3duLWtleXMuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1mb3JjZWQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VzZXItYWdlbnQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy92OC12ZXJzaW9uLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLWV4dGVybmFsLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9odG1sLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dyYXBwZWQtd2VsbC1rbm93bi1zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9iaW5kLWNvbnRleHQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlci5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtaXRlcmF0b3ItY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLXBvc3NpYmxlLXByb3RvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC10by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZyZWV6aW5nLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2FsbC13aXRoLXNhZmUtaXRlcmF0aW9uLWNsb3NpbmcuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRlLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4taW5zdGFuY2UuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24uanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZGVmaW5lLWFsbC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29sbGVjdGlvbi1zdHJvbmcuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc2V0LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb20taXRlcmFibGVzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL25vbkl0ZXJhYmxlU3ByZWFkLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXkuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy91dGlscy9tZXRob2RzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWMuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1yZWdleHAuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9ub3QtYS1yZWdleHAuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3JyZWN0LWlzLXJlZ2V4cC1sb2dpYy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYWR2YW5jZS1zdHJpbmctaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWdleHAtZXhlYy1hYnN0cmFjdC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3doaXRlc3BhY2VzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLXRyaW0uanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mb3JjZWQtc3RyaW5nLXRyaW0tbWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy50cmltLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvdXRpbHMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL2NvcmUvbmFtZXNwYWNlcy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL3V0aWxzL3dpbmRvdy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvdHlwZXMvQmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL3V0aWxzL2Fkb3B0ZXIuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL29wdGlvbmFsL2FycmFuZ2UuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2xvcHB5LWFycmF5LW1ldGhvZC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmRleC1vZi5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5qb2luLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL2NvcmUvcmVnZXguanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL29wdGlvbmFsL2NsYXNzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktZm9yLWVhY2guanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZm9yLWVhY2guanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL21vZHVsZXMvb3B0aW9uYWwvY3NzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9vcHRpb25hbC9kYXRhLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9vcHRpb25hbC9tZW1vcnkuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1yZWR1Y2UuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkucmVkdWNlLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9jb3JlL2V2ZW50LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXAuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZGF0ZS50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wYXJzZS1pbnQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucGFyc2UtaW50LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhIb2xlcy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheUxpbWl0LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVSZXN0LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvdHlwZXMvQ29sb3IuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmtleXMuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLm1hdGNoLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc3VwZXJQcm9wQmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NldFByb3RvdHlwZU9mLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHMuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLmNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcGFyc2UtZmxvYXQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucGFyc2UtZmxvYXQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy90eXBlcy9Qb2ludC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL3R5cGVzL01hdHJpeC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL21vZHVsZXMvY29yZS9wYXJzZXIuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy90eXBlcy9Cb3guanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy90eXBlcy9BcnJheVBvbHlmaWxsLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvdHlwZXMvTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL21vZHVsZXMvY29yZS9zZWxlY3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL3R5cGVzL0V2ZW50VGFyZ2V0LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9jb3JlL2RlZmF1bHRzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvdHlwZXMvU1ZHQXJyYXkuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy90eXBlcy9TVkdOdW1iZXIuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL2NvcmUvYXR0ci5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL0RvbS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL0VsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL29wdGlvbmFsL3N1Z2FyLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnJldmVyc2UuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9vcHRpb25hbC90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL2NvcmUvY2lyY2xlZC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1NoYXBlLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvQ2lyY2xlLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvQ29udGFpbmVyLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvRGVmcy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL0VsbGlwc2UuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9TdG9wLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvbW9kdWxlcy9jb3JlL2dyYWRpZW50ZWQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9HcmFkaWVudC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1BhdHRlcm4uanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9JbWFnZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL3R5cGVzL1BvaW50QXJyYXkuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL2NvcmUvcG9pbnRlZC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL0xpbmUuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9NYXJrZXIuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc29ydC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2FuaW1hdGlvbi9Db250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvdHlwZXMvUGF0aEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvYW5pbWF0aW9uL01vcnBoYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1BhdGguanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tb2R1bGVzL2NvcmUvcG9seS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1BvbHlnb24uanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9Qb2x5bGluZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1JlY3QuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc3BsaWNlLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvYW5pbWF0aW9uL1F1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvYW5pbWF0aW9uL0FuaW1hdG9yLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvYW5pbWF0aW9uL1RpbWVsaW5lLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvYW5pbWF0aW9uL1J1bm5lci5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1N2Zy5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1N5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL21vZHVsZXMvY29yZS90ZXh0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1RleHQuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9Uc3Bhbi5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL0NsaXBQYXRoLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvRm9yZWlnbk9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL0cuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9BLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvTWFzay5qcyIsIm5vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL2Rpc3Qvbm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvc3JjL2VsZW1lbnRzL1N0eWxlLmpzIiwibm9kZV9tb2R1bGVzL0Bzdmdkb3Rqcy9zdmcuanMvZGlzdC9ub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9zcmMvZWxlbWVudHMvVGV4dFBhdGguanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9lbGVtZW50cy9Vc2UuanMiLCJub2RlX21vZHVsZXMvQHN2Z2RvdGpzL3N2Zy5qcy9kaXN0L25vZGVfbW9kdWxlcy9Ac3ZnZG90anMvc3ZnLmpzL3NyYy9tYWluLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbGliL19lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9kaXN0L2QzLXF1YWR0cmVlLmpzIiwibm9kZV9tb2R1bGVzL2ludGVyYWN0anMvZGlzdC9pbnRlcmFjdC5taW4uanMiLCJub2RlX21vZHVsZXMvaXNlY3QvYnVpbGQvaXNlY3QuanMiLCJub2RlX21vZHVsZXMvanN0cy9kaXN0L2pzdHMubWluLmpzIiwibm9kZV9tb2R1bGVzL2xvZ2xldmVsL2xpYi9sb2dsZXZlbC5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcG9seWsvZGlzdC9wb2x5ay5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcm91Z2hqcy9idW5kbGVkL3JvdWdoLmNqcy5qcyIsIm5vZGVfbW9kdWxlcy9zaW1wbGV4LW5vaXNlL3NpbXBsZXgtbm9pc2UuanMiLCJub2RlX21vZHVsZXMvc2ltcGxpZnktanMvc2ltcGxpZnkuanMiLCJzcmMvbWFpbi50cyIsInNyYy9tYXBfZ2VuZXJhdG9yLnRzIiwic3JjL3RzL1ZlY3Rvci50cyIsInNyYy90cy9pbXBsL2Jhc2lzX2ZpZWxkLnRzIiwic3JjL3RzL2ltcGwvZ3JhcGgudHMiLCJzcmMvdHMvaW1wbC9ncmlkX3N0b3JhZ2UudHMiLCJzcmMvdHMvaW1wbC9pbnRlZ3JhdG9yLnRzIiwic3JjL3RzL2ltcGwvcG9seWdvbl9maW5kZXIudHMiLCJzcmMvdHMvaW1wbC9wb2x5Z29uX3V0aWwudHMiLCJzcmMvdHMvaW1wbC9zdHJlYW1saW5lcy50cyIsInNyYy90cy9pbXBsL3RlbnNvci50cyIsInNyYy90cy9pbXBsL3RlbnNvcl9maWVsZC50cyIsInNyYy90cy9pbXBsL3dhdGVyX2dlbmVyYXRvci50cyIsInNyYy90cy91aS9idWlsZGluZ3MudHMiLCJzcmMvdHMvdWkvY2FudmFzX3dyYXBwZXIudHMiLCJzcmMvdHMvdWkvZG9tYWluX2NvbnRyb2xsZXIudHMiLCJzcmMvdHMvdWkvZHJhZ19jb250cm9sbGVyLnRzIiwic3JjL3RzL3VpL21haW5fZ3VpLnRzIiwic3JjL3RzL3VpL3JvYWRfZ3VpLnRzIiwic3JjL3RzL3VpL3N0eWxlLnRzIiwic3JjL3RzL3VpL3RlbnNvcl9maWVsZF9ndWkudHMiLCJzcmMvdHMvdWkvd2F0ZXJfZ3VpLnRzIiwic3JjL3RzL3V0aWwudHMiLCJzcmMvdHMvdmVjdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0FBLElBQUksS0FBSyxHQUFHLFNBQVIsS0FBUSxDQUFVLEVBQVYsRUFBYztBQUN4QixTQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsSUFBSCxJQUFXLElBQWpCLElBQXlCLEVBQWhDO0FBQ0QsQ0FGRCxDOzs7QUFLQSxJQUFBLFFBQWMsRztBQUVaLEtBQUssQ0FBQyxRQUFPLFVBQVAsMENBQU8sVUFBUCxNQUFxQixRQUFyQixJQUFpQyxVQUFsQyxDQUFMLElBQ0EsS0FBSyxDQUFDLFFBQU8sTUFBUCwwQ0FBTyxNQUFQLE1BQWlCLFFBQWpCLElBQTZCLE1BQTlCLENBREwsSUFFQSxLQUFLLENBQUMsUUFBTyxJQUFQLDBDQUFPLElBQVAsTUFBZSxRQUFmLElBQTJCLElBQTVCLENBRkwsSUFHQSxLQUFLLENBQUMsU0FBTyxjQUFQLEtBQWlCLFFBQWpCLElBQTZCLGNBQTlCLENBSEwsSTtBQUtBLFFBQVEsQ0FBQyxhQUFELENBQVIsRUFQRjs7QUNMQSxJQUFBLEtBQWMsR0FBRyxTQUFqQixLQUFpQixDQUFVLElBQVYsRUFBZ0I7QUFDL0IsTUFBSTtBQUNGLFdBQU8sQ0FBQyxDQUFDLElBQUksRUFBYjtBQUNELEdBRkQsQ0FFRSxPQUFPLEtBQVAsRUFBYztBQUNkLFdBQU8sSUFBUDtBQUNEO0FBQ0YsQ0FORCxDLENDRUE7OztBQUNBLElBQUEsV0FBYyxHQUFHLENBQUMsS0FBSyxD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25hQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2h2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFPLElBQVA7QUFDSCxHQUhEOztBQUtBLEVBQUEsTUFBQSxDQUFBLFNBQUEsQ0FBQSxTQUFBLEdBQUEsVUFBVyxNQUFYLEVBQXlCO0FBQ3JCLFdBQU8sS0FBSyxTQUFMLEdBQWlCLGNBQWpCLENBQWdDLE1BQWhDLENBQVA7QUFDSCxHQUZEOztBQUlBLEVBQUEsTUFBQSxDQUFBLFNBQUEsQ0FBQSxHQUFBLEdBQUEsVUFBSSxDQUFKLEVBQWE7QUFDVCxTQUFLLENBQUwsSUFBVSxDQUFDLENBQUMsQ0FBWjtBQUNBLFNBQUssQ0FBTCxJQUFVLENBQUMsQ0FBQyxDQUFaO0FBQ0EsV0FBTyxJQUFQO0FBQ0gsR0FKRDs7QUFLSixTQUFBLE1BQUE7QUFBQyxDQS9LRCxFQUFBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwidmFyIGNoZWNrID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAmJiBpdC5NYXRoID09IE1hdGggJiYgaXQ7XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxubW9kdWxlLmV4cG9ydHMgPVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8XG4gIGNoZWNrKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYpIHx8XG4gIGNoZWNrKHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsKSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxuLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gTmFzaG9ybiB+IEpESzggYnVnXG52YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgIW5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAxOiAyIH0sIDEpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXG5leHBvcnRzLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6IG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcblxudmFyIHNwbGl0ID0gJycuc3BsaXQ7XG5cbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG5tb2R1bGUuZXhwb3J0cyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhyb3dzIGFuIGVycm9yIGluIHJoaW5vLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcmhpbm8vaXNzdWVzLzM0NlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIHJldHVybiAhT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XG59KSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY2xhc3NvZihpdCkgPT0gJ1N0cmluZycgPyBzcGxpdC5jYWxsKGl0LCAnJykgOiBPYmplY3QoaXQpO1xufSA6IE9iamVjdDtcbiIsIi8vIGBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlcXVpcmVvYmplY3Rjb2VyY2libGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0Jyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEluZGV4ZWRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShpdCkpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG4vLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9wcmltaXRpdmVcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQsIFBSRUZFUlJFRF9TVFJJTkcpIHtcbiAgaWYgKCFpc09iamVjdChpbnB1dCkpIHJldHVybiBpbnB1dDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChQUkVGRVJSRURfU1RSSU5HICYmIHR5cGVvZiAoZm4gPSBpbnB1dC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGlucHV0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFQUkVGRVJSRURfU1RSSU5HICYmIHR5cGVvZiAoZm4gPSBpbnB1dC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxudmFyIGRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgRVhJU1RTID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gRVhJU1RTID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGNyZWF0ZUVsZW1lbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQnKTtcblxuLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhREVTQ1JJUFRPUlMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdGVFbGVtZW50KCdkaXYnKSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9XG4gIH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUnKTtcblxudmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSW5kZXhlZE9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCFwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKGl0KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xuICB9IHJldHVybiBpdDtcbn07XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pZTgtZG9tLWRlZmluZScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZScpO1xuXG52YXIgbmF0aXZlRGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG5leHBvcnRzLmYgPSBERVNDUklQVE9SUyA/IG5hdGl2ZURlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG4iLCJ2YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gREVTQ1JJUFRPUlMgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoZ2xvYmFsLCBrZXksIHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBnbG9iYWxba2V5XSA9IHZhbHVlO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHNldEdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtZ2xvYmFsJyk7XG5cbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IHNldEdsb2JhbChTSEFSRUQsIHt9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdG9yZTtcbiIsInZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBzdG9yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQtc3RvcmUnKTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246ICczLjMuNicsXG4gIG1vZGU6IElTX1BVUkUgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAxOSBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzaGFyZWQoJ25hdGl2ZS1mdW5jdGlvbi10by1zdHJpbmcnLCBGdW5jdGlvbi50b1N0cmluZyk7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIG5hdGl2ZUZ1bmN0aW9uVG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdG8tc3RyaW5nJyk7XG5cbnZhciBXZWFrTWFwID0gZ2xvYmFsLldlYWtNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KG5hdGl2ZUZ1bmN0aW9uVG9TdHJpbmcuY2FsbChXZWFrTWFwKSk7XG4iLCJ2YXIgaWQgPSAwO1xudmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJyArIFN0cmluZyhrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5KSArICcpXycgKyAoKytpZCArIHBvc3RmaXgpLnRvU3RyaW5nKDM2KTtcbn07XG4iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91aWQnKTtcblxudmFyIGtleXMgPSBzaGFyZWQoJ2tleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlzW2tleV0gfHwgKGtleXNba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwidmFyIE5BVElWRV9XRUFLX01BUCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIG9iamVjdEhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBzaGFyZWRLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcblxudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcbnZhciBzZXQsIGdldCwgaGFzO1xuXG52YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaGFzKGl0KSA/IGdldChpdCkgOiBzZXQoaXQsIHt9KTtcbn07XG5cbnZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIHN0YXRlO1xuICAgIGlmICghaXNPYmplY3QoaXQpIHx8IChzdGF0ZSA9IGdldChpdCkpLnR5cGUgIT09IFRZUEUpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQnKTtcbiAgICB9IHJldHVybiBzdGF0ZTtcbiAgfTtcbn07XG5cbmlmIChOQVRJVkVfV0VBS19NQVApIHtcbiAgdmFyIHN0b3JlID0gbmV3IFdlYWtNYXAoKTtcbiAgdmFyIHdtZ2V0ID0gc3RvcmUuZ2V0O1xuICB2YXIgd21oYXMgPSBzdG9yZS5oYXM7XG4gIHZhciB3bXNldCA9IHN0b3JlLnNldDtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIHdtc2V0LmNhbGwoc3RvcmUsIGl0LCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21nZXQuY2FsbChzdG9yZSwgaXQpIHx8IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21oYXMuY2FsbChzdG9yZSwgaXQpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIFNUQVRFID0gc2hhcmVkS2V5KCdzdGF0ZScpO1xuICBoaWRkZW5LZXlzW1NUQVRFXSA9IHRydWU7XG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gb2JqZWN0SGFzKGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIG9iamVjdEhhcyhpdCwgU1RBVEUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXQsXG4gIGdldDogZ2V0LFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHNldEdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtZ2xvYmFsJyk7XG52YXIgbmF0aXZlRnVuY3Rpb25Ub1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi10by1zdHJpbmcnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG5cbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG52YXIgZW5mb3JjZUludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmVuZm9yY2U7XG52YXIgVEVNUExBVEUgPSBTdHJpbmcobmF0aXZlRnVuY3Rpb25Ub1N0cmluZykuc3BsaXQoJ3RvU3RyaW5nJyk7XG5cbnNoYXJlZCgnaW5zcGVjdFNvdXJjZScsIGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gbmF0aXZlRnVuY3Rpb25Ub1N0cmluZy5jYWxsKGl0KTtcbn0pO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICB2YXIgdW5zYWZlID0gb3B0aW9ucyA/ICEhb3B0aW9ucy51bnNhZmUgOiBmYWxzZTtcbiAgdmFyIHNpbXBsZSA9IG9wdGlvbnMgPyAhIW9wdGlvbnMuZW51bWVyYWJsZSA6IGZhbHNlO1xuICB2YXIgbm9UYXJnZXRHZXQgPSBvcHRpb25zID8gISFvcHRpb25zLm5vVGFyZ2V0R2V0IDogZmFsc2U7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmICh0eXBlb2Yga2V5ID09ICdzdHJpbmcnICYmICFoYXModmFsdWUsICduYW1lJykpIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSh2YWx1ZSwgJ25hbWUnLCBrZXkpO1xuICAgIGVuZm9yY2VJbnRlcm5hbFN0YXRlKHZhbHVlKS5zb3VyY2UgPSBURU1QTEFURS5qb2luKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyBrZXkgOiAnJyk7XG4gIH1cbiAgaWYgKE8gPT09IGdsb2JhbCkge1xuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICAgIGVsc2Ugc2V0R2xvYmFsKGtleSwgdmFsdWUpO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmICghdW5zYWZlKSB7XG4gICAgZGVsZXRlIE9ba2V5XTtcbiAgfSBlbHNlIGlmICghbm9UYXJnZXRHZXQgJiYgT1trZXldKSB7XG4gICAgc2ltcGxlID0gdHJ1ZTtcbiAgfVxuICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgZWxzZSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoTywga2V5LCB2YWx1ZSk7XG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbn0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIGdldEludGVybmFsU3RhdGUodGhpcykuc291cmNlIHx8IG5hdGl2ZUZ1bmN0aW9uVG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG4iLCJ2YXIgcGF0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wYXRoJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xuXG52YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKHZhcmlhYmxlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFyaWFibGUgPT0gJ2Z1bmN0aW9uJyA/IHZhcmlhYmxlIDogdW5kZWZpbmVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBtZXRob2QpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gYUZ1bmN0aW9uKHBhdGhbbmFtZXNwYWNlXSkgfHwgYUZ1bmN0aW9uKGdsb2JhbFtuYW1lc3BhY2VdKVxuICAgIDogcGF0aFtuYW1lc3BhY2VdICYmIHBhdGhbbmFtZXNwYWNlXVttZXRob2RdIHx8IGdsb2JhbFtuYW1lc3BhY2VdICYmIGdsb2JhbFtuYW1lc3BhY2VdW21ldGhvZF07XG59O1xuIiwidmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4vLyBgVG9JbnRlZ2VyYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvaW50ZWdlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGlzTmFOKGFyZ3VtZW50ID0gK2FyZ3VtZW50KSA/IDAgOiAoYXJndW1lbnQgPiAwID8gZmxvb3IgOiBjZWlsKShhcmd1bWVudCk7XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG5cbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gYFRvTGVuZ3RoYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluKHRvSW50ZWdlcihhcmd1bWVudCksIDB4MUZGRkZGRkZGRkZGRkYpIDogMDsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlcicpO1xuXG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4obGVuZ3RoLCBsZW5ndGgpLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbnRlZ2VyIDwgMCA/IG1heChpbnRlZ2VyICsgbGVuZ3RoLCAwKSA6IG1pbihpbnRlZ2VyLCBsZW5ndGgpO1xufTtcbiIsInZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXgnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgaWYgKChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSAmJiBPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4gIGluY2x1ZGVzOiBjcmVhdGVNZXRob2QodHJ1ZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4gIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZChmYWxzZSlcbn07XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIGluZGV4T2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMnKS5pbmRleE9mO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhcyhoaWRkZW5LZXlzLCBrZXkpICYmIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+aW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIElFOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdjb25zdHJ1Y3RvcicsXG4gICdoYXNPd25Qcm9wZXJ0eScsXG4gICdpc1Byb3RvdHlwZU9mJyxcbiAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgJ3RvU3RyaW5nJyxcbiAgJ3ZhbHVlT2YnXG5dO1xuIiwidmFyIGludGVybmFsT2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VudW0tYnVnLWtleXMnKTtcblxudmFyIGhpZGRlbktleXMgPSBlbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG4iLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuIiwidmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignUmVmbGVjdCcsICdvd25LZXlzJykgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZihhbk9iamVjdChpdCkpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBvd25LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL293bi1rZXlzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG4gIHZhciBrZXlzID0gb3duS2V5cyhzb3VyY2UpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xuICB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmICghaGFzKHRhcmdldCwga2V5KSkgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICB9XG59O1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbnZhciByZXBsYWNlbWVudCA9IC8jfFxcLnByb3RvdHlwZVxcLi87XG5cbnZhciBpc0ZvcmNlZCA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuICByZXR1cm4gdmFsdWUgPT0gUE9MWUZJTEwgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZVxuICAgIDogdHlwZW9mIGRldGVjdGlvbiA9PSAnZnVuY3Rpb24nID8gZmFpbHMoZGV0ZWN0aW9uKVxuICAgIDogISFkZXRlY3Rpb247XG59O1xuXG52YXIgbm9ybWFsaXplID0gaXNGb3JjZWQubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGRhdGEgPSBpc0ZvcmNlZC5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQuTkFUSVZFID0gJ04nO1xudmFyIFBPTFlGSUxMID0gaXNGb3JjZWQuUE9MWUZJTEwgPSAnUCc7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGb3JjZWQ7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJykuZjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciBzZXRHbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCcpO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzJyk7XG52YXIgaXNGb3JjZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtZm9yY2VkJyk7XG5cbi8qXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XG4gIG9wdGlvbnMuZ2xvYmFsICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5wcm90byAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5yZWFsICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG4gIG9wdGlvbnMuYmluZCAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLndyYXAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMudW5zYWZlICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcbiAgb3B0aW9ucy5zaGFtICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgb3B0aW9ucy5lbnVtZXJhYmxlICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG4gIG9wdGlvbnMubm9UYXJnZXRHZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcbiAgdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xuICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuICB2YXIgRk9SQ0VELCB0YXJnZXQsIGtleSwgdGFyZ2V0UHJvcGVydHksIHNvdXJjZVByb3BlcnR5LCBkZXNjcmlwdG9yO1xuICBpZiAoR0xPQkFMKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKFNUQVRJQykge1xuICAgIHRhcmdldCA9IGdsb2JhbFtUQVJHRVRdIHx8IHNldEdsb2JhbChUQVJHRVQsIHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSAoZ2xvYmFsW1RBUkdFVF0gfHwge30pLnByb3RvdHlwZTtcbiAgfVxuICBpZiAodGFyZ2V0KSBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICBzb3VyY2VQcm9wZXJ0eSA9IHNvdXJjZVtrZXldO1xuICAgIGlmIChvcHRpb25zLm5vVGFyZ2V0R2V0KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICAgLy8gY29udGFpbmVkIGluIHRhcmdldFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT09IHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSkgY29udGludWU7XG4gICAgICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgICBpZiAob3B0aW9ucy5zaGFtIHx8ICh0YXJnZXRQcm9wZXJ0eSAmJiB0YXJnZXRQcm9wZXJ0eS5zaGFtKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG5cbi8vIGBJc0FycmF5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlzYXJyYXlcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY2xhc3NvZihhcmcpID09ICdBcnJheSc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZScpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBwcm9wZXJ0eUtleSA9IHRvUHJpbWl0aXZlKGtleSk7XG4gIGlmIChwcm9wZXJ0eUtleSBpbiBvYmplY3QpIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBwcm9wZXJ0eUtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W3Byb3BlcnR5S2V5XSA9IHZhbHVlO1xufTtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICEhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgcmV0dXJuICFTdHJpbmcoU3ltYm9sKCkpO1xufSk7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG52YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtc3ltYm9sJyk7XG5cbnZhciBTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyIHN0b3JlID0gc2hhcmVkKCd3a3MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID0gTkFUSVZFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV1cbiAgICB8fCAoTkFUSVZFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcbiIsInZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ25hdmlnYXRvcicsICd1c2VyQWdlbnQnKSB8fCAnJztcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VzZXItYWdlbnQnKTtcblxudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MgJiYgcHJvY2Vzcy52ZXJzaW9ucztcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4O1xudmFyIG1hdGNoLCB2ZXJzaW9uO1xuXG5pZiAodjgpIHtcbiAgbWF0Y2ggPSB2OC5zcGxpdCgnLicpO1xuICB2ZXJzaW9uID0gbWF0Y2hbMF0gKyBtYXRjaFsxXTtcbn0gZWxzZSBpZiAodXNlckFnZW50KSB7XG4gIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9FZGdlXFwvKFxcZCspLyk7XG4gIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcbiAgICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG4gICAgaWYgKG1hdGNoKSB2ZXJzaW9uID0gbWF0Y2hbMV07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2ZXJzaW9uICYmICt2ZXJzaW9uO1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgVjhfVkVSU0lPTiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy92OC12ZXJzaW9uJyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gIC8vIFdlIGNhbid0IHVzZSB0aGlzIGZlYXR1cmUgZGV0ZWN0aW9uIGluIFY4IHNpbmNlIGl0IGNhdXNlc1xuICAvLyBkZW9wdGltaXphdGlvbiBhbmQgc2VyaW91cyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc3XG4gIHJldHVybiBWOF9WRVJTSU9OID49IDUxIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gYXJyYXkuY29uc3RydWN0b3IgPSB7fTtcbiAgICBjb25zdHJ1Y3RvcltTUEVDSUVTXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGZvbzogMSB9O1xuICAgIH07XG4gICAgcmV0dXJuIGFycmF5W01FVEhPRF9OQU1FXShCb29sZWFuKS5mb28gIT09IDE7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXknKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHknKTtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0Jyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG52YXIgbmF0aXZlU2xpY2UgPSBbXS5zbGljZTtcbnZhciBtYXggPSBNYXRoLm1heDtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5zbGljZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc2xpY2Vcbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBFUzMgc3RyaW5ncyBhbmQgRE9NIG9iamVjdHNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0KCdzbGljZScpIH0sIHtcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBrID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW5ndGgpO1xuICAgIHZhciBmaW4gPSB0b0Fic29sdXRlSW5kZXgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQsIGxlbmd0aCk7XG4gICAgLy8gaW5saW5lIGBBcnJheVNwZWNpZXNDcmVhdGVgIGZvciB1c2FnZSBuYXRpdmUgYEFycmF5I3NsaWNlYCB3aGVyZSBpdCdzIHBvc3NpYmxlXG4gICAgdmFyIENvbnN0cnVjdG9yLCByZXN1bHQsIG47XG4gICAgaWYgKGlzQXJyYXkoTykpIHtcbiAgICAgIENvbnN0cnVjdG9yID0gTy5jb25zdHJ1Y3RvcjtcbiAgICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgICBpZiAodHlwZW9mIENvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgKENvbnN0cnVjdG9yID09PSBBcnJheSB8fCBpc0FycmF5KENvbnN0cnVjdG9yLnByb3RvdHlwZSkpKSB7XG4gICAgICAgIENvbnN0cnVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcltTUEVDSUVTXTtcbiAgICAgICAgaWYgKENvbnN0cnVjdG9yID09PSBudWxsKSBDb25zdHJ1Y3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChDb25zdHJ1Y3RvciA9PT0gQXJyYXkgfHwgQ29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmF0aXZlU2xpY2UuY2FsbChPLCBrLCBmaW4pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQgPSBuZXcgKENvbnN0cnVjdG9yID09PSB1bmRlZmluZWQgPyBBcnJheSA6IENvbnN0cnVjdG9yKShtYXgoZmluIC0gaywgMCkpO1xuICAgIGZvciAobiA9IDA7IGsgPCBmaW47IGsrKywgbisrKSBpZiAoayBpbiBPKSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIG4sIE9ba10pO1xuICAgIHJlc3VsdC5sZW5ndGggPSBuO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBGdW5jdGlvblByb3RvdHlwZVRvU3RyaW5nID0gRnVuY3Rpb25Qcm90b3R5cGUudG9TdHJpbmc7XG52YXIgbmFtZVJFID0gL15cXHMqZnVuY3Rpb24gKFteIChdKikvO1xudmFyIE5BTUUgPSAnbmFtZSc7XG5cbi8vIEZ1bmN0aW9uIGluc3RhbmNlcyBgLm5hbWVgIHByb3BlcnR5XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1mdW5jdGlvbi1pbnN0YW5jZXMtbmFtZVxuaWYgKERFU0NSSVBUT1JTICYmICEoTkFNRSBpbiBGdW5jdGlvblByb3RvdHlwZSkpIHtcbiAgZGVmaW5lUHJvcGVydHkoRnVuY3Rpb25Qcm90b3R5cGUsIE5BTUUsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb25Qcm90b3R5cGVUb1N0cmluZy5jYWxsKHRoaXMpLm1hdGNoKG5hbWVSRSlbMV07XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbiIsInZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzJykuZjtcblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyhpdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJ1xuICAgID8gZ2V0V2luZG93TmFtZXMoaXQpXG4gICAgOiBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzKHRvSW5kZXhlZE9iamVjdChpdCkpO1xufTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy1leHRlcm5hbCcpLmY7XG5cbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkgeyByZXR1cm4gIU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKDEpOyB9KTtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGQUlMU19PTl9QUklNSVRJVkVTIH0sIHtcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lc1xufSk7XG4iLCJmdW5jdGlvbiBfdHlwZW9mMihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YyID0gZnVuY3Rpb24gX3R5cGVvZjIob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mMiA9IGZ1bmN0aW9uIF90eXBlb2YyKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZjIob2JqKTsgfVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIF90eXBlb2YyKFN5bWJvbC5pdGVyYXRvcikgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBfdHlwZW9mMihvYmopO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogX3R5cGVvZjIob2JqKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn0iLCJ2YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcblxuLy8gYFRvT2JqZWN0YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpKTtcbn07XG4iLCJ2YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cycpO1xuXG4vLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzJyk7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydGllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IG9iamVjdEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIFByb3BlcnRpZXNba2V5XSk7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ2RvY3VtZW50JywgJ2RvY3VtZW50RWxlbWVudCcpO1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGRlZmluZVByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cycpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2h0bWwnKTtcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQnKTtcbnZhciBzaGFyZWRLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpO1xudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xuXG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgc2NyaXB0ID0gJ3NjcmlwdCc7XG4gIHZhciBndCA9ICc+JztcbiAgdmFyIGpzID0gJ2phdmEnICsgc2NyaXB0ICsgJzonO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBodG1sLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSBTdHJpbmcoanMpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgc2NyaXB0ICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnLycgKyBzY3JpcHQgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbbGVuZ3RoXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG4vLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZGVmaW5lUHJvcGVydGllcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcblxuaGlkZGVuS2V5c1tJRV9QUk9UT10gPSB0cnVlO1xuIiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG4iLCJ2YXIgcGF0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wYXRoJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd3JhcHBlZC13ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FKSB7XG4gIHZhciBTeW1ib2wgPSBwYXRoLlN5bWJvbCB8fCAocGF0aC5TeW1ib2wgPSB7fSk7XG4gIGlmICghaGFzKFN5bWJvbCwgTkFNRSkpIGRlZmluZVByb3BlcnR5KFN5bWJvbCwgTkFNRSwge1xuICAgIHZhbHVlOiB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlLmYoTkFNRSlcbiAgfSk7XG59O1xuIiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBUQUcsIFNUQVRJQykge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IFNUQVRJQyA/IGl0IDogaXQucHJvdG90eXBlLCBUT19TVFJJTkdfVEFHKSkge1xuICAgIGRlZmluZVByb3BlcnR5KGl0LCBUT19TVFJJTkdfVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IFRBRyB9KTtcbiAgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICB9IHJldHVybiBpdDtcbn07XG4iLCJ2YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb24nKTtcblxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0KTtcbiAgICB9O1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5Jyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbi8vIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbEFycmF5LCBsZW5ndGgpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsQXJyYXkpKSB7XG4gICAgQyA9IG9yaWdpbmFsQXJyYXkuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZiAodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKSBDID0gdW5kZWZpbmVkO1xuICAgIGVsc2UgaWYgKGlzT2JqZWN0KEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gbmV3IChDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEMpKGxlbmd0aCA9PT0gMCA/IDAgOiBsZW5ndGgpO1xufTtcbiIsInZhciBiaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2JpbmQtY29udGV4dCcpO1xudmFyIEluZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcblxudmFyIHB1c2ggPSBbXS5wdXNoO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgZm9yRWFjaCwgbWFwLCBmaWx0ZXIsIHNvbWUsIGV2ZXJ5LCBmaW5kLCBmaW5kSW5kZXggfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCwgc3BlY2lmaWNDcmVhdGUpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgc2VsZiA9IEluZGV4ZWRPYmplY3QoTyk7XG4gICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGNhbGxiYWNrZm4sIHRoYXQsIDMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgY3JlYXRlID0gc3BlY2lmaWNDcmVhdGUgfHwgYXJyYXlTcGVjaWVzQ3JlYXRlO1xuICAgIHZhciB0YXJnZXQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWx1ZSwgcmVzdWx0O1xuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgICAgdmFsdWUgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlc3VsdCA9IGJvdW5kRnVuY3Rpb24odmFsdWUsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHRhcmdldFtpbmRleF0gPSByZXN1bHQ7IC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXN1bHQpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsdWU7ICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiBwdXNoLmNhbGwodGFyZ2V0LCB2YWx1ZSk7IC8vIGZpbHRlclxuICAgICAgICB9IGVsc2UgaWYgKElTX0VWRVJZKSByZXR1cm4gZmFsc2U7ICAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogdGFyZ2V0O1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG4gIGZvckVhY2g6IGNyZWF0ZU1ldGhvZCgwKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5tYXBgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUubWFwXG4gIG1hcDogY3JlYXRlTWV0aG9kKDEpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcbiAgZmlsdGVyOiBjcmVhdGVNZXRob2QoMiksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuc29tZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb21lXG4gIHNvbWU6IGNyZWF0ZU1ldGhvZCgzKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5ldmVyeWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5ldmVyeVxuICBldmVyeTogY3JlYXRlTWV0aG9kKDQpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZFxuICBmaW5kOiBjcmVhdGVNZXRob2QoNSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRJbmRleFxuICBmaW5kSW5kZXg6IGNyZWF0ZU1ldGhvZCg2KVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIE5BVElWRV9TWU1CT0wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXknKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBuYXRpdmVPYmplY3RDcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLWV4dGVybmFsJyk7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZScpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQnKTtcbnZhciBzaGFyZWRLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93cmFwcGVkLXdlbGwta25vd24tc3ltYm9sJyk7XG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xudmFyICRmb3JFYWNoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbicpLmZvckVhY2g7XG5cbnZhciBISURERU4gPSBzaGFyZWRLZXkoJ2hpZGRlbicpO1xudmFyIFNZTUJPTCA9ICdTeW1ib2wnO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCgndG9QcmltaXRpdmUnKTtcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFNZTUJPTCk7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0W1BST1RPVFlQRV07XG52YXIgJFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgSlNPTiA9IGdsb2JhbC5KU09OO1xudmFyIG5hdGl2ZUpTT05TdHJpbmdpZnkgPSBKU09OICYmIEpTT04uc3RyaW5naWZ5O1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xudmFyIG5hdGl2ZURlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzID0gZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsLmY7XG52YXIgbmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mO1xudmFyIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKTtcbnZhciBPYmplY3RQcm90b3R5cGVTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgU3RyaW5nVG9TeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3RyaW5nLXRvLXN5bWJvbC1yZWdpc3RyeScpO1xudmFyIFN5bWJvbFRvU3RyaW5nUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC10by1zdHJpbmctcmVnaXN0cnknKTtcbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQoJ3drcycpO1xudmFyIFFPYmplY3QgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIFVTRV9TRVRURVIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjcmlwdG9yID0gREVTQ1JJUFRPUlMgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0Q3JlYXRlKG5hdGl2ZURlZmluZVByb3BlcnR5KHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KHRoaXMsICdhJywgeyB2YWx1ZTogNyB9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uIChPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIHZhciBPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yID0gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdFByb3RvdHlwZSwgUCk7XG4gIGlmIChPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yKSBkZWxldGUgT2JqZWN0UHJvdG90eXBlW1BdO1xuICBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgaWYgKE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IgJiYgTyAhPT0gT2JqZWN0UHJvdG90eXBlKSB7XG4gICAgbmF0aXZlRGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG90eXBlLCBQLCBPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yKTtcbiAgfVxufSA6IG5hdGl2ZURlZmluZVByb3BlcnR5O1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uICh0YWcsIGRlc2NyaXB0aW9uKSB7XG4gIHZhciBzeW1ib2wgPSBBbGxTeW1ib2xzW3RhZ10gPSBuYXRpdmVPYmplY3RDcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc2V0SW50ZXJuYWxTdGF0ZShzeW1ib2wsIHtcbiAgICB0eXBlOiBTWU1CT0wsXG4gICAgdGFnOiB0YWcsXG4gICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uXG4gIH0pO1xuICBpZiAoIURFU0NSSVBUT1JTKSBzeW1ib2wuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgcmV0dXJuIHN5bWJvbDtcbn07XG5cbnZhciBpc1N5bWJvbCA9IE5BVElWRV9TWU1CT0wgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChpdCkgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgaWYgKE8gPT09IE9iamVjdFByb3RvdHlwZSkgJGRlZmluZVByb3BlcnR5KE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIFAsIEF0dHJpYnV0ZXMpO1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleSA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpKSB7XG4gICAgaWYgKCFBdHRyaWJ1dGVzLmVudW1lcmFibGUpIHtcbiAgICAgIGlmICghaGFzKE8sIEhJRERFTikpIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIEhJRERFTiwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHt9KSk7XG4gICAgICBPW0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXMoTywgSElEREVOKSAmJiBPW0hJRERFTl1ba2V5XSkgT1tISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEF0dHJpYnV0ZXMgPSBuYXRpdmVPYmplY3RDcmVhdGUoQXR0cmlidXRlcywgeyBlbnVtZXJhYmxlOiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgZmFsc2UpIH0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2NyaXB0b3IoTywga2V5LCBBdHRyaWJ1dGVzKTtcbiAgfSByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkoTywga2V5LCBBdHRyaWJ1dGVzKTtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIHByb3BlcnRpZXMgPSB0b0luZGV4ZWRPYmplY3QoUHJvcGVydGllcyk7XG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhwcm9wZXJ0aWVzKS5jb25jYXQoJGdldE93blByb3BlcnR5U3ltYm9scyhwcm9wZXJ0aWVzKSk7XG4gICRmb3JFYWNoKGtleXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIURFU0NSSVBUT1JTIHx8ICRwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHByb3BlcnRpZXMsIGtleSkpICRkZWZpbmVQcm9wZXJ0eShPLCBrZXksIHByb3BlcnRpZXNba2V5XSk7XG4gIH0pO1xuICByZXR1cm4gTztcbn07XG5cbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IG5hdGl2ZU9iamVjdENyZWF0ZShPKSA6ICRkZWZpbmVQcm9wZXJ0aWVzKG5hdGl2ZU9iamVjdENyZWF0ZShPKSwgUHJvcGVydGllcyk7XG59O1xuXG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgUCA9IHRvUHJpbWl0aXZlKFYsIHRydWUpO1xuICB2YXIgZW51bWVyYWJsZSA9IG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodGhpcywgUCk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90b3R5cGUgJiYgaGFzKEFsbFN5bWJvbHMsIFApICYmICFoYXMoT2JqZWN0UHJvdG90eXBlU3ltYm9scywgUCkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGVudW1lcmFibGUgfHwgIWhhcyh0aGlzLCBQKSB8fCAhaGFzKEFsbFN5bWJvbHMsIFApIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtQXSA/IGVudW1lcmFibGUgOiB0cnVlO1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICB2YXIgaXQgPSB0b0luZGV4ZWRPYmplY3QoTyk7XG4gIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90b3R5cGUgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPYmplY3RQcm90b3R5cGVTeW1ib2xzLCBrZXkpKSByZXR1cm47XG4gIHZhciBkZXNjcmlwdG9yID0gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpO1xuICBpZiAoZGVzY3JpcHRvciAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSB7XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZGVzY3JpcHRvcjtcbn07XG5cbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICB2YXIgbmFtZXMgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzKHRvSW5kZXhlZE9iamVjdChPKSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgJGZvckVhY2gobmFtZXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIWhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoaGlkZGVuS2V5cywga2V5KSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhPKSB7XG4gIHZhciBJU19PQkpFQ1RfUFJPVE9UWVBFID0gTyA9PT0gT2JqZWN0UHJvdG90eXBlO1xuICB2YXIgbmFtZXMgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzKElTX09CSkVDVF9QUk9UT1RZUEUgPyBPYmplY3RQcm90b3R5cGVTeW1ib2xzIDogdG9JbmRleGVkT2JqZWN0KE8pKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICAkZm9yRWFjaChuYW1lcywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSAmJiAoIUlTX09CSkVDVF9QUk9UT1RZUEUgfHwgaGFzKE9iamVjdFByb3RvdHlwZSwga2V5KSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIGBTeW1ib2xgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wtY29uc3RydWN0b3JcbmlmICghTkFUSVZFX1NZTUJPTCkge1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCkgdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3InKTtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSAhYXJndW1lbnRzLmxlbmd0aCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IFN0cmluZyhhcmd1bWVudHNbMF0pO1xuICAgIHZhciB0YWcgPSB1aWQoZGVzY3JpcHRpb24pO1xuICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90b3R5cGUpIHNldHRlci5jYWxsKE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmIChoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKSB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzY3JpcHRvcih0aGlzLCB0YWcsIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYgKERFU0NSSVBUT1JTICYmIFVTRV9TRVRURVIpIHNldFN5bWJvbERlc2NyaXB0b3IoT2JqZWN0UHJvdG90eXBlLCB0YWcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6IHNldHRlciB9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcsIGRlc2NyaXB0aW9uKTtcbiAgfTtcblxuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnRhZztcbiAgfSk7XG5cbiAgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgZGVmaW5lUHJvcGVydHlNb2R1bGUuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYgKERFU0NSSVBUT1JTKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtU3ltYm9sLWRlc2NyaXB0aW9uXG4gICAgbmF0aXZlRGVmaW5lUHJvcGVydHkoJFN5bWJvbFtQUk9UT1RZUEVdLCAnZGVzY3JpcHRpb24nLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5kZXNjcmlwdGlvbjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIUlTX1BVUkUpIHtcbiAgICAgIHJlZGVmaW5lKE9iamVjdFByb3RvdHlwZSwgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB7IHVuc2FmZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH1cblxuICB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlLmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdlbGxLbm93blN5bWJvbChuYW1lKSwgbmFtZSk7XG4gIH07XG59XG5cbiQoeyBnbG9iYWw6IHRydWUsIHdyYXA6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wsIHNoYW06ICFOQVRJVkVfU1lNQk9MIH0sIHtcbiAgU3ltYm9sOiAkU3ltYm9sXG59KTtcblxuJGZvckVhY2gob2JqZWN0S2V5cyhXZWxsS25vd25TeW1ib2xzU3RvcmUpLCBmdW5jdGlvbiAobmFtZSkge1xuICBkZWZpbmVXZWxsS25vd25TeW1ib2wobmFtZSk7XG59KTtcblxuJCh7IHRhcmdldDogU1lNQk9MLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MIH0sIHtcbiAgLy8gYFN5bWJvbC5mb3JgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wuZm9yXG4gICdmb3InOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHN0cmluZyA9IFN0cmluZyhrZXkpO1xuICAgIGlmIChoYXMoU3RyaW5nVG9TeW1ib2xSZWdpc3RyeSwgc3RyaW5nKSkgcmV0dXJuIFN0cmluZ1RvU3ltYm9sUmVnaXN0cnlbc3RyaW5nXTtcbiAgICB2YXIgc3ltYm9sID0gJFN5bWJvbChzdHJpbmcpO1xuICAgIFN0cmluZ1RvU3ltYm9sUmVnaXN0cnlbc3RyaW5nXSA9IHN5bWJvbDtcbiAgICBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5W3N5bWJvbF0gPSBzdHJpbmc7XG4gICAgcmV0dXJuIHN5bWJvbDtcbiAgfSxcbiAgLy8gYFN5bWJvbC5rZXlGb3JgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wua2V5Zm9yXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sJyk7XG4gICAgaWYgKGhhcyhTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5LCBzeW0pKSByZXR1cm4gU3ltYm9sVG9TdHJpbmdSZWdpc3RyeVtzeW1dO1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgVVNFX1NFVFRFUiA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBVU0VfU0VUVEVSID0gZmFsc2U7IH1cbn0pO1xuXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Jcbn0pO1xuXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCB9LCB7XG4gIC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eXN5bWJvbHNcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gQ2hyb21lIDM4IGFuZCAzOSBgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc2AgZmFpbHMgb24gcHJpbWl0aXZlc1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzQ0M1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogZmFpbHMoZnVuY3Rpb24gKCkgeyBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZigxKTsgfSkgfSwge1xuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICAgIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZih0b09iamVjdChpdCkpO1xuICB9XG59KTtcblxuLy8gYEpTT04uc3RyaW5naWZ5YCBtZXRob2QgYmVoYXZpb3Igd2l0aCBzeW1ib2xzXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1qc29uLnN0cmluZ2lmeVxuSlNPTiAmJiAkKHsgdGFyZ2V0OiAnSlNPTicsIHN0YXQ6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgc3ltYm9sID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICByZXR1cm4gbmF0aXZlSlNPTlN0cmluZ2lmeShbc3ltYm9sXSkgIT0gJ1tudWxsXSdcbiAgICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgICB8fCBuYXRpdmVKU09OU3RyaW5naWZ5KHsgYTogc3ltYm9sIH0pICE9ICd7fSdcbiAgICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICAgIHx8IG5hdGl2ZUpTT05TdHJpbmdpZnkoT2JqZWN0KHN5bWJvbCkpICE9ICd7fSc7XG59KSB9LCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7XG4gICAgdmFyIGFyZ3MgPSBbaXRdO1xuICAgIHZhciBpbmRleCA9IDE7XG4gICAgdmFyIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpbmRleCkgYXJncy5wdXNoKGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgJHJlcGxhY2VyID0gcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICBpZiAoIWlzQXJyYXkocmVwbGFjZXIpKSByZXBsYWNlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mICRyZXBsYWNlciA9PSAnZnVuY3Rpb24nKSB2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gbmF0aXZlSlNPTlN0cmluZ2lmeS5hcHBseShKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIGBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUtQEB0b3ByaW1pdGl2ZVxuaWYgKCEkU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSkge1xuICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbn1cbi8vIGBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddYCBwcm9wZXJ0eVxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLnByb3RvdHlwZS1AQHRvc3RyaW5ndGFnXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCBTWU1CT0wpO1xuXG5oaWRkZW5LZXlzW0hJRERFTl0gPSB0cnVlO1xuIiwiLy8gYFN5bWJvbC5wcm90b3R5cGUuZGVzY3JpcHRpb25gIGdldHRlclxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLnByb3RvdHlwZS5kZXNjcmlwdGlvblxuJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzJyk7XG5cbnZhciBOYXRpdmVTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xuXG5pZiAoREVTQ1JJUFRPUlMgJiYgdHlwZW9mIE5hdGl2ZVN5bWJvbCA9PSAnZnVuY3Rpb24nICYmICghKCdkZXNjcmlwdGlvbicgaW4gTmF0aXZlU3ltYm9sLnByb3RvdHlwZSkgfHxcbiAgLy8gU2FmYXJpIDEyIGJ1Z1xuICBOYXRpdmVTeW1ib2woKS5kZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkXG4pKSB7XG4gIHZhciBFbXB0eVN0cmluZ0Rlc2NyaXB0aW9uU3RvcmUgPSB7fTtcbiAgLy8gd3JhcCBTeW1ib2wgY29uc3RydWN0b3IgZm9yIGNvcnJlY3Qgd29yayB3aXRoIHVuZGVmaW5lZCBkZXNjcmlwdGlvblxuICB2YXIgU3ltYm9sV3JhcHBlciA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDwgMSB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IFN0cmluZyhhcmd1bWVudHNbMF0pO1xuICAgIHZhciByZXN1bHQgPSB0aGlzIGluc3RhbmNlb2YgU3ltYm9sV3JhcHBlclxuICAgICAgPyBuZXcgTmF0aXZlU3ltYm9sKGRlc2NyaXB0aW9uKVxuICAgICAgLy8gaW4gRWRnZSAxMywgU3RyaW5nKFN5bWJvbCh1bmRlZmluZWQpKSA9PT0gJ1N5bWJvbCh1bmRlZmluZWQpJ1xuICAgICAgOiBkZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkID8gTmF0aXZlU3ltYm9sKCkgOiBOYXRpdmVTeW1ib2woZGVzY3JpcHRpb24pO1xuICAgIGlmIChkZXNjcmlwdGlvbiA9PT0gJycpIEVtcHR5U3RyaW5nRGVzY3JpcHRpb25TdG9yZVtyZXN1bHRdID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKFN5bWJvbFdyYXBwZXIsIE5hdGl2ZVN5bWJvbCk7XG4gIHZhciBzeW1ib2xQcm90b3R5cGUgPSBTeW1ib2xXcmFwcGVyLnByb3RvdHlwZSA9IE5hdGl2ZVN5bWJvbC5wcm90b3R5cGU7XG4gIHN5bWJvbFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN5bWJvbFdyYXBwZXI7XG5cbiAgdmFyIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG90eXBlLnRvU3RyaW5nO1xuICB2YXIgbmF0aXZlID0gU3RyaW5nKE5hdGl2ZVN5bWJvbCgndGVzdCcpKSA9PSAnU3ltYm9sKHRlc3QpJztcbiAgdmFyIHJlZ2V4cCA9IC9eU3ltYm9sXFwoKC4qKVxcKVteKV0rJC87XG4gIGRlZmluZVByb3BlcnR5KHN5bWJvbFByb3RvdHlwZSwgJ2Rlc2NyaXB0aW9uJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgICAgdmFyIHN5bWJvbCA9IGlzT2JqZWN0KHRoaXMpID8gdGhpcy52YWx1ZU9mKCkgOiB0aGlzO1xuICAgICAgdmFyIHN0cmluZyA9IHN5bWJvbFRvU3RyaW5nLmNhbGwoc3ltYm9sKTtcbiAgICAgIGlmIChoYXMoRW1wdHlTdHJpbmdEZXNjcmlwdGlvblN0b3JlLCBzeW1ib2wpKSByZXR1cm4gJyc7XG4gICAgICB2YXIgZGVzYyA9IG5hdGl2ZSA/IHN0cmluZy5zbGljZSg3LCAtMSkgOiBzdHJpbmcucmVwbGFjZShyZWdleHAsICckMScpO1xuICAgICAgcmV0dXJuIGRlc2MgPT09ICcnID8gdW5kZWZpbmVkIDogZGVzYztcbiAgICB9XG4gIH0pO1xuXG4gICQoeyBnbG9iYWw6IHRydWUsIGZvcmNlZDogdHJ1ZSB9LCB7XG4gICAgU3ltYm9sOiBTeW1ib2xXcmFwcGVyXG4gIH0pO1xufVxuIiwidmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wnKTtcblxuLy8gYFN5bWJvbC5pdGVyYXRvcmAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC5pdGVyYXRvclxuZGVmaW5lV2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xuIiwidmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlJyk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xuXG52YXIgVU5TQ09QQUJMRVMgPSB3ZWxsS25vd25TeW1ib2woJ3Vuc2NvcGFibGVzJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmlmIChBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSB7XG4gIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShBcnJheVByb3RvdHlwZSwgVU5TQ09QQUJMRVMsIGNyZWF0ZShudWxsKSk7XG59XG5cbi8vIGFkZCBhIGtleSB0byBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgRi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBudWxsO1xuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcbn0pO1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBzaGFyZWRLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpO1xudmFyIENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb3JyZWN0LXByb3RvdHlwZS1nZXR0ZXInKTtcblxudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmdldHByb3RvdHlwZW9mXG5tb2R1bGUuZXhwb3J0cyA9IENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90b3R5cGUgOiBudWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZicpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gZmFsc2U7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVgIG9iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3RcbnZhciBJdGVyYXRvclByb3RvdHlwZSwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuXG5pZiAoW10ua2V5cykge1xuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xuICAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gdHJ1ZTtcbiAgZWxzZSB7XG4gICAgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoZ2V0UHJvdG90eXBlT2YoYXJyYXlJdGVyYXRvcikpO1xuICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG59XG5cbmlmIChJdGVyYXRvclByb3RvdHlwZSA9PSB1bmRlZmluZWQpIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5pZiAoIUlTX1BVUkUgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSB7XG4gIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSXRlcmF0b3JQcm90b3R5cGU6IEl0ZXJhdG9yUHJvdG90eXBlLFxuICBCVUdHWV9TQUZBUklfSVRFUkFUT1JTOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlJykuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICBJdGVyYXRvckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yQ29uc3RydWN0b3IsIFRPX1NUUklOR19UQUcsIGZhbHNlLCB0cnVlKTtcbiAgSXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgcmV0dXJuIEl0ZXJhdG9yQ29uc3RydWN0b3I7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSAmJiBpdCAhPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbid0IHNldCBcIiArIFN0cmluZyhpdCkgKyAnIGFzIGEgcHJvdG90eXBlJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBhUG9zc2libGVQcm90b3R5cGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1wb3NzaWJsZS1wcm90b3R5cGUnKTtcblxuLy8gYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3Quc2V0cHJvdG90eXBlb2Zcbi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IGZ1bmN0aW9uICgpIHtcbiAgdmFyIENPUlJFQ1RfU0VUVEVSID0gZmFsc2U7XG4gIHZhciB0ZXN0ID0ge307XG4gIHZhciBzZXR0ZXI7XG4gIHRyeSB7XG4gICAgc2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0O1xuICAgIHNldHRlci5jYWxsKHRlc3QsIFtdKTtcbiAgICBDT1JSRUNUX1NFVFRFUiA9IHRlc3QgaW5zdGFuY2VvZiBBcnJheTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICBhbk9iamVjdChPKTtcbiAgICBhUG9zc2libGVQcm90b3R5cGUocHJvdG8pO1xuICAgIGlmIChDT1JSRUNUX1NFVFRFUikgc2V0dGVyLmNhbGwoTywgcHJvdG8pO1xuICAgIGVsc2UgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICByZXR1cm4gTztcbiAgfTtcbn0oKSA6IHVuZGVmaW5lZCk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1pdGVyYXRvci1jb25zdHJ1Y3RvcicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcbnZhciBJdGVyYXRvcnNDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlJyk7XG5cbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IEl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IEl0ZXJhdG9yc0NvcmUuQlVHR1lfU0FGQVJJX0lURVJBVE9SUztcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xudmFyIEVOVFJJRVMgPSAnZW50cmllcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSXRlcmFibGUsIE5BTUUsIEl0ZXJhdG9yQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG5cbiAgdmFyIGdldEl0ZXJhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIChLSU5EKSB7XG4gICAgaWYgKEtJTkQgPT09IERFRkFVTFQgJiYgZGVmYXVsdEl0ZXJhdG9yKSByZXR1cm4gZGVmYXVsdEl0ZXJhdG9yO1xuICAgIGlmICghQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBLSU5EIGluIEl0ZXJhYmxlUHJvdG90eXBlKSByZXR1cm4gSXRlcmFibGVQcm90b3R5cGVbS0lORF07XG4gICAgc3dpdGNoIChLSU5EKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBFTlRSSUVTOiByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMpOyB9O1xuICB9O1xuXG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gZmFsc2U7XG4gIHZhciBJdGVyYWJsZVByb3RvdHlwZSA9IEl0ZXJhYmxlLnByb3RvdHlwZTtcbiAgdmFyIG5hdGl2ZUl0ZXJhdG9yID0gSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JdXG4gICAgfHwgSXRlcmFibGVQcm90b3R5cGVbJ0BAaXRlcmF0b3InXVxuICAgIHx8IERFRkFVTFQgJiYgSXRlcmFibGVQcm90b3R5cGVbREVGQVVMVF07XG4gIHZhciBkZWZhdWx0SXRlcmF0b3IgPSAhQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBuYXRpdmVJdGVyYXRvciB8fCBnZXRJdGVyYXRpb25NZXRob2QoREVGQVVMVCk7XG4gIHZhciBhbnlOYXRpdmVJdGVyYXRvciA9IE5BTUUgPT0gJ0FycmF5JyA/IEl0ZXJhYmxlUHJvdG90eXBlLmVudHJpZXMgfHwgbmF0aXZlSXRlcmF0b3IgOiBuYXRpdmVJdGVyYXRvcjtcbiAgdmFyIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgbWV0aG9kcywgS0VZO1xuXG4gIC8vIGZpeCBuYXRpdmVcbiAgaWYgKGFueU5hdGl2ZUl0ZXJhdG9yKSB7XG4gICAgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoYW55TmF0aXZlSXRlcmF0b3IuY2FsbChuZXcgSXRlcmFibGUoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgaWYgKCFJU19QVVJFICYmIGdldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSkgIT09IEl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChzZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgIHNldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBpZiAoSVNfUFVSRSkgSXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgICB9XG4gIH1cblxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChERUZBVUxUID09IFZBTFVFUyAmJiBuYXRpdmVJdGVyYXRvciAmJiBuYXRpdmVJdGVyYXRvci5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSB0cnVlO1xuICAgIGRlZmF1bHRJdGVyYXRvciA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5hdGl2ZUl0ZXJhdG9yLmNhbGwodGhpcyk7IH07XG4gIH1cblxuICAvLyBkZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghSVNfUFVSRSB8fCBGT1JDRUQpICYmIEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SXSAhPT0gZGVmYXVsdEl0ZXJhdG9yKSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KEl0ZXJhYmxlUHJvdG90eXBlLCBJVEVSQVRPUiwgZGVmYXVsdEl0ZXJhdG9yKTtcbiAgfVxuICBJdGVyYXRvcnNbTkFNRV0gPSBkZWZhdWx0SXRlcmF0b3I7XG5cbiAgLy8gZXhwb3J0IGFkZGl0aW9uYWwgbWV0aG9kc1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gZGVmYXVsdEl0ZXJhdG9yIDogZ2V0SXRlcmF0aW9uTWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogZ2V0SXRlcmF0aW9uTWV0aG9kKEVOVFJJRVMpXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKEtFWSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfHwgIShLRVkgaW4gSXRlcmFibGVQcm90b3R5cGUpKSB7XG4gICAgICAgIHJlZGVmaW5lKEl0ZXJhYmxlUHJvdG90eXBlLCBLRVksIG1ldGhvZHNbS0VZXSk7XG4gICAgICB9XG4gICAgfSBlbHNlICQoeyB0YXJnZXQ6IE5BTUUsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIH0sIG1ldGhvZHMpO1xuICB9XG5cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycycpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcbnZhciBkZWZpbmVJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3InKTtcblxudmFyIEFSUkFZX0lURVJBVE9SID0gJ0FycmF5IEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKEFSUkFZX0lURVJBVE9SKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5lbnRyaWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5lbnRyaWVzXG4vLyBgQXJyYXkucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmtleXNcbi8vIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS52YWx1ZXNcbi8vIGBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAaXRlcmF0b3Jcbi8vIGBDcmVhdGVBcnJheUl0ZXJhdG9yYCBpbnRlcm5hbCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNyZWF0ZWFycmF5aXRlcmF0b3Jcbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lSXRlcmF0b3IoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgICB0eXBlOiBBUlJBWV9JVEVSQVRPUixcbiAgICB0YXJnZXQ6IHRvSW5kZXhlZE9iamVjdChpdGVyYXRlZCksIC8vIHRhcmdldFxuICAgIGluZGV4OiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICAgIGtpbmQ6IGtpbmQgICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuICB9KTtcbi8vIGAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0lYXJyYXlpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0O1xuICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4Kys7XG4gIGlmICghdGFyZ2V0IHx8IGluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICBzdGF0ZS50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHsgdmFsdWU6IGluZGV4LCBkb25lOiBmYWxzZSB9O1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHsgdmFsdWU6IHRhcmdldFtpbmRleF0sIGRvbmU6IGZhbHNlIH07XG4gIHJldHVybiB7IHZhbHVlOiBbaW5kZXgsIHRhcmdldFtpbmRleF1dLCBkb25lOiBmYWxzZSB9O1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyVcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNyZWF0ZXVubWFwcGVkYXJndW1lbnRzb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1jcmVhdGVtYXBwZWRhcmd1bWVudHNvYmplY3Rcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cycpO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzJyk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBJbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0Jyk7XG5cbnZhciBuYXRpdmVBc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuYXNzaWduXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gIW5hdGl2ZUFzc2lnbiB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG4gIHZhciBhbHBoYWJldCA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbc3ltYm9sXSA9IDc7XG4gIGFscGhhYmV0LnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaHIpIHsgQltjaHJdID0gY2hyOyB9KTtcbiAgcmV0dXJuIG5hdGl2ZUFzc2lnbih7fSwgQSlbc3ltYm9sXSAhPSA3IHx8IG9iamVjdEtleXMobmF0aXZlQXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gYWxwaGFiZXQ7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcbiAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZjtcbiAgd2hpbGUgKGFyZ3VtZW50c0xlbmd0aCA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJbmRleGVkT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBvYmplY3RLZXlzKFMpLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoUykpIDogb2JqZWN0S2V5cyhTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIHtcbiAgICAgIGtleSA9IGtleXNbaisrXTtcbiAgICAgIGlmICghREVTQ1JJUFRPUlMgfHwgcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChTLCBrZXkpKSBUW2tleV0gPSBTW2tleV07XG4gICAgfVxuICB9IHJldHVybiBUO1xufSA6IG5hdGl2ZUFzc2lnbjtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtYXNzaWduJyk7XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IE9iamVjdC5hc3NpZ24gIT09IGFzc2lnbiB9LCB7XG4gIGFzc2lnbjogYXNzaWduXG59KTtcbiIsInZhciBjbGFzc29mUmF3ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBDT1JSRUNUX0FSR1VNRU5UUyA9IGNsYXNzb2ZSYXcoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbi8vIGdldHRpbmcgdGFnIGZyb20gRVM2KyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2Bcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCB0YWcsIHJlc3VsdDtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKHRhZyA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVE9fU1RSSU5HX1RBRykpID09ICdzdHJpbmcnID8gdGFnXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBDT1JSRUNUX0FSR1VNRU5UUyA/IGNsYXNzb2ZSYXcoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyIHRlc3QgPSB7fTtcblxudGVzdFtUT19TVFJJTkdfVEFHXSA9ICd6JztcblxuLy8gYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBTdHJpbmcodGVzdCkgIT09ICdbb2JqZWN0IHpdJyA/IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XG59IDogdGVzdC50b1N0cmluZztcbiIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC10by1zdHJpbmcnKTtcblxudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmdcbmlmICh0b1N0cmluZyAhPT0gT2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nKSB7XG4gIHJlZGVmaW5lKE9iamVjdFByb3RvdHlwZSwgJ3RvU3RyaW5nJywgdG9TdHJpbmcsIHsgdW5zYWZlOiB0cnVlIH0pO1xufVxuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5pc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbiIsInZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91aWQnKTtcbnZhciBGUkVFWklORyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mcmVlemluZycpO1xuXG52YXIgTUVUQURBVEEgPSB1aWQoJ21ldGEnKTtcbnZhciBpZCA9IDA7XG5cbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgc2V0TWV0YWRhdGEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgZGVmaW5lUHJvcGVydHkoaXQsIE1FVEFEQVRBLCB7IHZhbHVlOiB7XG4gICAgb2JqZWN0SUQ6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHdlYWtEYXRhOiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IH0pO1xufTtcblxudmFyIGZhc3RLZXkgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICAvLyByZXR1cm4gYSBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzKGl0LCBNRVRBREFUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YWRhdGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFEQVRBXS5vYmplY3RJRDtcbn07XG5cbnZhciBnZXRXZWFrRGF0YSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIGlmICghaGFzKGl0LCBNRVRBREFUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YWRhdGEoaXQpO1xuICAvLyByZXR1cm4gdGhlIHN0b3JlIG9mIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFEQVRBXS53ZWFrRGF0YTtcbn07XG5cbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWklORyAmJiBtZXRhLlJFUVVJUkVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQURBVEEpKSBzZXRNZXRhZGF0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIFJFUVVJUkVEOiBmYWxzZSxcbiAgZmFzdEtleTogZmFzdEtleSxcbiAgZ2V0V2Vha0RhdGE6IGdldFdlYWtEYXRhLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG5cbmhpZGRlbktleXNbTUVUQURBVEFdID0gdHJ1ZTtcbiIsInZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxuLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdID09PSBpdCk7XG59O1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xuXG4vLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBFTlRSSUVTKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEVOVFJJRVMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB2YXIgcmV0dXJuTWV0aG9kID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmIChyZXR1cm5NZXRob2QgIT09IHVuZGVmaW5lZCkgYW5PYmplY3QocmV0dXJuTWV0aG9kLmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXktaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9iaW5kLWNvbnRleHQnKTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jYWxsLXdpdGgtc2FmZS1pdGVyYXRpb24tY2xvc2luZycpO1xuXG52YXIgUmVzdWx0ID0gZnVuY3Rpb24gKHN0b3BwZWQsIHJlc3VsdCkge1xuICB0aGlzLnN0b3BwZWQgPSBzdG9wcGVkO1xuICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbn07XG5cbnZhciBpdGVyYXRlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGZuLCB0aGF0LCBBU19FTlRSSUVTLCBJU19JVEVSQVRPUikge1xuICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQoZm4sIHRoYXQsIEFTX0VOVFJJRVMgPyAyIDogMSk7XG4gIHZhciBpdGVyYXRvciwgaXRlckZuLCBpbmRleCwgbGVuZ3RoLCByZXN1bHQsIG5leHQsIHN0ZXA7XG5cbiAgaWYgKElTX0lURVJBVE9SKSB7XG4gICAgaXRlcmF0b3IgPSBpdGVyYWJsZTtcbiAgfSBlbHNlIHtcbiAgICBpdGVyRm4gPSBnZXRJdGVyYXRvck1ldGhvZChpdGVyYWJsZSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKCdUYXJnZXQgaXMgbm90IGl0ZXJhYmxlJyk7XG4gICAgLy8gb3B0aW1pc2F0aW9uIGZvciBhcnJheSBpdGVyYXRvcnNcbiAgICBpZiAoaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJGbikpIHtcbiAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICByZXN1bHQgPSBBU19FTlRSSUVTXG4gICAgICAgICAgPyBib3VuZEZ1bmN0aW9uKGFuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKVxuICAgICAgICAgIDogYm91bmRGdW5jdGlvbihpdGVyYWJsZVtpbmRleF0pO1xuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdCBpbnN0YW5jZW9mIFJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xuICAgIH1cbiAgICBpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTtcbiAgfVxuXG4gIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICB3aGlsZSAoIShzdGVwID0gbmV4dC5jYWxsKGl0ZXJhdG9yKSkuZG9uZSkge1xuICAgIHJlc3VsdCA9IGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcoaXRlcmF0b3IsIGJvdW5kRnVuY3Rpb24sIHN0ZXAudmFsdWUsIEFTX0VOVFJJRVMpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICdvYmplY3QnICYmIHJlc3VsdCAmJiByZXN1bHQgaW5zdGFuY2VvZiBSZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gIH0gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xufTtcblxuaXRlcmF0ZS5zdG9wID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICByZXR1cm4gbmV3IFJlc3VsdCh0cnVlLCByZXN1bHQpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSkge1xuICBpZiAoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW5jb3JyZWN0ICcgKyAobmFtZSA/IG5hbWUgKyAnICcgOiAnJykgKyAnaW52b2NhdGlvbicpO1xuICB9IHJldHVybiBpdDtcbn07XG4iLCJ2YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIGNhbGxlZCA9IDA7XG4gIHZhciBpdGVyYXRvcldpdGhSZXR1cm4gPSB7XG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHsgZG9uZTogISFjYWxsZWQrKyB9O1xuICAgIH0sXG4gICAgJ3JldHVybic6IGZ1bmN0aW9uICgpIHtcbiAgICAgIFNBRkVfQ0xPU0lORyA9IHRydWU7XG4gICAgfVxuICB9O1xuICBpdGVyYXRvcldpdGhSZXR1cm5bSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICBBcnJheS5mcm9tKGl0ZXJhdG9yV2l0aFJldHVybiwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgU0tJUF9DTE9TSU5HKSB7XG4gIGlmICghU0tJUF9DTE9TSU5HICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIElURVJBVElPTl9TVVBQT1JUID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIG9iamVjdCA9IHt9O1xuICAgIG9iamVjdFtJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogSVRFUkFUSU9OX1NVUFBPUlQgPSB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBleGVjKG9iamVjdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIElURVJBVElPTl9TVVBQT1JUO1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZicpO1xuXG4vLyBtYWtlcyBzdWJjbGFzc2luZyB3b3JrIGNvcnJlY3QgZm9yIHdyYXBwZWQgYnVpbHQtaW5zXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgkdGhpcywgZHVtbXksIFdyYXBwZXIpIHtcbiAgdmFyIE5ld1RhcmdldCwgTmV3VGFyZ2V0UHJvdG90eXBlO1xuICBpZiAoXG4gICAgLy8gaXQgY2FuIHdvcmsgb25seSB3aXRoIG5hdGl2ZSBgc2V0UHJvdG90eXBlT2ZgXG4gICAgc2V0UHJvdG90eXBlT2YgJiZcbiAgICAvLyB3ZSBoYXZlbid0IGNvbXBsZXRlbHkgY29ycmVjdCBwcmUtRVM2IHdheSBmb3IgZ2V0dGluZyBgbmV3LnRhcmdldGAsIHNvIHVzZSB0aGlzXG4gICAgdHlwZW9mIChOZXdUYXJnZXQgPSBkdW1teS5jb25zdHJ1Y3RvcikgPT0gJ2Z1bmN0aW9uJyAmJlxuICAgIE5ld1RhcmdldCAhPT0gV3JhcHBlciAmJlxuICAgIGlzT2JqZWN0KE5ld1RhcmdldFByb3RvdHlwZSA9IE5ld1RhcmdldC5wcm90b3R5cGUpICYmXG4gICAgTmV3VGFyZ2V0UHJvdG90eXBlICE9PSBXcmFwcGVyLnByb3RvdHlwZVxuICApIHNldFByb3RvdHlwZU9mKCR0aGlzLCBOZXdUYXJnZXRQcm90b3R5cGUpO1xuICByZXR1cm4gJHRoaXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGlzRm9yY2VkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWZvcmNlZCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgSW50ZXJuYWxNZXRhZGF0YU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1tZXRhZGF0YScpO1xudmFyIGl0ZXJhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0ZScpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4taW5zdGFuY2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24nKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1JfTkFNRSwgd3JhcHBlciwgY29tbW9uLCBJU19NQVAsIElTX1dFQUspIHtcbiAgdmFyIE5hdGl2ZUNvbnN0cnVjdG9yID0gZ2xvYmFsW0NPTlNUUlVDVE9SX05BTUVdO1xuICB2YXIgTmF0aXZlUHJvdG90eXBlID0gTmF0aXZlQ29uc3RydWN0b3IgJiYgTmF0aXZlQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICB2YXIgQ29uc3RydWN0b3IgPSBOYXRpdmVDb25zdHJ1Y3RvcjtcbiAgdmFyIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJztcbiAgdmFyIGV4cG9ydGVkID0ge307XG5cbiAgdmFyIGZpeE1ldGhvZCA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgICB2YXIgbmF0aXZlTWV0aG9kID0gTmF0aXZlUHJvdG90eXBlW0tFWV07XG4gICAgcmVkZWZpbmUoTmF0aXZlUHJvdG90eXBlLCBLRVksXG4gICAgICBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICAgICAgbmF0aXZlTWV0aG9kLmNhbGwodGhpcywgdmFsdWUgPT09IDAgPyAwIDogdmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gOiBLRVkgPT0gJ2RlbGV0ZScgPyBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChrZXkpID8gZmFsc2UgOiBuYXRpdmVNZXRob2QuY2FsbCh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5KTtcbiAgICAgIH0gOiBLRVkgPT0gJ2dldCcgPyBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChrZXkpID8gdW5kZWZpbmVkIDogbmF0aXZlTWV0aG9kLmNhbGwodGhpcywga2V5ID09PSAwID8gMCA6IGtleSk7XG4gICAgICB9IDogS0VZID09ICdoYXMnID8gZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3Qoa2V5KSA/IGZhbHNlIDogbmF0aXZlTWV0aG9kLmNhbGwodGhpcywga2V5ID09PSAwID8gMCA6IGtleSk7XG4gICAgICB9IDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgbmF0aXZlTWV0aG9kLmNhbGwodGhpcywga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICApO1xuICB9O1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gIGlmIChpc0ZvcmNlZChDT05TVFJVQ1RPUl9OQU1FLCB0eXBlb2YgTmF0aXZlQ29uc3RydWN0b3IgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgTmF0aXZlUHJvdG90eXBlLmZvckVhY2ggJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgTmF0aXZlQ29uc3RydWN0b3IoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpKSB7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDb25zdHJ1Y3RvciA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVAsIEFEREVSKTtcbiAgICBJbnRlcm5hbE1ldGFkYXRhTW9kdWxlLlJFUVVJUkVEID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc0ZvcmNlZChDT05TVFJVQ1RPUl9OQU1FLCB0cnVlKSkge1xuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgIC8vIGVhcmx5IGltcGxlbWVudGF0aW9ucyBub3Qgc3VwcG9ydHMgY2hhaW5pbmdcbiAgICB2YXIgSEFTTlRfQ0hBSU5JTkcgPSBpbnN0YW5jZVtBRERFUl0oSVNfV0VBSyA/IHt9IDogLTAsIDEpICE9IGluc3RhbmNlO1xuICAgIC8vIFY4IH4gQ2hyb21pdW0gNDAtIHdlYWstY29sbGVjdGlvbnMgdGhyb3dzIG9uIHByaW1pdGl2ZXMsIGJ1dCBzaG91bGQgcmV0dXJuIGZhbHNlXG4gICAgdmFyIFRIUk9XU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkgeyBpbnN0YW5jZS5oYXMoMSk7IH0pO1xuICAgIC8vIG1vc3QgZWFybHkgaW1wbGVtZW50YXRpb25zIGRvZXNuJ3Qgc3VwcG9ydHMgaXRlcmFibGVzLCBtb3N0IG1vZGVybiAtIG5vdCBjbG9zZSBpdCBjb3JyZWN0bHlcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3XG4gICAgdmFyIEFDQ0VQVF9JVEVSQUJMRVMgPSBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7IG5ldyBOYXRpdmVDb25zdHJ1Y3RvcihpdGVyYWJsZSk7IH0pO1xuICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxuICAgIHZhciBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVjggfiBDaHJvbWl1bSA0Mi0gZmFpbHMgb25seSB3aXRoIDUrIGVsZW1lbnRzXG4gICAgICB2YXIgJGluc3RhbmNlID0gbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCk7XG4gICAgICB2YXIgaW5kZXggPSA1O1xuICAgICAgd2hpbGUgKGluZGV4LS0pICRpbnN0YW5jZVtBRERFUl0oaW5kZXgsIGluZGV4KTtcbiAgICAgIHJldHVybiAhJGluc3RhbmNlLmhhcygtMCk7XG4gICAgfSk7XG5cbiAgICBpZiAoIUFDQ0VQVF9JVEVSQUJMRVMpIHtcbiAgICAgIENvbnN0cnVjdG9yID0gd3JhcHBlcihmdW5jdGlvbiAoZHVtbXksIGl0ZXJhYmxlKSB7XG4gICAgICAgIGFuSW5zdGFuY2UoZHVtbXksIENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FKTtcbiAgICAgICAgdmFyIHRoYXQgPSBpbmhlcml0SWZSZXF1aXJlZChuZXcgTmF0aXZlQ29uc3RydWN0b3IoKSwgZHVtbXksIENvbnN0cnVjdG9yKTtcbiAgICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgaXRlcmF0ZShpdGVyYWJsZSwgdGhhdFtBRERFUl0sIHRoYXQsIElTX01BUCk7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgfSk7XG4gICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBOYXRpdmVQcm90b3R5cGU7XG4gICAgICBOYXRpdmVQcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgICB9XG5cbiAgICBpZiAoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTykge1xuICAgICAgZml4TWV0aG9kKCdkZWxldGUnKTtcbiAgICAgIGZpeE1ldGhvZCgnaGFzJyk7XG4gICAgICBJU19NQVAgJiYgZml4TWV0aG9kKCdnZXQnKTtcbiAgICB9XG5cbiAgICBpZiAoQlVHR1lfWkVSTyB8fCBIQVNOVF9DSEFJTklORykgZml4TWV0aG9kKEFEREVSKTtcblxuICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgc2hvdWxkIG5vdCBjb250YWlucyAuY2xlYXIgbWV0aG9kXG4gICAgaWYgKElTX1dFQUsgJiYgTmF0aXZlUHJvdG90eXBlLmNsZWFyKSBkZWxldGUgTmF0aXZlUHJvdG90eXBlLmNsZWFyO1xuICB9XG5cbiAgZXhwb3J0ZWRbQ09OU1RSVUNUT1JfTkFNRV0gPSBDb25zdHJ1Y3RvcjtcbiAgJCh7IGdsb2JhbDogdHJ1ZSwgZm9yY2VkOiBDb25zdHJ1Y3RvciAhPSBOYXRpdmVDb25zdHJ1Y3RvciB9LCBleHBvcnRlZCk7XG5cbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUpO1xuXG4gIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQ29uc3RydWN0b3I7XG59O1xuIiwidmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgb3B0aW9ucyk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SX05BTUUpIHtcbiAgdmFyIENvbnN0cnVjdG9yID0gZ2V0QnVpbHRJbihDT05TVFJVQ1RPUl9OQU1FKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcblxuICBpZiAoREVTQ1JJUFRPUlMgJiYgQ29uc3RydWN0b3IgJiYgIUNvbnN0cnVjdG9yW1NQRUNJRVNdKSB7XG4gICAgZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFNQRUNJRVMsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfVxuICAgIH0pO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUtYWxsJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9iaW5kLWNvbnRleHQnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlJyk7XG52YXIgaXRlcmF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRlJyk7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWl0ZXJhdG9yJyk7XG52YXIgc2V0U3BlY2llcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtc3BlY2llcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZmFzdEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1tZXRhZGF0YScpLmZhc3RLZXk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xuXG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGludGVybmFsU3RhdGVHZXR0ZXJGb3IgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcjtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgQ09OU1RSVUNUT1JfTkFNRSk7XG4gICAgICBzZXRJbnRlcm5hbFN0YXRlKHRoYXQsIHtcbiAgICAgICAgdHlwZTogQ09OU1RSVUNUT1JfTkFNRSxcbiAgICAgICAgaW5kZXg6IGNyZWF0ZShudWxsKSxcbiAgICAgICAgZmlyc3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgbGFzdDogdW5kZWZpbmVkLFxuICAgICAgICBzaXplOiAwXG4gICAgICB9KTtcbiAgICAgIGlmICghREVTQ1JJUFRPUlMpIHRoYXQuc2l6ZSA9IDA7XG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBpdGVyYXRlKGl0ZXJhYmxlLCB0aGF0W0FEREVSXSwgdGhhdCwgSVNfTUFQKTtcbiAgICB9KTtcblxuICAgIHZhciBnZXRJbnRlcm5hbFN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvcihDT05TVFJVQ1RPUl9OQU1FKTtcblxuICAgIHZhciBkZWZpbmUgPSBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICB2YXIgcHJldmlvdXMsIGluZGV4O1xuICAgICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG4gICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgZW50cnkudmFsdWUgPSB2YWx1ZTtcbiAgICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmxhc3QgPSBlbnRyeSA9IHtcbiAgICAgICAgICBpbmRleDogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksXG4gICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHByZXZpb3VzOiBwcmV2aW91cyA9IHN0YXRlLmxhc3QsXG4gICAgICAgICAgbmV4dDogdW5kZWZpbmVkLFxuICAgICAgICAgIHJlbW92ZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGlmICghc3RhdGUuZmlyc3QpIHN0YXRlLmZpcnN0ID0gZW50cnk7XG4gICAgICAgIGlmIChwcmV2aW91cykgcHJldmlvdXMubmV4dCA9IGVudHJ5O1xuICAgICAgICBpZiAoREVTQ1JJUFRPUlMpIHN0YXRlLnNpemUrKztcbiAgICAgICAgZWxzZSB0aGF0LnNpemUrKztcbiAgICAgICAgLy8gYWRkIHRvIGluZGV4XG4gICAgICAgIGlmIChpbmRleCAhPT0gJ0YnKSBzdGF0ZS5pbmRleFtpbmRleF0gPSBlbnRyeTtcbiAgICAgIH0gcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIHZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uICh0aGF0LCBrZXkpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICAvLyBmYXN0IGNhc2VcbiAgICAgIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KTtcbiAgICAgIHZhciBlbnRyeTtcbiAgICAgIGlmIChpbmRleCAhPT0gJ0YnKSByZXR1cm4gc3RhdGUuaW5kZXhbaW5kZXhdO1xuICAgICAgLy8gZnJvemVuIG9iamVjdCBjYXNlXG4gICAgICBmb3IgKGVudHJ5ID0gc3RhdGUuZmlyc3Q7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm5leHQpIHtcbiAgICAgICAgaWYgKGVudHJ5LmtleSA9PSBrZXkpIHJldHVybiBlbnRyeTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgICAgdmFyIGRhdGEgPSBzdGF0ZS5pbmRleDtcbiAgICAgICAgdmFyIGVudHJ5ID0gc3RhdGUuZmlyc3Q7XG4gICAgICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgICAgIGVudHJ5LnJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgIGlmIChlbnRyeS5wcmV2aW91cykgZW50cnkucHJldmlvdXMgPSBlbnRyeS5wcmV2aW91cy5uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmluZGV4XTtcbiAgICAgICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZmlyc3QgPSBzdGF0ZS5sYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoREVTQ1JJUFRPUlMpIHN0YXRlLnNpemUgPSAwO1xuICAgICAgICBlbHNlIHRoYXQuc2l6ZSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHZhciBuZXh0ID0gZW50cnkubmV4dDtcbiAgICAgICAgICB2YXIgcHJldiA9IGVudHJ5LnByZXZpb3VzO1xuICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5pbmRleFtlbnRyeS5pbmRleF07XG4gICAgICAgICAgZW50cnkucmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKHByZXYpIHByZXYubmV4dCA9IG5leHQ7XG4gICAgICAgICAgaWYgKG5leHQpIG5leHQucHJldmlvdXMgPSBwcmV2O1xuICAgICAgICAgIGlmIChzdGF0ZS5maXJzdCA9PSBlbnRyeSkgc3RhdGUuZmlyc3QgPSBuZXh0O1xuICAgICAgICAgIGlmIChzdGF0ZS5sYXN0ID09IGVudHJ5KSBzdGF0ZS5sYXN0ID0gcHJldjtcbiAgICAgICAgICBpZiAoREVTQ1JJUFRPUlMpIHN0YXRlLnNpemUtLTtcbiAgICAgICAgICBlbHNlIHRoYXQuc2l6ZS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gICAgICAgIHZhciBib3VuZEZ1bmN0aW9uID0gYmluZChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMyk7XG4gICAgICAgIHZhciBlbnRyeTtcbiAgICAgICAgd2hpbGUgKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uZXh0IDogc3RhdGUuZmlyc3QpIHtcbiAgICAgICAgICBib3VuZEZ1bmN0aW9uKGVudHJ5LnZhbHVlLCBlbnRyeS5rZXksIHRoaXMpO1xuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yZW1vdmVkKSBlbnRyeSA9IGVudHJ5LnByZXZpb3VzO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBJU19NQVAgPyB7XG4gICAgICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnZhbHVlO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUodGhpcywga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gOiB7XG4gICAgICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgICAgIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUodGhpcywgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChERVNDUklQVE9SUykgZGVmaW5lUHJvcGVydHkoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNpemU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIHNldFN0cm9uZzogZnVuY3Rpb24gKEMsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCkge1xuICAgIHZhciBJVEVSQVRPUl9OQU1FID0gQ09OU1RSVUNUT1JfTkFNRSArICcgSXRlcmF0b3InO1xuICAgIHZhciBnZXRJbnRlcm5hbENvbGxlY3Rpb25TdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IoQ09OU1RSVUNUT1JfTkFNRSk7XG4gICAgdmFyIGdldEludGVybmFsSXRlcmF0b3JTdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IoSVRFUkFUT1JfTkFNRSk7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgIGRlZmluZUl0ZXJhdG9yKEMsIENPTlNUUlVDVE9SX05BTUUsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICAgICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgICAgIHR5cGU6IElURVJBVE9SX05BTUUsXG4gICAgICAgIHRhcmdldDogaXRlcmF0ZWQsXG4gICAgICAgIHN0YXRlOiBnZXRJbnRlcm5hbENvbGxlY3Rpb25TdGF0ZShpdGVyYXRlZCksXG4gICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgIGxhc3Q6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxJdGVyYXRvclN0YXRlKHRoaXMpO1xuICAgICAgdmFyIGtpbmQgPSBzdGF0ZS5raW5kO1xuICAgICAgdmFyIGVudHJ5ID0gc3RhdGUubGFzdDtcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnJlbW92ZWQpIGVudHJ5ID0gZW50cnkucHJldmlvdXM7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYgKCFzdGF0ZS50YXJnZXQgfHwgIShzdGF0ZS5sYXN0ID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm5leHQgOiBzdGF0ZS5zdGF0ZS5maXJzdCkpIHtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiB7IHZhbHVlOiBlbnRyeS5rZXksIGRvbmU6IGZhbHNlIH07XG4gICAgICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHsgdmFsdWU6IGVudHJ5LnZhbHVlLCBkb25lOiBmYWxzZSB9O1xuICAgICAgcmV0dXJuIHsgdmFsdWU6IFtlbnRyeS5rZXksIGVudHJ5LnZhbHVlXSwgZG9uZTogZmFsc2UgfTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJywgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBhZGQgW0BAc3BlY2llc10sIDIzLjEuMi4yLCAyMy4yLjIuMlxuICAgIHNldFNwZWNpZXMoQ09OU1RSVUNUT1JfTkFNRSk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb2xsZWN0aW9uJyk7XG52YXIgY29sbGVjdGlvblN0cm9uZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb2xsZWN0aW9uLXN0cm9uZycpO1xuXG4vLyBgU2V0YCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc2V0LW9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gY29sbGVjdGlvbignU2V0JywgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwgY29sbGVjdGlvblN0cm9uZyk7XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXInKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS57IGNvZGVQb2ludEF0LCBhdCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKENPTlZFUlRfVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIHBvcykge1xuICAgIHZhciBTID0gU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUoJHRoaXMpKTtcbiAgICB2YXIgcG9zaXRpb24gPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgc2l6ZSA9IFMubGVuZ3RoO1xuICAgIHZhciBmaXJzdCwgc2Vjb25kO1xuICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gc2l6ZSkgcmV0dXJuIENPTlZFUlRfVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgZmlyc3QgPSBTLmNoYXJDb2RlQXQocG9zaXRpb24pO1xuICAgIHJldHVybiBmaXJzdCA8IDB4RDgwMCB8fCBmaXJzdCA+IDB4REJGRiB8fCBwb3NpdGlvbiArIDEgPT09IHNpemVcbiAgICAgIHx8IChzZWNvbmQgPSBTLmNoYXJDb2RlQXQocG9zaXRpb24gKyAxKSkgPCAweERDMDAgfHwgc2Vjb25kID4gMHhERkZGXG4gICAgICAgID8gQ09OVkVSVF9UT19TVFJJTkcgPyBTLmNoYXJBdChwb3NpdGlvbikgOiBmaXJzdFxuICAgICAgICA6IENPTlZFUlRfVE9fU1RSSU5HID8gUy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyAyKSA6IChmaXJzdCAtIDB4RDgwMCA8PCAxMCkgKyAoc2Vjb25kIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmNvZGVwb2ludGF0XG4gIGNvZGVBdDogY3JlYXRlTWV0aG9kKGZhbHNlKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuYXRgIG1ldGhvZFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XG4gIGNoYXJBdDogY3JlYXRlTWV0aG9kKHRydWUpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNoYXJBdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zdHJpbmctbXVsdGlieXRlJykuY2hhckF0O1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcbnZhciBkZWZpbmVJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3InKTtcblxudmFyIFNUUklOR19JVEVSQVRPUiA9ICdTdHJpbmcgSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoU1RSSU5HX0lURVJBVE9SKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS1AQGl0ZXJhdG9yXG5kZWZpbmVJdGVyYXRvcihTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgdHlwZTogU1RSSU5HX0lURVJBVE9SLFxuICAgIHN0cmluZzogU3RyaW5nKGl0ZXJhdGVkKSxcbiAgICBpbmRleDogMFxuICB9KTtcbi8vIGAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXN0cmluZ2l0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG59LCBmdW5jdGlvbiBuZXh0KCkge1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICB2YXIgc3RyaW5nID0gc3RhdGUuc3RyaW5nO1xuICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleDtcbiAgdmFyIHBvaW50O1xuICBpZiAoaW5kZXggPj0gc3RyaW5nLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9IGNoYXJBdChzdHJpbmcsIGluZGV4KTtcbiAgc3RhdGUuaW5kZXggKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcbiIsIi8vIGl0ZXJhYmxlIERPTSBjb2xsZWN0aW9uc1xuLy8gZmxhZyAtIGBpdGVyYWJsZWAgaW50ZXJmYWNlIC0gJ2VudHJpZXMnLCAna2V5cycsICd2YWx1ZXMnLCAnZm9yRWFjaCcgbWV0aG9kc1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENTU1J1bGVMaXN0OiAwLFxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiAwLFxuICBDU1NWYWx1ZUxpc3Q6IDAsXG4gIENsaWVudFJlY3RMaXN0OiAwLFxuICBET01SZWN0TGlzdDogMCxcbiAgRE9NU3RyaW5nTGlzdDogMCxcbiAgRE9NVG9rZW5MaXN0OiAxLFxuICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogMCxcbiAgRmlsZUxpc3Q6IDAsXG4gIEhUTUxBbGxDb2xsZWN0aW9uOiAwLFxuICBIVE1MQ29sbGVjdGlvbjogMCxcbiAgSFRNTEZvcm1FbGVtZW50OiAwLFxuICBIVE1MU2VsZWN0RWxlbWVudDogMCxcbiAgTWVkaWFMaXN0OiAwLFxuICBNaW1lVHlwZUFycmF5OiAwLFxuICBOYW1lZE5vZGVNYXA6IDAsXG4gIE5vZGVMaXN0OiAxLFxuICBQYWludFJlcXVlc3RMaXN0OiAwLFxuICBQbHVnaW46IDAsXG4gIFBsdWdpbkFycmF5OiAwLFxuICBTVkdMZW5ndGhMaXN0OiAwLFxuICBTVkdOdW1iZXJMaXN0OiAwLFxuICBTVkdQYXRoU2VnTGlzdDogMCxcbiAgU1ZHUG9pbnRMaXN0OiAwLFxuICBTVkdTdHJpbmdMaXN0OiAwLFxuICBTVkdUcmFuc2Zvcm1MaXN0OiAwLFxuICBTb3VyY2VCdWZmZXJMaXN0OiAwLFxuICBTdHlsZVNoZWV0TGlzdDogMCxcbiAgVGV4dFRyYWNrQ3VlTGlzdDogMCxcbiAgVGV4dFRyYWNrTGlzdDogMCxcbiAgVG91Y2hMaXN0OiAwXG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBET01JdGVyYWJsZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9tLWl0ZXJhYmxlcycpO1xudmFyIEFycmF5SXRlcmF0b3JNZXRob2RzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvcicpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgQXJyYXlWYWx1ZXMgPSBBcnJheUl0ZXJhdG9yTWV0aG9kcy52YWx1ZXM7XG5cbmZvciAodmFyIENPTExFQ1RJT05fTkFNRSBpbiBET01JdGVyYWJsZXMpIHtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbQ09MTEVDVElPTl9OQU1FXTtcbiAgdmFyIENvbGxlY3Rpb25Qcm90b3R5cGUgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZSkge1xuICAgIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SXSAhPT0gQXJyYXlWYWx1ZXMpIHRyeSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUl0gPSBBcnJheVZhbHVlcztcbiAgICB9XG4gICAgaWYgKCFDb2xsZWN0aW9uUHJvdG90eXBlW1RPX1NUUklOR19UQUddKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgQ09MTEVDVElPTl9OQU1FKTtcbiAgICB9XG4gICAgaWYgKERPTUl0ZXJhYmxlc1tDT0xMRUNUSU9OX05BTUVdKSBmb3IgKHZhciBNRVRIT0RfTkFNRSBpbiBBcnJheUl0ZXJhdG9yTWV0aG9kcykge1xuICAgICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG4gICAgICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZVtNRVRIT0RfTkFNRV0gIT09IEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXSkgdHJ5IHtcbiAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIE1FVEhPRF9OQU1FLCBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgQ29sbGVjdGlvblByb3RvdHlwZVtNRVRIT0RfTkFNRV0gPSBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyMltpXSA9IGFycltpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfVxufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xufSIsImltcG9ydCBhcnJheVdpdGhvdXRIb2xlcyBmcm9tIFwiLi9hcnJheVdpdGhvdXRIb2xlc1wiO1xuaW1wb3J0IGl0ZXJhYmxlVG9BcnJheSBmcm9tIFwiLi9pdGVyYWJsZVRvQXJyYXlcIjtcbmltcG9ydCBub25JdGVyYWJsZVNwcmVhZCBmcm9tIFwiLi9ub25JdGVyYWJsZVNwcmVhZFwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufSIsImNvbnN0IG1ldGhvZHMgPSB7fVxyXG5jb25zdCBuYW1lcyA9IFtdXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJNZXRob2RzIChuYW1lLCBtKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcclxuICAgIGZvciAoY29uc3QgX25hbWUgb2YgbmFtZSkge1xyXG4gICAgICByZWdpc3Rlck1ldGhvZHMoX25hbWUsIG0pXHJcbiAgICB9XHJcbiAgICByZXR1cm5cclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcclxuICAgIGZvciAoY29uc3QgX25hbWUgaW4gbmFtZSkge1xyXG4gICAgICByZWdpc3Rlck1ldGhvZHMoX25hbWUsIG5hbWVbX25hbWVdKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICBhZGRNZXRob2ROYW1lcyhPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtKSlcclxuICBtZXRob2RzW25hbWVdID0gT2JqZWN0LmFzc2lnbihtZXRob2RzW25hbWVdIHx8IHt9LCBtKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWV0aG9kc0ZvciAobmFtZSkge1xyXG4gIHJldHVybiBtZXRob2RzW25hbWVdIHx8IHt9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNZXRob2ROYW1lcyAoKSB7XHJcbiAgcmV0dXJuIFsgLi4ubmV3IFNldChuYW1lcykgXVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYWRkTWV0aG9kTmFtZXMgKF9uYW1lcykge1xyXG4gIG5hbWVzLnB1c2goLi4uX25hbWVzKVxyXG59XHJcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyICRpbmNsdWRlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pbmNsdWRlcycpLmluY2x1ZGVzO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSB9LCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcygnaW5jbHVkZXMnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NgIGdldHRlciBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZ2V0LXJlZ2V4cC5wcm90b3R5cGUuZmxhZ3Ncbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IGFuT2JqZWN0KHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAodGhhdC5kb3RBbGwpIHJlc3VsdCArPSAncyc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnN0aWNreSkgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVnZXhwRmxhZ3MgPSByZXF1aXJlKCcuL3JlZ2V4cC1mbGFncycpO1xuXG52YXIgbmF0aXZlRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcbi8vIFRoaXMgYWx3YXlzIHJlZmVycyB0byB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLCBiZWNhdXNlIHRoZVxuLy8gU3RyaW5nI3JlcGxhY2UgcG9seWZpbGwgdXNlcyAuL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMuanMsXG4vLyB3aGljaCBsb2FkcyB0aGlzIGZpbGUgYmVmb3JlIHBhdGNoaW5nIHRoZSBtZXRob2QuXG52YXIgbmF0aXZlUmVwbGFjZSA9IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZTtcblxudmFyIHBhdGNoZWRFeGVjID0gbmF0aXZlRXhlYztcblxudmFyIFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByZTEgPSAvYS87XG4gIHZhciByZTIgPSAvYiovZztcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMSwgJ2EnKTtcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMiwgJ2EnKTtcbiAgcmV0dXJuIHJlMS5sYXN0SW5kZXggIT09IDAgfHwgcmUyLmxhc3RJbmRleCAhPT0gMDtcbn0pKCk7XG5cbi8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwLCBjb3BpZWQgZnJvbSBlczUtc2hpbSdzIFN0cmluZyNzcGxpdCBwYXRjaC5cbnZhciBOUENHX0lOQ0xVREVEID0gLygpPz8vLmV4ZWMoJycpWzFdICE9PSB1bmRlZmluZWQ7XG5cbnZhciBQQVRDSCA9IFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyB8fCBOUENHX0lOQ0xVREVEO1xuXG5pZiAoUEFUQ0gpIHtcbiAgcGF0Y2hlZEV4ZWMgPSBmdW5jdGlvbiBleGVjKHN0cikge1xuICAgIHZhciByZSA9IHRoaXM7XG4gICAgdmFyIGxhc3RJbmRleCwgcmVDb3B5LCBtYXRjaCwgaTtcblxuICAgIGlmIChOUENHX0lOQ0xVREVEKSB7XG4gICAgICByZUNvcHkgPSBuZXcgUmVnRXhwKCdeJyArIHJlLnNvdXJjZSArICckKD8hXFxcXHMpJywgcmVnZXhwRmxhZ3MuY2FsbChyZSkpO1xuICAgIH1cbiAgICBpZiAoVVBEQVRFU19MQVNUX0lOREVYX1dST05HKSBsYXN0SW5kZXggPSByZS5sYXN0SW5kZXg7XG5cbiAgICBtYXRjaCA9IG5hdGl2ZUV4ZWMuY2FsbChyZSwgc3RyKTtcblxuICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgJiYgbWF0Y2gpIHtcbiAgICAgIHJlLmxhc3RJbmRleCA9IHJlLmdsb2JhbCA/IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDogbGFzdEluZGV4O1xuICAgIH1cbiAgICBpZiAoTlBDR19JTkNMVURFRCAmJiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYFxuICAgICAgLy8gZm9yIE5QQ0csIGxpa2UgSUU4LiBOT1RFOiBUaGlzIGRvZXNuJyB3b3JrIGZvciAvKC4/KT8vXG4gICAgICBuYXRpdmVSZXBsYWNlLmNhbGwobWF0Y2hbMF0sIHJlQ29weSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaGVkRXhlYztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGV4ZWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMnKTtcblxuJCh7IHRhcmdldDogJ1JlZ0V4cCcsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IC8uLy5leGVjICE9PSBleGVjIH0sIHtcbiAgZXhlYzogZXhlY1xufSk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgTUFUQ0ggPSB3ZWxsS25vd25TeW1ib2woJ21hdGNoJyk7XG5cbi8vIGBJc1JlZ0V4cGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pc3JlZ2V4cFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY2xhc3NvZihpdCkgPT0gJ1JlZ0V4cCcpO1xufTtcbiIsInZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1yZWdleHAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGlzUmVnRXhwKGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihcIlRoZSBtZXRob2QgZG9lc24ndCBhY2NlcHQgcmVndWxhciBleHByZXNzaW9uc1wiKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgTUFUQ0ggPSB3ZWxsS25vd25TeW1ib2woJ21hdGNoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gIHZhciByZWdleHAgPSAvLi87XG4gIHRyeSB7XG4gICAgJy8uLydbTUVUSE9EX05BTUVdKHJlZ2V4cCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0cnkge1xuICAgICAgcmVnZXhwW01BVENIXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuICcvLi8nW01FVEhPRF9OQU1FXShyZWdleHApO1xuICAgIH0gY2F0Y2ggKGYpIHsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiBmYWxzZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBub3RBUmVnRXhwID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25vdC1hLXJlZ2V4cCcpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG52YXIgY29ycmVjdElzUmVnRXhwTG9naWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29ycmVjdC1pcy1yZWdleHAtbG9naWMnKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlc1xuJCh7IHRhcmdldDogJ1N0cmluZycsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFjb3JyZWN0SXNSZWdFeHBMb2dpYygnaW5jbHVkZXMnKSB9LCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hTdHJpbmcgLyogLCBwb3NpdGlvbiA9IDAgKi8pIHtcbiAgICByZXR1cm4gISF+U3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcykpXG4gICAgICAuaW5kZXhPZihub3RBUmVnRXhwKHNlYXJjaFN0cmluZyksIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciByZWdleHBFeGVjID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjJyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbnZhciBSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vICNyZXBsYWNlIG5lZWRzIGJ1aWx0LWluIHN1cHBvcnQgZm9yIG5hbWVkIGdyb3Vwcy5cbiAgLy8gI21hdGNoIHdvcmtzIGZpbmUgYmVjYXVzZSBpdCBqdXN0IHJldHVybiB0aGUgZXhlYyByZXN1bHRzLCBldmVuIGlmIGl0IGhhc1xuICAvLyBhIFwiZ3JvcHNcIiBwcm9wZXJ0eS5cbiAgdmFyIHJlID0gLy4vO1xuICByZS5leGVjID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICByZXN1bHQuZ3JvdXBzID0geyBhOiAnNycgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICByZXR1cm4gJycucmVwbGFjZShyZSwgJyQ8YT4nKSAhPT0gJzcnO1xufSk7XG5cbi8vIENocm9tZSA1MSBoYXMgYSBidWdneSBcInNwbGl0XCIgaW1wbGVtZW50YXRpb24gd2hlbiBSZWdFeHAjZXhlYyAhPT0gbmF0aXZlRXhlY1xuLy8gV2VleCBKUyBoYXMgZnJvemVuIGJ1aWx0LWluIHByb3RvdHlwZXMsIHNvIHVzZSB0cnkgLyBjYXRjaCB3cmFwcGVyXG52YXIgU1BMSVRfV09SS1NfV0lUSF9PVkVSV1JJVFRFTl9FWEVDID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlID0gLyg/OikvO1xuICB2YXIgb3JpZ2luYWxFeGVjID0gcmUuZXhlYztcbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9yaWdpbmFsRXhlYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICB2YXIgcmVzdWx0ID0gJ2FiJy5zcGxpdChyZSk7XG4gIHJldHVybiByZXN1bHQubGVuZ3RoICE9PSAyIHx8IHJlc3VsdFswXSAhPT0gJ2EnIHx8IHJlc3VsdFsxXSAhPT0gJ2InO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgbGVuZ3RoLCBleGVjLCBzaGFtKSB7XG4gIHZhciBTWU1CT0wgPSB3ZWxsS25vd25TeW1ib2woS0VZKTtcblxuICB2YXIgREVMRUdBVEVTX1RPX1NZTUJPTCA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3RyaW5nIG1ldGhvZHMgY2FsbCBzeW1ib2wtbmFtZWQgUmVnRXAgbWV0aG9kc1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KTtcblxuICB2YXIgREVMRUdBVEVTX1RPX0VYRUMgPSBERUxFR0FURVNfVE9fU1lNQk9MICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3ltYm9sLW5hbWVkIFJlZ0V4cCBtZXRob2RzIGNhbGwgLmV4ZWNcbiAgICB2YXIgZXhlY0NhbGxlZCA9IGZhbHNlO1xuICAgIHZhciByZSA9IC9hLztcblxuICAgIGlmIChLRVkgPT09ICdzcGxpdCcpIHtcbiAgICAgIC8vIFdlIGNhbid0IHVzZSByZWFsIHJlZ2V4IGhlcmUgc2luY2UgaXQgY2F1c2VzIGRlb3B0aW1pemF0aW9uXG4gICAgICAvLyBhbmQgc2VyaW91cyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvbiBpbiBWOFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzMwNlxuICAgICAgcmUgPSB7fTtcbiAgICAgIC8vIFJlZ0V4cFtAQHNwbGl0XSBkb2Vzbid0IGNhbGwgdGhlIHJlZ2V4J3MgZXhlYyBtZXRob2QsIGJ1dCBmaXJzdCBjcmVhdGVzXG4gICAgICAvLyBhIG5ldyBvbmUuIFdlIG5lZWQgdG8gcmV0dXJuIHRoZSBwYXRjaGVkIHJlZ2V4IHdoZW4gY3JlYXRpbmcgdGhlIG5ldyBvbmUuXG4gICAgICByZS5jb25zdHJ1Y3RvciA9IHt9O1xuICAgICAgcmUuY29uc3RydWN0b3JbU1BFQ0lFU10gPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZTsgfTtcbiAgICAgIHJlLmZsYWdzID0gJyc7XG4gICAgICByZVtTWU1CT0xdID0gLy4vW1NZTUJPTF07XG4gICAgfVxuXG4gICAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHsgZXhlY0NhbGxlZCA9IHRydWU7IHJldHVybiBudWxsOyB9O1xuXG4gICAgcmVbU1lNQk9MXSgnJyk7XG4gICAgcmV0dXJuICFleGVjQ2FsbGVkO1xuICB9KTtcblxuICBpZiAoXG4gICAgIURFTEVHQVRFU19UT19TWU1CT0wgfHxcbiAgICAhREVMRUdBVEVTX1RPX0VYRUMgfHxcbiAgICAoS0VZID09PSAncmVwbGFjZScgJiYgIVJFUExBQ0VfU1VQUE9SVFNfTkFNRURfR1JPVVBTKSB8fFxuICAgIChLRVkgPT09ICdzcGxpdCcgJiYgIVNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQylcbiAgKSB7XG4gICAgdmFyIG5hdGl2ZVJlZ0V4cE1ldGhvZCA9IC8uL1tTWU1CT0xdO1xuICAgIHZhciBtZXRob2RzID0gZXhlYyhTWU1CT0wsICcnW0tFWV0sIGZ1bmN0aW9uIChuYXRpdmVNZXRob2QsIHJlZ2V4cCwgc3RyLCBhcmcyLCBmb3JjZVN0cmluZ01ldGhvZCkge1xuICAgICAgaWYgKHJlZ2V4cC5leGVjID09PSByZWdleHBFeGVjKSB7XG4gICAgICAgIGlmIChERUxFR0FURVNfVE9fU1lNQk9MICYmICFmb3JjZVN0cmluZ01ldGhvZCkge1xuICAgICAgICAgIC8vIFRoZSBuYXRpdmUgU3RyaW5nIG1ldGhvZCBhbHJlYWR5IGRlbGVnYXRlcyB0byBAQG1ldGhvZCAodGhpc1xuICAgICAgICAgIC8vIHBvbHlmaWxsZWQgZnVuY3Rpb24pLCBsZWFzaW5nIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgICAgICAgICAvLyBXZSBhdm9pZCBpdCBieSBkaXJlY3RseSBjYWxsaW5nIHRoZSBuYXRpdmUgQEBtZXRob2QgbWV0aG9kLlxuICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiBuYXRpdmVSZWdFeHBNZXRob2QuY2FsbChyZWdleHAsIHN0ciwgYXJnMikgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbmF0aXZlTWV0aG9kLmNhbGwoc3RyLCByZWdleHAsIGFyZzIpIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyBkb25lOiBmYWxzZSB9O1xuICAgIH0pO1xuICAgIHZhciBzdHJpbmdNZXRob2QgPSBtZXRob2RzWzBdO1xuICAgIHZhciByZWdleE1ldGhvZCA9IG1ldGhvZHNbMV07XG5cbiAgICByZWRlZmluZShTdHJpbmcucHJvdG90eXBlLCBLRVksIHN0cmluZ01ldGhvZCk7XG4gICAgcmVkZWZpbmUoUmVnRXhwLnByb3RvdHlwZSwgU1lNQk9MLCBsZW5ndGggPT0gMlxuICAgICAgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKVxuICAgICAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF0oc3RyaW5nLCBsaW1pdClcbiAgICAgID8gZnVuY3Rpb24gKHN0cmluZywgYXJnKSB7IHJldHVybiByZWdleE1ldGhvZC5jYWxsKHN0cmluZywgdGhpcywgYXJnKTsgfVxuICAgICAgLy8gMjEuMi41LjYgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXShzdHJpbmcpXG4gICAgICAvLyAyMS4yLjUuOSBSZWdFeHAucHJvdG90eXBlW0BAc2VhcmNoXShzdHJpbmcpXG4gICAgICA6IGZ1bmN0aW9uIChzdHJpbmcpIHsgcmV0dXJuIHJlZ2V4TWV0aG9kLmNhbGwoc3RyaW5nLCB0aGlzKTsgfVxuICAgICk7XG4gICAgaWYgKHNoYW0pIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShSZWdFeHAucHJvdG90eXBlW1NZTUJPTF0sICdzaGFtJywgdHJ1ZSk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY2hhckF0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy1tdWx0aWJ5dGUnKS5jaGFyQXQ7XG5cbi8vIGBBZHZhbmNlU3RyaW5nSW5kZXhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYWR2YW5jZXN0cmluZ2luZGV4XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTLCBpbmRleCwgdW5pY29kZSkge1xuICByZXR1cm4gaW5kZXggKyAodW5pY29kZSA/IGNoYXJBdChTLCBpbmRleCkubGVuZ3RoIDogMSk7XG59O1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL2NsYXNzb2YtcmF3Jyk7XG52YXIgcmVnZXhwRXhlYyA9IHJlcXVpcmUoJy4vcmVnZXhwLWV4ZWMnKTtcblxuLy8gYFJlZ0V4cEV4ZWNgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwZXhlY1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUiwgUykge1xuICB2YXIgZXhlYyA9IFIuZXhlYztcbiAgaWYgKHR5cGVvZiBleGVjID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHJlc3VsdCA9IGV4ZWMuY2FsbChSLCBTKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignUmVnRXhwIGV4ZWMgbWV0aG9kIHJldHVybmVkIHNvbWV0aGluZyBvdGhlciB0aGFuIGFuIE9iamVjdCBvciBudWxsJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoY2xhc3NvZihSKSAhPT0gJ1JlZ0V4cCcpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZ0V4cCNleGVjIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgcmVjZWl2ZXInKTtcbiAgfVxuXG4gIHJldHVybiByZWdleHBFeGVjLmNhbGwoUiwgUyk7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG52YXIgZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZml4LXJlZ2V4cC13ZWxsLWtub3duLXN5bWJvbC1sb2dpYycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcbnZhciByZWdFeHBFeGVjID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFMgPSAvXFwkKFskJidgXXxcXGRcXGQ/fDxbXj5dKj4pL2c7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQgPSAvXFwkKFskJidgXXxcXGRcXGQ/KS9nO1xuXG52YXIgbWF5YmVUb1N0cmluZyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/IGl0IDogU3RyaW5nKGl0KTtcbn07XG5cbi8vIEBAcmVwbGFjZSBsb2dpY1xuZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMoJ3JlcGxhY2UnLCAyLCBmdW5jdGlvbiAoUkVQTEFDRSwgbmF0aXZlUmVwbGFjZSwgbWF5YmVDYWxsTmF0aXZlKSB7XG4gIHJldHVybiBbXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUucmVwbGFjZWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlXG4gICAgZnVuY3Rpb24gcmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKSB7XG4gICAgICB2YXIgTyA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcyk7XG4gICAgICB2YXIgcmVwbGFjZXIgPSBzZWFyY2hWYWx1ZSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZWFyY2hWYWx1ZVtSRVBMQUNFXTtcbiAgICAgIHJldHVybiByZXBsYWNlciAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gcmVwbGFjZXIuY2FsbChzZWFyY2hWYWx1ZSwgTywgcmVwbGFjZVZhbHVlKVxuICAgICAgICA6IG5hdGl2ZVJlcGxhY2UuY2FsbChTdHJpbmcoTyksIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHJlcGxhY2VcbiAgICBmdW5jdGlvbiAocmVnZXhwLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUobmF0aXZlUmVwbGFjZSwgcmVnZXhwLCB0aGlzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuXG4gICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG5cbiAgICAgIHZhciBmdW5jdGlvbmFsUmVwbGFjZSA9IHR5cGVvZiByZXBsYWNlVmFsdWUgPT09ICdmdW5jdGlvbic7XG4gICAgICBpZiAoIWZ1bmN0aW9uYWxSZXBsYWNlKSByZXBsYWNlVmFsdWUgPSBTdHJpbmcocmVwbGFjZVZhbHVlKTtcblxuICAgICAgdmFyIGdsb2JhbCA9IHJ4Lmdsb2JhbDtcbiAgICAgIGlmIChnbG9iYWwpIHtcbiAgICAgICAgdmFyIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcbiAgICAgICAgcngubGFzdEluZGV4ID0gMDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUyk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIGJyZWFrO1xuXG4gICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICBpZiAoIWdsb2JhbCkgYnJlYWs7XG5cbiAgICAgICAgdmFyIG1hdGNoU3RyID0gU3RyaW5nKHJlc3VsdFswXSk7XG4gICAgICAgIGlmIChtYXRjaFN0ciA9PT0gJycpIHJ4Lmxhc3RJbmRleCA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCB0b0xlbmd0aChyeC5sYXN0SW5kZXgpLCBmdWxsVW5pY29kZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhY2N1bXVsYXRlZFJlc3VsdCA9ICcnO1xuICAgICAgdmFyIG5leHRTb3VyY2VQb3NpdGlvbiA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0c1tpXTtcblxuICAgICAgICB2YXIgbWF0Y2hlZCA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBtYXgobWluKHRvSW50ZWdlcihyZXN1bHQuaW5kZXgpLCBTLmxlbmd0aCksIDApO1xuICAgICAgICB2YXIgY2FwdHVyZXMgPSBbXTtcbiAgICAgICAgLy8gTk9URTogVGhpcyBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAgIC8vICAgY2FwdHVyZXMgPSByZXN1bHQuc2xpY2UoMSkubWFwKG1heWJlVG9TdHJpbmcpXG4gICAgICAgIC8vIGJ1dCBmb3Igc29tZSByZWFzb24gYG5hdGl2ZVNsaWNlLmNhbGwocmVzdWx0LCAxLCByZXN1bHQubGVuZ3RoKWAgKGNhbGxlZCBpblxuICAgICAgICAvLyB0aGUgc2xpY2UgcG9seWZpbGwgd2hlbiBzbGljaW5nIG5hdGl2ZSBhcnJheXMpIFwiZG9lc24ndCB3b3JrXCIgaW4gc2FmYXJpIDkgYW5kXG4gICAgICAgIC8vIGNhdXNlcyBhIGNyYXNoIChodHRwczovL3Bhc3RlYmluLmNvbS9OMjFRemVRQSkgd2hlbiB0cnlpbmcgdG8gZGVidWcgaXQuXG4gICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgcmVzdWx0Lmxlbmd0aDsgaisrKSBjYXB0dXJlcy5wdXNoKG1heWJlVG9TdHJpbmcocmVzdWx0W2pdKSk7XG4gICAgICAgIHZhciBuYW1lZENhcHR1cmVzID0gcmVzdWx0Lmdyb3VwcztcbiAgICAgICAgaWYgKGZ1bmN0aW9uYWxSZXBsYWNlKSB7XG4gICAgICAgICAgdmFyIHJlcGxhY2VyQXJncyA9IFttYXRjaGVkXS5jb25jYXQoY2FwdHVyZXMsIHBvc2l0aW9uLCBTKTtcbiAgICAgICAgICBpZiAobmFtZWRDYXB0dXJlcyAhPT0gdW5kZWZpbmVkKSByZXBsYWNlckFyZ3MucHVzaChuYW1lZENhcHR1cmVzKTtcbiAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBTdHJpbmcocmVwbGFjZVZhbHVlLmFwcGx5KHVuZGVmaW5lZCwgcmVwbGFjZXJBcmdzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVwbGFjZW1lbnQgPSBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgUywgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSBuZXh0U291cmNlUG9zaXRpb24pIHtcbiAgICAgICAgICBhY2N1bXVsYXRlZFJlc3VsdCArPSBTLnNsaWNlKG5leHRTb3VyY2VQb3NpdGlvbiwgcG9zaXRpb24pICsgcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgbmV4dFNvdXJjZVBvc2l0aW9uID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdGVkUmVzdWx0ICsgUy5zbGljZShuZXh0U291cmNlUG9zaXRpb24pO1xuICAgIH1cbiAgXTtcblxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1nZXRzdWJzdGl0dXRpb25cbiAgZnVuY3Rpb24gZ2V0U3Vic3RpdHV0aW9uKG1hdGNoZWQsIHN0ciwgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlbWVudCkge1xuICAgIHZhciB0YWlsUG9zID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICB2YXIgbSA9IGNhcHR1cmVzLmxlbmd0aDtcbiAgICB2YXIgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTX05PX05BTUVEO1xuICAgIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG5hbWVkQ2FwdHVyZXMgPSB0b09iamVjdChuYW1lZENhcHR1cmVzKTtcbiAgICAgIHN5bWJvbHMgPSBTVUJTVElUVVRJT05fU1lNQk9MUztcbiAgICB9XG4gICAgcmV0dXJuIG5hdGl2ZVJlcGxhY2UuY2FsbChyZXBsYWNlbWVudCwgc3ltYm9scywgZnVuY3Rpb24gKG1hdGNoLCBjaCkge1xuICAgICAgdmFyIGNhcHR1cmU7XG4gICAgICBzd2l0Y2ggKGNoLmNoYXJBdCgwKSkge1xuICAgICAgICBjYXNlICckJzogcmV0dXJuICckJztcbiAgICAgICAgY2FzZSAnJic6IHJldHVybiBtYXRjaGVkO1xuICAgICAgICBjYXNlICdgJzogcmV0dXJuIHN0ci5zbGljZSgwLCBwb3NpdGlvbik7XG4gICAgICAgIGNhc2UgXCInXCI6IHJldHVybiBzdHIuc2xpY2UodGFpbFBvcyk7XG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgIGNhcHR1cmUgPSBuYW1lZENhcHR1cmVzW2NoLnNsaWNlKDEsIC0xKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IC8vIFxcZFxcZD9cbiAgICAgICAgICB2YXIgbiA9ICtjaDtcbiAgICAgICAgICBpZiAobiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIGlmIChuID4gbSkge1xuICAgICAgICAgICAgdmFyIGYgPSBmbG9vcihuIC8gMTApO1xuICAgICAgICAgICAgaWYgKGYgPT09IDApIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgIGlmIChmIDw9IG0pIHJldHVybiBjYXB0dXJlc1tmIC0gMV0gPT09IHVuZGVmaW5lZCA/IGNoLmNoYXJBdCgxKSA6IGNhcHR1cmVzW2YgLSAxXSArIGNoLmNoYXJBdCgxKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FwdHVyZSA9IGNhcHR1cmVzW24gLSAxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYXB0dXJlID09PSB1bmRlZmluZWQgPyAnJyA6IGNhcHR1cmU7XG4gICAgfSk7XG4gIH1cbn0pO1xuIiwiLy8gYSBzdHJpbmcgb2YgYWxsIHZhbGlkIHVuaWNvZGUgd2hpdGVzcGFjZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG5tb2R1bGUuZXhwb3J0cyA9ICdcXHUwMDA5XFx1MDAwQVxcdTAwMEJcXHUwMDBDXFx1MDAwRFxcdTAwMjBcXHUwMEEwXFx1MTY4MFxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJztcbiIsInZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xudmFyIHdoaXRlc3BhY2VzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3doaXRlc3BhY2VzJyk7XG5cbnZhciB3aGl0ZXNwYWNlID0gJ1snICsgd2hpdGVzcGFjZXMgKyAnXSc7XG52YXIgbHRyaW0gPSBSZWdFeHAoJ14nICsgd2hpdGVzcGFjZSArIHdoaXRlc3BhY2UgKyAnKicpO1xudmFyIHJ0cmltID0gUmVnRXhwKHdoaXRlc3BhY2UgKyB3aGl0ZXNwYWNlICsgJyokJyk7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbSwgdHJpbVN0YXJ0LCB0cmltRW5kLCB0cmltTGVmdCwgdHJpbVJpZ2h0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzKSB7XG4gICAgdmFyIHN0cmluZyA9IFN0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCR0aGlzKSk7XG4gICAgaWYgKFRZUEUgJiAxKSBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShsdHJpbSwgJycpO1xuICAgIGlmIChUWVBFICYgMikgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocnRyaW0sICcnKTtcbiAgICByZXR1cm4gc3RyaW5nO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbUxlZnQsIHRyaW1TdGFydCB9YCBtZXRob2RzXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbXN0YXJ0XG4gIHN0YXJ0OiBjcmVhdGVNZXRob2QoMSksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbVJpZ2h0LCB0cmltRW5kIH1gIG1ldGhvZHNcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltZW5kXG4gIGVuZDogY3JlYXRlTWV0aG9kKDIpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS50cmltYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltXG4gIHRyaW06IGNyZWF0ZU1ldGhvZCgzKVxufTtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIHdoaXRlc3BhY2VzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3doaXRlc3BhY2VzJyk7XG5cbnZhciBub24gPSAnXFx1MjAwQlxcdTAwODVcXHUxODBFJztcblxuLy8gY2hlY2sgdGhhdCBhIG1ldGhvZCB3b3JrcyB3aXRoIHRoZSBjb3JyZWN0IGxpc3Rcbi8vIG9mIHdoaXRlc3BhY2VzIGFuZCBoYXMgYSBjb3JyZWN0IG5hbWVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gIHJldHVybiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhd2hpdGVzcGFjZXNbTUVUSE9EX05BTUVdKCkgfHwgbm9uW01FVEhPRF9OQU1FXSgpICE9IG5vbiB8fCB3aGl0ZXNwYWNlc1tNRVRIT0RfTkFNRV0ubmFtZSAhPT0gTUVUSE9EX05BTUU7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyICR0cmltID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy10cmltJykudHJpbTtcbnZhciBmb3JjZWRTdHJpbmdUcmltTWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZvcmNlZC1zdHJpbmctdHJpbS1tZXRob2QnKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUudHJpbWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1cbiQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBmb3JjZWRTdHJpbmdUcmltTWV0aG9kKCd0cmltJykgfSwge1xuICB0cmltOiBmdW5jdGlvbiB0cmltKCkge1xuICAgIHJldHVybiAkdHJpbSh0aGlzKTtcbiAgfVxufSk7XG4iLCIvLyBNYXAgZnVuY3Rpb25cclxuZXhwb3J0IGZ1bmN0aW9uIG1hcCAoYXJyYXksIGJsb2NrKSB7XHJcbiAgdmFyIGlcclxuICB2YXIgaWwgPSBhcnJheS5sZW5ndGhcclxuICB2YXIgcmVzdWx0ID0gW11cclxuXHJcbiAgZm9yIChpID0gMDsgaSA8IGlsOyBpKyspIHtcclxuICAgIHJlc3VsdC5wdXNoKGJsb2NrKGFycmF5W2ldKSlcclxuICB9XHJcblxyXG4gIHJldHVybiByZXN1bHRcclxufVxyXG5cclxuLy8gRmlsdGVyIGZ1bmN0aW9uXHJcbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXIgKGFycmF5LCBibG9jaykge1xyXG4gIHZhciBpXHJcbiAgdmFyIGlsID0gYXJyYXkubGVuZ3RoXHJcbiAgdmFyIHJlc3VsdCA9IFtdXHJcblxyXG4gIGZvciAoaSA9IDA7IGkgPCBpbDsgaSsrKSB7XHJcbiAgICBpZiAoYmxvY2soYXJyYXlbaV0pKSB7XHJcbiAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlc3VsdFxyXG59XHJcblxyXG4vLyBEZWdyZWVzIHRvIHJhZGlhbnNcclxuZXhwb3J0IGZ1bmN0aW9uIHJhZGlhbnMgKGQpIHtcclxuICByZXR1cm4gZCAlIDM2MCAqIE1hdGguUEkgLyAxODBcclxufVxyXG5cclxuLy8gUmFkaWFucyB0byBkZWdyZWVzXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWdyZWVzIChyKSB7XHJcbiAgcmV0dXJuIHIgKiAxODAgLyBNYXRoLlBJICUgMzYwXHJcbn1cclxuXHJcbi8vIENvbnZlcnQgZGFzaC1zZXBhcmF0ZWQtc3RyaW5nIHRvIGNhbWVsQ2FzZVxyXG5leHBvcnQgZnVuY3Rpb24gY2FtZWxDYXNlIChzKSB7XHJcbiAgcmV0dXJuIHMudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tKC4pL2csIGZ1bmN0aW9uIChtLCBnKSB7XHJcbiAgICByZXR1cm4gZy50b1VwcGVyQ2FzZSgpXHJcbiAgfSlcclxufVxyXG5cclxuLy8gQ29udmVydCBjYW1lbCBjYXNlZCBzdHJpbmcgdG8gc3RyaW5nIHNlcGVyYXRlZFxyXG5leHBvcnQgZnVuY3Rpb24gdW5DYW1lbENhc2UgKHMpIHtcclxuICByZXR1cm4gcy5yZXBsYWNlKC8oW0EtWl0pL2csIGZ1bmN0aW9uIChtLCBnKSB7XHJcbiAgICByZXR1cm4gJy0nICsgZy50b0xvd2VyQ2FzZSgpXHJcbiAgfSlcclxufVxyXG5cclxuLy8gQ2FwaXRhbGl6ZSBmaXJzdCBsZXR0ZXIgb2YgYSBzdHJpbmdcclxuZXhwb3J0IGZ1bmN0aW9uIGNhcGl0YWxpemUgKHMpIHtcclxuICByZXR1cm4gcy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHMuc2xpY2UoMSlcclxufVxyXG5cclxuLy8gQ2FsY3VsYXRlIHByb3BvcnRpb25hbCB3aWR0aCBhbmQgaGVpZ2h0IHZhbHVlcyB3aGVuIG5lY2Vzc2FyeVxyXG5leHBvcnQgZnVuY3Rpb24gcHJvcG9ydGlvbmFsU2l6ZSAoZWxlbWVudCwgd2lkdGgsIGhlaWdodCwgYm94KSB7XHJcbiAgaWYgKHdpZHRoID09IG51bGwgfHwgaGVpZ2h0ID09IG51bGwpIHtcclxuICAgIGJveCA9IGJveCB8fCBlbGVtZW50LmJib3goKVxyXG5cclxuICAgIGlmICh3aWR0aCA9PSBudWxsKSB7XHJcbiAgICAgIHdpZHRoID0gYm94LndpZHRoIC8gYm94LmhlaWdodCAqIGhlaWdodFxyXG4gICAgfSBlbHNlIGlmIChoZWlnaHQgPT0gbnVsbCkge1xyXG4gICAgICBoZWlnaHQgPSBib3guaGVpZ2h0IC8gYm94LndpZHRoICogd2lkdGhcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICB3aWR0aDogd2lkdGgsXHJcbiAgICBoZWlnaHQ6IGhlaWdodFxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE9yaWdpbiAobywgZWxlbWVudCkge1xyXG4gIC8vIEFsbG93IG9yaWdpbiBvciBhcm91bmQgYXMgdGhlIG5hbWVzXHJcbiAgY29uc3Qgb3JpZ2luID0gby5vcmlnaW4gLy8gby5hcm91bmQgPT0gbnVsbCA/IG8ub3JpZ2luIDogby5hcm91bmRcclxuICBsZXQgb3gsIG95XHJcblxyXG4gIC8vIEFsbG93IHRoZSB1c2VyIHRvIHBhc3MgYSBzdHJpbmcgdG8gcm90YXRlIGFyb3VuZCBhIGdpdmVuIHBvaW50XHJcbiAgaWYgKHR5cGVvZiBvcmlnaW4gPT09ICdzdHJpbmcnIHx8IG9yaWdpbiA9PSBudWxsKSB7XHJcbiAgICAvLyBHZXQgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgZWxlbWVudCB3aXRoIG5vIHRyYW5zZm9ybWF0aW9ucyBhcHBsaWVkXHJcbiAgICBjb25zdCBzdHJpbmcgPSAob3JpZ2luIHx8ICdjZW50ZXInKS50b0xvd2VyQ2FzZSgpLnRyaW0oKVxyXG4gICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoLCB4LCB5IH0gPSBlbGVtZW50LmJib3goKVxyXG5cclxuICAgIC8vIENhbGN1bGF0ZSB0aGUgdHJhbnNmb3JtZWQgeCBhbmQgeSBjb29yZGluYXRlc1xyXG4gICAgY29uc3QgYnggPSBzdHJpbmcuaW5jbHVkZXMoJ2xlZnQnKSA/IHhcclxuICAgICAgOiBzdHJpbmcuaW5jbHVkZXMoJ3JpZ2h0JykgPyB4ICsgd2lkdGhcclxuICAgICAgOiB4ICsgd2lkdGggLyAyXHJcbiAgICBjb25zdCBieSA9IHN0cmluZy5pbmNsdWRlcygndG9wJykgPyB5XHJcbiAgICAgIDogc3RyaW5nLmluY2x1ZGVzKCdib3R0b20nKSA/IHkgKyBoZWlnaHRcclxuICAgICAgOiB5ICsgaGVpZ2h0IC8gMlxyXG5cclxuICAgIC8vIFNldCB0aGUgYm91bmRzIGVnIDogXCJib3R0b20tbGVmdFwiLCBcIlRvcCByaWdodFwiLCBcIm1pZGRsZVwiIGV0Yy4uLlxyXG4gICAgb3ggPSBvLm94ICE9IG51bGwgPyBvLm94IDogYnhcclxuICAgIG95ID0gby5veSAhPSBudWxsID8gby5veSA6IGJ5XHJcbiAgfSBlbHNlIHtcclxuICAgIG94ID0gb3JpZ2luWzBdXHJcbiAgICBveSA9IG9yaWdpblsxXVxyXG4gIH1cclxuXHJcbiAgLy8gUmV0dXJuIHRoZSBvcmlnaW4gYXMgaXQgaXMgaWYgaXQgd2Fzbid0IGEgc3RyaW5nXHJcbiAgcmV0dXJuIFsgb3gsIG95IF1cclxufVxyXG4iLCIvLyBEZWZhdWx0IG5hbWVzcGFjZXNcclxuZXhwb3J0IGNvbnN0IG5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xyXG5leHBvcnQgY29uc3QgeG1sbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nXHJcbmV4cG9ydCBjb25zdCB4bGluayA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJ1xyXG5leHBvcnQgY29uc3Qgc3ZnanMgPSAnaHR0cDovL3N2Z2pzLmNvbS9zdmdqcydcclxuIiwiZXhwb3J0IGNvbnN0IGdsb2JhbHMgPSB7XHJcbiAgd2luZG93OiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3csXHJcbiAgZG9jdW1lbnQ6IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogZG9jdW1lbnRcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyV2luZG93ICh3aW4gPSBudWxsLCBkb2MgPSBudWxsKSB7XHJcbiAgZ2xvYmFscy53aW5kb3cgPSB3aW5cclxuICBnbG9iYWxzLmRvY3VtZW50ID0gZG9jXHJcbn1cclxuXHJcbmNvbnN0IHNhdmUgPSB7fVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNhdmVXaW5kb3cgKCkge1xyXG4gIHNhdmUud2luZG93ID0gZ2xvYmFscy53aW5kb3dcclxuICBzYXZlLmRvY3VtZW50ID0gZ2xvYmFscy5kb2N1bWVudFxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVzdG9yZVdpbmRvdyAoKSB7XHJcbiAgZ2xvYmFscy53aW5kb3cgPSBzYXZlLndpbmRvd1xyXG4gIGdsb2JhbHMuZG9jdW1lbnQgPSBzYXZlLmRvY3VtZW50XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB3aXRoV2luZG93ICh3aW4sIGZuKSB7XHJcbiAgc2F2ZVdpbmRvdygpXHJcbiAgcmVnaXN0ZXJXaW5kb3cod2luLCB3aW4uZG9jdW1lbnQpXHJcbiAgZm4od2luLCB3aW4uZG9jdW1lbnQpXHJcbiAgcmVzdG9yZVdpbmRvdygpXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRXaW5kb3cgKCkge1xyXG4gIHJldHVybiBnbG9iYWxzLndpbmRvd1xyXG59XHJcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59IiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZSB7XHJcbiAgLy8gY29uc3RydWN0b3IgKG5vZGUvKiwge2V4dGVuc2lvbnMgPSBbXX0gKi8pIHtcclxuICAvLyAgIC8vIHRoaXMudGFncyA9IFtdXHJcbiAgLy8gICAvL1xyXG4gIC8vICAgLy8gZm9yIChsZXQgZXh0ZW5zaW9uIG9mIGV4dGVuc2lvbnMpIHtcclxuICAvLyAgIC8vICAgZXh0ZW5zaW9uLnNldHVwLmNhbGwodGhpcywgbm9kZSlcclxuICAvLyAgIC8vICAgdGhpcy50YWdzLnB1c2goZXh0ZW5zaW9uLm5hbWUpXHJcbiAgLy8gICAvLyB9XHJcbiAgLy8gfVxyXG59XHJcbiIsImltcG9ydCB7IGFkZE1ldGhvZE5hbWVzIH0gZnJvbSAnLi9tZXRob2RzLmpzJ1xyXG5pbXBvcnQgeyBjYXBpdGFsaXplIH0gZnJvbSAnLi91dGlscy5qcydcclxuaW1wb3J0IHsgbnMgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvbmFtZXNwYWNlcy5qcydcclxuaW1wb3J0IHsgZ2xvYmFscyB9IGZyb20gJy4uL3V0aWxzL3dpbmRvdy5qcydcclxuaW1wb3J0IEJhc2UgZnJvbSAnLi4vdHlwZXMvQmFzZS5qcydcclxuXHJcbmNvbnN0IGVsZW1lbnRzID0ge31cclxuZXhwb3J0IGNvbnN0IHJvb3QgPSAnX19fU1lNQk9MX19fUk9PVF9fXydcclxuXHJcbi8vIE1ldGhvZCBmb3IgZWxlbWVudCBjcmVhdGlvblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlIChuYW1lKSB7XHJcbiAgLy8gY3JlYXRlIGVsZW1lbnRcclxuICByZXR1cm4gZ2xvYmFscy5kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsIG5hbWUpXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtYWtlSW5zdGFuY2UgKGVsZW1lbnQpIHtcclxuICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEJhc2UpIHJldHVybiBlbGVtZW50XHJcblxyXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcpIHtcclxuICAgIHJldHVybiBhZG9wdGVyKGVsZW1lbnQpXHJcbiAgfVxyXG5cclxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XHJcbiAgICByZXR1cm4gbmV3IGVsZW1lbnRzW3Jvb3RdKClcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgJiYgZWxlbWVudC5jaGFyQXQoMCkgIT09ICc8Jykge1xyXG4gICAgcmV0dXJuIGFkb3B0ZXIoZ2xvYmFscy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsZW1lbnQpKVxyXG4gIH1cclxuXHJcbiAgdmFyIG5vZGUgPSBjcmVhdGUoJ3N2ZycpXHJcbiAgbm9kZS5pbm5lckhUTUwgPSBlbGVtZW50XHJcblxyXG4gIC8vIFdlIGNhbiB1c2UgZmlyc3RDaGlsZCBoZXJlIGJlY2F1c2Ugd2Uga25vdyxcclxuICAvLyB0aGF0IHRoZSBmaXJzdCBjaGFyIGlzIDwgYW5kIHRodXMgYW4gZWxlbWVudFxyXG4gIGVsZW1lbnQgPSBhZG9wdGVyKG5vZGUuZmlyc3RDaGlsZClcclxuXHJcbiAgcmV0dXJuIGVsZW1lbnRcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG5vZGVPck5ldyAobmFtZSwgbm9kZSkge1xyXG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgZ2xvYmFscy53aW5kb3cuTm9kZSA/IG5vZGUgOiBjcmVhdGUobmFtZSlcclxufVxyXG5cclxuLy8gQWRvcHQgZXhpc3Rpbmcgc3ZnIGVsZW1lbnRzXHJcbmV4cG9ydCBmdW5jdGlvbiBhZG9wdCAobm9kZSkge1xyXG4gIC8vIGNoZWNrIGZvciBwcmVzZW5jZSBvZiBub2RlXHJcbiAgaWYgKCFub2RlKSByZXR1cm4gbnVsbFxyXG5cclxuICAvLyBtYWtlIHN1cmUgYSBub2RlIGlzbid0IGFscmVhZHkgYWRvcHRlZFxyXG4gIGlmIChub2RlLmluc3RhbmNlIGluc3RhbmNlb2YgQmFzZSkgcmV0dXJuIG5vZGUuaW5zdGFuY2VcclxuXHJcbiAgLy8gaW5pdGlhbGl6ZSB2YXJpYWJsZXNcclxuICB2YXIgY2xhc3NOYW1lID0gY2FwaXRhbGl6ZShub2RlLm5vZGVOYW1lIHx8ICdEb20nKVxyXG5cclxuICAvLyBNYWtlIHN1cmUgdGhhdCBncmFkaWVudHMgYXJlIGFkb3B0ZWQgY29ycmVjdGx5XHJcbiAgaWYgKGNsYXNzTmFtZSA9PT0gJ0xpbmVhckdyYWRpZW50JyB8fCBjbGFzc05hbWUgPT09ICdSYWRpYWxHcmFkaWVudCcpIHtcclxuICAgIGNsYXNzTmFtZSA9ICdHcmFkaWVudCdcclxuXHJcbiAgLy8gRmFsbGJhY2sgdG8gRG9tIGlmIGVsZW1lbnQgaXMgbm90IGtub3duXHJcbiAgfSBlbHNlIGlmICghZWxlbWVudHNbY2xhc3NOYW1lXSkge1xyXG4gICAgY2xhc3NOYW1lID0gJ0RvbSdcclxuICB9XHJcblxyXG4gIHJldHVybiBuZXcgZWxlbWVudHNbY2xhc3NOYW1lXShub2RlKVxyXG59XHJcblxyXG5sZXQgYWRvcHRlciA9IGFkb3B0XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbW9ja0Fkb3B0IChtb2NrID0gYWRvcHQpIHtcclxuICBhZG9wdGVyID0gbW9ja1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXIgKGVsZW1lbnQsIG5hbWUgPSBlbGVtZW50Lm5hbWUsIGFzUm9vdCA9IGZhbHNlKSB7XHJcbiAgZWxlbWVudHNbbmFtZV0gPSBlbGVtZW50XHJcbiAgaWYgKGFzUm9vdCkgZWxlbWVudHNbcm9vdF0gPSBlbGVtZW50XHJcblxyXG4gIGFkZE1ldGhvZE5hbWVzKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVsZW1lbnQucHJvdG90eXBlKSlcclxuXHJcbiAgcmV0dXJuIGVsZW1lbnRcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldENsYXNzIChuYW1lKSB7XHJcbiAgcmV0dXJuIGVsZW1lbnRzW25hbWVdXHJcbn1cclxuXHJcbi8vIEVsZW1lbnQgaWQgc2VxdWVuY2VcclxubGV0IGRpZCA9IDEwMDBcclxuXHJcbi8vIEdldCBuZXh0IG5hbWVkIGVsZW1lbnQgaWRcclxuZXhwb3J0IGZ1bmN0aW9uIGVpZCAobmFtZSkge1xyXG4gIHJldHVybiAnU3ZnanMnICsgY2FwaXRhbGl6ZShuYW1lKSArIChkaWQrKylcclxufVxyXG5cclxuLy8gRGVlcCBuZXcgaWQgYXNzaWdubWVudFxyXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduTmV3SWQgKG5vZGUpIHtcclxuICAvLyBkbyB0aGUgc2FtZSBmb3IgU1ZHIGNoaWxkIG5vZGVzIGFzIHdlbGxcclxuICBmb3IgKHZhciBpID0gbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgYXNzaWduTmV3SWQobm9kZS5jaGlsZHJlbltpXSlcclxuICB9XHJcblxyXG4gIGlmIChub2RlLmlkKSB7XHJcbiAgICByZXR1cm4gYWRvcHQobm9kZSkuaWQoZWlkKG5vZGUubm9kZU5hbWUpKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFkb3B0KG5vZGUpXHJcbn1cclxuXHJcbi8vIE1ldGhvZCBmb3IgZXh0ZW5kaW5nIG9iamVjdHNcclxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZCAobW9kdWxlcywgbWV0aG9kcywgYXR0ckNoZWNrKSB7XHJcbiAgdmFyIGtleSwgaVxyXG5cclxuICBtb2R1bGVzID0gQXJyYXkuaXNBcnJheShtb2R1bGVzKSA/IG1vZHVsZXMgOiBbIG1vZHVsZXMgXVxyXG5cclxuICBmb3IgKGkgPSBtb2R1bGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICBmb3IgKGtleSBpbiBtZXRob2RzKSB7XHJcbiAgICAgIGxldCBtZXRob2QgPSBtZXRob2RzW2tleV1cclxuICAgICAgaWYgKGF0dHJDaGVjaykge1xyXG4gICAgICAgIG1ldGhvZCA9IHdyYXBXaXRoQXR0ckNoZWNrKG1ldGhvZHNba2V5XSlcclxuICAgICAgfVxyXG4gICAgICBtb2R1bGVzW2ldLnByb3RvdHlwZVtrZXldID0gbWV0aG9kXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyBleHBvcnQgZnVuY3Rpb24gZXh0ZW5kV2l0aEF0dHJDaGVjayAoLi4uYXJncykge1xyXG4vLyAgIGV4dGVuZCguLi5hcmdzLCB0cnVlKVxyXG4vLyB9XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gd3JhcFdpdGhBdHRyQ2hlY2sgKGZuKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICBjb25zdCBvID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdXHJcblxyXG4gICAgaWYgKG8gJiYgby5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmICEobyBpbnN0YW5jZW9mIEFycmF5KSkge1xyXG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncy5zbGljZSgwLCAtMSkpLmF0dHIobylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGludmVudCAoY29uZmlnKSB7XHJcbiAgLy8gQ3JlYXRlIGVsZW1lbnQgaW5pdGlhbGl6ZXJcclxuICB2YXIgaW5pdGlhbGl6ZXIgPSB0eXBlb2YgY29uZmlnLmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgPyBjb25maWcuY3JlYXRlXHJcbiAgICA6IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgIHRoaXMuY29uc3RydWN0b3Iobm9kZSB8fCBjcmVhdGUoY29uZmlnLmNyZWF0ZSkpXHJcbiAgICB9XHJcblxyXG4gIC8vIEluaGVyaXQgcHJvdG90eXBlXHJcbiAgaWYgKGNvbmZpZy5pbmhlcml0KSB7XHJcbiAgICAvKiBlc2xpbnQgbmV3LWNhcDogb2ZmICovXHJcbiAgICBpbml0aWFsaXplci5wcm90b3R5cGUgPSBuZXcgY29uZmlnLmluaGVyaXQoKVxyXG4gICAgaW5pdGlhbGl6ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gaW5pdGlhbGl6ZXJcclxuICB9XHJcblxyXG4gIC8vIEV4dGVuZCB3aXRoIG1ldGhvZHNcclxuICBpZiAoY29uZmlnLmV4dGVuZCkgeyBleHRlbmQoaW5pdGlhbGl6ZXIsIGNvbmZpZy5leHRlbmQpIH1cclxuXHJcbiAgLy8gQXR0YWNoIGNvbnN0cnVjdCBtZXRob2QgdG8gcGFyZW50XHJcbiAgaWYgKGNvbmZpZy5jb25zdHJ1Y3QpIHsgZXh0ZW5kKGNvbmZpZy5wYXJlbnQgfHwgZWxlbWVudHMuQ29udGFpbmVyLCBjb25maWcuY29uc3RydWN0KSB9XHJcblxyXG4gIHJldHVybiBpbml0aWFsaXplclxyXG59XHJcbiIsImltcG9ydCB7IG1ha2VJbnN0YW5jZSB9IGZyb20gJy4uLy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uLy4uL3V0aWxzL21ldGhvZHMuanMnXHJcblxyXG4vLyBHZXQgYWxsIHNpYmxpbmdzLCBpbmNsdWRpbmcgbXlzZWxmXHJcbmV4cG9ydCBmdW5jdGlvbiBzaWJsaW5ncyAoKSB7XHJcbiAgcmV0dXJuIHRoaXMucGFyZW50KCkuY2hpbGRyZW4oKVxyXG59XHJcblxyXG4vLyBHZXQgdGhlIGN1cmVudCBwb3NpdGlvbiBzaWJsaW5nc1xyXG5leHBvcnQgZnVuY3Rpb24gcG9zaXRpb24gKCkge1xyXG4gIHJldHVybiB0aGlzLnBhcmVudCgpLmluZGV4KHRoaXMpXHJcbn1cclxuXHJcbi8vIEdldCB0aGUgbmV4dCBlbGVtZW50ICh3aWxsIHJldHVybiBudWxsIGlmIHRoZXJlIGlzIG5vbmUpXHJcbmV4cG9ydCBmdW5jdGlvbiBuZXh0ICgpIHtcclxuICByZXR1cm4gdGhpcy5zaWJsaW5ncygpW3RoaXMucG9zaXRpb24oKSArIDFdXHJcbn1cclxuXHJcbi8vIEdldCB0aGUgbmV4dCBlbGVtZW50ICh3aWxsIHJldHVybiBudWxsIGlmIHRoZXJlIGlzIG5vbmUpXHJcbmV4cG9ydCBmdW5jdGlvbiBwcmV2ICgpIHtcclxuICByZXR1cm4gdGhpcy5zaWJsaW5ncygpW3RoaXMucG9zaXRpb24oKSAtIDFdXHJcbn1cclxuXHJcbi8vIFNlbmQgZ2l2ZW4gZWxlbWVudCBvbmUgc3RlcCBmb3J3YXJkXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3J3YXJkICgpIHtcclxuICB2YXIgaSA9IHRoaXMucG9zaXRpb24oKSArIDFcclxuICB2YXIgcCA9IHRoaXMucGFyZW50KClcclxuXHJcbiAgLy8gbW92ZSBub2RlIG9uZSBzdGVwIGZvcndhcmRcclxuICBwLnJlbW92ZUVsZW1lbnQodGhpcykuYWRkKHRoaXMsIGkpXHJcblxyXG4gIC8vIG1ha2Ugc3VyZSBkZWZzIG5vZGUgaXMgYWx3YXlzIGF0IHRoZSB0b3BcclxuICBpZiAodHlwZW9mIHAuaXNSb290ID09PSAnZnVuY3Rpb24nICYmIHAuaXNSb290KCkpIHtcclxuICAgIHAubm9kZS5hcHBlbmRDaGlsZChwLmRlZnMoKS5ub2RlKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXNcclxufVxyXG5cclxuLy8gU2VuZCBnaXZlbiBlbGVtZW50IG9uZSBzdGVwIGJhY2t3YXJkXHJcbmV4cG9ydCBmdW5jdGlvbiBiYWNrd2FyZCAoKSB7XHJcbiAgdmFyIGkgPSB0aGlzLnBvc2l0aW9uKClcclxuXHJcbiAgaWYgKGkgPiAwKSB7XHJcbiAgICB0aGlzLnBhcmVudCgpLnJlbW92ZUVsZW1lbnQodGhpcykuYWRkKHRoaXMsIGkgLSAxKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXNcclxufVxyXG5cclxuLy8gU2VuZCBnaXZlbiBlbGVtZW50IGFsbCB0aGUgd2F5IHRvIHRoZSBmcm9udFxyXG5leHBvcnQgZnVuY3Rpb24gZnJvbnQgKCkge1xyXG4gIHZhciBwID0gdGhpcy5wYXJlbnQoKVxyXG5cclxuICAvLyBNb3ZlIG5vZGUgZm9yd2FyZFxyXG4gIHAubm9kZS5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpXHJcblxyXG4gIC8vIE1ha2Ugc3VyZSBkZWZzIG5vZGUgaXMgYWx3YXlzIGF0IHRoZSB0b3BcclxuICBpZiAodHlwZW9mIHAuaXNSb290ID09PSAnZnVuY3Rpb24nICYmIHAuaXNSb290KCkpIHtcclxuICAgIHAubm9kZS5hcHBlbmRDaGlsZChwLmRlZnMoKS5ub2RlKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXNcclxufVxyXG5cclxuLy8gU2VuZCBnaXZlbiBlbGVtZW50IGFsbCB0aGUgd2F5IHRvIHRoZSBiYWNrXHJcbmV4cG9ydCBmdW5jdGlvbiBiYWNrICgpIHtcclxuICBpZiAodGhpcy5wb3NpdGlvbigpID4gMCkge1xyXG4gICAgdGhpcy5wYXJlbnQoKS5yZW1vdmVFbGVtZW50KHRoaXMpLmFkZCh0aGlzLCAwKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXNcclxufVxyXG5cclxuLy8gSW5zZXJ0cyBhIGdpdmVuIGVsZW1lbnQgYmVmb3JlIHRoZSB0YXJnZXRlZCBlbGVtZW50XHJcbmV4cG9ydCBmdW5jdGlvbiBiZWZvcmUgKGVsZW1lbnQpIHtcclxuICBlbGVtZW50ID0gbWFrZUluc3RhbmNlKGVsZW1lbnQpXHJcbiAgZWxlbWVudC5yZW1vdmUoKVxyXG5cclxuICB2YXIgaSA9IHRoaXMucG9zaXRpb24oKVxyXG5cclxuICB0aGlzLnBhcmVudCgpLmFkZChlbGVtZW50LCBpKVxyXG5cclxuICByZXR1cm4gdGhpc1xyXG59XHJcblxyXG4vLyBJbnNlcnRzIGEgZ2l2ZW4gZWxlbWVudCBhZnRlciB0aGUgdGFyZ2V0ZWQgZWxlbWVudFxyXG5leHBvcnQgZnVuY3Rpb24gYWZ0ZXIgKGVsZW1lbnQpIHtcclxuICBlbGVtZW50ID0gbWFrZUluc3RhbmNlKGVsZW1lbnQpXHJcbiAgZWxlbWVudC5yZW1vdmUoKVxyXG5cclxuICB2YXIgaSA9IHRoaXMucG9zaXRpb24oKVxyXG5cclxuICB0aGlzLnBhcmVudCgpLmFkZChlbGVtZW50LCBpICsgMSlcclxuXHJcbiAgcmV0dXJuIHRoaXNcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGluc2VydEJlZm9yZSAoZWxlbWVudCkge1xyXG4gIGVsZW1lbnQgPSBtYWtlSW5zdGFuY2UoZWxlbWVudClcclxuICBlbGVtZW50LmJlZm9yZSh0aGlzKVxyXG4gIHJldHVybiB0aGlzXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRBZnRlciAoZWxlbWVudCkge1xyXG4gIGVsZW1lbnQgPSBtYWtlSW5zdGFuY2UoZWxlbWVudClcclxuICBlbGVtZW50LmFmdGVyKHRoaXMpXHJcbiAgcmV0dXJuIHRoaXNcclxufVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKCdEb20nLCB7XHJcbiAgc2libGluZ3MsXHJcbiAgcG9zaXRpb24sXHJcbiAgbmV4dCxcclxuICBwcmV2LFxyXG4gIGZvcndhcmQsXHJcbiAgYmFja3dhcmQsXHJcbiAgZnJvbnQsXHJcbiAgYmFjayxcclxuICBiZWZvcmUsXHJcbiAgYWZ0ZXIsXHJcbiAgaW5zZXJ0QmVmb3JlLFxyXG4gIGluc2VydEFmdGVyXHJcbn0pXHJcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyICRmaWx0ZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJykuZmlsdGVyO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbHRlclxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0KCdmaWx0ZXInKSB9LCB7XG4gIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRmaWx0ZXIodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSwgYXJndW1lbnQpIHtcbiAgdmFyIG1ldGhvZCA9IFtdW01FVEhPRF9OQU1FXTtcbiAgcmV0dXJuICFtZXRob2QgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsLG5vLXRocm93LWxpdGVyYWxcbiAgICBtZXRob2QuY2FsbChudWxsLCBhcmd1bWVudCB8fCBmdW5jdGlvbiAoKSB7IHRocm93IDE7IH0sIDEpO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkaW5kZXhPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pbmNsdWRlcycpLmluZGV4T2Y7XG52YXIgc2xvcHB5QXJyYXlNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2xvcHB5LWFycmF5LW1ldGhvZCcpO1xuXG52YXIgbmF0aXZlSW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbnZhciBORUdBVElWRV9aRVJPID0gISFuYXRpdmVJbmRleE9mICYmIDEgLyBbMV0uaW5kZXhPZigxLCAtMCkgPCAwO1xudmFyIFNMT1BQWV9NRVRIT0QgPSBzbG9wcHlBcnJheU1ldGhvZCgnaW5kZXhPZicpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IE5FR0FUSVZFX1pFUk8gfHwgU0xPUFBZX01FVEhPRCB9LCB7XG4gIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICByZXR1cm4gTkVHQVRJVkVfWkVST1xuICAgICAgLy8gY29udmVydCAtMCB0byArMFxuICAgICAgPyBuYXRpdmVJbmRleE9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMFxuICAgICAgOiAkaW5kZXhPZih0aGlzLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCcpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIHNsb3BweUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Nsb3BweS1hcnJheS1tZXRob2QnKTtcblxudmFyIG5hdGl2ZUpvaW4gPSBbXS5qb2luO1xuXG52YXIgRVMzX1NUUklOR1MgPSBJbmRleGVkT2JqZWN0ICE9IE9iamVjdDtcbnZhciBTTE9QUFlfTUVUSE9EID0gc2xvcHB5QXJyYXlNZXRob2QoJ2pvaW4nLCAnLCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmpvaW5gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmpvaW5cbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEVTM19TVFJJTkdTIHx8IFNMT1BQWV9NRVRIT0QgfSwge1xuICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikge1xuICAgIHJldHVybiBuYXRpdmVKb2luLmNhbGwodG9JbmRleGVkT2JqZWN0KHRoaXMpLCBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCA/ICcsJyA6IHNlcGFyYXRvcik7XG4gIH1cbn0pO1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWZ1bmN0aW9uJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbi8vIGBTcGVjaWVzQ29uc3RydWN0b3JgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3BlY2llc2NvbnN0cnVjdG9yXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBkZWZhdWx0Q29uc3RydWN0b3IpIHtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbnN0cnVjdG9yIDogYUZ1bmN0aW9uKFMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmaXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljJyk7XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcmVnZXhwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIGFkdmFuY2VTdHJpbmdJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hZHZhbmNlLXN0cmluZy1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIGNhbGxSZWdFeHBFeGVjID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7XG52YXIgcmVnZXhwRXhlYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZXhlYycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbnZhciBhcnJheVB1c2ggPSBbXS5wdXNoO1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIE1BWF9VSU5UMzIgPSAweEZGRkZGRkZGO1xuXG4vLyBiYWJlbC1taW5pZnkgdHJhbnNwaWxlcyBSZWdFeHAoJ3gnLCAneScpIC0+IC94L3kgYW5kIGl0IGNhdXNlcyBTeW50YXhFcnJvclxudmFyIFNVUFBPUlRTX1kgPSAhZmFpbHMoZnVuY3Rpb24gKCkgeyByZXR1cm4gIVJlZ0V4cChNQVhfVUlOVDMyLCAneScpOyB9KTtcblxuLy8gQEBzcGxpdCBsb2dpY1xuZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMoJ3NwbGl0JywgMiwgZnVuY3Rpb24gKFNQTElULCBuYXRpdmVTcGxpdCwgbWF5YmVDYWxsTmF0aXZlKSB7XG4gIHZhciBpbnRlcm5hbFNwbGl0O1xuICBpZiAoXG4gICAgJ2FiYmMnLnNwbGl0KC8oYikqLylbMV0gPT0gJ2MnIHx8XG4gICAgJ3Rlc3QnLnNwbGl0KC8oPzopLywgLTEpLmxlbmd0aCAhPSA0IHx8XG4gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pLmxlbmd0aCAhPSAyIHx8XG4gICAgJy4nLnNwbGl0KC8oLj8pKC4/KS8pLmxlbmd0aCAhPSA0IHx8XG4gICAgJy4nLnNwbGl0KC8oKSgpLykubGVuZ3RoID4gMSB8fFxuICAgICcnLnNwbGl0KC8uPy8pLmxlbmd0aFxuICApIHtcbiAgICAvLyBiYXNlZCBvbiBlczUtc2hpbSBpbXBsZW1lbnRhdGlvbiwgbmVlZCB0byByZXdvcmsgaXRcbiAgICBpbnRlcm5hbFNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKSk7XG4gICAgICB2YXIgbGltID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9VSU5UMzIgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIGlmIChsaW0gPT09IDApIHJldHVybiBbXTtcbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtzdHJpbmddO1xuICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgIGlmICghaXNSZWdFeHAoc2VwYXJhdG9yKSkge1xuICAgICAgICByZXR1cm4gbmF0aXZlU3BsaXQuY2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltKTtcbiAgICAgIH1cbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIHZhciBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyAneScgOiAnJyk7XG4gICAgICB2YXIgbGFzdExhc3RJbmRleCA9IDA7XG4gICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgdmFyIHNlcGFyYXRvckNvcHkgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgIHZhciBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgICAgd2hpbGUgKG1hdGNoID0gcmVnZXhwRXhlYy5jYWxsKHNlcGFyYXRvckNvcHksIHN0cmluZykpIHtcbiAgICAgICAgbGFzdEluZGV4ID0gc2VwYXJhdG9yQ29weS5sYXN0SW5kZXg7XG4gICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmcubGVuZ3RoKSBhcnJheVB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IGxpbSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcGFyYXRvckNvcHkubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkgc2VwYXJhdG9yQ29weS5sYXN0SW5kZXgrKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgfVxuICAgICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvckNvcHkudGVzdCgnJykpIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgIH0gZWxzZSBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBsaW0gPyBvdXRwdXQuc2xpY2UoMCwgbGltKSA6IG91dHB1dDtcbiAgICB9O1xuICAvLyBDaGFrcmEsIFY4XG4gIH0gZWxzZSBpZiAoJzAnLnNwbGl0KHVuZGVmaW5lZCwgMCkubGVuZ3RoKSB7XG4gICAgaW50ZXJuYWxTcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICByZXR1cm4gc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDAgPyBbXSA6IG5hdGl2ZVNwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbiAgfSBlbHNlIGludGVybmFsU3BsaXQgPSBuYXRpdmVTcGxpdDtcblxuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLnNwbGl0YCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnNwbGl0XG4gICAgZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgdmFyIE8gPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpO1xuICAgICAgdmFyIHNwbGl0dGVyID0gc2VwYXJhdG9yID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlcGFyYXRvcltTUExJVF07XG4gICAgICByZXR1cm4gc3BsaXR0ZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IHNwbGl0dGVyLmNhbGwoc2VwYXJhdG9yLCBPLCBsaW1pdClcbiAgICAgICAgOiBpbnRlcm5hbFNwbGl0LmNhbGwoU3RyaW5nKE8pLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9LFxuICAgIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAc3BsaXRcbiAgICAvL1xuICAgIC8vIE5PVEU6IFRoaXMgY2Fubm90IGJlIHByb3Blcmx5IHBvbHlmaWxsZWQgaW4gZW5naW5lcyB0aGF0IGRvbid0IHN1cHBvcnRcbiAgICAvLyB0aGUgJ3knIGZsYWcuXG4gICAgZnVuY3Rpb24gKHJlZ2V4cCwgbGltaXQpIHtcbiAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUoaW50ZXJuYWxTcGxpdCwgcmVnZXhwLCB0aGlzLCBsaW1pdCwgaW50ZXJuYWxTcGxpdCAhPT0gbmF0aXZlU3BsaXQpO1xuICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuXG4gICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgICB2YXIgQyA9IHNwZWNpZXNDb25zdHJ1Y3RvcihyeCwgUmVnRXhwKTtcblxuICAgICAgdmFyIHVuaWNvZGVNYXRjaGluZyA9IHJ4LnVuaWNvZGU7XG4gICAgICB2YXIgZmxhZ3MgPSAocnguaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocngubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyeC51bmljb2RlID8gJ3UnIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChTVVBQT1JUU19ZID8gJ3knIDogJ2cnKTtcblxuICAgICAgLy8gXig/ICsgcnggKyApIGlzIG5lZWRlZCwgaW4gY29tYmluYXRpb24gd2l0aCBzb21lIFMgc2xpY2luZywgdG9cbiAgICAgIC8vIHNpbXVsYXRlIHRoZSAneScgZmxhZy5cbiAgICAgIHZhciBzcGxpdHRlciA9IG5ldyBDKFNVUFBPUlRTX1kgPyByeCA6ICdeKD86JyArIHJ4LnNvdXJjZSArICcpJywgZmxhZ3MpO1xuICAgICAgdmFyIGxpbSA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyBNQVhfVUlOVDMyIDogbGltaXQgPj4+IDA7XG4gICAgICBpZiAobGltID09PSAwKSByZXR1cm4gW107XG4gICAgICBpZiAoUy5sZW5ndGggPT09IDApIHJldHVybiBjYWxsUmVnRXhwRXhlYyhzcGxpdHRlciwgUykgPT09IG51bGwgPyBbU10gOiBbXTtcbiAgICAgIHZhciBwID0gMDtcbiAgICAgIHZhciBxID0gMDtcbiAgICAgIHZhciBBID0gW107XG4gICAgICB3aGlsZSAocSA8IFMubGVuZ3RoKSB7XG4gICAgICAgIHNwbGl0dGVyLmxhc3RJbmRleCA9IFNVUFBPUlRTX1kgPyBxIDogMDtcbiAgICAgICAgdmFyIHogPSBjYWxsUmVnRXhwRXhlYyhzcGxpdHRlciwgU1VQUE9SVFNfWSA/IFMgOiBTLnNsaWNlKHEpKTtcbiAgICAgICAgdmFyIGU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB6ID09PSBudWxsIHx8XG4gICAgICAgICAgKGUgPSBtaW4odG9MZW5ndGgoc3BsaXR0ZXIubGFzdEluZGV4ICsgKFNVUFBPUlRTX1kgPyAwIDogcSkpLCBTLmxlbmd0aCkpID09PSBwXG4gICAgICAgICkge1xuICAgICAgICAgIHEgPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgcSwgdW5pY29kZU1hdGNoaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBBLnB1c2goUy5zbGljZShwLCBxKSk7XG4gICAgICAgICAgaWYgKEEubGVuZ3RoID09PSBsaW0pIHJldHVybiBBO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHoubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBBLnB1c2goeltpXSk7XG4gICAgICAgICAgICBpZiAoQS5sZW5ndGggPT09IGxpbSkgcmV0dXJuIEE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHEgPSBwID0gZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgQS5wdXNoKFMuc2xpY2UocCkpO1xuICAgICAgcmV0dXJuIEE7XG4gICAgfVxuICBdO1xufSwgIVNVUFBPUlRTX1kpO1xuIiwiLy8gUGFyc2UgdW5pdCB2YWx1ZVxyXG5leHBvcnQgY29uc3QgbnVtYmVyQW5kVW5pdCA9IC9eKFsrLV0/KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspKGVbKy1dP1xcZCspPykoW2EteiVdKikkL2lcclxuXHJcbi8vIFBhcnNlIGhleCB2YWx1ZVxyXG5leHBvcnQgY29uc3QgaGV4ID0gL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaVxyXG5cclxuLy8gUGFyc2UgcmdiIHZhbHVlXHJcbmV4cG9ydCBjb25zdCByZ2IgPSAvcmdiXFwoKFxcZCspLChcXGQrKSwoXFxkKylcXCkvXHJcblxyXG4vLyBQYXJzZSByZWZlcmVuY2UgaWRcclxuZXhwb3J0IGNvbnN0IHJlZmVyZW5jZSA9IC8oI1thLXowLTlcXC1fXSspL2lcclxuXHJcbi8vIHNwbGl0cyBhIHRyYW5zZm9ybWF0aW9uIGNoYWluXHJcbmV4cG9ydCBjb25zdCB0cmFuc2Zvcm1zID0gL1xcKVxccyosP1xccyovXHJcblxyXG4vLyBXaGl0ZXNwYWNlXHJcbmV4cG9ydCBjb25zdCB3aGl0ZXNwYWNlID0gL1xccy9nXHJcblxyXG4vLyBUZXN0IGhleCB2YWx1ZVxyXG5leHBvcnQgY29uc3QgaXNIZXggPSAvXiNbYS1mMC05XXszLDZ9JC9pXHJcblxyXG4vLyBUZXN0IHJnYiB2YWx1ZVxyXG5leHBvcnQgY29uc3QgaXNSZ2IgPSAvXnJnYlxcKC9cclxuXHJcbi8vIFRlc3QgY3NzIGRlY2xhcmF0aW9uXHJcbmV4cG9ydCBjb25zdCBpc0NzcyA9IC9bXjpdKzpbXjtdKzs/L1xyXG5cclxuLy8gVGVzdCBmb3IgYmxhbmsgc3RyaW5nXHJcbmV4cG9ydCBjb25zdCBpc0JsYW5rID0gL14oXFxzKyk/JC9cclxuXHJcbi8vIFRlc3QgZm9yIG51bWVyaWMgc3RyaW5nXHJcbmV4cG9ydCBjb25zdCBpc051bWJlciA9IC9eWystXT8oXFxkKyhcXC5cXGQqKT98XFwuXFxkKykoZVsrLV0/XFxkKyk/JC9pXHJcblxyXG4vLyBUZXN0IGZvciBwZXJjZW50IHZhbHVlXHJcbmV4cG9ydCBjb25zdCBpc1BlcmNlbnQgPSAvXi0/W1xcZC5dKyUkL1xyXG5cclxuLy8gVGVzdCBmb3IgaW1hZ2UgdXJsXHJcbmV4cG9ydCBjb25zdCBpc0ltYWdlID0gL1xcLihqcGd8anBlZ3xwbmd8Z2lmfHN2ZykoXFw/W149XSsuKik/L2lcclxuXHJcbi8vIHNwbGl0IGF0IHdoaXRlc3BhY2UgYW5kIGNvbW1hXHJcbmV4cG9ydCBjb25zdCBkZWxpbWl0ZXIgPSAvW1xccyxdKy9cclxuXHJcbi8vIFRoZSBmb2xsb3dpbmcgcmVnZXggYXJlIHVzZWQgdG8gcGFyc2UgdGhlIGQgYXR0cmlidXRlIG9mIGEgcGF0aFxyXG5cclxuLy8gTWF0Y2hlcyBhbGwgaHlwaGVucyB3aGljaCBhcmUgbm90IGFmdGVyIGFuIGV4cG9uZW50XHJcbmV4cG9ydCBjb25zdCBoeXBoZW4gPSAvKFteZV0pLS9naVxyXG5cclxuLy8gUmVwbGFjZXMgYW5kIHRlc3RzIGZvciBhbGwgcGF0aCBsZXR0ZXJzXHJcbmV4cG9ydCBjb25zdCBwYXRoTGV0dGVycyA9IC9bTUxIVkNTUVRBWl0vZ2lcclxuXHJcbi8vIHllcyB3ZSBuZWVkIHRoaXMgb25lLCB0b29cclxuZXhwb3J0IGNvbnN0IGlzUGF0aExldHRlciA9IC9bTUxIVkNTUVRBWl0vaVxyXG5cclxuLy8gbWF0Y2hlcyAwLjE1NC4yMy40NVxyXG5leHBvcnQgY29uc3QgbnVtYmVyc1dpdGhEb3RzID0gLygoXFxkP1xcLlxcZCsoPzplWystXT9cXGQrKT8pKCg/OlxcLlxcZCsoPzplWystXT9cXGQrKT8pKykpKy9naVxyXG5cclxuLy8gbWF0Y2hlcyAuXHJcbmV4cG9ydCBjb25zdCBkb3RzID0gL1xcLi9nXHJcbiIsImltcG9ydCB7IGRlbGltaXRlciB9IGZyb20gJy4uL2NvcmUvcmVnZXguanMnXHJcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uLy4uL3V0aWxzL21ldGhvZHMuanMnXHJcblxyXG4vLyBSZXR1cm4gYXJyYXkgb2YgY2xhc3NlcyBvbiB0aGUgbm9kZVxyXG5leHBvcnQgZnVuY3Rpb24gY2xhc3NlcyAoKSB7XHJcbiAgdmFyIGF0dHIgPSB0aGlzLmF0dHIoJ2NsYXNzJylcclxuICByZXR1cm4gYXR0ciA9PSBudWxsID8gW10gOiBhdHRyLnRyaW0oKS5zcGxpdChkZWxpbWl0ZXIpXHJcbn1cclxuXHJcbi8vIFJldHVybiB0cnVlIGlmIGNsYXNzIGV4aXN0cyBvbiB0aGUgbm9kZSwgZmFsc2Ugb3RoZXJ3aXNlXHJcbmV4cG9ydCBmdW5jdGlvbiBoYXNDbGFzcyAobmFtZSkge1xyXG4gIHJldHVybiB0aGlzLmNsYXNzZXMoKS5pbmRleE9mKG5hbWUpICE9PSAtMVxyXG59XHJcblxyXG4vLyBBZGQgY2xhc3MgdG8gdGhlIG5vZGVcclxuZXhwb3J0IGZ1bmN0aW9uIGFkZENsYXNzIChuYW1lKSB7XHJcbiAgaWYgKCF0aGlzLmhhc0NsYXNzKG5hbWUpKSB7XHJcbiAgICB2YXIgYXJyYXkgPSB0aGlzLmNsYXNzZXMoKVxyXG4gICAgYXJyYXkucHVzaChuYW1lKVxyXG4gICAgdGhpcy5hdHRyKCdjbGFzcycsIGFycmF5LmpvaW4oJyAnKSlcclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzXHJcbn1cclxuXHJcbi8vIFJlbW92ZSBjbGFzcyBmcm9tIHRoZSBub2RlXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDbGFzcyAobmFtZSkge1xyXG4gIGlmICh0aGlzLmhhc0NsYXNzKG5hbWUpKSB7XHJcbiAgICB0aGlzLmF0dHIoJ2NsYXNzJywgdGhpcy5jbGFzc2VzKCkuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgIHJldHVybiBjICE9PSBuYW1lXHJcbiAgICB9KS5qb2luKCcgJykpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpc1xyXG59XHJcblxyXG4vLyBUb2dnbGUgdGhlIHByZXNlbmNlIG9mIGEgY2xhc3Mgb24gdGhlIG5vZGVcclxuZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZUNsYXNzIChuYW1lKSB7XHJcbiAgcmV0dXJuIHRoaXMuaGFzQ2xhc3MobmFtZSkgPyB0aGlzLnJlbW92ZUNsYXNzKG5hbWUpIDogdGhpcy5hZGRDbGFzcyhuYW1lKVxyXG59XHJcblxyXG5yZWdpc3Rlck1ldGhvZHMoJ0RvbScsIHtcclxuICBjbGFzc2VzLCBoYXNDbGFzcywgYWRkQ2xhc3MsIHJlbW92ZUNsYXNzLCB0b2dnbGVDbGFzc1xyXG59KVxyXG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGZvckVhY2ggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJykuZm9yRWFjaDtcbnZhciBzbG9wcHlBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zbG9wcHktYXJyYXktbWV0aG9kJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxubW9kdWxlLmV4cG9ydHMgPSBzbG9wcHlBcnJheU1ldGhvZCgnZm9yRWFjaCcpID8gZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICByZXR1cm4gJGZvckVhY2godGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xufSA6IFtdLmZvckVhY2g7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWZvci1lYWNoJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogW10uZm9yRWFjaCAhPSBmb3JFYWNoIH0sIHtcbiAgZm9yRWFjaDogZm9yRWFjaFxufSk7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIERPTUl0ZXJhYmxlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb20taXRlcmFibGVzJyk7XG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1mb3ItZWFjaCcpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcblxuZm9yICh2YXIgQ09MTEVDVElPTl9OQU1FIGluIERPTUl0ZXJhYmxlcykge1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtDT0xMRUNUSU9OX05BTUVdO1xuICB2YXIgQ29sbGVjdGlvblByb3RvdHlwZSA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZSAmJiBDb2xsZWN0aW9uUHJvdG90eXBlLmZvckVhY2ggIT09IGZvckVhY2gpIHRyeSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsICdmb3JFYWNoJywgZm9yRWFjaCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgQ29sbGVjdGlvblByb3RvdHlwZS5mb3JFYWNoID0gZm9yRWFjaDtcbiAgfVxufVxuIiwiaW1wb3J0IHsgY2FtZWxDYXNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvdXRpbHMuanMnXHJcbmltcG9ydCB7IGlzQmxhbmsgfSBmcm9tICcuLi9jb3JlL3JlZ2V4LmpzJ1xyXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi8uLi91dGlscy9tZXRob2RzLmpzJ1xyXG5cclxuLy8gRHluYW1pYyBzdHlsZSBnZW5lcmF0b3JcclxuZXhwb3J0IGZ1bmN0aW9uIGNzcyAoc3R5bGUsIHZhbCkge1xyXG4gIGNvbnN0IHJldCA9IHt9XHJcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgIC8vIGdldCBmdWxsIHN0eWxlIGFzIG9iamVjdFxyXG4gICAgdGhpcy5ub2RlLnN0eWxlLmNzc1RleHQuc3BsaXQoL1xccyo7XFxzKi8pXHJcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgcmV0dXJuICEhZWwubGVuZ3RoXHJcbiAgICAgIH0pXHJcbiAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIGNvbnN0IHQgPSBlbC5zcGxpdCgvXFxzKjpcXHMqLylcclxuICAgICAgICByZXRbdFswXV0gPSB0WzFdXHJcbiAgICAgIH0pXHJcbiAgICByZXR1cm4gcmV0XHJcbiAgfVxyXG5cclxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcclxuICAgIC8vIGdldCBzdHlsZSBwcm9wZXJ0aWVzIGluIHRoZSBhcnJheVxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUpKSB7XHJcbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBzdHlsZSkge1xyXG4gICAgICAgIGNvbnN0IGNhc2VkID0gY2FtZWxDYXNlKG5hbWUpXHJcbiAgICAgICAgcmV0W2Nhc2VkXSA9IHRoaXMubm9kZS5zdHlsZVtjYXNlZF1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmV0XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZ2V0IHN0eWxlIGZvciBwcm9wZXJ0eVxyXG4gICAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubm9kZS5zdHlsZVtjYW1lbENhc2Uoc3R5bGUpXVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHNldCBzdHlsZXMgaW4gb2JqZWN0XHJcbiAgICBpZiAodHlwZW9mIHN0eWxlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc3R5bGUpIHtcclxuICAgICAgICAvLyBzZXQgZW1wdHkgc3RyaW5nIGlmIG51bGwvdW5kZWZpbmVkLycnIHdhcyBnaXZlblxyXG4gICAgICAgIHRoaXMubm9kZS5zdHlsZVtjYW1lbENhc2UobmFtZSldXHJcbiAgICAgICAgICA9IChzdHlsZVtuYW1lXSA9PSBudWxsIHx8IGlzQmxhbmsudGVzdChzdHlsZVtuYW1lXSkpID8gJycgOiBzdHlsZVtuYW1lXVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBzZXQgc3R5bGUgZm9yIHByb3BlcnR5XHJcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcclxuICAgIHRoaXMubm9kZS5zdHlsZVtjYW1lbENhc2Uoc3R5bGUpXVxyXG4gICAgICA9ICh2YWwgPT0gbnVsbCB8fCBpc0JsYW5rLnRlc3QodmFsKSkgPyAnJyA6IHZhbFxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXNcclxufVxyXG5cclxuLy8gU2hvdyBlbGVtZW50XHJcbmV4cG9ydCBmdW5jdGlvbiBzaG93ICgpIHtcclxuICByZXR1cm4gdGhpcy5jc3MoJ2Rpc3BsYXknLCAnJylcclxufVxyXG5cclxuLy8gSGlkZSBlbGVtZW50XHJcbmV4cG9ydCBmdW5jdGlvbiBoaWRlICgpIHtcclxuICByZXR1cm4gdGhpcy5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpXHJcbn1cclxuXHJcbi8vIElzIGVsZW1lbnQgdmlzaWJsZT9cclxuZXhwb3J0IGZ1bmN0aW9uIHZpc2libGUgKCkge1xyXG4gIHJldHVybiB0aGlzLmNzcygnZGlzcGxheScpICE9PSAnbm9uZSdcclxufVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKCdEb20nLCB7XHJcbiAgY3NzLCBzaG93LCBoaWRlLCB2aXNpYmxlXHJcbn0pXHJcbiIsImltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uLy4uL3V0aWxzL21ldGhvZHMuanMnXHJcblxyXG4vLyBTdG9yZSBkYXRhIHZhbHVlcyBvbiBzdmcgbm9kZXNcclxuZXhwb3J0IGZ1bmN0aW9uIGRhdGEgKGEsIHYsIHIpIHtcclxuICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XHJcbiAgICBmb3IgKHYgaW4gYSkge1xyXG4gICAgICB0aGlzLmRhdGEodiwgYVt2XSlcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLmF0dHIoJ2RhdGEtJyArIGEpKVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdkYXRhLScgKyBhKVxyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLmF0dHIoJ2RhdGEtJyArIGEsXHJcbiAgICAgIHYgPT09IG51bGwgPyBudWxsXHJcbiAgICAgIDogciA9PT0gdHJ1ZSB8fCB0eXBlb2YgdiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHYgPT09ICdudW1iZXInID8gdlxyXG4gICAgICA6IEpTT04uc3RyaW5naWZ5KHYpXHJcbiAgICApXHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpc1xyXG59XHJcblxyXG5yZWdpc3Rlck1ldGhvZHMoJ0RvbScsIHsgZGF0YSB9KVxyXG4iLCJpbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi8uLi91dGlscy9tZXRob2RzLmpzJ1xyXG5cclxuLy8gUmVtZW1iZXIgYXJiaXRyYXJ5IGRhdGFcclxuZXhwb3J0IGZ1bmN0aW9uIHJlbWVtYmVyIChrLCB2KSB7XHJcbiAgLy8gcmVtZW1iZXIgZXZlcnkgaXRlbSBpbiBhbiBvYmplY3QgaW5kaXZpZHVhbGx5XHJcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSB7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gaykge1xyXG4gICAgICB0aGlzLnJlbWVtYmVyKGtleSwga1trZXldKVxyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgLy8gcmV0cmlldmUgbWVtb3J5XHJcbiAgICByZXR1cm4gdGhpcy5tZW1vcnkoKVtrXVxyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBzdG9yZSBtZW1vcnlcclxuICAgIHRoaXMubWVtb3J5KClba10gPSB2XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpc1xyXG59XHJcblxyXG4vLyBFcmFzZSBhIGdpdmVuIG1lbW9yeVxyXG5leHBvcnQgZnVuY3Rpb24gZm9yZ2V0ICgpIHtcclxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgdGhpcy5fbWVtb3J5ID0ge31cclxuICB9IGVsc2Uge1xyXG4gICAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICBkZWxldGUgdGhpcy5tZW1vcnkoKVthcmd1bWVudHNbaV1dXHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0aGlzXHJcbn1cclxuXHJcbi8vIFRoaXMgdHJpZ2dlcnMgY3JlYXRpb24gb2YgYSBuZXcgaGlkZGVuIGNsYXNzIHdoaWNoIGlzIG5vdCBwZXJmb3JtYW50XHJcbi8vIEhvd2V2ZXIsIHRoaXMgZnVuY3Rpb24gaXMgbm90IHJhcmVseSB1c2VkIHNvIGl0IHdpbGwgbm90IGhhcHBlbiBmcmVxdWVudGx5XHJcbi8vIFJldHVybiBsb2NhbCBtZW1vcnkgb2JqZWN0XHJcbmV4cG9ydCBmdW5jdGlvbiBtZW1vcnkgKCkge1xyXG4gIHJldHVybiAodGhpcy5fbWVtb3J5ID0gdGhpcy5fbWVtb3J5IHx8IHt9KVxyXG59XHJcblxyXG5yZWdpc3Rlck1ldGhvZHMoJ0RvbScsIHsgcmVtZW1iZXIsIGZvcmdldCwgbWVtb3J5IH0pXHJcbiIsInZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1mdW5jdGlvbicpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIEluZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IHJlZHVjZSwgcmVkdWNlUmlnaHQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChJU19SSUdIVCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c0xlbmd0aCwgbWVtbykge1xuICAgIGFGdW5jdGlvbihjYWxsYmFja2ZuKTtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoYXQpO1xuICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdChPKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IElTX1JJR0hUID8gbGVuZ3RoIC0gMSA6IDA7XG4gICAgdmFyIGkgPSBJU19SSUdIVCA/IC0xIDogMTtcbiAgICBpZiAoYXJndW1lbnRzTGVuZ3RoIDwgMikgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgICAgIG1lbW8gPSBzZWxmW2luZGV4XTtcbiAgICAgICAgaW5kZXggKz0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpbmRleCArPSBpO1xuICAgICAgaWYgKElTX1JJR0hUID8gaW5kZXggPCAwIDogbGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKDtJU19SSUdIVCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSkgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICAgIG1lbW8gPSBjYWxsYmFja2ZuKG1lbW8sIHNlbGZbaW5kZXhdLCBpbmRleCwgTyk7XG4gICAgfVxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZVxuICBsZWZ0OiBjcmVhdGVNZXRob2QoZmFsc2UpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZXJpZ2h0XG4gIHJpZ2h0OiBjcmVhdGVNZXRob2QodHJ1ZSlcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkcmVkdWNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXJlZHVjZScpLmxlZnQ7XG52YXIgc2xvcHB5QXJyYXlNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2xvcHB5LWFycmF5LW1ldGhvZCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnJlZHVjZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBzbG9wcHlBcnJheU1ldGhvZCgncmVkdWNlJykgfSwge1xuICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbiIsImltcG9ydCB7IGRlbGltaXRlciB9IGZyb20gJy4vcmVnZXguanMnXHJcbmltcG9ydCB7IG1ha2VJbnN0YW5jZSB9IGZyb20gJy4uLy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuLi8uLi91dGlscy93aW5kb3cuanMnXHJcblxyXG5sZXQgbGlzdGVuZXJJZCA9IDBcclxuY29uc3Qgd2luZG93RXZlbnRzID0ge31cclxuXHJcbmZ1bmN0aW9uIGdldEV2ZW50cyAoaW5zdGFuY2UpIHtcclxuICBsZXQgbiA9IGluc3RhbmNlLmdldEV2ZW50SG9sZGVyKClcclxuXHJcbiAgLy8gV2UgZG9udCB3YW50IHRvIHNhdmUgZXZlbnRzIGluIGdsb2JhbCBzcGFjZVxyXG4gIGlmIChuID09PSBnbG9iYWxzLndpbmRvdykgbiA9IHdpbmRvd0V2ZW50c1xyXG4gIGlmICghbi5ldmVudHMpIG4uZXZlbnRzID0ge31cclxuICByZXR1cm4gbi5ldmVudHNcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQgKGluc3RhbmNlKSB7XHJcbiAgcmV0dXJuIGluc3RhbmNlLmdldEV2ZW50VGFyZ2V0KClcclxufVxyXG5cclxuZnVuY3Rpb24gY2xlYXJFdmVudHMgKGluc3RhbmNlKSB7XHJcbiAgY29uc3QgbiA9IGluc3RhbmNlLmdldEV2ZW50SG9sZGVyKClcclxuICBpZiAobi5ldmVudHMpIG4uZXZlbnRzID0ge31cclxufVxyXG5cclxuLy8gQWRkIGV2ZW50IGJpbmRlciBpbiB0aGUgU1ZHIG5hbWVzcGFjZVxyXG5leHBvcnQgZnVuY3Rpb24gb24gKG5vZGUsIGV2ZW50cywgbGlzdGVuZXIsIGJpbmRpbmcsIG9wdGlvbnMpIHtcclxuICB2YXIgbCA9IGxpc3RlbmVyLmJpbmQoYmluZGluZyB8fCBub2RlKVxyXG4gIHZhciBpbnN0YW5jZSA9IG1ha2VJbnN0YW5jZShub2RlKVxyXG4gIHZhciBiYWcgPSBnZXRFdmVudHMoaW5zdGFuY2UpXHJcbiAgdmFyIG4gPSBnZXRFdmVudFRhcmdldChpbnN0YW5jZSlcclxuXHJcbiAgLy8gZXZlbnRzIGNhbiBiZSBhbiBhcnJheSBvZiBldmVudHMgb3IgYSBzdHJpbmcgb2YgZXZlbnRzXHJcbiAgZXZlbnRzID0gQXJyYXkuaXNBcnJheShldmVudHMpID8gZXZlbnRzIDogZXZlbnRzLnNwbGl0KGRlbGltaXRlcilcclxuXHJcbiAgLy8gYWRkIGlkIHRvIGxpc3RlbmVyXHJcbiAgaWYgKCFsaXN0ZW5lci5fc3ZnanNMaXN0ZW5lcklkKSB7XHJcbiAgICBsaXN0ZW5lci5fc3ZnanNMaXN0ZW5lcklkID0gKytsaXN0ZW5lcklkXHJcbiAgfVxyXG5cclxuICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIHZhciBldiA9IGV2ZW50LnNwbGl0KCcuJylbMF1cclxuICAgIHZhciBucyA9IGV2ZW50LnNwbGl0KCcuJylbMV0gfHwgJyonXHJcblxyXG4gICAgLy8gZW5zdXJlIHZhbGlkIG9iamVjdFxyXG4gICAgYmFnW2V2XSA9IGJhZ1tldl0gfHwge31cclxuICAgIGJhZ1tldl1bbnNdID0gYmFnW2V2XVtuc10gfHwge31cclxuXHJcbiAgICAvLyByZWZlcmVuY2UgbGlzdGVuZXJcclxuICAgIGJhZ1tldl1bbnNdW2xpc3RlbmVyLl9zdmdqc0xpc3RlbmVySWRdID0gbFxyXG5cclxuICAgIC8vIGFkZCBsaXN0ZW5lclxyXG4gICAgbi5hZGRFdmVudExpc3RlbmVyKGV2LCBsLCBvcHRpb25zIHx8IGZhbHNlKVxyXG4gIH0pXHJcbn1cclxuXHJcbi8vIEFkZCBldmVudCB1bmJpbmRlciBpbiB0aGUgU1ZHIG5hbWVzcGFjZVxyXG5leHBvcnQgZnVuY3Rpb24gb2ZmIChub2RlLCBldmVudHMsIGxpc3RlbmVyLCBvcHRpb25zKSB7XHJcbiAgdmFyIGluc3RhbmNlID0gbWFrZUluc3RhbmNlKG5vZGUpXHJcbiAgdmFyIGJhZyA9IGdldEV2ZW50cyhpbnN0YW5jZSlcclxuICB2YXIgbiA9IGdldEV2ZW50VGFyZ2V0KGluc3RhbmNlKVxyXG5cclxuICAvLyBsaXN0ZW5lciBjYW4gYmUgYSBmdW5jdGlvbiBvciBhIG51bWJlclxyXG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIGxpc3RlbmVyID0gbGlzdGVuZXIuX3N2Z2pzTGlzdGVuZXJJZFxyXG4gICAgaWYgKCFsaXN0ZW5lcikgcmV0dXJuXHJcbiAgfVxyXG5cclxuICAvLyBldmVudHMgY2FuIGJlIGFuIGFycmF5IG9mIGV2ZW50cyBvciBhIHN0cmluZyBvciB1bmRlZmluZWRcclxuICBldmVudHMgPSBBcnJheS5pc0FycmF5KGV2ZW50cykgPyBldmVudHMgOiAoZXZlbnRzIHx8ICcnKS5zcGxpdChkZWxpbWl0ZXIpXHJcblxyXG4gIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgdmFyIGV2ID0gZXZlbnQgJiYgZXZlbnQuc3BsaXQoJy4nKVswXVxyXG4gICAgdmFyIG5zID0gZXZlbnQgJiYgZXZlbnQuc3BsaXQoJy4nKVsxXVxyXG4gICAgdmFyIG5hbWVzcGFjZSwgbFxyXG5cclxuICAgIGlmIChsaXN0ZW5lcikge1xyXG4gICAgICAvLyByZW1vdmUgbGlzdGVuZXIgcmVmZXJlbmNlXHJcbiAgICAgIGlmIChiYWdbZXZdICYmIGJhZ1tldl1bbnMgfHwgJyonXSkge1xyXG4gICAgICAgIC8vIHJlbW92ZUxpc3RlbmVyXHJcbiAgICAgICAgbi5yZW1vdmVFdmVudExpc3RlbmVyKGV2LCBiYWdbZXZdW25zIHx8ICcqJ11bbGlzdGVuZXJdLCBvcHRpb25zIHx8IGZhbHNlKVxyXG5cclxuICAgICAgICBkZWxldGUgYmFnW2V2XVtucyB8fCAnKiddW2xpc3RlbmVyXVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGV2ICYmIG5zKSB7XHJcbiAgICAgIC8vIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciBhIG5hbWVzcGFjZWQgZXZlbnRcclxuICAgICAgaWYgKGJhZ1tldl0gJiYgYmFnW2V2XVtuc10pIHtcclxuICAgICAgICBmb3IgKGwgaW4gYmFnW2V2XVtuc10pIHtcclxuICAgICAgICAgIG9mZihuLCBbIGV2LCBucyBdLmpvaW4oJy4nKSwgbClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRlbGV0ZSBiYWdbZXZdW25zXVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG5zKSB7XHJcbiAgICAgIC8vIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciBhIHNwZWNpZmljIG5hbWVzcGFjZVxyXG4gICAgICBmb3IgKGV2ZW50IGluIGJhZykge1xyXG4gICAgICAgIGZvciAobmFtZXNwYWNlIGluIGJhZ1tldmVudF0pIHtcclxuICAgICAgICAgIGlmIChucyA9PT0gbmFtZXNwYWNlKSB7XHJcbiAgICAgICAgICAgIG9mZihuLCBbIGV2ZW50LCBucyBdLmpvaW4oJy4nKSlcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoZXYpIHtcclxuICAgICAgLy8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBldmVudFxyXG4gICAgICBpZiAoYmFnW2V2XSkge1xyXG4gICAgICAgIGZvciAobmFtZXNwYWNlIGluIGJhZ1tldl0pIHtcclxuICAgICAgICAgIG9mZihuLCBbIGV2LCBuYW1lc3BhY2UgXS5qb2luKCcuJykpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkZWxldGUgYmFnW2V2XVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyByZW1vdmUgYWxsIGxpc3RlbmVycyBvbiBhIGdpdmVuIG5vZGVcclxuICAgICAgZm9yIChldmVudCBpbiBiYWcpIHtcclxuICAgICAgICBvZmYobiwgZXZlbnQpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNsZWFyRXZlbnRzKGluc3RhbmNlKVxyXG4gICAgfVxyXG4gIH0pXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXNwYXRjaCAobm9kZSwgZXZlbnQsIGRhdGEpIHtcclxuICB2YXIgbiA9IGdldEV2ZW50VGFyZ2V0KG5vZGUpXHJcblxyXG4gIC8vIERpc3BhdGNoIGV2ZW50XHJcbiAgaWYgKGV2ZW50IGluc3RhbmNlb2YgZ2xvYmFscy53aW5kb3cuRXZlbnQpIHtcclxuICAgIG4uZGlzcGF0Y2hFdmVudChldmVudClcclxuICB9IGVsc2Uge1xyXG4gICAgZXZlbnQgPSBuZXcgZ2xvYmFscy53aW5kb3cuQ3VzdG9tRXZlbnQoZXZlbnQsIHsgZGV0YWlsOiBkYXRhLCBjYW5jZWxhYmxlOiB0cnVlIH0pXHJcbiAgICBuLmRpc3BhdGNoRXZlbnQoZXZlbnQpXHJcbiAgfVxyXG4gIHJldHVybiBldmVudFxyXG59XHJcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eScpO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBWOF9WRVJTSU9OID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Y4LXZlcnNpb24nKTtcblxudmFyIElTX0NPTkNBVF9TUFJFQURBQkxFID0gd2VsbEtub3duU3ltYm9sKCdpc0NvbmNhdFNwcmVhZGFibGUnKTtcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gMHgxRkZGRkZGRkZGRkZGRjtcbnZhciBNQVhJTVVNX0FMTE9XRURfSU5ERVhfRVhDRUVERUQgPSAnTWF4aW11bSBhbGxvd2VkIGluZGV4IGV4Y2VlZGVkJztcblxuLy8gV2UgY2FuJ3QgdXNlIHRoaXMgZmVhdHVyZSBkZXRlY3Rpb24gaW4gVjggc2luY2UgaXQgY2F1c2VzXG4vLyBkZW9wdGltaXphdGlvbiBhbmQgc2VyaW91cyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzY3OVxudmFyIElTX0NPTkNBVF9TUFJFQURBQkxFX1NVUFBPUlQgPSBWOF9WRVJTSU9OID49IDUxIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnJheSA9IFtdO1xuICBhcnJheVtJU19DT05DQVRfU1BSRUFEQUJMRV0gPSBmYWxzZTtcbiAgcmV0dXJuIGFycmF5LmNvbmNhdCgpWzBdICE9PSBhcnJheTtcbn0pO1xuXG52YXIgU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnY29uY2F0Jyk7XG5cbnZhciBpc0NvbmNhdFNwcmVhZGFibGUgPSBmdW5jdGlvbiAoTykge1xuICBpZiAoIWlzT2JqZWN0KE8pKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzcHJlYWRhYmxlID0gT1tJU19DT05DQVRfU1BSRUFEQUJMRV07XG4gIHJldHVybiBzcHJlYWRhYmxlICE9PSB1bmRlZmluZWQgPyAhIXNwcmVhZGFibGUgOiBpc0FycmF5KE8pO1xufTtcblxudmFyIEZPUkNFRCA9ICFJU19DT05DQVRfU1BSRUFEQUJMRV9TVVBQT1JUIHx8ICFTUEVDSUVTX1NVUFBPUlQ7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuY29uY2F0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5jb25jYXRcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBpc0NvbmNhdFNwcmVhZGFibGUgYW5kIEBAc3BlY2llc1xuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgY29uY2F0OiBmdW5jdGlvbiBjb25jYXQoYXJnKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlKE8sIDApO1xuICAgIHZhciBuID0gMDtcbiAgICB2YXIgaSwgaywgbGVuZ3RoLCBsZW4sIEU7XG4gICAgZm9yIChpID0gLTEsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgRSA9IGkgPT09IC0xID8gTyA6IGFyZ3VtZW50c1tpXTtcbiAgICAgIGlmIChpc0NvbmNhdFNwcmVhZGFibGUoRSkpIHtcbiAgICAgICAgbGVuID0gdG9MZW5ndGgoRS5sZW5ndGgpO1xuICAgICAgICBpZiAobiArIGxlbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHRocm93IFR5cGVFcnJvcihNQVhJTVVNX0FMTE9XRURfSU5ERVhfRVhDRUVERUQpO1xuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbGVuOyBrKyssIG4rKykgaWYgKGsgaW4gRSkgY3JlYXRlUHJvcGVydHkoQSwgbiwgRVtrXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobiA+PSBNQVhfU0FGRV9JTlRFR0VSKSB0aHJvdyBUeXBlRXJyb3IoTUFYSU1VTV9BTExPV0VEX0lOREVYX0VYQ0VFREVEKTtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkoQSwgbisrLCBFKTtcbiAgICAgIH1cbiAgICB9XG4gICAgQS5sZW5ndGggPSBuO1xuICAgIHJldHVybiBBO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyICRtYXAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJykubWFwO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5tYXBgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0KCdtYXAnKSB9LCB7XG4gIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRtYXAodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbiIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xuXG52YXIgRGF0ZVByb3RvdHlwZSA9IERhdGUucHJvdG90eXBlO1xudmFyIElOVkFMSURfREFURSA9ICdJbnZhbGlkIERhdGUnO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgbmF0aXZlRGF0ZVRvU3RyaW5nID0gRGF0ZVByb3RvdHlwZVtUT19TVFJJTkddO1xudmFyIGdldFRpbWUgPSBEYXRlUHJvdG90eXBlLmdldFRpbWU7XG5cbi8vIGBEYXRlLnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1kYXRlLnByb3RvdHlwZS50b3N0cmluZ1xuaWYgKG5ldyBEYXRlKE5hTikgKyAnJyAhPSBJTlZBTElEX0RBVEUpIHtcbiAgcmVkZWZpbmUoRGF0ZVByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgdmFsdWUgPSBnZXRUaW1lLmNhbGwodGhpcyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyBuYXRpdmVEYXRlVG9TdHJpbmcuY2FsbCh0aGlzKSA6IElOVkFMSURfREFURTtcbiAgfSk7XG59XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHRyaW0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLXRyaW0nKS50cmltO1xudmFyIHdoaXRlc3BhY2VzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3doaXRlc3BhY2VzJyk7XG5cbnZhciBuYXRpdmVQYXJzZUludCA9IGdsb2JhbC5wYXJzZUludDtcbnZhciBoZXggPSAvXlsrLV0/MFtYeF0vO1xudmFyIEZPUkNFRCA9IG5hdGl2ZVBhcnNlSW50KHdoaXRlc3BhY2VzICsgJzA4JykgIT09IDggfHwgbmF0aXZlUGFyc2VJbnQod2hpdGVzcGFjZXMgKyAnMHgxNicpICE9PSAyMjtcblxuLy8gYHBhcnNlSW50YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXBhcnNlaW50LXN0cmluZy1yYWRpeFxubW9kdWxlLmV4cG9ydHMgPSBGT1JDRUQgPyBmdW5jdGlvbiBwYXJzZUludChzdHJpbmcsIHJhZGl4KSB7XG4gIHZhciBTID0gdHJpbShTdHJpbmcoc3RyaW5nKSk7XG4gIHJldHVybiBuYXRpdmVQYXJzZUludChTLCAocmFkaXggPj4+IDApIHx8IChoZXgudGVzdChTKSA/IDE2IDogMTApKTtcbn0gOiBuYXRpdmVQYXJzZUludDtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIHBhcnNlSW50SW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcGFyc2UtaW50Jyk7XG5cbi8vIGBwYXJzZUludGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wYXJzZWludC1zdHJpbmctcmFkaXhcbiQoeyBnbG9iYWw6IHRydWUsIGZvcmNlZDogcGFyc2VJbnQgIT0gcGFyc2VJbnRJbXBsZW1lbnRhdGlvbiB9LCB7XG4gIHBhcnNlSW50OiBwYXJzZUludEltcGxlbWVudGF0aW9uXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgZmxhZ3MgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzJyk7XG5cbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyIFJlZ0V4cFByb3RvdHlwZSA9IFJlZ0V4cC5wcm90b3R5cGU7XG52YXIgbmF0aXZlVG9TdHJpbmcgPSBSZWdFeHBQcm90b3R5cGVbVE9fU1RSSU5HXTtcblxudmFyIE5PVF9HRU5FUklDID0gZmFpbHMoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmF0aXZlVG9TdHJpbmcuY2FsbCh7IHNvdXJjZTogJ2EnLCBmbGFnczogJ2InIH0pICE9ICcvYS9iJzsgfSk7XG4vLyBGRjQ0LSBSZWdFeHAjdG9TdHJpbmcgaGFzIGEgd3JvbmcgbmFtZVxudmFyIElOQ09SUkVDVF9OQU1FID0gbmF0aXZlVG9TdHJpbmcubmFtZSAhPSBUT19TVFJJTkc7XG5cbi8vIGBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbmlmIChOT1RfR0VORVJJQyB8fCBJTkNPUlJFQ1RfTkFNRSkge1xuICByZWRlZmluZShSZWdFeHAucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciBSID0gYW5PYmplY3QodGhpcyk7XG4gICAgdmFyIHAgPSBTdHJpbmcoUi5zb3VyY2UpO1xuICAgIHZhciByZiA9IFIuZmxhZ3M7XG4gICAgdmFyIGYgPSBTdHJpbmcocmYgPT09IHVuZGVmaW5lZCAmJiBSIGluc3RhbmNlb2YgUmVnRXhwICYmICEoJ2ZsYWdzJyBpbiBSZWdFeHBQcm90b3R5cGUpID8gZmxhZ3MuY2FsbChSKSA6IHJmKTtcbiAgICByZXR1cm4gJy8nICsgcCArICcvJyArIGY7XG4gIH0sIHsgdW5zYWZlOiB0cnVlIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgaWYgKCEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbn0iLCJpbXBvcnQgYXJyYXlXaXRoSG9sZXMgZnJvbSBcIi4vYXJyYXlXaXRoSG9sZXNcIjtcbmltcG9ydCBpdGVyYWJsZVRvQXJyYXlMaW1pdCBmcm9tIFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdFwiO1xuaW1wb3J0IG5vbkl0ZXJhYmxlUmVzdCBmcm9tIFwiLi9ub25JdGVyYWJsZVJlc3RcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufSIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn0iLCJcclxuaW1wb3J0IHsgaGV4LCBpc0hleCwgaXNSZ2IsIHJnYiwgd2hpdGVzcGFjZSB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9yZWdleC5qcydcclxuXHJcbmZ1bmN0aW9uIHNpeERpZ2l0SGV4IChoZXgpIHtcclxuICByZXR1cm4gaGV4Lmxlbmd0aCA9PT0gNFxyXG4gICAgPyBbICcjJyxcclxuICAgICAgaGV4LnN1YnN0cmluZygxLCAyKSwgaGV4LnN1YnN0cmluZygxLCAyKSxcclxuICAgICAgaGV4LnN1YnN0cmluZygyLCAzKSwgaGV4LnN1YnN0cmluZygyLCAzKSxcclxuICAgICAgaGV4LnN1YnN0cmluZygzLCA0KSwgaGV4LnN1YnN0cmluZygzLCA0KVxyXG4gICAgXS5qb2luKCcnKVxyXG4gICAgOiBoZXhcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcG9uZW50SGV4IChjb21wb25lbnQpIHtcclxuICBjb25zdCBpbnRlZ2VyID0gTWF0aC5yb3VuZChjb21wb25lbnQpXHJcbiAgY29uc3QgYm91bmRlZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgaW50ZWdlcikpXHJcbiAgY29uc3QgaGV4ID0gYm91bmRlZC50b1N0cmluZygxNilcclxuICByZXR1cm4gaGV4Lmxlbmd0aCA9PT0gMSA/ICcwJyArIGhleCA6IGhleFxyXG59XHJcblxyXG5mdW5jdGlvbiBpcyAob2JqZWN0LCBzcGFjZSkge1xyXG4gIGZvciAobGV0IGkgPSBzcGFjZS5sZW5ndGg7IGktLTspIHtcclxuICAgIGlmIChvYmplY3Rbc3BhY2VbaV1dID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0cnVlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFBhcmFtZXRlcnMgKGEsIGIpIHtcclxuICBjb25zdCBwYXJhbXMgPSBpcyhhLCAncmdiJykgPyB7IF9hOiBhLnIsIF9iOiBhLmcsIF9jOiBhLmIsIHNwYWNlOiAncmdiJyB9XHJcbiAgICA6IGlzKGEsICd4eXonKSA/IHsgX2E6IGEueCwgX2I6IGEueSwgX2M6IGEueiwgX2Q6IDAsIHNwYWNlOiAneHl6JyB9XHJcbiAgICA6IGlzKGEsICdoc2wnKSA/IHsgX2E6IGEuaCwgX2I6IGEucywgX2M6IGEubCwgX2Q6IDAsIHNwYWNlOiAnaHNsJyB9XHJcbiAgICA6IGlzKGEsICdsYWInKSA/IHsgX2E6IGEubCwgX2I6IGEuYSwgX2M6IGEuYiwgX2Q6IDAsIHNwYWNlOiAnbGFiJyB9XHJcbiAgICA6IGlzKGEsICdsY2gnKSA/IHsgX2E6IGEubCwgX2I6IGEuYywgX2M6IGEuaCwgX2Q6IDAsIHNwYWNlOiAnbGNoJyB9XHJcbiAgICA6IGlzKGEsICdjbXlrJykgPyB7IF9hOiBhLmMsIF9iOiBhLm0sIF9jOiBhLnksIF9kOiBhLmssIHNwYWNlOiAnY215aycgfVxyXG4gICAgOiB7IF9hOiAwLCBfYjogMCwgX2M6IDAsIHNwYWNlOiAncmdiJyB9XHJcblxyXG4gIHBhcmFtcy5zcGFjZSA9IGIgfHwgcGFyYW1zLnNwYWNlXHJcbiAgcmV0dXJuIHBhcmFtc1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaWVTcGFjZSAoc3BhY2UpIHtcclxuICBpZiAoc3BhY2UgPT09ICdsYWInIHx8IHNwYWNlID09PSAneHl6JyB8fCBzcGFjZSA9PT0gJ2xjaCcpIHtcclxuICAgIHJldHVybiB0cnVlXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaHVlVG9SZ2IgKHAsIHEsIHQpIHtcclxuICBpZiAodCA8IDApIHQgKz0gMVxyXG4gIGlmICh0ID4gMSkgdCAtPSAxXHJcbiAgaWYgKHQgPCAxIC8gNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHRcclxuICBpZiAodCA8IDEgLyAyKSByZXR1cm4gcVxyXG4gIGlmICh0IDwgMiAvIDMpIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNlxyXG4gIHJldHVybiBwXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbG9yIHtcclxuICBjb25zdHJ1Y3RvciAoLi4uaW5wdXRzKSB7XHJcbiAgICB0aGlzLmluaXQoLi4uaW5wdXRzKVxyXG4gIH1cclxuXHJcbiAgaW5pdCAoYSA9IDAsIGIgPSAwLCBjID0gMCwgZCA9IDAsIHNwYWNlID0gJ3JnYicpIHtcclxuICAgIC8vIFRoaXMgY2F0Y2hlcyB0aGUgY2FzZSB3aGVuIGEgZmFsc3kgdmFsdWUgaXMgcGFzc2VkIGxpa2UgJydcclxuICAgIGEgPSAhYSA/IDAgOiBhXHJcblxyXG4gICAgLy8gUmVzZXQgYWxsIHZhbHVlcyBpbiBjYXNlIHRoZSBpbml0IGZ1bmN0aW9uIGlzIHJlcnVuIHdpdGggbmV3IGNvbG9yIHNwYWNlXHJcbiAgICBpZiAodGhpcy5zcGFjZSkge1xyXG4gICAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBpbiB0aGlzLnNwYWNlKSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXNbdGhpcy5zcGFjZVtjb21wb25lbnRdXVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJykge1xyXG4gICAgICAvLyBBbGxvdyBmb3IgdGhlIGNhc2UgdGhhdCB3ZSBkb24ndCBuZWVkIGQuLi5cclxuICAgICAgc3BhY2UgPSB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyBkIDogc3BhY2VcclxuICAgICAgZCA9IHR5cGVvZiBkID09PSAnc3RyaW5nJyA/IDAgOiBkXHJcblxyXG4gICAgICAvLyBBc3NpZ24gdGhlIHZhbHVlcyBzdHJhaWdodCB0byB0aGUgY29sb3JcclxuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IF9hOiBhLCBfYjogYiwgX2M6IGMsIF9kOiBkLCBzcGFjZSB9KVxyXG4gICAgLy8gSWYgdGhlIHVzZXIgZ2F2ZSB1cyBhbiBhcnJheSwgbWFrZSB0aGUgY29sb3IgZnJvbSBpdFxyXG4gICAgfSBlbHNlIGlmIChhIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgdGhpcy5zcGFjZSA9IGIgfHwgKHR5cGVvZiBhWzNdID09PSAnc3RyaW5nJyA/IGFbM10gOiBhWzRdKSB8fCAncmdiJ1xyXG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgX2E6IGFbMF0sIF9iOiBhWzFdLCBfYzogYVsyXSwgX2Q6IGFbM10gfHwgMCB9KVxyXG4gICAgfSBlbHNlIGlmIChhIGluc3RhbmNlb2YgT2JqZWN0KSB7XHJcbiAgICAgIC8vIFNldCB0aGUgb2JqZWN0IHVwIGFuZCBhc3NpZ24gaXRzIHZhbHVlcyBkaXJlY3RseVxyXG4gICAgICBjb25zdCB2YWx1ZXMgPSBnZXRQYXJhbWV0ZXJzKGEsIGIpXHJcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgdmFsdWVzKVxyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgaWYgKGlzUmdiLnRlc3QoYSkpIHtcclxuICAgICAgICBjb25zdCBub1doaXRlc3BhY2UgPSBhLnJlcGxhY2Uod2hpdGVzcGFjZSwgJycpXHJcbiAgICAgICAgY29uc3QgWyBfYSwgX2IsIF9jIF0gPSByZ2IuZXhlYyhub1doaXRlc3BhY2UpXHJcbiAgICAgICAgICAuc2xpY2UoMSwgNCkubWFwKHYgPT4gcGFyc2VJbnQodikpXHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IF9hLCBfYiwgX2MsIF9kOiAwLCBzcGFjZTogJ3JnYicgfSlcclxuICAgICAgfSBlbHNlIGlmIChpc0hleC50ZXN0KGEpKSB7XHJcbiAgICAgICAgY29uc3QgaGV4UGFyc2UgPSB2ID0+IHBhcnNlSW50KHYsIDE2KVxyXG4gICAgICAgIGNvbnN0IFsgLCBfYSwgX2IsIF9jIF0gPSBoZXguZXhlYyhzaXhEaWdpdEhleChhKSkubWFwKGhleFBhcnNlKVxyXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyBfYSwgX2IsIF9jLCBfZDogMCwgc3BhY2U6ICdyZ2InIH0pXHJcbiAgICAgIH0gZWxzZSB0aHJvdyBFcnJvcignVW5zdXBwb3J0ZWQgc3RyaW5nIGZvcm1hdCwgY2FuXFwndCBjb25zdHJ1Y3QgQ29sb3InKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vdyBhZGQgdGhlIGNvbXBvbmVudHMgYXMgYSBjb252ZW5pZW5jZVxyXG4gICAgY29uc3QgeyBfYSwgX2IsIF9jLCBfZCB9ID0gdGhpc1xyXG4gICAgY29uc3QgY29tcG9uZW50cyA9IHRoaXMuc3BhY2UgPT09ICdyZ2InID8geyByOiBfYSwgZzogX2IsIGI6IF9jIH1cclxuICAgICAgOiB0aGlzLnNwYWNlID09PSAneHl6JyA/IHsgeDogX2EsIHk6IF9iLCB6OiBfYyB9XHJcbiAgICAgIDogdGhpcy5zcGFjZSA9PT0gJ2hzbCcgPyB7IGg6IF9hLCBzOiBfYiwgbDogX2MgfVxyXG4gICAgICA6IHRoaXMuc3BhY2UgPT09ICdsYWInID8geyBsOiBfYSwgYTogX2IsIGI6IF9jIH1cclxuICAgICAgOiB0aGlzLnNwYWNlID09PSAnbGNoJyA/IHsgbDogX2EsIGM6IF9iLCBoOiBfYyB9XHJcbiAgICAgIDogdGhpcy5zcGFjZSA9PT0gJ2NteWsnID8geyBjOiBfYSwgbTogX2IsIHk6IF9jLCBrOiBfZCB9XHJcbiAgICAgIDoge31cclxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgY29tcG9uZW50cylcclxuICB9XHJcblxyXG4gIC8qXHJcbiAgQ29udmVyc2lvbiBNZXRob2RzXHJcbiAgKi9cclxuXHJcbiAgcmdiICgpIHtcclxuICAgIGlmICh0aGlzLnNwYWNlID09PSAncmdiJykge1xyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfSBlbHNlIGlmIChjaWVTcGFjZSh0aGlzLnNwYWNlKSkge1xyXG4gICAgICAvLyBDb252ZXJ0IHRvIHRoZSB4eXogY29sb3Igc3BhY2VcclxuICAgICAgbGV0IHsgeCwgeSwgeiB9ID0gdGhpc1xyXG4gICAgICBpZiAodGhpcy5zcGFjZSA9PT0gJ2xhYicgfHwgdGhpcy5zcGFjZSA9PT0gJ2xjaCcpIHtcclxuICAgICAgICAvLyBHZXQgdGhlIHZhbHVlcyBpbiB0aGUgbGFiIHNwYWNlXHJcbiAgICAgICAgbGV0IHsgbCwgYSwgYiB9ID0gdGhpc1xyXG4gICAgICAgIGlmICh0aGlzLnNwYWNlID09PSAnbGNoJykge1xyXG4gICAgICAgICAgY29uc3QgeyBjLCBoIH0gPSB0aGlzXHJcbiAgICAgICAgICBjb25zdCBkVG9SID0gTWF0aC5QSSAvIDE4MFxyXG4gICAgICAgICAgYSA9IGMgKiBNYXRoLmNvcyhkVG9SICogaClcclxuICAgICAgICAgIGIgPSBjICogTWF0aC5zaW4oZFRvUiAqIGgpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVbmRvIHRoZSBub25saW5lYXIgZnVuY3Rpb25cclxuICAgICAgICBjb25zdCB5TCA9IChsICsgMTYpIC8gMTE2XHJcbiAgICAgICAgY29uc3QgeEwgPSBhIC8gNTAwICsgeUxcclxuICAgICAgICBjb25zdCB6TCA9IHlMIC0gYiAvIDIwMFxyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIHh5eiB2YWx1ZXNcclxuICAgICAgICBjb25zdCBjdCA9IDE2IC8gMTE2XHJcbiAgICAgICAgY29uc3QgbXggPSAwLjAwODg1NlxyXG4gICAgICAgIGNvbnN0IG5tID0gNy43ODdcclxuICAgICAgICB4ID0gMC45NTA0NyAqICgoeEwgKiogMyA+IG14KSA/IHhMICoqIDMgOiAoeEwgLSBjdCkgLyBubSlcclxuICAgICAgICB5ID0gMS4wMDAwMCAqICgoeUwgKiogMyA+IG14KSA/IHlMICoqIDMgOiAoeUwgLSBjdCkgLyBubSlcclxuICAgICAgICB6ID0gMS4wODg4MyAqICgoekwgKiogMyA+IG14KSA/IHpMICoqIDMgOiAoekwgLSBjdCkgLyBubSlcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ29udmVydCB4eXogdG8gdW5ib3VuZGVkIHJnYiB2YWx1ZXNcclxuICAgICAgY29uc3QgclUgPSB4ICogMy4yNDA2ICsgeSAqIC0xLjUzNzIgKyB6ICogLTAuNDk4NlxyXG4gICAgICBjb25zdCBnVSA9IHggKiAtMC45Njg5ICsgeSAqIDEuODc1OCArIHogKiAwLjA0MTVcclxuICAgICAgY29uc3QgYlUgPSB4ICogMC4wNTU3ICsgeSAqIC0wLjIwNDAgKyB6ICogMS4wNTcwXHJcblxyXG4gICAgICAvLyBDb252ZXJ0IHRoZSB2YWx1ZXMgdG8gdHJ1ZSByZ2IgdmFsdWVzXHJcbiAgICAgIGNvbnN0IHBvdyA9IE1hdGgucG93XHJcbiAgICAgIGNvbnN0IGJkID0gMC4wMDMxMzA4XHJcbiAgICAgIGNvbnN0IHIgPSAoclUgPiBiZCkgPyAoMS4wNTUgKiBwb3coclUsIDEgLyAyLjQpIC0gMC4wNTUpIDogMTIuOTIgKiByVVxyXG4gICAgICBjb25zdCBnID0gKGdVID4gYmQpID8gKDEuMDU1ICogcG93KGdVLCAxIC8gMi40KSAtIDAuMDU1KSA6IDEyLjkyICogZ1VcclxuICAgICAgY29uc3QgYiA9IChiVSA+IGJkKSA/ICgxLjA1NSAqIHBvdyhiVSwgMSAvIDIuNCkgLSAwLjA1NSkgOiAxMi45MiAqIGJVXHJcblxyXG4gICAgICAvLyBNYWtlIGFuZCByZXR1cm4gdGhlIGNvbG9yXHJcbiAgICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKDI1NSAqIHIsIDI1NSAqIGcsIDI1NSAqIGIpXHJcbiAgICAgIHJldHVybiBjb2xvclxyXG4gICAgfSBlbHNlIGlmICh0aGlzLnNwYWNlID09PSAnaHNsJykge1xyXG4gICAgICAvLyBodHRwczovL2Jncmlucy5naXRodWIuaW8vVGlueUNvbG9yL2RvY3MvdGlueWNvbG9yLmh0bWxcclxuICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGhzbCB2YWx1ZXNcclxuICAgICAgbGV0IHsgaCwgcywgbCB9ID0gdGhpc1xyXG4gICAgICBoIC89IDM2MFxyXG4gICAgICBzIC89IDEwMFxyXG4gICAgICBsIC89IDEwMFxyXG5cclxuICAgICAgLy8gSWYgd2UgYXJlIGdyZXksIHRoZW4ganVzdCBtYWtlIHRoZSBjb2xvciBkaXJlY3RseVxyXG4gICAgICBpZiAocyA9PT0gMCkge1xyXG4gICAgICAgIGwgKj0gMjU1XHJcbiAgICAgICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IobCwgbCwgbClcclxuICAgICAgICByZXR1cm4gY29sb3JcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVE9ETyBJIGhhdmUgbm8gaWRlYSB3aGF0IHRoaXMgZG9lcyA6RCBJZiB5b3UgZmlndXJlIGl0IG91dCwgdGVsbCBtZSFcclxuICAgICAgY29uc3QgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHNcclxuICAgICAgY29uc3QgcCA9IDIgKiBsIC0gcVxyXG5cclxuICAgICAgLy8gR2V0IHRoZSByZ2IgdmFsdWVzXHJcbiAgICAgIGNvbnN0IHIgPSAyNTUgKiBodWVUb1JnYihwLCBxLCBoICsgMSAvIDMpXHJcbiAgICAgIGNvbnN0IGcgPSAyNTUgKiBodWVUb1JnYihwLCBxLCBoKVxyXG4gICAgICBjb25zdCBiID0gMjU1ICogaHVlVG9SZ2IocCwgcSwgaCAtIDEgLyAzKVxyXG5cclxuICAgICAgLy8gTWFrZSBhIG5ldyBjb2xvclxyXG4gICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihyLCBnLCBiKVxyXG4gICAgICByZXR1cm4gY29sb3JcclxuICAgIH0gZWxzZSBpZiAodGhpcy5zcGFjZSA9PT0gJ2NteWsnKSB7XHJcbiAgICAgIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2ZlbGlwZXNhYmluby81MDY2MzM2XHJcbiAgICAgIC8vIEdldCB0aGUgbm9ybWFsaXNlZCBjbXlrIHZhbHVlc1xyXG4gICAgICBjb25zdCB7IGMsIG0sIHksIGsgfSA9IHRoaXNcclxuXHJcbiAgICAgIC8vIEdldCB0aGUgcmdiIHZhbHVlc1xyXG4gICAgICBjb25zdCByID0gMjU1ICogKDEgLSBNYXRoLm1pbigxLCBjICogKDEgLSBrKSArIGspKVxyXG4gICAgICBjb25zdCBnID0gMjU1ICogKDEgLSBNYXRoLm1pbigxLCBtICogKDEgLSBrKSArIGspKVxyXG4gICAgICBjb25zdCBiID0gMjU1ICogKDEgLSBNYXRoLm1pbigxLCB5ICogKDEgLSBrKSArIGspKVxyXG5cclxuICAgICAgLy8gRm9ybSB0aGUgY29sb3IgYW5kIHJldHVybiBpdFxyXG4gICAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihyLCBnLCBiKVxyXG4gICAgICByZXR1cm4gY29sb3JcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBsYWIgKCkge1xyXG4gICAgLy8gR2V0IHRoZSB4eXogY29sb3JcclxuICAgIGNvbnN0IHsgeCwgeSwgeiB9ID0gdGhpcy54eXooKVxyXG5cclxuICAgIC8vIEdldCB0aGUgbGFiIGNvbXBvbmVudHNcclxuICAgIGNvbnN0IGwgPSAoMTE2ICogeSkgLSAxNlxyXG4gICAgY29uc3QgYSA9IDUwMCAqICh4IC0geSlcclxuICAgIGNvbnN0IGIgPSAyMDAgKiAoeSAtIHopXHJcblxyXG4gICAgLy8gQ29uc3RydWN0IGFuZCByZXR1cm4gYSBuZXcgY29sb3JcclxuICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKGwsIGEsIGIsICdsYWInKVxyXG4gICAgcmV0dXJuIGNvbG9yXHJcbiAgfVxyXG5cclxuICB4eXogKCkge1xyXG5cclxuICAgIC8vIE5vcm1hbGlzZSB0aGUgcmVkLCBncmVlbiBhbmQgYmx1ZSB2YWx1ZXNcclxuICAgIGNvbnN0IHsgX2E6IHIyNTUsIF9iOiBnMjU1LCBfYzogYjI1NSB9ID0gdGhpcy5yZ2IoKVxyXG4gICAgY29uc3QgWyByLCBnLCBiIF0gPSBbIHIyNTUsIGcyNTUsIGIyNTUgXS5tYXAodiA9PiB2IC8gMjU1KVxyXG5cclxuICAgIC8vIENvbnZlcnQgdG8gdGhlIGxhYiByZ2Igc3BhY2VcclxuICAgIGNvbnN0IHJMID0gKHIgPiAwLjA0MDQ1KSA/IE1hdGgucG93KChyICsgMC4wNTUpIC8gMS4wNTUsIDIuNCkgOiByIC8gMTIuOTJcclxuICAgIGNvbnN0IGdMID0gKGcgPiAwLjA0MDQ1KSA/IE1hdGgucG93KChnICsgMC4wNTUpIC8gMS4wNTUsIDIuNCkgOiBnIC8gMTIuOTJcclxuICAgIGNvbnN0IGJMID0gKGIgPiAwLjA0MDQ1KSA/IE1hdGgucG93KChiICsgMC4wNTUpIC8gMS4wNTUsIDIuNCkgOiBiIC8gMTIuOTJcclxuXHJcbiAgICAvLyBDb252ZXJ0IHRvIHRoZSB4eXogY29sb3Igc3BhY2Ugd2l0aG91dCBib3VuZGluZyB0aGUgdmFsdWVzXHJcbiAgICBjb25zdCB4VSA9IChyTCAqIDAuNDEyNCArIGdMICogMC4zNTc2ICsgYkwgKiAwLjE4MDUpIC8gMC45NTA0N1xyXG4gICAgY29uc3QgeVUgPSAockwgKiAwLjIxMjYgKyBnTCAqIDAuNzE1MiArIGJMICogMC4wNzIyKSAvIDEuMDAwMDBcclxuICAgIGNvbnN0IHpVID0gKHJMICogMC4wMTkzICsgZ0wgKiAwLjExOTIgKyBiTCAqIDAuOTUwNSkgLyAxLjA4ODgzXHJcblxyXG4gICAgLy8gR2V0IHRoZSBwcm9wZXIgeHl6IHZhbHVlcyBieSBhcHBseWluZyB0aGUgYm91bmRpbmdcclxuICAgIGNvbnN0IHggPSAoeFUgPiAwLjAwODg1NikgPyBNYXRoLnBvdyh4VSwgMSAvIDMpIDogKDcuNzg3ICogeFUpICsgMTYgLyAxMTZcclxuICAgIGNvbnN0IHkgPSAoeVUgPiAwLjAwODg1NikgPyBNYXRoLnBvdyh5VSwgMSAvIDMpIDogKDcuNzg3ICogeVUpICsgMTYgLyAxMTZcclxuICAgIGNvbnN0IHogPSAoelUgPiAwLjAwODg1NikgPyBNYXRoLnBvdyh6VSwgMSAvIDMpIDogKDcuNzg3ICogelUpICsgMTYgLyAxMTZcclxuXHJcbiAgICAvLyBNYWtlIGFuZCByZXR1cm4gdGhlIGNvbG9yXHJcbiAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcih4LCB5LCB6LCAneHl6JylcclxuICAgIHJldHVybiBjb2xvclxyXG4gIH1cclxuXHJcbiAgbGNoICgpIHtcclxuXHJcbiAgICAvLyBHZXQgdGhlIGxhYiBjb2xvciBkaXJlY3RseVxyXG4gICAgY29uc3QgeyBsLCBhLCBiIH0gPSB0aGlzLmxhYigpXHJcblxyXG4gICAgLy8gR2V0IHRoZSBjaHJvbWF0aWNpdHkgYW5kIHRoZSBodWUgdXNpbmcgcG9sYXIgY29vcmRpbmF0ZXNcclxuICAgIGNvbnN0IGMgPSBNYXRoLnNxcnQoYSAqKiAyICsgYiAqKiAyKVxyXG4gICAgbGV0IGggPSAxODAgKiBNYXRoLmF0YW4yKGIsIGEpIC8gTWF0aC5QSVxyXG4gICAgaWYgKGggPCAwKSB7XHJcbiAgICAgIGggKj0gLTFcclxuICAgICAgaCA9IDM2MCAtIGhcclxuICAgIH1cclxuXHJcbiAgICAvLyBNYWtlIGEgbmV3IGNvbG9yIGFuZCByZXR1cm4gaXRcclxuICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKGwsIGMsIGgsICdsY2gnKVxyXG4gICAgcmV0dXJuIGNvbG9yXHJcbiAgfVxyXG5cclxuICBoc2wgKCkge1xyXG5cclxuICAgIC8vIEdldCB0aGUgcmdiIHZhbHVlc1xyXG4gICAgY29uc3QgeyBfYSwgX2IsIF9jIH0gPSB0aGlzLnJnYigpXHJcbiAgICBjb25zdCBbIHIsIGcsIGIgXSA9IFsgX2EsIF9iLCBfYyBdLm1hcCh2ID0+IHYgLyAyNTUpXHJcblxyXG4gICAgLy8gRmluZCB0aGUgbWF4aW11bSBhbmQgbWluaW11bSB2YWx1ZXMgdG8gZ2V0IHRoZSBsaWdodG5lc3NcclxuICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpXHJcbiAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKVxyXG4gICAgY29uc3QgbCA9IChtYXggKyBtaW4pIC8gMlxyXG5cclxuICAgIC8vIElmIHRoZSByLCBnLCB2IHZhbHVlcyBhcmUgaWRlbnRpY2FsIHRoZW4gd2UgYXJlIGdyZXlcclxuICAgIGNvbnN0IGlzR3JleSA9IG1heCA9PT0gbWluXHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBodWUgYW5kIHNhdHVyYXRpb25cclxuICAgIGNvbnN0IGRlbHRhID0gbWF4IC0gbWluXHJcbiAgICBjb25zdCBzID0gaXNHcmV5ID8gMFxyXG4gICAgICA6IGwgPiAwLjUgPyBkZWx0YSAvICgyIC0gbWF4IC0gbWluKVxyXG4gICAgICA6IGRlbHRhIC8gKG1heCArIG1pbilcclxuICAgIGNvbnN0IGggPSBpc0dyZXkgPyAwXHJcbiAgICAgIDogbWF4ID09PSByID8gKChnIC0gYikgLyBkZWx0YSArIChnIDwgYiA/IDYgOiAwKSkgLyA2XHJcbiAgICAgIDogbWF4ID09PSBnID8gKChiIC0gcikgLyBkZWx0YSArIDIpIC8gNlxyXG4gICAgICA6IG1heCA9PT0gYiA/ICgociAtIGcpIC8gZGVsdGEgKyA0KSAvIDZcclxuICAgICAgOiAwXHJcblxyXG4gICAgLy8gQ29uc3RydWN0IGFuZCByZXR1cm4gdGhlIG5ldyBjb2xvclxyXG4gICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IoMzYwICogaCwgMTAwICogcywgMTAwICogbCwgJ2hzbCcpXHJcbiAgICByZXR1cm4gY29sb3JcclxuICB9XHJcblxyXG4gIGNteWsgKCkge1xyXG5cclxuICAgIC8vIEdldCB0aGUgcmdiIHZhbHVlcyBmb3IgdGhlIGN1cnJlbnQgY29sb3JcclxuICAgIGNvbnN0IHsgX2EsIF9iLCBfYyB9ID0gdGhpcy5yZ2IoKVxyXG4gICAgY29uc3QgWyByLCBnLCBiIF0gPSBbIF9hLCBfYiwgX2MgXS5tYXAodiA9PiB2IC8gMjU1KVxyXG5cclxuICAgIC8vIEdldCB0aGUgY215ayB2YWx1ZXMgaW4gYW4gdW5ib3VuZGVkIGZvcm1hdFxyXG4gICAgY29uc3QgayA9IE1hdGgubWluKDEgLSByLCAxIC0gZywgMSAtIGIpXHJcblxyXG4gICAgaWYgKGsgPT09IDEpIHtcclxuICAgICAgLy8gQ2F0Y2ggdGhlIGJsYWNrIGNhc2VcclxuICAgICAgcmV0dXJuIG5ldyBDb2xvcigwLCAwLCAwLCAxLCAnY215aycpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYyA9ICgxIC0gciAtIGspIC8gKDEgLSBrKVxyXG4gICAgY29uc3QgbSA9ICgxIC0gZyAtIGspIC8gKDEgLSBrKVxyXG4gICAgY29uc3QgeSA9ICgxIC0gYiAtIGspIC8gKDEgLSBrKVxyXG5cclxuICAgIC8vIENvbnN0cnVjdCB0aGUgbmV3IGNvbG9yXHJcbiAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcihjLCBtLCB5LCBrLCAnY215aycpXHJcbiAgICByZXR1cm4gY29sb3JcclxuICB9XHJcblxyXG4gIC8qXHJcbiAgSW5wdXQgYW5kIE91dHB1dCBtZXRob2RzXHJcbiAgKi9cclxuXHJcbiAgX2NsYW1wZWQgKCkge1xyXG4gICAgY29uc3QgeyBfYSwgX2IsIF9jIH0gPSB0aGlzLnJnYigpXHJcbiAgICBjb25zdCB7IG1heCwgbWluLCByb3VuZCB9ID0gTWF0aFxyXG4gICAgY29uc3QgZm9ybWF0ID0gdiA9PiBtYXgoMCwgbWluKHJvdW5kKHYpLCAyNTUpKVxyXG4gICAgcmV0dXJuIFsgX2EsIF9iLCBfYyBdLm1hcChmb3JtYXQpXHJcbiAgfVxyXG5cclxuICB0b0hleCAoKSB7XHJcbiAgICBjb25zdCBbIHIsIGcsIGIgXSA9IHRoaXMuX2NsYW1wZWQoKS5tYXAoY29tcG9uZW50SGV4KVxyXG4gICAgcmV0dXJuIGAjJHtyfSR7Z30ke2J9YFxyXG4gIH1cclxuXHJcbiAgdG9TdHJpbmcgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudG9IZXgoKVxyXG4gIH1cclxuXHJcbiAgdG9SZ2IgKCkge1xyXG4gICAgY29uc3QgWyByViwgZ1YsIGJWIF0gPSB0aGlzLl9jbGFtcGVkKClcclxuICAgIGNvbnN0IHN0cmluZyA9IGByZ2IoJHtyVn0sJHtnVn0sJHtiVn0pYFxyXG4gICAgcmV0dXJuIHN0cmluZ1xyXG4gIH1cclxuXHJcbiAgdG9BcnJheSAoKSB7XHJcbiAgICBjb25zdCB7IF9hLCBfYiwgX2MsIF9kLCBzcGFjZSB9ID0gdGhpc1xyXG4gICAgcmV0dXJuIFsgX2EsIF9iLCBfYywgX2QsIHNwYWNlIF1cclxuICB9XHJcblxyXG4gIC8qXHJcbiAgR2VuZXJhdGluZyByYW5kb20gY29sb3JzXHJcbiAgKi9cclxuXHJcbiAgc3RhdGljIHJhbmRvbSAobW9kZSA9ICd2aWJyYW50JywgdCwgdSkge1xyXG5cclxuICAgIC8vIEdldCB0aGUgbWF0aCBtb2R1bGVzXHJcbiAgICBjb25zdCB7IHJhbmRvbSwgcm91bmQsIHNpbiwgUEk6IHBpIH0gPSBNYXRoXHJcblxyXG4gICAgLy8gUnVuIHRoZSBjb3JyZWN0IGdlbmVyYXRvclxyXG4gICAgaWYgKG1vZGUgPT09ICd2aWJyYW50Jykge1xyXG5cclxuICAgICAgY29uc3QgbCA9ICg4MSAtIDU3KSAqIHJhbmRvbSgpICsgNTdcclxuICAgICAgY29uc3QgYyA9ICg4MyAtIDQ1KSAqIHJhbmRvbSgpICsgNDVcclxuICAgICAgY29uc3QgaCA9IDM2MCAqIHJhbmRvbSgpXHJcbiAgICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKGwsIGMsIGgsICdsY2gnKVxyXG4gICAgICByZXR1cm4gY29sb3JcclxuXHJcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdzaW5lJykge1xyXG5cclxuICAgICAgdCA9IHQgPT0gbnVsbCA/IHJhbmRvbSgpIDogdFxyXG4gICAgICBjb25zdCByID0gcm91bmQoODAgKiBzaW4oMiAqIHBpICogdCAvIDAuNSArIDAuMDEpICsgMTUwKVxyXG4gICAgICBjb25zdCBnID0gcm91bmQoNTAgKiBzaW4oMiAqIHBpICogdCAvIDAuNSArIDQuNikgKyAyMDApXHJcbiAgICAgIGNvbnN0IGIgPSByb3VuZCgxMDAgKiBzaW4oMiAqIHBpICogdCAvIDAuNSArIDIuMykgKyAxNTApXHJcbiAgICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKHIsIGcsIGIpXHJcbiAgICAgIHJldHVybiBjb2xvclxyXG5cclxuICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ3Bhc3RlbCcpIHtcclxuXHJcbiAgICAgIGNvbnN0IGwgPSAoOTQgLSA4NikgKiByYW5kb20oKSArIDg2XHJcbiAgICAgIGNvbnN0IGMgPSAoMjYgLSA5KSAqIHJhbmRvbSgpICsgOVxyXG4gICAgICBjb25zdCBoID0gMzYwICogcmFuZG9tKClcclxuICAgICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IobCwgYywgaCwgJ2xjaCcpXHJcbiAgICAgIHJldHVybiBjb2xvclxyXG5cclxuICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2RhcmsnKSB7XHJcblxyXG4gICAgICBjb25zdCBsID0gMTAgKyAxMCAqIHJhbmRvbSgpXHJcbiAgICAgIGNvbnN0IGMgPSAoMTI1IC0gNzUpICogcmFuZG9tKCkgKyA4NlxyXG4gICAgICBjb25zdCBoID0gMzYwICogcmFuZG9tKClcclxuICAgICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IobCwgYywgaCwgJ2xjaCcpXHJcbiAgICAgIHJldHVybiBjb2xvclxyXG5cclxuICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ3JnYicpIHtcclxuXHJcbiAgICAgIGNvbnN0IHIgPSAyNTUgKiByYW5kb20oKVxyXG4gICAgICBjb25zdCBnID0gMjU1ICogcmFuZG9tKClcclxuICAgICAgY29uc3QgYiA9IDI1NSAqIHJhbmRvbSgpXHJcbiAgICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKHIsIGcsIGIpXHJcbiAgICAgIHJldHVybiBjb2xvclxyXG5cclxuICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2xhYicpIHtcclxuXHJcbiAgICAgIGNvbnN0IGwgPSAxMDAgKiByYW5kb20oKVxyXG4gICAgICBjb25zdCBhID0gMjU2ICogcmFuZG9tKCkgLSAxMjhcclxuICAgICAgY29uc3QgYiA9IDI1NiAqIHJhbmRvbSgpIC0gMTI4XHJcbiAgICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKGwsIGEsIGIsICdsYWInKVxyXG4gICAgICByZXR1cm4gY29sb3JcclxuXHJcbiAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdncmV5Jykge1xyXG5cclxuICAgICAgY29uc3QgZ3JleSA9IDI1NSAqIHJhbmRvbSgpXHJcbiAgICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKGdyZXksIGdyZXksIGdyZXkpXHJcbiAgICAgIHJldHVybiBjb2xvclxyXG5cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qXHJcbiAgQ29uc3RydWN0aW5nIGNvbG9yc1xyXG4gICovXHJcblxyXG4gIC8vIFRlc3QgaWYgZ2l2ZW4gdmFsdWUgaXMgYSBjb2xvciBzdHJpbmdcclxuICBzdGF0aWMgdGVzdCAoY29sb3IpIHtcclxuICAgIHJldHVybiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJylcclxuICAgICAgJiYgKGlzSGV4LnRlc3QoY29sb3IpIHx8IGlzUmdiLnRlc3QoY29sb3IpKVxyXG4gIH1cclxuXHJcbiAgLy8gVGVzdCBpZiBnaXZlbiB2YWx1ZSBpcyBhbiByZ2Igb2JqZWN0XHJcbiAgc3RhdGljIGlzUmdiIChjb2xvcikge1xyXG4gICAgcmV0dXJuIGNvbG9yICYmIHR5cGVvZiBjb2xvci5yID09PSAnbnVtYmVyJ1xyXG4gICAgICAmJiB0eXBlb2YgY29sb3IuZyA9PT0gJ251bWJlcidcclxuICAgICAgJiYgdHlwZW9mIGNvbG9yLmIgPT09ICdudW1iZXInXHJcbiAgfVxyXG5cclxuICAvLyBUZXN0IGlmIGdpdmVuIHZhbHVlIGlzIGEgY29sb3JcclxuICBzdGF0aWMgaXNDb2xvciAoY29sb3IpIHtcclxuICAgIHJldHVybiBjb2xvciAmJiAoXHJcbiAgICAgIGNvbG9yIGluc3RhbmNlb2YgQ29sb3JcclxuICAgICAgfHwgdGhpcy5pc1JnYihjb2xvcilcclxuICAgICAgfHwgdGhpcy50ZXN0KGNvbG9yKVxyXG4gICAgKVxyXG4gIH1cclxufVxyXG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBuYXRpdmVLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxudmFyIEZBSUxTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IG5hdGl2ZUtleXMoMSk7IH0pO1xuXG4vLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZBSUxTX09OX1BSSU1JVElWRVMgfSwge1xuICBrZXlzOiBmdW5jdGlvbiBrZXlzKGl0KSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXModG9PYmplY3QoaXQpKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZml4LXJlZ2V4cC13ZWxsLWtub3duLXN5bWJvbC1sb2dpYycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FkdmFuY2Utc3RyaW5nLWluZGV4Jyk7XG52YXIgcmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZXhlYy1hYnN0cmFjdCcpO1xuXG4vLyBAQG1hdGNoIGxvZ2ljXG5maXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYygnbWF0Y2gnLCAxLCBmdW5jdGlvbiAoTUFUQ0gsIG5hdGl2ZU1hdGNoLCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5tYXRjaGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5tYXRjaFxuICAgIGZ1bmN0aW9uIG1hdGNoKHJlZ2V4cCkge1xuICAgICAgdmFyIE8gPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpO1xuICAgICAgdmFyIG1hdGNoZXIgPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW01BVENIXTtcbiAgICAgIHJldHVybiBtYXRjaGVyICE9PSB1bmRlZmluZWQgPyBtYXRjaGVyLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtNQVRDSF0oU3RyaW5nKE8pKTtcbiAgICB9LFxuICAgIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAbWF0Y2hdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAbWF0Y2hcbiAgICBmdW5jdGlvbiAocmVnZXhwKSB7XG4gICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKG5hdGl2ZU1hdGNoLCByZWdleHAsIHRoaXMpO1xuICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuXG4gICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG5cbiAgICAgIGlmICghcnguZ2xvYmFsKSByZXR1cm4gcmVnRXhwRXhlYyhyeCwgUyk7XG5cbiAgICAgIHZhciBmdWxsVW5pY29kZSA9IHJ4LnVuaWNvZGU7XG4gICAgICByeC5sYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIEEgPSBbXTtcbiAgICAgIHZhciBuID0gMDtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICB3aGlsZSAoKHJlc3VsdCA9IHJlZ0V4cEV4ZWMocngsIFMpKSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgbWF0Y2hTdHIgPSBTdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgQVtuXSA9IG1hdGNoU3RyO1xuICAgICAgICBpZiAobWF0Y2hTdHIgPT09ICcnKSByeC5sYXN0SW5kZXggPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgdG9MZW5ndGgocngubGFzdEluZGV4KSwgZnVsbFVuaWNvZGUpO1xuICAgICAgICBuKys7XG4gICAgICB9XG4gICAgICByZXR1cm4gbiA9PT0gMCA/IG51bGwgOiBBO1xuICAgIH1cbiAgXTtcbn0pO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn0iLCJpbXBvcnQgX3R5cGVvZiBmcm9tIFwiLi4vLi4vaGVscGVycy9lc20vdHlwZW9mXCI7XG5pbXBvcnQgYXNzZXJ0VGhpc0luaXRpYWxpemVkIGZyb20gXCIuL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59IiwiaW1wb3J0IGdldFByb3RvdHlwZU9mIGZyb20gXCIuL2dldFByb3RvdHlwZU9mXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59IiwiaW1wb3J0IHN1cGVyUHJvcEJhc2UgZnJvbSBcIi4vc3VwZXJQcm9wQmFzZVwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gIH0gZWxzZSB7XG4gICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgIHZhciBiYXNlID0gc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTtcbiAgICAgIGlmICghYmFzZSkgcmV0dXJuO1xuICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcblxuICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59IiwiaW1wb3J0IHNldFByb3RvdHlwZU9mIGZyb20gXCIuL3NldFByb3RvdHlwZU9mXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59IiwiJ3VzZSBzdHJpY3QnO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGlzRm9yY2VkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWZvcmNlZCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMnKS5mO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJykuZjtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciB0cmltID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy10cmltJykudHJpbTtcblxudmFyIE5VTUJFUiA9ICdOdW1iZXInO1xudmFyIE5hdGl2ZU51bWJlciA9IGdsb2JhbFtOVU1CRVJdO1xudmFyIE51bWJlclByb3RvdHlwZSA9IE5hdGl2ZU51bWJlci5wcm90b3R5cGU7XG5cbi8vIE9wZXJhIH4xMiBoYXMgYnJva2VuIE9iamVjdCN0b1N0cmluZ1xudmFyIEJST0tFTl9DTEFTU09GID0gY2xhc3NvZihjcmVhdGUoTnVtYmVyUHJvdG90eXBlKSkgPT0gTlVNQkVSO1xuXG4vLyBgVG9OdW1iZXJgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9udW1iZXJcbnZhciB0b051bWJlciA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIgaXQgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgZmFsc2UpO1xuICB2YXIgZmlyc3QsIHRoaXJkLCByYWRpeCwgbWF4Q29kZSwgZGlnaXRzLCBsZW5ndGgsIGluZGV4LCBjb2RlO1xuICBpZiAodHlwZW9mIGl0ID09ICdzdHJpbmcnICYmIGl0Lmxlbmd0aCA+IDIpIHtcbiAgICBpdCA9IHRyaW0oaXQpO1xuICAgIGZpcnN0ID0gaXQuY2hhckNvZGVBdCgwKTtcbiAgICBpZiAoZmlyc3QgPT09IDQzIHx8IGZpcnN0ID09PSA0NSkge1xuICAgICAgdGhpcmQgPSBpdC5jaGFyQ29kZUF0KDIpO1xuICAgICAgaWYgKHRoaXJkID09PSA4OCB8fCB0aGlyZCA9PT0gMTIwKSByZXR1cm4gTmFOOyAvLyBOdW1iZXIoJysweDEnKSBzaG91bGQgYmUgTmFOLCBvbGQgVjggZml4XG4gICAgfSBlbHNlIGlmIChmaXJzdCA9PT0gNDgpIHtcbiAgICAgIHN3aXRjaCAoaXQuY2hhckNvZGVBdCgxKSkge1xuICAgICAgICBjYXNlIDY2OiBjYXNlIDk4OiByYWRpeCA9IDI7IG1heENvZGUgPSA0OTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgb2YgL14wYlswMV0rJC9pXG4gICAgICAgIGNhc2UgNzk6IGNhc2UgMTExOiByYWRpeCA9IDg7IG1heENvZGUgPSA1NTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgb2YgL14wb1swLTddKyQvaVxuICAgICAgICBkZWZhdWx0OiByZXR1cm4gK2l0O1xuICAgICAgfVxuICAgICAgZGlnaXRzID0gaXQuc2xpY2UoMik7XG4gICAgICBsZW5ndGggPSBkaWdpdHMubGVuZ3RoO1xuICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGNvZGUgPSBkaWdpdHMuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgIC8vIHBhcnNlSW50IHBhcnNlcyBhIHN0cmluZyB0byBhIGZpcnN0IHVuYXZhaWxhYmxlIHN5bWJvbFxuICAgICAgICAvLyBidXQgVG9OdW1iZXIgc2hvdWxkIHJldHVybiBOYU4gaWYgYSBzdHJpbmcgY29udGFpbnMgdW5hdmFpbGFibGUgc3ltYm9sc1xuICAgICAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiBtYXhDb2RlKSByZXR1cm4gTmFOO1xuICAgICAgfSByZXR1cm4gcGFyc2VJbnQoZGlnaXRzLCByYWRpeCk7XG4gICAgfVxuICB9IHJldHVybiAraXQ7XG59O1xuXG4vLyBgTnVtYmVyYCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbnVtYmVyLWNvbnN0cnVjdG9yXG5pZiAoaXNGb3JjZWQoTlVNQkVSLCAhTmF0aXZlTnVtYmVyKCcgMG8xJykgfHwgIU5hdGl2ZU51bWJlcignMGIxJykgfHwgTmF0aXZlTnVtYmVyKCcrMHgxJykpKSB7XG4gIHZhciBOdW1iZXJXcmFwcGVyID0gZnVuY3Rpb24gTnVtYmVyKHZhbHVlKSB7XG4gICAgdmFyIGl0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDEgPyAwIDogdmFsdWU7XG4gICAgdmFyIGR1bW15ID0gdGhpcztcbiAgICByZXR1cm4gZHVtbXkgaW5zdGFuY2VvZiBOdW1iZXJXcmFwcGVyXG4gICAgICAvLyBjaGVjayBvbiAxLi5jb25zdHJ1Y3Rvcihmb28pIGNhc2VcbiAgICAgICYmIChCUk9LRU5fQ0xBU1NPRiA/IGZhaWxzKGZ1bmN0aW9uICgpIHsgTnVtYmVyUHJvdG90eXBlLnZhbHVlT2YuY2FsbChkdW1teSk7IH0pIDogY2xhc3NvZihkdW1teSkgIT0gTlVNQkVSKVxuICAgICAgICA/IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBOYXRpdmVOdW1iZXIodG9OdW1iZXIoaXQpKSwgZHVtbXksIE51bWJlcldyYXBwZXIpIDogdG9OdW1iZXIoaXQpO1xuICB9O1xuICBmb3IgKHZhciBrZXlzID0gREVTQ1JJUFRPUlMgPyBnZXRPd25Qcm9wZXJ0eU5hbWVzKE5hdGl2ZU51bWJlcikgOiAoXG4gICAgLy8gRVMzOlxuICAgICdNQVhfVkFMVUUsTUlOX1ZBTFVFLE5hTixORUdBVElWRV9JTkZJTklUWSxQT1NJVElWRV9JTkZJTklUWSwnICtcbiAgICAvLyBFUzIwMTUgKGluIGNhc2UsIGlmIG1vZHVsZXMgd2l0aCBFUzIwMTUgTnVtYmVyIHN0YXRpY3MgcmVxdWlyZWQgYmVmb3JlKTpcbiAgICAnRVBTSUxPTixpc0Zpbml0ZSxpc0ludGVnZXIsaXNOYU4saXNTYWZlSW50ZWdlcixNQVhfU0FGRV9JTlRFR0VSLCcgK1xuICAgICdNSU5fU0FGRV9JTlRFR0VSLHBhcnNlRmxvYXQscGFyc2VJbnQsaXNJbnRlZ2VyJ1xuICApLnNwbGl0KCcsJyksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajsgaisrKSB7XG4gICAgaWYgKGhhcyhOYXRpdmVOdW1iZXIsIGtleSA9IGtleXNbal0pICYmICFoYXMoTnVtYmVyV3JhcHBlciwga2V5KSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkoTnVtYmVyV3JhcHBlciwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTmF0aXZlTnVtYmVyLCBrZXkpKTtcbiAgICB9XG4gIH1cbiAgTnVtYmVyV3JhcHBlci5wcm90b3R5cGUgPSBOdW1iZXJQcm90b3R5cGU7XG4gIE51bWJlclByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE51bWJlcldyYXBwZXI7XG4gIHJlZGVmaW5lKGdsb2JhbCwgTlVNQkVSLCBOdW1iZXJXcmFwcGVyKTtcbn1cbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgdHJpbSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zdHJpbmctdHJpbScpLnRyaW07XG52YXIgd2hpdGVzcGFjZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2hpdGVzcGFjZXMnKTtcblxudmFyIG5hdGl2ZVBhcnNlRmxvYXQgPSBnbG9iYWwucGFyc2VGbG9hdDtcbnZhciBGT1JDRUQgPSAxIC8gbmF0aXZlUGFyc2VGbG9hdCh3aGl0ZXNwYWNlcyArICctMCcpICE9PSAtSW5maW5pdHk7XG5cbi8vIGBwYXJzZUZsb2F0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXBhcnNlZmxvYXQtc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IEZPUkNFRCA/IGZ1bmN0aW9uIHBhcnNlRmxvYXQoc3RyaW5nKSB7XG4gIHZhciB0cmltbWVkU3RyaW5nID0gdHJpbShTdHJpbmcoc3RyaW5nKSk7XG4gIHZhciByZXN1bHQgPSBuYXRpdmVQYXJzZUZsb2F0KHRyaW1tZWRTdHJpbmcpO1xuICByZXR1cm4gcmVzdWx0ID09PSAwICYmIHRyaW1tZWRTdHJpbmcuY2hhckF0KDApID09ICctJyA/IC0wIDogcmVzdWx0O1xufSA6IG5hdGl2ZVBhcnNlRmxvYXQ7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBwYXJzZUZsb2F0SW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcGFyc2UtZmxvYXQnKTtcblxuLy8gYHBhcnNlRmxvYXRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcGFyc2VmbG9hdC1zdHJpbmdcbiQoeyBnbG9iYWw6IHRydWUsIGZvcmNlZDogcGFyc2VGbG9hdCAhPSBwYXJzZUZsb2F0SW1wbGVtZW50YXRpb24gfSwge1xuICBwYXJzZUZsb2F0OiBwYXJzZUZsb2F0SW1wbGVtZW50YXRpb25cbn0pO1xuIiwiaW1wb3J0IE1hdHJpeCBmcm9tICcuL01hdHJpeC5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50IHtcclxuICAvLyBJbml0aWFsaXplXHJcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcclxuICAgIHRoaXMuaW5pdCguLi5hcmdzKVxyXG4gIH1cclxuXHJcbiAgaW5pdCAoeCwgeSkge1xyXG4gICAgY29uc3QgYmFzZSA9IHsgeDogMCwgeTogMCB9XHJcblxyXG4gICAgLy8gZW5zdXJlIHNvdXJjZSBhcyBvYmplY3RcclxuICAgIGNvbnN0IHNvdXJjZSA9IEFycmF5LmlzQXJyYXkoeCkgPyB7IHg6IHhbMF0sIHk6IHhbMV0gfVxyXG4gICAgICA6IHR5cGVvZiB4ID09PSAnb2JqZWN0JyA/IHsgeDogeC54LCB5OiB4LnkgfVxyXG4gICAgICA6IHsgeDogeCwgeTogeSB9XHJcblxyXG4gICAgLy8gbWVyZ2Ugc291cmNlXHJcbiAgICB0aGlzLnggPSBzb3VyY2UueCA9PSBudWxsID8gYmFzZS54IDogc291cmNlLnhcclxuICAgIHRoaXMueSA9IHNvdXJjZS55ID09IG51bGwgPyBiYXNlLnkgOiBzb3VyY2UueVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvLyBDbG9uZSBwb2ludFxyXG4gIGNsb25lICgpIHtcclxuICAgIHJldHVybiBuZXcgUG9pbnQodGhpcylcclxuICB9XHJcblxyXG4gIHRyYW5zZm9ybSAobSkge1xyXG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS50cmFuc2Zvcm1PKG0pXHJcbiAgfVxyXG5cclxuICAvLyBUcmFuc2Zvcm0gcG9pbnQgd2l0aCBtYXRyaXhcclxuICB0cmFuc2Zvcm1PIChtKSB7XHJcbiAgICBpZiAoIU1hdHJpeC5pc01hdHJpeExpa2UobSkpIHtcclxuICAgICAgbSA9IG5ldyBNYXRyaXgobSlcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXNcclxuXHJcbiAgICAvLyBQZXJmb3JtIHRoZSBtYXRyaXggbXVsdGlwbGljYXRpb25cclxuICAgIHRoaXMueCA9IG0uYSAqIHggKyBtLmMgKiB5ICsgbS5lXHJcbiAgICB0aGlzLnkgPSBtLmIgKiB4ICsgbS5kICogeSArIG0uZlxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICB0b0FycmF5ICgpIHtcclxuICAgIHJldHVybiBbIHRoaXMueCwgdGhpcy55IF1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBwb2ludCAoeCwgeSkge1xyXG4gIHJldHVybiBuZXcgUG9pbnQoeCwgeSkudHJhbnNmb3JtKHRoaXMuc2NyZWVuQ1RNKCkuaW52ZXJzZSgpKVxyXG59XHJcbiIsImltcG9ydCB7IGRlbGltaXRlciB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9yZWdleC5qcydcclxuaW1wb3J0IHsgcmFkaWFucyB9IGZyb20gJy4uL3V0aWxzL3V0aWxzLmpzJ1xyXG5pbXBvcnQgeyByZWdpc3RlciB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCBFbGVtZW50IGZyb20gJy4uL2VsZW1lbnRzL0VsZW1lbnQuanMnXHJcbmltcG9ydCBQb2ludCBmcm9tICcuL1BvaW50LmpzJ1xyXG5cclxuZnVuY3Rpb24gY2xvc2VFbm91Z2ggKGEsIGIsIHRocmVzaG9sZCkge1xyXG4gIHJldHVybiBNYXRoLmFicyhiIC0gYSkgPCAodGhyZXNob2xkIHx8IDFlLTYpXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hdHJpeCB7XHJcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcclxuICAgIHRoaXMuaW5pdCguLi5hcmdzKVxyXG4gIH1cclxuXHJcbiAgLy8gSW5pdGlhbGl6ZVxyXG4gIGluaXQgKHNvdXJjZSkge1xyXG4gICAgdmFyIGJhc2UgPSBNYXRyaXguZnJvbUFycmF5KFsgMSwgMCwgMCwgMSwgMCwgMCBdKVxyXG5cclxuICAgIC8vIGVuc3VyZSBzb3VyY2UgYXMgb2JqZWN0XHJcbiAgICBzb3VyY2UgPSBzb3VyY2UgaW5zdGFuY2VvZiBFbGVtZW50ID8gc291cmNlLm1hdHJpeGlmeSgpXHJcbiAgICAgIDogdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyBNYXRyaXguZnJvbUFycmF5KHNvdXJjZS5zcGxpdChkZWxpbWl0ZXIpLm1hcChwYXJzZUZsb2F0KSlcclxuICAgICAgOiBBcnJheS5pc0FycmF5KHNvdXJjZSkgPyBNYXRyaXguZnJvbUFycmF5KHNvdXJjZSlcclxuICAgICAgOiAodHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcgJiYgTWF0cml4LmlzTWF0cml4TGlrZShzb3VyY2UpKSA/IHNvdXJjZVxyXG4gICAgICA6ICh0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0JykgPyBuZXcgTWF0cml4KCkudHJhbnNmb3JtKHNvdXJjZSlcclxuICAgICAgOiBhcmd1bWVudHMubGVuZ3RoID09PSA2ID8gTWF0cml4LmZyb21BcnJheShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXHJcbiAgICAgIDogYmFzZVxyXG5cclxuICAgIC8vIE1lcmdlIHRoZSBzb3VyY2UgbWF0cml4IHdpdGggdGhlIGJhc2UgbWF0cml4XHJcbiAgICB0aGlzLmEgPSBzb3VyY2UuYSAhPSBudWxsID8gc291cmNlLmEgOiBiYXNlLmFcclxuICAgIHRoaXMuYiA9IHNvdXJjZS5iICE9IG51bGwgPyBzb3VyY2UuYiA6IGJhc2UuYlxyXG4gICAgdGhpcy5jID0gc291cmNlLmMgIT0gbnVsbCA/IHNvdXJjZS5jIDogYmFzZS5jXHJcbiAgICB0aGlzLmQgPSBzb3VyY2UuZCAhPSBudWxsID8gc291cmNlLmQgOiBiYXNlLmRcclxuICAgIHRoaXMuZSA9IHNvdXJjZS5lICE9IG51bGwgPyBzb3VyY2UuZSA6IGJhc2UuZVxyXG4gICAgdGhpcy5mID0gc291cmNlLmYgIT0gbnVsbCA/IHNvdXJjZS5mIDogYmFzZS5mXHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8vIENsb25lcyB0aGlzIG1hdHJpeFxyXG4gIGNsb25lICgpIHtcclxuICAgIHJldHVybiBuZXcgTWF0cml4KHRoaXMpXHJcbiAgfVxyXG5cclxuICAvLyBUcmFuc2Zvcm0gYSBtYXRyaXggaW50byBhbm90aGVyIG1hdHJpeCBieSBtYW5pcHVsYXRpbmcgdGhlIHNwYWNlXHJcbiAgdHJhbnNmb3JtIChvKSB7XHJcbiAgICAvLyBDaGVjayBpZiBvIGlzIGEgbWF0cml4IGFuZCB0aGVuIGxlZnQgbXVsdGlwbHkgaXQgZGlyZWN0bHlcclxuICAgIGlmIChNYXRyaXguaXNNYXRyaXhMaWtlKG8pKSB7XHJcbiAgICAgIHZhciBtYXRyaXggPSBuZXcgTWF0cml4KG8pXHJcbiAgICAgIHJldHVybiBtYXRyaXgubXVsdGlwbHlPKHRoaXMpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2V0IHRoZSBwcm9wb3NlZCB0cmFuc2Zvcm1hdGlvbnMgYW5kIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uc1xyXG4gICAgdmFyIHQgPSBNYXRyaXguZm9ybWF0VHJhbnNmb3JtcyhvKVxyXG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzXHJcbiAgICBjb25zdCB7IHg6IG94LCB5OiBveSB9ID0gbmV3IFBvaW50KHQub3gsIHQub3kpLnRyYW5zZm9ybShjdXJyZW50KVxyXG5cclxuICAgIC8vIENvbnN0cnVjdCB0aGUgcmVzdWx0aW5nIG1hdHJpeFxyXG4gICAgdmFyIHRyYW5zZm9ybWVyID0gbmV3IE1hdHJpeCgpXHJcbiAgICAgIC50cmFuc2xhdGVPKHQucngsIHQucnkpXHJcbiAgICAgIC5sbXVsdGlwbHlPKGN1cnJlbnQpXHJcbiAgICAgIC50cmFuc2xhdGVPKC1veCwgLW95KVxyXG4gICAgICAuc2NhbGVPKHQuc2NhbGVYLCB0LnNjYWxlWSlcclxuICAgICAgLnNrZXdPKHQuc2tld1gsIHQuc2tld1kpXHJcbiAgICAgIC5zaGVhck8odC5zaGVhcilcclxuICAgICAgLnJvdGF0ZU8odC50aGV0YSlcclxuICAgICAgLnRyYW5zbGF0ZU8ob3gsIG95KVxyXG5cclxuICAgIC8vIElmIHdlIHdhbnQgdGhlIG9yaWdpbiBhdCBhIHBhcnRpY3VsYXIgcGxhY2UsIHdlIGZvcmNlIGl0IHRoZXJlXHJcbiAgICBpZiAoaXNGaW5pdGUodC5weCkgfHwgaXNGaW5pdGUodC5weSkpIHtcclxuICAgICAgY29uc3Qgb3JpZ2luID0gbmV3IFBvaW50KG94LCBveSkudHJhbnNmb3JtKHRyYW5zZm9ybWVyKVxyXG4gICAgICAvLyBUT0RPOiBSZXBsYWNlIHQucHggd2l0aCBpc0Zpbml0ZSh0LnB4KVxyXG4gICAgICBjb25zdCBkeCA9IHQucHggPyB0LnB4IC0gb3JpZ2luLnggOiAwXHJcbiAgICAgIGNvbnN0IGR5ID0gdC5weSA/IHQucHkgLSBvcmlnaW4ueSA6IDBcclxuICAgICAgdHJhbnNmb3JtZXIudHJhbnNsYXRlTyhkeCwgZHkpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gVHJhbnNsYXRlIG5vdyBhZnRlciBwb3NpdGlvbmluZ1xyXG4gICAgdHJhbnNmb3JtZXIudHJhbnNsYXRlTyh0LnR4LCB0LnR5KVxyXG4gICAgcmV0dXJuIHRyYW5zZm9ybWVyXHJcbiAgfVxyXG5cclxuICAvLyBBcHBsaWVzIGEgbWF0cml4IGRlZmluZWQgYnkgaXRzIGFmZmluZSBwYXJhbWV0ZXJzXHJcbiAgY29tcG9zZSAobykge1xyXG4gICAgaWYgKG8ub3JpZ2luKSB7XHJcbiAgICAgIG8ub3JpZ2luWCA9IG8ub3JpZ2luWzBdXHJcbiAgICAgIG8ub3JpZ2luWSA9IG8ub3JpZ2luWzFdXHJcbiAgICB9XHJcbiAgICAvLyBHZXQgdGhlIHBhcmFtZXRlcnNcclxuICAgIHZhciBveCA9IG8ub3JpZ2luWCB8fCAwXHJcbiAgICB2YXIgb3kgPSBvLm9yaWdpblkgfHwgMFxyXG4gICAgdmFyIHN4ID0gby5zY2FsZVggfHwgMVxyXG4gICAgdmFyIHN5ID0gby5zY2FsZVkgfHwgMVxyXG4gICAgdmFyIGxhbSA9IG8uc2hlYXIgfHwgMFxyXG4gICAgdmFyIHRoZXRhID0gby5yb3RhdGUgfHwgMFxyXG4gICAgdmFyIHR4ID0gby50cmFuc2xhdGVYIHx8IDBcclxuICAgIHZhciB0eSA9IG8udHJhbnNsYXRlWSB8fCAwXHJcblxyXG4gICAgLy8gQXBwbHkgdGhlIHN0YW5kYXJkIG1hdHJpeFxyXG4gICAgdmFyIHJlc3VsdCA9IG5ldyBNYXRyaXgoKVxyXG4gICAgICAudHJhbnNsYXRlTygtb3gsIC1veSlcclxuICAgICAgLnNjYWxlTyhzeCwgc3kpXHJcbiAgICAgIC5zaGVhck8obGFtKVxyXG4gICAgICAucm90YXRlTyh0aGV0YSlcclxuICAgICAgLnRyYW5zbGF0ZU8odHgsIHR5KVxyXG4gICAgICAubG11bHRpcGx5Tyh0aGlzKVxyXG4gICAgICAudHJhbnNsYXRlTyhveCwgb3kpXHJcbiAgICByZXR1cm4gcmVzdWx0XHJcbiAgfVxyXG5cclxuICAvLyBEZWNvbXBvc2VzIHRoaXMgbWF0cml4IGludG8gaXRzIGFmZmluZSBwYXJhbWV0ZXJzXHJcbiAgZGVjb21wb3NlIChjeCA9IDAsIGN5ID0gMCkge1xyXG4gICAgLy8gR2V0IHRoZSBwYXJhbWV0ZXJzIGZyb20gdGhlIG1hdHJpeFxyXG4gICAgdmFyIGEgPSB0aGlzLmFcclxuICAgIHZhciBiID0gdGhpcy5iXHJcbiAgICB2YXIgYyA9IHRoaXMuY1xyXG4gICAgdmFyIGQgPSB0aGlzLmRcclxuICAgIHZhciBlID0gdGhpcy5lXHJcbiAgICB2YXIgZiA9IHRoaXMuZlxyXG5cclxuICAgIC8vIEZpZ3VyZSBvdXQgaWYgdGhlIHdpbmRpbmcgZGlyZWN0aW9uIGlzIGNsb2Nrd2lzZSBvciBjb3VudGVyY2xvY2t3aXNlXHJcbiAgICB2YXIgZGV0ZXJtaW5hbnQgPSBhICogZCAtIGIgKiBjXHJcbiAgICB2YXIgY2N3ID0gZGV0ZXJtaW5hbnQgPiAwID8gMSA6IC0xXHJcblxyXG4gICAgLy8gU2luY2Ugd2Ugb25seSBzaGVhciBpbiB4LCB3ZSBjYW4gdXNlIHRoZSB4IGJhc2lzIHRvIGdldCB0aGUgeCBzY2FsZVxyXG4gICAgLy8gYW5kIHRoZSByb3RhdGlvbiBvZiB0aGUgcmVzdWx0aW5nIG1hdHJpeFxyXG4gICAgdmFyIHN4ID0gY2N3ICogTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpXHJcbiAgICB2YXIgdGhldGFSYWQgPSBNYXRoLmF0YW4yKGNjdyAqIGIsIGNjdyAqIGEpXHJcbiAgICB2YXIgdGhldGEgPSAxODAgLyBNYXRoLlBJICogdGhldGFSYWRcclxuICAgIHZhciBjdCA9IE1hdGguY29zKHRoZXRhUmFkKVxyXG4gICAgdmFyIHN0ID0gTWF0aC5zaW4odGhldGFSYWQpXHJcblxyXG4gICAgLy8gV2UgY2FuIHRoZW4gc29sdmUgdGhlIHkgYmFzaXMgdmVjdG9yIHNpbXVsdGFuZW91c2x5IHRvIGdldCB0aGUgb3RoZXJcclxuICAgIC8vIHR3byBhZmZpbmUgcGFyYW1ldGVycyBkaXJlY3RseSBmcm9tIHRoZXNlIHBhcmFtZXRlcnNcclxuICAgIHZhciBsYW0gPSAoYSAqIGMgKyBiICogZCkgLyBkZXRlcm1pbmFudFxyXG4gICAgdmFyIHN5ID0gKChjICogc3gpIC8gKGxhbSAqIGEgLSBiKSkgfHwgKChkICogc3gpIC8gKGxhbSAqIGIgKyBhKSlcclxuXHJcbiAgICAvLyBVc2UgdGhlIHRyYW5zbGF0aW9uc1xyXG4gICAgY29uc3QgdHggPSBlIC0gY3ggKyBjeCAqIGN0ICogc3ggKyBjeSAqIChsYW0gKiBjdCAqIHN4IC0gc3QgKiBzeSlcclxuICAgIGNvbnN0IHR5ID0gZiAtIGN5ICsgY3ggKiBzdCAqIHN4ICsgY3kgKiAobGFtICogc3QgKiBzeCArIGN0ICogc3kpXHJcblxyXG4gICAgLy8gQ29uc3RydWN0IHRoZSBkZWNvbXBvc2l0aW9uIGFuZCByZXR1cm4gaXRcclxuICAgIHJldHVybiB7XHJcbiAgICAgIC8vIFJldHVybiB0aGUgYWZmaW5lIHBhcmFtZXRlcnNcclxuICAgICAgc2NhbGVYOiBzeCxcclxuICAgICAgc2NhbGVZOiBzeSxcclxuICAgICAgc2hlYXI6IGxhbSxcclxuICAgICAgcm90YXRlOiB0aGV0YSxcclxuICAgICAgdHJhbnNsYXRlWDogdHgsXHJcbiAgICAgIHRyYW5zbGF0ZVk6IHR5LFxyXG4gICAgICBvcmlnaW5YOiBjeCxcclxuICAgICAgb3JpZ2luWTogY3ksXHJcblxyXG4gICAgICAvLyBSZXR1cm4gdGhlIG1hdHJpeCBwYXJhbWV0ZXJzXHJcbiAgICAgIGE6IHRoaXMuYSxcclxuICAgICAgYjogdGhpcy5iLFxyXG4gICAgICBjOiB0aGlzLmMsXHJcbiAgICAgIGQ6IHRoaXMuZCxcclxuICAgICAgZTogdGhpcy5lLFxyXG4gICAgICBmOiB0aGlzLmZcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIExlZnQgbXVsdGlwbGllcyBieSB0aGUgZ2l2ZW4gbWF0cml4XHJcbiAgbXVsdGlwbHkgKG1hdHJpeCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5tdWx0aXBseU8obWF0cml4KVxyXG4gIH1cclxuXHJcbiAgbXVsdGlwbHlPIChtYXRyaXgpIHtcclxuICAgIC8vIEdldCB0aGUgbWF0cmljZXNcclxuICAgIHZhciBsID0gdGhpc1xyXG4gICAgdmFyIHIgPSBtYXRyaXggaW5zdGFuY2VvZiBNYXRyaXhcclxuICAgICAgPyBtYXRyaXhcclxuICAgICAgOiBuZXcgTWF0cml4KG1hdHJpeClcclxuXHJcbiAgICByZXR1cm4gTWF0cml4Lm1hdHJpeE11bHRpcGx5KGwsIHIsIHRoaXMpXHJcbiAgfVxyXG5cclxuICBsbXVsdGlwbHkgKG1hdHJpeCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5sbXVsdGlwbHlPKG1hdHJpeClcclxuICB9XHJcblxyXG4gIGxtdWx0aXBseU8gKG1hdHJpeCkge1xyXG4gICAgdmFyIHIgPSB0aGlzXHJcbiAgICB2YXIgbCA9IG1hdHJpeCBpbnN0YW5jZW9mIE1hdHJpeFxyXG4gICAgICA/IG1hdHJpeFxyXG4gICAgICA6IG5ldyBNYXRyaXgobWF0cml4KVxyXG5cclxuICAgIHJldHVybiBNYXRyaXgubWF0cml4TXVsdGlwbHkobCwgciwgdGhpcylcclxuICB9XHJcblxyXG4gIC8vIEludmVyc2VzIG1hdHJpeFxyXG4gIGludmVyc2VPICgpIHtcclxuICAgIC8vIEdldCB0aGUgY3VycmVudCBwYXJhbWV0ZXJzIG91dCBvZiB0aGUgbWF0cml4XHJcbiAgICB2YXIgYSA9IHRoaXMuYVxyXG4gICAgdmFyIGIgPSB0aGlzLmJcclxuICAgIHZhciBjID0gdGhpcy5jXHJcbiAgICB2YXIgZCA9IHRoaXMuZFxyXG4gICAgdmFyIGUgPSB0aGlzLmVcclxuICAgIHZhciBmID0gdGhpcy5mXHJcblxyXG4gICAgLy8gSW52ZXJ0IHRoZSAyeDIgbWF0cml4IGluIHRoZSB0b3AgbGVmdFxyXG4gICAgdmFyIGRldCA9IGEgKiBkIC0gYiAqIGNcclxuICAgIGlmICghZGV0KSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnZlcnQgJyArIHRoaXMpXHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSB0b3AgMngyIG1hdHJpeFxyXG4gICAgdmFyIG5hID0gZCAvIGRldFxyXG4gICAgdmFyIG5iID0gLWIgLyBkZXRcclxuICAgIHZhciBuYyA9IC1jIC8gZGV0XHJcbiAgICB2YXIgbmQgPSBhIC8gZGV0XHJcblxyXG4gICAgLy8gQXBwbHkgdGhlIGludmVydGVkIG1hdHJpeCB0byB0aGUgdG9wIHJpZ2h0XHJcbiAgICB2YXIgbmUgPSAtKG5hICogZSArIG5jICogZilcclxuICAgIHZhciBuZiA9IC0obmIgKiBlICsgbmQgKiBmKVxyXG5cclxuICAgIC8vIENvbnN0cnVjdCB0aGUgaW52ZXJ0ZWQgbWF0cml4XHJcbiAgICB0aGlzLmEgPSBuYVxyXG4gICAgdGhpcy5iID0gbmJcclxuICAgIHRoaXMuYyA9IG5jXHJcbiAgICB0aGlzLmQgPSBuZFxyXG4gICAgdGhpcy5lID0gbmVcclxuICAgIHRoaXMuZiA9IG5mXHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIGludmVyc2UgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbnZlcnNlTygpXHJcbiAgfVxyXG5cclxuICAvLyBUcmFuc2xhdGUgbWF0cml4XHJcbiAgdHJhbnNsYXRlICh4LCB5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnRyYW5zbGF0ZU8oeCwgeSlcclxuICB9XHJcblxyXG4gIHRyYW5zbGF0ZU8gKHgsIHkpIHtcclxuICAgIHRoaXMuZSArPSB4IHx8IDBcclxuICAgIHRoaXMuZiArPSB5IHx8IDBcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvLyBTY2FsZSBtYXRyaXhcclxuICBzY2FsZSAoeCwgeSwgY3gsIGN5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnNjYWxlTyguLi5hcmd1bWVudHMpXHJcbiAgfVxyXG5cclxuICBzY2FsZU8gKHgsIHkgPSB4LCBjeCA9IDAsIGN5ID0gMCkge1xyXG4gICAgLy8gU3VwcG9ydCB1bmlmb3JtIHNjYWxpbmdcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XHJcbiAgICAgIGN5ID0gY3hcclxuICAgICAgY3ggPSB5XHJcbiAgICAgIHkgPSB4XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeyBhLCBiLCBjLCBkLCBlLCBmIH0gPSB0aGlzXHJcblxyXG4gICAgdGhpcy5hID0gYSAqIHhcclxuICAgIHRoaXMuYiA9IGIgKiB5XHJcbiAgICB0aGlzLmMgPSBjICogeFxyXG4gICAgdGhpcy5kID0gZCAqIHlcclxuICAgIHRoaXMuZSA9IGUgKiB4IC0gY3ggKiB4ICsgY3hcclxuICAgIHRoaXMuZiA9IGYgKiB5IC0gY3kgKiB5ICsgY3lcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgLy8gUm90YXRlIG1hdHJpeFxyXG4gIHJvdGF0ZSAociwgY3gsIGN5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnJvdGF0ZU8ociwgY3gsIGN5KVxyXG4gIH1cclxuXHJcbiAgcm90YXRlTyAociwgY3ggPSAwLCBjeSA9IDApIHtcclxuICAgIC8vIENvbnZlcnQgZGVncmVlcyB0byByYWRpYW5zXHJcbiAgICByID0gcmFkaWFucyhyKVxyXG5cclxuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKHIpXHJcbiAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihyKVxyXG5cclxuICAgIGNvbnN0IHsgYSwgYiwgYywgZCwgZSwgZiB9ID0gdGhpc1xyXG5cclxuICAgIHRoaXMuYSA9IGEgKiBjb3MgLSBiICogc2luXHJcbiAgICB0aGlzLmIgPSBiICogY29zICsgYSAqIHNpblxyXG4gICAgdGhpcy5jID0gYyAqIGNvcyAtIGQgKiBzaW5cclxuICAgIHRoaXMuZCA9IGQgKiBjb3MgKyBjICogc2luXHJcbiAgICB0aGlzLmUgPSBlICogY29zIC0gZiAqIHNpbiArIGN5ICogc2luIC0gY3ggKiBjb3MgKyBjeFxyXG4gICAgdGhpcy5mID0gZiAqIGNvcyArIGUgKiBzaW4gLSBjeCAqIHNpbiAtIGN5ICogY29zICsgY3lcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgLy8gRmxpcCBtYXRyaXggb24geCBvciB5LCBhdCBhIGdpdmVuIG9mZnNldFxyXG4gIGZsaXAgKGF4aXMsIGFyb3VuZCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5mbGlwTyhheGlzLCBhcm91bmQpXHJcbiAgfVxyXG5cclxuICBmbGlwTyAoYXhpcywgYXJvdW5kKSB7XHJcbiAgICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gdGhpcy5zY2FsZU8oLTEsIDEsIGFyb3VuZCwgMClcclxuICAgICAgOiBheGlzID09PSAneScgPyB0aGlzLnNjYWxlTygxLCAtMSwgMCwgYXJvdW5kKVxyXG4gICAgICA6IHRoaXMuc2NhbGVPKC0xLCAtMSwgYXhpcywgYXJvdW5kIHx8IGF4aXMpIC8vIERlZmluZSBhbiB4LCB5IGZsaXAgcG9pbnRcclxuICB9XHJcblxyXG4gIC8vIFNoZWFyIG1hdHJpeFxyXG4gIHNoZWFyIChhLCBjeCwgY3kpIHtcclxuICAgIHJldHVybiB0aGlzLmNsb25lKCkuc2hlYXJPKGEsIGN4LCBjeSlcclxuICB9XHJcblxyXG4gIHNoZWFyTyAobHgsIGN4ID0gMCwgY3kgPSAwKSB7XHJcbiAgICBjb25zdCB7IGEsIGIsIGMsIGQsIGUsIGYgfSA9IHRoaXNcclxuXHJcbiAgICB0aGlzLmEgPSBhICsgYiAqIGx4XHJcbiAgICB0aGlzLmMgPSBjICsgZCAqIGx4XHJcbiAgICB0aGlzLmUgPSBlICsgZiAqIGx4IC0gY3kgKiBseFxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvLyBTa2V3IE1hdHJpeFxyXG4gIHNrZXcgKHgsIHksIGN4LCBjeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5za2V3TyguLi5hcmd1bWVudHMpXHJcbiAgfVxyXG5cclxuICBza2V3TyAoeCwgeSA9IHgsIGN4ID0gMCwgY3kgPSAwKSB7XHJcbiAgICAvLyBzdXBwb3J0IHVuaWZvcm1hbCBza2V3XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xyXG4gICAgICBjeSA9IGN4XHJcbiAgICAgIGN4ID0geVxyXG4gICAgICB5ID0geFxyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbnZlcnQgZGVncmVlcyB0byByYWRpYW5zXHJcbiAgICB4ID0gcmFkaWFucyh4KVxyXG4gICAgeSA9IHJhZGlhbnMoeSlcclxuXHJcbiAgICBjb25zdCBseCA9IE1hdGgudGFuKHgpXHJcbiAgICBjb25zdCBseSA9IE1hdGgudGFuKHkpXHJcblxyXG4gICAgY29uc3QgeyBhLCBiLCBjLCBkLCBlLCBmIH0gPSB0aGlzXHJcblxyXG4gICAgdGhpcy5hID0gYSArIGIgKiBseFxyXG4gICAgdGhpcy5iID0gYiArIGEgKiBseVxyXG4gICAgdGhpcy5jID0gYyArIGQgKiBseFxyXG4gICAgdGhpcy5kID0gZCArIGMgKiBseVxyXG4gICAgdGhpcy5lID0gZSArIGYgKiBseCAtIGN5ICogbHhcclxuICAgIHRoaXMuZiA9IGYgKyBlICogbHkgLSBjeCAqIGx5XHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8vIFNrZXdYXHJcbiAgc2tld1ggKHgsIGN4LCBjeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2tldyh4LCAwLCBjeCwgY3kpXHJcbiAgfVxyXG5cclxuICBza2V3WE8gKHgsIGN4LCBjeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2tld08oeCwgMCwgY3gsIGN5KVxyXG4gIH1cclxuXHJcbiAgLy8gU2tld1lcclxuICBza2V3WSAoeSwgY3gsIGN5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5za2V3KDAsIHksIGN4LCBjeSlcclxuICB9XHJcblxyXG4gIHNrZXdZTyAoeSwgY3gsIGN5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5za2V3TygwLCB5LCBjeCwgY3kpXHJcbiAgfVxyXG5cclxuICAvLyBUcmFuc2Zvcm0gYXJvdW5kIGEgY2VudGVyIHBvaW50XHJcbiAgYXJvdW5kTyAoY3gsIGN5LCBtYXRyaXgpIHtcclxuICAgIHZhciBkeCA9IGN4IHx8IDBcclxuICAgIHZhciBkeSA9IGN5IHx8IDBcclxuICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZU8oLWR4LCAtZHkpLmxtdWx0aXBseU8obWF0cml4KS50cmFuc2xhdGVPKGR4LCBkeSlcclxuICB9XHJcblxyXG4gIGFyb3VuZCAoY3gsIGN5LCBtYXRyaXgpIHtcclxuICAgIHJldHVybiB0aGlzLmNsb25lKCkuYXJvdW5kTyhjeCwgY3ksIG1hdHJpeClcclxuICB9XHJcblxyXG4gIC8vIENoZWNrIGlmIHR3byBtYXRyaWNlcyBhcmUgZXF1YWxcclxuICBlcXVhbHMgKG90aGVyKSB7XHJcbiAgICB2YXIgY29tcCA9IG5ldyBNYXRyaXgob3RoZXIpXHJcbiAgICByZXR1cm4gY2xvc2VFbm91Z2godGhpcy5hLCBjb21wLmEpICYmIGNsb3NlRW5vdWdoKHRoaXMuYiwgY29tcC5iKVxyXG4gICAgICAmJiBjbG9zZUVub3VnaCh0aGlzLmMsIGNvbXAuYykgJiYgY2xvc2VFbm91Z2godGhpcy5kLCBjb21wLmQpXHJcbiAgICAgICYmIGNsb3NlRW5vdWdoKHRoaXMuZSwgY29tcC5lKSAmJiBjbG9zZUVub3VnaCh0aGlzLmYsIGNvbXAuZilcclxuICB9XHJcblxyXG4gIC8vIENvbnZlcnQgbWF0cml4IHRvIHN0cmluZ1xyXG4gIHRvU3RyaW5nICgpIHtcclxuICAgIHJldHVybiAnbWF0cml4KCcgKyB0aGlzLmEgKyAnLCcgKyB0aGlzLmIgKyAnLCcgKyB0aGlzLmMgKyAnLCcgKyB0aGlzLmQgKyAnLCcgKyB0aGlzLmUgKyAnLCcgKyB0aGlzLmYgKyAnKSdcclxuICB9XHJcblxyXG4gIHRvQXJyYXkgKCkge1xyXG4gICAgcmV0dXJuIFsgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgdGhpcy5kLCB0aGlzLmUsIHRoaXMuZiBdXHJcbiAgfVxyXG5cclxuICB2YWx1ZU9mICgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGE6IHRoaXMuYSxcclxuICAgICAgYjogdGhpcy5iLFxyXG4gICAgICBjOiB0aGlzLmMsXHJcbiAgICAgIGQ6IHRoaXMuZCxcclxuICAgICAgZTogdGhpcy5lLFxyXG4gICAgICBmOiB0aGlzLmZcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0YXRpYyBmcm9tQXJyYXkgKGEpIHtcclxuICAgIHJldHVybiB7IGE6IGFbMF0sIGI6IGFbMV0sIGM6IGFbMl0sIGQ6IGFbM10sIGU6IGFbNF0sIGY6IGFbNV0gfVxyXG4gIH1cclxuXHJcbiAgc3RhdGljIGlzTWF0cml4TGlrZSAobykge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgby5hICE9IG51bGxcclxuICAgICAgfHwgby5iICE9IG51bGxcclxuICAgICAgfHwgby5jICE9IG51bGxcclxuICAgICAgfHwgby5kICE9IG51bGxcclxuICAgICAgfHwgby5lICE9IG51bGxcclxuICAgICAgfHwgby5mICE9IG51bGxcclxuICAgIClcclxuICB9XHJcblxyXG4gIHN0YXRpYyBmb3JtYXRUcmFuc2Zvcm1zIChvKSB7XHJcbiAgICAvLyBHZXQgYWxsIG9mIHRoZSBwYXJhbWV0ZXJzIHJlcXVpcmVkIHRvIGZvcm0gdGhlIG1hdHJpeFxyXG4gICAgdmFyIGZsaXBCb3RoID0gby5mbGlwID09PSAnYm90aCcgfHwgby5mbGlwID09PSB0cnVlXHJcbiAgICB2YXIgZmxpcFggPSBvLmZsaXAgJiYgKGZsaXBCb3RoIHx8IG8uZmxpcCA9PT0gJ3gnKSA/IC0xIDogMVxyXG4gICAgdmFyIGZsaXBZID0gby5mbGlwICYmIChmbGlwQm90aCB8fCBvLmZsaXAgPT09ICd5JykgPyAtMSA6IDFcclxuICAgIHZhciBza2V3WCA9IG8uc2tldyAmJiBvLnNrZXcubGVuZ3RoID8gby5za2V3WzBdXHJcbiAgICAgIDogaXNGaW5pdGUoby5za2V3KSA/IG8uc2tld1xyXG4gICAgICA6IGlzRmluaXRlKG8uc2tld1gpID8gby5za2V3WFxyXG4gICAgICA6IDBcclxuICAgIHZhciBza2V3WSA9IG8uc2tldyAmJiBvLnNrZXcubGVuZ3RoID8gby5za2V3WzFdXHJcbiAgICAgIDogaXNGaW5pdGUoby5za2V3KSA/IG8uc2tld1xyXG4gICAgICA6IGlzRmluaXRlKG8uc2tld1kpID8gby5za2V3WVxyXG4gICAgICA6IDBcclxuICAgIHZhciBzY2FsZVggPSBvLnNjYWxlICYmIG8uc2NhbGUubGVuZ3RoID8gby5zY2FsZVswXSAqIGZsaXBYXHJcbiAgICAgIDogaXNGaW5pdGUoby5zY2FsZSkgPyBvLnNjYWxlICogZmxpcFhcclxuICAgICAgOiBpc0Zpbml0ZShvLnNjYWxlWCkgPyBvLnNjYWxlWCAqIGZsaXBYXHJcbiAgICAgIDogZmxpcFhcclxuICAgIHZhciBzY2FsZVkgPSBvLnNjYWxlICYmIG8uc2NhbGUubGVuZ3RoID8gby5zY2FsZVsxXSAqIGZsaXBZXHJcbiAgICAgIDogaXNGaW5pdGUoby5zY2FsZSkgPyBvLnNjYWxlICogZmxpcFlcclxuICAgICAgOiBpc0Zpbml0ZShvLnNjYWxlWSkgPyBvLnNjYWxlWSAqIGZsaXBZXHJcbiAgICAgIDogZmxpcFlcclxuICAgIHZhciBzaGVhciA9IG8uc2hlYXIgfHwgMFxyXG4gICAgdmFyIHRoZXRhID0gby5yb3RhdGUgfHwgby50aGV0YSB8fCAwXHJcbiAgICB2YXIgb3JpZ2luID0gbmV3IFBvaW50KG8ub3JpZ2luIHx8IG8uYXJvdW5kIHx8IG8ub3ggfHwgby5vcmlnaW5YLCBvLm95IHx8IG8ub3JpZ2luWSlcclxuICAgIHZhciBveCA9IG9yaWdpbi54XHJcbiAgICB2YXIgb3kgPSBvcmlnaW4ueVxyXG4gICAgdmFyIHBvc2l0aW9uID0gbmV3IFBvaW50KG8ucG9zaXRpb24gfHwgby5weCB8fCBvLnBvc2l0aW9uWCwgby5weSB8fCBvLnBvc2l0aW9uWSlcclxuICAgIHZhciBweCA9IHBvc2l0aW9uLnhcclxuICAgIHZhciBweSA9IHBvc2l0aW9uLnlcclxuICAgIHZhciB0cmFuc2xhdGUgPSBuZXcgUG9pbnQoby50cmFuc2xhdGUgfHwgby50eCB8fCBvLnRyYW5zbGF0ZVgsIG8udHkgfHwgby50cmFuc2xhdGVZKVxyXG4gICAgdmFyIHR4ID0gdHJhbnNsYXRlLnhcclxuICAgIHZhciB0eSA9IHRyYW5zbGF0ZS55XHJcbiAgICB2YXIgcmVsYXRpdmUgPSBuZXcgUG9pbnQoby5yZWxhdGl2ZSB8fCBvLnJ4IHx8IG8ucmVsYXRpdmVYLCBvLnJ5IHx8IG8ucmVsYXRpdmVZKVxyXG4gICAgdmFyIHJ4ID0gcmVsYXRpdmUueFxyXG4gICAgdmFyIHJ5ID0gcmVsYXRpdmUueVxyXG5cclxuICAgIC8vIFBvcHVsYXRlIGFsbCBvZiB0aGUgdmFsdWVzXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzY2FsZVgsIHNjYWxlWSwgc2tld1gsIHNrZXdZLCBzaGVhciwgdGhldGEsIHJ4LCByeSwgdHgsIHR5LCBveCwgb3ksIHB4LCBweVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gbGVmdCBtYXRyaXgsIHJpZ2h0IG1hdHJpeCwgdGFyZ2V0IG1hdHJpeCB3aGljaCBpcyBvdmVyd3JpdHRlblxyXG4gIHN0YXRpYyBtYXRyaXhNdWx0aXBseSAobCwgciwgbykge1xyXG4gICAgLy8gV29yayBvdXQgdGhlIHByb2R1Y3QgZGlyZWN0bHlcclxuICAgIHZhciBhID0gbC5hICogci5hICsgbC5jICogci5iXHJcbiAgICB2YXIgYiA9IGwuYiAqIHIuYSArIGwuZCAqIHIuYlxyXG4gICAgdmFyIGMgPSBsLmEgKiByLmMgKyBsLmMgKiByLmRcclxuICAgIHZhciBkID0gbC5iICogci5jICsgbC5kICogci5kXHJcbiAgICB2YXIgZSA9IGwuZSArIGwuYSAqIHIuZSArIGwuYyAqIHIuZlxyXG4gICAgdmFyIGYgPSBsLmYgKyBsLmIgKiByLmUgKyBsLmQgKiByLmZcclxuXHJcbiAgICAvLyBtYWtlIHN1cmUgdG8gdXNlIGxvY2FsIHZhcmlhYmxlcyBiZWNhdXNlIGwvciBhbmQgbyBjb3VsZCBiZSB0aGUgc2FtZVxyXG4gICAgby5hID0gYVxyXG4gICAgby5iID0gYlxyXG4gICAgby5jID0gY1xyXG4gICAgby5kID0gZFxyXG4gICAgby5lID0gZVxyXG4gICAgby5mID0gZlxyXG5cclxuICAgIHJldHVybiBvXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3RtICgpIHtcclxuICByZXR1cm4gbmV3IE1hdHJpeCh0aGlzLm5vZGUuZ2V0Q1RNKCkpXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzY3JlZW5DVE0gKCkge1xyXG4gIC8qIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzNDQ1MzdcclxuICAgICBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIEZGIGRvZXMgbm90IHJldHVybiB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4XHJcbiAgICAgZm9yIHRoZSBpbm5lciBjb29yZGluYXRlIHN5c3RlbSB3aGVuIGdldFNjcmVlbkNUTSgpIGlzIGNhbGxlZCBvbiBuZXN0ZWQgc3Zncy5cclxuICAgICBIb3dldmVyIGFsbCBvdGhlciBCcm93c2VycyBkbyB0aGF0ICovXHJcbiAgaWYgKHR5cGVvZiB0aGlzLmlzUm9vdCA9PT0gJ2Z1bmN0aW9uJyAmJiAhdGhpcy5pc1Jvb3QoKSkge1xyXG4gICAgdmFyIHJlY3QgPSB0aGlzLnJlY3QoMSwgMSlcclxuICAgIHZhciBtID0gcmVjdC5ub2RlLmdldFNjcmVlbkNUTSgpXHJcbiAgICByZWN0LnJlbW92ZSgpXHJcbiAgICByZXR1cm4gbmV3IE1hdHJpeChtKVxyXG4gIH1cclxuICByZXR1cm4gbmV3IE1hdHJpeCh0aGlzLm5vZGUuZ2V0U2NyZWVuQ1RNKCkpXHJcbn1cclxuXHJcbnJlZ2lzdGVyKE1hdHJpeCwgJ01hdHJpeCcpXHJcbiIsImltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuLi8uLi91dGlscy93aW5kb3cuanMnXHJcbmltcG9ydCB7IG1ha2VJbnN0YW5jZSB9IGZyb20gJy4uLy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwYXJzZXIgKCkge1xyXG4gIC8vIFJldXNlIGNhY2hlZCBlbGVtZW50IGlmIHBvc3NpYmxlXHJcbiAgaWYgKCFwYXJzZXIubm9kZXMpIHtcclxuICAgIGNvbnN0IHN2ZyA9IG1ha2VJbnN0YW5jZSgpLnNpemUoMiwgMClcclxuICAgIHN2Zy5ub2RlLnN0eWxlLmNzc1RleHQgPSBbXHJcbiAgICAgICdvcGFjaXR5OiAwJyxcclxuICAgICAgJ3Bvc2l0aW9uOiBhYnNvbHV0ZScsXHJcbiAgICAgICdsZWZ0OiAtMTAwJScsXHJcbiAgICAgICd0b3A6IC0xMDAlJyxcclxuICAgICAgJ292ZXJmbG93OiBoaWRkZW4nXHJcbiAgICBdLmpvaW4oJzsnKVxyXG5cclxuICAgIHN2Zy5hdHRyKCdmb2N1c2FibGUnLCAnZmFsc2UnKVxyXG4gICAgc3ZnLmF0dHIoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKVxyXG5cclxuICAgIGNvbnN0IHBhdGggPSBzdmcucGF0aCgpLm5vZGVcclxuXHJcbiAgICBwYXJzZXIubm9kZXMgPSB7IHN2ZywgcGF0aCB9XHJcbiAgfVxyXG5cclxuICBpZiAoIXBhcnNlci5ub2Rlcy5zdmcubm9kZS5wYXJlbnROb2RlKSB7XHJcbiAgICBjb25zdCBiID0gZ2xvYmFscy5kb2N1bWVudC5ib2R5IHx8IGdsb2JhbHMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XHJcbiAgICBwYXJzZXIubm9kZXMuc3ZnLmFkZFRvKGIpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gcGFyc2VyLm5vZGVzXHJcbn1cclxuIiwiaW1wb3J0IHsgZGVsaW1pdGVyIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3JlZ2V4LmpzJ1xyXG5pbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi4vdXRpbHMvd2luZG93LmpzJ1xyXG5pbXBvcnQgeyByZWdpc3RlciB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXHJcbmltcG9ydCBNYXRyaXggZnJvbSAnLi9NYXRyaXguanMnXHJcbmltcG9ydCBQb2ludCBmcm9tICcuL1BvaW50LmpzJ1xyXG5pbXBvcnQgcGFyc2VyIGZyb20gJy4uL21vZHVsZXMvY29yZS9wYXJzZXIuanMnXHJcblxyXG5mdW5jdGlvbiBpc051bGxlZEJveCAoYm94KSB7XHJcbiAgcmV0dXJuICFib3gud2lkdGggJiYgIWJveC5oZWlnaHQgJiYgIWJveC54ICYmICFib3gueVxyXG59XHJcblxyXG5mdW5jdGlvbiBkb21Db250YWlucyAobm9kZSkge1xyXG4gIHJldHVybiBub2RlID09PSBnbG9iYWxzLmRvY3VtZW50XHJcbiAgICB8fCAoZ2xvYmFscy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMgfHwgZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgLy8gVGhpcyBpcyBJRSAtIGl0IGRvZXMgbm90IHN1cHBvcnQgY29udGFpbnMoKSBmb3IgdG9wLWxldmVsIFNWR3NcclxuICAgICAgd2hpbGUgKG5vZGUucGFyZW50Tm9kZSkge1xyXG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGVcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbm9kZSA9PT0gZ2xvYmFscy5kb2N1bWVudFxyXG4gICAgfSkuY2FsbChnbG9iYWxzLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSlcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQm94IHtcclxuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xyXG4gICAgdGhpcy5pbml0KC4uLmFyZ3MpXHJcbiAgfVxyXG5cclxuICBpbml0IChzb3VyY2UpIHtcclxuICAgIHZhciBiYXNlID0gWyAwLCAwLCAwLCAwIF1cclxuICAgIHNvdXJjZSA9IHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnID8gc291cmNlLnNwbGl0KGRlbGltaXRlcikubWFwKHBhcnNlRmxvYXQpXHJcbiAgICAgIDogQXJyYXkuaXNBcnJheShzb3VyY2UpID8gc291cmNlXHJcbiAgICAgIDogdHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcgPyBbIHNvdXJjZS5sZWZ0ICE9IG51bGwgPyBzb3VyY2UubGVmdFxyXG4gICAgICA6IHNvdXJjZS54LCBzb3VyY2UudG9wICE9IG51bGwgPyBzb3VyY2UudG9wIDogc291cmNlLnksIHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodCBdXHJcbiAgICAgIDogYXJndW1lbnRzLmxlbmd0aCA9PT0gNCA/IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxyXG4gICAgICA6IGJhc2VcclxuXHJcbiAgICB0aGlzLnggPSBzb3VyY2VbMF0gfHwgMFxyXG4gICAgdGhpcy55ID0gc291cmNlWzFdIHx8IDBcclxuICAgIHRoaXMud2lkdGggPSB0aGlzLncgPSBzb3VyY2VbMl0gfHwgMFxyXG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmggPSBzb3VyY2VbM10gfHwgMFxyXG5cclxuICAgIC8vIEFkZCBtb3JlIGJvdW5kaW5nIGJveCBwcm9wZXJ0aWVzXHJcbiAgICB0aGlzLngyID0gdGhpcy54ICsgdGhpcy53XHJcbiAgICB0aGlzLnkyID0gdGhpcy55ICsgdGhpcy5oXHJcbiAgICB0aGlzLmN4ID0gdGhpcy54ICsgdGhpcy53IC8gMlxyXG4gICAgdGhpcy5jeSA9IHRoaXMueSArIHRoaXMuaCAvIDJcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgLy8gTWVyZ2UgcmVjdCBib3ggd2l0aCBhbm90aGVyLCByZXR1cm4gYSBuZXcgaW5zdGFuY2VcclxuICBtZXJnZSAoYm94KSB7XHJcbiAgICBjb25zdCB4ID0gTWF0aC5taW4odGhpcy54LCBib3gueClcclxuICAgIGNvbnN0IHkgPSBNYXRoLm1pbih0aGlzLnksIGJveC55KVxyXG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heCh0aGlzLnggKyB0aGlzLndpZHRoLCBib3gueCArIGJveC53aWR0aCkgLSB4XHJcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1heCh0aGlzLnkgKyB0aGlzLmhlaWdodCwgYm94LnkgKyBib3guaGVpZ2h0KSAtIHlcclxuXHJcbiAgICByZXR1cm4gbmV3IEJveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxyXG4gIH1cclxuXHJcbiAgdHJhbnNmb3JtIChtKSB7XHJcbiAgICBpZiAoIShtIGluc3RhbmNlb2YgTWF0cml4KSkge1xyXG4gICAgICBtID0gbmV3IE1hdHJpeChtKVxyXG4gICAgfVxyXG5cclxuICAgIGxldCB4TWluID0gSW5maW5pdHlcclxuICAgIGxldCB4TWF4ID0gLUluZmluaXR5XHJcbiAgICBsZXQgeU1pbiA9IEluZmluaXR5XHJcbiAgICBsZXQgeU1heCA9IC1JbmZpbml0eVxyXG5cclxuICAgIGNvbnN0IHB0cyA9IFtcclxuICAgICAgbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KSxcclxuICAgICAgbmV3IFBvaW50KHRoaXMueDIsIHRoaXMueSksXHJcbiAgICAgIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueTIpLFxyXG4gICAgICBuZXcgUG9pbnQodGhpcy54MiwgdGhpcy55MilcclxuICAgIF1cclxuXHJcbiAgICBwdHMuZm9yRWFjaChmdW5jdGlvbiAocCkge1xyXG4gICAgICBwID0gcC50cmFuc2Zvcm0obSlcclxuICAgICAgeE1pbiA9IE1hdGgubWluKHhNaW4sIHAueClcclxuICAgICAgeE1heCA9IE1hdGgubWF4KHhNYXgsIHAueClcclxuICAgICAgeU1pbiA9IE1hdGgubWluKHlNaW4sIHAueSlcclxuICAgICAgeU1heCA9IE1hdGgubWF4KHlNYXgsIHAueSlcclxuICAgIH0pXHJcblxyXG4gICAgcmV0dXJuIG5ldyBCb3goXHJcbiAgICAgIHhNaW4sIHlNaW4sXHJcbiAgICAgIHhNYXggLSB4TWluLFxyXG4gICAgICB5TWF4IC0geU1pblxyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgYWRkT2Zmc2V0ICgpIHtcclxuICAgIC8vIG9mZnNldCBieSB3aW5kb3cgc2Nyb2xsIHBvc2l0aW9uLCBiZWNhdXNlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBjaGFuZ2VzIHdoZW4gd2luZG93IGlzIHNjcm9sbGVkXHJcbiAgICB0aGlzLnggKz0gZ2xvYmFscy53aW5kb3cucGFnZVhPZmZzZXRcclxuICAgIHRoaXMueSArPSBnbG9iYWxzLndpbmRvdy5wYWdlWU9mZnNldFxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIHRvU3RyaW5nICgpIHtcclxuICAgIHJldHVybiB0aGlzLnggKyAnICcgKyB0aGlzLnkgKyAnICcgKyB0aGlzLndpZHRoICsgJyAnICsgdGhpcy5oZWlnaHRcclxuICB9XHJcblxyXG4gIHRvQXJyYXkgKCkge1xyXG4gICAgcmV0dXJuIFsgdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0IF1cclxuICB9XHJcblxyXG4gIGlzTnVsbGVkICgpIHtcclxuICAgIHJldHVybiBpc051bGxlZEJveCh0aGlzKVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0Qm94IChjYiwgcmV0cnkpIHtcclxuICBsZXQgYm94XHJcblxyXG4gIHRyeSB7XHJcbiAgICBib3ggPSBjYih0aGlzLm5vZGUpXHJcblxyXG4gICAgaWYgKGlzTnVsbGVkQm94KGJveCkgJiYgIWRvbUNvbnRhaW5zKHRoaXMubm9kZSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50IG5vdCBpbiB0aGUgZG9tJylcclxuICAgIH1cclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBib3ggPSByZXRyeSh0aGlzKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGJveFxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYmJveCAoKSB7XHJcbiAgcmV0dXJuIG5ldyBCb3goZ2V0Qm94LmNhbGwodGhpcywgKG5vZGUpID0+IG5vZGUuZ2V0QkJveCgpLCAoZWwpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNsb25lID0gZWwuY2xvbmUoKS5hZGRUbyhwYXJzZXIoKS5zdmcpLnNob3coKVxyXG4gICAgICBjb25zdCBib3ggPSBjbG9uZS5ub2RlLmdldEJCb3goKVxyXG4gICAgICBjbG9uZS5yZW1vdmUoKVxyXG4gICAgICByZXR1cm4gYm94XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignR2V0dGluZyBiYm94IG9mIGVsZW1lbnQgXCInICsgZWwubm9kZS5ub2RlTmFtZSArICdcIiBpcyBub3QgcG9zc2libGUuICcgKyBlLnRvU3RyaW5nKCkpXHJcbiAgICB9XHJcbiAgfSkpXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByYm94IChlbCkge1xyXG4gIGNvbnN0IGJveCA9IG5ldyBCb3goZ2V0Qm94LmNhbGwodGhpcywgKG5vZGUpID0+IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIChlbCkgPT4ge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdHZXR0aW5nIHJib3ggb2YgZWxlbWVudCBcIicgKyBlbC5ub2RlLm5vZGVOYW1lICsgJ1wiIGlzIG5vdCBwb3NzaWJsZScpXHJcbiAgfSkpXHJcbiAgaWYgKGVsKSByZXR1cm4gYm94LnRyYW5zZm9ybShlbC5zY3JlZW5DVE0oKS5pbnZlcnNlKCkpXHJcbiAgcmV0dXJuIGJveC5hZGRPZmZzZXQoKVxyXG59XHJcblxyXG5yZWdpc3Rlck1ldGhvZHMoe1xyXG4gIHZpZXdib3g6IHtcclxuICAgIHZpZXdib3ggKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgLy8gYWN0IGFzIGdldHRlclxyXG4gICAgICBpZiAoeCA9PSBudWxsKSByZXR1cm4gbmV3IEJveCh0aGlzLmF0dHIoJ3ZpZXdCb3gnKSlcclxuXHJcbiAgICAgIC8vIGFjdCBhcyBzZXR0ZXJcclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cigndmlld0JveCcsIG5ldyBCb3goeCwgeSwgd2lkdGgsIGhlaWdodCkpXHJcbiAgICB9LFxyXG5cclxuICAgIHpvb20gKGxldmVsLCBwb2ludCkge1xyXG4gICAgICBsZXQgd2lkdGggPSB0aGlzLm5vZGUuY2xpZW50V2lkdGhcclxuICAgICAgbGV0IGhlaWdodCA9IHRoaXMubm9kZS5jbGllbnRIZWlnaHRcclxuICAgICAgY29uc3QgdiA9IHRoaXMudmlld2JveCgpXHJcblxyXG4gICAgICAvLyBGaXJlZm94IGRvZXMgbm90IHN1cHBvcnQgY2xpZW50SGVpZ2h0IGFuZCByZXR1cm5zIDBcclxuICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODc0ODExXHJcbiAgICAgIGlmICghd2lkdGggJiYgIWhlaWdodCkge1xyXG4gICAgICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMubm9kZSlcclxuICAgICAgICB3aWR0aCA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnd2lkdGgnKSlcclxuICAgICAgICBoZWlnaHQgPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2hlaWdodCcpKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCB6b29tWCA9IHdpZHRoIC8gdi53aWR0aFxyXG4gICAgICBjb25zdCB6b29tWSA9IGhlaWdodCAvIHYuaGVpZ2h0XHJcbiAgICAgIGNvbnN0IHpvb20gPSBNYXRoLm1pbih6b29tWCwgem9vbVkpXHJcblxyXG4gICAgICBpZiAobGV2ZWwgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiB6b29tXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCB6b29tQW1vdW50ID0gem9vbSAvIGxldmVsXHJcbiAgICAgIGlmICh6b29tQW1vdW50ID09PSBJbmZpbml0eSkgem9vbUFtb3VudCA9IE51bWJlci5NSU5fVkFMVUVcclxuXHJcbiAgICAgIHBvaW50ID0gcG9pbnQgfHwgbmV3IFBvaW50KHdpZHRoIC8gMiAvIHpvb21YICsgdi54LCBoZWlnaHQgLyAyIC8gem9vbVkgKyB2LnkpXHJcblxyXG4gICAgICBjb25zdCBib3ggPSBuZXcgQm94KHYpLnRyYW5zZm9ybShcclxuICAgICAgICBuZXcgTWF0cml4KHsgc2NhbGU6IHpvb21BbW91bnQsIG9yaWdpbjogcG9pbnQgfSlcclxuICAgICAgKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMudmlld2JveChib3gpXHJcbiAgICB9XHJcbiAgfVxyXG59KVxyXG5cclxucmVnaXN0ZXIoQm94LCAnQm94JylcclxuIiwiLyogZXNsaW50IG5vLW5ldy1mdW5jOiBcIm9mZlwiICovXHJcbmV4cG9ydCBjb25zdCBzdWJDbGFzc0FycmF5ID0gKGZ1bmN0aW9uICgpIHtcclxuICB0cnkge1xyXG4gICAgLy8gdHJ5IGVzNiBzdWJjbGFzc2luZ1xyXG4gICAgcmV0dXJuIEZ1bmN0aW9uKCduYW1lJywgJ2Jhc2VDbGFzcycsICdfY29uc3RydWN0b3InLCBbXHJcbiAgICAgICdiYXNlQ2xhc3MgPSBiYXNlQ2xhc3MgfHwgQXJyYXknLFxyXG4gICAgICAncmV0dXJuIHsnLFxyXG4gICAgICAnICBbbmFtZV06IGNsYXNzIGV4dGVuZHMgYmFzZUNsYXNzIHsnLFxyXG4gICAgICAnICAgIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7JyxcclxuICAgICAgJyAgICAgIHN1cGVyKC4uLmFyZ3MpJyxcclxuICAgICAgJyAgICAgIF9jb25zdHJ1Y3RvciAmJiBfY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJncyknLFxyXG4gICAgICAnICAgIH0nLFxyXG4gICAgICAnICB9JyxcclxuICAgICAgJ31bbmFtZV0nXHJcbiAgICBdLmpvaW4oJ1xcbicpKVxyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIC8vIFVzZSBlczUgYXBwcm9hY2hcclxuICAgIHJldHVybiAobmFtZSwgYmFzZUNsYXNzID0gQXJyYXksIF9jb25zdHJ1Y3RvcikgPT4ge1xyXG4gICAgICBjb25zdCBBcnIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgYmFzZUNsYXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcclxuICAgICAgICBfY29uc3RydWN0b3IgJiYgX2NvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcclxuICAgICAgfVxyXG5cclxuICAgICAgQXJyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYmFzZUNsYXNzLnByb3RvdHlwZSlcclxuICAgICAgQXJyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFyclxyXG5cclxuICAgICAgQXJyLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICBjb25zdCBhcnIgPSBuZXcgQXJyKClcclxuICAgICAgICBhcnIucHVzaC5hcHBseShhcnIsIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbCh0aGlzLCBmbikpXHJcbiAgICAgICAgcmV0dXJuIGFyclxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gQXJyXHJcbiAgICB9XHJcbiAgfVxyXG59KSgpXHJcbiIsImltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IHN1YkNsYXNzQXJyYXkgfSBmcm9tICcuL0FycmF5UG9seWZpbGwuanMnXHJcblxyXG5jb25zdCBMaXN0ID0gc3ViQ2xhc3NBcnJheSgnTGlzdCcsIEFycmF5LCBmdW5jdGlvbiAoYXJyID0gW10pIHtcclxuICAvLyBUaGlzIGNhdGNoZXMgdGhlIGNhc2UsIHRoYXQgbmF0aXZlIG1hcCB0cmllcyB0byBjcmVhdGUgYW4gYXJyYXkgd2l0aCBuZXcgQXJyYXkoMSlcclxuICBpZiAodHlwZW9mIGFyciA9PT0gJ251bWJlcicpIHJldHVybiB0aGlzXHJcbiAgdGhpcy5sZW5ndGggPSAwXHJcbiAgdGhpcy5wdXNoKC4uLmFycilcclxufSlcclxuXHJcbmV4cG9ydCBkZWZhdWx0IExpc3RcclxuXHJcbmV4dGVuZChMaXN0LCB7XHJcbiAgZWFjaCAoZm5Pck1ldGhvZE5hbWUsIC4uLmFyZ3MpIHtcclxuICAgIGlmICh0eXBlb2YgZm5Pck1ldGhvZE5hbWUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubWFwKChlbCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBmbk9yTWV0aG9kTmFtZS5jYWxsKGVsLCBlbClcclxuICAgICAgfSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1hcChlbCA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGVsW2ZuT3JNZXRob2ROYW1lXSguLi5hcmdzKVxyXG4gICAgICB9KVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHRvQXJyYXkgKCkge1xyXG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIHRoaXMpXHJcbiAgfVxyXG59KVxyXG5cclxuY29uc3QgcmVzZXJ2ZWQgPSBbICd0b0FycmF5JywgJ2NvbnN0cnVjdG9yJywgJ2VhY2gnIF1cclxuXHJcbkxpc3QuZXh0ZW5kID0gZnVuY3Rpb24gKG1ldGhvZHMpIHtcclxuICBtZXRob2RzID0gbWV0aG9kcy5yZWR1Y2UoKG9iaiwgbmFtZSkgPT4ge1xyXG4gICAgLy8gRG9uJ3Qgb3ZlcndyaXRlIG93biBtZXRob2RzXHJcbiAgICBpZiAocmVzZXJ2ZWQuaW5jbHVkZXMobmFtZSkpIHJldHVybiBvYmpcclxuXHJcbiAgICAvLyBEb24ndCBhZGQgcHJpdmF0ZSBtZXRob2RzXHJcbiAgICBpZiAobmFtZVswXSA9PT0gJ18nKSByZXR1cm4gb2JqXHJcblxyXG4gICAgLy8gUmVsYXkgZXZlcnkgY2FsbCB0byBlYWNoKClcclxuICAgIG9ialtuYW1lXSA9IGZ1bmN0aW9uICguLi5hdHRycykge1xyXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKG5hbWUsIC4uLmF0dHJzKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9ialxyXG4gIH0sIHt9KVxyXG5cclxuICBleHRlbmQoTGlzdCwgbWV0aG9kcylcclxufVxyXG4iLCJpbXBvcnQgeyBhZG9wdCB9IGZyb20gJy4uLy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuLi8uLi91dGlscy93aW5kb3cuanMnXHJcbmltcG9ydCB7IG1hcCB9IGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzLmpzJ1xyXG5pbXBvcnQgTGlzdCBmcm9tICcuLi8uLi90eXBlcy9MaXN0LmpzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmFzZUZpbmQgKHF1ZXJ5LCBwYXJlbnQpIHtcclxuICByZXR1cm4gbmV3IExpc3QobWFwKChwYXJlbnQgfHwgZ2xvYmFscy5kb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChxdWVyeSksIGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICByZXR1cm4gYWRvcHQobm9kZSlcclxuICB9KSlcclxufVxyXG5cclxuLy8gU2NvcGVkIGZpbmQgbWV0aG9kXHJcbmV4cG9ydCBmdW5jdGlvbiBmaW5kIChxdWVyeSkge1xyXG4gIHJldHVybiBiYXNlRmluZChxdWVyeSwgdGhpcy5ub2RlKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZmluZE9uZSAocXVlcnkpIHtcclxuICByZXR1cm4gYWRvcHQodGhpcy5ub2RlLnF1ZXJ5U2VsZWN0b3IocXVlcnkpKVxyXG59XHJcbiIsImltcG9ydCB7IGRpc3BhdGNoLCBvZmYsIG9uIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL2V2ZW50LmpzJ1xyXG5pbXBvcnQgeyByZWdpc3RlciB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCBCYXNlIGZyb20gJy4vQmFzZS5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50VGFyZ2V0IGV4dGVuZHMgQmFzZSB7XHJcbiAgY29uc3RydWN0b3IgKHsgZXZlbnRzID0ge30gfSA9IHt9KSB7XHJcbiAgICBzdXBlcigpXHJcbiAgICB0aGlzLmV2ZW50cyA9IGV2ZW50c1xyXG4gIH1cclxuXHJcbiAgYWRkRXZlbnRMaXN0ZW5lciAoKSB7fVxyXG5cclxuICBkaXNwYXRjaCAoZXZlbnQsIGRhdGEpIHtcclxuICAgIHJldHVybiBkaXNwYXRjaCh0aGlzLCBldmVudCwgZGF0YSlcclxuICB9XHJcblxyXG4gIGRpc3BhdGNoRXZlbnQgKGV2ZW50KSB7XHJcbiAgICBjb25zdCBiYWcgPSB0aGlzLmdldEV2ZW50SG9sZGVyKCkuZXZlbnRzXHJcbiAgICBpZiAoIWJhZykgcmV0dXJuIHRydWVcclxuXHJcbiAgICBjb25zdCBldmVudHMgPSBiYWdbZXZlbnQudHlwZV1cclxuXHJcbiAgICBmb3IgKGNvbnN0IGkgaW4gZXZlbnRzKSB7XHJcbiAgICAgIGZvciAoY29uc3QgaiBpbiBldmVudHNbaV0pIHtcclxuICAgICAgICBldmVudHNbaV1bal0oZXZlbnQpXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWRcclxuICB9XHJcblxyXG4gIC8vIEZpcmUgZ2l2ZW4gZXZlbnRcclxuICBmaXJlIChldmVudCwgZGF0YSkge1xyXG4gICAgdGhpcy5kaXNwYXRjaChldmVudCwgZGF0YSlcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICBnZXRFdmVudEhvbGRlciAoKSB7XHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgZ2V0RXZlbnRUYXJnZXQgKCkge1xyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8vIFVuYmluZCBldmVudCBmcm9tIGxpc3RlbmVyXHJcbiAgb2ZmIChldmVudCwgbGlzdGVuZXIpIHtcclxuICAgIG9mZih0aGlzLCBldmVudCwgbGlzdGVuZXIpXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgLy8gQmluZCBnaXZlbiBldmVudCB0byBsaXN0ZW5lclxyXG4gIG9uIChldmVudCwgbGlzdGVuZXIsIGJpbmRpbmcsIG9wdGlvbnMpIHtcclxuICAgIG9uKHRoaXMsIGV2ZW50LCBsaXN0ZW5lciwgYmluZGluZywgb3B0aW9ucylcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICByZW1vdmVFdmVudExpc3RlbmVyICgpIHt9XHJcbn1cclxuXHJcbnJlZ2lzdGVyKEV2ZW50VGFyZ2V0LCAnRXZlbnRUYXJnZXQnKVxyXG4iLCJcclxuZXhwb3J0IGZ1bmN0aW9uIG5vb3AgKCkge31cclxuXHJcbi8vIERlZmF1bHQgYW5pbWF0aW9uIHZhbHVlc1xyXG5leHBvcnQgY29uc3QgdGltZWxpbmUgPSB7XHJcbiAgZHVyYXRpb246IDQwMCxcclxuICBlYXNlOiAnPicsXHJcbiAgZGVsYXk6IDBcclxufVxyXG5cclxuLy8gRGVmYXVsdCBhdHRyaWJ1dGUgdmFsdWVzXHJcbmV4cG9ydCBjb25zdCBhdHRycyA9IHtcclxuXHJcbiAgLy8gZmlsbCBhbmQgc3Ryb2tlXHJcbiAgJ2ZpbGwtb3BhY2l0eSc6IDEsXHJcbiAgJ3N0cm9rZS1vcGFjaXR5JzogMSxcclxuICAnc3Ryb2tlLXdpZHRoJzogMCxcclxuICAnc3Ryb2tlLWxpbmVqb2luJzogJ21pdGVyJyxcclxuICAnc3Ryb2tlLWxpbmVjYXAnOiAnYnV0dCcsXHJcbiAgZmlsbDogJyMwMDAwMDAnLFxyXG4gIHN0cm9rZTogJyMwMDAwMDAnLFxyXG4gIG9wYWNpdHk6IDEsXHJcblxyXG4gIC8vIHBvc2l0aW9uXHJcbiAgeDogMCxcclxuICB5OiAwLFxyXG4gIGN4OiAwLFxyXG4gIGN5OiAwLFxyXG5cclxuICAvLyBzaXplXHJcbiAgd2lkdGg6IDAsXHJcbiAgaGVpZ2h0OiAwLFxyXG5cclxuICAvLyByYWRpdXNcclxuICByOiAwLFxyXG4gIHJ4OiAwLFxyXG4gIHJ5OiAwLFxyXG5cclxuICAvLyBncmFkaWVudFxyXG4gIG9mZnNldDogMCxcclxuICAnc3RvcC1vcGFjaXR5JzogMSxcclxuICAnc3RvcC1jb2xvcic6ICcjMDAwMDAwJyxcclxuXHJcbiAgLy8gdGV4dFxyXG4gICd0ZXh0LWFuY2hvcic6ICdzdGFydCdcclxufVxyXG4iLCJpbXBvcnQgeyBkZWxpbWl0ZXIgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvcmVnZXguanMnXHJcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IHN1YkNsYXNzQXJyYXkgfSBmcm9tICcuL0FycmF5UG9seWZpbGwuanMnXHJcblxyXG5jb25zdCBTVkdBcnJheSA9IHN1YkNsYXNzQXJyYXkoJ1NWR0FycmF5JywgQXJyYXksIGZ1bmN0aW9uIChhcnIpIHtcclxuICB0aGlzLmluaXQoYXJyKVxyXG59KVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU1ZHQXJyYXlcclxuXHJcbmV4dGVuZChTVkdBcnJheSwge1xyXG4gIGluaXQgKGFycikge1xyXG4gICAgLy8gVGhpcyBjYXRjaGVzIHRoZSBjYXNlLCB0aGF0IG5hdGl2ZSBtYXAgdHJpZXMgdG8gY3JlYXRlIGFuIGFycmF5IHdpdGggbmV3IEFycmF5KDEpXHJcbiAgICBpZiAodHlwZW9mIGFyciA9PT0gJ251bWJlcicpIHJldHVybiB0aGlzXHJcbiAgICB0aGlzLmxlbmd0aCA9IDBcclxuICAgIHRoaXMucHVzaCguLi50aGlzLnBhcnNlKGFycikpXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH0sXHJcblxyXG4gIHRvQXJyYXkgKCkge1xyXG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIHRoaXMpXHJcbiAgfSxcclxuXHJcbiAgdG9TdHJpbmcgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuam9pbignICcpXHJcbiAgfSxcclxuXHJcbiAgLy8gRmxhdHRlbnMgdGhlIGFycmF5IGlmIG5lZWRlZFxyXG4gIHZhbHVlT2YgKCkge1xyXG4gICAgY29uc3QgcmV0ID0gW11cclxuICAgIHJldC5wdXNoKC4uLnRoaXMpXHJcbiAgICByZXR1cm4gcmV0XHJcbiAgfSxcclxuXHJcbiAgLy8gUGFyc2Ugd2hpdGVzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nXHJcbiAgcGFyc2UgKGFycmF5ID0gW10pIHtcclxuICAgIC8vIElmIGFscmVhZHkgaXMgYW4gYXJyYXksIG5vIG5lZWQgdG8gcGFyc2UgaXRcclxuICAgIGlmIChhcnJheSBpbnN0YW5jZW9mIEFycmF5KSByZXR1cm4gYXJyYXlcclxuXHJcbiAgICByZXR1cm4gYXJyYXkudHJpbSgpLnNwbGl0KGRlbGltaXRlcikubWFwKHBhcnNlRmxvYXQpXHJcbiAgfSxcclxuXHJcbiAgY2xvbmUgKCkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpXHJcbiAgfSxcclxuXHJcbiAgdG9TZXQgKCkge1xyXG4gICAgcmV0dXJuIG5ldyBTZXQodGhpcylcclxuICB9XHJcbn0pXHJcbiIsImltcG9ydCB7IG51bWJlckFuZFVuaXQgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvcmVnZXguanMnXHJcblxyXG4vLyBNb2R1bGUgZm9yIHVuaXQgY29udmVydGlvbnNcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU1ZHTnVtYmVyIHtcclxuICAvLyBJbml0aWFsaXplXHJcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcclxuICAgIHRoaXMuaW5pdCguLi5hcmdzKVxyXG4gIH1cclxuXHJcbiAgaW5pdCAodmFsdWUsIHVuaXQpIHtcclxuICAgIHVuaXQgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlWzFdIDogdW5pdFxyXG4gICAgdmFsdWUgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlWzBdIDogdmFsdWVcclxuXHJcbiAgICAvLyBpbml0aWFsaXplIGRlZmF1bHRzXHJcbiAgICB0aGlzLnZhbHVlID0gMFxyXG4gICAgdGhpcy51bml0ID0gdW5pdCB8fCAnJ1xyXG5cclxuICAgIC8vIHBhcnNlIHZhbHVlXHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAvLyBlbnN1cmUgYSB2YWxpZCBudW1lcmljIHZhbHVlXHJcbiAgICAgIHRoaXMudmFsdWUgPSBpc05hTih2YWx1ZSkgPyAwIDogIWlzRmluaXRlKHZhbHVlKSA/ICh2YWx1ZSA8IDAgPyAtMy40ZSszOCA6ICszLjRlKzM4KSA6IHZhbHVlXHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgdW5pdCA9IHZhbHVlLm1hdGNoKG51bWJlckFuZFVuaXQpXHJcblxyXG4gICAgICBpZiAodW5pdCkge1xyXG4gICAgICAgIC8vIG1ha2UgdmFsdWUgbnVtZXJpY1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSBwYXJzZUZsb2F0KHVuaXRbMV0pXHJcblxyXG4gICAgICAgIC8vIG5vcm1hbGl6ZVxyXG4gICAgICAgIGlmICh1bml0WzVdID09PSAnJScpIHtcclxuICAgICAgICAgIHRoaXMudmFsdWUgLz0gMTAwXHJcbiAgICAgICAgfSBlbHNlIGlmICh1bml0WzVdID09PSAncycpIHtcclxuICAgICAgICAgIHRoaXMudmFsdWUgKj0gMTAwMFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gc3RvcmUgdW5pdFxyXG4gICAgICAgIHRoaXMudW5pdCA9IHVuaXRbNV1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU1ZHTnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlLnZhbHVlT2YoKVxyXG4gICAgICAgIHRoaXMudW5pdCA9IHZhbHVlLnVuaXRcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICB0b1N0cmluZyAoKSB7XHJcbiAgICByZXR1cm4gKHRoaXMudW5pdCA9PT0gJyUnID8gfn4odGhpcy52YWx1ZSAqIDFlOCkgLyAxZTZcclxuICAgICAgOiB0aGlzLnVuaXQgPT09ICdzJyA/IHRoaXMudmFsdWUgLyAxZTNcclxuICAgICAgOiB0aGlzLnZhbHVlXHJcbiAgICApICsgdGhpcy51bml0XHJcbiAgfVxyXG5cclxuICB0b0pTT04gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKVxyXG4gIH1cclxuXHJcbiAgdG9BcnJheSAoKSB7XHJcbiAgICByZXR1cm4gWyB0aGlzLnZhbHVlLCB0aGlzLnVuaXQgXVxyXG4gIH1cclxuXHJcbiAgdmFsdWVPZiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZVxyXG4gIH1cclxuXHJcbiAgLy8gQWRkIG51bWJlclxyXG4gIHBsdXMgKG51bWJlcikge1xyXG4gICAgbnVtYmVyID0gbmV3IFNWR051bWJlcihudW1iZXIpXHJcbiAgICByZXR1cm4gbmV3IFNWR051bWJlcih0aGlzICsgbnVtYmVyLCB0aGlzLnVuaXQgfHwgbnVtYmVyLnVuaXQpXHJcbiAgfVxyXG5cclxuICAvLyBTdWJ0cmFjdCBudW1iZXJcclxuICBtaW51cyAobnVtYmVyKSB7XHJcbiAgICBudW1iZXIgPSBuZXcgU1ZHTnVtYmVyKG51bWJlcilcclxuICAgIHJldHVybiBuZXcgU1ZHTnVtYmVyKHRoaXMgLSBudW1iZXIsIHRoaXMudW5pdCB8fCBudW1iZXIudW5pdClcclxuICB9XHJcblxyXG4gIC8vIE11bHRpcGx5IG51bWJlclxyXG4gIHRpbWVzIChudW1iZXIpIHtcclxuICAgIG51bWJlciA9IG5ldyBTVkdOdW1iZXIobnVtYmVyKVxyXG4gICAgcmV0dXJuIG5ldyBTVkdOdW1iZXIodGhpcyAqIG51bWJlciwgdGhpcy51bml0IHx8IG51bWJlci51bml0KVxyXG4gIH1cclxuXHJcbiAgLy8gRGl2aWRlIG51bWJlclxyXG4gIGRpdmlkZSAobnVtYmVyKSB7XHJcbiAgICBudW1iZXIgPSBuZXcgU1ZHTnVtYmVyKG51bWJlcilcclxuICAgIHJldHVybiBuZXcgU1ZHTnVtYmVyKHRoaXMgLyBudW1iZXIsIHRoaXMudW5pdCB8fCBudW1iZXIudW5pdClcclxuICB9XHJcblxyXG4gIGNvbnZlcnQgKHVuaXQpIHtcclxuICAgIHJldHVybiBuZXcgU1ZHTnVtYmVyKHRoaXMudmFsdWUsIHVuaXQpXHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IGF0dHJzIGFzIGRlZmF1bHRzIH0gZnJvbSAnLi9kZWZhdWx0cy5qcydcclxuaW1wb3J0IHsgaXNOdW1iZXIgfSBmcm9tICcuL3JlZ2V4LmpzJ1xyXG5pbXBvcnQgQ29sb3IgZnJvbSAnLi4vLi4vdHlwZXMvQ29sb3IuanMnXHJcbmltcG9ydCBTVkdBcnJheSBmcm9tICcuLi8uLi90eXBlcy9TVkdBcnJheS5qcydcclxuaW1wb3J0IFNWR051bWJlciBmcm9tICcuLi8uLi90eXBlcy9TVkdOdW1iZXIuanMnXHJcblxyXG5jb25zdCBob29rcyA9IFtdXHJcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckF0dHJIb29rIChmbikge1xyXG4gIGhvb2tzLnB1c2goZm4pXHJcbn1cclxuXHJcbi8vIFNldCBzdmcgZWxlbWVudCBhdHRyaWJ1dGVcclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXR0ciAoYXR0ciwgdmFsLCBucykge1xyXG4gIC8vIGFjdCBhcyBmdWxsIGdldHRlclxyXG4gIGlmIChhdHRyID09IG51bGwpIHtcclxuICAgIC8vIGdldCBhbiBvYmplY3Qgb2YgYXR0cmlidXRlc1xyXG4gICAgYXR0ciA9IHt9XHJcbiAgICB2YWwgPSB0aGlzLm5vZGUuYXR0cmlidXRlc1xyXG5cclxuICAgIGZvciAoY29uc3Qgbm9kZSBvZiB2YWwpIHtcclxuICAgICAgYXR0cltub2RlLm5vZGVOYW1lXSA9IGlzTnVtYmVyLnRlc3Qobm9kZS5ub2RlVmFsdWUpXHJcbiAgICAgICAgPyBwYXJzZUZsb2F0KG5vZGUubm9kZVZhbHVlKVxyXG4gICAgICAgIDogbm9kZS5ub2RlVmFsdWVcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYXR0clxyXG4gIH0gZWxzZSBpZiAoYXR0ciBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAvLyBsb29wIHRocm91Z2ggYXJyYXkgYW5kIGdldCBhbGwgdmFsdWVzXHJcbiAgICByZXR1cm4gYXR0ci5yZWR1Y2UoKGxhc3QsIGN1cnIpID0+IHtcclxuICAgICAgbGFzdFtjdXJyXSA9IHRoaXMuYXR0cihjdXJyKVxyXG4gICAgICByZXR1cm4gbGFzdFxyXG4gICAgfSwge30pXHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXR0ciA9PT0gJ29iamVjdCcgJiYgYXR0ci5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XHJcbiAgICAvLyBhcHBseSBldmVyeSBhdHRyaWJ1dGUgaW5kaXZpZHVhbGx5IGlmIGFuIG9iamVjdCBpcyBwYXNzZWRcclxuICAgIGZvciAodmFsIGluIGF0dHIpIHRoaXMuYXR0cih2YWwsIGF0dHJbdmFsXSlcclxuICB9IGVsc2UgaWYgKHZhbCA9PT0gbnVsbCkge1xyXG4gICAgLy8gcmVtb3ZlIHZhbHVlXHJcbiAgICB0aGlzLm5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHIpXHJcbiAgfSBlbHNlIGlmICh2YWwgPT0gbnVsbCkge1xyXG4gICAgLy8gYWN0IGFzIGEgZ2V0dGVyIGlmIHRoZSBmaXJzdCBhbmQgb25seSBhcmd1bWVudCBpcyBub3QgYW4gb2JqZWN0XHJcbiAgICB2YWwgPSB0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKGF0dHIpXHJcbiAgICByZXR1cm4gdmFsID09IG51bGwgPyBkZWZhdWx0c1thdHRyXVxyXG4gICAgICA6IGlzTnVtYmVyLnRlc3QodmFsKSA/IHBhcnNlRmxvYXQodmFsKVxyXG4gICAgICA6IHZhbFxyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBMb29wIHRocm91Z2ggaG9va3MgYW5kIGV4ZWN1dGUgdGhlbSB0byBjb252ZXJ0IHZhbHVlXHJcbiAgICB2YWwgPSBob29rcy5yZWR1Y2UoKF92YWwsIGhvb2spID0+IHtcclxuICAgICAgcmV0dXJuIGhvb2soYXR0ciwgX3ZhbCwgdGhpcylcclxuICAgIH0sIHZhbClcclxuXHJcbiAgICAvLyBlbnN1cmUgY29ycmVjdCBudW1lcmljIHZhbHVlcyAoYWxzbyBhY2NlcHRzIE5hTiBhbmQgSW5maW5pdHkpXHJcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgdmFsID0gbmV3IFNWR051bWJlcih2YWwpXHJcbiAgICB9IGVsc2UgaWYgKENvbG9yLmlzQ29sb3IodmFsKSkge1xyXG4gICAgICAvLyBlbnN1cmUgZnVsbCBoZXggY29sb3JcclxuICAgICAgdmFsID0gbmV3IENvbG9yKHZhbClcclxuICAgIH0gZWxzZSBpZiAodmFsLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xyXG4gICAgICAvLyBDaGVjayBmb3IgcGxhaW4gYXJyYXlzIGFuZCBwYXJzZSBhcnJheSB2YWx1ZXNcclxuICAgICAgdmFsID0gbmV3IFNWR0FycmF5KHZhbClcclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiB0aGUgcGFzc2VkIGF0dHJpYnV0ZSBpcyBsZWFkaW5nLi4uXHJcbiAgICBpZiAoYXR0ciA9PT0gJ2xlYWRpbmcnKSB7XHJcbiAgICAgIC8vIC4uLiBjYWxsIHRoZSBsZWFkaW5nIG1ldGhvZCBpbnN0ZWFkXHJcbiAgICAgIGlmICh0aGlzLmxlYWRpbmcpIHtcclxuICAgICAgICB0aGlzLmxlYWRpbmcodmFsKVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBzZXQgZ2l2ZW4gYXR0cmlidXRlIG9uIG5vZGVcclxuICAgICAgdHlwZW9mIG5zID09PSAnc3RyaW5nJyA/IHRoaXMubm9kZS5zZXRBdHRyaWJ1dGVOUyhucywgYXR0ciwgdmFsLnRvU3RyaW5nKCkpXHJcbiAgICAgICAgOiB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIHZhbC50b1N0cmluZygpKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHJlYnVpbGQgaWYgcmVxdWlyZWRcclxuICAgIGlmICh0aGlzLnJlYnVpbGQgJiYgKGF0dHIgPT09ICdmb250LXNpemUnIHx8IGF0dHIgPT09ICd4JykpIHtcclxuICAgICAgdGhpcy5yZWJ1aWxkKClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzXHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICBhZG9wdCxcclxuICBhc3NpZ25OZXdJZCxcclxuICBlaWQsXHJcbiAgZXh0ZW5kLFxyXG4gIG1ha2VJbnN0YW5jZSxcclxuICBjcmVhdGUsXHJcbiAgcmVnaXN0ZXJcclxufSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgeyBmaW5kLCBmaW5kT25lIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3NlbGVjdG9yLmpzJ1xyXG5pbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi4vdXRpbHMvd2luZG93LmpzJ1xyXG5pbXBvcnQgeyBtYXAgfSBmcm9tICcuLi91dGlscy91dGlscy5qcydcclxuaW1wb3J0IHsgbnMgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvbmFtZXNwYWNlcy5qcydcclxuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4uL3R5cGVzL0V2ZW50VGFyZ2V0LmpzJ1xyXG5pbXBvcnQgTGlzdCBmcm9tICcuLi90eXBlcy9MaXN0LmpzJ1xyXG5pbXBvcnQgYXR0ciBmcm9tICcuLi9tb2R1bGVzL2NvcmUvYXR0ci5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvbSBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcclxuICBjb25zdHJ1Y3RvciAobm9kZSwgYXR0cnMpIHtcclxuICAgIHN1cGVyKG5vZGUpXHJcbiAgICB0aGlzLm5vZGUgPSBub2RlXHJcbiAgICB0aGlzLnR5cGUgPSBub2RlLm5vZGVOYW1lXHJcblxyXG4gICAgaWYgKGF0dHJzICYmIG5vZGUgIT09IGF0dHJzKSB7XHJcbiAgICAgIHRoaXMuYXR0cihhdHRycylcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFkZCBnaXZlbiBlbGVtZW50IGF0IGEgcG9zaXRpb25cclxuICBhZGQgKGVsZW1lbnQsIGkpIHtcclxuICAgIGVsZW1lbnQgPSBtYWtlSW5zdGFuY2UoZWxlbWVudClcclxuXHJcbiAgICBpZiAoaSA9PSBudWxsKSB7XHJcbiAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChlbGVtZW50Lm5vZGUpXHJcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnQubm9kZSAhPT0gdGhpcy5ub2RlLmNoaWxkTm9kZXNbaV0pIHtcclxuICAgICAgdGhpcy5ub2RlLmluc2VydEJlZm9yZShlbGVtZW50Lm5vZGUsIHRoaXMubm9kZS5jaGlsZE5vZGVzW2ldKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvLyBBZGQgZWxlbWVudCB0byBnaXZlbiBjb250YWluZXIgYW5kIHJldHVybiBzZWxmXHJcbiAgYWRkVG8gKHBhcmVudCkge1xyXG4gICAgcmV0dXJuIG1ha2VJbnN0YW5jZShwYXJlbnQpLnB1dCh0aGlzKVxyXG4gIH1cclxuXHJcbiAgLy8gUmV0dXJucyBhbGwgY2hpbGQgZWxlbWVudHNcclxuICBjaGlsZHJlbiAoKSB7XHJcbiAgICByZXR1cm4gbmV3IExpc3QobWFwKHRoaXMubm9kZS5jaGlsZHJlbiwgZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgcmV0dXJuIGFkb3B0KG5vZGUpXHJcbiAgICB9KSlcclxuICB9XHJcblxyXG4gIC8vIFJlbW92ZSBhbGwgZWxlbWVudHMgaW4gdGhpcyBjb250YWluZXJcclxuICBjbGVhciAoKSB7XHJcbiAgICAvLyByZW1vdmUgY2hpbGRyZW5cclxuICAgIHdoaWxlICh0aGlzLm5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XHJcbiAgICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUubGFzdENoaWxkKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvLyBDbG9uZSBlbGVtZW50XHJcbiAgY2xvbmUgKCkge1xyXG4gICAgLy8gd3JpdGUgZG9tIGRhdGEgdG8gdGhlIGRvbSBzbyB0aGUgY2xvbmUgY2FuIHBpY2t1cCB0aGUgZGF0YVxyXG4gICAgdGhpcy53cml0ZURhdGFUb0RvbSgpXHJcblxyXG4gICAgLy8gY2xvbmUgZWxlbWVudCBhbmQgYXNzaWduIG5ldyBpZFxyXG4gICAgcmV0dXJuIGFzc2lnbk5ld0lkKHRoaXMubm9kZS5jbG9uZU5vZGUodHJ1ZSkpXHJcbiAgfVxyXG5cclxuICAvLyBJdGVyYXRlcyBvdmVyIGFsbCBjaGlsZHJlbiBhbmQgaW52b2tlcyBhIGdpdmVuIGJsb2NrXHJcbiAgZWFjaCAoYmxvY2ssIGRlZXApIHtcclxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4oKVxyXG4gICAgdmFyIGksIGlsXHJcblxyXG4gICAgZm9yIChpID0gMCwgaWwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XHJcbiAgICAgIGJsb2NrLmFwcGx5KGNoaWxkcmVuW2ldLCBbIGksIGNoaWxkcmVuIF0pXHJcblxyXG4gICAgICBpZiAoZGVlcCkge1xyXG4gICAgICAgIGNoaWxkcmVuW2ldLmVhY2goYmxvY2ssIGRlZXApXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgZWxlbWVudCAobm9kZU5hbWUpIHtcclxuICAgIHJldHVybiB0aGlzLnB1dChuZXcgRG9tKGNyZWF0ZShub2RlTmFtZSkpKVxyXG4gIH1cclxuXHJcbiAgLy8gR2V0IGZpcnN0IGNoaWxkXHJcbiAgZmlyc3QgKCkge1xyXG4gICAgcmV0dXJuIGFkb3B0KHRoaXMubm9kZS5maXJzdENoaWxkKVxyXG4gIH1cclxuXHJcbiAgLy8gR2V0IGEgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcclxuICBnZXQgKGkpIHtcclxuICAgIHJldHVybiBhZG9wdCh0aGlzLm5vZGUuY2hpbGROb2Rlc1tpXSlcclxuICB9XHJcblxyXG4gIGdldEV2ZW50SG9sZGVyICgpIHtcclxuICAgIHJldHVybiB0aGlzLm5vZGVcclxuICB9XHJcblxyXG4gIGdldEV2ZW50VGFyZ2V0ICgpIHtcclxuICAgIHJldHVybiB0aGlzLm5vZGVcclxuICB9XHJcblxyXG4gIC8vIENoZWNrcyBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBhIGNoaWxkXHJcbiAgaGFzIChlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gdGhpcy5pbmRleChlbGVtZW50KSA+PSAwXHJcbiAgfVxyXG5cclxuICAvLyBHZXQgLyBzZXQgaWRcclxuICBpZCAoaWQpIHtcclxuICAgIC8vIGdlbmVyYXRlIG5ldyBpZCBpZiBubyBpZCBzZXRcclxuICAgIGlmICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnICYmICF0aGlzLm5vZGUuaWQpIHtcclxuICAgICAgdGhpcy5ub2RlLmlkID0gZWlkKHRoaXMudHlwZSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBkb250J3Qgc2V0IGRpcmVjdGx5IHdpZHRoIHRoaXMubm9kZS5pZCB0byBtYWtlIGBudWxsYCB3b3JrIGNvcnJlY3RseVxyXG4gICAgcmV0dXJuIHRoaXMuYXR0cignaWQnLCBpZClcclxuICB9XHJcblxyXG4gIC8vIEdldHMgaW5kZXggb2YgZ2l2ZW4gZWxlbWVudFxyXG4gIGluZGV4IChlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gW10uc2xpY2UuY2FsbCh0aGlzLm5vZGUuY2hpbGROb2RlcykuaW5kZXhPZihlbGVtZW50Lm5vZGUpXHJcbiAgfVxyXG5cclxuICAvLyBHZXQgdGhlIGxhc3QgY2hpbGRcclxuICBsYXN0ICgpIHtcclxuICAgIHJldHVybiBhZG9wdCh0aGlzLm5vZGUubGFzdENoaWxkKVxyXG4gIH1cclxuXHJcbiAgLy8gbWF0Y2hlcyB0aGUgZWxlbWVudCB2cyBhIGNzcyBzZWxlY3RvclxyXG4gIG1hdGNoZXMgKHNlbGVjdG9yKSB7XHJcbiAgICBjb25zdCBlbCA9IHRoaXMubm9kZVxyXG4gICAgcmV0dXJuIChlbC5tYXRjaGVzIHx8IGVsLm1hdGNoZXNTZWxlY3RvciB8fCBlbC5tc01hdGNoZXNTZWxlY3RvciB8fCBlbC5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgZWwud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGVsLm9NYXRjaGVzU2VsZWN0b3IpLmNhbGwoZWwsIHNlbGVjdG9yKVxyXG4gIH1cclxuXHJcbiAgLy8gUmV0dXJucyB0aGUgcGFyZW50IGVsZW1lbnQgaW5zdGFuY2VcclxuICBwYXJlbnQgKHR5cGUpIHtcclxuICAgIHZhciBwYXJlbnQgPSB0aGlzXHJcblxyXG4gICAgLy8gY2hlY2sgZm9yIHBhcmVudFxyXG4gICAgaWYgKCFwYXJlbnQubm9kZS5wYXJlbnROb2RlKSByZXR1cm4gbnVsbFxyXG5cclxuICAgIC8vIGdldCBwYXJlbnQgZWxlbWVudFxyXG4gICAgcGFyZW50ID0gYWRvcHQocGFyZW50Lm5vZGUucGFyZW50Tm9kZSlcclxuXHJcbiAgICBpZiAoIXR5cGUpIHJldHVybiBwYXJlbnRcclxuXHJcbiAgICAvLyBsb29wIHRyb3VnaCBhbmNlc3RvcnMgaWYgdHlwZSBpcyBnaXZlblxyXG4gICAgd2hpbGUgKHBhcmVudCkge1xyXG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50Lm1hdGNoZXModHlwZSkgOiBwYXJlbnQgaW5zdGFuY2VvZiB0eXBlKSByZXR1cm4gcGFyZW50XHJcbiAgICAgIGlmICghcGFyZW50Lm5vZGUucGFyZW50Tm9kZSB8fCBwYXJlbnQubm9kZS5wYXJlbnROb2RlLm5vZGVOYW1lID09PSAnI2RvY3VtZW50JyB8fCBwYXJlbnQubm9kZS5wYXJlbnROb2RlLm5vZGVOYW1lID09PSAnI2RvY3VtZW50LWZyYWdtZW50JykgcmV0dXJuIG51bGwgLy8gIzc1OSwgIzcyMFxyXG4gICAgICBwYXJlbnQgPSBhZG9wdChwYXJlbnQubm9kZS5wYXJlbnROb2RlKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQmFzaWNhbGx5IGRvZXMgdGhlIHNhbWUgYXMgYGFkZCgpYCBidXQgcmV0dXJucyB0aGUgYWRkZWQgZWxlbWVudCBpbnN0ZWFkXHJcbiAgcHV0IChlbGVtZW50LCBpKSB7XHJcbiAgICB0aGlzLmFkZChlbGVtZW50LCBpKVxyXG4gICAgcmV0dXJuIGVsZW1lbnRcclxuICB9XHJcblxyXG4gIC8vIEFkZCBlbGVtZW50IHRvIGdpdmVuIGNvbnRhaW5lciBhbmQgcmV0dXJuIGNvbnRhaW5lclxyXG4gIHB1dEluIChwYXJlbnQpIHtcclxuICAgIHJldHVybiBtYWtlSW5zdGFuY2UocGFyZW50KS5hZGQodGhpcylcclxuICB9XHJcblxyXG4gIC8vIFJlbW92ZSBlbGVtZW50XHJcbiAgcmVtb3ZlICgpIHtcclxuICAgIGlmICh0aGlzLnBhcmVudCgpKSB7XHJcbiAgICAgIHRoaXMucGFyZW50KCkucmVtb3ZlRWxlbWVudCh0aGlzKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgYSBnaXZlbiBjaGlsZFxyXG4gIHJlbW92ZUVsZW1lbnQgKGVsZW1lbnQpIHtcclxuICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZChlbGVtZW50Lm5vZGUpXHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8vIFJlcGxhY2UgdGhpcyB3aXRoIGVsZW1lbnRcclxuICByZXBsYWNlIChlbGVtZW50KSB7XHJcbiAgICBlbGVtZW50ID0gbWFrZUluc3RhbmNlKGVsZW1lbnQpXHJcbiAgICB0aGlzLm5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZWxlbWVudC5ub2RlLCB0aGlzLm5vZGUpXHJcbiAgICByZXR1cm4gZWxlbWVudFxyXG4gIH1cclxuXHJcbiAgcm91bmQgKHByZWNpc2lvbiA9IDIsIG1hcCkge1xyXG4gICAgY29uc3QgZmFjdG9yID0gMTAgKiogcHJlY2lzaW9uXHJcbiAgICBjb25zdCBhdHRycyA9IHRoaXMuYXR0cigpXHJcblxyXG4gICAgLy8gSWYgd2UgaGF2ZSBubyBtYXAsIGJ1aWxkIG9uZSBmcm9tIGF0dHJzXHJcbiAgICBpZiAoIW1hcCkge1xyXG4gICAgICBtYXAgPSBPYmplY3Qua2V5cyhhdHRycylcclxuICAgIH1cclxuXHJcbiAgICAvLyBIb2xkcyByb3VuZGVkIGF0dHJpYnV0ZXNcclxuICAgIGNvbnN0IG5ld0F0dHJzID0ge31cclxuICAgIG1hcC5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgbmV3QXR0cnNba2V5XSA9IE1hdGgucm91bmQoYXR0cnNba2V5XSAqIGZhY3RvcikgLyBmYWN0b3JcclxuICAgIH0pXHJcblxyXG4gICAgdGhpcy5hdHRyKG5ld0F0dHJzKVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8vIFJldHVybiBpZCBvbiBzdHJpbmcgY29udmVyc2lvblxyXG4gIHRvU3RyaW5nICgpIHtcclxuICAgIHJldHVybiB0aGlzLmlkKClcclxuICB9XHJcblxyXG4gIC8vIEltcG9ydCByYXcgc3ZnXHJcbiAgc3ZnIChzdmdPckZuLCBvdXRlckhUTUwpIHtcclxuICAgIHZhciB3ZWxsLCBsZW4sIGZyYWdtZW50XHJcblxyXG4gICAgaWYgKHN2Z09yRm4gPT09IGZhbHNlKSB7XHJcbiAgICAgIG91dGVySFRNTCA9IGZhbHNlXHJcbiAgICAgIHN2Z09yRm4gPSBudWxsXHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWN0IGFzIGdldHRlciBpZiBubyBzdmcgc3RyaW5nIGlzIGdpdmVuXHJcbiAgICBpZiAoc3ZnT3JGbiA9PSBudWxsIHx8IHR5cGVvZiBzdmdPckZuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIC8vIFRoZSBkZWZhdWx0IGZvciBleHBvcnRzIGlzLCB0aGF0IHRoZSBvdXRlck5vZGUgaXMgaW5jbHVkZWRcclxuICAgICAgb3V0ZXJIVE1MID0gb3V0ZXJIVE1MID09IG51bGwgPyB0cnVlIDogb3V0ZXJIVE1MXHJcblxyXG4gICAgICAvLyB3cml0ZSBzdmdqcyBkYXRhIHRvIHRoZSBkb21cclxuICAgICAgdGhpcy53cml0ZURhdGFUb0RvbSgpXHJcbiAgICAgIGxldCBjdXJyZW50ID0gdGhpc1xyXG5cclxuICAgICAgLy8gQW4gZXhwb3J0IG1vZGlmaWVyIHdhcyBwYXNzZWRcclxuICAgICAgaWYgKHN2Z09yRm4gIT0gbnVsbCkge1xyXG4gICAgICAgIGN1cnJlbnQgPSBhZG9wdChjdXJyZW50Lm5vZGUuY2xvbmVOb2RlKHRydWUpKVxyXG5cclxuICAgICAgICAvLyBJZiB0aGUgdXNlciB3YW50cyBvdXRlckhUTUwgd2UgbmVlZCB0byBwcm9jZXNzIHRoaXMgbm9kZSwgdG9vXHJcbiAgICAgICAgaWYgKG91dGVySFRNTCkge1xyXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gc3ZnT3JGbihjdXJyZW50KVxyXG4gICAgICAgICAgY3VycmVudCA9IHJlc3VsdCB8fCBjdXJyZW50XHJcblxyXG4gICAgICAgICAgLy8gVGhlIHVzZXIgZG9lcyBub3Qgd2FudCB0aGlzIG5vZGU/IFdlbGwsIHRoZW4gaGUgZ2V0cyBub3RoaW5nXHJcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkgcmV0dXJuICcnXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWVwIGxvb3AgdGhyb3VnaCBhbGwgY2hpbGRyZW4gYW5kIGFwcGx5IG1vZGlmaWVyXHJcbiAgICAgICAgY3VycmVudC5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHN2Z09yRm4odGhpcylcclxuICAgICAgICAgIGNvbnN0IF90aGlzID0gcmVzdWx0IHx8IHRoaXNcclxuXHJcbiAgICAgICAgICAvLyBJZiBtb2RpZmllciByZXR1cm5zIGZhbHNlLCBkaXNjYXJkIG5vZGVcclxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKClcclxuXHJcbiAgICAgICAgICAgIC8vIElmIG1vZGlmaWVyIHJldHVybnMgbmV3IG5vZGUsIHVzZSBpdFxyXG4gICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQgJiYgdGhpcyAhPT0gX3RoaXMpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXBsYWNlKF90aGlzKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIHRydWUpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJldHVybiBvdXRlciBvciBpbm5lciBjb250ZW50XHJcbiAgICAgIHJldHVybiBvdXRlckhUTUxcclxuICAgICAgICA/IGN1cnJlbnQubm9kZS5vdXRlckhUTUxcclxuICAgICAgICA6IGN1cnJlbnQubm9kZS5pbm5lckhUTUxcclxuICAgIH1cclxuXHJcbiAgICAvLyBBY3QgYXMgc2V0dGVyIGlmIHdlIGdvdCBhIHN0cmluZ1xyXG5cclxuICAgIC8vIFRoZSBkZWZhdWx0IGZvciBpbXBvcnQgaXMsIHRoYXQgdGhlIGN1cnJlbnQgbm9kZSBpcyBub3QgcmVwbGFjZWRcclxuICAgIG91dGVySFRNTCA9IG91dGVySFRNTCA9PSBudWxsID8gZmFsc2UgOiBvdXRlckhUTUxcclxuXHJcbiAgICAvLyBDcmVhdGUgdGVtcG9yYXJ5IGhvbGRlclxyXG4gICAgd2VsbCA9IGdsb2JhbHMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCAnc3ZnJylcclxuICAgIGZyYWdtZW50ID0gZ2xvYmFscy5kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcclxuXHJcbiAgICAvLyBEdW1wIHJhdyBzdmdcclxuICAgIHdlbGwuaW5uZXJIVE1MID0gc3ZnT3JGblxyXG5cclxuICAgIC8vIFRyYW5zcGxhbnQgbm9kZXMgaW50byB0aGUgZnJhZ21lbnRcclxuICAgIGZvciAobGVuID0gd2VsbC5jaGlsZHJlbi5sZW5ndGg7IGxlbi0tOykge1xyXG4gICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZCh3ZWxsLmZpcnN0RWxlbWVudENoaWxkKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50KClcclxuXHJcbiAgICAvLyBBZGQgdGhlIHdob2xlIGZyYWdtZW50IGF0IG9uY2VcclxuICAgIHJldHVybiBvdXRlckhUTUxcclxuICAgICAgPyB0aGlzLnJlcGxhY2UoZnJhZ21lbnQpICYmIHBhcmVudFxyXG4gICAgICA6IHRoaXMuYWRkKGZyYWdtZW50KVxyXG4gIH1cclxuXHJcbiAgd29yZHMgKHRleHQpIHtcclxuICAgIC8vIFRoaXMgaXMgZmFzdGVyIHRoYW4gcmVtb3ZpbmcgYWxsIGNoaWxkcmVuIGFuZCBhZGRpbmcgYSBuZXcgb25lXHJcbiAgICB0aGlzLm5vZGUudGV4dENvbnRlbnQgPSB0ZXh0XHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgLy8gd3JpdGUgc3ZnanMgZGF0YSB0byB0aGUgZG9tXHJcbiAgd3JpdGVEYXRhVG9Eb20gKCkge1xyXG4gICAgLy8gZHVtcCB2YXJpYWJsZXMgcmVjdXJzaXZlbHlcclxuICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMud3JpdGVEYXRhVG9Eb20oKVxyXG4gICAgfSlcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxufVxyXG5cclxuZXh0ZW5kKERvbSwgeyBhdHRyLCBmaW5kLCBmaW5kT25lIH0pXHJcbnJlZ2lzdGVyKERvbSwgJ0RvbScpXHJcbiIsImltcG9ydCB7IGJib3gsIHJib3ggfSBmcm9tICcuLi90eXBlcy9Cb3guanMnXHJcbmltcG9ydCB7IGN0bSwgc2NyZWVuQ1RNIH0gZnJvbSAnLi4vdHlwZXMvTWF0cml4LmpzJ1xyXG5pbXBvcnQge1xyXG4gIGV4dGVuZCxcclxuICBnZXRDbGFzcyxcclxuICBtYWtlSW5zdGFuY2UsXHJcbiAgcmVnaXN0ZXIsXHJcbiAgcm9vdFxyXG59IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuLi91dGlscy93aW5kb3cuanMnXHJcbmltcG9ydCB7IHBvaW50IH0gZnJvbSAnLi4vdHlwZXMvUG9pbnQuanMnXHJcbmltcG9ydCB7IHByb3BvcnRpb25hbFNpemUgfSBmcm9tICcuLi91dGlscy91dGlscy5qcydcclxuaW1wb3J0IHsgcmVmZXJlbmNlIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3JlZ2V4LmpzJ1xyXG5pbXBvcnQgRG9tIGZyb20gJy4vRG9tLmpzJ1xyXG5pbXBvcnQgTGlzdCBmcm9tICcuLi90eXBlcy9MaXN0LmpzJ1xyXG5pbXBvcnQgU1ZHTnVtYmVyIGZyb20gJy4uL3R5cGVzL1NWR051bWJlci5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVsZW1lbnQgZXh0ZW5kcyBEb20ge1xyXG4gIGNvbnN0cnVjdG9yIChub2RlLCBhdHRycykge1xyXG4gICAgc3VwZXIobm9kZSwgYXR0cnMpXHJcblxyXG4gICAgLy8gaW5pdGlhbGl6ZSBkYXRhIG9iamVjdFxyXG4gICAgdGhpcy5kb20gPSB7fVxyXG5cclxuICAgIC8vIGNyZWF0ZSBjaXJjdWxhciByZWZlcmVuY2VcclxuICAgIHRoaXMubm9kZS5pbnN0YW5jZSA9IHRoaXNcclxuXHJcbiAgICBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoJ3N2Z2pzOmRhdGEnKSkge1xyXG4gICAgICAvLyBwdWxsIHN2Z2pzIGRhdGEgZnJvbSB0aGUgZG9tIChnZXRBdHRyaWJ1dGVOUyBkb2Vzbid0IHdvcmsgaW4gaHRtbDUpXHJcbiAgICAgIHRoaXMuc2V0RGF0YShKU09OLnBhcnNlKG5vZGUuZ2V0QXR0cmlidXRlKCdzdmdqczpkYXRhJykpIHx8IHt9KVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gTW92ZSBlbGVtZW50IGJ5IGl0cyBjZW50ZXJcclxuICBjZW50ZXIgKHgsIHkpIHtcclxuICAgIHJldHVybiB0aGlzLmN4KHgpLmN5KHkpXHJcbiAgfVxyXG5cclxuICAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHgtYXhpc1xyXG4gIGN4ICh4KSB7XHJcbiAgICByZXR1cm4geCA9PSBudWxsID8gdGhpcy54KCkgKyB0aGlzLndpZHRoKCkgLyAyIDogdGhpcy54KHggLSB0aGlzLndpZHRoKCkgLyAyKVxyXG4gIH1cclxuXHJcbiAgLy8gTW92ZSBieSBjZW50ZXIgb3ZlciB5LWF4aXNcclxuICBjeSAoeSkge1xyXG4gICAgcmV0dXJuIHkgPT0gbnVsbFxyXG4gICAgICA/IHRoaXMueSgpICsgdGhpcy5oZWlnaHQoKSAvIDJcclxuICAgICAgOiB0aGlzLnkoeSAtIHRoaXMuaGVpZ2h0KCkgLyAyKVxyXG4gIH1cclxuXHJcbiAgLy8gR2V0IGRlZnNcclxuICBkZWZzICgpIHtcclxuICAgIHJldHVybiB0aGlzLnJvb3QoKS5kZWZzKClcclxuICB9XHJcblxyXG4gIC8vIFJlbGF0aXZlIG1vdmUgb3ZlciB4IGFuZCB5IGF4ZXNcclxuICBkbW92ZSAoeCwgeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuZHgoeCkuZHkoeSlcclxuICB9XHJcblxyXG4gIC8vIFJlbGF0aXZlIG1vdmUgb3ZlciB4IGF4aXNcclxuICBkeCAoeCA9IDApIHtcclxuICAgIHJldHVybiB0aGlzLngobmV3IFNWR051bWJlcih4KS5wbHVzKHRoaXMueCgpKSlcclxuICB9XHJcblxyXG4gIC8vIFJlbGF0aXZlIG1vdmUgb3ZlciB5IGF4aXNcclxuICBkeSAoeSA9IDApIHtcclxuICAgIHJldHVybiB0aGlzLnkobmV3IFNWR051bWJlcih5KS5wbHVzKHRoaXMueSgpKSlcclxuICB9XHJcblxyXG4gIC8vIEdldCBwYXJlbnQgZG9jdW1lbnRcclxuICByb290ICgpIHtcclxuICAgIGNvbnN0IHAgPSB0aGlzLnBhcmVudChnZXRDbGFzcyhyb290KSlcclxuICAgIHJldHVybiBwICYmIHAucm9vdCgpXHJcbiAgfVxyXG5cclxuICBnZXRFdmVudEhvbGRlciAoKSB7XHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XHJcbiAgaGVpZ2h0IChoZWlnaHQpIHtcclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ2hlaWdodCcsIGhlaWdodClcclxuICB9XHJcblxyXG4gIC8vIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBwb2ludCBpbnNpZGUgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgZWxlbWVudFxyXG4gIGluc2lkZSAoeCwgeSkge1xyXG4gICAgY29uc3QgYm94ID0gdGhpcy5iYm94KClcclxuXHJcbiAgICByZXR1cm4geCA+IGJveC54XHJcbiAgICAgICYmIHkgPiBib3gueVxyXG4gICAgICAmJiB4IDwgYm94LnggKyBib3gud2lkdGhcclxuICAgICAgJiYgeSA8IGJveC55ICsgYm94LmhlaWdodFxyXG4gIH1cclxuXHJcbiAgLy8gTW92ZSBlbGVtZW50IHRvIGdpdmVuIHggYW5kIHkgdmFsdWVzXHJcbiAgbW92ZSAoeCwgeSkge1xyXG4gICAgcmV0dXJuIHRoaXMueCh4KS55KHkpXHJcbiAgfVxyXG5cclxuICAvLyByZXR1cm4gYXJyYXkgb2YgYWxsIGFuY2VzdG9ycyBvZiBnaXZlbiB0eXBlIHVwIHRvIHRoZSByb290IHN2Z1xyXG4gIHBhcmVudHMgKHVudGlsID0gZ2xvYmFscy5kb2N1bWVudCkge1xyXG4gICAgdW50aWwgPSBtYWtlSW5zdGFuY2UodW50aWwpXHJcbiAgICBjb25zdCBwYXJlbnRzID0gbmV3IExpc3QoKVxyXG4gICAgbGV0IHBhcmVudCA9IHRoaXNcclxuXHJcbiAgICB3aGlsZSAoXHJcbiAgICAgIChwYXJlbnQgPSBwYXJlbnQucGFyZW50KCkpXHJcbiAgICAgICYmIHBhcmVudC5ub2RlICE9PSB1bnRpbC5ub2RlXHJcbiAgICAgICYmIHBhcmVudC5ub2RlICE9PSBnbG9iYWxzLmRvY3VtZW50XHJcbiAgICApIHtcclxuICAgICAgcGFyZW50cy5wdXNoKHBhcmVudClcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGFyZW50c1xyXG4gIH1cclxuXHJcbiAgLy8gR2V0IHJlZmVyZW5jZWQgZWxlbWVudCBmb3JtIGF0dHJpYnV0ZSB2YWx1ZVxyXG4gIHJlZmVyZW5jZSAoYXR0cikge1xyXG4gICAgYXR0ciA9IHRoaXMuYXR0cihhdHRyKVxyXG4gICAgaWYgKCFhdHRyKSByZXR1cm4gbnVsbFxyXG5cclxuICAgIGNvbnN0IG0gPSBhdHRyLm1hdGNoKHJlZmVyZW5jZSlcclxuICAgIHJldHVybiBtID8gbWFrZUluc3RhbmNlKG1bMV0pIDogbnVsbFxyXG4gIH1cclxuXHJcbiAgLy8gc2V0IGdpdmVuIGRhdGEgdG8gdGhlIGVsZW1lbnRzIGRhdGEgcHJvcGVydHlcclxuICBzZXREYXRhIChvKSB7XHJcbiAgICB0aGlzLmRvbSA9IG9cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvLyBTZXQgZWxlbWVudCBzaXplIHRvIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHRcclxuICBzaXplICh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICBjb25zdCBwID0gcHJvcG9ydGlvbmFsU2l6ZSh0aGlzLCB3aWR0aCwgaGVpZ2h0KVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgICAgIC53aWR0aChuZXcgU1ZHTnVtYmVyKHAud2lkdGgpKVxyXG4gICAgICAuaGVpZ2h0KG5ldyBTVkdOdW1iZXIocC5oZWlnaHQpKVxyXG4gIH1cclxuXHJcbiAgLy8gU2V0IHdpZHRoIG9mIGVsZW1lbnRcclxuICB3aWR0aCAod2lkdGgpIHtcclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ3dpZHRoJywgd2lkdGgpXHJcbiAgfVxyXG5cclxuICAvLyB3cml0ZSBzdmdqcyBkYXRhIHRvIHRoZSBkb21cclxuICB3cml0ZURhdGFUb0RvbSAoKSB7XHJcbiAgICAvLyByZW1vdmUgcHJldmlvdXNseSBzZXQgZGF0YVxyXG4gICAgdGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZSgnc3ZnanM6ZGF0YScpXHJcblxyXG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuZG9tKS5sZW5ndGgpIHtcclxuICAgICAgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgnc3ZnanM6ZGF0YScsIEpTT04uc3RyaW5naWZ5KHRoaXMuZG9tKSkgLy8gc2VlICM0MjhcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3VwZXIud3JpdGVEYXRhVG9Eb20oKVxyXG4gIH1cclxuXHJcbiAgLy8gTW92ZSBvdmVyIHgtYXhpc1xyXG4gIHggKHgpIHtcclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ3gnLCB4KVxyXG4gIH1cclxuXHJcbiAgLy8gTW92ZSBvdmVyIHktYXhpc1xyXG4gIHkgKHkpIHtcclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ3knLCB5KVxyXG4gIH1cclxufVxyXG5cclxuZXh0ZW5kKEVsZW1lbnQsIHtcclxuICBiYm94LCByYm94LCBwb2ludCwgY3RtLCBzY3JlZW5DVE1cclxufSlcclxuXHJcbnJlZ2lzdGVyKEVsZW1lbnQsICdFbGVtZW50JylcclxuIiwiaW1wb3J0IHsgb24sIG9mZiB9IGZyb20gJy4uL2NvcmUvZXZlbnQuanMnXHJcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uLy4uL3V0aWxzL21ldGhvZHMuanMnXHJcbmltcG9ydCBDb2xvciBmcm9tICcuLi8uLi90eXBlcy9Db2xvci5qcydcclxuaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vLi4vZWxlbWVudHMvRWxlbWVudC5qcydcclxuaW1wb3J0IE1hdHJpeCBmcm9tICcuLi8uLi90eXBlcy9NYXRyaXguanMnXHJcbmltcG9ydCBQb2ludCBmcm9tICcuLi8uLi90eXBlcy9Qb2ludC5qcydcclxuaW1wb3J0IFNWR051bWJlciBmcm9tICcuLi8uLi90eXBlcy9TVkdOdW1iZXIuanMnXHJcblxyXG4vLyBEZWZpbmUgbGlzdCBvZiBhdmFpbGFibGUgYXR0cmlidXRlcyBmb3Igc3Ryb2tlIGFuZCBmaWxsXHJcbnZhciBzdWdhciA9IHtcclxuICBzdHJva2U6IFsgJ2NvbG9yJywgJ3dpZHRoJywgJ29wYWNpdHknLCAnbGluZWNhcCcsICdsaW5lam9pbicsICdtaXRlcmxpbWl0JywgJ2Rhc2hhcnJheScsICdkYXNob2Zmc2V0JyBdLFxyXG4gIGZpbGw6IFsgJ2NvbG9yJywgJ29wYWNpdHknLCAncnVsZScgXSxcclxuICBwcmVmaXg6IGZ1bmN0aW9uICh0LCBhKSB7XHJcbiAgICByZXR1cm4gYSA9PT0gJ2NvbG9yJyA/IHQgOiB0ICsgJy0nICsgYVxyXG4gIH1cclxufVxyXG5cclxuLy8gQWRkIHN1Z2FyIGZvciBmaWxsIGFuZCBzdHJva2VcclxuO1sgJ2ZpbGwnLCAnc3Ryb2tlJyBdLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcclxuICB2YXIgZXh0ZW5zaW9uID0ge31cclxuICB2YXIgaVxyXG5cclxuICBleHRlbnNpb25bbV0gPSBmdW5jdGlvbiAobykge1xyXG4gICAgaWYgKHR5cGVvZiBvID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKG0pXHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIG8gPT09ICdzdHJpbmcnIHx8IG8gaW5zdGFuY2VvZiBDb2xvciB8fCBDb2xvci5pc1JnYihvKSB8fCAobyBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XHJcbiAgICAgIHRoaXMuYXR0cihtLCBvKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gc2V0IGFsbCBhdHRyaWJ1dGVzIGZyb20gc3VnYXIuZmlsbCBhbmQgc3VnYXIuc3Ryb2tlIGxpc3RcclxuICAgICAgZm9yIChpID0gc3VnYXJbbV0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBpZiAob1tzdWdhclttXVtpXV0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgdGhpcy5hdHRyKHN1Z2FyLnByZWZpeChtLCBzdWdhclttXVtpXSksIG9bc3VnYXJbbV1baV1dKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICByZWdpc3Rlck1ldGhvZHMoWyAnRWxlbWVudCcsICdSdW5uZXInIF0sIGV4dGVuc2lvbilcclxufSlcclxuXHJcbnJlZ2lzdGVyTWV0aG9kcyhbICdFbGVtZW50JywgJ1J1bm5lcicgXSwge1xyXG4gIC8vIExldCB0aGUgdXNlciBzZXQgdGhlIG1hdHJpeCBkaXJlY3RseVxyXG4gIG1hdHJpeDogZnVuY3Rpb24gKG1hdCwgYiwgYywgZCwgZSwgZikge1xyXG4gICAgLy8gQWN0IGFzIGEgZ2V0dGVyXHJcbiAgICBpZiAobWF0ID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIG5ldyBNYXRyaXgodGhpcylcclxuICAgIH1cclxuXHJcbiAgICAvLyBBY3QgYXMgYSBzZXR0ZXIsIHRoZSB1c2VyIGNhbiBwYXNzIGEgbWF0cml4IG9yIGEgc2V0IG9mIG51bWJlcnNcclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ3RyYW5zZm9ybScsIG5ldyBNYXRyaXgobWF0LCBiLCBjLCBkLCBlLCBmKSlcclxuICB9LFxyXG5cclxuICAvLyBNYXAgcm90YXRpb24gdG8gdHJhbnNmb3JtXHJcbiAgcm90YXRlOiBmdW5jdGlvbiAoYW5nbGUsIGN4LCBjeSkge1xyXG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHsgcm90YXRlOiBhbmdsZSwgb3g6IGN4LCBveTogY3kgfSwgdHJ1ZSlcclxuICB9LFxyXG5cclxuICAvLyBNYXAgc2tldyB0byB0cmFuc2Zvcm1cclxuICBza2V3OiBmdW5jdGlvbiAoeCwgeSwgY3gsIGN5KSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAzXHJcbiAgICAgID8gdGhpcy50cmFuc2Zvcm0oeyBza2V3OiB4LCBveDogeSwgb3k6IGN4IH0sIHRydWUpXHJcbiAgICAgIDogdGhpcy50cmFuc2Zvcm0oeyBza2V3OiBbIHgsIHkgXSwgb3g6IGN4LCBveTogY3kgfSwgdHJ1ZSlcclxuICB9LFxyXG5cclxuICBzaGVhcjogZnVuY3Rpb24gKGxhbSwgY3gsIGN5KSB7XHJcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oeyBzaGVhcjogbGFtLCBveDogY3gsIG95OiBjeSB9LCB0cnVlKVxyXG4gIH0sXHJcblxyXG4gIC8vIE1hcCBzY2FsZSB0byB0cmFuc2Zvcm1cclxuICBzY2FsZTogZnVuY3Rpb24gKHgsIHksIGN4LCBjeSkge1xyXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gM1xyXG4gICAgICA/IHRoaXMudHJhbnNmb3JtKHsgc2NhbGU6IHgsIG94OiB5LCBveTogY3ggfSwgdHJ1ZSlcclxuICAgICAgOiB0aGlzLnRyYW5zZm9ybSh7IHNjYWxlOiBbIHgsIHkgXSwgb3g6IGN4LCBveTogY3kgfSwgdHJ1ZSlcclxuICB9LFxyXG5cclxuICAvLyBNYXAgdHJhbnNsYXRlIHRvIHRyYW5zZm9ybVxyXG4gIHRyYW5zbGF0ZTogZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSh7IHRyYW5zbGF0ZTogWyB4LCB5IF0gfSwgdHJ1ZSlcclxuICB9LFxyXG5cclxuICAvLyBNYXAgcmVsYXRpdmUgdHJhbnNsYXRpb25zIHRvIHRyYW5zZm9ybVxyXG4gIHJlbGF0aXZlOiBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHsgcmVsYXRpdmU6IFsgeCwgeSBdIH0sIHRydWUpXHJcbiAgfSxcclxuXHJcbiAgLy8gTWFwIGZsaXAgdG8gdHJhbnNmb3JtXHJcbiAgZmxpcDogZnVuY3Rpb24gKGRpcmVjdGlvbiwgYXJvdW5kKSB7XHJcbiAgICB2YXIgZGlyZWN0aW9uU3RyaW5nID0gdHlwZW9mIGRpcmVjdGlvbiA9PT0gJ3N0cmluZycgPyBkaXJlY3Rpb25cclxuICAgICAgOiBpc0Zpbml0ZShkaXJlY3Rpb24pID8gJ2JvdGgnXHJcbiAgICAgIDogJ2JvdGgnXHJcbiAgICB2YXIgb3JpZ2luID0gKGRpcmVjdGlvbiA9PT0gJ2JvdGgnICYmIGlzRmluaXRlKGFyb3VuZCkpID8gWyBhcm91bmQsIGFyb3VuZCBdXHJcbiAgICAgIDogKGRpcmVjdGlvbiA9PT0gJ3gnKSA/IFsgYXJvdW5kLCAwIF1cclxuICAgICAgOiAoZGlyZWN0aW9uID09PSAneScpID8gWyAwLCBhcm91bmQgXVxyXG4gICAgICA6IGlzRmluaXRlKGRpcmVjdGlvbikgPyBbIGRpcmVjdGlvbiwgZGlyZWN0aW9uIF1cclxuICAgICAgOiBbIDAsIDAgXVxyXG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHsgZmxpcDogZGlyZWN0aW9uU3RyaW5nLCBvcmlnaW46IG9yaWdpbiB9LCB0cnVlKVxyXG4gIH0sXHJcblxyXG4gIC8vIE9wYWNpdHlcclxuICBvcGFjaXR5OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ29wYWNpdHknLCB2YWx1ZSlcclxuICB9XHJcbn0pXHJcblxyXG5yZWdpc3Rlck1ldGhvZHMoJ3JhZGl1cycsIHtcclxuICAvLyBBZGQgeCBhbmQgeSByYWRpdXNcclxuICByYWRpdXM6IGZ1bmN0aW9uICh4LCB5KSB7XHJcbiAgICB2YXIgdHlwZSA9ICh0aGlzLl9lbGVtZW50IHx8IHRoaXMpLnR5cGVcclxuICAgIHJldHVybiB0eXBlID09PSAncmFkaWFsR3JhZGllbnQnIHx8IHR5cGUgPT09ICdyYWRpYWxHcmFkaWVudCdcclxuICAgICAgPyB0aGlzLmF0dHIoJ3InLCBuZXcgU1ZHTnVtYmVyKHgpKVxyXG4gICAgICA6IHRoaXMucngoeCkucnkoeSA9PSBudWxsID8geCA6IHkpXHJcbiAgfVxyXG59KVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKCdQYXRoJywge1xyXG4gIC8vIEdldCBwYXRoIGxlbmd0aFxyXG4gIGxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubm9kZS5nZXRUb3RhbExlbmd0aCgpXHJcbiAgfSxcclxuICAvLyBHZXQgcG9pbnQgYXQgbGVuZ3RoXHJcbiAgcG9pbnRBdDogZnVuY3Rpb24gKGxlbmd0aCkge1xyXG4gICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLm5vZGUuZ2V0UG9pbnRBdExlbmd0aChsZW5ndGgpKVxyXG4gIH1cclxufSlcclxuXHJcbnJlZ2lzdGVyTWV0aG9kcyhbICdFbGVtZW50JywgJ1J1bm5lcicgXSwge1xyXG4gIC8vIFNldCBmb250XHJcbiAgZm9udDogZnVuY3Rpb24gKGEsIHYpIHtcclxuICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgZm9yICh2IGluIGEpIHRoaXMuZm9udCh2LCBhW3ZdKVxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhID09PSAnbGVhZGluZydcclxuICAgICAgPyB0aGlzLmxlYWRpbmcodilcclxuICAgICAgOiBhID09PSAnYW5jaG9yJ1xyXG4gICAgICAgID8gdGhpcy5hdHRyKCd0ZXh0LWFuY2hvcicsIHYpXHJcbiAgICAgICAgOiBhID09PSAnc2l6ZScgfHwgYSA9PT0gJ2ZhbWlseScgfHwgYSA9PT0gJ3dlaWdodCcgfHwgYSA9PT0gJ3N0cmV0Y2gnIHx8IGEgPT09ICd2YXJpYW50JyB8fCBhID09PSAnc3R5bGUnXHJcbiAgICAgICAgICA/IHRoaXMuYXR0cignZm9udC0nICsgYSwgdilcclxuICAgICAgICAgIDogdGhpcy5hdHRyKGEsIHYpXHJcbiAgfVxyXG59KVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKCdUZXh0Jywge1xyXG4gIGF4ICh4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCd4JywgeClcclxuICB9LFxyXG4gIGF5ICh5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCd5JywgeSlcclxuICB9LFxyXG4gIGFtb3ZlICh4LCB5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5heCh4KS5heSh5KVxyXG4gIH1cclxufSlcclxuXHJcbi8vIEFkZCBldmVudHMgdG8gZWxlbWVudHNcclxuY29uc3QgbWV0aG9kcyA9IFsgJ2NsaWNrJyxcclxuICAnZGJsY2xpY2snLFxyXG4gICdtb3VzZWRvd24nLFxyXG4gICdtb3VzZXVwJyxcclxuICAnbW91c2VvdmVyJyxcclxuICAnbW91c2VvdXQnLFxyXG4gICdtb3VzZW1vdmUnLFxyXG4gICdtb3VzZWVudGVyJyxcclxuICAnbW91c2VsZWF2ZScsXHJcbiAgJ3RvdWNoc3RhcnQnLFxyXG4gICd0b3VjaG1vdmUnLFxyXG4gICd0b3VjaGxlYXZlJyxcclxuICAndG91Y2hlbmQnLFxyXG4gICd0b3VjaGNhbmNlbCcgXS5yZWR1Y2UoZnVuY3Rpb24gKGxhc3QsIGV2ZW50KSB7XHJcbiAgLy8gYWRkIGV2ZW50IHRvIEVsZW1lbnRcclxuICBjb25zdCBmbiA9IGZ1bmN0aW9uIChmKSB7XHJcbiAgICBpZiAoZiA9PT0gbnVsbCkge1xyXG4gICAgICBvZmYodGhpcywgZXZlbnQpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBvbih0aGlzLCBldmVudCwgZilcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICBsYXN0W2V2ZW50XSA9IGZuXHJcbiAgcmV0dXJuIGxhc3RcclxufSwge30pXHJcblxyXG5yZWdpc3Rlck1ldGhvZHMoJ0VsZW1lbnQnLCBtZXRob2RzKVxyXG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5Jyk7XG5cbnZhciBuYXRpdmVSZXZlcnNlID0gW10ucmV2ZXJzZTtcbnZhciB0ZXN0ID0gWzEsIDJdO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnJldmVyc2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJldmVyc2Vcbi8vIGZpeCBmb3IgU2FmYXJpIDEyLjAgYnVnXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTg4Nzk0XG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBTdHJpbmcodGVzdCkgPT09IFN0cmluZyh0ZXN0LnJldmVyc2UoKSkgfSwge1xuICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnblxuICAgIGlmIChpc0FycmF5KHRoaXMpKSB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIHJldHVybiBuYXRpdmVSZXZlcnNlLmNhbGwodGhpcyk7XG4gIH1cbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcycpO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFERVNDUklQVE9SUywgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgZGVmaW5lUHJvcGVydGllczogZGVmaW5lUHJvcGVydGllc1xufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIG9iamVjdERlZmluZVByb3BlcnR5TW9kaWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFERVNDUklQVE9SUywgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgZGVmaW5lUHJvcGVydHk6IG9iamVjdERlZmluZVByb3BlcnR5TW9kaWxlLmZcbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpLmY7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcblxudmFyIEZBSUxTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcigxKTsgfSk7XG52YXIgRk9SQ0VEID0gIURFU0NSSVBUT1JTIHx8IEZBSUxTX09OX1BSSU1JVElWRVM7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICAgIHJldHVybiBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JbmRleGVkT2JqZWN0KGl0KSwga2V5KTtcbiAgfVxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIG93bktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb3duLWtleXMnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iamVjdCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KG9iamVjdCk7XG4gICAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xuICAgIHZhciBrZXlzID0gb3duS2V5cyhPKTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIga2V5LCBkZXNjcmlwdG9yO1xuICAgIHdoaWxlIChrZXlzLmxlbmd0aCA+IGluZGV4KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIGtleSA9IGtleXNbaW5kZXgrK10pO1xuICAgICAgaWYgKGRlc2NyaXB0b3IgIT09IHVuZGVmaW5lZCkgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSIsImltcG9ydCB7IGdldE9yaWdpbiB9IGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzLmpzJ1xyXG5pbXBvcnQgeyBkZWxpbWl0ZXIsIHRyYW5zZm9ybXMgfSBmcm9tICcuLi9jb3JlL3JlZ2V4LmpzJ1xyXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi8uLi91dGlscy9tZXRob2RzLmpzJ1xyXG5pbXBvcnQgTWF0cml4IGZyb20gJy4uLy4uL3R5cGVzL01hdHJpeC5qcydcclxuXHJcbi8vIFJlc2V0IGFsbCB0cmFuc2Zvcm1hdGlvbnNcclxuZXhwb3J0IGZ1bmN0aW9uIHVudHJhbnNmb3JtICgpIHtcclxuICByZXR1cm4gdGhpcy5hdHRyKCd0cmFuc2Zvcm0nLCBudWxsKVxyXG59XHJcblxyXG4vLyBtZXJnZSB0aGUgd2hvbGUgdHJhbnNmb3JtYXRpb24gY2hhaW4gaW50byBvbmUgbWF0cml4IGFuZCByZXR1cm5zIGl0XHJcbmV4cG9ydCBmdW5jdGlvbiBtYXRyaXhpZnkgKCkge1xyXG4gIHZhciBtYXRyaXggPSAodGhpcy5hdHRyKCd0cmFuc2Zvcm0nKSB8fCAnJylcclxuICAgIC8vIHNwbGl0IHRyYW5zZm9ybWF0aW9uc1xyXG4gICAgLnNwbGl0KHRyYW5zZm9ybXMpLnNsaWNlKDAsIC0xKS5tYXAoZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAvLyBnZW5lcmF0ZSBrZXkgPT4gdmFsdWUgcGFpcnNcclxuICAgICAgdmFyIGt2ID0gc3RyLnRyaW0oKS5zcGxpdCgnKCcpXHJcbiAgICAgIHJldHVybiBbIGt2WzBdLFxyXG4gICAgICAgIGt2WzFdLnNwbGl0KGRlbGltaXRlcilcclxuICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHIpXHJcbiAgICAgICAgICB9KVxyXG4gICAgICBdXHJcbiAgICB9KVxyXG4gICAgLnJldmVyc2UoKVxyXG4gICAgLy8gbWVyZ2UgZXZlcnkgdHJhbnNmb3JtYXRpb24gaW50byBvbmUgbWF0cml4XHJcbiAgICAucmVkdWNlKGZ1bmN0aW9uIChtYXRyaXgsIHRyYW5zZm9ybSkge1xyXG4gICAgICBpZiAodHJhbnNmb3JtWzBdID09PSAnbWF0cml4Jykge1xyXG4gICAgICAgIHJldHVybiBtYXRyaXgubG11bHRpcGx5KE1hdHJpeC5mcm9tQXJyYXkodHJhbnNmb3JtWzFdKSlcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbWF0cml4W3RyYW5zZm9ybVswXV0uYXBwbHkobWF0cml4LCB0cmFuc2Zvcm1bMV0pXHJcbiAgICB9LCBuZXcgTWF0cml4KCkpXHJcblxyXG4gIHJldHVybiBtYXRyaXhcclxufVxyXG5cclxuLy8gYWRkIGFuIGVsZW1lbnQgdG8gYW5vdGhlciBwYXJlbnQgd2l0aG91dCBjaGFuZ2luZyB0aGUgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9uIHRoZSBzY3JlZW5cclxuZXhwb3J0IGZ1bmN0aW9uIHRvUGFyZW50IChwYXJlbnQpIHtcclxuICBpZiAodGhpcyA9PT0gcGFyZW50KSByZXR1cm4gdGhpc1xyXG4gIHZhciBjdG0gPSB0aGlzLnNjcmVlbkNUTSgpXHJcbiAgdmFyIHBDdG0gPSBwYXJlbnQuc2NyZWVuQ1RNKCkuaW52ZXJzZSgpXHJcblxyXG4gIHRoaXMuYWRkVG8ocGFyZW50KS51bnRyYW5zZm9ybSgpLnRyYW5zZm9ybShwQ3RtLm11bHRpcGx5KGN0bSkpXHJcblxyXG4gIHJldHVybiB0aGlzXHJcbn1cclxuXHJcbi8vIHNhbWUgYXMgYWJvdmUgd2l0aCBwYXJlbnQgZXF1YWxzIHJvb3Qtc3ZnXHJcbmV4cG9ydCBmdW5jdGlvbiB0b1Jvb3QgKCkge1xyXG4gIHJldHVybiB0aGlzLnRvUGFyZW50KHRoaXMucm9vdCgpKVxyXG59XHJcblxyXG4vLyBBZGQgdHJhbnNmb3JtYXRpb25zXHJcbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm0gKG8sIHJlbGF0aXZlKSB7XHJcbiAgLy8gQWN0IGFzIGEgZ2V0dGVyIGlmIG5vIG9iamVjdCB3YXMgcGFzc2VkXHJcbiAgaWYgKG8gPT0gbnVsbCB8fCB0eXBlb2YgbyA9PT0gJ3N0cmluZycpIHtcclxuICAgIHZhciBkZWNvbXBvc2VkID0gbmV3IE1hdHJpeCh0aGlzKS5kZWNvbXBvc2UoKVxyXG4gICAgcmV0dXJuIG8gPT0gbnVsbCA/IGRlY29tcG9zZWQgOiBkZWNvbXBvc2VkW29dXHJcbiAgfVxyXG5cclxuICBpZiAoIU1hdHJpeC5pc01hdHJpeExpa2UobykpIHtcclxuICAgIC8vIFNldCB0aGUgb3JpZ2luIGFjY29yZGluZyB0byB0aGUgZGVmaW5lZCB0cmFuc2Zvcm1cclxuICAgIG8gPSB7IC4uLm8sIG9yaWdpbjogZ2V0T3JpZ2luKG8sIHRoaXMpIH1cclxuICB9XHJcblxyXG4gIC8vIFRoZSB1c2VyIGNhbiBwYXNzIGEgYm9vbGVhbiwgYW4gRWxlbWVudCBvciBhbiBNYXRyaXggb3Igbm90aGluZ1xyXG4gIHZhciBjbGVhblJlbGF0aXZlID0gcmVsYXRpdmUgPT09IHRydWUgPyB0aGlzIDogKHJlbGF0aXZlIHx8IGZhbHNlKVxyXG4gIHZhciByZXN1bHQgPSBuZXcgTWF0cml4KGNsZWFuUmVsYXRpdmUpLnRyYW5zZm9ybShvKVxyXG4gIHJldHVybiB0aGlzLmF0dHIoJ3RyYW5zZm9ybScsIHJlc3VsdClcclxufVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKCdFbGVtZW50Jywge1xyXG4gIHVudHJhbnNmb3JtLCBtYXRyaXhpZnksIHRvUGFyZW50LCB0b1Jvb3QsIHRyYW5zZm9ybVxyXG59KVxyXG4iLCJpbXBvcnQgU1ZHTnVtYmVyIGZyb20gJy4uLy4uL3R5cGVzL1NWR051bWJlci5qcydcclxuXHJcbi8vIFJhZGl1cyB4IHZhbHVlXHJcbmV4cG9ydCBmdW5jdGlvbiByeCAocngpIHtcclxuICByZXR1cm4gdGhpcy5hdHRyKCdyeCcsIHJ4KVxyXG59XHJcblxyXG4vLyBSYWRpdXMgeSB2YWx1ZVxyXG5leHBvcnQgZnVuY3Rpb24gcnkgKHJ5KSB7XHJcbiAgcmV0dXJuIHRoaXMuYXR0cigncnknLCByeSlcclxufVxyXG5cclxuLy8gTW92ZSBvdmVyIHgtYXhpc1xyXG5leHBvcnQgZnVuY3Rpb24geCAoeCkge1xyXG4gIHJldHVybiB4ID09IG51bGxcclxuICAgID8gdGhpcy5jeCgpIC0gdGhpcy5yeCgpXHJcbiAgICA6IHRoaXMuY3goeCArIHRoaXMucngoKSlcclxufVxyXG5cclxuLy8gTW92ZSBvdmVyIHktYXhpc1xyXG5leHBvcnQgZnVuY3Rpb24geSAoeSkge1xyXG4gIHJldHVybiB5ID09IG51bGxcclxuICAgID8gdGhpcy5jeSgpIC0gdGhpcy5yeSgpXHJcbiAgICA6IHRoaXMuY3koeSArIHRoaXMucnkoKSlcclxufVxyXG5cclxuLy8gTW92ZSBieSBjZW50ZXIgb3ZlciB4LWF4aXNcclxuZXhwb3J0IGZ1bmN0aW9uIGN4ICh4KSB7XHJcbiAgcmV0dXJuIHggPT0gbnVsbFxyXG4gICAgPyB0aGlzLmF0dHIoJ2N4JylcclxuICAgIDogdGhpcy5hdHRyKCdjeCcsIHgpXHJcbn1cclxuXHJcbi8vIE1vdmUgYnkgY2VudGVyIG92ZXIgeS1heGlzXHJcbmV4cG9ydCBmdW5jdGlvbiBjeSAoeSkge1xyXG4gIHJldHVybiB5ID09IG51bGxcclxuICAgID8gdGhpcy5hdHRyKCdjeScpXHJcbiAgICA6IHRoaXMuYXR0cignY3knLCB5KVxyXG59XHJcblxyXG4vLyBTZXQgd2lkdGggb2YgZWxlbWVudFxyXG5leHBvcnQgZnVuY3Rpb24gd2lkdGggKHdpZHRoKSB7XHJcbiAgcmV0dXJuIHdpZHRoID09IG51bGxcclxuICAgID8gdGhpcy5yeCgpICogMlxyXG4gICAgOiB0aGlzLnJ4KG5ldyBTVkdOdW1iZXIod2lkdGgpLmRpdmlkZSgyKSlcclxufVxyXG5cclxuLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XHJcbmV4cG9ydCBmdW5jdGlvbiBoZWlnaHQgKGhlaWdodCkge1xyXG4gIHJldHVybiBoZWlnaHQgPT0gbnVsbFxyXG4gICAgPyB0aGlzLnJ5KCkgKiAyXHJcbiAgICA6IHRoaXMucnkobmV3IFNWR051bWJlcihoZWlnaHQpLmRpdmlkZSgyKSlcclxufVxyXG4iLCJpbXBvcnQgeyByZWdpc3RlciB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCBFbGVtZW50IGZyb20gJy4vRWxlbWVudC5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYXBlIGV4dGVuZHMgRWxlbWVudCB7fVxyXG5cclxucmVnaXN0ZXIoU2hhcGUsICdTaGFwZScpXHJcbiIsImltcG9ydCB7IGN4LCBjeSwgaGVpZ2h0LCB3aWR0aCwgeCwgeSB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9jaXJjbGVkLmpzJ1xyXG5pbXBvcnQge1xyXG4gIGV4dGVuZCxcclxuICBub2RlT3JOZXcsXHJcbiAgcmVnaXN0ZXIsXHJcbiAgd3JhcFdpdGhBdHRyQ2hlY2tcclxufSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xyXG5pbXBvcnQgU1ZHTnVtYmVyIGZyb20gJy4uL3R5cGVzL1NWR051bWJlci5qcydcclxuaW1wb3J0IFNoYXBlIGZyb20gJy4vU2hhcGUuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaXJjbGUgZXh0ZW5kcyBTaGFwZSB7XHJcbiAgY29uc3RydWN0b3IgKG5vZGUpIHtcclxuICAgIHN1cGVyKG5vZGVPck5ldygnY2lyY2xlJywgbm9kZSksIG5vZGUpXHJcbiAgfVxyXG5cclxuICByYWRpdXMgKHIpIHtcclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ3InLCByKVxyXG4gIH1cclxuXHJcbiAgLy8gUmFkaXVzIHggdmFsdWVcclxuICByeCAocngpIHtcclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ3InLCByeClcclxuICB9XHJcblxyXG4gIC8vIEFsaWFzIHJhZGl1cyB4IHZhbHVlXHJcbiAgcnkgKHJ5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5yeChyeSlcclxuICB9XHJcblxyXG4gIHNpemUgKHNpemUpIHtcclxuICAgIHJldHVybiB0aGlzLnJhZGl1cyhuZXcgU1ZHTnVtYmVyKHNpemUpLmRpdmlkZSgyKSlcclxuICB9XHJcbn1cclxuXHJcbmV4dGVuZChDaXJjbGUsIHsgeCwgeSwgY3gsIGN5LCB3aWR0aCwgaGVpZ2h0IH0pXHJcblxyXG5yZWdpc3Rlck1ldGhvZHMoe1xyXG4gIENvbnRhaW5lcjoge1xyXG4gICAgLy8gQ3JlYXRlIGNpcmNsZSBlbGVtZW50XHJcbiAgICBjaXJjbGU6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uIChzaXplKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgQ2lyY2xlKCkpXHJcbiAgICAgICAgLnNpemUoc2l6ZSlcclxuICAgICAgICAubW92ZSgwLCAwKVxyXG4gICAgfSlcclxuICB9XHJcbn0pXHJcblxyXG5yZWdpc3RlcihDaXJjbGUsICdDaXJjbGUnKVxyXG4iLCJpbXBvcnQgeyByZWdpc3RlciB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCBFbGVtZW50IGZyb20gJy4vRWxlbWVudC5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRhaW5lciBleHRlbmRzIEVsZW1lbnQge1xyXG4gIGZsYXR0ZW4gKHBhcmVudCkge1xyXG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBDb250YWluZXIpIHJldHVybiB0aGlzLmZsYXR0ZW4ocGFyZW50KS51bmdyb3VwKHBhcmVudClcclxuICAgICAgcmV0dXJuIHRoaXMudG9QYXJlbnQocGFyZW50KVxyXG4gICAgfSlcclxuXHJcbiAgICAvLyB3ZSBuZWVkIHRoaXMgc28gdGhhdCB0aGUgcm9vdCBkb2VzIG5vdCBnZXQgcmVtb3ZlZFxyXG4gICAgdGhpcy5ub2RlLmZpcnN0RWxlbWVudENoaWxkIHx8IHRoaXMucmVtb3ZlKClcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgdW5ncm91cCAocGFyZW50KSB7XHJcbiAgICBwYXJlbnQgPSBwYXJlbnQgfHwgdGhpcy5wYXJlbnQoKVxyXG5cclxuICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRvUGFyZW50KHBhcmVudClcclxuICAgIH0pXHJcblxyXG4gICAgdGhpcy5yZW1vdmUoKVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG59XHJcblxyXG5yZWdpc3RlcihDb250YWluZXIsICdDb250YWluZXInKVxyXG4iLCJpbXBvcnQgeyBub2RlT3JOZXcsIHJlZ2lzdGVyIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcclxuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL0NvbnRhaW5lci5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZnMgZXh0ZW5kcyBDb250YWluZXIge1xyXG4gIGNvbnN0cnVjdG9yIChub2RlKSB7XHJcbiAgICBzdXBlcihub2RlT3JOZXcoJ2RlZnMnLCBub2RlKSwgbm9kZSlcclxuICB9XHJcblxyXG4gIGZsYXR0ZW4gKCkge1xyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XG5cclxuICB1bmdyb3VwICgpIHtcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG59XHJcblxyXG5yZWdpc3RlcihEZWZzLCAnRGVmcycpXHJcbiIsImltcG9ydCB7XHJcbiAgZXh0ZW5kLFxyXG4gIG5vZGVPck5ldyxcclxuICByZWdpc3RlcixcclxuICB3cmFwV2l0aEF0dHJDaGVja1xyXG59IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IHByb3BvcnRpb25hbFNpemUgfSBmcm9tICcuLi91dGlscy91dGlscy5qcydcclxuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcclxuaW1wb3J0IFNWR051bWJlciBmcm9tICcuLi90eXBlcy9TVkdOdW1iZXIuanMnXHJcbmltcG9ydCBTaGFwZSBmcm9tICcuL1NoYXBlLmpzJ1xyXG5pbXBvcnQgKiBhcyBjaXJjbGVkIGZyb20gJy4uL21vZHVsZXMvY29yZS9jaXJjbGVkLmpzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWxsaXBzZSBleHRlbmRzIFNoYXBlIHtcclxuICBjb25zdHJ1Y3RvciAobm9kZSkge1xyXG4gICAgc3VwZXIobm9kZU9yTmV3KCdlbGxpcHNlJywgbm9kZSksIG5vZGUpXHJcbiAgfVxyXG5cclxuICBzaXplICh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICB2YXIgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodClcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gICAgICAucngobmV3IFNWR051bWJlcihwLndpZHRoKS5kaXZpZGUoMikpXHJcbiAgICAgIC5yeShuZXcgU1ZHTnVtYmVyKHAuaGVpZ2h0KS5kaXZpZGUoMikpXHJcbiAgfVxyXG59XHJcblxyXG5leHRlbmQoRWxsaXBzZSwgY2lyY2xlZClcclxuXHJcbnJlZ2lzdGVyTWV0aG9kcygnQ29udGFpbmVyJywge1xyXG4gIC8vIENyZWF0ZSBhbiBlbGxpcHNlXHJcbiAgZWxsaXBzZTogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHdpZHRoID0gMCwgaGVpZ2h0ID0gd2lkdGgpIHtcclxuICAgIHJldHVybiB0aGlzLnB1dChuZXcgRWxsaXBzZSgpKS5zaXplKHdpZHRoLCBoZWlnaHQpLm1vdmUoMCwgMClcclxuICB9KVxyXG59KVxyXG5cclxucmVnaXN0ZXIoRWxsaXBzZSwgJ0VsbGlwc2UnKVxyXG4iLCJpbXBvcnQgeyBub2RlT3JOZXcsIHJlZ2lzdGVyIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcclxuaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi9FbGVtZW50LmpzJ1xyXG5pbXBvcnQgU1ZHTnVtYmVyIGZyb20gJy4uL3R5cGVzL1NWR051bWJlci5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0b3AgZXh0ZW5kcyBFbGVtZW50IHtcclxuICBjb25zdHJ1Y3RvciAobm9kZSkge1xyXG4gICAgc3VwZXIobm9kZU9yTmV3KCdzdG9wJywgbm9kZSksIG5vZGUpXHJcbiAgfVxyXG5cclxuICAvLyBhZGQgY29sb3Igc3RvcHNcclxuICB1cGRhdGUgKG8pIHtcclxuICAgIGlmICh0eXBlb2YgbyA9PT0gJ251bWJlcicgfHwgbyBpbnN0YW5jZW9mIFNWR051bWJlcikge1xyXG4gICAgICBvID0ge1xyXG4gICAgICAgIG9mZnNldDogYXJndW1lbnRzWzBdLFxyXG4gICAgICAgIGNvbG9yOiBhcmd1bWVudHNbMV0sXHJcbiAgICAgICAgb3BhY2l0eTogYXJndW1lbnRzWzJdXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBzZXQgYXR0cmlidXRlc1xyXG4gICAgaWYgKG8ub3BhY2l0eSAhPSBudWxsKSB0aGlzLmF0dHIoJ3N0b3Atb3BhY2l0eScsIG8ub3BhY2l0eSlcclxuICAgIGlmIChvLmNvbG9yICE9IG51bGwpIHRoaXMuYXR0cignc3RvcC1jb2xvcicsIG8uY29sb3IpXHJcbiAgICBpZiAoby5vZmZzZXQgIT0gbnVsbCkgdGhpcy5hdHRyKCdvZmZzZXQnLCBuZXcgU1ZHTnVtYmVyKG8ub2Zmc2V0KSlcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxufVxyXG5cclxucmVnaXN0ZXIoU3RvcCwgJ1N0b3AnKVxyXG4iLCJpbXBvcnQgU1ZHTnVtYmVyIGZyb20gJy4uLy4uL3R5cGVzL1NWR051bWJlci5qcydcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmcm9tICh4LCB5KSB7XHJcbiAgcmV0dXJuICh0aGlzLl9lbGVtZW50IHx8IHRoaXMpLnR5cGUgPT09ICdyYWRpYWxHcmFkaWVudCdcclxuICAgID8gdGhpcy5hdHRyKHsgZng6IG5ldyBTVkdOdW1iZXIoeCksIGZ5OiBuZXcgU1ZHTnVtYmVyKHkpIH0pXHJcbiAgICA6IHRoaXMuYXR0cih7IHgxOiBuZXcgU1ZHTnVtYmVyKHgpLCB5MTogbmV3IFNWR051bWJlcih5KSB9KVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdG8gKHgsIHkpIHtcclxuICByZXR1cm4gKHRoaXMuX2VsZW1lbnQgfHwgdGhpcykudHlwZSA9PT0gJ3JhZGlhbEdyYWRpZW50J1xyXG4gICAgPyB0aGlzLmF0dHIoeyBjeDogbmV3IFNWR051bWJlcih4KSwgY3k6IG5ldyBTVkdOdW1iZXIoeSkgfSlcclxuICAgIDogdGhpcy5hdHRyKHsgeDI6IG5ldyBTVkdOdW1iZXIoeCksIHkyOiBuZXcgU1ZHTnVtYmVyKHkpIH0pXHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICBleHRlbmQsXHJcbiAgbm9kZU9yTmV3LFxyXG4gIHJlZ2lzdGVyLFxyXG4gIHdyYXBXaXRoQXR0ckNoZWNrXHJcbn0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcclxuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcclxuaW1wb3J0IEJveCBmcm9tICcuLi90eXBlcy9Cb3guanMnXHJcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi9Db250YWluZXIuanMnXHJcbmltcG9ydCBTdG9wIGZyb20gJy4vU3RvcC5qcydcclxuaW1wb3J0IGJhc2VGaW5kIGZyb20gJy4uL21vZHVsZXMvY29yZS9zZWxlY3Rvci5qcydcclxuaW1wb3J0ICogYXMgZ3JhZGllbnRlZCBmcm9tICcuLi9tb2R1bGVzL2NvcmUvZ3JhZGllbnRlZC5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyYWRpZW50IGV4dGVuZHMgQ29udGFpbmVyIHtcclxuICBjb25zdHJ1Y3RvciAodHlwZSwgYXR0cnMpIHtcclxuICAgIHN1cGVyKFxyXG4gICAgICBub2RlT3JOZXcodHlwZSArICdHcmFkaWVudCcsIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IG51bGwgOiB0eXBlKSxcclxuICAgICAgYXR0cnNcclxuICAgIClcclxuICB9XHJcblxyXG4gIC8vIEFkZCBhIGNvbG9yIHN0b3BcclxuICBzdG9wIChvZmZzZXQsIGNvbG9yLCBvcGFjaXR5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5wdXQobmV3IFN0b3AoKSkudXBkYXRlKG9mZnNldCwgY29sb3IsIG9wYWNpdHkpXHJcbiAgfVxyXG5cclxuICAvLyBVcGRhdGUgZ3JhZGllbnRcclxuICB1cGRhdGUgKGJsb2NrKSB7XHJcbiAgICAvLyByZW1vdmUgYWxsIHN0b3BzXHJcbiAgICB0aGlzLmNsZWFyKClcclxuXHJcbiAgICAvLyBpbnZva2UgcGFzc2VkIGJsb2NrXHJcbiAgICBpZiAodHlwZW9mIGJsb2NrID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGJsb2NrLmNhbGwodGhpcywgdGhpcylcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgLy8gUmV0dXJuIHRoZSBmaWxsIGlkXHJcbiAgdXJsICgpIHtcclxuICAgIHJldHVybiAndXJsKCMnICsgdGhpcy5pZCgpICsgJyknXHJcbiAgfVxyXG5cclxuICAvLyBBbGlhcyBzdHJpbmcgY29udmVydGlvbiB0byBmaWxsXHJcbiAgdG9TdHJpbmcgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudXJsKClcclxuICB9XHJcblxyXG4gIC8vIGN1c3RvbSBhdHRyIHRvIGhhbmRsZSB0cmFuc2Zvcm1cclxuICBhdHRyIChhLCBiLCBjKSB7XHJcbiAgICBpZiAoYSA9PT0gJ3RyYW5zZm9ybScpIGEgPSAnZ3JhZGllbnRUcmFuc2Zvcm0nXHJcbiAgICByZXR1cm4gc3VwZXIuYXR0cihhLCBiLCBjKVxyXG4gIH1cclxuXHJcbiAgdGFyZ2V0cyAoKSB7XHJcbiAgICByZXR1cm4gYmFzZUZpbmQoJ3N2ZyBbZmlsbCo9XCInICsgdGhpcy5pZCgpICsgJ1wiXScpXHJcbiAgfVxyXG5cclxuICBiYm94ICgpIHtcclxuICAgIHJldHVybiBuZXcgQm94KClcclxuICB9XHJcbn1cclxuXHJcbmV4dGVuZChHcmFkaWVudCwgZ3JhZGllbnRlZClcclxuXHJcbnJlZ2lzdGVyTWV0aG9kcyh7XHJcbiAgQ29udGFpbmVyOiB7XHJcbiAgICAvLyBDcmVhdGUgZ3JhZGllbnQgZWxlbWVudCBpbiBkZWZzXHJcbiAgICBncmFkaWVudDogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHR5cGUsIGJsb2NrKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5ncmFkaWVudCh0eXBlLCBibG9jaylcclxuICAgIH0pXHJcbiAgfSxcclxuICAvLyBkZWZpbmUgZ3JhZGllbnRcclxuICBEZWZzOiB7XHJcbiAgICBncmFkaWVudDogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHR5cGUsIGJsb2NrKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgR3JhZGllbnQodHlwZSkpLnVwZGF0ZShibG9jaylcclxuICAgIH0pXHJcbiAgfVxyXG59KVxyXG5cclxucmVnaXN0ZXIoR3JhZGllbnQsICdHcmFkaWVudCcpXHJcbiIsImltcG9ydCB7IG5vZGVPck5ldywgcmVnaXN0ZXIsIHdyYXBXaXRoQXR0ckNoZWNrIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcclxuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcclxuaW1wb3J0IEJveCBmcm9tICcuLi90eXBlcy9Cb3guanMnXHJcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi9Db250YWluZXIuanMnXHJcbmltcG9ydCBiYXNlRmluZCBmcm9tICcuLi9tb2R1bGVzL2NvcmUvc2VsZWN0b3IuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXR0ZXJuIGV4dGVuZHMgQ29udGFpbmVyIHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjb25zdHJ1Y3RvciAobm9kZSkge1xyXG4gICAgc3VwZXIobm9kZU9yTmV3KCdwYXR0ZXJuJywgbm9kZSksIG5vZGUpXHJcbiAgfVxyXG5cclxuICAvLyBSZXR1cm4gdGhlIGZpbGwgaWRcclxuICB1cmwgKCkge1xyXG4gICAgcmV0dXJuICd1cmwoIycgKyB0aGlzLmlkKCkgKyAnKSdcclxuICB9XHJcblxyXG4gIC8vIFVwZGF0ZSBwYXR0ZXJuIGJ5IHJlYnVpbGRpbmdcclxuICB1cGRhdGUgKGJsb2NrKSB7XHJcbiAgICAvLyByZW1vdmUgY29udGVudFxyXG4gICAgdGhpcy5jbGVhcigpXHJcblxyXG4gICAgLy8gaW52b2tlIHBhc3NlZCBibG9ja1xyXG4gICAgaWYgKHR5cGVvZiBibG9jayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBibG9jay5jYWxsKHRoaXMsIHRoaXMpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8vIEFsaWFzIHN0cmluZyBjb252ZXJ0aW9uIHRvIGZpbGxcclxuICB0b1N0cmluZyAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy51cmwoKVxyXG4gIH1cclxuXHJcbiAgLy8gY3VzdG9tIGF0dHIgdG8gaGFuZGxlIHRyYW5zZm9ybVxyXG4gIGF0dHIgKGEsIGIsIGMpIHtcclxuICAgIGlmIChhID09PSAndHJhbnNmb3JtJykgYSA9ICdwYXR0ZXJuVHJhbnNmb3JtJ1xyXG4gICAgcmV0dXJuIHN1cGVyLmF0dHIoYSwgYiwgYylcclxuICB9XHJcblxyXG4gIHRhcmdldHMgKCkge1xyXG4gICAgcmV0dXJuIGJhc2VGaW5kKCdzdmcgW2ZpbGwqPVwiJyArIHRoaXMuaWQoKSArICdcIl0nKVxyXG4gIH1cclxuXHJcbiAgYmJveCAoKSB7XHJcbiAgICByZXR1cm4gbmV3IEJveCgpXHJcbiAgfVxyXG59XHJcblxyXG5yZWdpc3Rlck1ldGhvZHMoe1xyXG4gIENvbnRhaW5lcjoge1xyXG4gICAgLy8gQ3JlYXRlIHBhdHRlcm4gZWxlbWVudCBpbiBkZWZzXHJcbiAgICBwYXR0ZXJuICguLi5hcmdzKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5wYXR0ZXJuKC4uLmFyZ3MpXHJcbiAgICB9XHJcbiAgfSxcclxuICBEZWZzOiB7XHJcbiAgICBwYXR0ZXJuOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgYmxvY2spIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBQYXR0ZXJuKCkpLnVwZGF0ZShibG9jaykuYXR0cih7XHJcbiAgICAgICAgeDogMCxcclxuICAgICAgICB5OiAwLFxyXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICBwYXR0ZXJuVW5pdHM6ICd1c2VyU3BhY2VPblVzZSdcclxuICAgICAgfSlcclxuICAgIH0pXHJcbiAgfVxyXG59KVxyXG5cclxucmVnaXN0ZXIoUGF0dGVybiwgJ1BhdHRlcm4nKVxyXG4iLCJpbXBvcnQgeyBpc0ltYWdlIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3JlZ2V4LmpzJ1xyXG5pbXBvcnQgeyBub2RlT3JOZXcsIHJlZ2lzdGVyLCB3cmFwV2l0aEF0dHJDaGVjayB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IG9mZiwgb24gfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvZXZlbnQuanMnXHJcbmltcG9ydCB7IHJlZ2lzdGVyQXR0ckhvb2sgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvYXR0ci5qcydcclxuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcclxuaW1wb3J0IHsgeGxpbmsgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvbmFtZXNwYWNlcy5qcydcclxuaW1wb3J0IFBhdHRlcm4gZnJvbSAnLi9QYXR0ZXJuLmpzJ1xyXG5pbXBvcnQgU2hhcGUgZnJvbSAnLi9TaGFwZS5qcydcclxuaW1wb3J0IHsgZ2xvYmFscyB9IGZyb20gJy4uL3V0aWxzL3dpbmRvdy5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEltYWdlIGV4dGVuZHMgU2hhcGUge1xyXG4gIGNvbnN0cnVjdG9yIChub2RlKSB7XHJcbiAgICBzdXBlcihub2RlT3JOZXcoJ2ltYWdlJywgbm9kZSksIG5vZGUpXHJcbiAgfVxyXG5cclxuICAvLyAocmUpbG9hZCBpbWFnZVxyXG4gIGxvYWQgKHVybCwgY2FsbGJhY2spIHtcclxuICAgIGlmICghdXJsKSByZXR1cm4gdGhpc1xyXG5cclxuICAgIHZhciBpbWcgPSBuZXcgZ2xvYmFscy53aW5kb3cuSW1hZ2UoKVxyXG5cclxuICAgIG9uKGltZywgJ2xvYWQnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICB2YXIgcCA9IHRoaXMucGFyZW50KFBhdHRlcm4pXHJcblxyXG4gICAgICAvLyBlbnN1cmUgaW1hZ2Ugc2l6ZVxyXG4gICAgICBpZiAodGhpcy53aWR0aCgpID09PSAwICYmIHRoaXMuaGVpZ2h0KCkgPT09IDApIHtcclxuICAgICAgICB0aGlzLnNpemUoaW1nLndpZHRoLCBpbWcuaGVpZ2h0KVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocCBpbnN0YW5jZW9mIFBhdHRlcm4pIHtcclxuICAgICAgICAvLyBlbnN1cmUgcGF0dGVybiBzaXplIGlmIG5vdCBzZXRcclxuICAgICAgICBpZiAocC53aWR0aCgpID09PSAwICYmIHAuaGVpZ2h0KCkgPT09IDApIHtcclxuICAgICAgICAgIHAuc2l6ZSh0aGlzLndpZHRoKCksIHRoaXMuaGVpZ2h0KCkpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBlKVxyXG4gICAgICB9XHJcbiAgICB9LCB0aGlzKVxyXG5cclxuICAgIG9uKGltZywgJ2xvYWQgZXJyb3InLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIC8vIGRvbnQgZm9yZ2V0IHRvIHVuYmluZCBtZW1vcnkgbGVha2luZyBldmVudHNcclxuICAgICAgb2ZmKGltZylcclxuICAgIH0pXHJcblxyXG4gICAgcmV0dXJuIHRoaXMuYXR0cignaHJlZicsIChpbWcuc3JjID0gdXJsKSwgeGxpbmspXHJcbiAgfVxyXG59XHJcblxyXG5yZWdpc3RlckF0dHJIb29rKGZ1bmN0aW9uIChhdHRyLCB2YWwsIF90aGlzKSB7XHJcbiAgLy8gY29udmVydCBpbWFnZSBmaWxsIGFuZCBzdHJva2UgdG8gcGF0dGVybnNcclxuICBpZiAoYXR0ciA9PT0gJ2ZpbGwnIHx8IGF0dHIgPT09ICdzdHJva2UnKSB7XHJcbiAgICBpZiAoaXNJbWFnZS50ZXN0KHZhbCkpIHtcclxuICAgICAgdmFsID0gX3RoaXMucm9vdCgpLmRlZnMoKS5pbWFnZSh2YWwpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAodmFsIGluc3RhbmNlb2YgSW1hZ2UpIHtcclxuICAgIHZhbCA9IF90aGlzLnJvb3QoKS5kZWZzKCkucGF0dGVybigwLCAwLCAocGF0dGVybikgPT4ge1xyXG4gICAgICBwYXR0ZXJuLmFkZCh2YWwpXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHZhbFxyXG59KVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKHtcclxuICBDb250YWluZXI6IHtcclxuICAgIC8vIGNyZWF0ZSBpbWFnZSBlbGVtZW50LCBsb2FkIGltYWdlIGFuZCBzZXQgaXRzIHNpemVcclxuICAgIGltYWdlOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAoc291cmNlLCBjYWxsYmFjaykge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IEltYWdlKCkpLnNpemUoMCwgMCkubG9hZChzb3VyY2UsIGNhbGxiYWNrKVxyXG4gICAgfSlcclxuICB9XHJcbn0pXHJcblxyXG5yZWdpc3RlcihJbWFnZSwgJ0ltYWdlJylcclxuIiwiaW1wb3J0IHsgZGVsaW1pdGVyIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3JlZ2V4LmpzJ1xyXG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgeyBzdWJDbGFzc0FycmF5IH0gZnJvbSAnLi9BcnJheVBvbHlmaWxsLmpzJ1xyXG5pbXBvcnQgU1ZHQXJyYXkgZnJvbSAnLi9TVkdBcnJheS5qcydcclxuXHJcbmNvbnN0IFBvaW50QXJyYXkgPSBzdWJDbGFzc0FycmF5KCdQb2ludEFycmF5JywgU1ZHQXJyYXkpXHJcblxyXG5leHBvcnQgZGVmYXVsdCBQb2ludEFycmF5XHJcblxyXG5leHRlbmQoUG9pbnRBcnJheSwge1xyXG4gIC8vIENvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXHJcbiAgdG9TdHJpbmcgKCkge1xyXG4gICAgLy8gY29udmVydCB0byBhIHBvbHkgcG9pbnQgc3RyaW5nXHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0aGlzLmxlbmd0aCwgYXJyYXkgPSBbXTsgaSA8IGlsOyBpKyspIHtcclxuICAgICAgYXJyYXkucHVzaCh0aGlzW2ldLmpvaW4oJywnKSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYXJyYXkuam9pbignICcpXHJcbiAgfSxcclxuXHJcbiAgLy8gQ29udmVydCBhcnJheSB0byBsaW5lIG9iamVjdFxyXG4gIHRvTGluZSAoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4MTogdGhpc1swXVswXSxcclxuICAgICAgeTE6IHRoaXNbMF1bMV0sXHJcbiAgICAgIHgyOiB0aGlzWzFdWzBdLFxyXG4gICAgICB5MjogdGhpc1sxXVsxXVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8vIEdldCBtb3JwaGVkIGFycmF5IGF0IGdpdmVuIHBvc2l0aW9uXHJcbiAgYXQgKHBvcykge1xyXG4gICAgLy8gbWFrZSBzdXJlIGEgZGVzdGluYXRpb24gaXMgZGVmaW5lZFxyXG4gICAgaWYgKCF0aGlzLmRlc3RpbmF0aW9uKSByZXR1cm4gdGhpc1xyXG5cclxuICAgIC8vIGdlbmVyYXRlIG1vcnBoZWQgcG9pbnQgc3RyaW5nXHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0aGlzLmxlbmd0aCwgYXJyYXkgPSBbXTsgaSA8IGlsOyBpKyspIHtcclxuICAgICAgYXJyYXkucHVzaChbXHJcbiAgICAgICAgdGhpc1tpXVswXSArICh0aGlzLmRlc3RpbmF0aW9uW2ldWzBdIC0gdGhpc1tpXVswXSkgKiBwb3MsXHJcbiAgICAgICAgdGhpc1tpXVsxXSArICh0aGlzLmRlc3RpbmF0aW9uW2ldWzFdIC0gdGhpc1tpXVsxXSkgKiBwb3NcclxuICAgICAgXSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IFBvaW50QXJyYXkoYXJyYXkpXHJcbiAgfSxcclxuXHJcbiAgLy8gUGFyc2UgcG9pbnQgc3RyaW5nIGFuZCBmbGF0IGFycmF5XHJcbiAgcGFyc2UgKGFycmF5ID0gWyBbIDAsIDAgXSBdKSB7XHJcbiAgICB2YXIgcG9pbnRzID0gW11cclxuXHJcbiAgICAvLyBpZiBpdCBpcyBhbiBhcnJheVxyXG4gICAgaWYgKGFycmF5IGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgLy8gYW5kIGl0IGlzIG5vdCBmbGF0LCB0aGVyZSBpcyBubyBuZWVkIHRvIHBhcnNlIGl0XHJcbiAgICAgIGlmIChhcnJheVswXSBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7IC8vIEVsc2UsIGl0IGlzIGNvbnNpZGVyZWQgYXMgYSBzdHJpbmdcclxuICAgICAgLy8gcGFyc2UgcG9pbnRzXHJcbiAgICAgIGFycmF5ID0gYXJyYXkudHJpbSgpLnNwbGl0KGRlbGltaXRlcikubWFwKHBhcnNlRmxvYXQpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gdmFsaWRhdGUgcG9pbnRzIC0gaHR0cHM6Ly9zdmd3Zy5vcmcvc3ZnMi1kcmFmdC9zaGFwZXMuaHRtbCNEYXRhVHlwZVBvaW50c1xyXG4gICAgLy8gT2RkIG51bWJlciBvZiBjb29yZGluYXRlcyBpcyBhbiBlcnJvci4gSW4gc3VjaCBjYXNlcywgZHJvcCB0aGUgbGFzdCBvZGQgY29vcmRpbmF0ZS5cclxuICAgIGlmIChhcnJheS5sZW5ndGggJSAyICE9PSAwKSBhcnJheS5wb3AoKVxyXG5cclxuICAgIC8vIHdyYXAgcG9pbnRzIGluIHR3by10dXBsZXNcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkgPSBpICsgMikge1xyXG4gICAgICBwb2ludHMucHVzaChbIGFycmF5W2ldLCBhcnJheVtpICsgMV0gXSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcG9pbnRzXHJcbiAgfSxcclxuXHJcbiAgLy8gdHJhbnNmb3JtIHBvaW50cyB3aXRoIG1hdHJpeCAoc2ltaWxhciB0byBQb2ludC50cmFuc2Zvcm0pXHJcbiAgdHJhbnNmb3JtIChtKSB7XHJcbiAgICBjb25zdCBwb2ludHMgPSBbXVxyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBwb2ludCA9IHRoaXNbaV1cclxuICAgICAgLy8gUGVyZm9ybSB0aGUgbWF0cml4IG11bHRpcGxpY2F0aW9uXHJcbiAgICAgIHBvaW50cy5wdXNoKFtcclxuICAgICAgICBtLmEgKiBwb2ludFswXSArIG0uYyAqIHBvaW50WzFdICsgbS5lLFxyXG4gICAgICAgIG0uYiAqIHBvaW50WzBdICsgbS5kICogcG9pbnRbMV0gKyBtLmZcclxuICAgICAgXSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXR1cm4gdGhlIHJlcXVpcmVkIHBvaW50XHJcbiAgICByZXR1cm4gbmV3IFBvaW50QXJyYXkocG9pbnRzKVxyXG4gIH0sXHJcblxyXG4gIC8vIE1vdmUgcG9pbnQgc3RyaW5nXHJcbiAgbW92ZSAoeCwgeSkge1xyXG4gICAgdmFyIGJveCA9IHRoaXMuYmJveCgpXHJcblxyXG4gICAgLy8gZ2V0IHJlbGF0aXZlIG9mZnNldFxyXG4gICAgeCAtPSBib3gueFxyXG4gICAgeSAtPSBib3gueVxyXG5cclxuICAgIC8vIG1vdmUgZXZlcnkgcG9pbnRcclxuICAgIGlmICghaXNOYU4oeCkgJiYgIWlzTmFOKHkpKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgdGhpc1tpXSA9IFsgdGhpc1tpXVswXSArIHgsIHRoaXNbaV1bMV0gKyB5IF1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfSxcclxuXHJcbiAgLy8gUmVzaXplIHBvbHkgc3RyaW5nXHJcbiAgc2l6ZSAod2lkdGgsIGhlaWdodCkge1xyXG4gICAgdmFyIGlcclxuICAgIHZhciBib3ggPSB0aGlzLmJib3goKVxyXG5cclxuICAgIC8vIHJlY2FsY3VsYXRlIHBvc2l0aW9uIG9mIGFsbCBwb2ludHMgYWNjb3JkaW5nIHRvIG5ldyBzaXplXHJcbiAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIGlmIChib3gud2lkdGgpIHRoaXNbaV1bMF0gPSAoKHRoaXNbaV1bMF0gLSBib3gueCkgKiB3aWR0aCkgLyBib3gud2lkdGggKyBib3gueFxyXG4gICAgICBpZiAoYm94LmhlaWdodCkgdGhpc1tpXVsxXSA9ICgodGhpc1tpXVsxXSAtIGJveC55KSAqIGhlaWdodCkgLyBib3guaGVpZ2h0ICsgYm94LnlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH0sXHJcblxyXG4gIC8vIEdldCBib3VuZGluZyBib3ggb2YgcG9pbnRzXHJcbiAgYmJveCAoKSB7XHJcbiAgICB2YXIgbWF4WCA9IC1JbmZpbml0eVxyXG4gICAgdmFyIG1heFkgPSAtSW5maW5pdHlcclxuICAgIHZhciBtaW5YID0gSW5maW5pdHlcclxuICAgIHZhciBtaW5ZID0gSW5maW5pdHlcclxuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgbWF4WCA9IE1hdGgubWF4KGVsWzBdLCBtYXhYKVxyXG4gICAgICBtYXhZID0gTWF0aC5tYXgoZWxbMV0sIG1heFkpXHJcbiAgICAgIG1pblggPSBNYXRoLm1pbihlbFswXSwgbWluWClcclxuICAgICAgbWluWSA9IE1hdGgubWluKGVsWzFdLCBtaW5ZKVxyXG4gICAgfSlcclxuICAgIHJldHVybiB7IHg6IG1pblgsIHk6IG1pblksIHdpZHRoOiBtYXhYIC0gbWluWCwgaGVpZ2h0OiBtYXhZIC0gbWluWSB9XHJcbiAgfVxyXG59KVxyXG4iLCJpbXBvcnQgUG9pbnRBcnJheSBmcm9tICcuLi8uLi90eXBlcy9Qb2ludEFycmF5LmpzJ1xyXG5cclxuZXhwb3J0IGNvbnN0IE1vcnBoQXJyYXkgPSBQb2ludEFycmF5XHJcblxyXG4vLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lciBvdmVyIHgtYXhpc1xyXG5leHBvcnQgZnVuY3Rpb24geCAoeCkge1xyXG4gIHJldHVybiB4ID09IG51bGwgPyB0aGlzLmJib3goKS54IDogdGhpcy5tb3ZlKHgsIHRoaXMuYmJveCgpLnkpXHJcbn1cclxuXHJcbi8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyIG92ZXIgeS1heGlzXHJcbmV4cG9ydCBmdW5jdGlvbiB5ICh5KSB7XHJcbiAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMuYmJveCgpLnkgOiB0aGlzLm1vdmUodGhpcy5iYm94KCkueCwgeSlcclxufVxyXG5cclxuLy8gU2V0IHdpZHRoIG9mIGVsZW1lbnRcclxuZXhwb3J0IGZ1bmN0aW9uIHdpZHRoICh3aWR0aCkge1xyXG4gIGNvbnN0IGIgPSB0aGlzLmJib3goKVxyXG4gIHJldHVybiB3aWR0aCA9PSBudWxsID8gYi53aWR0aCA6IHRoaXMuc2l6ZSh3aWR0aCwgYi5oZWlnaHQpXHJcbn1cclxuXHJcbi8vIFNldCBoZWlnaHQgb2YgZWxlbWVudFxyXG5leHBvcnQgZnVuY3Rpb24gaGVpZ2h0IChoZWlnaHQpIHtcclxuICBjb25zdCBiID0gdGhpcy5iYm94KClcclxuICByZXR1cm4gaGVpZ2h0ID09IG51bGwgPyBiLmhlaWdodCA6IHRoaXMuc2l6ZShiLndpZHRoLCBoZWlnaHQpXHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICBleHRlbmQsXHJcbiAgbm9kZU9yTmV3LFxyXG4gIHJlZ2lzdGVyLFxyXG4gIHdyYXBXaXRoQXR0ckNoZWNrXHJcbn0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcclxuaW1wb3J0IHsgcHJvcG9ydGlvbmFsU2l6ZSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzLmpzJ1xyXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xyXG5pbXBvcnQgUG9pbnRBcnJheSBmcm9tICcuLi90eXBlcy9Qb2ludEFycmF5LmpzJ1xyXG5pbXBvcnQgU2hhcGUgZnJvbSAnLi9TaGFwZS5qcydcclxuaW1wb3J0ICogYXMgcG9pbnRlZCBmcm9tICcuLi9tb2R1bGVzL2NvcmUvcG9pbnRlZC5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmUgZXh0ZW5kcyBTaGFwZSB7XHJcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXHJcbiAgY29uc3RydWN0b3IgKG5vZGUpIHtcclxuICAgIHN1cGVyKG5vZGVPck5ldygnbGluZScsIG5vZGUpLCBub2RlKVxyXG4gIH1cclxuXHJcbiAgLy8gR2V0IGFycmF5XHJcbiAgYXJyYXkgKCkge1xyXG4gICAgcmV0dXJuIG5ldyBQb2ludEFycmF5KFtcclxuICAgICAgWyB0aGlzLmF0dHIoJ3gxJyksIHRoaXMuYXR0cigneTEnKSBdLFxyXG4gICAgICBbIHRoaXMuYXR0cigneDInKSwgdGhpcy5hdHRyKCd5MicpIF1cclxuICAgIF0pXHJcbiAgfVxyXG5cclxuICAvLyBPdmVyd3JpdGUgbmF0aXZlIHBsb3QoKSBtZXRob2RcclxuICBwbG90ICh4MSwgeTEsIHgyLCB5Mikge1xyXG4gICAgaWYgKHgxID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXJyYXkoKVxyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgeTEgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHgxID0geyB4MTogeDEsIHkxOiB5MSwgeDI6IHgyLCB5MjogeTIgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgeDEgPSBuZXcgUG9pbnRBcnJheSh4MSkudG9MaW5lKClcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKHgxKVxyXG4gIH1cclxuXHJcbiAgLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXJcclxuICBtb3ZlICh4LCB5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKHRoaXMuYXJyYXkoKS5tb3ZlKHgsIHkpLnRvTGluZSgpKVxyXG4gIH1cclxuXHJcbiAgLy8gU2V0IGVsZW1lbnQgc2l6ZSB0byBnaXZlbiB3aWR0aCBhbmQgaGVpZ2h0XHJcbiAgc2l6ZSAod2lkdGgsIGhlaWdodCkge1xyXG4gICAgdmFyIHAgPSBwcm9wb3J0aW9uYWxTaXplKHRoaXMsIHdpZHRoLCBoZWlnaHQpXHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKHRoaXMuYXJyYXkoKS5zaXplKHAud2lkdGgsIHAuaGVpZ2h0KS50b0xpbmUoKSlcclxuICB9XHJcbn1cclxuXHJcbmV4dGVuZChMaW5lLCBwb2ludGVkKVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKHtcclxuICBDb250YWluZXI6IHtcclxuICAgIC8vIENyZWF0ZSBhIGxpbmUgZWxlbWVudFxyXG4gICAgbGluZTogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgLy8gbWFrZSBzdXJlIHBsb3QgaXMgY2FsbGVkIGFzIGEgc2V0dGVyXHJcbiAgICAgIC8vIHgxIGlzIG5vdCBuZWNlc3NhcmlseSBhIG51bWJlciwgaXQgY2FuIGFsc28gYmUgYW4gYXJyYXksIGEgc3RyaW5nIGFuZCBhIFBvaW50QXJyYXlcclxuICAgICAgcmV0dXJuIExpbmUucHJvdG90eXBlLnBsb3QuYXBwbHkoXHJcbiAgICAgICAgdGhpcy5wdXQobmV3IExpbmUoKSlcclxuICAgICAgICAsIGFyZ3NbMF0gIT0gbnVsbCA/IGFyZ3MgOiBbIDAsIDAsIDAsIDAgXVxyXG4gICAgICApXHJcbiAgICB9KVxyXG4gIH1cclxufSlcclxuXHJcbnJlZ2lzdGVyKExpbmUsICdMaW5lJylcclxuIiwiaW1wb3J0IHsgbm9kZU9yTmV3LCByZWdpc3Rlciwgd3JhcFdpdGhBdHRyQ2hlY2sgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xyXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vQ29udGFpbmVyLmpzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFya2VyIGV4dGVuZHMgQ29udGFpbmVyIHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjb25zdHJ1Y3RvciAobm9kZSkge1xyXG4gICAgc3VwZXIobm9kZU9yTmV3KCdtYXJrZXInLCBub2RlKSwgbm9kZSlcclxuICB9XHJcblxyXG4gIC8vIFNldCB3aWR0aCBvZiBlbGVtZW50XHJcbiAgd2lkdGggKHdpZHRoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdtYXJrZXJXaWR0aCcsIHdpZHRoKVxyXG4gIH1cclxuXHJcbiAgLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XHJcbiAgaGVpZ2h0IChoZWlnaHQpIHtcclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ21hcmtlckhlaWdodCcsIGhlaWdodClcclxuICB9XHJcblxyXG4gIC8vIFNldCBtYXJrZXIgcmVmWCBhbmQgcmVmWVxyXG4gIHJlZiAoeCwgeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuYXR0cigncmVmWCcsIHgpLmF0dHIoJ3JlZlknLCB5KVxyXG4gIH1cclxuXHJcbiAgLy8gVXBkYXRlIG1hcmtlclxyXG4gIHVwZGF0ZSAoYmxvY2spIHtcclxuICAgIC8vIHJlbW92ZSBhbGwgY29udGVudFxyXG4gICAgdGhpcy5jbGVhcigpXHJcblxyXG4gICAgLy8gaW52b2tlIHBhc3NlZCBibG9ja1xyXG4gICAgaWYgKHR5cGVvZiBibG9jayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBibG9jay5jYWxsKHRoaXMsIHRoaXMpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8vIFJldHVybiB0aGUgZmlsbCBpZFxyXG4gIHRvU3RyaW5nICgpIHtcclxuICAgIHJldHVybiAndXJsKCMnICsgdGhpcy5pZCgpICsgJyknXHJcbiAgfVxyXG59XHJcblxyXG5yZWdpc3Rlck1ldGhvZHMoe1xyXG4gIENvbnRhaW5lcjoge1xyXG4gICAgbWFya2VyICguLi5hcmdzKSB7XHJcbiAgICAgIC8vIENyZWF0ZSBtYXJrZXIgZWxlbWVudCBpbiBkZWZzXHJcbiAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5tYXJrZXIoLi4uYXJncylcclxuICAgIH1cclxuICB9LFxyXG4gIERlZnM6IHtcclxuICAgIC8vIENyZWF0ZSBtYXJrZXJcclxuICAgIG1hcmtlcjogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQsIGJsb2NrKSB7XHJcbiAgICAgIC8vIFNldCBkZWZhdWx0IHZpZXdib3ggdG8gbWF0Y2ggdGhlIHdpZHRoIGFuZCBoZWlnaHQsIHNldCByZWYgdG8gY3ggYW5kIGN5IGFuZCBzZXQgb3JpZW50IHRvIGF1dG9cclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBNYXJrZXIoKSlcclxuICAgICAgICAuc2l6ZSh3aWR0aCwgaGVpZ2h0KVxyXG4gICAgICAgIC5yZWYod2lkdGggLyAyLCBoZWlnaHQgLyAyKVxyXG4gICAgICAgIC52aWV3Ym94KDAsIDAsIHdpZHRoLCBoZWlnaHQpXHJcbiAgICAgICAgLmF0dHIoJ29yaWVudCcsICdhdXRvJylcclxuICAgICAgICAudXBkYXRlKGJsb2NrKVxyXG4gICAgfSlcclxuICB9LFxyXG4gIG1hcmtlcjoge1xyXG4gICAgLy8gQ3JlYXRlIGFuZCBhdHRhY2ggbWFya2Vyc1xyXG4gICAgbWFya2VyIChtYXJrZXIsIHdpZHRoLCBoZWlnaHQsIGJsb2NrKSB7XHJcbiAgICAgIHZhciBhdHRyID0gWyAnbWFya2VyJyBdXHJcblxyXG4gICAgICAvLyBCdWlsZCBhdHRyaWJ1dGUgbmFtZVxyXG4gICAgICBpZiAobWFya2VyICE9PSAnYWxsJykgYXR0ci5wdXNoKG1hcmtlcilcclxuICAgICAgYXR0ciA9IGF0dHIuam9pbignLScpXHJcblxyXG4gICAgICAvLyBTZXQgbWFya2VyIGF0dHJpYnV0ZVxyXG4gICAgICBtYXJrZXIgPSBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBNYXJrZXJcclxuICAgICAgICA/IGFyZ3VtZW50c1sxXVxyXG4gICAgICAgIDogdGhpcy5kZWZzKCkubWFya2VyKHdpZHRoLCBoZWlnaHQsIGJsb2NrKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cihhdHRyLCBtYXJrZXIpXHJcbiAgICB9XHJcbiAgfVxyXG59KVxyXG5cclxucmVnaXN0ZXIoTWFya2VyLCAnTWFya2VyJylcclxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb24nKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIHNsb3BweUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Nsb3BweS1hcnJheS1tZXRob2QnKTtcblxudmFyIG5hdGl2ZVNvcnQgPSBbXS5zb3J0O1xudmFyIHRlc3QgPSBbMSwgMiwgM107XG5cbi8vIElFOC1cbnZhciBGQUlMU19PTl9VTkRFRklORUQgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHRlc3Quc29ydCh1bmRlZmluZWQpO1xufSk7XG4vLyBWOCBidWdcbnZhciBGQUlMU19PTl9OVUxMID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICB0ZXN0LnNvcnQobnVsbCk7XG59KTtcbi8vIE9sZCBXZWJLaXRcbnZhciBTTE9QUFlfTUVUSE9EID0gc2xvcHB5QXJyYXlNZXRob2QoJ3NvcnQnKTtcblxudmFyIEZPUkNFRCA9IEZBSUxTX09OX1VOREVGSU5FRCB8fCAhRkFJTFNfT05fTlVMTCB8fCBTTE9QUFlfTUVUSE9EO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnNvcnRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvcnRcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVmbiA9PT0gdW5kZWZpbmVkXG4gICAgICA/IG5hdGl2ZVNvcnQuY2FsbCh0b09iamVjdCh0aGlzKSlcbiAgICAgIDogbmF0aXZlU29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpLCBhRnVuY3Rpb24oY29tcGFyZWZuKSk7XG4gIH1cbn0pO1xuIiwiaW1wb3J0IHsgdGltZWxpbmUgfSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvZGVmYXVsdHMuanMnXHJcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcblxyXG4vKioqXHJcbkJhc2UgQ2xhc3NcclxuPT09PT09PT09PVxyXG5UaGUgYmFzZSBzdGVwcGVyIGNsYXNzIHRoYXQgd2lsbCBiZVxyXG4qKiovXHJcblxyXG5mdW5jdGlvbiBtYWtlU2V0dGVyR2V0dGVyIChrLCBmKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XHJcbiAgICBpZiAodiA9PSBudWxsKSByZXR1cm4gdGhpc1t2XVxyXG4gICAgdGhpc1trXSA9IHZcclxuICAgIGlmIChmKSBmLmNhbGwodGhpcylcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZWFzaW5nID0ge1xyXG4gICctJzogZnVuY3Rpb24gKHBvcykge1xyXG4gICAgcmV0dXJuIHBvc1xyXG4gIH0sXHJcbiAgJzw+JzogZnVuY3Rpb24gKHBvcykge1xyXG4gICAgcmV0dXJuIC1NYXRoLmNvcyhwb3MgKiBNYXRoLlBJKSAvIDIgKyAwLjVcclxuICB9LFxyXG4gICc+JzogZnVuY3Rpb24gKHBvcykge1xyXG4gICAgcmV0dXJuIE1hdGguc2luKHBvcyAqIE1hdGguUEkgLyAyKVxyXG4gIH0sXHJcbiAgJzwnOiBmdW5jdGlvbiAocG9zKSB7XHJcbiAgICByZXR1cm4gLU1hdGguY29zKHBvcyAqIE1hdGguUEkgLyAyKSArIDFcclxuICB9LFxyXG4gIGJlemllcjogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XHJcbiAgICAvLyBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1lYXNpbmctMS8jY3ViaWMtYmV6aWVyLWFsZ29cclxuICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xyXG4gICAgICBpZiAodCA8IDApIHtcclxuICAgICAgICBpZiAoeDEgPiAwKSB7XHJcbiAgICAgICAgICByZXR1cm4geTEgLyB4MSAqIHRcclxuICAgICAgICB9IGVsc2UgaWYgKHgyID4gMCkge1xyXG4gICAgICAgICAgcmV0dXJuIHkyIC8geDIgKiB0XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiAwXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHQgPiAxKSB7XHJcbiAgICAgICAgaWYgKHgyIDwgMSkge1xyXG4gICAgICAgICAgcmV0dXJuICgxIC0geTIpIC8gKDEgLSB4MikgKiB0ICsgKHkyIC0geDIpIC8gKDEgLSB4MilcclxuICAgICAgICB9IGVsc2UgaWYgKHgxIDwgMSkge1xyXG4gICAgICAgICAgcmV0dXJuICgxIC0geTEpIC8gKDEgLSB4MSkgKiB0ICsgKHkxIC0geDEpIC8gKDEgLSB4MSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIDFcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIDMgKiB0ICogKDEgLSB0KSAqKiAyICogeTEgKyAzICogdCAqKiAyICogKDEgLSB0KSAqIHkyICsgdCAqKiAzXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG4gIC8vIHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLWVhc2luZy0xLyNzdGVwLXRpbWluZy1mdW5jdGlvbi1hbGdvXHJcbiAgc3RlcHM6IGZ1bmN0aW9uIChzdGVwcywgc3RlcFBvc2l0aW9uID0gJ2VuZCcpIHtcclxuICAgIC8vIGRlYWwgd2l0aCBcImp1bXAtXCIgcHJlZml4XHJcbiAgICBzdGVwUG9zaXRpb24gPSBzdGVwUG9zaXRpb24uc3BsaXQoJy0nKS5yZXZlcnNlKClbMF1cclxuXHJcbiAgICBsZXQganVtcHMgPSBzdGVwc1xyXG4gICAgaWYgKHN0ZXBQb3NpdGlvbiA9PT0gJ25vbmUnKSB7XHJcbiAgICAgIC0tanVtcHNcclxuICAgIH0gZWxzZSBpZiAoc3RlcFBvc2l0aW9uID09PSAnYm90aCcpIHtcclxuICAgICAgKytqdW1wc1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZSBiZWZvcmVGbGFnIGlzIGVzc2VudGlhbGx5IHVzZWxlc3NcclxuICAgIHJldHVybiAodCwgYmVmb3JlRmxhZyA9IGZhbHNlKSA9PiB7XHJcbiAgICAgIC8vIFN0ZXAgaXMgY2FsbGVkIGN1cnJlbnRTdGVwIGluIHJlZmVyZW5jZWQgdXJsXHJcbiAgICAgIGxldCBzdGVwID0gTWF0aC5mbG9vcih0ICogc3RlcHMpXHJcbiAgICAgIGNvbnN0IGp1bXBpbmcgPSAodCAqIHN0ZXApICUgMSA9PT0gMFxyXG5cclxuICAgICAgaWYgKHN0ZXBQb3NpdGlvbiA9PT0gJ3N0YXJ0JyB8fCBzdGVwUG9zaXRpb24gPT09ICdib3RoJykge1xyXG4gICAgICAgICsrc3RlcFxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYmVmb3JlRmxhZyAmJiBqdW1waW5nKSB7XHJcbiAgICAgICAgLS1zdGVwXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0ID49IDAgJiYgc3RlcCA8IDApIHtcclxuICAgICAgICBzdGVwID0gMFxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodCA8PSAxICYmIHN0ZXAgPiBqdW1wcykge1xyXG4gICAgICAgIHN0ZXAgPSBqdW1wc1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc3RlcCAvIGp1bXBzXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgU3RlcHBlciB7XHJcbiAgZG9uZSAoKSB7XHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9XHJcbn1cclxuXHJcbi8qKipcclxuRWFzaW5nIEZ1bmN0aW9uc1xyXG49PT09PT09PT09PT09PT09XHJcbioqKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBFYXNlIGV4dGVuZHMgU3RlcHBlciB7XHJcbiAgY29uc3RydWN0b3IgKGZuKSB7XHJcbiAgICBzdXBlcigpXHJcbiAgICB0aGlzLmVhc2UgPSBlYXNpbmdbZm4gfHwgdGltZWxpbmUuZWFzZV0gfHwgZm5cclxuICB9XHJcblxyXG4gIHN0ZXAgKGZyb20sIHRvLCBwb3MpIHtcclxuICAgIGlmICh0eXBlb2YgZnJvbSAhPT0gJ251bWJlcicpIHtcclxuICAgICAgcmV0dXJuIHBvcyA8IDEgPyBmcm9tIDogdG9cclxuICAgIH1cclxuICAgIHJldHVybiBmcm9tICsgKHRvIC0gZnJvbSkgKiB0aGlzLmVhc2UocG9zKVxyXG4gIH1cclxufVxyXG5cclxuLyoqKlxyXG5Db250cm9sbGVyIFR5cGVzXHJcbj09PT09PT09PT09PT09PT1cclxuKioqL1xyXG5cclxuZXhwb3J0IGNsYXNzIENvbnRyb2xsZXIgZXh0ZW5kcyBTdGVwcGVyIHtcclxuICBjb25zdHJ1Y3RvciAoZm4pIHtcclxuICAgIHN1cGVyKClcclxuICAgIHRoaXMuc3RlcHBlciA9IGZuXHJcbiAgfVxyXG5cclxuICBzdGVwIChjdXJyZW50LCB0YXJnZXQsIGR0LCBjKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdGVwcGVyKGN1cnJlbnQsIHRhcmdldCwgZHQsIGMpXHJcbiAgfVxyXG5cclxuICBkb25lIChjKSB7XHJcbiAgICByZXR1cm4gYy5kb25lXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZWNhbGN1bGF0ZSAoKSB7XHJcbiAgLy8gQXBwbHkgdGhlIGRlZmF1bHQgcGFyYW1ldGVyc1xyXG4gIHZhciBkdXJhdGlvbiA9ICh0aGlzLl9kdXJhdGlvbiB8fCA1MDApIC8gMTAwMFxyXG4gIHZhciBvdmVyc2hvb3QgPSB0aGlzLl9vdmVyc2hvb3QgfHwgMFxyXG5cclxuICAvLyBDYWxjdWxhdGUgdGhlIFBJRCBuYXR1cmFsIHJlc3BvbnNlXHJcbiAgdmFyIGVwcyA9IDFlLTEwXHJcbiAgdmFyIHBpID0gTWF0aC5QSVxyXG4gIHZhciBvcyA9IE1hdGgubG9nKG92ZXJzaG9vdCAvIDEwMCArIGVwcylcclxuICB2YXIgemV0YSA9IC1vcyAvIE1hdGguc3FydChwaSAqIHBpICsgb3MgKiBvcylcclxuICB2YXIgd24gPSAzLjkgLyAoemV0YSAqIGR1cmF0aW9uKVxyXG5cclxuICAvLyBDYWxjdWxhdGUgdGhlIFNwcmluZyB2YWx1ZXNcclxuICB0aGlzLmQgPSAyICogemV0YSAqIHduXHJcbiAgdGhpcy5rID0gd24gKiB3blxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgU3ByaW5nIGV4dGVuZHMgQ29udHJvbGxlciB7XHJcbiAgY29uc3RydWN0b3IgKGR1cmF0aW9uLCBvdmVyc2hvb3QpIHtcclxuICAgIHN1cGVyKClcclxuICAgIHRoaXMuZHVyYXRpb24oZHVyYXRpb24gfHwgNTAwKVxyXG4gICAgICAub3ZlcnNob290KG92ZXJzaG9vdCB8fCAwKVxyXG4gIH1cclxuXHJcbiAgc3RlcCAoY3VycmVudCwgdGFyZ2V0LCBkdCwgYykge1xyXG4gICAgaWYgKHR5cGVvZiBjdXJyZW50ID09PSAnc3RyaW5nJykgcmV0dXJuIGN1cnJlbnRcclxuICAgIGMuZG9uZSA9IGR0ID09PSBJbmZpbml0eVxyXG4gICAgaWYgKGR0ID09PSBJbmZpbml0eSkgcmV0dXJuIHRhcmdldFxyXG4gICAgaWYgKGR0ID09PSAwKSByZXR1cm4gY3VycmVudFxyXG5cclxuICAgIGlmIChkdCA+IDEwMCkgZHQgPSAxNlxyXG5cclxuICAgIGR0IC89IDEwMDBcclxuXHJcbiAgICAvLyBHZXQgdGhlIHByZXZpb3VzIHZlbG9jaXR5XHJcbiAgICB2YXIgdmVsb2NpdHkgPSBjLnZlbG9jaXR5IHx8IDBcclxuXHJcbiAgICAvLyBBcHBseSB0aGUgY29udHJvbCB0byBnZXQgdGhlIG5ldyBwb3NpdGlvbiBhbmQgc3RvcmUgaXRcclxuICAgIHZhciBhY2NlbGVyYXRpb24gPSAtdGhpcy5kICogdmVsb2NpdHkgLSB0aGlzLmsgKiAoY3VycmVudCAtIHRhcmdldClcclxuICAgIHZhciBuZXdQb3NpdGlvbiA9IGN1cnJlbnRcclxuICAgICAgKyB2ZWxvY2l0eSAqIGR0XHJcbiAgICAgICsgYWNjZWxlcmF0aW9uICogZHQgKiBkdCAvIDJcclxuXHJcbiAgICAvLyBTdG9yZSB0aGUgdmVsb2NpdHlcclxuICAgIGMudmVsb2NpdHkgPSB2ZWxvY2l0eSArIGFjY2VsZXJhdGlvbiAqIGR0XHJcblxyXG4gICAgLy8gRmlndXJlIG91dCBpZiB3ZSBoYXZlIGNvbnZlcmdlZCwgYW5kIGlmIHNvLCBwYXNzIHRoZSB2YWx1ZVxyXG4gICAgYy5kb25lID0gTWF0aC5hYnModGFyZ2V0IC0gbmV3UG9zaXRpb24pICsgTWF0aC5hYnModmVsb2NpdHkpIDwgMC4wMDJcclxuICAgIHJldHVybiBjLmRvbmUgPyB0YXJnZXQgOiBuZXdQb3NpdGlvblxyXG4gIH1cclxufVxyXG5cclxuZXh0ZW5kKFNwcmluZywge1xyXG4gIGR1cmF0aW9uOiBtYWtlU2V0dGVyR2V0dGVyKCdfZHVyYXRpb24nLCByZWNhbGN1bGF0ZSksXHJcbiAgb3ZlcnNob290OiBtYWtlU2V0dGVyR2V0dGVyKCdfb3ZlcnNob290JywgcmVjYWxjdWxhdGUpXHJcbn0pXHJcblxyXG5leHBvcnQgY2xhc3MgUElEIGV4dGVuZHMgQ29udHJvbGxlciB7XHJcbiAgY29uc3RydWN0b3IgKHAsIGksIGQsIHdpbmR1cCkge1xyXG4gICAgc3VwZXIoKVxyXG5cclxuICAgIHAgPSBwID09IG51bGwgPyAwLjEgOiBwXHJcbiAgICBpID0gaSA9PSBudWxsID8gMC4wMSA6IGlcclxuICAgIGQgPSBkID09IG51bGwgPyAwIDogZFxyXG4gICAgd2luZHVwID0gd2luZHVwID09IG51bGwgPyAxMDAwIDogd2luZHVwXHJcbiAgICB0aGlzLnAocCkuaShpKS5kKGQpLndpbmR1cCh3aW5kdXApXHJcbiAgfVxyXG5cclxuICBzdGVwIChjdXJyZW50LCB0YXJnZXQsIGR0LCBjKSB7XHJcbiAgICBpZiAodHlwZW9mIGN1cnJlbnQgPT09ICdzdHJpbmcnKSByZXR1cm4gY3VycmVudFxyXG4gICAgYy5kb25lID0gZHQgPT09IEluZmluaXR5XHJcblxyXG4gICAgaWYgKGR0ID09PSBJbmZpbml0eSkgcmV0dXJuIHRhcmdldFxyXG4gICAgaWYgKGR0ID09PSAwKSByZXR1cm4gY3VycmVudFxyXG5cclxuICAgIHZhciBwID0gdGFyZ2V0IC0gY3VycmVudFxyXG4gICAgdmFyIGkgPSAoYy5pbnRlZ3JhbCB8fCAwKSArIHAgKiBkdFxyXG4gICAgdmFyIGQgPSAocCAtIChjLmVycm9yIHx8IDApKSAvIGR0XHJcbiAgICB2YXIgd2luZHVwID0gdGhpcy53aW5kdXBcclxuXHJcbiAgICAvLyBhbnRpd2luZHVwXHJcbiAgICBpZiAod2luZHVwICE9PSBmYWxzZSkge1xyXG4gICAgICBpID0gTWF0aC5tYXgoLXdpbmR1cCwgTWF0aC5taW4oaSwgd2luZHVwKSlcclxuICAgIH1cclxuXHJcbiAgICBjLmVycm9yID0gcFxyXG4gICAgYy5pbnRlZ3JhbCA9IGlcclxuXHJcbiAgICBjLmRvbmUgPSBNYXRoLmFicyhwKSA8IDAuMDAxXHJcblxyXG4gICAgcmV0dXJuIGMuZG9uZSA/IHRhcmdldCA6IGN1cnJlbnQgKyAodGhpcy5QICogcCArIHRoaXMuSSAqIGkgKyB0aGlzLkQgKiBkKVxyXG4gIH1cclxufVxyXG5cclxuZXh0ZW5kKFBJRCwge1xyXG4gIHdpbmR1cDogbWFrZVNldHRlckdldHRlcignd2luZHVwJyksXHJcbiAgcDogbWFrZVNldHRlckdldHRlcignUCcpLFxyXG4gIGk6IG1ha2VTZXR0ZXJHZXR0ZXIoJ0knKSxcclxuICBkOiBtYWtlU2V0dGVyR2V0dGVyKCdEJylcclxufSlcclxuIiwiaW1wb3J0IHtcclxuICBkZWxpbWl0ZXIsXHJcbiAgZG90cyxcclxuICBoeXBoZW4sXHJcbiAgaXNQYXRoTGV0dGVyLFxyXG4gIG51bWJlcnNXaXRoRG90cyxcclxuICBwYXRoTGV0dGVyc1xyXG59IGZyb20gJy4uL21vZHVsZXMvY29yZS9yZWdleC5qcydcclxuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcclxuaW1wb3J0IHsgc3ViQ2xhc3NBcnJheSB9IGZyb20gJy4vQXJyYXlQb2x5ZmlsbC5qcydcclxuaW1wb3J0IFBvaW50IGZyb20gJy4vUG9pbnQuanMnXHJcbmltcG9ydCBTVkdBcnJheSBmcm9tICcuL1NWR0FycmF5LmpzJ1xyXG5pbXBvcnQgcGFyc2VyIGZyb20gJy4uL21vZHVsZXMvY29yZS9wYXJzZXIuanMnXHJcblxyXG5jb25zdCBQYXRoQXJyYXkgPSBzdWJDbGFzc0FycmF5KCdQYXRoQXJyYXknLCBTVkdBcnJheSlcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFBhdGhBcnJheVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHBhdGhSZWdSZXBsYWNlIChhLCBiLCBjLCBkKSB7XHJcbiAgcmV0dXJuIGMgKyBkLnJlcGxhY2UoZG90cywgJyAuJylcclxufVxyXG5cclxuZnVuY3Rpb24gYXJyYXlUb1N0cmluZyAoYSkge1xyXG4gIGZvciAodmFyIGkgPSAwLCBpbCA9IGEubGVuZ3RoLCBzID0gJyc7IGkgPCBpbDsgaSsrKSB7XHJcbiAgICBzICs9IGFbaV1bMF1cclxuXHJcbiAgICBpZiAoYVtpXVsxXSAhPSBudWxsKSB7XHJcbiAgICAgIHMgKz0gYVtpXVsxXVxyXG5cclxuICAgICAgaWYgKGFbaV1bMl0gIT0gbnVsbCkge1xyXG4gICAgICAgIHMgKz0gJyAnXHJcbiAgICAgICAgcyArPSBhW2ldWzJdXHJcblxyXG4gICAgICAgIGlmIChhW2ldWzNdICE9IG51bGwpIHtcclxuICAgICAgICAgIHMgKz0gJyAnXHJcbiAgICAgICAgICBzICs9IGFbaV1bM11cclxuICAgICAgICAgIHMgKz0gJyAnXHJcbiAgICAgICAgICBzICs9IGFbaV1bNF1cclxuXHJcbiAgICAgICAgICBpZiAoYVtpXVs1XSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHMgKz0gJyAnXHJcbiAgICAgICAgICAgIHMgKz0gYVtpXVs1XVxyXG4gICAgICAgICAgICBzICs9ICcgJ1xyXG4gICAgICAgICAgICBzICs9IGFbaV1bNl1cclxuXHJcbiAgICAgICAgICAgIGlmIChhW2ldWzddICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICBzICs9ICcgJ1xyXG4gICAgICAgICAgICAgIHMgKz0gYVtpXVs3XVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcyArICcgJ1xyXG59XHJcblxyXG5jb25zdCBwYXRoSGFuZGxlcnMgPSB7XHJcbiAgTTogZnVuY3Rpb24gKGMsIHAsIHAwKSB7XHJcbiAgICBwLnggPSBwMC54ID0gY1swXVxyXG4gICAgcC55ID0gcDAueSA9IGNbMV1cclxuXHJcbiAgICByZXR1cm4gWyAnTScsIHAueCwgcC55IF1cclxuICB9LFxyXG4gIEw6IGZ1bmN0aW9uIChjLCBwKSB7XHJcbiAgICBwLnggPSBjWzBdXHJcbiAgICBwLnkgPSBjWzFdXHJcbiAgICByZXR1cm4gWyAnTCcsIGNbMF0sIGNbMV0gXVxyXG4gIH0sXHJcbiAgSDogZnVuY3Rpb24gKGMsIHApIHtcclxuICAgIHAueCA9IGNbMF1cclxuICAgIHJldHVybiBbICdIJywgY1swXSBdXHJcbiAgfSxcclxuICBWOiBmdW5jdGlvbiAoYywgcCkge1xyXG4gICAgcC55ID0gY1swXVxyXG4gICAgcmV0dXJuIFsgJ1YnLCBjWzBdIF1cclxuICB9LFxyXG4gIEM6IGZ1bmN0aW9uIChjLCBwKSB7XHJcbiAgICBwLnggPSBjWzRdXHJcbiAgICBwLnkgPSBjWzVdXHJcbiAgICByZXR1cm4gWyAnQycsIGNbMF0sIGNbMV0sIGNbMl0sIGNbM10sIGNbNF0sIGNbNV0gXVxyXG4gIH0sXHJcbiAgUzogZnVuY3Rpb24gKGMsIHApIHtcclxuICAgIHAueCA9IGNbMl1cclxuICAgIHAueSA9IGNbM11cclxuICAgIHJldHVybiBbICdTJywgY1swXSwgY1sxXSwgY1syXSwgY1szXSBdXHJcbiAgfSxcclxuICBROiBmdW5jdGlvbiAoYywgcCkge1xyXG4gICAgcC54ID0gY1syXVxyXG4gICAgcC55ID0gY1szXVxyXG4gICAgcmV0dXJuIFsgJ1EnLCBjWzBdLCBjWzFdLCBjWzJdLCBjWzNdIF1cclxuICB9LFxyXG4gIFQ6IGZ1bmN0aW9uIChjLCBwKSB7XHJcbiAgICBwLnggPSBjWzBdXHJcbiAgICBwLnkgPSBjWzFdXHJcbiAgICByZXR1cm4gWyAnVCcsIGNbMF0sIGNbMV0gXVxyXG4gIH0sXHJcbiAgWjogZnVuY3Rpb24gKGMsIHAsIHAwKSB7XHJcbiAgICBwLnggPSBwMC54XHJcbiAgICBwLnkgPSBwMC55XHJcbiAgICByZXR1cm4gWyAnWicgXVxyXG4gIH0sXHJcbiAgQTogZnVuY3Rpb24gKGMsIHApIHtcclxuICAgIHAueCA9IGNbNV1cclxuICAgIHAueSA9IGNbNl1cclxuICAgIHJldHVybiBbICdBJywgY1swXSwgY1sxXSwgY1syXSwgY1szXSwgY1s0XSwgY1s1XSwgY1s2XSBdXHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBtbGh2cXRjc2F6ID0gJ21saHZxdGNzYXonLnNwbGl0KCcnKVxyXG5cclxuZm9yICh2YXIgaSA9IDAsIGlsID0gbWxodnF0Y3Nhei5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XHJcbiAgcGF0aEhhbmRsZXJzW21saHZxdGNzYXpbaV1dID0gKGZ1bmN0aW9uIChpKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGMsIHAsIHAwKSB7XHJcbiAgICAgIGlmIChpID09PSAnSCcpIGNbMF0gPSBjWzBdICsgcC54XHJcbiAgICAgIGVsc2UgaWYgKGkgPT09ICdWJykgY1swXSA9IGNbMF0gKyBwLnlcclxuICAgICAgZWxzZSBpZiAoaSA9PT0gJ0EnKSB7XHJcbiAgICAgICAgY1s1XSA9IGNbNV0gKyBwLnhcclxuICAgICAgICBjWzZdID0gY1s2XSArIHAueVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqbCA9IGMubGVuZ3RoOyBqIDwgamw7ICsraikge1xyXG4gICAgICAgICAgY1tqXSA9IGNbal0gKyAoaiAlIDIgPyBwLnkgOiBwLngpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcGF0aEhhbmRsZXJzW2ldKGMsIHAsIHAwKVxyXG4gICAgfVxyXG4gIH0pKG1saHZxdGNzYXpbaV0udG9VcHBlckNhc2UoKSlcclxufVxyXG5cclxuZXh0ZW5kKFBhdGhBcnJheSwge1xyXG4gIC8vIENvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXHJcbiAgdG9TdHJpbmcgKCkge1xyXG4gICAgcmV0dXJuIGFycmF5VG9TdHJpbmcodGhpcylcclxuICB9LFxyXG5cclxuICAvLyBNb3ZlIHBhdGggc3RyaW5nXHJcbiAgbW92ZSAoeCwgeSkge1xyXG4gICAgLy8gZ2V0IGJvdW5kaW5nIGJveCBvZiBjdXJyZW50IHNpdHVhdGlvblxyXG4gICAgdmFyIGJveCA9IHRoaXMuYmJveCgpXHJcblxyXG4gICAgLy8gZ2V0IHJlbGF0aXZlIG9mZnNldFxyXG4gICAgeCAtPSBib3gueFxyXG4gICAgeSAtPSBib3gueVxyXG5cclxuICAgIGlmICghaXNOYU4oeCkgJiYgIWlzTmFOKHkpKSB7XHJcbiAgICAgIC8vIG1vdmUgZXZlcnkgcG9pbnRcclxuICAgICAgZm9yICh2YXIgbCwgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBsID0gdGhpc1tpXVswXVxyXG5cclxuICAgICAgICBpZiAobCA9PT0gJ00nIHx8IGwgPT09ICdMJyB8fCBsID09PSAnVCcpIHtcclxuICAgICAgICAgIHRoaXNbaV1bMV0gKz0geFxyXG4gICAgICAgICAgdGhpc1tpXVsyXSArPSB5XHJcbiAgICAgICAgfSBlbHNlIGlmIChsID09PSAnSCcpIHtcclxuICAgICAgICAgIHRoaXNbaV1bMV0gKz0geFxyXG4gICAgICAgIH0gZWxzZSBpZiAobCA9PT0gJ1YnKSB7XHJcbiAgICAgICAgICB0aGlzW2ldWzFdICs9IHlcclxuICAgICAgICB9IGVsc2UgaWYgKGwgPT09ICdDJyB8fCBsID09PSAnUycgfHwgbCA9PT0gJ1EnKSB7XHJcbiAgICAgICAgICB0aGlzW2ldWzFdICs9IHhcclxuICAgICAgICAgIHRoaXNbaV1bMl0gKz0geVxyXG4gICAgICAgICAgdGhpc1tpXVszXSArPSB4XHJcbiAgICAgICAgICB0aGlzW2ldWzRdICs9IHlcclxuXHJcbiAgICAgICAgICBpZiAobCA9PT0gJ0MnKSB7XHJcbiAgICAgICAgICAgIHRoaXNbaV1bNV0gKz0geFxyXG4gICAgICAgICAgICB0aGlzW2ldWzZdICs9IHlcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGwgPT09ICdBJykge1xyXG4gICAgICAgICAgdGhpc1tpXVs2XSArPSB4XHJcbiAgICAgICAgICB0aGlzW2ldWzddICs9IHlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH0sXHJcblxyXG4gIC8vIFJlc2l6ZSBwYXRoIHN0cmluZ1xyXG4gIHNpemUgKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIC8vIGdldCBib3VuZGluZyBib3ggb2YgY3VycmVudCBzaXR1YXRpb25cclxuICAgIHZhciBib3ggPSB0aGlzLmJib3goKVxyXG4gICAgdmFyIGksIGxcclxuXHJcbiAgICAvLyBJZiB0aGUgYm94IHdpZHRoIG9yIGhlaWdodCBpcyAwIHRoZW4gd2UgaWdub3JlXHJcbiAgICAvLyB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIHJlc3BlY3RpdmUgYXhpc1xyXG4gICAgYm94LndpZHRoID0gYm94LndpZHRoID09PSAwID8gMSA6IGJveC53aWR0aFxyXG4gICAgYm94LmhlaWdodCA9IGJveC5oZWlnaHQgPT09IDAgPyAxIDogYm94LmhlaWdodFxyXG5cclxuICAgIC8vIHJlY2FsY3VsYXRlIHBvc2l0aW9uIG9mIGFsbCBwb2ludHMgYWNjb3JkaW5nIHRvIG5ldyBzaXplXHJcbiAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIGwgPSB0aGlzW2ldWzBdXHJcblxyXG4gICAgICBpZiAobCA9PT0gJ00nIHx8IGwgPT09ICdMJyB8fCBsID09PSAnVCcpIHtcclxuICAgICAgICB0aGlzW2ldWzFdID0gKCh0aGlzW2ldWzFdIC0gYm94LngpICogd2lkdGgpIC8gYm94LndpZHRoICsgYm94LnhcclxuICAgICAgICB0aGlzW2ldWzJdID0gKCh0aGlzW2ldWzJdIC0gYm94LnkpICogaGVpZ2h0KSAvIGJveC5oZWlnaHQgKyBib3gueVxyXG4gICAgICB9IGVsc2UgaWYgKGwgPT09ICdIJykge1xyXG4gICAgICAgIHRoaXNbaV1bMV0gPSAoKHRoaXNbaV1bMV0gLSBib3gueCkgKiB3aWR0aCkgLyBib3gud2lkdGggKyBib3gueFxyXG4gICAgICB9IGVsc2UgaWYgKGwgPT09ICdWJykge1xyXG4gICAgICAgIHRoaXNbaV1bMV0gPSAoKHRoaXNbaV1bMV0gLSBib3gueSkgKiBoZWlnaHQpIC8gYm94LmhlaWdodCArIGJveC55XHJcbiAgICAgIH0gZWxzZSBpZiAobCA9PT0gJ0MnIHx8IGwgPT09ICdTJyB8fCBsID09PSAnUScpIHtcclxuICAgICAgICB0aGlzW2ldWzFdID0gKCh0aGlzW2ldWzFdIC0gYm94LngpICogd2lkdGgpIC8gYm94LndpZHRoICsgYm94LnhcclxuICAgICAgICB0aGlzW2ldWzJdID0gKCh0aGlzW2ldWzJdIC0gYm94LnkpICogaGVpZ2h0KSAvIGJveC5oZWlnaHQgKyBib3gueVxyXG4gICAgICAgIHRoaXNbaV1bM10gPSAoKHRoaXNbaV1bM10gLSBib3gueCkgKiB3aWR0aCkgLyBib3gud2lkdGggKyBib3gueFxyXG4gICAgICAgIHRoaXNbaV1bNF0gPSAoKHRoaXNbaV1bNF0gLSBib3gueSkgKiBoZWlnaHQpIC8gYm94LmhlaWdodCArIGJveC55XHJcblxyXG4gICAgICAgIGlmIChsID09PSAnQycpIHtcclxuICAgICAgICAgIHRoaXNbaV1bNV0gPSAoKHRoaXNbaV1bNV0gLSBib3gueCkgKiB3aWR0aCkgLyBib3gud2lkdGggKyBib3gueFxyXG4gICAgICAgICAgdGhpc1tpXVs2XSA9ICgodGhpc1tpXVs2XSAtIGJveC55KSAqIGhlaWdodCkgLyBib3guaGVpZ2h0ICsgYm94LnlcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAobCA9PT0gJ0EnKSB7XHJcbiAgICAgICAgLy8gcmVzaXplIHJhZGlpXHJcbiAgICAgICAgdGhpc1tpXVsxXSA9ICh0aGlzW2ldWzFdICogd2lkdGgpIC8gYm94LndpZHRoXHJcbiAgICAgICAgdGhpc1tpXVsyXSA9ICh0aGlzW2ldWzJdICogaGVpZ2h0KSAvIGJveC5oZWlnaHRcclxuXHJcbiAgICAgICAgLy8gbW92ZSBwb3NpdGlvbiB2YWx1ZXNcclxuICAgICAgICB0aGlzW2ldWzZdID0gKCh0aGlzW2ldWzZdIC0gYm94LngpICogd2lkdGgpIC8gYm94LndpZHRoICsgYm94LnhcclxuICAgICAgICB0aGlzW2ldWzddID0gKCh0aGlzW2ldWzddIC0gYm94LnkpICogaGVpZ2h0KSAvIGJveC5oZWlnaHQgKyBib3gueVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9LFxyXG5cclxuICAvLyBUZXN0IGlmIHRoZSBwYXNzZWQgcGF0aCBhcnJheSB1c2UgdGhlIHNhbWUgcGF0aCBkYXRhIGNvbW1hbmRzIGFzIHRoaXMgcGF0aCBhcnJheVxyXG4gIGVxdWFsQ29tbWFuZHMgKHBhdGhBcnJheSkge1xyXG4gICAgdmFyIGksIGlsLCBlcXVhbENvbW1hbmRzXHJcblxyXG4gICAgcGF0aEFycmF5ID0gbmV3IFBhdGhBcnJheShwYXRoQXJyYXkpXHJcblxyXG4gICAgZXF1YWxDb21tYW5kcyA9IHRoaXMubGVuZ3RoID09PSBwYXRoQXJyYXkubGVuZ3RoXHJcbiAgICBmb3IgKGkgPSAwLCBpbCA9IHRoaXMubGVuZ3RoOyBlcXVhbENvbW1hbmRzICYmIGkgPCBpbDsgaSsrKSB7XHJcbiAgICAgIGVxdWFsQ29tbWFuZHMgPSB0aGlzW2ldWzBdID09PSBwYXRoQXJyYXlbaV1bMF1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZXF1YWxDb21tYW5kc1xyXG4gIH0sXHJcblxyXG4gIC8vIE1ha2UgcGF0aCBhcnJheSBtb3JwaGFibGVcclxuICBtb3JwaCAocGF0aEFycmF5KSB7XHJcbiAgICBwYXRoQXJyYXkgPSBuZXcgUGF0aEFycmF5KHBhdGhBcnJheSlcclxuXHJcbiAgICBpZiAodGhpcy5lcXVhbENvbW1hbmRzKHBhdGhBcnJheSkpIHtcclxuICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IHBhdGhBcnJheVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG51bGxcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH0sXHJcblxyXG4gIC8vIEdldCBtb3JwaGVkIHBhdGggYXJyYXkgYXQgZ2l2ZW4gcG9zaXRpb25cclxuICBhdCAocG9zKSB7XHJcbiAgICAvLyBtYWtlIHN1cmUgYSBkZXN0aW5hdGlvbiBpcyBkZWZpbmVkXHJcbiAgICBpZiAoIXRoaXMuZGVzdGluYXRpb24pIHJldHVybiB0aGlzXHJcblxyXG4gICAgdmFyIHNvdXJjZUFycmF5ID0gdGhpc1xyXG4gICAgdmFyIGRlc3RpbmF0aW9uQXJyYXkgPSB0aGlzLmRlc3RpbmF0aW9uLnZhbHVlXHJcbiAgICB2YXIgYXJyYXkgPSBbXVxyXG4gICAgdmFyIHBhdGhBcnJheSA9IG5ldyBQYXRoQXJyYXkoKVxyXG4gICAgdmFyIGksIGlsLCBqLCBqbFxyXG5cclxuICAgIC8vIEFuaW1hdGUgaGFzIHNwZWNpZmllZCBpbiB0aGUgU1ZHIHNwZWNcclxuICAgIC8vIFNlZTogaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRzExL3BhdGhzLmh0bWwjUGF0aEVsZW1lbnRcclxuICAgIGZvciAoaSA9IDAsIGlsID0gc291cmNlQXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xyXG4gICAgICBhcnJheVtpXSA9IFsgc291cmNlQXJyYXlbaV1bMF0gXVxyXG4gICAgICBmb3IgKGogPSAxLCBqbCA9IHNvdXJjZUFycmF5W2ldLmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcclxuICAgICAgICBhcnJheVtpXVtqXSA9IHNvdXJjZUFycmF5W2ldW2pdICsgKGRlc3RpbmF0aW9uQXJyYXlbaV1bal0gLSBzb3VyY2VBcnJheVtpXVtqXSkgKiBwb3NcclxuICAgICAgfVxyXG4gICAgICAvLyBGb3IgdGhlIHR3byBmbGFncyBvZiB0aGUgZWxsaXB0aWNhbCBhcmMgY29tbWFuZCwgdGhlIFNWRyBzcGVjIHNheTpcclxuICAgICAgLy8gRmxhZ3MgYW5kIGJvb2xlYW5zIGFyZSBpbnRlcnBvbGF0ZWQgYXMgZnJhY3Rpb25zIGJldHdlZW4gemVybyBhbmQgb25lLCB3aXRoIGFueSBub24temVybyB2YWx1ZSBjb25zaWRlcmVkIHRvIGJlIGEgdmFsdWUgb2Ygb25lL3RydWVcclxuICAgICAgLy8gRWxsaXB0aWNhbCBhcmMgY29tbWFuZCBhcyBhbiBhcnJheSBmb2xsb3dlZCBieSBjb3JyZXNwb25kaW5nIGluZGV4ZXM6XHJcbiAgICAgIC8vIFsnQScsIHJ4LCByeSwgeC1heGlzLXJvdGF0aW9uLCBsYXJnZS1hcmMtZmxhZywgc3dlZXAtZmxhZywgeCwgeV1cclxuICAgICAgLy8gICAwICAgIDEgICAyICAgICAgICAzICAgICAgICAgICAgICAgICA0ICAgICAgICAgICAgIDUgICAgICA2ICA3XHJcbiAgICAgIGlmIChhcnJheVtpXVswXSA9PT0gJ0EnKSB7XHJcbiAgICAgICAgYXJyYXlbaV1bNF0gPSArKGFycmF5W2ldWzRdICE9PSAwKVxyXG4gICAgICAgIGFycmF5W2ldWzVdID0gKyhhcnJheVtpXVs1XSAhPT0gMClcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIERpcmVjdGx5IG1vZGlmeSB0aGUgdmFsdWUgb2YgYSBwYXRoIGFycmF5LCB0aGlzIGlzIGRvbmUgdGhpcyB3YXkgZm9yIHBlcmZvcm1hbmNlXHJcbiAgICBwYXRoQXJyYXkudmFsdWUgPSBhcnJheVxyXG4gICAgcmV0dXJuIHBhdGhBcnJheVxyXG4gIH0sXHJcblxyXG4gIC8vIEFic29sdXRpemUgYW5kIHBhcnNlIHBhdGggdG8gYXJyYXlcclxuICBwYXJzZSAoYXJyYXkgPSBbIFsgJ00nLCAwLCAwIF0gXSkge1xyXG4gICAgLy8gaWYgaXQncyBhbHJlYWR5IGEgcGF0aGFycmF5LCBubyBuZWVkIHRvIHBhcnNlIGl0XHJcbiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBQYXRoQXJyYXkpIHJldHVybiBhcnJheVxyXG5cclxuICAgIC8vIHByZXBhcmUgZm9yIHBhcnNpbmdcclxuICAgIHZhciBzXHJcbiAgICB2YXIgcGFyYW1DbnQgPSB7IE06IDIsIEw6IDIsIEg6IDEsIFY6IDEsIEM6IDYsIFM6IDQsIFE6IDQsIFQ6IDIsIEE6IDcsIFo6IDAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgYXJyYXkgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIGFycmF5ID0gYXJyYXlcclxuICAgICAgICAucmVwbGFjZShudW1iZXJzV2l0aERvdHMsIHBhdGhSZWdSZXBsYWNlKSAvLyBjb252ZXJ0IDQ1LjEyMy4xMjMgdG8gNDUuMTIzIC4xMjNcclxuICAgICAgICAucmVwbGFjZShwYXRoTGV0dGVycywgJyAkJiAnKSAvLyBwdXQgc29tZSByb29tIGJldHdlZW4gbGV0dGVycyBhbmQgbnVtYmVyc1xyXG4gICAgICAgIC5yZXBsYWNlKGh5cGhlbiwgJyQxIC0nKSAvLyBhZGQgc3BhY2UgYmVmb3JlIGh5cGhlblxyXG4gICAgICAgIC50cmltKCkgLy8gdHJpbVxyXG4gICAgICAgIC5zcGxpdChkZWxpbWl0ZXIpIC8vIHNwbGl0IGludG8gYXJyYXlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGFycmF5ID0gYXJyYXkucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdLmNvbmNhdC5jYWxsKHByZXYsIGN1cnIpXHJcbiAgICAgIH0sIFtdKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGFycmF5IG5vdyBpcyBhbiBhcnJheSBjb250YWluaW5nIGFsbCBwYXJ0cyBvZiBhIHBhdGggZS5nLiBbJ00nLCAnMCcsICcwJywgJ0wnLCAnMzAnLCAnMzAnIC4uLl1cclxuICAgIHZhciByZXN1bHQgPSBbXVxyXG4gICAgdmFyIHAgPSBuZXcgUG9pbnQoKVxyXG4gICAgdmFyIHAwID0gbmV3IFBvaW50KClcclxuICAgIHZhciBpbmRleCA9IDBcclxuICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGhcclxuXHJcbiAgICBkbyB7XHJcbiAgICAgIC8vIFRlc3QgaWYgd2UgaGF2ZSBhIHBhdGggbGV0dGVyXHJcbiAgICAgIGlmIChpc1BhdGhMZXR0ZXIudGVzdChhcnJheVtpbmRleF0pKSB7XHJcbiAgICAgICAgcyA9IGFycmF5W2luZGV4XVxyXG4gICAgICAgICsraW5kZXhcclxuICAgICAgICAvLyBJZiBsYXN0IGxldHRlciB3YXMgYSBtb3ZlIGNvbW1hbmQgYW5kIHdlIGdvdCBubyBuZXcsIGl0IGRlZmF1bHRzIHRvIFtMXWluZVxyXG4gICAgICB9IGVsc2UgaWYgKHMgPT09ICdNJykge1xyXG4gICAgICAgIHMgPSAnTCdcclxuICAgICAgfSBlbHNlIGlmIChzID09PSAnbScpIHtcclxuICAgICAgICBzID0gJ2wnXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlc3VsdC5wdXNoKHBhdGhIYW5kbGVyc1tzXS5jYWxsKG51bGwsXHJcbiAgICAgICAgYXJyYXkuc2xpY2UoaW5kZXgsIChpbmRleCA9IGluZGV4ICsgcGFyYW1DbnRbcy50b1VwcGVyQ2FzZSgpXSkpLm1hcChwYXJzZUZsb2F0KSxcclxuICAgICAgICBwLCBwMFxyXG4gICAgICApXHJcbiAgICAgIClcclxuICAgIH0gd2hpbGUgKGxlbiA+IGluZGV4KVxyXG5cclxuICAgIHJldHVybiByZXN1bHRcclxuICB9LFxyXG5cclxuICAvLyBHZXQgYm91bmRpbmcgYm94IG9mIHBhdGhcclxuICBiYm94ICgpIHtcclxuICAgIHBhcnNlcigpLnBhdGguc2V0QXR0cmlidXRlKCdkJywgdGhpcy50b1N0cmluZygpKVxyXG4gICAgcmV0dXJuIHBhcnNlci5ub2Rlcy5wYXRoLmdldEJCb3goKVxyXG4gIH1cclxufSlcclxuIiwiaW1wb3J0IHsgRWFzZSB9IGZyb20gJy4vQ29udHJvbGxlci5qcydcclxuaW1wb3J0IHtcclxuICBkZWxpbWl0ZXIsXHJcbiAgbnVtYmVyQW5kVW5pdCxcclxuICBwYXRoTGV0dGVyc1xyXG59IGZyb20gJy4uL21vZHVsZXMvY29yZS9yZWdleC5qcydcclxuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcclxuaW1wb3J0IENvbG9yIGZyb20gJy4uL3R5cGVzL0NvbG9yLmpzJ1xyXG5pbXBvcnQgUGF0aEFycmF5IGZyb20gJy4uL3R5cGVzL1BhdGhBcnJheS5qcydcclxuaW1wb3J0IFNWR0FycmF5IGZyb20gJy4uL3R5cGVzL1NWR0FycmF5LmpzJ1xyXG5pbXBvcnQgU1ZHTnVtYmVyIGZyb20gJy4uL3R5cGVzL1NWR051bWJlci5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vcnBoYWJsZSB7XHJcbiAgY29uc3RydWN0b3IgKHN0ZXBwZXIpIHtcclxuICAgIHRoaXMuX3N0ZXBwZXIgPSBzdGVwcGVyIHx8IG5ldyBFYXNlKCctJylcclxuXHJcbiAgICB0aGlzLl9mcm9tID0gbnVsbFxyXG4gICAgdGhpcy5fdG8gPSBudWxsXHJcbiAgICB0aGlzLl90eXBlID0gbnVsbFxyXG4gICAgdGhpcy5fY29udGV4dCA9IG51bGxcclxuICAgIHRoaXMuX21vcnBoT2JqID0gbnVsbFxyXG4gIH1cclxuXHJcbiAgZnJvbSAodmFsKSB7XHJcbiAgICBpZiAodmFsID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2Zyb21cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9mcm9tID0gdGhpcy5fc2V0KHZhbClcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICB0byAodmFsKSB7XHJcbiAgICBpZiAodmFsID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3RvXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fdG8gPSB0aGlzLl9zZXQodmFsKVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIHR5cGUgKHR5cGUpIHtcclxuICAgIC8vIGdldHRlclxyXG4gICAgaWYgKHR5cGUgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fdHlwZVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHNldHRlclxyXG4gICAgdGhpcy5fdHlwZSA9IHR5cGVcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICBfc2V0ICh2YWx1ZSkge1xyXG4gICAgaWYgKCF0aGlzLl90eXBlKSB7XHJcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlXHJcblxyXG4gICAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICB0aGlzLnR5cGUoU1ZHTnVtYmVyKVxyXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgaWYgKENvbG9yLmlzQ29sb3IodmFsdWUpKSB7XHJcbiAgICAgICAgICB0aGlzLnR5cGUoQ29sb3IpXHJcbiAgICAgICAgfSBlbHNlIGlmIChkZWxpbWl0ZXIudGVzdCh2YWx1ZSkpIHtcclxuICAgICAgICAgIHRoaXMudHlwZShwYXRoTGV0dGVycy50ZXN0KHZhbHVlKVxyXG4gICAgICAgICAgICA/IFBhdGhBcnJheVxyXG4gICAgICAgICAgICA6IFNWR0FycmF5XHJcbiAgICAgICAgICApXHJcbiAgICAgICAgfSBlbHNlIGlmIChudW1iZXJBbmRVbml0LnRlc3QodmFsdWUpKSB7XHJcbiAgICAgICAgICB0aGlzLnR5cGUoU1ZHTnVtYmVyKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLnR5cGUoTm9uTW9ycGhhYmxlKVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChtb3JwaGFibGVUeXBlcy5pbmRleE9mKHZhbHVlLmNvbnN0cnVjdG9yKSA+IC0xKSB7XHJcbiAgICAgICAgdGhpcy50eXBlKHZhbHVlLmNvbnN0cnVjdG9yKVxyXG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgdGhpcy50eXBlKFNWR0FycmF5KVxyXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgdGhpcy50eXBlKE9iamVjdEJhZylcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnR5cGUoTm9uTW9ycGhhYmxlKVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IChuZXcgdGhpcy5fdHlwZSh2YWx1ZSkpXHJcbiAgICBpZiAodGhpcy5fdHlwZSA9PT0gQ29sb3IpIHtcclxuICAgICAgcmVzdWx0ID0gdGhpcy5fdG8gPyByZXN1bHRbdGhpcy5fdG9bNF1dKClcclxuICAgICAgICA6IHRoaXMuX2Zyb20gPyByZXN1bHRbdGhpcy5fZnJvbVs0XV0oKVxyXG4gICAgICAgIDogcmVzdWx0XHJcbiAgICB9XHJcbiAgICByZXN1bHQgPSByZXN1bHQudG9BcnJheSgpXHJcblxyXG4gICAgdGhpcy5fbW9ycGhPYmogPSB0aGlzLl9tb3JwaE9iaiB8fCBuZXcgdGhpcy5fdHlwZSgpXHJcbiAgICB0aGlzLl9jb250ZXh0ID0gdGhpcy5fY29udGV4dFxyXG4gICAgICB8fCBBcnJheS5hcHBseShudWxsLCBBcnJheShyZXN1bHQubGVuZ3RoKSlcclxuICAgICAgICAubWFwKE9iamVjdClcclxuICAgICAgICAubWFwKGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgICBvLmRvbmUgPSB0cnVlXHJcbiAgICAgICAgICByZXR1cm4gb1xyXG4gICAgICAgIH0pXHJcbiAgICByZXR1cm4gcmVzdWx0XHJcbiAgfVxyXG5cclxuICBzdGVwcGVyIChzdGVwcGVyKSB7XHJcbiAgICBpZiAoc3RlcHBlciA9PSBudWxsKSByZXR1cm4gdGhpcy5fc3RlcHBlclxyXG4gICAgdGhpcy5fc3RlcHBlciA9IHN0ZXBwZXJcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICBkb25lICgpIHtcclxuICAgIHZhciBjb21wbGV0ZSA9IHRoaXMuX2NvbnRleHRcclxuICAgICAgLm1hcCh0aGlzLl9zdGVwcGVyLmRvbmUpXHJcbiAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGxhc3QsIGN1cnIpIHtcclxuICAgICAgICByZXR1cm4gbGFzdCAmJiBjdXJyXHJcbiAgICAgIH0sIHRydWUpXHJcbiAgICByZXR1cm4gY29tcGxldGVcclxuICB9XHJcblxyXG4gIGF0IChwb3MpIHtcclxuICAgIHZhciBfdGhpcyA9IHRoaXNcclxuXHJcbiAgICByZXR1cm4gdGhpcy5fbW9ycGhPYmouZnJvbUFycmF5KFxyXG4gICAgICB0aGlzLl9mcm9tLm1hcChmdW5jdGlvbiAoaSwgaW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gX3RoaXMuX3N0ZXBwZXIuc3RlcChpLCBfdGhpcy5fdG9baW5kZXhdLCBwb3MsIF90aGlzLl9jb250ZXh0W2luZGV4XSwgX3RoaXMuX2NvbnRleHQpXHJcbiAgICAgIH0pXHJcbiAgICApXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgTm9uTW9ycGhhYmxlIHtcclxuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xyXG4gICAgdGhpcy5pbml0KC4uLmFyZ3MpXHJcbiAgfVxyXG5cclxuICBpbml0ICh2YWwpIHtcclxuICAgIHZhbCA9IEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbFswXSA6IHZhbFxyXG4gICAgdGhpcy52YWx1ZSA9IHZhbFxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIHZhbHVlT2YgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudmFsdWVcclxuICB9XHJcblxyXG4gIHRvQXJyYXkgKCkge1xyXG4gICAgcmV0dXJuIFsgdGhpcy52YWx1ZSBdXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgVHJhbnNmb3JtQmFnIHtcclxuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xyXG4gICAgdGhpcy5pbml0KC4uLmFyZ3MpXHJcbiAgfVxyXG5cclxuICBpbml0IChvYmopIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcclxuICAgICAgb2JqID0ge1xyXG4gICAgICAgIHNjYWxlWDogb2JqWzBdLFxyXG4gICAgICAgIHNjYWxlWTogb2JqWzFdLFxyXG4gICAgICAgIHNoZWFyOiBvYmpbMl0sXHJcbiAgICAgICAgcm90YXRlOiBvYmpbM10sXHJcbiAgICAgICAgdHJhbnNsYXRlWDogb2JqWzRdLFxyXG4gICAgICAgIHRyYW5zbGF0ZVk6IG9ials1XSxcclxuICAgICAgICBvcmlnaW5YOiBvYmpbNl0sXHJcbiAgICAgICAgb3JpZ2luWTogb2JqWzddXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIFRyYW5zZm9ybUJhZy5kZWZhdWx0cywgb2JqKVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIHRvQXJyYXkgKCkge1xyXG4gICAgdmFyIHYgPSB0aGlzXHJcblxyXG4gICAgcmV0dXJuIFtcclxuICAgICAgdi5zY2FsZVgsXHJcbiAgICAgIHYuc2NhbGVZLFxyXG4gICAgICB2LnNoZWFyLFxyXG4gICAgICB2LnJvdGF0ZSxcclxuICAgICAgdi50cmFuc2xhdGVYLFxyXG4gICAgICB2LnRyYW5zbGF0ZVksXHJcbiAgICAgIHYub3JpZ2luWCxcclxuICAgICAgdi5vcmlnaW5ZXHJcbiAgICBdXHJcbiAgfVxyXG59XHJcblxyXG5UcmFuc2Zvcm1CYWcuZGVmYXVsdHMgPSB7XHJcbiAgc2NhbGVYOiAxLFxyXG4gIHNjYWxlWTogMSxcclxuICBzaGVhcjogMCxcclxuICByb3RhdGU6IDAsXHJcbiAgdHJhbnNsYXRlWDogMCxcclxuICB0cmFuc2xhdGVZOiAwLFxyXG4gIG9yaWdpblg6IDAsXHJcbiAgb3JpZ2luWTogMFxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgT2JqZWN0QmFnIHtcclxuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xyXG4gICAgdGhpcy5pbml0KC4uLmFyZ3MpXHJcbiAgfVxyXG5cclxuICBpbml0IChvYmpPckFycikge1xyXG4gICAgdGhpcy52YWx1ZXMgPSBbXVxyXG5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iak9yQXJyKSkge1xyXG4gICAgICB0aGlzLnZhbHVlcyA9IG9iak9yQXJyXHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIG9iak9yQXJyID0gb2JqT3JBcnIgfHwge31cclxuICAgIHZhciBlbnRyaWVzID0gW11cclxuXHJcbiAgICBmb3IgKGNvbnN0IGkgaW4gb2JqT3JBcnIpIHtcclxuICAgICAgZW50cmllcy5wdXNoKFsgaSwgb2JqT3JBcnJbaV0gXSlcclxuICAgIH1cclxuXHJcbiAgICBlbnRyaWVzLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgcmV0dXJuIGFbMF0gLSBiWzBdXHJcbiAgICB9KVxyXG5cclxuICAgIHRoaXMudmFsdWVzID0gZW50cmllcy5yZWR1Y2UoKGxhc3QsIGN1cnIpID0+IGxhc3QuY29uY2F0KGN1cnIpLCBbXSlcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICB2YWx1ZU9mICgpIHtcclxuICAgIHZhciBvYmogPSB7fVxyXG4gICAgdmFyIGFyciA9IHRoaXMudmFsdWVzXHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xyXG4gICAgICBvYmpbYXJyW2ldXSA9IGFycltpICsgMV1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb2JqXHJcbiAgfVxyXG5cclxuICB0b0FycmF5ICgpIHtcclxuICAgIHJldHVybiB0aGlzLnZhbHVlc1xyXG4gIH1cclxufVxyXG5cclxuY29uc3QgbW9ycGhhYmxlVHlwZXMgPSBbXHJcbiAgTm9uTW9ycGhhYmxlLFxyXG4gIFRyYW5zZm9ybUJhZyxcclxuICBPYmplY3RCYWdcclxuXVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyTW9ycGhhYmxlVHlwZSAodHlwZSA9IFtdKSB7XHJcbiAgbW9ycGhhYmxlVHlwZXMucHVzaCguLi5bXS5jb25jYXQodHlwZSkpXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtYWtlTW9ycGhhYmxlICgpIHtcclxuICBleHRlbmQobW9ycGhhYmxlVHlwZXMsIHtcclxuICAgIHRvICh2YWwpIHtcclxuICAgICAgcmV0dXJuIG5ldyBNb3JwaGFibGUoKVxyXG4gICAgICAgIC50eXBlKHRoaXMuY29uc3RydWN0b3IpXHJcbiAgICAgICAgLmZyb20odGhpcy52YWx1ZU9mKCkpXHJcbiAgICAgICAgLnRvKHZhbClcclxuICAgIH0sXHJcbiAgICBmcm9tQXJyYXkgKGFycikge1xyXG4gICAgICB0aGlzLmluaXQoYXJyKVxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gIH0pXHJcbn1cclxuIiwiaW1wb3J0IHsgbm9kZU9yTmV3LCByZWdpc3Rlciwgd3JhcFdpdGhBdHRyQ2hlY2sgfSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgeyBwcm9wb3J0aW9uYWxTaXplIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMuanMnXHJcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXHJcbmltcG9ydCBQYXRoQXJyYXkgZnJvbSAnLi4vdHlwZXMvUGF0aEFycmF5LmpzJ1xyXG5pbXBvcnQgU2hhcGUgZnJvbSAnLi9TaGFwZS5qcydcclxuaW1wb3J0IGJhc2VGaW5kIGZyb20gJy4uL21vZHVsZXMvY29yZS9zZWxlY3Rvci5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhdGggZXh0ZW5kcyBTaGFwZSB7XHJcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXHJcbiAgY29uc3RydWN0b3IgKG5vZGUpIHtcclxuICAgIHN1cGVyKG5vZGVPck5ldygncGF0aCcsIG5vZGUpLCBub2RlKVxyXG4gIH1cclxuXHJcbiAgLy8gR2V0IGFycmF5XHJcbiAgYXJyYXkgKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2FycmF5IHx8ICh0aGlzLl9hcnJheSA9IG5ldyBQYXRoQXJyYXkodGhpcy5hdHRyKCdkJykpKVxyXG4gIH1cclxuXHJcbiAgLy8gUGxvdCBuZXcgcGF0aFxyXG4gIHBsb3QgKGQpIHtcclxuICAgIHJldHVybiAoZCA9PSBudWxsKSA/IHRoaXMuYXJyYXkoKVxyXG4gICAgICA6IHRoaXMuY2xlYXIoKS5hdHRyKCdkJywgdHlwZW9mIGQgPT09ICdzdHJpbmcnID8gZCA6ICh0aGlzLl9hcnJheSA9IG5ldyBQYXRoQXJyYXkoZCkpKVxyXG4gIH1cclxuXHJcbiAgLy8gQ2xlYXIgYXJyYXkgY2FjaGVcclxuICBjbGVhciAoKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fYXJyYXlcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lclxyXG4gIG1vdmUgKHgsIHkpIHtcclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ2QnLCB0aGlzLmFycmF5KCkubW92ZSh4LCB5KSlcclxuICB9XHJcblxyXG4gIC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyIG92ZXIgeC1heGlzXHJcbiAgeCAoeCkge1xyXG4gICAgcmV0dXJuIHggPT0gbnVsbCA/IHRoaXMuYmJveCgpLnggOiB0aGlzLm1vdmUoeCwgdGhpcy5iYm94KCkueSlcclxuICB9XHJcblxyXG4gIC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyIG92ZXIgeS1heGlzXHJcbiAgeSAoeSkge1xyXG4gICAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMuYmJveCgpLnkgOiB0aGlzLm1vdmUodGhpcy5iYm94KCkueCwgeSlcclxuICB9XHJcblxyXG4gIC8vIFNldCBlbGVtZW50IHNpemUgdG8gZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxyXG4gIHNpemUgKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIHZhciBwID0gcHJvcG9ydGlvbmFsU2l6ZSh0aGlzLCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAgcmV0dXJuIHRoaXMuYXR0cignZCcsIHRoaXMuYXJyYXkoKS5zaXplKHAud2lkdGgsIHAuaGVpZ2h0KSlcclxuICB9XHJcblxyXG4gIC8vIFNldCB3aWR0aCBvZiBlbGVtZW50XHJcbiAgd2lkdGggKHdpZHRoKSB7XHJcbiAgICByZXR1cm4gd2lkdGggPT0gbnVsbCA/IHRoaXMuYmJveCgpLndpZHRoIDogdGhpcy5zaXplKHdpZHRoLCB0aGlzLmJib3goKS5oZWlnaHQpXHJcbiAgfVxyXG5cclxuICAvLyBTZXQgaGVpZ2h0IG9mIGVsZW1lbnRcclxuICBoZWlnaHQgKGhlaWdodCkge1xyXG4gICAgcmV0dXJuIGhlaWdodCA9PSBudWxsID8gdGhpcy5iYm94KCkuaGVpZ2h0IDogdGhpcy5zaXplKHRoaXMuYmJveCgpLndpZHRoLCBoZWlnaHQpXHJcbiAgfVxyXG5cclxuICB0YXJnZXRzICgpIHtcclxuICAgIHJldHVybiBiYXNlRmluZCgnc3ZnIHRleHRwYXRoIFtocmVmKj1cIicgKyB0aGlzLmlkKCkgKyAnXCJdJylcclxuICB9XHJcbn1cclxuXHJcbi8vIERlZmluZSBtb3JwaGFibGUgYXJyYXlcclxuUGF0aC5wcm90b3R5cGUuTW9ycGhBcnJheSA9IFBhdGhBcnJheVxyXG5cclxuLy8gQWRkIHBhcmVudCBtZXRob2RcclxucmVnaXN0ZXJNZXRob2RzKHtcclxuICBDb250YWluZXI6IHtcclxuICAgIC8vIENyZWF0ZSBhIHdyYXBwZWQgcGF0aCBlbGVtZW50XHJcbiAgICBwYXRoOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAoZCkge1xyXG4gICAgICAvLyBtYWtlIHN1cmUgcGxvdCBpcyBjYWxsZWQgYXMgYSBzZXR0ZXJcclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBQYXRoKCkpLnBsb3QoZCB8fCBuZXcgUGF0aEFycmF5KCkpXHJcbiAgICB9KVxyXG4gIH1cclxufSlcclxuXHJcbnJlZ2lzdGVyKFBhdGgsICdQYXRoJylcclxuIiwiaW1wb3J0IHsgcHJvcG9ydGlvbmFsU2l6ZSB9IGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzLmpzJ1xyXG5pbXBvcnQgUG9pbnRBcnJheSBmcm9tICcuLi8uLi90eXBlcy9Qb2ludEFycmF5LmpzJ1xyXG5cclxuLy8gR2V0IGFycmF5XHJcbmV4cG9ydCBmdW5jdGlvbiBhcnJheSAoKSB7XHJcbiAgcmV0dXJuIHRoaXMuX2FycmF5IHx8ICh0aGlzLl9hcnJheSA9IG5ldyBQb2ludEFycmF5KHRoaXMuYXR0cigncG9pbnRzJykpKVxyXG59XHJcblxyXG4vLyBQbG90IG5ldyBwYXRoXHJcbmV4cG9ydCBmdW5jdGlvbiBwbG90IChwKSB7XHJcbiAgcmV0dXJuIChwID09IG51bGwpID8gdGhpcy5hcnJheSgpXHJcbiAgICA6IHRoaXMuY2xlYXIoKS5hdHRyKCdwb2ludHMnLCB0eXBlb2YgcCA9PT0gJ3N0cmluZycgPyBwXHJcbiAgICA6ICh0aGlzLl9hcnJheSA9IG5ldyBQb2ludEFycmF5KHApKSlcclxufVxyXG5cclxuLy8gQ2xlYXIgYXJyYXkgY2FjaGVcclxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyICgpIHtcclxuICBkZWxldGUgdGhpcy5fYXJyYXlcclxuICByZXR1cm4gdGhpc1xyXG59XHJcblxyXG4vLyBNb3ZlIGJ5IGxlZnQgdG9wIGNvcm5lclxyXG5leHBvcnQgZnVuY3Rpb24gbW92ZSAoeCwgeSkge1xyXG4gIHJldHVybiB0aGlzLmF0dHIoJ3BvaW50cycsIHRoaXMuYXJyYXkoKS5tb3ZlKHgsIHkpKVxyXG59XHJcblxyXG4vLyBTZXQgZWxlbWVudCBzaXplIHRvIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHRcclxuZXhwb3J0IGZ1bmN0aW9uIHNpemUgKHdpZHRoLCBoZWlnaHQpIHtcclxuICBjb25zdCBwID0gcHJvcG9ydGlvbmFsU2l6ZSh0aGlzLCB3aWR0aCwgaGVpZ2h0KVxyXG4gIHJldHVybiB0aGlzLmF0dHIoJ3BvaW50cycsIHRoaXMuYXJyYXkoKS5zaXplKHAud2lkdGgsIHAuaGVpZ2h0KSlcclxufVxyXG4iLCJpbXBvcnQge1xyXG4gIGV4dGVuZCxcclxuICBub2RlT3JOZXcsXHJcbiAgcmVnaXN0ZXIsXHJcbiAgd3JhcFdpdGhBdHRyQ2hlY2tcclxufSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xyXG5pbXBvcnQgUG9pbnRBcnJheSBmcm9tICcuLi90eXBlcy9Qb2ludEFycmF5LmpzJ1xyXG5pbXBvcnQgU2hhcGUgZnJvbSAnLi9TaGFwZS5qcydcclxuaW1wb3J0ICogYXMgcG9pbnRlZCBmcm9tICcuLi9tb2R1bGVzL2NvcmUvcG9pbnRlZC5qcydcclxuaW1wb3J0ICogYXMgcG9seSBmcm9tICcuLi9tb2R1bGVzL2NvcmUvcG9seS5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvbHlnb24gZXh0ZW5kcyBTaGFwZSB7XHJcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXHJcbiAgY29uc3RydWN0b3IgKG5vZGUpIHtcclxuICAgIHN1cGVyKG5vZGVPck5ldygncG9seWdvbicsIG5vZGUpLCBub2RlKVxyXG4gIH1cclxufVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKHtcclxuICBDb250YWluZXI6IHtcclxuICAgIC8vIENyZWF0ZSBhIHdyYXBwZWQgcG9seWdvbiBlbGVtZW50XHJcbiAgICBwb2x5Z29uOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAocCkge1xyXG4gICAgICAvLyBtYWtlIHN1cmUgcGxvdCBpcyBjYWxsZWQgYXMgYSBzZXR0ZXJcclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBQb2x5Z29uKCkpLnBsb3QocCB8fCBuZXcgUG9pbnRBcnJheSgpKVxyXG4gICAgfSlcclxuICB9XHJcbn0pXHJcblxyXG5leHRlbmQoUG9seWdvbiwgcG9pbnRlZClcclxuZXh0ZW5kKFBvbHlnb24sIHBvbHkpXHJcbnJlZ2lzdGVyKFBvbHlnb24sICdQb2x5Z29uJylcclxuIiwiaW1wb3J0IHtcclxuICBleHRlbmQsXHJcbiAgbm9kZU9yTmV3LFxyXG4gIHJlZ2lzdGVyLFxyXG4gIHdyYXBXaXRoQXR0ckNoZWNrXHJcbn0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcclxuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcclxuaW1wb3J0IFBvaW50QXJyYXkgZnJvbSAnLi4vdHlwZXMvUG9pbnRBcnJheS5qcydcclxuaW1wb3J0IFNoYXBlIGZyb20gJy4vU2hhcGUuanMnXHJcbmltcG9ydCAqIGFzIHBvaW50ZWQgZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3BvaW50ZWQuanMnXHJcbmltcG9ydCAqIGFzIHBvbHkgZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3BvbHkuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2x5bGluZSBleHRlbmRzIFNoYXBlIHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjb25zdHJ1Y3RvciAobm9kZSkge1xyXG4gICAgc3VwZXIobm9kZU9yTmV3KCdwb2x5bGluZScsIG5vZGUpLCBub2RlKVxyXG4gIH1cclxufVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKHtcclxuICBDb250YWluZXI6IHtcclxuICAgIC8vIENyZWF0ZSBhIHdyYXBwZWQgcG9seWdvbiBlbGVtZW50XHJcbiAgICBwb2x5bGluZTogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHApIHtcclxuICAgICAgLy8gbWFrZSBzdXJlIHBsb3QgaXMgY2FsbGVkIGFzIGEgc2V0dGVyXHJcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgUG9seWxpbmUoKSkucGxvdChwIHx8IG5ldyBQb2ludEFycmF5KCkpXHJcbiAgICB9KVxyXG4gIH1cclxufSlcclxuXHJcbmV4dGVuZChQb2x5bGluZSwgcG9pbnRlZClcclxuZXh0ZW5kKFBvbHlsaW5lLCBwb2x5KVxyXG5yZWdpc3RlcihQb2x5bGluZSwgJ1BvbHlsaW5lJylcclxuIiwiaW1wb3J0IHtcclxuICBleHRlbmQsXHJcbiAgbm9kZU9yTmV3LFxyXG4gIHJlZ2lzdGVyLFxyXG4gIHdyYXBXaXRoQXR0ckNoZWNrXHJcbn0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcclxuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcclxuaW1wb3J0IHsgcngsIHJ5IH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL2NpcmNsZWQuanMnXHJcbmltcG9ydCBTaGFwZSBmcm9tICcuL1NoYXBlLmpzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjdCBleHRlbmRzIFNoYXBlIHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjb25zdHJ1Y3RvciAobm9kZSkge1xyXG4gICAgc3VwZXIobm9kZU9yTmV3KCdyZWN0Jywgbm9kZSksIG5vZGUpXHJcbiAgfVxyXG59XHJcblxyXG5leHRlbmQoUmVjdCwgeyByeCwgcnkgfSlcclxuXHJcbnJlZ2lzdGVyTWV0aG9kcyh7XHJcbiAgQ29udGFpbmVyOiB7XHJcbiAgICAvLyBDcmVhdGUgYSByZWN0IGVsZW1lbnRcclxuICAgIHJlY3Q6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgUmVjdCgpKS5zaXplKHdpZHRoLCBoZWlnaHQpXHJcbiAgICB9KVxyXG4gIH1cclxufSlcclxuXHJcbnJlZ2lzdGVyKFJlY3QsICdSZWN0JylcclxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHknKTtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0Jyk7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gMHgxRkZGRkZGRkZGRkZGRjtcbnZhciBNQVhJTVVNX0FMTE9XRURfTEVOR1RIX0VYQ0VFREVEID0gJ01heGltdW0gYWxsb3dlZCBsZW5ndGggZXhjZWVkZWQnO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnNwbGljZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc3BsaWNlXG4vLyB3aXRoIGFkZGluZyBzdXBwb3J0IG9mIEBAc3BlY2llc1xuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIWFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoJ3NwbGljZScpIH0sIHtcbiAgc3BsaWNlOiBmdW5jdGlvbiBzcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50IC8qICwgLi4uaXRlbXMgKi8pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBsZW4gPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGFjdHVhbFN0YXJ0ID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW4pO1xuICAgIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBpbnNlcnRDb3VudCwgYWN0dWFsRGVsZXRlQ291bnQsIEEsIGssIGZyb20sIHRvO1xuICAgIGlmIChhcmd1bWVudHNMZW5ndGggPT09IDApIHtcbiAgICAgIGluc2VydENvdW50ID0gYWN0dWFsRGVsZXRlQ291bnQgPSAwO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzTGVuZ3RoID09PSAxKSB7XG4gICAgICBpbnNlcnRDb3VudCA9IDA7XG4gICAgICBhY3R1YWxEZWxldGVDb3VudCA9IGxlbiAtIGFjdHVhbFN0YXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnNlcnRDb3VudCA9IGFyZ3VtZW50c0xlbmd0aCAtIDI7XG4gICAgICBhY3R1YWxEZWxldGVDb3VudCA9IG1pbihtYXgodG9JbnRlZ2VyKGRlbGV0ZUNvdW50KSwgMCksIGxlbiAtIGFjdHVhbFN0YXJ0KTtcbiAgICB9XG4gICAgaWYgKGxlbiArIGluc2VydENvdW50IC0gYWN0dWFsRGVsZXRlQ291bnQgPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoTUFYSU1VTV9BTExPV0VEX0xFTkdUSF9FWENFRURFRCk7XG4gICAgfVxuICAgIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgYWN0dWFsRGVsZXRlQ291bnQpO1xuICAgIGZvciAoayA9IDA7IGsgPCBhY3R1YWxEZWxldGVDb3VudDsgaysrKSB7XG4gICAgICBmcm9tID0gYWN0dWFsU3RhcnQgKyBrO1xuICAgICAgaWYgKGZyb20gaW4gTykgY3JlYXRlUHJvcGVydHkoQSwgaywgT1tmcm9tXSk7XG4gICAgfVxuICAgIEEubGVuZ3RoID0gYWN0dWFsRGVsZXRlQ291bnQ7XG4gICAgaWYgKGluc2VydENvdW50IDwgYWN0dWFsRGVsZXRlQ291bnQpIHtcbiAgICAgIGZvciAoayA9IGFjdHVhbFN0YXJ0OyBrIDwgbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQ7IGsrKykge1xuICAgICAgICBmcm9tID0gayArIGFjdHVhbERlbGV0ZUNvdW50O1xuICAgICAgICB0byA9IGsgKyBpbnNlcnRDb3VudDtcbiAgICAgICAgaWYgKGZyb20gaW4gTykgT1t0b10gPSBPW2Zyb21dO1xuICAgICAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICAgIH1cbiAgICAgIGZvciAoayA9IGxlbjsgayA+IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50ICsgaW5zZXJ0Q291bnQ7IGstLSkgZGVsZXRlIE9bayAtIDFdO1xuICAgIH0gZWxzZSBpZiAoaW5zZXJ0Q291bnQgPiBhY3R1YWxEZWxldGVDb3VudCkge1xuICAgICAgZm9yIChrID0gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQ7IGsgPiBhY3R1YWxTdGFydDsgay0tKSB7XG4gICAgICAgIGZyb20gPSBrICsgYWN0dWFsRGVsZXRlQ291bnQgLSAxO1xuICAgICAgICB0byA9IGsgKyBpbnNlcnRDb3VudCAtIDE7XG4gICAgICAgIGlmIChmcm9tIGluIE8pIE9bdG9dID0gT1tmcm9tXTtcbiAgICAgICAgZWxzZSBkZWxldGUgT1t0b107XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoayA9IDA7IGsgPCBpbnNlcnRDb3VudDsgaysrKSB7XG4gICAgICBPW2sgKyBhY3R1YWxTdGFydF0gPSBhcmd1bWVudHNbayArIDJdO1xuICAgIH1cbiAgICBPLmxlbmd0aCA9IGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50ICsgaW5zZXJ0Q291bnQ7XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgUXVldWUge1xyXG4gIGNvbnN0cnVjdG9yICgpIHtcclxuICAgIHRoaXMuX2ZpcnN0ID0gbnVsbFxyXG4gICAgdGhpcy5fbGFzdCA9IG51bGxcclxuICB9XHJcblxyXG4gIHB1c2ggKHZhbHVlKSB7XHJcbiAgICAvLyBBbiBpdGVtIHN0b3JlcyBhbiBpZCBhbmQgdGhlIHByb3ZpZGVkIHZhbHVlXHJcbiAgICB2YXIgaXRlbSA9IHZhbHVlLm5leHQgPyB2YWx1ZSA6IHsgdmFsdWU6IHZhbHVlLCBuZXh0OiBudWxsLCBwcmV2OiBudWxsIH1cclxuXHJcbiAgICAvLyBEZWFsIHdpdGggdGhlIHF1ZXVlIGJlaW5nIGVtcHR5IG9yIHBvcHVsYXRlZFxyXG4gICAgaWYgKHRoaXMuX2xhc3QpIHtcclxuICAgICAgaXRlbS5wcmV2ID0gdGhpcy5fbGFzdFxyXG4gICAgICB0aGlzLl9sYXN0Lm5leHQgPSBpdGVtXHJcbiAgICAgIHRoaXMuX2xhc3QgPSBpdGVtXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9sYXN0ID0gaXRlbVxyXG4gICAgICB0aGlzLl9maXJzdCA9IGl0ZW1cclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXR1cm4gdGhlIGN1cnJlbnQgaXRlbVxyXG4gICAgcmV0dXJuIGl0ZW1cclxuICB9XHJcblxyXG4gIHNoaWZ0ICgpIHtcclxuICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgYSB2YWx1ZVxyXG4gICAgdmFyIHJlbW92ZSA9IHRoaXMuX2ZpcnN0XHJcbiAgICBpZiAoIXJlbW92ZSkgcmV0dXJuIG51bGxcclxuXHJcbiAgICAvLyBJZiB3ZSBkbywgcmVtb3ZlIGl0IGFuZCByZWxpbmsgdGhpbmdzXHJcbiAgICB0aGlzLl9maXJzdCA9IHJlbW92ZS5uZXh0XHJcbiAgICBpZiAodGhpcy5fZmlyc3QpIHRoaXMuX2ZpcnN0LnByZXYgPSBudWxsXHJcbiAgICB0aGlzLl9sYXN0ID0gdGhpcy5fZmlyc3QgPyB0aGlzLl9sYXN0IDogbnVsbFxyXG4gICAgcmV0dXJuIHJlbW92ZS52YWx1ZVxyXG4gIH1cclxuXHJcbiAgLy8gU2hvd3MgdXMgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3RcclxuICBmaXJzdCAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZmlyc3QgJiYgdGhpcy5fZmlyc3QudmFsdWVcclxuICB9XHJcblxyXG4gIC8vIFNob3dzIHVzIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIGxpc3RcclxuICBsYXN0ICgpIHtcclxuICAgIHJldHVybiB0aGlzLl9sYXN0ICYmIHRoaXMuX2xhc3QudmFsdWVcclxuICB9XHJcblxyXG4gIC8vIFJlbW92ZXMgdGhlIGl0ZW0gdGhhdCB3YXMgcmV0dXJuZWQgZnJvbSB0aGUgcHVzaFxyXG4gIHJlbW92ZSAoaXRlbSkge1xyXG4gICAgLy8gUmVsaW5rIHRoZSBwcmV2aW91cyBpdGVtXHJcbiAgICBpZiAoaXRlbS5wcmV2KSBpdGVtLnByZXYubmV4dCA9IGl0ZW0ubmV4dFxyXG4gICAgaWYgKGl0ZW0ubmV4dCkgaXRlbS5uZXh0LnByZXYgPSBpdGVtLnByZXZcclxuICAgIGlmIChpdGVtID09PSB0aGlzLl9sYXN0KSB0aGlzLl9sYXN0ID0gaXRlbS5wcmV2XHJcbiAgICBpZiAoaXRlbSA9PT0gdGhpcy5fZmlyc3QpIHRoaXMuX2ZpcnN0ID0gaXRlbS5uZXh0XHJcblxyXG4gICAgLy8gSW52YWxpZGF0ZSBpdGVtXHJcbiAgICBpdGVtLnByZXYgPSBudWxsXHJcbiAgICBpdGVtLm5leHQgPSBudWxsXHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuLi91dGlscy93aW5kb3cuanMnXHJcbmltcG9ydCBRdWV1ZSBmcm9tICcuL1F1ZXVlLmpzJ1xyXG5cclxuY29uc3QgQW5pbWF0b3IgPSB7XHJcbiAgbmV4dERyYXc6IG51bGwsXHJcbiAgZnJhbWVzOiBuZXcgUXVldWUoKSxcclxuICB0aW1lb3V0czogbmV3IFF1ZXVlKCksXHJcbiAgaW1tZWRpYXRlczogbmV3IFF1ZXVlKCksXHJcbiAgdGltZXI6ICgpID0+IGdsb2JhbHMud2luZG93LnBlcmZvcm1hbmNlIHx8IGdsb2JhbHMud2luZG93LkRhdGUsXHJcbiAgdHJhbnNmb3JtczogW10sXHJcblxyXG4gIGZyYW1lIChmbikge1xyXG4gICAgLy8gU3RvcmUgdGhlIG5vZGVcclxuICAgIHZhciBub2RlID0gQW5pbWF0b3IuZnJhbWVzLnB1c2goeyBydW46IGZuIH0pXHJcblxyXG4gICAgLy8gUmVxdWVzdCBhbiBhbmltYXRpb24gZnJhbWUgaWYgd2UgZG9uJ3QgaGF2ZSBvbmVcclxuICAgIGlmIChBbmltYXRvci5uZXh0RHJhdyA9PT0gbnVsbCkge1xyXG4gICAgICBBbmltYXRvci5uZXh0RHJhdyA9IGdsb2JhbHMud2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShBbmltYXRvci5fZHJhdylcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXR1cm4gdGhlIG5vZGUgc28gd2UgY2FuIHJlbW92ZSBpdCBlYXNpbHlcclxuICAgIHJldHVybiBub2RlXHJcbiAgfSxcclxuXHJcbiAgdGltZW91dCAoZm4sIGRlbGF5KSB7XHJcbiAgICBkZWxheSA9IGRlbGF5IHx8IDBcclxuXHJcbiAgICAvLyBXb3JrIG91dCB3aGVuIHRoZSBldmVudCBzaG91bGQgZmlyZVxyXG4gICAgdmFyIHRpbWUgPSBBbmltYXRvci50aW1lcigpLm5vdygpICsgZGVsYXlcclxuXHJcbiAgICAvLyBBZGQgdGhlIHRpbWVvdXQgdG8gdGhlIGVuZCBvZiB0aGUgcXVldWVcclxuICAgIHZhciBub2RlID0gQW5pbWF0b3IudGltZW91dHMucHVzaCh7IHJ1bjogZm4sIHRpbWU6IHRpbWUgfSlcclxuXHJcbiAgICAvLyBSZXF1ZXN0IGFub3RoZXIgYW5pbWF0aW9uIGZyYW1lIGlmIHdlIG5lZWQgb25lXHJcbiAgICBpZiAoQW5pbWF0b3IubmV4dERyYXcgPT09IG51bGwpIHtcclxuICAgICAgQW5pbWF0b3IubmV4dERyYXcgPSBnbG9iYWxzLndpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoQW5pbWF0b3IuX2RyYXcpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5vZGVcclxuICB9LFxyXG5cclxuICBpbW1lZGlhdGUgKGZuKSB7XHJcbiAgICAvLyBBZGQgdGhlIGltbWVkaWF0ZSBmbiB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxyXG4gICAgdmFyIG5vZGUgPSBBbmltYXRvci5pbW1lZGlhdGVzLnB1c2goZm4pXHJcbiAgICAvLyBSZXF1ZXN0IGFub3RoZXIgYW5pbWF0aW9uIGZyYW1lIGlmIHdlIG5lZWQgb25lXHJcbiAgICBpZiAoQW5pbWF0b3IubmV4dERyYXcgPT09IG51bGwpIHtcclxuICAgICAgQW5pbWF0b3IubmV4dERyYXcgPSBnbG9iYWxzLndpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoQW5pbWF0b3IuX2RyYXcpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5vZGVcclxuICB9LFxyXG5cclxuICBjYW5jZWxGcmFtZSAobm9kZSkge1xyXG4gICAgbm9kZSAhPSBudWxsICYmIEFuaW1hdG9yLmZyYW1lcy5yZW1vdmUobm9kZSlcclxuICB9LFxyXG5cclxuICBjbGVhclRpbWVvdXQgKG5vZGUpIHtcclxuICAgIG5vZGUgIT0gbnVsbCAmJiBBbmltYXRvci50aW1lb3V0cy5yZW1vdmUobm9kZSlcclxuICB9LFxyXG5cclxuICBjYW5jZWxJbW1lZGlhdGUgKG5vZGUpIHtcclxuICAgIG5vZGUgIT0gbnVsbCAmJiBBbmltYXRvci5pbW1lZGlhdGVzLnJlbW92ZShub2RlKVxyXG4gIH0sXHJcblxyXG4gIF9kcmF3IChub3cpIHtcclxuICAgIC8vIFJ1biBhbGwgdGhlIHRpbWVvdXRzIHdlIGNhbiBydW4sIGlmIHRoZXkgYXJlIG5vdCByZWFkeSB5ZXQsIGFkZCB0aGVtXHJcbiAgICAvLyB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZSBpbW1lZGlhdGVseSEgKGJhZCB0aW1lb3V0cyEhISBbc2FyY2FzbV0pXHJcbiAgICB2YXIgbmV4dFRpbWVvdXQgPSBudWxsXHJcbiAgICB2YXIgbGFzdFRpbWVvdXQgPSBBbmltYXRvci50aW1lb3V0cy5sYXN0KClcclxuICAgIHdoaWxlICgobmV4dFRpbWVvdXQgPSBBbmltYXRvci50aW1lb3V0cy5zaGlmdCgpKSkge1xyXG4gICAgICAvLyBSdW4gdGhlIHRpbWVvdXQgaWYgaXRzIHRpbWUsIG9yIHB1c2ggaXQgdG8gdGhlIGVuZFxyXG4gICAgICBpZiAobm93ID49IG5leHRUaW1lb3V0LnRpbWUpIHtcclxuICAgICAgICBuZXh0VGltZW91dC5ydW4oKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIEFuaW1hdG9yLnRpbWVvdXRzLnB1c2gobmV4dFRpbWVvdXQpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIElmIHdlIGhpdCB0aGUgbGFzdCBpdGVtLCB3ZSBzaG91bGQgc3RvcCBzaGlmdGluZyBvdXQgbW9yZSBpdGVtc1xyXG4gICAgICBpZiAobmV4dFRpbWVvdXQgPT09IGxhc3RUaW1lb3V0KSBicmVha1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJ1biBhbGwgb2YgdGhlIGFuaW1hdGlvbiBmcmFtZXNcclxuICAgIHZhciBuZXh0RnJhbWUgPSBudWxsXHJcbiAgICB2YXIgbGFzdEZyYW1lID0gQW5pbWF0b3IuZnJhbWVzLmxhc3QoKVxyXG4gICAgd2hpbGUgKChuZXh0RnJhbWUgIT09IGxhc3RGcmFtZSkgJiYgKG5leHRGcmFtZSA9IEFuaW1hdG9yLmZyYW1lcy5zaGlmdCgpKSkge1xyXG4gICAgICBuZXh0RnJhbWUucnVuKG5vdylcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbmV4dEltbWVkaWF0ZSA9IG51bGxcclxuICAgIHdoaWxlICgobmV4dEltbWVkaWF0ZSA9IEFuaW1hdG9yLmltbWVkaWF0ZXMuc2hpZnQoKSkpIHtcclxuICAgICAgbmV4dEltbWVkaWF0ZSgpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgd2UgaGF2ZSByZW1haW5pbmcgdGltZW91dHMgb3IgZnJhbWVzLCBkcmF3IHVudGlsIHdlIGRvbid0IGFueW1vcmVcclxuICAgIEFuaW1hdG9yLm5leHREcmF3ID0gQW5pbWF0b3IudGltZW91dHMuZmlyc3QoKSB8fCBBbmltYXRvci5mcmFtZXMuZmlyc3QoKVxyXG4gICAgICA/IGdsb2JhbHMud2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShBbmltYXRvci5fZHJhdylcclxuICAgICAgOiBudWxsXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBbmltYXRvclxyXG4iLCJpbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi4vdXRpbHMvd2luZG93LmpzJ1xyXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xyXG5pbXBvcnQgQW5pbWF0b3IgZnJvbSAnLi9BbmltYXRvci5qcydcclxuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4uL3R5cGVzL0V2ZW50VGFyZ2V0LmpzJ1xyXG5cclxudmFyIG1ha2VTY2hlZHVsZSA9IGZ1bmN0aW9uIChydW5uZXJJbmZvKSB7XHJcbiAgdmFyIHN0YXJ0ID0gcnVubmVySW5mby5zdGFydFxyXG4gIHZhciBkdXJhdGlvbiA9IHJ1bm5lckluZm8ucnVubmVyLmR1cmF0aW9uKClcclxuICB2YXIgZW5kID0gc3RhcnQgKyBkdXJhdGlvblxyXG4gIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZHVyYXRpb246IGR1cmF0aW9uLCBlbmQ6IGVuZCwgcnVubmVyOiBydW5uZXJJbmZvLnJ1bm5lciB9XHJcbn1cclxuXHJcbmNvbnN0IGRlZmF1bHRTb3VyY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgY29uc3QgdyA9IGdsb2JhbHMud2luZG93XHJcbiAgcmV0dXJuICh3LnBlcmZvcm1hbmNlIHx8IHcuRGF0ZSkubm93KClcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZWxpbmUgZXh0ZW5kcyBFdmVudFRhcmdldCB7XHJcbiAgLy8gQ29uc3RydWN0IGEgbmV3IHRpbWVsaW5lIG9uIHRoZSBnaXZlbiBlbGVtZW50XHJcbiAgY29uc3RydWN0b3IgKHRpbWVTb3VyY2UgPSBkZWZhdWx0U291cmNlKSB7XHJcbiAgICBzdXBlcigpXHJcblxyXG4gICAgdGhpcy5fdGltZVNvdXJjZSA9IHRpbWVTb3VyY2VcclxuXHJcbiAgICAvLyBTdG9yZSB0aGUgdGltaW5nIHZhcmlhYmxlc1xyXG4gICAgdGhpcy5fc3RhcnRUaW1lID0gMFxyXG4gICAgdGhpcy5fc3BlZWQgPSAxLjBcclxuXHJcbiAgICAvLyBEZXRlcm1pbmVzIGhvdyBsb25nIGEgcnVubmVyIGlzIGhvbGQgaW4gbWVtb3J5LiBDYW4gYmUgYSBkdCBvciB0cnVlL2ZhbHNlXHJcbiAgICB0aGlzLl9wZXJzaXN0ID0gMFxyXG5cclxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIHJ1bm5pbmcgYW5pbWF0aW9ucyBhbmQgdGhlaXIgc3RhcnRpbmcgcGFyYW1ldGVyc1xyXG4gICAgdGhpcy5fbmV4dEZyYW1lID0gbnVsbFxyXG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZVxyXG4gICAgdGhpcy5fcnVubmVycyA9IFtdXHJcbiAgICB0aGlzLl9ydW5uZXJJZHMgPSBbXVxyXG4gICAgdGhpcy5fbGFzdFJ1bm5lcklkID0gLTFcclxuICAgIHRoaXMuX3RpbWUgPSAwXHJcbiAgICB0aGlzLl9sYXN0U291cmNlVGltZSA9IDBcclxuICAgIHRoaXMuX2xhc3RTdGVwVGltZSA9IDBcclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgdGhhdCBzdGVwIGlzIGFsd2F5cyBjYWxsZWQgaW4gY2xhc3MgY29udGV4dFxyXG4gICAgdGhpcy5fc3RlcCA9IHRoaXMuX3N0ZXBGbi5iaW5kKHRoaXMsIGZhbHNlKVxyXG4gICAgdGhpcy5fc3RlcEltbWVkaWF0ZSA9IHRoaXMuX3N0ZXBGbi5iaW5kKHRoaXMsIHRydWUpXHJcbiAgfVxyXG5cclxuICAvLyBzY2hlZHVsZXMgYSBydW5uZXIgb24gdGhlIHRpbWVsaW5lXHJcbiAgc2NoZWR1bGUgKHJ1bm5lciwgZGVsYXksIHdoZW4pIHtcclxuICAgIGlmIChydW5uZXIgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fcnVubmVycy5tYXAobWFrZVNjaGVkdWxlKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZSBzdGFydCB0aW1lIGZvciB0aGUgbmV4dCBhbmltYXRpb24gY2FuIGVpdGhlciBiZSBnaXZlbiBleHBsaWNpdGx5LFxyXG4gICAgLy8gZGVyaXZlZCBmcm9tIHRoZSBjdXJyZW50IHRpbWVsaW5lIHRpbWUgb3IgaXQgY2FuIGJlIHJlbGF0aXZlIHRvIHRoZVxyXG4gICAgLy8gbGFzdCBzdGFydCB0aW1lIHRvIGNoYWluIGFuaW1hdGlvbnMgZGlyZWNsdHlcclxuXHJcbiAgICB2YXIgYWJzb2x1dGVTdGFydFRpbWUgPSAwXHJcbiAgICB2YXIgZW5kVGltZSA9IHRoaXMuZ2V0RW5kVGltZSgpXHJcbiAgICBkZWxheSA9IGRlbGF5IHx8IDBcclxuXHJcbiAgICAvLyBXb3JrIG91dCB3aGVuIHRvIHN0YXJ0IHRoZSBhbmltYXRpb25cclxuICAgIGlmICh3aGVuID09IG51bGwgfHwgd2hlbiA9PT0gJ2xhc3QnIHx8IHdoZW4gPT09ICdhZnRlcicpIHtcclxuICAgICAgLy8gVGFrZSB0aGUgbGFzdCB0aW1lIGFuZCBpbmNyZW1lbnRcclxuICAgICAgYWJzb2x1dGVTdGFydFRpbWUgPSBlbmRUaW1lXHJcbiAgICB9IGVsc2UgaWYgKHdoZW4gPT09ICdhYnNvbHV0ZScgfHwgd2hlbiA9PT0gJ3N0YXJ0Jykge1xyXG4gICAgICBhYnNvbHV0ZVN0YXJ0VGltZSA9IGRlbGF5XHJcbiAgICAgIGRlbGF5ID0gMFxyXG4gICAgfSBlbHNlIGlmICh3aGVuID09PSAnbm93Jykge1xyXG4gICAgICBhYnNvbHV0ZVN0YXJ0VGltZSA9IHRoaXMuX3RpbWVcclxuICAgIH0gZWxzZSBpZiAod2hlbiA9PT0gJ3JlbGF0aXZlJykge1xyXG4gICAgICBjb25zdCBydW5uZXJJbmZvID0gdGhpcy5fcnVubmVyc1tydW5uZXIuaWRdXHJcbiAgICAgIGlmIChydW5uZXJJbmZvKSB7XHJcbiAgICAgICAgYWJzb2x1dGVTdGFydFRpbWUgPSBydW5uZXJJbmZvLnN0YXJ0ICsgZGVsYXlcclxuICAgICAgICBkZWxheSA9IDBcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciB0aGUgXCJ3aGVuXCIgcGFyYW1ldGVyJylcclxuICAgIH1cclxuXHJcbiAgICAvLyBNYW5hZ2UgcnVubmVyXHJcbiAgICBydW5uZXIudW5zY2hlZHVsZSgpXHJcbiAgICBydW5uZXIudGltZWxpbmUodGhpcylcclxuXHJcbiAgICBjb25zdCBwZXJzaXN0ID0gcnVubmVyLnBlcnNpc3QoKVxyXG4gICAgY29uc3QgcnVubmVySW5mbyA9IHtcclxuICAgICAgcGVyc2lzdDogcGVyc2lzdCA9PT0gbnVsbCA/IHRoaXMuX3BlcnNpc3QgOiBwZXJzaXN0LFxyXG4gICAgICBzdGFydDogYWJzb2x1dGVTdGFydFRpbWUgKyBkZWxheSxcclxuICAgICAgcnVubmVyXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fbGFzdFJ1bm5lcklkID0gcnVubmVyLmlkXHJcblxyXG4gICAgdGhpcy5fcnVubmVycy5wdXNoKHJ1bm5lckluZm8pXHJcbiAgICB0aGlzLl9ydW5uZXJzLnNvcnQoKGEsIGIpID0+IGEuc3RhcnQgLSBiLnN0YXJ0KVxyXG4gICAgdGhpcy5fcnVubmVySWRzID0gdGhpcy5fcnVubmVycy5tYXAoaW5mbyA9PiBpbmZvLnJ1bm5lci5pZClcclxuXHJcbiAgICB0aGlzLnVwZGF0ZVRpbWUoKS5fY29udGludWUoKVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8vIFJlbW92ZSB0aGUgcnVubmVyIGZyb20gdGhpcyB0aW1lbGluZVxyXG4gIHVuc2NoZWR1bGUgKHJ1bm5lcikge1xyXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fcnVubmVySWRzLmluZGV4T2YocnVubmVyLmlkKVxyXG4gICAgaWYgKGluZGV4IDwgMCkgcmV0dXJuIHRoaXNcclxuXHJcbiAgICB0aGlzLl9ydW5uZXJzLnNwbGljZShpbmRleCwgMSlcclxuICAgIHRoaXMuX3J1bm5lcklkcy5zcGxpY2UoaW5kZXgsIDEpXHJcblxyXG4gICAgcnVubmVyLnRpbWVsaW5lKG51bGwpXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgLy8gQ2FsY3VsYXRlcyB0aGUgZW5kIG9mIHRoZSB0aW1lbGluZVxyXG4gIGdldEVuZFRpbWUgKCkge1xyXG4gICAgdmFyIGxhc3RSdW5uZXJJbmZvID0gdGhpcy5fcnVubmVyc1t0aGlzLl9ydW5uZXJJZHMuaW5kZXhPZih0aGlzLl9sYXN0UnVubmVySWQpXVxyXG4gICAgdmFyIGxhc3REdXJhdGlvbiA9IGxhc3RSdW5uZXJJbmZvID8gbGFzdFJ1bm5lckluZm8ucnVubmVyLmR1cmF0aW9uKCkgOiAwXHJcbiAgICB2YXIgbGFzdFN0YXJ0VGltZSA9IGxhc3RSdW5uZXJJbmZvID8gbGFzdFJ1bm5lckluZm8uc3RhcnQgOiAwXHJcbiAgICByZXR1cm4gbGFzdFN0YXJ0VGltZSArIGxhc3REdXJhdGlvblxyXG4gIH1cclxuXHJcbiAgZ2V0RW5kVGltZU9mVGltZWxpbmUgKCkge1xyXG4gICAgbGV0IGxhc3RFbmRUaW1lID0gMFxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ydW5uZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHJ1bm5lckluZm8gPSB0aGlzLl9ydW5uZXJzW2ldXHJcbiAgICAgIHZhciBkdXJhdGlvbiA9IHJ1bm5lckluZm8gPyBydW5uZXJJbmZvLnJ1bm5lci5kdXJhdGlvbigpIDogMFxyXG4gICAgICB2YXIgc3RhcnRUaW1lID0gcnVubmVySW5mbyA/IHJ1bm5lckluZm8uc3RhcnQgOiAwXHJcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBzdGFydFRpbWUgKyBkdXJhdGlvblxyXG4gICAgICBpZiAoZW5kVGltZSA+IGxhc3RFbmRUaW1lKSB7XHJcbiAgICAgICAgbGFzdEVuZFRpbWUgPSBlbmRUaW1lXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBsYXN0RW5kVGltZVxyXG4gIH1cclxuXHJcbiAgLy8gTWFrZXMgc3VyZSwgdGhhdCBhZnRlciBwYXVzaW5nIHRoZSB0aW1lIGRvZXNuJ3QganVtcFxyXG4gIHVwZGF0ZVRpbWUgKCkge1xyXG4gICAgaWYgKCF0aGlzLmFjdGl2ZSgpKSB7XHJcbiAgICAgIHRoaXMuX2xhc3RTb3VyY2VUaW1lID0gdGhpcy5fdGltZVNvdXJjZSgpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgcGxheSAoKSB7XHJcbiAgICAvLyBOb3cgbWFrZSBzdXJlIHdlIGFyZSBub3QgcGF1c2VkIGFuZCBjb250aW51ZSB0aGUgYW5pbWF0aW9uXHJcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZVxyXG4gICAgcmV0dXJuIHRoaXMudXBkYXRlVGltZSgpLl9jb250aW51ZSgpXHJcbiAgfVxyXG5cclxuICBwYXVzZSAoKSB7XHJcbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlXHJcbiAgICByZXR1cm4gdGhpcy5fY29udGludWUoKVxyXG4gIH1cclxuXHJcbiAgc3RvcCAoKSB7XHJcbiAgICAvLyBHbyB0byBzdGFydCBhbmQgcGF1c2VcclxuICAgIHRoaXMudGltZSgwKVxyXG4gICAgcmV0dXJuIHRoaXMucGF1c2UoKVxyXG4gIH1cclxuXHJcbiAgZmluaXNoICgpIHtcclxuICAgIC8vIEdvIHRvIGVuZCBhbmQgcGF1c2VcclxuICAgIHRoaXMudGltZSh0aGlzLmdldEVuZFRpbWVPZlRpbWVsaW5lKCkgKyAxKVxyXG4gICAgcmV0dXJuIHRoaXMucGF1c2UoKVxyXG4gIH1cclxuXHJcbiAgc3BlZWQgKHNwZWVkKSB7XHJcbiAgICBpZiAoc3BlZWQgPT0gbnVsbCkgcmV0dXJuIHRoaXMuX3NwZWVkXHJcbiAgICB0aGlzLl9zcGVlZCA9IHNwZWVkXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgcmV2ZXJzZSAoeWVzKSB7XHJcbiAgICB2YXIgY3VycmVudFNwZWVkID0gdGhpcy5zcGVlZCgpXHJcbiAgICBpZiAoeWVzID09IG51bGwpIHJldHVybiB0aGlzLnNwZWVkKC1jdXJyZW50U3BlZWQpXHJcblxyXG4gICAgdmFyIHBvc2l0aXZlID0gTWF0aC5hYnMoY3VycmVudFNwZWVkKVxyXG4gICAgcmV0dXJuIHRoaXMuc3BlZWQoeWVzID8gcG9zaXRpdmUgOiAtcG9zaXRpdmUpXHJcbiAgfVxyXG5cclxuICBzZWVrIChkdCkge1xyXG4gICAgcmV0dXJuIHRoaXMudGltZSh0aGlzLl90aW1lICsgZHQpXHJcbiAgfVxyXG5cclxuICB0aW1lICh0aW1lKSB7XHJcbiAgICBpZiAodGltZSA9PSBudWxsKSByZXR1cm4gdGhpcy5fdGltZVxyXG4gICAgdGhpcy5fdGltZSA9IHRpbWVcclxuICAgIHJldHVybiB0aGlzLl9jb250aW51ZSh0cnVlKVxyXG4gIH1cclxuXHJcbiAgcGVyc2lzdCAoZHRPckZvcmV2ZXIpIHtcclxuICAgIGlmIChkdE9yRm9yZXZlciA9PSBudWxsKSByZXR1cm4gdGhpcy5fcGVyc2lzdFxyXG4gICAgdGhpcy5fcGVyc2lzdCA9IGR0T3JGb3JldmVyXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgc291cmNlIChmbikge1xyXG4gICAgaWYgKGZuID09IG51bGwpIHJldHVybiB0aGlzLl90aW1lU291cmNlXHJcbiAgICB0aGlzLl90aW1lU291cmNlID0gZm5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICBfc3RlcEZuIChpbW1lZGlhdGVTdGVwID0gZmFsc2UpIHtcclxuICAgIC8vIEdldCB0aGUgdGltZSBkZWx0YSBmcm9tIHRoZSBsYXN0IHRpbWUgYW5kIHVwZGF0ZSB0aGUgdGltZVxyXG4gICAgdmFyIHRpbWUgPSB0aGlzLl90aW1lU291cmNlKClcclxuICAgIHZhciBkdFNvdXJjZSA9IHRpbWUgLSB0aGlzLl9sYXN0U291cmNlVGltZVxyXG5cclxuICAgIGlmIChpbW1lZGlhdGVTdGVwKSBkdFNvdXJjZSA9IDBcclxuXHJcbiAgICB2YXIgZHRUaW1lID0gdGhpcy5fc3BlZWQgKiBkdFNvdXJjZSArICh0aGlzLl90aW1lIC0gdGhpcy5fbGFzdFN0ZXBUaW1lKVxyXG4gICAgdGhpcy5fbGFzdFNvdXJjZVRpbWUgPSB0aW1lXHJcblxyXG4gICAgLy8gT25seSB1cGRhdGUgdGhlIHRpbWUgaWYgd2UgdXNlIHRoZSB0aW1lU291cmNlLlxyXG4gICAgLy8gT3RoZXJ3aXNlIHVzZSB0aGUgY3VycmVudCB0aW1lXHJcbiAgICBpZiAoIWltbWVkaWF0ZVN0ZXApIHtcclxuICAgICAgLy8gVXBkYXRlIHRoZSB0aW1lXHJcbiAgICAgIHRoaXMuX3RpbWUgKz0gZHRUaW1lXHJcbiAgICAgIHRoaXMuX3RpbWUgPSB0aGlzLl90aW1lIDwgMCA/IDAgOiB0aGlzLl90aW1lXHJcbiAgICB9XHJcbiAgICB0aGlzLl9sYXN0U3RlcFRpbWUgPSB0aGlzLl90aW1lXHJcbiAgICB0aGlzLmZpcmUoJ3RpbWUnLCB0aGlzLl90aW1lKVxyXG5cclxuICAgIC8vIFRoaXMgaXMgZm9yIHRoZSBjYXNlIHRoYXQgdGhlIHRpbWVsaW5lIHdhcyBzZWVrZWQgc28gdGhhdCB0aGUgdGltZVxyXG4gICAgLy8gaXMgbm93IGJlZm9yZSB0aGUgc3RhcnRUaW1lIG9mIHRoZSBydW5uZXIuIFRoYXRzIHdoeSB3ZSBuZWVkIHRvIHNldFxyXG4gICAgLy8gdGhlIHJ1bm5lciB0byBwb3NpdGlvbiAwXHJcblxyXG4gICAgLy8gRklYTUU6XHJcbiAgICAvLyBIb3dldmVyLCByZXNldGluZyBpbiBpbnNlcnRpb24gb3JkZXIgbGVhZHMgdG8gYnVncy4gQ29uc2lkZXJpbmcgdGhlIGNhc2UsXHJcbiAgICAvLyB3aGVyZSAyIHJ1bm5lcnMgY2hhbmdlIHRoZSBzYW1lIGF0dHJpdXRlIGJ1dCBpbiBkaWZmZXJlbnQgdGltZXMsXHJcbiAgICAvLyByZXNldGluZyBib3RoIG9mIHRoZW0gd2lsbCBsZWFkIHRvIHRoZSBjYXNlIHdoZXJlIHRoZSBsYXRlciBkZWZpbmVkXHJcbiAgICAvLyBydW5uZXIgYWx3YXlzIHdpbnMgdGhlIHJlc2V0IGV2ZW4gaWYgdGhlIG90aGVyIHJ1bm5lciBzdGFydGVkIGVhcmxpZXJcclxuICAgIC8vIGFuZCB0aGVyZWZvcmUgc2hvdWxkIHdpbiB0aGUgYXR0cmlidXRlIGJhdHRsZVxyXG4gICAgLy8gdGhpcyBjYW4gYmUgc29sdmVkIGJ5IHJlc2V0aW5nIHRoZW0gYmFja3dhcmRzXHJcbiAgICBmb3IgKHZhciBrID0gdGhpcy5fcnVubmVycy5sZW5ndGg7IGstLTspIHtcclxuICAgICAgLy8gR2V0IGFuZCBydW4gdGhlIGN1cnJlbnQgcnVubmVyIGFuZCBpZ25vcmUgaXQgaWYgaXRzIGluYWN0aXZlXHJcbiAgICAgIGNvbnN0IHJ1bm5lckluZm8gPSB0aGlzLl9ydW5uZXJzW2tdXHJcbiAgICAgIGNvbnN0IHJ1bm5lciA9IHJ1bm5lckluZm8ucnVubmVyXHJcblxyXG4gICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSBnaXZlIHRoZSBhY3R1YWwgZGlmZmVyZW5jZVxyXG4gICAgICAvLyBiZXR3ZWVuIHJ1bm5lciBzdGFydCB0aW1lIGFuZCBub3dcclxuICAgICAgY29uc3QgZHRUb1N0YXJ0ID0gdGhpcy5fdGltZSAtIHJ1bm5lckluZm8uc3RhcnRcclxuXHJcbiAgICAgIC8vIERvbnQgcnVuIHJ1bm5lciBpZiBub3Qgc3RhcnRlZCB5ZXRcclxuICAgICAgLy8gYW5kIHRyeSB0byByZXNldCBpdFxyXG4gICAgICBpZiAoZHRUb1N0YXJ0IDw9IDApIHtcclxuICAgICAgICBydW5uZXIucmVzZXQoKVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUnVuIGFsbCBvZiB0aGUgcnVubmVycyBkaXJlY3RseVxyXG4gICAgdmFyIHJ1bm5lcnNMZWZ0ID0gZmFsc2VcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9ydW5uZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIC8vIEdldCBhbmQgcnVuIHRoZSBjdXJyZW50IHJ1bm5lciBhbmQgaWdub3JlIGl0IGlmIGl0cyBpbmFjdGl2ZVxyXG4gICAgICBjb25zdCBydW5uZXJJbmZvID0gdGhpcy5fcnVubmVyc1tpXVxyXG4gICAgICBjb25zdCBydW5uZXIgPSBydW5uZXJJbmZvLnJ1bm5lclxyXG4gICAgICBsZXQgZHQgPSBkdFRpbWVcclxuXHJcbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGdpdmUgdGhlIGFjdHVhbCBkaWZmZXJlbmNlXHJcbiAgICAgIC8vIGJldHdlZW4gcnVubmVyIHN0YXJ0IHRpbWUgYW5kIG5vd1xyXG4gICAgICBjb25zdCBkdFRvU3RhcnQgPSB0aGlzLl90aW1lIC0gcnVubmVySW5mby5zdGFydFxyXG5cclxuICAgICAgLy8gRG9udCBydW4gcnVubmVyIGlmIG5vdCBzdGFydGVkIHlldFxyXG4gICAgICBpZiAoZHRUb1N0YXJ0IDw9IDApIHtcclxuICAgICAgICBydW5uZXJzTGVmdCA9IHRydWVcclxuICAgICAgICBjb250aW51ZVxyXG4gICAgICB9IGVsc2UgaWYgKGR0VG9TdGFydCA8IGR0KSB7XHJcbiAgICAgICAgLy8gQWRqdXN0IGR0IHRvIG1ha2Ugc3VyZSB0aGF0IGFuaW1hdGlvbiBpcyBvbiBwb2ludFxyXG4gICAgICAgIGR0ID0gZHRUb1N0YXJ0XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghcnVubmVyLmFjdGl2ZSgpKSBjb250aW51ZVxyXG5cclxuICAgICAgLy8gSWYgdGhpcyBydW5uZXIgaXMgc3RpbGwgZ29pbmcsIHNpZ25hbCB0aGF0IHdlIG5lZWQgYW5vdGhlciBhbmltYXRpb25cclxuICAgICAgLy8gZnJhbWUsIG90aGVyd2lzZSwgcmVtb3ZlIHRoZSBjb21wbGV0ZWQgcnVubmVyXHJcbiAgICAgIHZhciBmaW5pc2hlZCA9IHJ1bm5lci5zdGVwKGR0KS5kb25lXHJcbiAgICAgIGlmICghZmluaXNoZWQpIHtcclxuICAgICAgICBydW5uZXJzTGVmdCA9IHRydWVcclxuICAgICAgICAvLyBjb250aW51ZVxyXG4gICAgICB9IGVsc2UgaWYgKHJ1bm5lckluZm8ucGVyc2lzdCAhPT0gdHJ1ZSkge1xyXG4gICAgICAgIC8vIHJ1bm5lciBpcyBmaW5pc2hlZC4gQW5kIHJ1bm5lciBtaWdodCBnZXQgcmVtb3ZlZFxyXG4gICAgICAgIHZhciBlbmRUaW1lID0gcnVubmVyLmR1cmF0aW9uKCkgLSBydW5uZXIudGltZSgpICsgdGhpcy5fdGltZVxyXG5cclxuICAgICAgICBpZiAoZW5kVGltZSArIHJ1bm5lckluZm8ucGVyc2lzdCA8IHRoaXMuX3RpbWUpIHtcclxuICAgICAgICAgIC8vIERlbGV0ZSBydW5uZXIgYW5kIGNvcnJlY3QgaW5kZXhcclxuICAgICAgICAgIHJ1bm5lci51bnNjaGVkdWxlKClcclxuICAgICAgICAgIC0taVxyXG4gICAgICAgICAgLS1sZW5cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBCYXNpY2FsbHk6IHdlIGNvbnRpbnVlIHdoZW4gdGhlcmUgYXJlIHJ1bm5lcnMgcmlnaHQgZnJvbSB1cyBpbiB0aW1lXHJcbiAgICAvLyB3aGVuIC0tPiwgYW5kIHdoZW4gcnVubmVycyBhcmUgbGVmdCBmcm9tIHVzIHdoZW4gPC0tXHJcbiAgICBpZiAoKHJ1bm5lcnNMZWZ0ICYmICEodGhpcy5fc3BlZWQgPCAwICYmIHRoaXMuX3RpbWUgPT09IDApKSB8fCAodGhpcy5fcnVubmVySWRzLmxlbmd0aCAmJiB0aGlzLl9zcGVlZCA8IDAgJiYgdGhpcy5fdGltZSA+IDApKSB7XHJcbiAgICAgIHRoaXMuX2NvbnRpbnVlKClcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMucGF1c2UoKVxyXG4gICAgICB0aGlzLmZpcmUoJ2ZpbmlzaGVkJylcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgLy8gQ2hlY2tzIGlmIHdlIGFyZSBydW5uaW5nIGFuZCBjb250aW51ZXMgdGhlIGFuaW1hdGlvblxyXG4gIF9jb250aW51ZSAoaW1tZWRpYXRlU3RlcCA9IGZhbHNlKSB7XHJcbiAgICBBbmltYXRvci5jYW5jZWxGcmFtZSh0aGlzLl9uZXh0RnJhbWUpXHJcbiAgICB0aGlzLl9uZXh0RnJhbWUgPSBudWxsXHJcblxyXG4gICAgaWYgKGltbWVkaWF0ZVN0ZXApIHJldHVybiB0aGlzLl9zdGVwSW1tZWRpYXRlKClcclxuICAgIGlmICh0aGlzLl9wYXVzZWQpIHJldHVybiB0aGlzXHJcblxyXG4gICAgdGhpcy5fbmV4dEZyYW1lID0gQW5pbWF0b3IuZnJhbWUodGhpcy5fc3RlcClcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICBhY3RpdmUgKCkge1xyXG4gICAgcmV0dXJuICEhdGhpcy5fbmV4dEZyYW1lXHJcbiAgfVxyXG59XHJcblxyXG5yZWdpc3Rlck1ldGhvZHMoe1xyXG4gIEVsZW1lbnQ6IHtcclxuICAgIHRpbWVsaW5lOiBmdW5jdGlvbiAodGltZWxpbmUpIHtcclxuICAgICAgaWYgKHRpbWVsaW5lID09IG51bGwpIHtcclxuICAgICAgICB0aGlzLl90aW1lbGluZSA9ICh0aGlzLl90aW1lbGluZSB8fCBuZXcgVGltZWxpbmUoKSlcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGltZWxpbmVcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl90aW1lbGluZSA9IHRpbWVsaW5lXHJcbiAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufSlcclxuIiwiaW1wb3J0IHsgQ29udHJvbGxlciwgRWFzZSwgU3RlcHBlciB9IGZyb20gJy4vQ29udHJvbGxlci5qcydcclxuaW1wb3J0IHsgZXh0ZW5kLCByZWdpc3RlciB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IGZyb20sIHRvIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL2dyYWRpZW50ZWQuanMnXHJcbmltcG9ydCB7IGdldE9yaWdpbiB9IGZyb20gJy4uL3V0aWxzL3V0aWxzLmpzJ1xyXG5pbXBvcnQgeyBub29wLCB0aW1lbGluZSB9IGZyb20gJy4uL21vZHVsZXMvY29yZS9kZWZhdWx0cy5qcydcclxuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcclxuaW1wb3J0IHsgcngsIHJ5IH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL2NpcmNsZWQuanMnXHJcbmltcG9ydCBBbmltYXRvciBmcm9tICcuL0FuaW1hdG9yLmpzJ1xyXG5pbXBvcnQgQm94IGZyb20gJy4uL3R5cGVzL0JveC5qcydcclxuaW1wb3J0IEV2ZW50VGFyZ2V0IGZyb20gJy4uL3R5cGVzL0V2ZW50VGFyZ2V0LmpzJ1xyXG5pbXBvcnQgTWF0cml4IGZyb20gJy4uL3R5cGVzL01hdHJpeC5qcydcclxuaW1wb3J0IE1vcnBoYWJsZSwgeyBUcmFuc2Zvcm1CYWcgfSBmcm9tICcuL01vcnBoYWJsZS5qcydcclxuaW1wb3J0IFBvaW50IGZyb20gJy4uL3R5cGVzL1BvaW50LmpzJ1xyXG5pbXBvcnQgU1ZHTnVtYmVyIGZyb20gJy4uL3R5cGVzL1NWR051bWJlci5qcydcclxuaW1wb3J0IFRpbWVsaW5lIGZyb20gJy4vVGltZWxpbmUuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdW5uZXIgZXh0ZW5kcyBFdmVudFRhcmdldCB7XHJcbiAgY29uc3RydWN0b3IgKG9wdGlvbnMpIHtcclxuICAgIHN1cGVyKClcclxuXHJcbiAgICAvLyBTdG9yZSBhIHVuaXF1ZSBpZCBvbiB0aGUgcnVubmVyLCBzbyB0aGF0IHdlIGNhbiBpZGVudGlmeSBpdCBsYXRlclxyXG4gICAgdGhpcy5pZCA9IFJ1bm5lci5pZCsrXHJcblxyXG4gICAgLy8gRW5zdXJlIGEgZGVmYXVsdCB2YWx1ZVxyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPT0gbnVsbFxyXG4gICAgICA/IHRpbWVsaW5lLmR1cmF0aW9uXHJcbiAgICAgIDogb3B0aW9uc1xyXG5cclxuICAgIC8vIEVuc3VyZSB0aGF0IHdlIGdldCBhIGNvbnRyb2xsZXJcclxuICAgIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICA/IG5ldyBDb250cm9sbGVyKG9wdGlvbnMpXHJcbiAgICAgIDogb3B0aW9uc1xyXG5cclxuICAgIC8vIERlY2xhcmUgYWxsIG9mIHRoZSB2YXJpYWJsZXNcclxuICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsXHJcbiAgICB0aGlzLl90aW1lbGluZSA9IG51bGxcclxuICAgIHRoaXMuZG9uZSA9IGZhbHNlXHJcbiAgICB0aGlzLl9xdWV1ZSA9IFtdXHJcblxyXG4gICAgLy8gV29yayBvdXQgdGhlIHN0ZXBwZXIgYW5kIHRoZSBkdXJhdGlvblxyXG4gICAgdGhpcy5fZHVyYXRpb24gPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicgJiYgb3B0aW9uc1xyXG4gICAgdGhpcy5faXNEZWNsYXJhdGl2ZSA9IG9wdGlvbnMgaW5zdGFuY2VvZiBDb250cm9sbGVyXHJcbiAgICB0aGlzLl9zdGVwcGVyID0gdGhpcy5faXNEZWNsYXJhdGl2ZSA/IG9wdGlvbnMgOiBuZXcgRWFzZSgpXHJcblxyXG4gICAgLy8gV2UgY29weSB0aGUgY3VycmVudCB2YWx1ZXMgZnJvbSB0aGUgdGltZWxpbmUgYmVjYXVzZSB0aGV5IGNhbiBjaGFuZ2VcclxuICAgIHRoaXMuX2hpc3RvcnkgPSB7fVxyXG5cclxuICAgIC8vIFN0b3JlIHRoZSBzdGF0ZSBvZiB0aGUgcnVubmVyXHJcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlXHJcbiAgICB0aGlzLl90aW1lID0gMFxyXG4gICAgdGhpcy5fbGFzdFRpbWUgPSAwXHJcblxyXG4gICAgLy8gQXQgY3JlYXRpb24sIHRoZSBydW5uZXIgaXMgaW4gcmVzZXRlZCBzdGF0ZVxyXG4gICAgdGhpcy5fcmVzZXRlZCA9IHRydWVcclxuXHJcbiAgICAvLyBTYXZlIHRyYW5zZm9ybXMgYXBwbGllZCB0byB0aGlzIHJ1bm5lclxyXG4gICAgdGhpcy50cmFuc2Zvcm1zID0gbmV3IE1hdHJpeCgpXHJcbiAgICB0aGlzLnRyYW5zZm9ybUlkID0gMVxyXG5cclxuICAgIC8vIExvb3BpbmcgdmFyaWFibGVzXHJcbiAgICB0aGlzLl9oYXZlUmV2ZXJzZWQgPSBmYWxzZVxyXG4gICAgdGhpcy5fcmV2ZXJzZSA9IGZhbHNlXHJcbiAgICB0aGlzLl9sb29wc0RvbmUgPSAwXHJcbiAgICB0aGlzLl9zd2luZyA9IGZhbHNlXHJcbiAgICB0aGlzLl93YWl0ID0gMFxyXG4gICAgdGhpcy5fdGltZXMgPSAxXHJcblxyXG4gICAgdGhpcy5fZnJhbWVJZCA9IG51bGxcclxuXHJcbiAgICAvLyBTdG9yZXMgaG93IGxvbmcgYSBydW5uZXIgaXMgc3RvcmVkIGFmdGVyIGJlZWluZyBkb25lXHJcbiAgICB0aGlzLl9wZXJzaXN0ID0gdGhpcy5faXNEZWNsYXJhdGl2ZSA/IHRydWUgOiBudWxsXHJcbiAgfVxyXG5cclxuICAvKlxyXG4gIFJ1bm5lciBEZWZpbml0aW9uc1xyXG4gID09PT09PT09PT09PT09PT09PVxyXG4gIFRoZXNlIG1ldGhvZHMgaGVscCB1cyBkZWZpbmUgdGhlIHJ1bnRpbWUgYmVoYXZpb3VyIG9mIHRoZSBSdW5uZXIgb3IgdGhleVxyXG4gIGhlbHAgdXMgbWFrZSBuZXcgcnVubmVycyBmcm9tIHRoZSBjdXJyZW50IHJ1bm5lclxyXG4gICovXHJcblxyXG4gIGVsZW1lbnQgKGVsZW1lbnQpIHtcclxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHJldHVybiB0aGlzLl9lbGVtZW50XHJcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudFxyXG4gICAgZWxlbWVudC5fcHJlcGFyZVJ1bm5lcigpXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgdGltZWxpbmUgKHRpbWVsaW5lKSB7XHJcbiAgICAvLyBjaGVjayBleHBsaWNpdGx5IGZvciB1bmRlZmluZWQgc28gd2UgY2FuIHNldCB0aGUgdGltZWxpbmUgdG8gbnVsbFxyXG4gICAgaWYgKHR5cGVvZiB0aW1lbGluZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiB0aGlzLl90aW1lbGluZVxyXG4gICAgdGhpcy5fdGltZWxpbmUgPSB0aW1lbGluZVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIGFuaW1hdGUgKGR1cmF0aW9uLCBkZWxheSwgd2hlbikge1xyXG4gICAgdmFyIG8gPSBSdW5uZXIuc2FuaXRpc2UoZHVyYXRpb24sIGRlbGF5LCB3aGVuKVxyXG4gICAgdmFyIHJ1bm5lciA9IG5ldyBSdW5uZXIoby5kdXJhdGlvbilcclxuICAgIGlmICh0aGlzLl90aW1lbGluZSkgcnVubmVyLnRpbWVsaW5lKHRoaXMuX3RpbWVsaW5lKVxyXG4gICAgaWYgKHRoaXMuX2VsZW1lbnQpIHJ1bm5lci5lbGVtZW50KHRoaXMuX2VsZW1lbnQpXHJcbiAgICByZXR1cm4gcnVubmVyLmxvb3Aobykuc2NoZWR1bGUoby5kZWxheSwgby53aGVuKVxyXG4gIH1cclxuXHJcbiAgc2NoZWR1bGUgKHRpbWVsaW5lLCBkZWxheSwgd2hlbikge1xyXG4gICAgLy8gVGhlIHVzZXIgZG9lc24ndCBuZWVkIHRvIHBhc3MgYSB0aW1lbGluZSBpZiB3ZSBhbHJlYWR5IGhhdmUgb25lXHJcbiAgICBpZiAoISh0aW1lbGluZSBpbnN0YW5jZW9mIFRpbWVsaW5lKSkge1xyXG4gICAgICB3aGVuID0gZGVsYXlcclxuICAgICAgZGVsYXkgPSB0aW1lbGluZVxyXG4gICAgICB0aW1lbGluZSA9IHRoaXMudGltZWxpbmUoKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHRoZXJlIGlzIG5vIHRpbWVsaW5lLCB5ZWxsIGF0IHRoZSB1c2VyLi4uXHJcbiAgICBpZiAoIXRpbWVsaW5lKSB7XHJcbiAgICAgIHRocm93IEVycm9yKCdSdW5uZXIgY2Fubm90IGJlIHNjaGVkdWxlZCB3aXRob3V0IHRpbWVsaW5lJylcclxuICAgIH1cclxuXHJcbiAgICAvLyBTY2hlZHVsZSB0aGUgcnVubmVyIG9uIHRoZSB0aW1lbGluZSBwcm92aWRlZFxyXG4gICAgdGltZWxpbmUuc2NoZWR1bGUodGhpcywgZGVsYXksIHdoZW4pXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgdW5zY2hlZHVsZSAoKSB7XHJcbiAgICB2YXIgdGltZWxpbmUgPSB0aGlzLnRpbWVsaW5lKClcclxuICAgIHRpbWVsaW5lICYmIHRpbWVsaW5lLnVuc2NoZWR1bGUodGhpcylcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICBsb29wICh0aW1lcywgc3dpbmcsIHdhaXQpIHtcclxuICAgIC8vIERlYWwgd2l0aCB0aGUgdXNlciBwYXNzaW5nIGluIGFuIG9iamVjdFxyXG4gICAgaWYgKHR5cGVvZiB0aW1lcyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgc3dpbmcgPSB0aW1lcy5zd2luZ1xyXG4gICAgICB3YWl0ID0gdGltZXMud2FpdFxyXG4gICAgICB0aW1lcyA9IHRpbWVzLnRpbWVzXHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2FuaXRpc2UgdGhlIHZhbHVlcyBhbmQgc3RvcmUgdGhlbVxyXG4gICAgdGhpcy5fdGltZXMgPSB0aW1lcyB8fCBJbmZpbml0eVxyXG4gICAgdGhpcy5fc3dpbmcgPSBzd2luZyB8fCBmYWxzZVxyXG4gICAgdGhpcy5fd2FpdCA9IHdhaXQgfHwgMFxyXG5cclxuICAgIC8vIEFsbG93IHRydWUgdG8gYmUgcGFzc2VkXHJcbiAgICBpZiAodGhpcy5fdGltZXMgPT09IHRydWUpIHsgdGhpcy5fdGltZXMgPSBJbmZpbml0eSB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIGRlbGF5IChkZWxheSkge1xyXG4gICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSgwLCBkZWxheSlcclxuICB9XHJcblxyXG4gIC8qXHJcbiAgQmFzaWMgRnVuY3Rpb25hbGl0eVxyXG4gID09PT09PT09PT09PT09PT09PT1cclxuICBUaGVzZSBtZXRob2RzIGFsbG93IHVzIHRvIGF0dGFjaCBiYXNpYyBmdW5jdGlvbnMgdG8gdGhlIHJ1bm5lciBkaXJlY3RseVxyXG4gICovXHJcblxyXG4gIHF1ZXVlIChpbml0Rm4sIHJ1bkZuLCByZXRhcmdldEZuLCBpc1RyYW5zZm9ybSkge1xyXG4gICAgdGhpcy5fcXVldWUucHVzaCh7XHJcbiAgICAgIGluaXRpYWxpc2VyOiBpbml0Rm4gfHwgbm9vcCxcclxuICAgICAgcnVubmVyOiBydW5GbiB8fCBub29wLFxyXG4gICAgICByZXRhcmdldDogcmV0YXJnZXRGbixcclxuICAgICAgaXNUcmFuc2Zvcm06IGlzVHJhbnNmb3JtLFxyXG4gICAgICBpbml0aWFsaXNlZDogZmFsc2UsXHJcbiAgICAgIGZpbmlzaGVkOiBmYWxzZVxyXG4gICAgfSlcclxuICAgIHZhciB0aW1lbGluZSA9IHRoaXMudGltZWxpbmUoKVxyXG4gICAgdGltZWxpbmUgJiYgdGhpcy50aW1lbGluZSgpLl9jb250aW51ZSgpXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgZHVyaW5nIChmbikge1xyXG4gICAgcmV0dXJuIHRoaXMucXVldWUobnVsbCwgZm4pXHJcbiAgfVxyXG5cclxuICBhZnRlciAoZm4pIHtcclxuICAgIHJldHVybiB0aGlzLm9uKCdmaW5pc2hlZCcsIGZuKVxyXG4gIH1cclxuXHJcbiAgLypcclxuICBSdW5uZXIgYW5pbWF0aW9uIG1ldGhvZHNcclxuICA9PT09PT09PT09PT09PT09PT09PT09PT1cclxuICBDb250cm9sIGhvdyB0aGUgYW5pbWF0aW9uIHBsYXlzXHJcbiAgKi9cclxuXHJcbiAgdGltZSAodGltZSkge1xyXG4gICAgaWYgKHRpbWUgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fdGltZVxyXG4gICAgfVxyXG4gICAgY29uc3QgZHQgPSB0aW1lIC0gdGhpcy5fdGltZVxyXG4gICAgdGhpcy5zdGVwKGR0KVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIGR1cmF0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLl90aW1lcyAqICh0aGlzLl93YWl0ICsgdGhpcy5fZHVyYXRpb24pIC0gdGhpcy5fd2FpdFxyXG4gIH1cclxuXHJcbiAgbG9vcHMgKHApIHtcclxuICAgIHZhciBsb29wRHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbiArIHRoaXMuX3dhaXRcclxuICAgIGlmIChwID09IG51bGwpIHtcclxuICAgICAgdmFyIGxvb3BzRG9uZSA9IE1hdGguZmxvb3IodGhpcy5fdGltZSAvIGxvb3BEdXJhdGlvbilcclxuICAgICAgdmFyIHJlbGF0aXZlVGltZSA9ICh0aGlzLl90aW1lIC0gbG9vcHNEb25lICogbG9vcER1cmF0aW9uKVxyXG4gICAgICB2YXIgcG9zaXRpb24gPSByZWxhdGl2ZVRpbWUgLyB0aGlzLl9kdXJhdGlvblxyXG4gICAgICByZXR1cm4gTWF0aC5taW4obG9vcHNEb25lICsgcG9zaXRpb24sIHRoaXMuX3RpbWVzKVxyXG4gICAgfVxyXG4gICAgdmFyIHdob2xlID0gTWF0aC5mbG9vcihwKVxyXG4gICAgdmFyIHBhcnRpYWwgPSBwICUgMVxyXG4gICAgdmFyIHRpbWUgPSBsb29wRHVyYXRpb24gKiB3aG9sZSArIHRoaXMuX2R1cmF0aW9uICogcGFydGlhbFxyXG4gICAgcmV0dXJuIHRoaXMudGltZSh0aW1lKVxyXG4gIH1cclxuXHJcbiAgcGVyc2lzdCAoZHRPckZvcmV2ZXIpIHtcclxuICAgIGlmIChkdE9yRm9yZXZlciA9PSBudWxsKSByZXR1cm4gdGhpcy5fcGVyc2lzdFxyXG4gICAgdGhpcy5fcGVyc2lzdCA9IGR0T3JGb3JldmVyXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgcG9zaXRpb24gKHApIHtcclxuICAgIC8vIEdldCBhbGwgb2YgdGhlIHZhcmlhYmxlcyB3ZSBuZWVkXHJcbiAgICB2YXIgeCA9IHRoaXMuX3RpbWVcclxuICAgIHZhciBkID0gdGhpcy5fZHVyYXRpb25cclxuICAgIHZhciB3ID0gdGhpcy5fd2FpdFxyXG4gICAgdmFyIHQgPSB0aGlzLl90aW1lc1xyXG4gICAgdmFyIHMgPSB0aGlzLl9zd2luZ1xyXG4gICAgdmFyIHIgPSB0aGlzLl9yZXZlcnNlXHJcbiAgICB2YXIgcG9zaXRpb25cclxuXHJcbiAgICBpZiAocCA9PSBudWxsKSB7XHJcbiAgICAgIC8qXHJcbiAgICAgIFRoaXMgZnVuY3Rpb24gY29udmVydHMgYSB0aW1lIHRvIGEgcG9zaXRpb24gaW4gdGhlIHJhbmdlIFswLCAxXVxyXG4gICAgICBUaGUgZnVsbCBleHBsYW5hdGlvbiBjYW4gYmUgZm91bmQgaW4gdGhpcyBkZXNtb3MgZGVtb25zdHJhdGlvblxyXG4gICAgICAgIGh0dHBzOi8vd3d3LmRlc21vcy5jb20vY2FsY3VsYXRvci91NGZiYXZnY2hlXHJcbiAgICAgIFRoZSBsb2dpYyBpcyBzbGlnaHRseSBzaW1wbGlmaWVkIGhlcmUgYmVjYXVzZSB3ZSBjYW4gdXNlIGJvb2xlYW5zXHJcbiAgICAgICovXHJcblxyXG4gICAgICAvLyBGaWd1cmUgb3V0IHRoZSB2YWx1ZSB3aXRob3V0IHRoaW5raW5nIGFib3V0IHRoZSBzdGFydCBvciBlbmQgdGltZVxyXG4gICAgICBjb25zdCBmID0gZnVuY3Rpb24gKHgpIHtcclxuICAgICAgICB2YXIgc3dpbmdpbmcgPSBzICogTWF0aC5mbG9vcih4ICUgKDIgKiAodyArIGQpKSAvICh3ICsgZCkpXHJcbiAgICAgICAgdmFyIGJhY2t3YXJkcyA9IChzd2luZ2luZyAmJiAhcikgfHwgKCFzd2luZ2luZyAmJiByKVxyXG4gICAgICAgIHZhciB1bmNsaXBlZCA9IE1hdGgucG93KC0xLCBiYWNrd2FyZHMpICogKHggJSAodyArIGQpKSAvIGQgKyBiYWNrd2FyZHNcclxuICAgICAgICB2YXIgY2xpcHBlZCA9IE1hdGgubWF4KE1hdGgubWluKHVuY2xpcGVkLCAxKSwgMClcclxuICAgICAgICByZXR1cm4gY2xpcHBlZFxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBGaWd1cmUgb3V0IHRoZSB2YWx1ZSBieSBpbmNvcnBvcmF0aW5nIHRoZSBzdGFydCB0aW1lXHJcbiAgICAgIHZhciBlbmRUaW1lID0gdCAqICh3ICsgZCkgLSB3XHJcbiAgICAgIHBvc2l0aW9uID0geCA8PSAwID8gTWF0aC5yb3VuZChmKDFlLTUpKVxyXG4gICAgICAgIDogeCA8IGVuZFRpbWUgPyBmKHgpXHJcbiAgICAgICAgOiBNYXRoLnJvdW5kKGYoZW5kVGltZSAtIDFlLTUpKVxyXG4gICAgICByZXR1cm4gcG9zaXRpb25cclxuICAgIH1cclxuXHJcbiAgICAvLyBXb3JrIG91dCB0aGUgbG9vcHMgZG9uZSBhbmQgYWRkIHRoZSBwb3NpdGlvbiB0byB0aGUgbG9vcHMgZG9uZVxyXG4gICAgdmFyIGxvb3BzRG9uZSA9IE1hdGguZmxvb3IodGhpcy5sb29wcygpKVxyXG4gICAgdmFyIHN3aW5nRm9yd2FyZCA9IHMgJiYgKGxvb3BzRG9uZSAlIDIgPT09IDApXHJcbiAgICB2YXIgZm9yd2FyZHMgPSAoc3dpbmdGb3J3YXJkICYmICFyKSB8fCAociAmJiBzd2luZ0ZvcndhcmQpXHJcbiAgICBwb3NpdGlvbiA9IGxvb3BzRG9uZSArIChmb3J3YXJkcyA/IHAgOiAxIC0gcClcclxuICAgIHJldHVybiB0aGlzLmxvb3BzKHBvc2l0aW9uKVxyXG4gIH1cclxuXHJcbiAgcHJvZ3Jlc3MgKHApIHtcclxuICAgIGlmIChwID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIE1hdGgubWluKDEsIHRoaXMuX3RpbWUgLyB0aGlzLmR1cmF0aW9uKCkpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy50aW1lKHAgKiB0aGlzLmR1cmF0aW9uKCkpXHJcbiAgfVxyXG5cclxuICBzdGVwIChkdCkge1xyXG4gICAgLy8gSWYgd2UgYXJlIGluYWN0aXZlLCB0aGlzIHN0ZXBwZXIganVzdCBnZXRzIHNraXBwZWRcclxuICAgIGlmICghdGhpcy5lbmFibGVkKSByZXR1cm4gdGhpc1xyXG5cclxuICAgIC8vIFVwZGF0ZSB0aGUgdGltZSBhbmQgZ2V0IHRoZSBuZXcgcG9zaXRpb25cclxuICAgIGR0ID0gZHQgPT0gbnVsbCA/IDE2IDogZHRcclxuICAgIHRoaXMuX3RpbWUgKz0gZHRcclxuICAgIHZhciBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb24oKVxyXG5cclxuICAgIC8vIEZpZ3VyZSBvdXQgaWYgd2UgbmVlZCB0byBydW4gdGhlIHN0ZXBwZXIgaW4gdGhpcyBmcmFtZVxyXG4gICAgdmFyIHJ1bm5pbmcgPSB0aGlzLl9sYXN0UG9zaXRpb24gIT09IHBvc2l0aW9uICYmIHRoaXMuX3RpbWUgPj0gMFxyXG4gICAgdGhpcy5fbGFzdFBvc2l0aW9uID0gcG9zaXRpb25cclxuXHJcbiAgICAvLyBGaWd1cmUgb3V0IGlmIHdlIGp1c3Qgc3RhcnRlZFxyXG4gICAgdmFyIGR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbigpXHJcbiAgICB2YXIganVzdFN0YXJ0ZWQgPSB0aGlzLl9sYXN0VGltZSA8PSAwICYmIHRoaXMuX3RpbWUgPiAwXHJcbiAgICB2YXIganVzdEZpbmlzaGVkID0gdGhpcy5fbGFzdFRpbWUgPCBkdXJhdGlvbiAmJiB0aGlzLl90aW1lID49IGR1cmF0aW9uXHJcblxyXG4gICAgdGhpcy5fbGFzdFRpbWUgPSB0aGlzLl90aW1lXHJcbiAgICBpZiAoanVzdFN0YXJ0ZWQpIHtcclxuICAgICAgdGhpcy5maXJlKCdzdGFydCcsIHRoaXMpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gV29yayBvdXQgaWYgdGhlIHJ1bm5lciBpcyBmaW5pc2hlZCBzZXQgdGhlIGRvbmUgZmxhZyBoZXJlIHNvIGFuaW1hdGlvbnNcclxuICAgIC8vIGtub3csIHRoYXQgdGhleSBhcmUgcnVubmluZyBpbiB0aGUgbGFzdCBzdGVwICh0aGlzIGlzIGdvb2QgZm9yXHJcbiAgICAvLyB0cmFuc2Zvcm1hdGlvbnMgd2hpY2ggY2FuIGJlIG1lcmdlZClcclxuICAgIHZhciBkZWNsYXJhdGl2ZSA9IHRoaXMuX2lzRGVjbGFyYXRpdmVcclxuICAgIHRoaXMuZG9uZSA9ICFkZWNsYXJhdGl2ZSAmJiAhanVzdEZpbmlzaGVkICYmIHRoaXMuX3RpbWUgPj0gZHVyYXRpb25cclxuXHJcbiAgICAvLyBSdW5uZXIgaXMgcnVubmluZy4gU28gaXRzIG5vdCBpbiByZXNldGVkIHN0YXRlIGFueW1vcmVcclxuICAgIHRoaXMuX3Jlc2V0ZWQgPSBmYWxzZVxyXG5cclxuICAgIC8vIENhbGwgaW5pdGlhbGlzZSBhbmQgdGhlIHJ1biBmdW5jdGlvblxyXG4gICAgaWYgKHJ1bm5pbmcgfHwgZGVjbGFyYXRpdmUpIHtcclxuICAgICAgdGhpcy5faW5pdGlhbGlzZShydW5uaW5nKVxyXG5cclxuICAgICAgLy8gY2xlYXIgdGhlIHRyYW5zZm9ybXMgb24gdGhpcyBydW5uZXIgc28gdGhleSBkb250IGdldCBhZGRlZCBhZ2FpbiBhbmQgYWdhaW5cclxuICAgICAgdGhpcy50cmFuc2Zvcm1zID0gbmV3IE1hdHJpeCgpXHJcbiAgICAgIHZhciBjb252ZXJnZWQgPSB0aGlzLl9ydW4oZGVjbGFyYXRpdmUgPyBkdCA6IHBvc2l0aW9uKVxyXG5cclxuICAgICAgdGhpcy5maXJlKCdzdGVwJywgdGhpcylcclxuICAgIH1cclxuICAgIC8vIGNvcnJlY3QgdGhlIGRvbmUgZmxhZyBoZXJlXHJcbiAgICAvLyBkZWNsYXJpdGl2ZSBhbmltYXRpb25zIGl0c2VsZiBrbm93IHdoZW4gdGhleSBjb252ZXJnZWRcclxuICAgIHRoaXMuZG9uZSA9IHRoaXMuZG9uZSB8fCAoY29udmVyZ2VkICYmIGRlY2xhcmF0aXZlKVxyXG4gICAgaWYgKGp1c3RGaW5pc2hlZCkge1xyXG4gICAgICB0aGlzLmZpcmUoJ2ZpbmlzaGVkJywgdGhpcylcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICByZXNldCAoKSB7XHJcbiAgICBpZiAodGhpcy5fcmVzZXRlZCkgcmV0dXJuIHRoaXNcclxuICAgIHRoaXMudGltZSgwKVxyXG4gICAgdGhpcy5fcmVzZXRlZCA9IHRydWVcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICBmaW5pc2ggKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RlcChJbmZpbml0eSlcclxuICB9XHJcblxyXG4gIHJldmVyc2UgKHJldmVyc2UpIHtcclxuICAgIHRoaXMuX3JldmVyc2UgPSByZXZlcnNlID09IG51bGwgPyAhdGhpcy5fcmV2ZXJzZSA6IHJldmVyc2VcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICBlYXNlIChmbikge1xyXG4gICAgdGhpcy5fc3RlcHBlciA9IG5ldyBFYXNlKGZuKVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIGFjdGl2ZSAoZW5hYmxlZCkge1xyXG4gICAgaWYgKGVuYWJsZWQgPT0gbnVsbCkgcmV0dXJuIHRoaXMuZW5hYmxlZFxyXG4gICAgdGhpcy5lbmFibGVkID0gZW5hYmxlZFxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8qXHJcbiAgUHJpdmF0ZSBNZXRob2RzXHJcbiAgPT09PT09PT09PT09PT09XHJcbiAgTWV0aG9kcyB0aGF0IHNob3VsZG4ndCBiZSB1c2VkIGV4dGVybmFsbHlcclxuICAqL1xyXG5cclxuICAvLyBTYXZlIGEgbW9ycGhlciB0byB0aGUgbW9ycGhlciBsaXN0IHNvIHRoYXQgd2UgY2FuIHJldGFyZ2V0IGl0IGxhdGVyXHJcbiAgX3JlbWVtYmVyTW9ycGhlciAobWV0aG9kLCBtb3JwaGVyKSB7XHJcbiAgICB0aGlzLl9oaXN0b3J5W21ldGhvZF0gPSB7XHJcbiAgICAgIG1vcnBoZXI6IG1vcnBoZXIsXHJcbiAgICAgIGNhbGxlcjogdGhpcy5fcXVldWVbdGhpcy5fcXVldWUubGVuZ3RoIC0gMV1cclxuICAgIH1cclxuXHJcbiAgICAvLyBXZSBoYXZlIHRvIHJlc3VtZSB0aGUgdGltZWxpbmUgaW4gY2FzZSBhIGNvbnRyb2xsZXJcclxuICAgIC8vIGlzIGFscmVhZHkgZG9uZSB3aXRob3V0IGJlZWluZyBldmVyIHJ1blxyXG4gICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gZS5nLiB0aGlzIGlzIGRvbmU6XHJcbiAgICAvLyAgICBhbmltID0gZWwuYW5pbWF0ZShuZXcgU1ZHLlNwcmluZylcclxuICAgIC8vIGFuZCBsYXRlclxyXG4gICAgLy8gICAgYW5pbS5tb3ZlKC4uLilcclxuICAgIGlmICh0aGlzLl9pc0RlY2xhcmF0aXZlKSB7XHJcbiAgICAgIHZhciB0aW1lbGluZSA9IHRoaXMudGltZWxpbmUoKVxyXG4gICAgICB0aW1lbGluZSAmJiB0aW1lbGluZS5wbGF5KClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFRyeSB0byBzZXQgdGhlIHRhcmdldCBmb3IgYSBtb3JwaGVyIGlmIHRoZSBtb3JwaGVyIGV4aXN0cywgb3RoZXJ3aXNlXHJcbiAgLy8gZG8gbm90aGluZyBhbmQgcmV0dXJuIGZhbHNlXHJcbiAgX3RyeVJldGFyZ2V0IChtZXRob2QsIHRhcmdldCwgZXh0cmEpIHtcclxuICAgIGlmICh0aGlzLl9oaXN0b3J5W21ldGhvZF0pIHtcclxuICAgICAgLy8gaWYgdGhlIGxhc3QgbWV0aG9kIHdhc250IGV2ZW4gaW5pdGlhbGlzZWQsIHRocm93IGl0IGF3YXlcclxuICAgICAgaWYgKCF0aGlzLl9oaXN0b3J5W21ldGhvZF0uY2FsbGVyLmluaXRpYWxpc2VkKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9xdWV1ZS5pbmRleE9mKHRoaXMuX2hpc3RvcnlbbWV0aG9kXS5jYWxsZXIpXHJcbiAgICAgICAgdGhpcy5fcXVldWUuc3BsaWNlKGluZGV4LCAxKVxyXG4gICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBmb3IgdGhlIGNhc2Ugb2YgdHJhbnNmb3JtYXRpb25zLCB3ZSB1c2UgdGhlIHNwZWNpYWwgcmV0YXJnZXQgZnVuY3Rpb25cclxuICAgICAgLy8gd2hpY2ggaGFzIGFjY2VzcyB0byB0aGUgb3V0ZXIgc2NvcGVcclxuICAgICAgaWYgKHRoaXMuX2hpc3RvcnlbbWV0aG9kXS5jYWxsZXIucmV0YXJnZXQpIHtcclxuICAgICAgICB0aGlzLl9oaXN0b3J5W21ldGhvZF0uY2FsbGVyLnJldGFyZ2V0KHRhcmdldCwgZXh0cmEpXHJcbiAgICAgICAgLy8gZm9yIGV2ZXJ5dGhpbmcgZWxzZSBhIHNpbXBsZSBtb3JwaGVyIGNoYW5nZSBpcyBzdWZmaWNpZW50XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5faGlzdG9yeVttZXRob2RdLm1vcnBoZXIudG8odGFyZ2V0KVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9oaXN0b3J5W21ldGhvZF0uY2FsbGVyLmZpbmlzaGVkID0gZmFsc2VcclxuICAgICAgdmFyIHRpbWVsaW5lID0gdGhpcy50aW1lbGluZSgpXHJcbiAgICAgIHRpbWVsaW5lICYmIHRpbWVsaW5lLnBsYXkoKVxyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG5cclxuICAvLyBSdW4gZWFjaCBpbml0aWFsaXNlIGZ1bmN0aW9uIGluIHRoZSBydW5uZXIgaWYgcmVxdWlyZWRcclxuICBfaW5pdGlhbGlzZSAocnVubmluZykge1xyXG4gICAgLy8gSWYgd2UgYXJlbid0IHJ1bm5pbmcsIHdlIHNob3VsZG4ndCBpbml0aWFsaXNlIHdoZW4gbm90IGRlY2xhcmF0aXZlXHJcbiAgICBpZiAoIXJ1bm5pbmcgJiYgIXRoaXMuX2lzRGVjbGFyYXRpdmUpIHJldHVyblxyXG5cclxuICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgb2YgdGhlIGluaXRpYWxpc2Vyc1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3F1ZXVlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgIC8vIEdldCB0aGUgY3VycmVudCBpbml0aWFsaXNlclxyXG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuX3F1ZXVlW2ldXHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgd2hldGhlciB3ZSBuZWVkIHRvIGluaXRpYWxpc2VcclxuICAgICAgdmFyIG5lZWRzSXQgPSB0aGlzLl9pc0RlY2xhcmF0aXZlIHx8ICghY3VycmVudC5pbml0aWFsaXNlZCAmJiBydW5uaW5nKVxyXG4gICAgICBydW5uaW5nID0gIWN1cnJlbnQuZmluaXNoZWRcclxuXHJcbiAgICAgIC8vIENhbGwgdGhlIGluaXRpYWxpc2VyIGlmIHdlIG5lZWQgdG9cclxuICAgICAgaWYgKG5lZWRzSXQgJiYgcnVubmluZykge1xyXG4gICAgICAgIGN1cnJlbnQuaW5pdGlhbGlzZXIuY2FsbCh0aGlzKVxyXG4gICAgICAgIGN1cnJlbnQuaW5pdGlhbGlzZWQgPSB0cnVlXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFJ1biBlYWNoIHJ1biBmdW5jdGlvbiBmb3IgdGhlIHBvc2l0aW9uIG9yIGR0IGdpdmVuXHJcbiAgX3J1biAocG9zaXRpb25PckR0KSB7XHJcbiAgICAvLyBSdW4gYWxsIG9mIHRoZSBfcXVldWUgZGlyZWN0bHlcclxuICAgIHZhciBhbGxmaW5pc2hlZCA9IHRydWVcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9xdWV1ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgZnVuY3Rpb24gdG8gcnVuXHJcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5fcXVldWVbaV1cclxuXHJcbiAgICAgIC8vIFJ1biB0aGUgZnVuY3Rpb24gaWYgaXRzIG5vdCBmaW5pc2hlZCwgd2Uga2VlcCB0cmFjayBvZiB0aGUgZmluaXNoZWRcclxuICAgICAgLy8gZmxhZyBmb3IgdGhlIHNha2Ugb2YgZGVjbGFyYXRpdmUgX3F1ZXVlXHJcbiAgICAgIHZhciBjb252ZXJnZWQgPSBjdXJyZW50LnJ1bm5lci5jYWxsKHRoaXMsIHBvc2l0aW9uT3JEdClcclxuICAgICAgY3VycmVudC5maW5pc2hlZCA9IGN1cnJlbnQuZmluaXNoZWQgfHwgKGNvbnZlcmdlZCA9PT0gdHJ1ZSlcclxuICAgICAgYWxsZmluaXNoZWQgPSBhbGxmaW5pc2hlZCAmJiBjdXJyZW50LmZpbmlzaGVkXHJcbiAgICB9XHJcblxyXG4gICAgLy8gV2UgcmVwb3J0IHdoZW4gYWxsIG9mIHRoZSBjb25zdHJ1Y3RvcnMgYXJlIGZpbmlzaGVkXHJcbiAgICByZXR1cm4gYWxsZmluaXNoZWRcclxuICB9XHJcblxyXG4gIGFkZFRyYW5zZm9ybSAodHJhbnNmb3JtLCBpbmRleCkge1xyXG4gICAgdGhpcy50cmFuc2Zvcm1zLmxtdWx0aXBseU8odHJhbnNmb3JtKVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIGNsZWFyVHJhbnNmb3JtICgpIHtcclxuICAgIHRoaXMudHJhbnNmb3JtcyA9IG5ldyBNYXRyaXgoKVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8vIFRPRE86IEtlZXAgdHJhY2sgb2YgYWxsIHRyYW5zZm9ybWF0aW9ucyBzbyB0aGF0IGRlbGV0aW9uIGlzIGZhc3RlclxyXG4gIGNsZWFyVHJhbnNmb3Jtc0Zyb21RdWV1ZSAoKSB7XHJcbiAgICBpZiAoIXRoaXMuZG9uZSB8fCAhdGhpcy5fdGltZWxpbmUgfHwgIXRoaXMuX3RpbWVsaW5lLl9ydW5uZXJJZHMuaW5jbHVkZXModGhpcy5pZCkpIHtcclxuICAgICAgdGhpcy5fcXVldWUgPSB0aGlzLl9xdWV1ZS5maWx0ZXIoKGl0ZW0pID0+IHtcclxuICAgICAgICByZXR1cm4gIWl0ZW0uaXNUcmFuc2Zvcm1cclxuICAgICAgfSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0YXRpYyBzYW5pdGlzZSAoZHVyYXRpb24sIGRlbGF5LCB3aGVuKSB7XHJcbiAgICAvLyBJbml0aWFsaXNlIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnNcclxuICAgIHZhciB0aW1lcyA9IDFcclxuICAgIHZhciBzd2luZyA9IGZhbHNlXHJcbiAgICB2YXIgd2FpdCA9IDBcclxuICAgIGR1cmF0aW9uID0gZHVyYXRpb24gfHwgdGltZWxpbmUuZHVyYXRpb25cclxuICAgIGRlbGF5ID0gZGVsYXkgfHwgdGltZWxpbmUuZGVsYXlcclxuICAgIHdoZW4gPSB3aGVuIHx8ICdsYXN0J1xyXG5cclxuICAgIC8vIElmIHdlIGhhdmUgYW4gb2JqZWN0LCB1bnBhY2sgdGhlIHZhbHVlc1xyXG4gICAgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ29iamVjdCcgJiYgIShkdXJhdGlvbiBpbnN0YW5jZW9mIFN0ZXBwZXIpKSB7XHJcbiAgICAgIGRlbGF5ID0gZHVyYXRpb24uZGVsYXkgfHwgZGVsYXlcclxuICAgICAgd2hlbiA9IGR1cmF0aW9uLndoZW4gfHwgd2hlblxyXG4gICAgICBzd2luZyA9IGR1cmF0aW9uLnN3aW5nIHx8IHN3aW5nXHJcbiAgICAgIHRpbWVzID0gZHVyYXRpb24udGltZXMgfHwgdGltZXNcclxuICAgICAgd2FpdCA9IGR1cmF0aW9uLndhaXQgfHwgd2FpdFxyXG4gICAgICBkdXJhdGlvbiA9IGR1cmF0aW9uLmR1cmF0aW9uIHx8IHRpbWVsaW5lLmR1cmF0aW9uXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxyXG4gICAgICBkZWxheTogZGVsYXksXHJcbiAgICAgIHN3aW5nOiBzd2luZyxcclxuICAgICAgdGltZXM6IHRpbWVzLFxyXG4gICAgICB3YWl0OiB3YWl0LFxyXG4gICAgICB3aGVuOiB3aGVuXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5SdW5uZXIuaWQgPSAwXHJcblxyXG5jbGFzcyBGYWtlUnVubmVyIHtcclxuICBjb25zdHJ1Y3RvciAodHJhbnNmb3JtcyA9IG5ldyBNYXRyaXgoKSwgaWQgPSAtMSwgZG9uZSA9IHRydWUpIHtcclxuICAgIHRoaXMudHJhbnNmb3JtcyA9IHRyYW5zZm9ybXNcclxuICAgIHRoaXMuaWQgPSBpZFxyXG4gICAgdGhpcy5kb25lID0gZG9uZVxyXG4gIH1cclxuXHJcbiAgY2xlYXJUcmFuc2Zvcm1zRnJvbVF1ZXVlICgpIHsgfVxyXG59XHJcblxyXG5leHRlbmQoWyBSdW5uZXIsIEZha2VSdW5uZXIgXSwge1xyXG4gIG1lcmdlV2l0aCAocnVubmVyKSB7XHJcbiAgICByZXR1cm4gbmV3IEZha2VSdW5uZXIoXHJcbiAgICAgIHJ1bm5lci50cmFuc2Zvcm1zLmxtdWx0aXBseSh0aGlzLnRyYW5zZm9ybXMpLFxyXG4gICAgICBydW5uZXIuaWRcclxuICAgIClcclxuICB9XHJcbn0pXHJcblxyXG4vLyBGYWtlUnVubmVyLmVtcHR5UnVubmVyID0gbmV3IEZha2VSdW5uZXIoKVxyXG5cclxuY29uc3QgbG11bHRpcGx5ID0gKGxhc3QsIGN1cnIpID0+IGxhc3QubG11bHRpcGx5TyhjdXJyKVxyXG5jb25zdCBnZXRSdW5uZXJUcmFuc2Zvcm0gPSAocnVubmVyKSA9PiBydW5uZXIudHJhbnNmb3Jtc1xyXG5cclxuZnVuY3Rpb24gbWVyZ2VUcmFuc2Zvcm1zICgpIHtcclxuICAvLyBGaW5kIHRoZSBtYXRyaXggdG8gYXBwbHkgdG8gdGhlIGVsZW1lbnQgYW5kIGFwcGx5IGl0XHJcbiAgY29uc3QgcnVubmVycyA9IHRoaXMuX3RyYW5zZm9ybWF0aW9uUnVubmVycy5ydW5uZXJzXHJcbiAgY29uc3QgbmV0VHJhbnNmb3JtID0gcnVubmVyc1xyXG4gICAgLm1hcChnZXRSdW5uZXJUcmFuc2Zvcm0pXHJcbiAgICAucmVkdWNlKGxtdWx0aXBseSwgbmV3IE1hdHJpeCgpKVxyXG5cclxuICB0aGlzLnRyYW5zZm9ybShuZXRUcmFuc2Zvcm0pXHJcblxyXG4gIHRoaXMuX3RyYW5zZm9ybWF0aW9uUnVubmVycy5tZXJnZSgpXHJcblxyXG4gIGlmICh0aGlzLl90cmFuc2Zvcm1hdGlvblJ1bm5lcnMubGVuZ3RoKCkgPT09IDEpIHtcclxuICAgIHRoaXMuX2ZyYW1lSWQgPSBudWxsXHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBSdW5uZXJBcnJheSB7XHJcbiAgY29uc3RydWN0b3IgKCkge1xyXG4gICAgdGhpcy5ydW5uZXJzID0gW11cclxuICAgIHRoaXMuaWRzID0gW11cclxuICB9XHJcblxyXG4gIGFkZCAocnVubmVyKSB7XHJcbiAgICBpZiAodGhpcy5ydW5uZXJzLmluY2x1ZGVzKHJ1bm5lcikpIHJldHVyblxyXG4gICAgY29uc3QgaWQgPSBydW5uZXIuaWQgKyAxXHJcblxyXG4gICAgdGhpcy5ydW5uZXJzLnB1c2gocnVubmVyKVxyXG4gICAgdGhpcy5pZHMucHVzaChpZClcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgZ2V0QnlJRCAoaWQpIHtcclxuICAgIHJldHVybiB0aGlzLnJ1bm5lcnNbdGhpcy5pZHMuaW5kZXhPZihpZCArIDEpXVxyXG4gIH1cclxuXHJcbiAgcmVtb3ZlIChpZCkge1xyXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmlkcy5pbmRleE9mKGlkICsgMSlcclxuICAgIHRoaXMuaWRzLnNwbGljZShpbmRleCwgMSlcclxuICAgIHRoaXMucnVubmVycy5zcGxpY2UoaW5kZXgsIDEpXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgbWVyZ2UgKCkge1xyXG4gICAgbGV0IGxhc3RSdW5uZXIgPSBudWxsXHJcbiAgICB0aGlzLnJ1bm5lcnMuZm9yRWFjaCgocnVubmVyLCBpKSA9PiB7XHJcblxyXG4gICAgICBjb25zdCBjb25kaXRpb24gPSBsYXN0UnVubmVyXHJcbiAgICAgICAgJiYgcnVubmVyLmRvbmUgJiYgbGFzdFJ1bm5lci5kb25lXHJcbiAgICAgICAgLy8gZG9uJ3QgbWVyZ2UgcnVubmVyIHdoZW4gcGVyc2lzdGVkIG9uIHRpbWVsaW5lXHJcbiAgICAgICAgJiYgKCFydW5uZXIuX3RpbWVsaW5lIHx8ICFydW5uZXIuX3RpbWVsaW5lLl9ydW5uZXJJZHMuaW5jbHVkZXMocnVubmVyLmlkKSlcclxuICAgICAgICAmJiAoIWxhc3RSdW5uZXIuX3RpbWVsaW5lIHx8ICFsYXN0UnVubmVyLl90aW1lbGluZS5fcnVubmVySWRzLmluY2x1ZGVzKGxhc3RSdW5uZXIuaWQpKVxyXG5cclxuICAgICAgaWYgKGNvbmRpdGlvbikge1xyXG4gICAgICAgIC8vIHRoZSArMSBoYXBwZW5zIGluIHRoZSBmdW5jdGlvblxyXG4gICAgICAgIHRoaXMucmVtb3ZlKHJ1bm5lci5pZClcclxuICAgICAgICB0aGlzLmVkaXQobGFzdFJ1bm5lci5pZCwgcnVubmVyLm1lcmdlV2l0aChsYXN0UnVubmVyKSlcclxuICAgICAgfVxyXG5cclxuICAgICAgbGFzdFJ1bm5lciA9IHJ1bm5lclxyXG4gICAgfSlcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgZWRpdCAoaWQsIG5ld1J1bm5lcikge1xyXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmlkcy5pbmRleE9mKGlkICsgMSlcclxuICAgIHRoaXMuaWRzLnNwbGljZShpbmRleCwgMSwgaWQgKyAxKVxyXG4gICAgdGhpcy5ydW5uZXJzLnNwbGljZShpbmRleCwgMSwgbmV3UnVubmVyKVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIGxlbmd0aCAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pZHMubGVuZ3RoXHJcbiAgfVxyXG5cclxuICBjbGVhckJlZm9yZSAoaWQpIHtcclxuICAgIGNvbnN0IGRlbGV0ZUNudCA9IHRoaXMuaWRzLmluZGV4T2YoaWQgKyAxKSB8fCAxXHJcbiAgICB0aGlzLmlkcy5zcGxpY2UoMCwgZGVsZXRlQ250LCAwKVxyXG4gICAgdGhpcy5ydW5uZXJzLnNwbGljZSgwLCBkZWxldGVDbnQsIG5ldyBGYWtlUnVubmVyKCkpXHJcbiAgICAgIC5mb3JFYWNoKChyKSA9PiByLmNsZWFyVHJhbnNmb3Jtc0Zyb21RdWV1ZSgpKVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcbn1cclxuXHJcbnJlZ2lzdGVyTWV0aG9kcyh7XHJcbiAgRWxlbWVudDoge1xyXG4gICAgYW5pbWF0ZSAoZHVyYXRpb24sIGRlbGF5LCB3aGVuKSB7XHJcbiAgICAgIHZhciBvID0gUnVubmVyLnNhbml0aXNlKGR1cmF0aW9uLCBkZWxheSwgd2hlbilcclxuICAgICAgdmFyIHRpbWVsaW5lID0gdGhpcy50aW1lbGluZSgpXHJcbiAgICAgIHJldHVybiBuZXcgUnVubmVyKG8uZHVyYXRpb24pXHJcbiAgICAgICAgLmxvb3AobylcclxuICAgICAgICAuZWxlbWVudCh0aGlzKVxyXG4gICAgICAgIC50aW1lbGluZSh0aW1lbGluZS5wbGF5KCkpXHJcbiAgICAgICAgLnNjaGVkdWxlKG8uZGVsYXksIG8ud2hlbilcclxuICAgIH0sXHJcblxyXG4gICAgZGVsYXkgKGJ5LCB3aGVuKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoMCwgYnksIHdoZW4pXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHRoaXMgZnVuY3Rpb24gc2VhcmNoZXMgZm9yIGFsbCBydW5uZXJzIG9uIHRoZSBlbGVtZW50IGFuZCBkZWxldGVzIHRoZSBvbmVzXHJcbiAgICAvLyB3aGljaCBydW4gYmVmb3JlIHRoZSBjdXJyZW50IG9uZS4gVGhpcyBpcyBiZWNhdXNlIGFic29sdXRlIHRyYW5zZm9ybWF0aW9uc1xyXG4gICAgLy8gb3Zlcndmcml0ZSBhbnl0aGluZyBhbnl3YXkgc28gdGhlcmUgaXMgbm8gbmVlZCB0byB3YXN0ZSB0aW1lIGNvbXB1dGluZ1xyXG4gICAgLy8gb3RoZXIgcnVubmVyc1xyXG4gICAgX2NsZWFyVHJhbnNmb3JtUnVubmVyc0JlZm9yZSAoY3VycmVudFJ1bm5lcikge1xyXG4gICAgICB0aGlzLl90cmFuc2Zvcm1hdGlvblJ1bm5lcnMuY2xlYXJCZWZvcmUoY3VycmVudFJ1bm5lci5pZClcclxuICAgIH0sXHJcblxyXG4gICAgX2N1cnJlbnRUcmFuc2Zvcm0gKGN1cnJlbnQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybWF0aW9uUnVubmVycy5ydW5uZXJzXHJcbiAgICAgICAgLy8gd2UgbmVlZCB0aGUgZXF1YWwgc2lnbiBoZXJlIHRvIG1ha2Ugc3VyZSwgdGhhdCBhbHNvIHRyYW5zZm9ybWF0aW9uc1xyXG4gICAgICAgIC8vIG9uIHRoZSBzYW1lIHJ1bm5lciB3aGljaCBleGVjdXRlIGJlZm9yZSB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBhcmVcclxuICAgICAgICAvLyB0YWtlbiBpbnRvIGFjY291bnRcclxuICAgICAgICAuZmlsdGVyKChydW5uZXIpID0+IHJ1bm5lci5pZCA8PSBjdXJyZW50LmlkKVxyXG4gICAgICAgIC5tYXAoZ2V0UnVubmVyVHJhbnNmb3JtKVxyXG4gICAgICAgIC5yZWR1Y2UobG11bHRpcGx5LCBuZXcgTWF0cml4KCkpXHJcbiAgICB9LFxyXG5cclxuICAgIF9hZGRSdW5uZXIgKHJ1bm5lcikge1xyXG4gICAgICB0aGlzLl90cmFuc2Zvcm1hdGlvblJ1bm5lcnMuYWRkKHJ1bm5lcilcclxuXHJcbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBydW5uZXIgbWVyZ2UgaXMgZXhlY3V0ZWQgYXQgdGhlIHZlcnkgZW5kIG9mXHJcbiAgICAgIC8vIGFsbCBBbmltYXRvciBmdW5jdGlvbnMuIFRoYXRzIHdoeSB3ZSB1c2UgaW1tZWRpYXRlIGhlcmUgdG8gZXhlY3V0ZVxyXG4gICAgICAvLyB0aGUgbWVyZ2UgcmlnaHQgYWZ0ZXIgYWxsIGZyYW1lcyBhcmUgcnVuXHJcbiAgICAgIEFuaW1hdG9yLmNhbmNlbEltbWVkaWF0ZSh0aGlzLl9mcmFtZUlkKVxyXG4gICAgICB0aGlzLl9mcmFtZUlkID0gQW5pbWF0b3IuaW1tZWRpYXRlKG1lcmdlVHJhbnNmb3Jtcy5iaW5kKHRoaXMpKVxyXG4gICAgfSxcclxuXHJcbiAgICBfcHJlcGFyZVJ1bm5lciAoKSB7XHJcbiAgICAgIGlmICh0aGlzLl9mcmFtZUlkID09IG51bGwpIHtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm1hdGlvblJ1bm5lcnMgPSBuZXcgUnVubmVyQXJyYXkoKVxyXG4gICAgICAgICAgLmFkZChuZXcgRmFrZVJ1bm5lcihuZXcgTWF0cml4KHRoaXMpKSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufSlcclxuXHJcbmV4dGVuZChSdW5uZXIsIHtcclxuICBhdHRyIChhLCB2KSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdHlsZUF0dHIoJ2F0dHInLCBhLCB2KVxyXG4gIH0sXHJcblxyXG4gIC8vIEFkZCBhbmltYXRhYmxlIHN0eWxlc1xyXG4gIGNzcyAocywgdikge1xyXG4gICAgcmV0dXJuIHRoaXMuc3R5bGVBdHRyKCdjc3MnLCBzLCB2KVxyXG4gIH0sXHJcblxyXG4gIHN0eWxlQXR0ciAodHlwZSwgbmFtZSwgdmFsKSB7XHJcbiAgICAvLyBhcHBseSBhdHRyaWJ1dGVzIGluZGl2aWR1YWxseVxyXG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xyXG4gICAgICBmb3IgKHZhciBrZXkgaW4gbmFtZSkge1xyXG4gICAgICAgIHRoaXMuc3R5bGVBdHRyKHR5cGUsIGtleSwgbmFtZVtrZXldKVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG1vcnBoZXIgPSBuZXcgTW9ycGhhYmxlKHRoaXMuX3N0ZXBwZXIpLnRvKHZhbClcclxuXHJcbiAgICB0aGlzLnF1ZXVlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgbW9ycGhlciA9IG1vcnBoZXIuZnJvbSh0aGlzLmVsZW1lbnQoKVt0eXBlXShuYW1lKSlcclxuICAgIH0sIGZ1bmN0aW9uIChwb3MpIHtcclxuICAgICAgdGhpcy5lbGVtZW50KClbdHlwZV0obmFtZSwgbW9ycGhlci5hdChwb3MpKVxyXG4gICAgICByZXR1cm4gbW9ycGhlci5kb25lKClcclxuICAgIH0pXHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9LFxyXG5cclxuICB6b29tIChsZXZlbCwgcG9pbnQpIHtcclxuICAgIGlmICh0aGlzLl90cnlSZXRhcmdldCgnem9vbScsIHRvLCBwb2ludCkpIHJldHVybiB0aGlzXHJcblxyXG4gICAgdmFyIG1vcnBoZXIgPSBuZXcgTW9ycGhhYmxlKHRoaXMuX3N0ZXBwZXIpLnRvKG5ldyBTVkdOdW1iZXIobGV2ZWwpKVxyXG5cclxuICAgIHRoaXMucXVldWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICBtb3JwaGVyID0gbW9ycGhlci5mcm9tKHRoaXMuZWxlbWVudCgpLnpvb20oKSlcclxuICAgIH0sIGZ1bmN0aW9uIChwb3MpIHtcclxuICAgICAgdGhpcy5lbGVtZW50KCkuem9vbShtb3JwaGVyLmF0KHBvcyksIHBvaW50KVxyXG4gICAgICByZXR1cm4gbW9ycGhlci5kb25lKClcclxuICAgIH0sIGZ1bmN0aW9uIChuZXdMZXZlbCwgbmV3UG9pbnQpIHtcclxuICAgICAgcG9pbnQgPSBuZXdQb2ludFxyXG4gICAgICBtb3JwaGVyLnRvKG5ld0xldmVsKVxyXG4gICAgfSlcclxuXHJcbiAgICB0aGlzLl9yZW1lbWJlck1vcnBoZXIoJ3pvb20nLCBtb3JwaGVyKVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiogYWJzb2x1dGUgdHJhbnNmb3JtYXRpb25zXHJcbiAgICoqL1xyXG5cclxuICAvL1xyXG4gIC8vIE0gdiAtLS0tLXwtLS0tLShEIE0gdiA9IEYgdiktLS0tLS18LS0tLS0+ICBUIHZcclxuICAvL1xyXG4gIC8vIDEuIGRlZmluZSB0aGUgZmluYWwgc3RhdGUgKFQpIGFuZCBkZWNvbXBvc2UgaXQgKG9uY2UpXHJcbiAgLy8gICAgdCA9IFt0eCwgdHksIHRoZSwgbGFtLCBzeSwgc3hdXHJcbiAgLy8gMi4gb24gZXZlcnkgZnJhbWU6IHB1bGwgdGhlIGN1cnJlbnQgc3RhdGUgb2YgYWxsIHByZXZpb3VzIHRyYW5zZm9ybXNcclxuICAvLyAgICAoTSAtIG0gY2FuIGNoYW5nZSlcclxuICAvLyAgIGFuZCB0aGVuIHdyaXRlIHRoaXMgYXMgbSA9IFt0eDAsIHR5MCwgdGhlMCwgbGFtMCwgc3kwLCBzeDBdXHJcbiAgLy8gMy4gRmluZCB0aGUgaW50ZXJwb2xhdGVkIG1hdHJpeCBGKHBvcykgPSBtICsgcG9zICogKHQgLSBtKVxyXG4gIC8vICAgLSBOb3RlIEYoMCkgPSBNXHJcbiAgLy8gICAtIE5vdGUgRigxKSA9IFRcclxuICAvLyA0LiBOb3cgeW91IGdldCB0aGUgZGVsdGEgbWF0cml4IGFzIGEgcmVzdWx0OiBEID0gRiAqIGludihNKVxyXG5cclxuICB0cmFuc2Zvcm0gKHRyYW5zZm9ybXMsIHJlbGF0aXZlLCBhZmZpbmUpIHtcclxuICAgIC8vIElmIHdlIGhhdmUgYSBkZWNsYXJhdGl2ZSBmdW5jdGlvbiwgd2Ugc2hvdWxkIHJldGFyZ2V0IGl0IGlmIHBvc3NpYmxlXHJcbiAgICByZWxhdGl2ZSA9IHRyYW5zZm9ybXMucmVsYXRpdmUgfHwgcmVsYXRpdmVcclxuICAgIGlmICh0aGlzLl9pc0RlY2xhcmF0aXZlICYmICFyZWxhdGl2ZSAmJiB0aGlzLl90cnlSZXRhcmdldCgndHJhbnNmb3JtJywgdHJhbnNmb3JtcykpIHtcclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICAvLyBQYXJzZSB0aGUgcGFyYW1ldGVyc1xyXG4gICAgdmFyIGlzTWF0cml4ID0gTWF0cml4LmlzTWF0cml4TGlrZSh0cmFuc2Zvcm1zKVxyXG4gICAgYWZmaW5lID0gdHJhbnNmb3Jtcy5hZmZpbmUgIT0gbnVsbFxyXG4gICAgICA/IHRyYW5zZm9ybXMuYWZmaW5lXHJcbiAgICAgIDogKGFmZmluZSAhPSBudWxsID8gYWZmaW5lIDogIWlzTWF0cml4KVxyXG5cclxuICAgIC8vIENyZWF0ZSBhIG1vcmVwaGVyIGFuZCBzZXQgaXRzIHR5cGVcclxuICAgIGNvbnN0IG1vcnBoZXIgPSBuZXcgTW9ycGhhYmxlKHRoaXMuX3N0ZXBwZXIpXHJcbiAgICAgIC50eXBlKGFmZmluZSA/IFRyYW5zZm9ybUJhZyA6IE1hdHJpeClcclxuXHJcbiAgICBsZXQgb3JpZ2luXHJcbiAgICBsZXQgZWxlbWVudFxyXG4gICAgbGV0IGN1cnJlbnRcclxuICAgIGxldCBjdXJyZW50QW5nbGVcclxuICAgIGxldCBzdGFydFRyYW5zZm9ybVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldHVwICgpIHtcclxuICAgICAgLy8gbWFrZSBzdXJlIGVsZW1lbnQgYW5kIG9yaWdpbiBpcyBkZWZpbmVkXHJcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50IHx8IHRoaXMuZWxlbWVudCgpXHJcbiAgICAgIG9yaWdpbiA9IG9yaWdpbiB8fCBnZXRPcmlnaW4odHJhbnNmb3JtcywgZWxlbWVudClcclxuXHJcbiAgICAgIHN0YXJ0VHJhbnNmb3JtID0gbmV3IE1hdHJpeChyZWxhdGl2ZSA/IHVuZGVmaW5lZCA6IGVsZW1lbnQpXHJcblxyXG4gICAgICAvLyBhZGQgdGhlIHJ1bm5lciB0byB0aGUgZWxlbWVudCBzbyBpdCBjYW4gbWVyZ2UgdHJhbnNmb3JtYXRpb25zXHJcbiAgICAgIGVsZW1lbnQuX2FkZFJ1bm5lcih0aGlzKVxyXG5cclxuICAgICAgLy8gRGVhY3RpdmF0ZSBhbGwgdHJhbnNmb3JtcyB0aGF0IGhhdmUgcnVuIHNvIGZhciBpZiB3ZSBhcmUgYWJzb2x1dGVcclxuICAgICAgaWYgKCFyZWxhdGl2ZSkge1xyXG4gICAgICAgIGVsZW1lbnQuX2NsZWFyVHJhbnNmb3JtUnVubmVyc0JlZm9yZSh0aGlzKVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcnVuIChwb3MpIHtcclxuICAgICAgLy8gY2xlYXIgYWxsIG90aGVyIHRyYW5zZm9ybXMgYmVmb3JlIHRoaXMgaW4gY2FzZSBzb21ldGhpbmcgaXMgc2F2ZWRcclxuICAgICAgLy8gb24gdGhpcyBydW5uZXIuIFdlIGFyZSBhYnNvbHV0ZS4gV2UgZG9udCBuZWVkIHRoZXNlIVxyXG4gICAgICBpZiAoIXJlbGF0aXZlKSB0aGlzLmNsZWFyVHJhbnNmb3JtKClcclxuXHJcbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gbmV3IFBvaW50KG9yaWdpbikudHJhbnNmb3JtKGVsZW1lbnQuX2N1cnJlbnRUcmFuc2Zvcm0odGhpcykpXHJcblxyXG4gICAgICBsZXQgdGFyZ2V0ID0gbmV3IE1hdHJpeCh7IC4uLnRyYW5zZm9ybXMsIG9yaWdpbjogWyB4LCB5IF0gfSlcclxuICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5faXNEZWNsYXJhdGl2ZSAmJiBjdXJyZW50XHJcbiAgICAgICAgPyBjdXJyZW50XHJcbiAgICAgICAgOiBzdGFydFRyYW5zZm9ybVxyXG5cclxuICAgICAgaWYgKGFmZmluZSkge1xyXG4gICAgICAgIHRhcmdldCA9IHRhcmdldC5kZWNvbXBvc2UoeCwgeSlcclxuICAgICAgICBzdGFydCA9IHN0YXJ0LmRlY29tcG9zZSh4LCB5KVxyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgYW5kIHRhcmdldCBhbmdsZSBhcyBpdCB3YXMgc2V0XHJcbiAgICAgICAgY29uc3QgclRhcmdldCA9IHRhcmdldC5yb3RhdGVcclxuICAgICAgICBjb25zdCByQ3VycmVudCA9IHN0YXJ0LnJvdGF0ZVxyXG5cclxuICAgICAgICAvLyBGaWd1cmUgb3V0IHRoZSBzaG9ydGVzdCBwYXRoIHRvIHJvdGF0ZSBkaXJlY3RseVxyXG4gICAgICAgIGNvbnN0IHBvc3NpYmlsaXRpZXMgPSBbIHJUYXJnZXQgLSAzNjAsIHJUYXJnZXQsIHJUYXJnZXQgKyAzNjAgXVxyXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlcyA9IHBvc3NpYmlsaXRpZXMubWFwKGEgPT4gTWF0aC5hYnMoYSAtIHJDdXJyZW50KSlcclxuICAgICAgICBjb25zdCBzaG9ydGVzdCA9IE1hdGgubWluKC4uLmRpc3RhbmNlcylcclxuICAgICAgICBjb25zdCBpbmRleCA9IGRpc3RhbmNlcy5pbmRleE9mKHNob3J0ZXN0KVxyXG4gICAgICAgIHRhcmdldC5yb3RhdGUgPSBwb3NzaWJpbGl0aWVzW2luZGV4XVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAvLyB3ZSBoYXZlIHRvIGJlIGNhcmVmdWwgaGVyZSBub3QgdG8gb3ZlcndyaXRlIHRoZSByb3RhdGlvblxyXG4gICAgICAgIC8vIHdpdGggdGhlIHJvdGF0ZSBtZXRob2Qgb2YgTWF0cml4XHJcbiAgICAgICAgaWYgKCFpc01hdHJpeCkge1xyXG4gICAgICAgICAgdGFyZ2V0LnJvdGF0ZSA9IHRyYW5zZm9ybXMucm90YXRlIHx8IDBcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzRGVjbGFyYXRpdmUgJiYgY3VycmVudEFuZ2xlKSB7XHJcbiAgICAgICAgICBzdGFydC5yb3RhdGUgPSBjdXJyZW50QW5nbGVcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG1vcnBoZXIuZnJvbShzdGFydClcclxuICAgICAgbW9ycGhlci50byh0YXJnZXQpXHJcblxyXG4gICAgICBjb25zdCBhZmZpbmVQYXJhbWV0ZXJzID0gbW9ycGhlci5hdChwb3MpXHJcbiAgICAgIGN1cnJlbnRBbmdsZSA9IGFmZmluZVBhcmFtZXRlcnMucm90YXRlXHJcbiAgICAgIGN1cnJlbnQgPSBuZXcgTWF0cml4KGFmZmluZVBhcmFtZXRlcnMpXHJcblxyXG4gICAgICB0aGlzLmFkZFRyYW5zZm9ybShjdXJyZW50KVxyXG4gICAgICBlbGVtZW50Ll9hZGRSdW5uZXIodGhpcylcclxuICAgICAgcmV0dXJuIG1vcnBoZXIuZG9uZSgpXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmV0YXJnZXQgKG5ld1RyYW5zZm9ybXMpIHtcclxuICAgICAgLy8gb25seSBnZXQgYSBuZXcgb3JpZ2luIGlmIGl0IGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgY2FsbFxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgKG5ld1RyYW5zZm9ybXMub3JpZ2luIHx8ICdjZW50ZXInKS50b1N0cmluZygpXHJcbiAgICAgICAgIT09ICh0cmFuc2Zvcm1zLm9yaWdpbiB8fCAnY2VudGVyJykudG9TdHJpbmcoKVxyXG4gICAgICApIHtcclxuICAgICAgICBvcmlnaW4gPSBnZXRPcmlnaW4odHJhbnNmb3JtcywgZWxlbWVudClcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gb3ZlcndyaXRlIHRoZSBvbGQgdHJhbnNmb3JtYXRpb25zIHdpdGggdGhlIG5ldyBvbmVzXHJcbiAgICAgIHRyYW5zZm9ybXMgPSB7IC4uLm5ld1RyYW5zZm9ybXMsIG9yaWdpbiB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5xdWV1ZShzZXR1cCwgcnVuLCByZXRhcmdldCwgdHJ1ZSlcclxuICAgIHRoaXMuX2lzRGVjbGFyYXRpdmUgJiYgdGhpcy5fcmVtZW1iZXJNb3JwaGVyKCd0cmFuc2Zvcm0nLCBtb3JwaGVyKVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9LFxyXG5cclxuICAvLyBBbmltYXRhYmxlIHgtYXhpc1xyXG4gIHggKHgsIHJlbGF0aXZlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcXVldWVOdW1iZXIoJ3gnLCB4KVxyXG4gIH0sXHJcblxyXG4gIC8vIEFuaW1hdGFibGUgeS1heGlzXHJcbiAgeSAoeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlTnVtYmVyKCd5JywgeSlcclxuICB9LFxyXG5cclxuICBkeCAoeCA9IDApIHtcclxuICAgIHJldHVybiB0aGlzLl9xdWV1ZU51bWJlckRlbHRhKCd4JywgeClcclxuICB9LFxyXG5cclxuICBkeSAoeSA9IDApIHtcclxuICAgIHJldHVybiB0aGlzLl9xdWV1ZU51bWJlckRlbHRhKCd5JywgeSlcclxuICB9LFxyXG5cclxuICBkbW92ZSAoeCwgeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuZHgoeCkuZHkoeSlcclxuICB9LFxyXG5cclxuICBfcXVldWVOdW1iZXJEZWx0YSAobWV0aG9kLCB0bykge1xyXG4gICAgdG8gPSBuZXcgU1ZHTnVtYmVyKHRvKVxyXG5cclxuICAgIC8vIFRyeSB0byBjaGFuZ2UgdGhlIHRhcmdldCBpZiB3ZSBoYXZlIHRoaXMgbWV0aG9kIGFscmVhZHkgcmVnaXN0ZXJkXHJcbiAgICBpZiAodGhpcy5fdHJ5UmV0YXJnZXQobWV0aG9kLCB0bykpIHJldHVybiB0aGlzXHJcblxyXG4gICAgLy8gTWFrZSBhIG1vcnBoZXIgYW5kIHF1ZXVlIHRoZSBhbmltYXRpb25cclxuICAgIHZhciBtb3JwaGVyID0gbmV3IE1vcnBoYWJsZSh0aGlzLl9zdGVwcGVyKS50byh0bylcclxuICAgIHZhciBmcm9tID0gbnVsbFxyXG4gICAgdGhpcy5xdWV1ZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGZyb20gPSB0aGlzLmVsZW1lbnQoKVttZXRob2RdKClcclxuICAgICAgbW9ycGhlci5mcm9tKGZyb20pXHJcbiAgICAgIG1vcnBoZXIudG8oZnJvbSArIHRvKVxyXG4gICAgfSwgZnVuY3Rpb24gKHBvcykge1xyXG4gICAgICB0aGlzLmVsZW1lbnQoKVttZXRob2RdKG1vcnBoZXIuYXQocG9zKSlcclxuICAgICAgcmV0dXJuIG1vcnBoZXIuZG9uZSgpXHJcbiAgICB9LCBmdW5jdGlvbiAobmV3VG8pIHtcclxuICAgICAgbW9ycGhlci50byhmcm9tICsgbmV3IFNWR051bWJlcihuZXdUbykpXHJcbiAgICB9KVxyXG5cclxuICAgIC8vIFJlZ2lzdGVyIHRoZSBtb3JwaGVyIHNvIHRoYXQgaWYgaXQgaXMgY2hhbmdlZCBhZ2Fpbiwgd2UgY2FuIHJldGFyZ2V0IGl0XHJcbiAgICB0aGlzLl9yZW1lbWJlck1vcnBoZXIobWV0aG9kLCBtb3JwaGVyKVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9LFxyXG5cclxuICBfcXVldWVPYmplY3QgKG1ldGhvZCwgdG8pIHtcclxuICAgIC8vIFRyeSB0byBjaGFuZ2UgdGhlIHRhcmdldCBpZiB3ZSBoYXZlIHRoaXMgbWV0aG9kIGFscmVhZHkgcmVnaXN0ZXJkXHJcbiAgICBpZiAodGhpcy5fdHJ5UmV0YXJnZXQobWV0aG9kLCB0bykpIHJldHVybiB0aGlzXHJcblxyXG4gICAgLy8gTWFrZSBhIG1vcnBoZXIgYW5kIHF1ZXVlIHRoZSBhbmltYXRpb25cclxuICAgIHZhciBtb3JwaGVyID0gbmV3IE1vcnBoYWJsZSh0aGlzLl9zdGVwcGVyKS50byh0bylcclxuICAgIHRoaXMucXVldWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICBtb3JwaGVyLmZyb20odGhpcy5lbGVtZW50KClbbWV0aG9kXSgpKVxyXG4gICAgfSwgZnVuY3Rpb24gKHBvcykge1xyXG4gICAgICB0aGlzLmVsZW1lbnQoKVttZXRob2RdKG1vcnBoZXIuYXQocG9zKSlcclxuICAgICAgcmV0dXJuIG1vcnBoZXIuZG9uZSgpXHJcbiAgICB9KVxyXG5cclxuICAgIC8vIFJlZ2lzdGVyIHRoZSBtb3JwaGVyIHNvIHRoYXQgaWYgaXQgaXMgY2hhbmdlZCBhZ2Fpbiwgd2UgY2FuIHJldGFyZ2V0IGl0XHJcbiAgICB0aGlzLl9yZW1lbWJlck1vcnBoZXIobWV0aG9kLCBtb3JwaGVyKVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9LFxyXG5cclxuICBfcXVldWVOdW1iZXIgKG1ldGhvZCwgdmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLl9xdWV1ZU9iamVjdChtZXRob2QsIG5ldyBTVkdOdW1iZXIodmFsdWUpKVxyXG4gIH0sXHJcblxyXG4gIC8vIEFuaW1hdGFibGUgY2VudGVyIHgtYXhpc1xyXG4gIGN4ICh4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcXVldWVOdW1iZXIoJ2N4JywgeClcclxuICB9LFxyXG5cclxuICAvLyBBbmltYXRhYmxlIGNlbnRlciB5LWF4aXNcclxuICBjeSAoeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlTnVtYmVyKCdjeScsIHkpXHJcbiAgfSxcclxuXHJcbiAgLy8gQWRkIGFuaW1hdGFibGUgbW92ZVxyXG4gIG1vdmUgKHgsIHkpIHtcclxuICAgIHJldHVybiB0aGlzLngoeCkueSh5KVxyXG4gIH0sXHJcblxyXG4gIC8vIEFkZCBhbmltYXRhYmxlIGNlbnRlclxyXG4gIGNlbnRlciAoeCwgeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuY3goeCkuY3koeSlcclxuICB9LFxyXG5cclxuICAvLyBBZGQgYW5pbWF0YWJsZSBzaXplXHJcbiAgc2l6ZSAod2lkdGgsIGhlaWdodCkge1xyXG4gICAgLy8gYW5pbWF0ZSBiYm94IGJhc2VkIHNpemUgZm9yIGFsbCBvdGhlciBlbGVtZW50c1xyXG4gICAgdmFyIGJveFxyXG5cclxuICAgIGlmICghd2lkdGggfHwgIWhlaWdodCkge1xyXG4gICAgICBib3ggPSB0aGlzLl9lbGVtZW50LmJib3goKVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghd2lkdGgpIHtcclxuICAgICAgd2lkdGggPSBib3gud2lkdGggLyBib3guaGVpZ2h0ICogaGVpZ2h0XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFoZWlnaHQpIHtcclxuICAgICAgaGVpZ2h0ID0gYm94LmhlaWdodCAvIGJveC53aWR0aCAqIHdpZHRoXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICAgICAgLndpZHRoKHdpZHRoKVxyXG4gICAgICAuaGVpZ2h0KGhlaWdodClcclxuICB9LFxyXG5cclxuICAvLyBBZGQgYW5pbWF0YWJsZSB3aWR0aFxyXG4gIHdpZHRoICh3aWR0aCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlTnVtYmVyKCd3aWR0aCcsIHdpZHRoKVxyXG4gIH0sXHJcblxyXG4gIC8vIEFkZCBhbmltYXRhYmxlIGhlaWdodFxyXG4gIGhlaWdodCAoaGVpZ2h0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcXVldWVOdW1iZXIoJ2hlaWdodCcsIGhlaWdodClcclxuICB9LFxyXG5cclxuICAvLyBBZGQgYW5pbWF0YWJsZSBwbG90XHJcbiAgcGxvdCAoYSwgYiwgYywgZCkge1xyXG4gICAgLy8gTGluZXMgY2FuIGJlIHBsb3R0ZWQgd2l0aCA0IGFyZ3VtZW50c1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucGxvdChbIGEsIGIsIGMsIGQgXSlcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fdHJ5UmV0YXJnZXQoJ3Bsb3QnLCBhKSkgcmV0dXJuIHRoaXNcclxuXHJcbiAgICB2YXIgbW9ycGhlciA9IG5ldyBNb3JwaGFibGUodGhpcy5fc3RlcHBlcilcclxuICAgICAgLnR5cGUodGhpcy5fZWxlbWVudC5Nb3JwaEFycmF5KS50byhhKVxyXG5cclxuICAgIHRoaXMucXVldWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICBtb3JwaGVyLmZyb20odGhpcy5fZWxlbWVudC5hcnJheSgpKVxyXG4gICAgfSwgZnVuY3Rpb24gKHBvcykge1xyXG4gICAgICB0aGlzLl9lbGVtZW50LnBsb3QobW9ycGhlci5hdChwb3MpKVxyXG4gICAgICByZXR1cm4gbW9ycGhlci5kb25lKClcclxuICAgIH0pXHJcblxyXG4gICAgdGhpcy5fcmVtZW1iZXJNb3JwaGVyKCdwbG90JywgbW9ycGhlcilcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfSxcclxuXHJcbiAgLy8gQWRkIGxlYWRpbmcgbWV0aG9kXHJcbiAgbGVhZGluZyAodmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLl9xdWV1ZU51bWJlcignbGVhZGluZycsIHZhbHVlKVxyXG4gIH0sXHJcblxyXG4gIC8vIEFkZCBhbmltYXRhYmxlIHZpZXdib3hcclxuICB2aWV3Ym94ICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcXVldWVPYmplY3QoJ3ZpZXdib3gnLCBuZXcgQm94KHgsIHksIHdpZHRoLCBoZWlnaHQpKVxyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZSAobykge1xyXG4gICAgaWYgKHR5cGVvZiBvICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICByZXR1cm4gdGhpcy51cGRhdGUoe1xyXG4gICAgICAgIG9mZnNldDogYXJndW1lbnRzWzBdLFxyXG4gICAgICAgIGNvbG9yOiBhcmd1bWVudHNbMV0sXHJcbiAgICAgICAgb3BhY2l0eTogYXJndW1lbnRzWzJdXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG8ub3BhY2l0eSAhPSBudWxsKSB0aGlzLmF0dHIoJ3N0b3Atb3BhY2l0eScsIG8ub3BhY2l0eSlcclxuICAgIGlmIChvLmNvbG9yICE9IG51bGwpIHRoaXMuYXR0cignc3RvcC1jb2xvcicsIG8uY29sb3IpXHJcbiAgICBpZiAoby5vZmZzZXQgIT0gbnVsbCkgdGhpcy5hdHRyKCdvZmZzZXQnLCBvLm9mZnNldClcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxufSlcclxuXHJcbmV4dGVuZChSdW5uZXIsIHsgcngsIHJ5LCBmcm9tLCB0byB9KVxyXG5yZWdpc3RlcihSdW5uZXIsICdSdW5uZXInKVxyXG4iLCJpbXBvcnQge1xyXG4gIGFkb3B0LFxyXG4gIG5vZGVPck5ldyxcclxuICByZWdpc3RlcixcclxuICB3cmFwV2l0aEF0dHJDaGVja1xyXG59IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IG5zLCBzdmdqcywgeGxpbmssIHhtbG5zIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL25hbWVzcGFjZXMuanMnXHJcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXHJcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi9Db250YWluZXIuanMnXHJcbmltcG9ydCBEZWZzIGZyb20gJy4vRGVmcy5qcydcclxuaW1wb3J0IHsgZ2xvYmFscyB9IGZyb20gJy4uL3V0aWxzL3dpbmRvdy5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN2ZyBleHRlbmRzIENvbnRhaW5lciB7XHJcbiAgY29uc3RydWN0b3IgKG5vZGUpIHtcclxuICAgIHN1cGVyKG5vZGVPck5ldygnc3ZnJywgbm9kZSksIG5vZGUpXHJcbiAgICB0aGlzLm5hbWVzcGFjZSgpXHJcbiAgfVxyXG5cclxuICBpc1Jvb3QgKCkge1xyXG4gICAgcmV0dXJuICF0aGlzLm5vZGUucGFyZW50Tm9kZVxyXG4gICAgICB8fCAhKHRoaXMubm9kZS5wYXJlbnROb2RlIGluc3RhbmNlb2YgZ2xvYmFscy53aW5kb3cuU1ZHRWxlbWVudClcclxuICAgICAgfHwgdGhpcy5ub2RlLnBhcmVudE5vZGUubm9kZU5hbWUgPT09ICcjZG9jdW1lbnQnXHJcbiAgfVxyXG5cclxuICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgcm9vdCBzdmdcclxuICAvLyBJZiBub3QsIGNhbGwgZG9jcyBmcm9tIHRoaXMgZWxlbWVudFxyXG4gIHJvb3QgKCkge1xyXG4gICAgaWYgKHRoaXMuaXNSb290KCkpIHJldHVybiB0aGlzXHJcbiAgICByZXR1cm4gc3VwZXIucm9vdCgpXHJcbiAgfVxyXG5cclxuICAvLyBBZGQgbmFtZXNwYWNlc1xyXG4gIG5hbWVzcGFjZSAoKSB7XHJcbiAgICBpZiAoIXRoaXMuaXNSb290KCkpIHJldHVybiB0aGlzLnJvb3QoKS5uYW1lc3BhY2UoKVxyXG4gICAgcmV0dXJuIHRoaXNcclxuICAgICAgLmF0dHIoeyB4bWxuczogbnMsIHZlcnNpb246ICcxLjEnIH0pXHJcbiAgICAgIC5hdHRyKCd4bWxuczp4bGluaycsIHhsaW5rLCB4bWxucylcclxuICAgICAgLmF0dHIoJ3htbG5zOnN2Z2pzJywgc3ZnanMsIHhtbG5zKVxyXG4gIH1cclxuXHJcbiAgLy8gQ3JlYXRlcyBhbmQgcmV0dXJucyBkZWZzIGVsZW1lbnRcclxuICBkZWZzICgpIHtcclxuICAgIGlmICghdGhpcy5pc1Jvb3QoKSkgcmV0dXJuIHRoaXMucm9vdCgpLmRlZnMoKVxyXG5cclxuICAgIHJldHVybiBhZG9wdCh0aGlzLm5vZGUucXVlcnlTZWxlY3RvcignZGVmcycpKVxyXG4gICAgICB8fCB0aGlzLnB1dChuZXcgRGVmcygpKVxyXG4gIH1cclxuXHJcbiAgLy8gY3VzdG9tIHBhcmVudCBtZXRob2RcclxuICBwYXJlbnQgKHR5cGUpIHtcclxuICAgIGlmICh0aGlzLmlzUm9vdCgpKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZSA9PT0gJyNkb2N1bWVudCdcclxuICAgICAgICA/IG51bGxcclxuICAgICAgICA6IGFkb3B0KHRoaXMubm9kZS5wYXJlbnROb2RlKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdXBlci5wYXJlbnQodHlwZSlcclxuICB9XHJcblxyXG4gIGNsZWFyICgpIHtcclxuICAgIC8vIHJlbW92ZSBjaGlsZHJlblxyXG4gICAgd2hpbGUgKHRoaXMubm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcclxuICAgICAgdGhpcy5ub2RlLnJlbW92ZUNoaWxkKHRoaXMubm9kZS5sYXN0Q2hpbGQpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmVtb3ZlIGRlZnMgcmVmZXJlbmNlXHJcbiAgICBkZWxldGUgdGhpcy5fZGVmc1xyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG59XHJcblxyXG5yZWdpc3Rlck1ldGhvZHMoe1xyXG4gIENvbnRhaW5lcjoge1xyXG4gICAgLy8gQ3JlYXRlIG5lc3RlZCBzdmcgZG9jdW1lbnRcclxuICAgIG5lc3RlZDogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFN2ZygpKVxyXG4gICAgfSlcclxuICB9XHJcbn0pXHJcblxyXG5yZWdpc3RlcihTdmcsICdTdmcnLCB0cnVlKVxyXG4iLCJpbXBvcnQgeyBub2RlT3JOZXcsIHJlZ2lzdGVyLCB3cmFwV2l0aEF0dHJDaGVjayB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXHJcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi9Db250YWluZXIuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTeW1ib2wgZXh0ZW5kcyBDb250YWluZXIge1xyXG4gIC8vIEluaXRpYWxpemUgbm9kZVxyXG4gIGNvbnN0cnVjdG9yIChub2RlKSB7XHJcbiAgICBzdXBlcihub2RlT3JOZXcoJ3N5bWJvbCcsIG5vZGUpLCBub2RlKVxyXG4gIH1cclxufVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKHtcclxuICBDb250YWluZXI6IHtcclxuICAgIHN5bWJvbDogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFN5bWJvbCgpKVxyXG4gICAgfSlcclxuICB9XHJcbn0pXHJcblxyXG5yZWdpc3RlcihTeW1ib2wsICdTeW1ib2wnKVxyXG4iLCJpbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi4vLi4vdXRpbHMvd2luZG93LmpzJ1xyXG5cclxuLy8gQ3JlYXRlIHBsYWluIHRleHQgbm9kZVxyXG5leHBvcnQgZnVuY3Rpb24gcGxhaW4gKHRleHQpIHtcclxuICAvLyBjbGVhciBpZiBidWlsZCBtb2RlIGlzIGRpc2FibGVkXHJcbiAgaWYgKHRoaXMuX2J1aWxkID09PSBmYWxzZSkge1xyXG4gICAgdGhpcy5jbGVhcigpXHJcbiAgfVxyXG5cclxuICAvLyBjcmVhdGUgdGV4dCBub2RlXHJcbiAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGdsb2JhbHMuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpXHJcblxyXG4gIHJldHVybiB0aGlzXHJcbn1cclxuXHJcbi8vIEdldCBsZW5ndGggb2YgdGV4dCBlbGVtZW50XHJcbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGggKCkge1xyXG4gIHJldHVybiB0aGlzLm5vZGUuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKClcclxufVxyXG4iLCJpbXBvcnQge1xyXG4gIGFkb3B0LFxyXG4gIGV4dGVuZCxcclxuICBub2RlT3JOZXcsXHJcbiAgcmVnaXN0ZXIsXHJcbiAgd3JhcFdpdGhBdHRyQ2hlY2tcclxufSBmcm9tICcuLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xyXG5pbXBvcnQgU1ZHTnVtYmVyIGZyb20gJy4uL3R5cGVzL1NWR051bWJlci5qcydcclxuaW1wb3J0IFNoYXBlIGZyb20gJy4vU2hhcGUuanMnXHJcbmltcG9ydCB7IGdsb2JhbHMgfSBmcm9tICcuLi91dGlscy93aW5kb3cuanMnXHJcbmltcG9ydCAqIGFzIHRleHRhYmxlIGZyb20gJy4uL21vZHVsZXMvY29yZS90ZXh0YWJsZS5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHQgZXh0ZW5kcyBTaGFwZSB7XHJcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXHJcbiAgY29uc3RydWN0b3IgKG5vZGUpIHtcclxuICAgIHN1cGVyKG5vZGVPck5ldygndGV4dCcsIG5vZGUpLCBub2RlKVxyXG5cclxuICAgIHRoaXMuZG9tLmxlYWRpbmcgPSBuZXcgU1ZHTnVtYmVyKDEuMykgLy8gc3RvcmUgbGVhZGluZyB2YWx1ZSBmb3IgcmVidWlsZGluZ1xyXG4gICAgdGhpcy5fcmVidWlsZCA9IHRydWUgLy8gZW5hYmxlIGF1dG9tYXRpYyB1cGRhdGluZyBvZiBkeSB2YWx1ZXNcclxuICAgIHRoaXMuX2J1aWxkID0gZmFsc2UgLy8gZGlzYWJsZSBidWlsZCBtb2RlIGZvciBhZGRpbmcgbXVsdGlwbGUgbGluZXNcclxuICB9XHJcblxyXG4gIC8vIE1vdmUgb3ZlciB4LWF4aXNcclxuICAvLyBUZXh0IGlzIG1vdmVkIGl0cyBib3VuZGluZyBib3hcclxuICAvLyB0ZXh0LWFuY2hvciBkb2VzIE5PVCBtYXR0ZXJcclxuICB4ICh4LCBib3ggPSB0aGlzLmJib3goKSkge1xyXG4gICAgaWYgKHggPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gYm94LnhcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCd4JywgdGhpcy5hdHRyKCd4JykgKyB4IC0gYm94LngpXHJcbiAgfVxyXG5cclxuICAvLyBNb3ZlIG92ZXIgeS1heGlzXHJcbiAgeSAoeSwgYm94ID0gdGhpcy5iYm94KCkpIHtcclxuICAgIGlmICh5ID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIGJveC55XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuYXR0cigneScsIHRoaXMuYXR0cigneScpICsgeSAtIGJveC55KVxyXG4gIH1cclxuXHJcbiAgbW92ZSAoeCwgeSwgYm94ID0gdGhpcy5iYm94KCkpIHtcclxuICAgIHJldHVybiB0aGlzLngoeCwgYm94KS55KHksIGJveClcclxuICB9XHJcblxyXG4gIC8vIE1vdmUgY2VudGVyIG92ZXIgeC1heGlzXHJcbiAgY3ggKHgsIGJveCA9IHRoaXMuYmJveCgpKSB7XHJcbiAgICBpZiAoeCA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBib3guY3hcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCd4JywgdGhpcy5hdHRyKCd4JykgKyB4IC0gYm94LmN4KVxyXG4gIH1cclxuXHJcbiAgLy8gTW92ZSBjZW50ZXIgb3ZlciB5LWF4aXNcclxuICBjeSAoeSwgYm94ID0gdGhpcy5iYm94KCkpIHtcclxuICAgIGlmICh5ID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIGJveC5jeVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ3knLCB0aGlzLmF0dHIoJ3knKSArIHkgLSBib3guY3kpXHJcbiAgfVxyXG5cclxuICBjZW50ZXIgKHgsIHksIGJveCA9IHRoaXMuYmJveCgpKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jeCh4LCBib3gpLmN5KHksIGJveClcclxuICB9XHJcblxyXG4gIC8vIFNldCB0aGUgdGV4dCBjb250ZW50XHJcbiAgdGV4dCAodGV4dCkge1xyXG4gICAgLy8gYWN0IGFzIGdldHRlclxyXG4gICAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLm5vZGUuY2hpbGROb2Rlc1xyXG4gICAgICB2YXIgZmlyc3RMaW5lID0gMFxyXG4gICAgICB0ZXh0ID0gJydcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICAgIC8vIHNraXAgdGV4dFBhdGhzIC0gdGhleSBhcmUgbm8gbGluZXNcclxuICAgICAgICBpZiAoY2hpbGRyZW5baV0ubm9kZU5hbWUgPT09ICd0ZXh0UGF0aCcpIHtcclxuICAgICAgICAgIGlmIChpID09PSAwKSBmaXJzdExpbmUgPSAxXHJcbiAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYWRkIG5ld2xpbmUgaWYgaXRzIG5vdCB0aGUgZmlyc3QgY2hpbGQgYW5kIG5ld0xpbmVkIGlzIHNldCB0byB0cnVlXHJcbiAgICAgICAgaWYgKGkgIT09IGZpcnN0TGluZSAmJiBjaGlsZHJlbltpXS5ub2RlVHlwZSAhPT0gMyAmJiBhZG9wdChjaGlsZHJlbltpXSkuZG9tLm5ld0xpbmVkID09PSB0cnVlKSB7XHJcbiAgICAgICAgICB0ZXh0ICs9ICdcXG4nXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhZGQgY29udGVudCBvZiB0aGlzIG5vZGVcclxuICAgICAgICB0ZXh0ICs9IGNoaWxkcmVuW2ldLnRleHRDb250ZW50XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0ZXh0XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmVtb3ZlIGV4aXN0aW5nIGNvbnRlbnRcclxuICAgIHRoaXMuY2xlYXIoKS5idWlsZCh0cnVlKVxyXG5cclxuICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAvLyBjYWxsIGJsb2NrXHJcbiAgICAgIHRleHQuY2FsbCh0aGlzLCB0aGlzKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gc3RvcmUgdGV4dCBhbmQgbWFrZSBzdXJlIHRleHQgaXMgbm90IGJsYW5rXHJcbiAgICAgIHRleHQgPSB0ZXh0LnNwbGl0KCdcXG4nKVxyXG5cclxuICAgICAgLy8gYnVpbGQgbmV3IGxpbmVzXHJcbiAgICAgIGZvciAodmFyIGogPSAwLCBqbCA9IHRleHQubGVuZ3RoOyBqIDwgamw7IGorKykge1xyXG4gICAgICAgIHRoaXMudHNwYW4odGV4dFtqXSkubmV3TGluZSgpXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBkaXNhYmxlIGJ1aWxkIG1vZGUgYW5kIHJlYnVpbGQgbGluZXNcclxuICAgIHJldHVybiB0aGlzLmJ1aWxkKGZhbHNlKS5yZWJ1aWxkKClcclxuICB9XHJcblxyXG4gIC8vIFNldCAvIGdldCBsZWFkaW5nXHJcbiAgbGVhZGluZyAodmFsdWUpIHtcclxuICAgIC8vIGFjdCBhcyBnZXR0ZXJcclxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRvbS5sZWFkaW5nXHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWN0IGFzIHNldHRlclxyXG4gICAgdGhpcy5kb20ubGVhZGluZyA9IG5ldyBTVkdOdW1iZXIodmFsdWUpXHJcblxyXG4gICAgcmV0dXJuIHRoaXMucmVidWlsZCgpXHJcbiAgfVxyXG5cclxuICAvLyBSZWJ1aWxkIGFwcGVhcmFuY2UgdHlwZVxyXG4gIHJlYnVpbGQgKHJlYnVpbGQpIHtcclxuICAgIC8vIHN0b3JlIG5ldyByZWJ1aWxkIGZsYWcgaWYgZ2l2ZW5cclxuICAgIGlmICh0eXBlb2YgcmVidWlsZCA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgIHRoaXMuX3JlYnVpbGQgPSByZWJ1aWxkXHJcbiAgICB9XHJcblxyXG4gICAgLy8gZGVmaW5lIHBvc2l0aW9uIG9mIGFsbCBsaW5lc1xyXG4gICAgaWYgKHRoaXMuX3JlYnVpbGQpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzXHJcbiAgICAgIHZhciBibGFua0xpbmVPZmZzZXQgPSAwXHJcbiAgICAgIHZhciBsZWFkaW5nID0gdGhpcy5kb20ubGVhZGluZ1xyXG5cclxuICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZm9udFNpemUgPSBnbG9iYWxzLndpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMubm9kZSlcclxuICAgICAgICAgIC5nZXRQcm9wZXJ0eVZhbHVlKCdmb250LXNpemUnKVxyXG4gICAgICAgIHZhciBkeSA9IGxlYWRpbmcgKiBuZXcgU1ZHTnVtYmVyKGZvbnRTaXplKVxyXG5cclxuICAgICAgICBpZiAodGhpcy5kb20ubmV3TGluZWQpIHtcclxuICAgICAgICAgIHRoaXMuYXR0cigneCcsIHNlbGYuYXR0cigneCcpKVxyXG5cclxuICAgICAgICAgIGlmICh0aGlzLnRleHQoKSA9PT0gJ1xcbicpIHtcclxuICAgICAgICAgICAgYmxhbmtMaW5lT2Zmc2V0ICs9IGR5XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmF0dHIoJ2R5JywgZHkgKyBibGFua0xpbmVPZmZzZXQpXHJcbiAgICAgICAgICAgIGJsYW5rTGluZU9mZnNldCA9IDBcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcblxyXG4gICAgICB0aGlzLmZpcmUoJ3JlYnVpbGQnKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvLyBFbmFibGUgLyBkaXNhYmxlIGJ1aWxkIG1vZGVcclxuICBidWlsZCAoYnVpbGQpIHtcclxuICAgIHRoaXMuX2J1aWxkID0gISFidWlsZFxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIC8vIG92ZXJ3cml0ZSBtZXRob2QgZnJvbSBwYXJlbnQgdG8gc2V0IGRhdGEgcHJvcGVybHlcclxuICBzZXREYXRhIChvKSB7XHJcbiAgICB0aGlzLmRvbSA9IG9cclxuICAgIHRoaXMuZG9tLmxlYWRpbmcgPSBuZXcgU1ZHTnVtYmVyKG8ubGVhZGluZyB8fCAxLjMpXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxufVxyXG5cclxuZXh0ZW5kKFRleHQsIHRleHRhYmxlKVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKHtcclxuICBDb250YWluZXI6IHtcclxuICAgIC8vIENyZWF0ZSB0ZXh0IGVsZW1lbnRcclxuICAgIHRleHQ6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgVGV4dCgpKS50ZXh0KHRleHQpXHJcbiAgICB9KSxcclxuXHJcbiAgICAvLyBDcmVhdGUgcGxhaW4gdGV4dCBlbGVtZW50XHJcbiAgICBwbGFpbjogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHRleHQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBUZXh0KCkpLnBsYWluKHRleHQpXHJcbiAgICB9KVxyXG4gIH1cclxufSlcclxuXHJcbnJlZ2lzdGVyKFRleHQsICdUZXh0JylcclxuIiwiaW1wb3J0IHtcclxuICBleHRlbmQsXHJcbiAgbm9kZU9yTmV3LFxyXG4gIHJlZ2lzdGVyLFxyXG4gIHdyYXBXaXRoQXR0ckNoZWNrXHJcbn0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcclxuaW1wb3J0IHsgZ2xvYmFscyB9IGZyb20gJy4uL3V0aWxzL3dpbmRvdy5qcydcclxuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcclxuaW1wb3J0IFNWR051bWJlciBmcm9tICcuLi90eXBlcy9TVkdOdW1iZXIuanMnXHJcbmltcG9ydCBUZXh0IGZyb20gJy4vVGV4dC5qcydcclxuaW1wb3J0ICogYXMgdGV4dGFibGUgZnJvbSAnLi4vbW9kdWxlcy9jb3JlL3RleHRhYmxlLmpzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHNwYW4gZXh0ZW5kcyBUZXh0IHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjb25zdHJ1Y3RvciAobm9kZSkge1xyXG4gICAgc3VwZXIobm9kZU9yTmV3KCd0c3BhbicsIG5vZGUpLCBub2RlKVxyXG4gIH1cclxuXHJcbiAgLy8gU2V0IHRleHQgY29udGVudFxyXG4gIHRleHQgKHRleHQpIHtcclxuICAgIGlmICh0ZXh0ID09IG51bGwpIHJldHVybiB0aGlzLm5vZGUudGV4dENvbnRlbnQgKyAodGhpcy5kb20ubmV3TGluZWQgPyAnXFxuJyA6ICcnKVxyXG5cclxuICAgIHR5cGVvZiB0ZXh0ID09PSAnZnVuY3Rpb24nID8gdGV4dC5jYWxsKHRoaXMsIHRoaXMpIDogdGhpcy5wbGFpbih0ZXh0KVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvLyBTaG9ydGN1dCBkeFxyXG4gIGR4IChkeCkge1xyXG4gICAgcmV0dXJuIHRoaXMuYXR0cignZHgnLCBkeClcclxuICB9XHJcblxyXG4gIC8vIFNob3J0Y3V0IGR5XHJcbiAgZHkgKGR5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdkeScsIGR5KVxyXG4gIH1cclxuXHJcbiAgeCAoeCkge1xyXG4gICAgcmV0dXJuIHRoaXMuYXR0cigneCcsIHgpXHJcbiAgfVxyXG5cclxuICB5ICh5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCd4JywgeSlcclxuICB9XHJcblxyXG4gIG1vdmUgKHgsIHkpIHtcclxuICAgIHJldHVybiB0aGlzLngoeCkueSh5KVxyXG4gIH1cclxuXHJcbiAgLy8gQ3JlYXRlIG5ldyBsaW5lXHJcbiAgbmV3TGluZSAoKSB7XHJcbiAgICAvLyBmZXRjaCB0ZXh0IHBhcmVudFxyXG4gICAgdmFyIHQgPSB0aGlzLnBhcmVudChUZXh0KVxyXG5cclxuICAgIC8vIG1hcmsgbmV3IGxpbmVcclxuICAgIHRoaXMuZG9tLm5ld0xpbmVkID0gdHJ1ZVxyXG5cclxuICAgIHZhciBmb250U2l6ZSA9IGdsb2JhbHMud2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5ub2RlKVxyXG4gICAgICAuZ2V0UHJvcGVydHlWYWx1ZSgnZm9udC1zaXplJylcclxuICAgIHZhciBkeSA9IHQuZG9tLmxlYWRpbmcgKiBuZXcgU1ZHTnVtYmVyKGZvbnRTaXplKVxyXG5cclxuICAgIC8vIGFwcGx5IG5ldyBwb3NpdGlvblxyXG4gICAgcmV0dXJuIHRoaXMuZHkoZHkpLmF0dHIoJ3gnLCB0LngoKSlcclxuICB9XHJcbn1cclxuXHJcbmV4dGVuZChUc3BhbiwgdGV4dGFibGUpXHJcblxyXG5yZWdpc3Rlck1ldGhvZHMoe1xyXG4gIFRzcGFuOiB7XHJcbiAgICB0c3Bhbjogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHRleHQpIHtcclxuICAgICAgdmFyIHRzcGFuID0gbmV3IFRzcGFuKClcclxuXHJcbiAgICAgIC8vIGNsZWFyIGlmIGJ1aWxkIG1vZGUgaXMgZGlzYWJsZWRcclxuICAgICAgaWYgKCF0aGlzLl9idWlsZCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXIoKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBhZGQgbmV3IHRzcGFuXHJcbiAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0c3Bhbi5ub2RlKVxyXG5cclxuICAgICAgcmV0dXJuIHRzcGFuLnRleHQodGV4dClcclxuICAgIH0pXHJcbiAgfVxyXG59KVxyXG5cclxucmVnaXN0ZXIoVHNwYW4sICdUc3BhbicpXHJcbiIsImltcG9ydCB7IG5vZGVPck5ldywgcmVnaXN0ZXIsIHdyYXBXaXRoQXR0ckNoZWNrIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcclxuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcclxuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL0NvbnRhaW5lci5qcydcclxuaW1wb3J0IGJhc2VGaW5kIGZyb20gJy4uL21vZHVsZXMvY29yZS9zZWxlY3Rvci5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENsaXBQYXRoIGV4dGVuZHMgQ29udGFpbmVyIHtcclxuICBjb25zdHJ1Y3RvciAobm9kZSkge1xyXG4gICAgc3VwZXIobm9kZU9yTmV3KCdjbGlwUGF0aCcsIG5vZGUpLCBub2RlKVxyXG4gIH1cclxuXHJcbiAgLy8gVW5jbGlwIGFsbCBjbGlwcGVkIGVsZW1lbnRzIGFuZCByZW1vdmUgaXRzZWxmXHJcbiAgcmVtb3ZlICgpIHtcclxuICAgIC8vIHVuY2xpcCBhbGwgdGFyZ2V0c1xyXG4gICAgdGhpcy50YXJnZXRzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgZWwudW5jbGlwKClcclxuICAgIH0pXHJcblxyXG4gICAgLy8gcmVtb3ZlIGNsaXBQYXRoIGZyb20gcGFyZW50XHJcbiAgICByZXR1cm4gc3VwZXIucmVtb3ZlKClcclxuICB9XHJcblxyXG4gIHRhcmdldHMgKCkge1xyXG4gICAgcmV0dXJuIGJhc2VGaW5kKCdzdmcgW2NsaXAtcGF0aCo9XCInICsgdGhpcy5pZCgpICsgJ1wiXScpXHJcbiAgfVxyXG59XHJcblxyXG5yZWdpc3Rlck1ldGhvZHMoe1xyXG4gIENvbnRhaW5lcjoge1xyXG4gICAgLy8gQ3JlYXRlIGNsaXBwaW5nIGVsZW1lbnRcclxuICAgIGNsaXA6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZGVmcygpLnB1dChuZXcgQ2xpcFBhdGgoKSlcclxuICAgIH0pXHJcbiAgfSxcclxuICBFbGVtZW50OiB7XHJcbiAgICAvLyBEaXN0cmlidXRlIGNsaXBQYXRoIHRvIHN2ZyBlbGVtZW50XHJcbiAgICBjbGlwV2l0aCAoZWxlbWVudCkge1xyXG4gICAgICAvLyB1c2UgZ2l2ZW4gY2xpcCBvciBjcmVhdGUgYSBuZXcgb25lXHJcbiAgICAgIGNvbnN0IGNsaXBwZXIgPSBlbGVtZW50IGluc3RhbmNlb2YgQ2xpcFBhdGhcclxuICAgICAgICA/IGVsZW1lbnRcclxuICAgICAgICA6IHRoaXMucGFyZW50KCkuY2xpcCgpLmFkZChlbGVtZW50KVxyXG5cclxuICAgICAgLy8gYXBwbHkgbWFza1xyXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdjbGlwLXBhdGgnLCAndXJsKFwiIycgKyBjbGlwcGVyLmlkKCkgKyAnXCIpJylcclxuICAgIH0sXHJcblxyXG4gICAgLy8gVW5jbGlwIGVsZW1lbnRcclxuICAgIHVuY2xpcCAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2NsaXAtcGF0aCcsIG51bGwpXHJcbiAgICB9LFxyXG5cclxuICAgIGNsaXBwZXIgKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2UoJ2NsaXAtcGF0aCcpXHJcbiAgICB9XHJcbiAgfVxyXG59KVxyXG5cclxucmVnaXN0ZXIoQ2xpcFBhdGgsICdDbGlwUGF0aCcpXHJcbiIsImltcG9ydCB7IG5vZGVPck5ldywgcmVnaXN0ZXIsIHdyYXBXaXRoQXR0ckNoZWNrIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcclxuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcclxuaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi9FbGVtZW50LmpzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9yZWlnbk9iamVjdCBleHRlbmRzIEVsZW1lbnQge1xyXG4gIGNvbnN0cnVjdG9yIChub2RlKSB7XHJcbiAgICBzdXBlcihub2RlT3JOZXcoJ2ZvcmVpZ25PYmplY3QnLCBub2RlKSwgbm9kZSlcclxuICB9XHJcbn1cclxuXHJcbnJlZ2lzdGVyTWV0aG9kcyh7XHJcbiAgQ29udGFpbmVyOiB7XHJcbiAgICBmb3JlaWduT2JqZWN0OiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IEZvcmVpZ25PYmplY3QoKSkuc2l6ZSh3aWR0aCwgaGVpZ2h0KVxyXG4gICAgfSlcclxuICB9XHJcbn0pXHJcblxyXG5yZWdpc3RlcihGb3JlaWduT2JqZWN0LCAnRm9yZWlnbk9iamVjdCcpXHJcbiIsImltcG9ydCB7IG5vZGVPck5ldywgcmVnaXN0ZXIsIHdyYXBXaXRoQXR0ckNoZWNrIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcclxuaW1wb3J0IHsgcHJvcG9ydGlvbmFsU2l6ZSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzLmpzJ1xyXG5pbXBvcnQgeyByZWdpc3Rlck1ldGhvZHMgfSBmcm9tICcuLi91dGlscy9tZXRob2RzLmpzJ1xyXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vQ29udGFpbmVyLmpzJ1xyXG5pbXBvcnQgTWF0cml4IGZyb20gJy4uL3R5cGVzL01hdHJpeC5qcydcclxuaW1wb3J0IFBvaW50IGZyb20gJy4uL3R5cGVzL1BvaW50LmpzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRyBleHRlbmRzIENvbnRhaW5lciB7XHJcbiAgY29uc3RydWN0b3IgKG5vZGUpIHtcclxuICAgIHN1cGVyKG5vZGVPck5ldygnZycsIG5vZGUpLCBub2RlKVxyXG4gIH1cclxuXHJcbiAgeCAoeCwgYm94ID0gdGhpcy5iYm94KCkpIHtcclxuICAgIGlmICh4ID09IG51bGwpIHJldHVybiBib3gueFxyXG4gICAgcmV0dXJuIHRoaXMubW92ZSh4LCBib3gueSwgYm94KVxyXG4gIH1cclxuXHJcbiAgeSAoeSwgYm94ID0gdGhpcy5iYm94KCkpIHtcclxuICAgIGlmICh5ID09IG51bGwpIHJldHVybiBib3gueVxyXG4gICAgcmV0dXJuIHRoaXMubW92ZShib3gueCwgeSwgYm94KVxyXG4gIH1cclxuXHJcbiAgbW92ZSAoeCA9IDAsIHkgPSAwLCBib3ggPSB0aGlzLmJib3goKSkge1xyXG4gICAgY29uc3QgZHggPSB4IC0gYm94LnhcclxuICAgIGNvbnN0IGR5ID0geSAtIGJveC55XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZG1vdmUoZHgsIGR5KVxyXG4gIH1cclxuXHJcbiAgZHggKGR4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5kbW92ZShkeCwgMClcclxuICB9XHJcblxyXG4gIGR5IChkeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuZG1vdmUoMCwgZHkpXHJcbiAgfVxyXG5cclxuICBkbW92ZSAoZHgsIGR5KSB7XHJcbiAgICB0aGlzLmNoaWxkcmVuKCkuZm9yRWFjaCgoY2hpbGQsIGkpID0+IHtcclxuICAgICAgLy8gR2V0IHRoZSBjaGlsZHMgYmJveFxyXG4gICAgICBjb25zdCBiYm94ID0gY2hpbGQuYmJveCgpXHJcbiAgICAgIC8vIEdldCBjaGlsZHMgbWF0cml4XHJcbiAgICAgIGNvbnN0IG0gPSBuZXcgTWF0cml4KGNoaWxkKVxyXG4gICAgICAvLyBUcmFuc2xhdGUgY2hpbGRzIG1hdHJpeCBieSBhbW91bnQgYW5kXHJcbiAgICAgIC8vIHRyYW5zZm9ybSBpdCBiYWNrIGludG8gcGFyZW50cyBzcGFjZVxyXG4gICAgICBjb25zdCBtYXRyaXggPSBtLnRyYW5zbGF0ZShkeCwgZHkpLnRyYW5zZm9ybShtLmludmVyc2UoKSlcclxuICAgICAgLy8gQ2FsY3VsYXRlIG5ldyB4IGFuZCB5IGZyb20gb2xkIGJveFxyXG4gICAgICBjb25zdCBwID0gbmV3IFBvaW50KGJib3gueCwgYmJveC55KS50cmFuc2Zvcm0obWF0cml4KVxyXG4gICAgICAvLyBNb3ZlIGVsZW1lbnRcclxuICAgICAgY2hpbGQubW92ZShwLngsIHAueSlcclxuICAgIH0pXHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIHdpZHRoICh3aWR0aCwgYm94ID0gdGhpcy5iYm94KCkpIHtcclxuICAgIGlmICh3aWR0aCA9PSBudWxsKSByZXR1cm4gYm94LndpZHRoXHJcbiAgICByZXR1cm4gdGhpcy5zaXplKHdpZHRoLCBib3guaGVpZ2h0LCBib3gpXHJcbiAgfVxyXG5cclxuICBoZWlnaHQgKGhlaWdodCwgYm94ID0gdGhpcy5iYm94KCkpIHtcclxuICAgIGlmIChoZWlnaHQgPT0gbnVsbCkgcmV0dXJuIGJveC5oZWlnaHRcclxuICAgIHJldHVybiB0aGlzLnNpemUoYm94LndpZHRoLCBoZWlnaHQsIGJveClcclxuICB9XHJcblxyXG4gIHNpemUgKHdpZHRoLCBoZWlnaHQsIGJveCA9IHRoaXMuYmJveCgpKSB7XHJcbiAgICBjb25zdCBwID0gcHJvcG9ydGlvbmFsU2l6ZSh0aGlzLCB3aWR0aCwgaGVpZ2h0LCBib3gpXHJcbiAgICBjb25zdCBzY2FsZVggPSBwLndpZHRoIC8gYm94LndpZHRoXHJcbiAgICBjb25zdCBzY2FsZVkgPSBwLmhlaWdodCAvIGJveC5oZWlnaHRcclxuXHJcbiAgICB0aGlzLmNoaWxkcmVuKCkuZm9yRWFjaCgoY2hpbGQsIGkpID0+IHtcclxuICAgICAgY29uc3QgbyA9IG5ldyBQb2ludChib3gpLnRyYW5zZm9ybShuZXcgTWF0cml4KGNoaWxkKS5pbnZlcnNlKCkpXHJcbiAgICAgIGNoaWxkLnNjYWxlKHNjYWxlWCwgc2NhbGVZLCBvLngsIG8ueSlcclxuICAgIH0pXHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcbn1cclxuXHJcbnJlZ2lzdGVyTWV0aG9kcyh7XHJcbiAgQ29udGFpbmVyOiB7XHJcbiAgICAvLyBDcmVhdGUgYSBncm91cCBlbGVtZW50XHJcbiAgICBncm91cDogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IEcoKSlcclxuICAgIH0pXHJcbiAgfVxyXG59KVxyXG5cclxucmVnaXN0ZXIoRywgJ0cnKVxyXG4iLCJpbXBvcnQgeyBub2RlT3JOZXcsIHJlZ2lzdGVyLCB3cmFwV2l0aEF0dHJDaGVjayB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXHJcbmltcG9ydCB7IHhsaW5rIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL25hbWVzcGFjZXMuanMnXHJcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi9Db250YWluZXIuanMnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBIGV4dGVuZHMgQ29udGFpbmVyIHtcclxuICBjb25zdHJ1Y3RvciAobm9kZSkge1xyXG4gICAgc3VwZXIobm9kZU9yTmV3KCdhJywgbm9kZSksIG5vZGUpXHJcbiAgfVxyXG5cclxuICAvLyBMaW5rIHVybFxyXG4gIHRvICh1cmwpIHtcclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ2hyZWYnLCB1cmwsIHhsaW5rKVxyXG4gIH1cclxuXHJcbiAgLy8gTGluayB0YXJnZXQgYXR0cmlidXRlXHJcbiAgdGFyZ2V0ICh0YXJnZXQpIHtcclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ3RhcmdldCcsIHRhcmdldClcclxuICB9XHJcbn1cclxuXHJcbnJlZ2lzdGVyTWV0aG9kcyh7XHJcbiAgQ29udGFpbmVyOiB7XHJcbiAgICAvLyBDcmVhdGUgYSBoeXBlcmxpbmsgZWxlbWVudFxyXG4gICAgbGluazogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IEEoKSkudG8odXJsKVxyXG4gICAgfSlcclxuICB9LFxyXG4gIEVsZW1lbnQ6IHtcclxuICAgIC8vIENyZWF0ZSBhIGh5cGVybGluayBlbGVtZW50XHJcbiAgICBsaW5rVG86IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgdmFyIGxpbmsgPSBuZXcgQSgpXHJcblxyXG4gICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHVybC5jYWxsKGxpbmssIGxpbmspXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGluay50byh1cmwpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpLnB1dChsaW5rKS5wdXQodGhpcylcclxuICAgIH1cclxuICB9XHJcbn0pXHJcblxyXG5yZWdpc3RlcihBLCAnQScpXHJcbiIsImltcG9ydCB7IG5vZGVPck5ldywgcmVnaXN0ZXIsIHdyYXBXaXRoQXR0ckNoZWNrIH0gZnJvbSAnLi4vdXRpbHMvYWRvcHRlci5qcydcclxuaW1wb3J0IHsgcmVnaXN0ZXJNZXRob2RzIH0gZnJvbSAnLi4vdXRpbHMvbWV0aG9kcy5qcydcclxuaW1wb3J0IENvbnRhaW5lciBmcm9tICcuL0NvbnRhaW5lci5qcydcclxuaW1wb3J0IGJhc2VGaW5kIGZyb20gJy4uL21vZHVsZXMvY29yZS9zZWxlY3Rvci5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hc2sgZXh0ZW5kcyBDb250YWluZXIge1xyXG4gIC8vIEluaXRpYWxpemUgbm9kZVxyXG4gIGNvbnN0cnVjdG9yIChub2RlKSB7XHJcbiAgICBzdXBlcihub2RlT3JOZXcoJ21hc2snLCBub2RlKSwgbm9kZSlcclxuICB9XHJcblxyXG4gIC8vIFVubWFzayBhbGwgbWFza2VkIGVsZW1lbnRzIGFuZCByZW1vdmUgaXRzZWxmXHJcbiAgcmVtb3ZlICgpIHtcclxuICAgIC8vIHVubWFzayBhbGwgdGFyZ2V0c1xyXG4gICAgdGhpcy50YXJnZXRzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgZWwudW5tYXNrKClcclxuICAgIH0pXHJcblxyXG4gICAgLy8gcmVtb3ZlIG1hc2sgZnJvbSBwYXJlbnRcclxuICAgIHJldHVybiBzdXBlci5yZW1vdmUoKVxyXG4gIH1cclxuXHJcbiAgdGFyZ2V0cyAoKSB7XHJcbiAgICByZXR1cm4gYmFzZUZpbmQoJ3N2ZyBbbWFzayo9XCInICsgdGhpcy5pZCgpICsgJ1wiXScpXHJcbiAgfVxyXG59XHJcblxyXG5yZWdpc3Rlck1ldGhvZHMoe1xyXG4gIENvbnRhaW5lcjoge1xyXG4gICAgbWFzazogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5kZWZzKCkucHV0KG5ldyBNYXNrKCkpXHJcbiAgICB9KVxyXG4gIH0sXHJcbiAgRWxlbWVudDoge1xyXG4gICAgLy8gRGlzdHJpYnV0ZSBtYXNrIHRvIHN2ZyBlbGVtZW50XHJcbiAgICBtYXNrV2l0aCAoZWxlbWVudCkge1xyXG4gICAgICAvLyB1c2UgZ2l2ZW4gbWFzayBvciBjcmVhdGUgYSBuZXcgb25lXHJcbiAgICAgIHZhciBtYXNrZXIgPSBlbGVtZW50IGluc3RhbmNlb2YgTWFza1xyXG4gICAgICAgID8gZWxlbWVudFxyXG4gICAgICAgIDogdGhpcy5wYXJlbnQoKS5tYXNrKCkuYWRkKGVsZW1lbnQpXHJcblxyXG4gICAgICAvLyBhcHBseSBtYXNrXHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ21hc2snLCAndXJsKFwiIycgKyBtYXNrZXIuaWQoKSArICdcIiknKVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBVbm1hc2sgZWxlbWVudFxyXG4gICAgdW5tYXNrICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cignbWFzaycsIG51bGwpXHJcbiAgICB9LFxyXG5cclxuICAgIG1hc2tlciAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnJlZmVyZW5jZSgnbWFzaycpXHJcbiAgICB9XHJcbiAgfVxyXG59KVxyXG5cclxucmVnaXN0ZXIoTWFzaywgJ01hc2snKVxyXG4iLCJpbXBvcnQgeyBub2RlT3JOZXcsIHJlZ2lzdGVyLCB3cmFwV2l0aEF0dHJDaGVjayB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXHJcbmltcG9ydCB7IHVuQ2FtZWxDYXNlIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMuanMnXHJcbmltcG9ydCBFbGVtZW50IGZyb20gJy4vRWxlbWVudC5qcydcclxuXHJcbmZ1bmN0aW9uIGNzc1J1bGUgKHNlbGVjdG9yLCBydWxlKSB7XHJcbiAgaWYgKCFzZWxlY3RvcikgcmV0dXJuICcnXHJcbiAgaWYgKCFydWxlKSByZXR1cm4gc2VsZWN0b3JcclxuXHJcbiAgdmFyIHJldCA9IHNlbGVjdG9yICsgJ3snXHJcblxyXG4gIGZvciAodmFyIGkgaW4gcnVsZSkge1xyXG4gICAgcmV0ICs9IHVuQ2FtZWxDYXNlKGkpICsgJzonICsgcnVsZVtpXSArICc7J1xyXG4gIH1cclxuXHJcbiAgcmV0ICs9ICd9J1xyXG5cclxuICByZXR1cm4gcmV0XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0eWxlIGV4dGVuZHMgRWxlbWVudCB7XHJcbiAgY29uc3RydWN0b3IgKG5vZGUpIHtcclxuICAgIHN1cGVyKG5vZGVPck5ldygnc3R5bGUnLCBub2RlKSwgbm9kZSlcclxuICB9XHJcblxyXG4gIGFkZFRleHQgKHcgPSAnJykge1xyXG4gICAgdGhpcy5ub2RlLnRleHRDb250ZW50ICs9IHdcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICBmb250IChuYW1lLCBzcmMsIHBhcmFtcyA9IHt9KSB7XHJcbiAgICByZXR1cm4gdGhpcy5ydWxlKCdAZm9udC1mYWNlJywge1xyXG4gICAgICBmb250RmFtaWx5OiBuYW1lLFxyXG4gICAgICBzcmM6IHNyYyxcclxuICAgICAgLi4ucGFyYW1zXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgcnVsZSAoc2VsZWN0b3IsIG9iaikge1xyXG4gICAgcmV0dXJuIHRoaXMuYWRkVGV4dChjc3NSdWxlKHNlbGVjdG9yLCBvYmopKVxyXG4gIH1cclxufVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKCdEb20nLCB7XHJcbiAgc3R5bGU6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uIChzZWxlY3Rvciwgb2JqKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wdXQobmV3IFN0eWxlKCkpLnJ1bGUoc2VsZWN0b3IsIG9iailcclxuICB9KSxcclxuICBmb250ZmFjZTogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKG5hbWUsIHNyYywgcGFyYW1zKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wdXQobmV3IFN0eWxlKCkpLmZvbnQobmFtZSwgc3JjLCBwYXJhbXMpXHJcbiAgfSlcclxufSlcclxuXHJcbnJlZ2lzdGVyKFN0eWxlLCAnU3R5bGUnKVxyXG4iLCJpbXBvcnQgeyBub2RlT3JOZXcsIHJlZ2lzdGVyLCB3cmFwV2l0aEF0dHJDaGVjayB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXHJcbmltcG9ydCB7IHhsaW5rIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL25hbWVzcGFjZXMuanMnXHJcbmltcG9ydCBQYXRoIGZyb20gJy4vUGF0aC5qcydcclxuaW1wb3J0IFBhdGhBcnJheSBmcm9tICcuLi90eXBlcy9QYXRoQXJyYXkuanMnXHJcbmltcG9ydCBUZXh0IGZyb20gJy4vVGV4dC5qcydcclxuaW1wb3J0IGJhc2VGaW5kIGZyb20gJy4uL21vZHVsZXMvY29yZS9zZWxlY3Rvci5qcydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHRQYXRoIGV4dGVuZHMgVGV4dCB7XHJcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXHJcbiAgY29uc3RydWN0b3IgKG5vZGUpIHtcclxuICAgIHN1cGVyKG5vZGVPck5ldygndGV4dFBhdGgnLCBub2RlKSwgbm9kZSlcclxuICB9XHJcblxyXG4gIC8vIHJldHVybiB0aGUgYXJyYXkgb2YgdGhlIHBhdGggdHJhY2sgZWxlbWVudFxyXG4gIGFycmF5ICgpIHtcclxuICAgIHZhciB0cmFjayA9IHRoaXMudHJhY2soKVxyXG5cclxuICAgIHJldHVybiB0cmFjayA/IHRyYWNrLmFycmF5KCkgOiBudWxsXHJcbiAgfVxyXG5cclxuICAvLyBQbG90IHBhdGggaWYgYW55XHJcbiAgcGxvdCAoZCkge1xyXG4gICAgdmFyIHRyYWNrID0gdGhpcy50cmFjaygpXHJcbiAgICB2YXIgcGF0aEFycmF5ID0gbnVsbFxyXG5cclxuICAgIGlmICh0cmFjaykge1xyXG4gICAgICBwYXRoQXJyYXkgPSB0cmFjay5wbG90KGQpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChkID09IG51bGwpID8gcGF0aEFycmF5IDogdGhpc1xyXG4gIH1cclxuXHJcbiAgLy8gR2V0IHRoZSBwYXRoIGVsZW1lbnRcclxuICB0cmFjayAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2UoJ2hyZWYnKVxyXG4gIH1cclxufVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKHtcclxuICBDb250YWluZXI6IHtcclxuICAgIHRleHRQYXRoOiB3cmFwV2l0aEF0dHJDaGVjayhmdW5jdGlvbiAodGV4dCwgcGF0aCkge1xyXG4gICAgICAvLyBDb252ZXJ0IHRleHQgdG8gaW5zdGFuY2UgaWYgbmVlZGVkXHJcbiAgICAgIGlmICghKHRleHQgaW5zdGFuY2VvZiBUZXh0KSkge1xyXG4gICAgICAgIHRleHQgPSB0aGlzLnRleHQodGV4dClcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRleHQucGF0aChwYXRoKVxyXG4gICAgfSlcclxuICB9LFxyXG4gIFRleHQ6IHtcclxuICAgIC8vIENyZWF0ZSBwYXRoIGZvciB0ZXh0IHRvIHJ1biBvblxyXG4gICAgcGF0aDogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHRyYWNrLCBpbXBvcnROb2RlcyA9IHRydWUpIHtcclxuICAgICAgdmFyIHRleHRQYXRoID0gbmV3IFRleHRQYXRoKClcclxuXHJcbiAgICAgIC8vIGlmIHRyYWNrIGlzIGEgcGF0aCwgcmV1c2UgaXRcclxuICAgICAgaWYgKCEodHJhY2sgaW5zdGFuY2VvZiBQYXRoKSkge1xyXG4gICAgICAgIC8vIGNyZWF0ZSBwYXRoIGVsZW1lbnRcclxuICAgICAgICB0cmFjayA9IHRoaXMuZGVmcygpLnBhdGgodHJhY2spXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGxpbmsgdGV4dFBhdGggdG8gcGF0aCBhbmQgYWRkIGNvbnRlbnRcclxuICAgICAgdGV4dFBhdGguYXR0cignaHJlZicsICcjJyArIHRyYWNrLCB4bGluaylcclxuXHJcbiAgICAgIC8vIFRyYW5zcGxhbnQgYWxsIG5vZGVzIGZyb20gdGV4dCB0byB0ZXh0UGF0aFxyXG4gICAgICBsZXQgbm9kZVxyXG4gICAgICBpZiAoaW1wb3J0Tm9kZXMpIHtcclxuICAgICAgICB3aGlsZSAoKG5vZGUgPSB0aGlzLm5vZGUuZmlyc3RDaGlsZCkpIHtcclxuICAgICAgICAgIHRleHRQYXRoLm5vZGUuYXBwZW5kQ2hpbGQobm9kZSlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGFkZCB0ZXh0UGF0aCBlbGVtZW50IGFzIGNoaWxkIG5vZGUgYW5kIHJldHVybiB0ZXh0UGF0aFxyXG4gICAgICByZXR1cm4gdGhpcy5wdXQodGV4dFBhdGgpXHJcbiAgICB9KSxcclxuXHJcbiAgICAvLyBHZXQgdGhlIHRleHRQYXRoIGNoaWxkcmVuXHJcbiAgICB0ZXh0UGF0aCAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZpbmRPbmUoJ3RleHRQYXRoJylcclxuICAgIH1cclxuICB9LFxyXG4gIFBhdGg6IHtcclxuICAgIC8vIGNyZWF0ZXMgYSB0ZXh0UGF0aCBmcm9tIHRoaXMgcGF0aFxyXG4gICAgdGV4dDogd3JhcFdpdGhBdHRyQ2hlY2soZnVuY3Rpb24gKHRleHQpIHtcclxuICAgICAgLy8gQ29udmVydCB0ZXh0IHRvIGluc3RhbmNlIGlmIG5lZWRlZFxyXG4gICAgICBpZiAoISh0ZXh0IGluc3RhbmNlb2YgVGV4dCkpIHtcclxuICAgICAgICB0ZXh0ID0gbmV3IFRleHQoKS5hZGRUbyh0aGlzLnBhcmVudCgpKS50ZXh0KHRleHQpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENyZWF0ZSB0ZXh0UGF0aCBmcm9tIHRleHQgYW5kIHBhdGggYW5kIHJldHVyblxyXG4gICAgICByZXR1cm4gdGV4dC5wYXRoKHRoaXMpXHJcbiAgICB9KSxcclxuXHJcbiAgICB0YXJnZXRzICgpIHtcclxuICAgICAgcmV0dXJuIGJhc2VGaW5kKCdzdmcgW2hyZWYqPVwiJyArIHRoaXMuaWQoKSArICdcIl0nKVxyXG4gICAgfVxyXG4gIH1cclxufSlcclxuXHJcblRleHRQYXRoLnByb3RvdHlwZS5Nb3JwaEFycmF5ID0gUGF0aEFycmF5XHJcbnJlZ2lzdGVyKFRleHRQYXRoLCAnVGV4dFBhdGgnKVxyXG4iLCJpbXBvcnQgeyBub2RlT3JOZXcsIHJlZ2lzdGVyLCB3cmFwV2l0aEF0dHJDaGVjayB9IGZyb20gJy4uL3V0aWxzL2Fkb3B0ZXIuanMnXHJcbmltcG9ydCB7IHJlZ2lzdGVyTWV0aG9kcyB9IGZyb20gJy4uL3V0aWxzL21ldGhvZHMuanMnXHJcbmltcG9ydCB7IHhsaW5rIH0gZnJvbSAnLi4vbW9kdWxlcy9jb3JlL25hbWVzcGFjZXMuanMnXHJcbmltcG9ydCBTaGFwZSBmcm9tICcuL1NoYXBlLmpzJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXNlIGV4dGVuZHMgU2hhcGUge1xyXG4gIGNvbnN0cnVjdG9yIChub2RlKSB7XHJcbiAgICBzdXBlcihub2RlT3JOZXcoJ3VzZScsIG5vZGUpLCBub2RlKVxyXG4gIH1cclxuXHJcbiAgLy8gVXNlIGVsZW1lbnQgYXMgYSByZWZlcmVuY2VcclxuICBlbGVtZW50IChlbGVtZW50LCBmaWxlKSB7XHJcbiAgICAvLyBTZXQgbGluZWQgZWxlbWVudFxyXG4gICAgcmV0dXJuIHRoaXMuYXR0cignaHJlZicsIChmaWxlIHx8ICcnKSArICcjJyArIGVsZW1lbnQsIHhsaW5rKVxyXG4gIH1cclxufVxyXG5cclxucmVnaXN0ZXJNZXRob2RzKHtcclxuICBDb250YWluZXI6IHtcclxuICAgIC8vIENyZWF0ZSBhIHVzZSBlbGVtZW50XHJcbiAgICB1c2U6IHdyYXBXaXRoQXR0ckNoZWNrKGZ1bmN0aW9uIChlbGVtZW50LCBmaWxlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgVXNlKCkpLmVsZW1lbnQoZWxlbWVudCwgZmlsZSlcclxuICAgIH0pXHJcbiAgfVxyXG59KVxyXG5cclxucmVnaXN0ZXIoVXNlLCAnVXNlJylcclxuIiwiLyogT3B0aW9uYWwgTW9kdWxlcyAqL1xyXG5pbXBvcnQgJy4vbW9kdWxlcy9vcHRpb25hbC9hcnJhbmdlLmpzJ1xyXG5pbXBvcnQgJy4vbW9kdWxlcy9vcHRpb25hbC9jbGFzcy5qcydcclxuaW1wb3J0ICcuL21vZHVsZXMvb3B0aW9uYWwvY3NzLmpzJ1xyXG5pbXBvcnQgJy4vbW9kdWxlcy9vcHRpb25hbC9kYXRhLmpzJ1xyXG5pbXBvcnQgJy4vbW9kdWxlcy9vcHRpb25hbC9tZW1vcnkuanMnXHJcbmltcG9ydCAnLi9tb2R1bGVzL29wdGlvbmFsL3N1Z2FyLmpzJ1xyXG5pbXBvcnQgJy4vbW9kdWxlcy9vcHRpb25hbC90cmFuc2Zvcm0uanMnXHJcblxyXG5pbXBvcnQgeyBleHRlbmQsIG1ha2VJbnN0YW5jZSB9IGZyb20gJy4vdXRpbHMvYWRvcHRlci5qcydcclxuaW1wb3J0IHsgZ2V0TWV0aG9kTmFtZXMsIGdldE1ldGhvZHNGb3IgfSBmcm9tICcuL3V0aWxzL21ldGhvZHMuanMnXHJcbmltcG9ydCBCb3ggZnJvbSAnLi90eXBlcy9Cb3guanMnXHJcbmltcG9ydCBDaXJjbGUgZnJvbSAnLi9lbGVtZW50cy9DaXJjbGUuanMnXHJcbmltcG9ydCBDb2xvciBmcm9tICcuL3R5cGVzL0NvbG9yLmpzJ1xyXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4vZWxlbWVudHMvQ29udGFpbmVyLmpzJ1xyXG5pbXBvcnQgRGVmcyBmcm9tICcuL2VsZW1lbnRzL0RlZnMuanMnXHJcbmltcG9ydCBEb20gZnJvbSAnLi9lbGVtZW50cy9Eb20uanMnXHJcbmltcG9ydCBFbGVtZW50IGZyb20gJy4vZWxlbWVudHMvRWxlbWVudC5qcydcclxuaW1wb3J0IEVsbGlwc2UgZnJvbSAnLi9lbGVtZW50cy9FbGxpcHNlLmpzJ1xyXG5pbXBvcnQgRXZlbnRUYXJnZXQgZnJvbSAnLi90eXBlcy9FdmVudFRhcmdldC5qcydcclxuaW1wb3J0IEdyYWRpZW50IGZyb20gJy4vZWxlbWVudHMvR3JhZGllbnQuanMnXHJcbmltcG9ydCBJbWFnZSBmcm9tICcuL2VsZW1lbnRzL0ltYWdlLmpzJ1xyXG5pbXBvcnQgTGluZSBmcm9tICcuL2VsZW1lbnRzL0xpbmUuanMnXHJcbmltcG9ydCBMaXN0IGZyb20gJy4vdHlwZXMvTGlzdC5qcydcclxuaW1wb3J0IE1hcmtlciBmcm9tICcuL2VsZW1lbnRzL01hcmtlci5qcydcclxuaW1wb3J0IE1hdHJpeCBmcm9tICcuL3R5cGVzL01hdHJpeC5qcydcclxuaW1wb3J0IE1vcnBoYWJsZSwge1xyXG4gIE5vbk1vcnBoYWJsZSxcclxuICBPYmplY3RCYWcsXHJcbiAgVHJhbnNmb3JtQmFnLFxyXG4gIG1ha2VNb3JwaGFibGUsXHJcbiAgcmVnaXN0ZXJNb3JwaGFibGVUeXBlXHJcbn0gZnJvbSAnLi9hbmltYXRpb24vTW9ycGhhYmxlLmpzJ1xyXG5pbXBvcnQgUGF0aCBmcm9tICcuL2VsZW1lbnRzL1BhdGguanMnXHJcbmltcG9ydCBQYXRoQXJyYXkgZnJvbSAnLi90eXBlcy9QYXRoQXJyYXkuanMnXHJcbmltcG9ydCBQYXR0ZXJuIGZyb20gJy4vZWxlbWVudHMvUGF0dGVybi5qcydcclxuaW1wb3J0IFBvaW50QXJyYXkgZnJvbSAnLi90eXBlcy9Qb2ludEFycmF5LmpzJ1xyXG5pbXBvcnQgUG9seWdvbiBmcm9tICcuL2VsZW1lbnRzL1BvbHlnb24uanMnXHJcbmltcG9ydCBQb2x5bGluZSBmcm9tICcuL2VsZW1lbnRzL1BvbHlsaW5lLmpzJ1xyXG5pbXBvcnQgUmVjdCBmcm9tICcuL2VsZW1lbnRzL1JlY3QuanMnXHJcbmltcG9ydCBSdW5uZXIgZnJvbSAnLi9hbmltYXRpb24vUnVubmVyLmpzJ1xyXG5pbXBvcnQgU1ZHQXJyYXkgZnJvbSAnLi90eXBlcy9TVkdBcnJheS5qcydcclxuaW1wb3J0IFNWR051bWJlciBmcm9tICcuL3R5cGVzL1NWR051bWJlci5qcydcclxuaW1wb3J0IFNoYXBlIGZyb20gJy4vZWxlbWVudHMvU2hhcGUuanMnXHJcbmltcG9ydCBTdmcgZnJvbSAnLi9lbGVtZW50cy9TdmcuanMnXHJcbmltcG9ydCBTeW1ib2wgZnJvbSAnLi9lbGVtZW50cy9TeW1ib2wuanMnXHJcbmltcG9ydCBUZXh0IGZyb20gJy4vZWxlbWVudHMvVGV4dC5qcydcclxuaW1wb3J0IFRzcGFuIGZyb20gJy4vZWxlbWVudHMvVHNwYW4uanMnXHJcbmltcG9ydCAqIGFzIGRlZmF1bHRzIGZyb20gJy4vbW9kdWxlcy9jb3JlL2RlZmF1bHRzLmpzJ1xyXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL3V0aWxzL3V0aWxzLmpzJ1xyXG5pbXBvcnQgKiBhcyBuYW1lc3BhY2VzIGZyb20gJy4vbW9kdWxlcy9jb3JlL25hbWVzcGFjZXMuanMnXHJcbmltcG9ydCAqIGFzIHJlZ2V4IGZyb20gJy4vbW9kdWxlcy9jb3JlL3JlZ2V4LmpzJ1xyXG5cclxuZXhwb3J0IHtcclxuICBNb3JwaGFibGUsXHJcbiAgcmVnaXN0ZXJNb3JwaGFibGVUeXBlLFxyXG4gIG1ha2VNb3JwaGFibGUsXHJcbiAgVHJhbnNmb3JtQmFnLFxyXG4gIE9iamVjdEJhZyxcclxuICBOb25Nb3JwaGFibGVcclxufVxyXG5cclxuZXhwb3J0IHsgZGVmYXVsdHMsIHV0aWxzLCBuYW1lc3BhY2VzLCByZWdleCB9XHJcbmV4cG9ydCBjb25zdCBTVkcgPSBtYWtlSW5zdGFuY2VcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBwYXJzZXIgfSBmcm9tICcuL21vZHVsZXMvY29yZS9wYXJzZXIuanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZmluZCB9IGZyb20gJy4vbW9kdWxlcy9jb3JlL3NlbGVjdG9yLmpzJ1xyXG5leHBvcnQgKiBmcm9tICcuL21vZHVsZXMvY29yZS9ldmVudC5qcydcclxuZXhwb3J0ICogZnJvbSAnLi91dGlscy9hZG9wdGVyLmpzJ1xyXG5leHBvcnQgeyByZWdpc3RlcldpbmRvdyB9IGZyb20gJy4vdXRpbHMvd2luZG93LmpzJ1xyXG5cclxuLyogQW5pbWF0aW9uIE1vZHVsZXMgKi9cclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBBbmltYXRvciB9IGZyb20gJy4vYW5pbWF0aW9uL0FuaW1hdG9yLmpzJ1xyXG5leHBvcnQgeyBDb250cm9sbGVyLCBFYXNlLCBQSUQsIFNwcmluZywgZWFzaW5nIH0gZnJvbSAnLi9hbmltYXRpb24vQ29udHJvbGxlci5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBRdWV1ZSB9IGZyb20gJy4vYW5pbWF0aW9uL1F1ZXVlLmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFJ1bm5lciB9IGZyb20gJy4vYW5pbWF0aW9uL1J1bm5lci5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBUaW1lbGluZSB9IGZyb20gJy4vYW5pbWF0aW9uL1RpbWVsaW5lLmpzJ1xyXG5cclxuLyogVHlwZXMgKi9cclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBBcnJheSB9IGZyb20gJy4vdHlwZXMvU1ZHQXJyYXkuanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQm94IH0gZnJvbSAnLi90eXBlcy9Cb3guanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ29sb3IgfSBmcm9tICcuL3R5cGVzL0NvbG9yLmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIEV2ZW50VGFyZ2V0IH0gZnJvbSAnLi90eXBlcy9FdmVudFRhcmdldC5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBNYXRyaXggfSBmcm9tICcuL3R5cGVzL01hdHJpeC5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBOdW1iZXIgfSBmcm9tICcuL3R5cGVzL1NWR051bWJlci5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBQYXRoQXJyYXkgfSBmcm9tICcuL3R5cGVzL1BhdGhBcnJheS5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBQb2ludCB9IGZyb20gJy4vdHlwZXMvUG9pbnQuanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUG9pbnRBcnJheSB9IGZyb20gJy4vdHlwZXMvUG9pbnRBcnJheS5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaXN0IH0gZnJvbSAnLi90eXBlcy9MaXN0LmpzJ1xyXG5cclxuLyogRWxlbWVudHMgKi9cclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBDaXJjbGUgfSBmcm9tICcuL2VsZW1lbnRzL0NpcmNsZS5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBDbGlwUGF0aCB9IGZyb20gJy4vZWxlbWVudHMvQ2xpcFBhdGguanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ29udGFpbmVyIH0gZnJvbSAnLi9lbGVtZW50cy9Db250YWluZXIuanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRGVmcyB9IGZyb20gJy4vZWxlbWVudHMvRGVmcy5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBEb20gfSBmcm9tICcuL2VsZW1lbnRzL0RvbS5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBFbGVtZW50IH0gZnJvbSAnLi9lbGVtZW50cy9FbGVtZW50LmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIEVsbGlwc2UgfSBmcm9tICcuL2VsZW1lbnRzL0VsbGlwc2UuanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRm9yZWlnbk9iamVjdCB9IGZyb20gJy4vZWxlbWVudHMvRm9yZWlnbk9iamVjdC5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBHcmFkaWVudCB9IGZyb20gJy4vZWxlbWVudHMvR3JhZGllbnQuanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRyB9IGZyb20gJy4vZWxlbWVudHMvRy5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBBIH0gZnJvbSAnLi9lbGVtZW50cy9BLmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIEltYWdlIH0gZnJvbSAnLi9lbGVtZW50cy9JbWFnZS5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaW5lIH0gZnJvbSAnLi9lbGVtZW50cy9MaW5lLmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIE1hcmtlciB9IGZyb20gJy4vZWxlbWVudHMvTWFya2VyLmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIE1hc2sgfSBmcm9tICcuL2VsZW1lbnRzL01hc2suanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUGF0aCB9IGZyb20gJy4vZWxlbWVudHMvUGF0aC5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBQYXR0ZXJuIH0gZnJvbSAnLi9lbGVtZW50cy9QYXR0ZXJuLmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFBvbHlnb24gfSBmcm9tICcuL2VsZW1lbnRzL1BvbHlnb24uanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUG9seWxpbmUgfSBmcm9tICcuL2VsZW1lbnRzL1BvbHlsaW5lLmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFJlY3QgfSBmcm9tICcuL2VsZW1lbnRzL1JlY3QuanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2hhcGUgfSBmcm9tICcuL2VsZW1lbnRzL1NoYXBlLmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFN0b3AgfSBmcm9tICcuL2VsZW1lbnRzL1N0b3AuanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU3R5bGUgfSBmcm9tICcuL2VsZW1lbnRzL1N0eWxlLmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFN2ZyB9IGZyb20gJy4vZWxlbWVudHMvU3ZnLmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFN5bWJvbCB9IGZyb20gJy4vZWxlbWVudHMvU3ltYm9sLmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFRleHQgfSBmcm9tICcuL2VsZW1lbnRzL1RleHQuanMnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGV4dFBhdGggfSBmcm9tICcuL2VsZW1lbnRzL1RleHRQYXRoLmpzJ1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFRzcGFuIH0gZnJvbSAnLi9lbGVtZW50cy9Uc3Bhbi5qcydcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBVc2UgfSBmcm9tICcuL2VsZW1lbnRzL1VzZS5qcydcclxuXHJcbmV4dGVuZChbXHJcbiAgU3ZnLFxyXG4gIFN5bWJvbCxcclxuICBJbWFnZSxcclxuICBQYXR0ZXJuLFxyXG4gIE1hcmtlclxyXG5dLCBnZXRNZXRob2RzRm9yKCd2aWV3Ym94JykpXHJcblxyXG5leHRlbmQoW1xyXG4gIExpbmUsXHJcbiAgUG9seWxpbmUsXHJcbiAgUG9seWdvbixcclxuICBQYXRoXHJcbl0sIGdldE1ldGhvZHNGb3IoJ21hcmtlcicpKVxyXG5cclxuZXh0ZW5kKFRleHQsIGdldE1ldGhvZHNGb3IoJ1RleHQnKSlcclxuZXh0ZW5kKFBhdGgsIGdldE1ldGhvZHNGb3IoJ1BhdGgnKSlcclxuXHJcbmV4dGVuZChEZWZzLCBnZXRNZXRob2RzRm9yKCdEZWZzJykpXHJcblxyXG5leHRlbmQoW1xyXG4gIFRleHQsXHJcbiAgVHNwYW5cclxuXSwgZ2V0TWV0aG9kc0ZvcignVHNwYW4nKSlcclxuXHJcbmV4dGVuZChbXHJcbiAgUmVjdCxcclxuICBFbGxpcHNlLFxyXG4gIENpcmNsZSxcclxuICBHcmFkaWVudFxyXG5dLCBnZXRNZXRob2RzRm9yKCdyYWRpdXMnKSlcclxuXHJcbmV4dGVuZChFdmVudFRhcmdldCwgZ2V0TWV0aG9kc0ZvcignRXZlbnRUYXJnZXQnKSlcclxuZXh0ZW5kKERvbSwgZ2V0TWV0aG9kc0ZvcignRG9tJykpXHJcbmV4dGVuZChFbGVtZW50LCBnZXRNZXRob2RzRm9yKCdFbGVtZW50JykpXHJcbmV4dGVuZChTaGFwZSwgZ2V0TWV0aG9kc0ZvcignU2hhcGUnKSlcclxuLy8gZXh0ZW5kKEVsZW1lbnQsIGdldENvbnN0cnVjdG9yKCdNZW1vcnknKSlcclxuZXh0ZW5kKENvbnRhaW5lciwgZ2V0TWV0aG9kc0ZvcignQ29udGFpbmVyJykpXHJcblxyXG5leHRlbmQoUnVubmVyLCBnZXRNZXRob2RzRm9yKCdSdW5uZXInKSlcclxuXHJcbkxpc3QuZXh0ZW5kKGdldE1ldGhvZE5hbWVzKCkpXHJcblxyXG5yZWdpc3Rlck1vcnBoYWJsZVR5cGUoW1xyXG4gIFNWR051bWJlcixcclxuICBDb2xvcixcclxuICBCb3gsXHJcbiAgTWF0cml4LFxyXG4gIFNWR0FycmF5LFxyXG4gIFBvaW50QXJyYXksXHJcbiAgUGF0aEFycmF5XHJcbl0pXHJcblxyXG5tYWtlTW9ycGhhYmxlKClcclxuIiwiIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1xdWFkdHJlZS8gdjEuMC43IENvcHlyaWdodCAyMDE5IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gdHJlZV9hZGQoZCkge1xuICB2YXIgeCA9ICt0aGlzLl94LmNhbGwobnVsbCwgZCksXG4gICAgICB5ID0gK3RoaXMuX3kuY2FsbChudWxsLCBkKTtcbiAgcmV0dXJuIGFkZCh0aGlzLmNvdmVyKHgsIHkpLCB4LCB5LCBkKTtcbn1cblxuZnVuY3Rpb24gYWRkKHRyZWUsIHgsIHksIGQpIHtcbiAgaWYgKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSByZXR1cm4gdHJlZTsgLy8gaWdub3JlIGludmFsaWQgcG9pbnRzXG5cbiAgdmFyIHBhcmVudCxcbiAgICAgIG5vZGUgPSB0cmVlLl9yb290LFxuICAgICAgbGVhZiA9IHtkYXRhOiBkfSxcbiAgICAgIHgwID0gdHJlZS5feDAsXG4gICAgICB5MCA9IHRyZWUuX3kwLFxuICAgICAgeDEgPSB0cmVlLl94MSxcbiAgICAgIHkxID0gdHJlZS5feTEsXG4gICAgICB4bSxcbiAgICAgIHltLFxuICAgICAgeHAsXG4gICAgICB5cCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgICAgaSxcbiAgICAgIGo7XG5cbiAgLy8gSWYgdGhlIHRyZWUgaXMgZW1wdHksIGluaXRpYWxpemUgdGhlIHJvb3QgYXMgYSBsZWFmLlxuICBpZiAoIW5vZGUpIHJldHVybiB0cmVlLl9yb290ID0gbGVhZiwgdHJlZTtcblxuICAvLyBGaW5kIHRoZSBleGlzdGluZyBsZWFmIGZvciB0aGUgbmV3IHBvaW50LCBvciBhZGQgaXQuXG4gIHdoaWxlIChub2RlLmxlbmd0aCkge1xuICAgIGlmIChyaWdodCA9IHggPj0gKHhtID0gKHgwICsgeDEpIC8gMikpIHgwID0geG07IGVsc2UgeDEgPSB4bTtcbiAgICBpZiAoYm90dG9tID0geSA+PSAoeW0gPSAoeTAgKyB5MSkgLyAyKSkgeTAgPSB5bTsgZWxzZSB5MSA9IHltO1xuICAgIGlmIChwYXJlbnQgPSBub2RlLCAhKG5vZGUgPSBub2RlW2kgPSBib3R0b20gPDwgMSB8IHJpZ2h0XSkpIHJldHVybiBwYXJlbnRbaV0gPSBsZWFmLCB0cmVlO1xuICB9XG5cbiAgLy8gSXMgdGhlIG5ldyBwb2ludCBpcyBleGFjdGx5IGNvaW5jaWRlbnQgd2l0aCB0aGUgZXhpc3RpbmcgcG9pbnQ/XG4gIHhwID0gK3RyZWUuX3guY2FsbChudWxsLCBub2RlLmRhdGEpO1xuICB5cCA9ICt0cmVlLl95LmNhbGwobnVsbCwgbm9kZS5kYXRhKTtcbiAgaWYgKHggPT09IHhwICYmIHkgPT09IHlwKSByZXR1cm4gbGVhZi5uZXh0ID0gbm9kZSwgcGFyZW50ID8gcGFyZW50W2ldID0gbGVhZiA6IHRyZWUuX3Jvb3QgPSBsZWFmLCB0cmVlO1xuXG4gIC8vIE90aGVyd2lzZSwgc3BsaXQgdGhlIGxlYWYgbm9kZSB1bnRpbCB0aGUgb2xkIGFuZCBuZXcgcG9pbnQgYXJlIHNlcGFyYXRlZC5cbiAgZG8ge1xuICAgIHBhcmVudCA9IHBhcmVudCA/IHBhcmVudFtpXSA9IG5ldyBBcnJheSg0KSA6IHRyZWUuX3Jvb3QgPSBuZXcgQXJyYXkoNCk7XG4gICAgaWYgKHJpZ2h0ID0geCA+PSAoeG0gPSAoeDAgKyB4MSkgLyAyKSkgeDAgPSB4bTsgZWxzZSB4MSA9IHhtO1xuICAgIGlmIChib3R0b20gPSB5ID49ICh5bSA9ICh5MCArIHkxKSAvIDIpKSB5MCA9IHltOyBlbHNlIHkxID0geW07XG4gIH0gd2hpbGUgKChpID0gYm90dG9tIDw8IDEgfCByaWdodCkgPT09IChqID0gKHlwID49IHltKSA8PCAxIHwgKHhwID49IHhtKSkpO1xuICByZXR1cm4gcGFyZW50W2pdID0gbm9kZSwgcGFyZW50W2ldID0gbGVhZiwgdHJlZTtcbn1cblxuZnVuY3Rpb24gYWRkQWxsKGRhdGEpIHtcbiAgdmFyIGQsIGksIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgeHogPSBuZXcgQXJyYXkobiksXG4gICAgICB5eiA9IG5ldyBBcnJheShuKSxcbiAgICAgIHgwID0gSW5maW5pdHksXG4gICAgICB5MCA9IEluZmluaXR5LFxuICAgICAgeDEgPSAtSW5maW5pdHksXG4gICAgICB5MSA9IC1JbmZpbml0eTtcblxuICAvLyBDb21wdXRlIHRoZSBwb2ludHMgYW5kIHRoZWlyIGV4dGVudC5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGlmIChpc05hTih4ID0gK3RoaXMuX3guY2FsbChudWxsLCBkID0gZGF0YVtpXSkpIHx8IGlzTmFOKHkgPSArdGhpcy5feS5jYWxsKG51bGwsIGQpKSkgY29udGludWU7XG4gICAgeHpbaV0gPSB4O1xuICAgIHl6W2ldID0geTtcbiAgICBpZiAoeCA8IHgwKSB4MCA9IHg7XG4gICAgaWYgKHggPiB4MSkgeDEgPSB4O1xuICAgIGlmICh5IDwgeTApIHkwID0geTtcbiAgICBpZiAoeSA+IHkxKSB5MSA9IHk7XG4gIH1cblxuICAvLyBJZiB0aGVyZSB3ZXJlIG5vICh2YWxpZCkgcG9pbnRzLCBhYm9ydC5cbiAgaWYgKHgwID4geDEgfHwgeTAgPiB5MSkgcmV0dXJuIHRoaXM7XG5cbiAgLy8gRXhwYW5kIHRoZSB0cmVlIHRvIGNvdmVyIHRoZSBuZXcgcG9pbnRzLlxuICB0aGlzLmNvdmVyKHgwLCB5MCkuY292ZXIoeDEsIHkxKTtcblxuICAvLyBBZGQgdGhlIG5ldyBwb2ludHMuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBhZGQodGhpcywgeHpbaV0sIHl6W2ldLCBkYXRhW2ldKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB0cmVlX2NvdmVyKHgsIHkpIHtcbiAgaWYgKGlzTmFOKHggPSAreCkgfHwgaXNOYU4oeSA9ICt5KSkgcmV0dXJuIHRoaXM7IC8vIGlnbm9yZSBpbnZhbGlkIHBvaW50c1xuXG4gIHZhciB4MCA9IHRoaXMuX3gwLFxuICAgICAgeTAgPSB0aGlzLl95MCxcbiAgICAgIHgxID0gdGhpcy5feDEsXG4gICAgICB5MSA9IHRoaXMuX3kxO1xuXG4gIC8vIElmIHRoZSBxdWFkdHJlZSBoYXMgbm8gZXh0ZW50LCBpbml0aWFsaXplIHRoZW0uXG4gIC8vIEludGVnZXIgZXh0ZW50IGFyZSBuZWNlc3Nhcnkgc28gdGhhdCBpZiB3ZSBsYXRlciBkb3VibGUgdGhlIGV4dGVudCxcbiAgLy8gdGhlIGV4aXN0aW5nIHF1YWRyYW50IGJvdW5kYXJpZXMgZG9u4oCZdCBjaGFuZ2UgZHVlIHRvIGZsb2F0aW5nIHBvaW50IGVycm9yIVxuICBpZiAoaXNOYU4oeDApKSB7XG4gICAgeDEgPSAoeDAgPSBNYXRoLmZsb29yKHgpKSArIDE7XG4gICAgeTEgPSAoeTAgPSBNYXRoLmZsb29yKHkpKSArIDE7XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIGRvdWJsZSByZXBlYXRlZGx5IHRvIGNvdmVyLlxuICBlbHNlIHtcbiAgICB2YXIgeiA9IHgxIC0geDAsXG4gICAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIGk7XG5cbiAgICB3aGlsZSAoeDAgPiB4IHx8IHggPj0geDEgfHwgeTAgPiB5IHx8IHkgPj0geTEpIHtcbiAgICAgIGkgPSAoeSA8IHkwKSA8PCAxIHwgKHggPCB4MCk7XG4gICAgICBwYXJlbnQgPSBuZXcgQXJyYXkoNCksIHBhcmVudFtpXSA9IG5vZGUsIG5vZGUgPSBwYXJlbnQsIHogKj0gMjtcbiAgICAgIHN3aXRjaCAoaSkge1xuICAgICAgICBjYXNlIDA6IHgxID0geDAgKyB6LCB5MSA9IHkwICsgejsgYnJlYWs7XG4gICAgICAgIGNhc2UgMTogeDAgPSB4MSAtIHosIHkxID0geTAgKyB6OyBicmVhaztcbiAgICAgICAgY2FzZSAyOiB4MSA9IHgwICsgeiwgeTAgPSB5MSAtIHo7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IHgwID0geDEgLSB6LCB5MCA9IHkxIC0gejsgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3Jvb3QgJiYgdGhpcy5fcm9vdC5sZW5ndGgpIHRoaXMuX3Jvb3QgPSBub2RlO1xuICB9XG5cbiAgdGhpcy5feDAgPSB4MDtcbiAgdGhpcy5feTAgPSB5MDtcbiAgdGhpcy5feDEgPSB4MTtcbiAgdGhpcy5feTEgPSB5MTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHRyZWVfZGF0YSgpIHtcbiAgdmFyIGRhdGEgPSBbXTtcbiAgdGhpcy52aXNpdChmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlLmxlbmd0aCkgZG8gZGF0YS5wdXNoKG5vZGUuZGF0YSk7IHdoaWxlIChub2RlID0gbm9kZS5uZXh0KVxuICB9KTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIHRyZWVfZXh0ZW50KF8pIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5jb3ZlcigrX1swXVswXSwgK19bMF1bMV0pLmNvdmVyKCtfWzFdWzBdLCArX1sxXVsxXSlcbiAgICAgIDogaXNOYU4odGhpcy5feDApID8gdW5kZWZpbmVkIDogW1t0aGlzLl94MCwgdGhpcy5feTBdLCBbdGhpcy5feDEsIHRoaXMuX3kxXV07XG59XG5cbmZ1bmN0aW9uIFF1YWQobm9kZSwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy54MCA9IHgwO1xuICB0aGlzLnkwID0geTA7XG4gIHRoaXMueDEgPSB4MTtcbiAgdGhpcy55MSA9IHkxO1xufVxuXG5mdW5jdGlvbiB0cmVlX2ZpbmQoeCwgeSwgcmFkaXVzKSB7XG4gIHZhciBkYXRhLFxuICAgICAgeDAgPSB0aGlzLl94MCxcbiAgICAgIHkwID0gdGhpcy5feTAsXG4gICAgICB4MSxcbiAgICAgIHkxLFxuICAgICAgeDIsXG4gICAgICB5MixcbiAgICAgIHgzID0gdGhpcy5feDEsXG4gICAgICB5MyA9IHRoaXMuX3kxLFxuICAgICAgcXVhZHMgPSBbXSxcbiAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxuICAgICAgcSxcbiAgICAgIGk7XG5cbiAgaWYgKG5vZGUpIHF1YWRzLnB1c2gobmV3IFF1YWQobm9kZSwgeDAsIHkwLCB4MywgeTMpKTtcbiAgaWYgKHJhZGl1cyA9PSBudWxsKSByYWRpdXMgPSBJbmZpbml0eTtcbiAgZWxzZSB7XG4gICAgeDAgPSB4IC0gcmFkaXVzLCB5MCA9IHkgLSByYWRpdXM7XG4gICAgeDMgPSB4ICsgcmFkaXVzLCB5MyA9IHkgKyByYWRpdXM7XG4gICAgcmFkaXVzICo9IHJhZGl1cztcbiAgfVxuXG4gIHdoaWxlIChxID0gcXVhZHMucG9wKCkpIHtcblxuICAgIC8vIFN0b3Agc2VhcmNoaW5nIGlmIHRoaXMgcXVhZHJhbnQgY2Fu4oCZdCBjb250YWluIGEgY2xvc2VyIG5vZGUuXG4gICAgaWYgKCEobm9kZSA9IHEubm9kZSlcbiAgICAgICAgfHwgKHgxID0gcS54MCkgPiB4M1xuICAgICAgICB8fCAoeTEgPSBxLnkwKSA+IHkzXG4gICAgICAgIHx8ICh4MiA9IHEueDEpIDwgeDBcbiAgICAgICAgfHwgKHkyID0gcS55MSkgPCB5MCkgY29udGludWU7XG5cbiAgICAvLyBCaXNlY3QgdGhlIGN1cnJlbnQgcXVhZHJhbnQuXG4gICAgaWYgKG5vZGUubGVuZ3RoKSB7XG4gICAgICB2YXIgeG0gPSAoeDEgKyB4MikgLyAyLFxuICAgICAgICAgIHltID0gKHkxICsgeTIpIC8gMjtcblxuICAgICAgcXVhZHMucHVzaChcbiAgICAgICAgbmV3IFF1YWQobm9kZVszXSwgeG0sIHltLCB4MiwgeTIpLFxuICAgICAgICBuZXcgUXVhZChub2RlWzJdLCB4MSwgeW0sIHhtLCB5MiksXG4gICAgICAgIG5ldyBRdWFkKG5vZGVbMV0sIHhtLCB5MSwgeDIsIHltKSxcbiAgICAgICAgbmV3IFF1YWQobm9kZVswXSwgeDEsIHkxLCB4bSwgeW0pXG4gICAgICApO1xuXG4gICAgICAvLyBWaXNpdCB0aGUgY2xvc2VzdCBxdWFkcmFudCBmaXJzdC5cbiAgICAgIGlmIChpID0gKHkgPj0geW0pIDw8IDEgfCAoeCA+PSB4bSkpIHtcbiAgICAgICAgcSA9IHF1YWRzW3F1YWRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBxdWFkc1txdWFkcy5sZW5ndGggLSAxXSA9IHF1YWRzW3F1YWRzLmxlbmd0aCAtIDEgLSBpXTtcbiAgICAgICAgcXVhZHNbcXVhZHMubGVuZ3RoIC0gMSAtIGldID0gcTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWaXNpdCB0aGlzIHBvaW50LiAoVmlzaXRpbmcgY29pbmNpZGVudCBwb2ludHMgaXNu4oCZdCBuZWNlc3NhcnkhKVxuICAgIGVsc2Uge1xuICAgICAgdmFyIGR4ID0geCAtICt0aGlzLl94LmNhbGwobnVsbCwgbm9kZS5kYXRhKSxcbiAgICAgICAgICBkeSA9IHkgLSArdGhpcy5feS5jYWxsKG51bGwsIG5vZGUuZGF0YSksXG4gICAgICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgIGlmIChkMiA8IHJhZGl1cykge1xuICAgICAgICB2YXIgZCA9IE1hdGguc3FydChyYWRpdXMgPSBkMik7XG4gICAgICAgIHgwID0geCAtIGQsIHkwID0geSAtIGQ7XG4gICAgICAgIHgzID0geCArIGQsIHkzID0geSArIGQ7XG4gICAgICAgIGRhdGEgPSBub2RlLmRhdGE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIHRyZWVfcmVtb3ZlKGQpIHtcbiAgaWYgKGlzTmFOKHggPSArdGhpcy5feC5jYWxsKG51bGwsIGQpKSB8fCBpc05hTih5ID0gK3RoaXMuX3kuY2FsbChudWxsLCBkKSkpIHJldHVybiB0aGlzOyAvLyBpZ25vcmUgaW52YWxpZCBwb2ludHNcblxuICB2YXIgcGFyZW50LFxuICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXG4gICAgICByZXRhaW5lcixcbiAgICAgIHByZXZpb3VzLFxuICAgICAgbmV4dCxcbiAgICAgIHgwID0gdGhpcy5feDAsXG4gICAgICB5MCA9IHRoaXMuX3kwLFxuICAgICAgeDEgPSB0aGlzLl94MSxcbiAgICAgIHkxID0gdGhpcy5feTEsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHhtLFxuICAgICAgeW0sXG4gICAgICByaWdodCxcbiAgICAgIGJvdHRvbSxcbiAgICAgIGksXG4gICAgICBqO1xuXG4gIC8vIElmIHRoZSB0cmVlIGlzIGVtcHR5LCBpbml0aWFsaXplIHRoZSByb290IGFzIGEgbGVhZi5cbiAgaWYgKCFub2RlKSByZXR1cm4gdGhpcztcblxuICAvLyBGaW5kIHRoZSBsZWFmIG5vZGUgZm9yIHRoZSBwb2ludC5cbiAgLy8gV2hpbGUgZGVzY2VuZGluZywgYWxzbyByZXRhaW4gdGhlIGRlZXBlc3QgcGFyZW50IHdpdGggYSBub24tcmVtb3ZlZCBzaWJsaW5nLlxuICBpZiAobm9kZS5sZW5ndGgpIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKHJpZ2h0ID0geCA+PSAoeG0gPSAoeDAgKyB4MSkgLyAyKSkgeDAgPSB4bTsgZWxzZSB4MSA9IHhtO1xuICAgIGlmIChib3R0b20gPSB5ID49ICh5bSA9ICh5MCArIHkxKSAvIDIpKSB5MCA9IHltOyBlbHNlIHkxID0geW07XG4gICAgaWYgKCEocGFyZW50ID0gbm9kZSwgbm9kZSA9IG5vZGVbaSA9IGJvdHRvbSA8PCAxIHwgcmlnaHRdKSkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCFub2RlLmxlbmd0aCkgYnJlYWs7XG4gICAgaWYgKHBhcmVudFsoaSArIDEpICYgM10gfHwgcGFyZW50WyhpICsgMikgJiAzXSB8fCBwYXJlbnRbKGkgKyAzKSAmIDNdKSByZXRhaW5lciA9IHBhcmVudCwgaiA9IGk7XG4gIH1cblxuICAvLyBGaW5kIHRoZSBwb2ludCB0byByZW1vdmUuXG4gIHdoaWxlIChub2RlLmRhdGEgIT09IGQpIGlmICghKHByZXZpb3VzID0gbm9kZSwgbm9kZSA9IG5vZGUubmV4dCkpIHJldHVybiB0aGlzO1xuICBpZiAobmV4dCA9IG5vZGUubmV4dCkgZGVsZXRlIG5vZGUubmV4dDtcblxuICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY29pbmNpZGVudCBwb2ludHMsIHJlbW92ZSBqdXN0IHRoZSBwb2ludC5cbiAgaWYgKHByZXZpb3VzKSByZXR1cm4gKG5leHQgPyBwcmV2aW91cy5uZXh0ID0gbmV4dCA6IGRlbGV0ZSBwcmV2aW91cy5uZXh0KSwgdGhpcztcblxuICAvLyBJZiB0aGlzIGlzIHRoZSByb290IHBvaW50LCByZW1vdmUgaXQuXG4gIGlmICghcGFyZW50KSByZXR1cm4gdGhpcy5fcm9vdCA9IG5leHQsIHRoaXM7XG5cbiAgLy8gUmVtb3ZlIHRoaXMgbGVhZi5cbiAgbmV4dCA/IHBhcmVudFtpXSA9IG5leHQgOiBkZWxldGUgcGFyZW50W2ldO1xuXG4gIC8vIElmIHRoZSBwYXJlbnQgbm93IGNvbnRhaW5zIGV4YWN0bHkgb25lIGxlYWYsIGNvbGxhcHNlIHN1cGVyZmx1b3VzIHBhcmVudHMuXG4gIGlmICgobm9kZSA9IHBhcmVudFswXSB8fCBwYXJlbnRbMV0gfHwgcGFyZW50WzJdIHx8IHBhcmVudFszXSlcbiAgICAgICYmIG5vZGUgPT09IChwYXJlbnRbM10gfHwgcGFyZW50WzJdIHx8IHBhcmVudFsxXSB8fCBwYXJlbnRbMF0pXG4gICAgICAmJiAhbm9kZS5sZW5ndGgpIHtcbiAgICBpZiAocmV0YWluZXIpIHJldGFpbmVyW2pdID0gbm9kZTtcbiAgICBlbHNlIHRoaXMuX3Jvb3QgPSBub2RlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUFsbChkYXRhKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gZGF0YS5sZW5ndGg7IGkgPCBuOyArK2kpIHRoaXMucmVtb3ZlKGRhdGFbaV0pO1xuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdHJlZV9yb290KCkge1xuICByZXR1cm4gdGhpcy5fcm9vdDtcbn1cblxuZnVuY3Rpb24gdHJlZV9zaXplKCkge1xuICB2YXIgc2l6ZSA9IDA7XG4gIHRoaXMudmlzaXQoZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICghbm9kZS5sZW5ndGgpIGRvICsrc2l6ZTsgd2hpbGUgKG5vZGUgPSBub2RlLm5leHQpXG4gIH0pO1xuICByZXR1cm4gc2l6ZTtcbn1cblxuZnVuY3Rpb24gdHJlZV92aXNpdChjYWxsYmFjaykge1xuICB2YXIgcXVhZHMgPSBbXSwgcSwgbm9kZSA9IHRoaXMuX3Jvb3QsIGNoaWxkLCB4MCwgeTAsIHgxLCB5MTtcbiAgaWYgKG5vZGUpIHF1YWRzLnB1c2gobmV3IFF1YWQobm9kZSwgdGhpcy5feDAsIHRoaXMuX3kwLCB0aGlzLl94MSwgdGhpcy5feTEpKTtcbiAgd2hpbGUgKHEgPSBxdWFkcy5wb3AoKSkge1xuICAgIGlmICghY2FsbGJhY2sobm9kZSA9IHEubm9kZSwgeDAgPSBxLngwLCB5MCA9IHEueTAsIHgxID0gcS54MSwgeTEgPSBxLnkxKSAmJiBub2RlLmxlbmd0aCkge1xuICAgICAgdmFyIHhtID0gKHgwICsgeDEpIC8gMiwgeW0gPSAoeTAgKyB5MSkgLyAyO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVszXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHltLCB4MSwgeTEpKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMl0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHgwLCB5bSwgeG0sIHkxKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzFdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4bSwgeTAsIHgxLCB5bSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVswXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHkwLCB4bSwgeW0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHRyZWVfdmlzaXRBZnRlcihjYWxsYmFjaykge1xuICB2YXIgcXVhZHMgPSBbXSwgbmV4dCA9IFtdLCBxO1xuICBpZiAodGhpcy5fcm9vdCkgcXVhZHMucHVzaChuZXcgUXVhZCh0aGlzLl9yb290LCB0aGlzLl94MCwgdGhpcy5feTAsIHRoaXMuX3gxLCB0aGlzLl95MSkpO1xuICB3aGlsZSAocSA9IHF1YWRzLnBvcCgpKSB7XG4gICAgdmFyIG5vZGUgPSBxLm5vZGU7XG4gICAgaWYgKG5vZGUubGVuZ3RoKSB7XG4gICAgICB2YXIgY2hpbGQsIHgwID0gcS54MCwgeTAgPSBxLnkwLCB4MSA9IHEueDEsIHkxID0gcS55MSwgeG0gPSAoeDAgKyB4MSkgLyAyLCB5bSA9ICh5MCArIHkxKSAvIDI7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzBdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4MCwgeTAsIHhtLCB5bSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVsxXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHkwLCB4MSwgeW0pKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMl0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHgwLCB5bSwgeG0sIHkxKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzNdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4bSwgeW0sIHgxLCB5MSkpO1xuICAgIH1cbiAgICBuZXh0LnB1c2gocSk7XG4gIH1cbiAgd2hpbGUgKHEgPSBuZXh0LnBvcCgpKSB7XG4gICAgY2FsbGJhY2socS5ub2RlLCBxLngwLCBxLnkwLCBxLngxLCBxLnkxKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFgoZCkge1xuICByZXR1cm4gZFswXTtcbn1cblxuZnVuY3Rpb24gdHJlZV94KF8pIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGhpcy5feCA9IF8sIHRoaXMpIDogdGhpcy5feDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFkoZCkge1xuICByZXR1cm4gZFsxXTtcbn1cblxuZnVuY3Rpb24gdHJlZV95KF8pIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGhpcy5feSA9IF8sIHRoaXMpIDogdGhpcy5feTtcbn1cblxuZnVuY3Rpb24gcXVhZHRyZWUobm9kZXMsIHgsIHkpIHtcbiAgdmFyIHRyZWUgPSBuZXcgUXVhZHRyZWUoeCA9PSBudWxsID8gZGVmYXVsdFggOiB4LCB5ID09IG51bGwgPyBkZWZhdWx0WSA6IHksIE5hTiwgTmFOLCBOYU4sIE5hTik7XG4gIHJldHVybiBub2RlcyA9PSBudWxsID8gdHJlZSA6IHRyZWUuYWRkQWxsKG5vZGVzKTtcbn1cblxuZnVuY3Rpb24gUXVhZHRyZWUoeCwgeSwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdGhpcy5feCA9IHg7XG4gIHRoaXMuX3kgPSB5O1xuICB0aGlzLl94MCA9IHgwO1xuICB0aGlzLl95MCA9IHkwO1xuICB0aGlzLl94MSA9IHgxO1xuICB0aGlzLl95MSA9IHkxO1xuICB0aGlzLl9yb290ID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBsZWFmX2NvcHkobGVhZikge1xuICB2YXIgY29weSA9IHtkYXRhOiBsZWFmLmRhdGF9LCBuZXh0ID0gY29weTtcbiAgd2hpbGUgKGxlYWYgPSBsZWFmLm5leHQpIG5leHQgPSBuZXh0Lm5leHQgPSB7ZGF0YTogbGVhZi5kYXRhfTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbnZhciB0cmVlUHJvdG8gPSBxdWFkdHJlZS5wcm90b3R5cGUgPSBRdWFkdHJlZS5wcm90b3R5cGU7XG5cbnRyZWVQcm90by5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb3B5ID0gbmV3IFF1YWR0cmVlKHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3gwLCB0aGlzLl95MCwgdGhpcy5feDEsIHRoaXMuX3kxKSxcbiAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxuICAgICAgbm9kZXMsXG4gICAgICBjaGlsZDtcblxuICBpZiAoIW5vZGUpIHJldHVybiBjb3B5O1xuXG4gIGlmICghbm9kZS5sZW5ndGgpIHJldHVybiBjb3B5Ll9yb290ID0gbGVhZl9jb3B5KG5vZGUpLCBjb3B5O1xuXG4gIG5vZGVzID0gW3tzb3VyY2U6IG5vZGUsIHRhcmdldDogY29weS5fcm9vdCA9IG5ldyBBcnJheSg0KX1dO1xuICB3aGlsZSAobm9kZSA9IG5vZGVzLnBvcCgpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGUuc291cmNlW2ldKSB7XG4gICAgICAgIGlmIChjaGlsZC5sZW5ndGgpIG5vZGVzLnB1c2goe3NvdXJjZTogY2hpbGQsIHRhcmdldDogbm9kZS50YXJnZXRbaV0gPSBuZXcgQXJyYXkoNCl9KTtcbiAgICAgICAgZWxzZSBub2RlLnRhcmdldFtpXSA9IGxlYWZfY29weShjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59O1xuXG50cmVlUHJvdG8uYWRkID0gdHJlZV9hZGQ7XG50cmVlUHJvdG8uYWRkQWxsID0gYWRkQWxsO1xudHJlZVByb3RvLmNvdmVyID0gdHJlZV9jb3ZlcjtcbnRyZWVQcm90by5kYXRhID0gdHJlZV9kYXRhO1xudHJlZVByb3RvLmV4dGVudCA9IHRyZWVfZXh0ZW50O1xudHJlZVByb3RvLmZpbmQgPSB0cmVlX2ZpbmQ7XG50cmVlUHJvdG8ucmVtb3ZlID0gdHJlZV9yZW1vdmU7XG50cmVlUHJvdG8ucmVtb3ZlQWxsID0gcmVtb3ZlQWxsO1xudHJlZVByb3RvLnJvb3QgPSB0cmVlX3Jvb3Q7XG50cmVlUHJvdG8uc2l6ZSA9IHRyZWVfc2l6ZTtcbnRyZWVQcm90by52aXNpdCA9IHRyZWVfdmlzaXQ7XG50cmVlUHJvdG8udmlzaXRBZnRlciA9IHRyZWVfdmlzaXRBZnRlcjtcbnRyZWVQcm90by54ID0gdHJlZV94O1xudHJlZVByb3RvLnkgPSB0cmVlX3k7XG5cbmV4cG9ydHMucXVhZHRyZWUgPSBxdWFkdHJlZTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIiwiLyogaW50ZXJhY3QuanMgMS4xMC4yNyB8IGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vdGF5ZS9pbnRlcmFjdC5qcy9tYWluL0xJQ0VOU0UgKi9cblxuIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoZSk6KHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczp0fHxzZWxmKS5pbnRlcmFjdD1lKCl9KHRoaXMsKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gdCh0LGUpe3ZhciBuPU9iamVjdC5rZXlzKHQpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciByPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModCk7ZSYmKHI9ci5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsZSkuZW51bWVyYWJsZX0pKSksbi5wdXNoLmFwcGx5KG4scil9cmV0dXJuIG59ZnVuY3Rpb24gZShlKXtmb3IodmFyIG49MTtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKXt2YXIgcj1udWxsIT1hcmd1bWVudHNbbl0/YXJndW1lbnRzW25dOnt9O24lMj90KE9iamVjdChyKSwhMCkuZm9yRWFjaCgoZnVuY3Rpb24odCl7YShlLHQsclt0XSl9KSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhyKSk6dChPYmplY3QocikpLmZvckVhY2goKGZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLHQpKX0pKX1yZXR1cm4gZX1mdW5jdGlvbiBuKHQpe3JldHVybiBuPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9LG4odCl9ZnVuY3Rpb24gcih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaSh0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lW25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxkKHIua2V5KSxyKX19ZnVuY3Rpb24gbyh0LGUsbil7cmV0dXJuIGUmJmkodC5wcm90b3R5cGUsZSksbiYmaSh0LG4pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwicHJvdG90eXBlXCIse3dyaXRhYmxlOiExfSksdH1mdW5jdGlvbiBhKHQsZSxuKXtyZXR1cm4oZT1kKGUpKWluIHQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnRbZV09bix0fWZ1bmN0aW9uIHModCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwicHJvdG90eXBlXCIse3dyaXRhYmxlOiExfSksZSYmbCh0LGUpfWZ1bmN0aW9uIGModCl7cmV0dXJuIGM9T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCk6ZnVuY3Rpb24odCl7cmV0dXJuIHQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCl9LGModCl9ZnVuY3Rpb24gbCh0LGUpe3JldHVybiBsPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuX19wcm90b19fPWUsdH0sbCh0LGUpfWZ1bmN0aW9uIHUodCl7aWYodm9pZCAwPT09dCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIHR9ZnVuY3Rpb24gcCh0KXt2YXIgZT1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhUmVmbGVjdC5jb25zdHJ1Y3QpcmV0dXJuITE7aWYoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2godCl7cmV0dXJuITF9fSgpO3JldHVybiBmdW5jdGlvbigpe3ZhciBuLHI9Yyh0KTtpZihlKXt2YXIgaT1jKHRoaXMpLmNvbnN0cnVjdG9yO249UmVmbGVjdC5jb25zdHJ1Y3Qocixhcmd1bWVudHMsaSl9ZWxzZSBuPXIuYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiBmdW5jdGlvbih0LGUpe2lmKGUmJihcIm9iamVjdFwiPT10eXBlb2YgZXx8XCJmdW5jdGlvblwiPT10eXBlb2YgZSkpcmV0dXJuIGU7aWYodm9pZCAwIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7cmV0dXJuIHUodCl9KHRoaXMsbil9fWZ1bmN0aW9uIGYoKXtyZXR1cm4gZj1cInVuZGVmaW5lZFwiIT10eXBlb2YgUmVmbGVjdCYmUmVmbGVjdC5nZXQ/UmVmbGVjdC5nZXQuYmluZCgpOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1mdW5jdGlvbih0LGUpe2Zvcig7IU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGUpJiZudWxsIT09KHQ9Yyh0KSk7KTtyZXR1cm4gdH0odCxlKTtpZihyKXt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsZSk7cmV0dXJuIGkuZ2V0P2kuZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aDwzP3Q6bik6aS52YWx1ZX19LGYuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZ1bmN0aW9uIGQodCl7dmFyIGU9ZnVuY3Rpb24odCxlKXtpZihcIm9iamVjdFwiIT10eXBlb2YgdHx8bnVsbD09PXQpcmV0dXJuIHQ7dmFyIG49dFtTeW1ib2wudG9QcmltaXRpdmVdO2lmKHZvaWQgMCE9PW4pe3ZhciByPW4uY2FsbCh0LGV8fFwiZGVmYXVsdFwiKTtpZihcIm9iamVjdFwiIT10eXBlb2YgcilyZXR1cm4gcjt0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIil9cmV0dXJuKFwic3RyaW5nXCI9PT1lP1N0cmluZzpOdW1iZXIpKHQpfSh0LFwic3RyaW5nXCIpO3JldHVyblwic3ltYm9sXCI9PXR5cGVvZiBlP2U6ZStcIlwifXZhciBoPWZ1bmN0aW9uKHQpe3JldHVybiEoIXR8fCF0LldpbmRvdykmJnQgaW5zdGFuY2VvZiB0LldpbmRvd30sdj12b2lkIDAsZz12b2lkIDA7ZnVuY3Rpb24gbSh0KXt2PXQ7dmFyIGU9dC5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKTtlLm93bmVyRG9jdW1lbnQhPT10LmRvY3VtZW50JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LndyYXAmJnQud3JhcChlKT09PWUmJih0PXQud3JhcCh0KSksZz10fWZ1bmN0aW9uIHkodCl7cmV0dXJuIGgodCk/dDoodC5vd25lckRvY3VtZW50fHx0KS5kZWZhdWx0Vmlld3x8Zy53aW5kb3d9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmd2luZG93JiZtKHdpbmRvdyk7dmFyIGI9ZnVuY3Rpb24odCl7cmV0dXJuISF0JiZcIm9iamVjdFwiPT09bih0KX0seD1mdW5jdGlvbih0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0fSx3PXt3aW5kb3c6ZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT1nfHxoKHQpfSxkb2NGcmFnOmZ1bmN0aW9uKHQpe3JldHVybiBiKHQpJiYxMT09PXQubm9kZVR5cGV9LG9iamVjdDpiLGZ1bmM6eCxudW1iZXI6ZnVuY3Rpb24odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHR9LGJvb2w6ZnVuY3Rpb24odCl7cmV0dXJuXCJib29sZWFuXCI9PXR5cGVvZiB0fSxzdHJpbmc6ZnVuY3Rpb24odCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHR9LGVsZW1lbnQ6ZnVuY3Rpb24odCl7aWYoIXR8fFwib2JqZWN0XCIhPT1uKHQpKXJldHVybiExO3ZhciBlPXkodCl8fGc7cmV0dXJuL29iamVjdHxmdW5jdGlvbi8udGVzdChcInVuZGVmaW5lZFwiPT10eXBlb2YgRWxlbWVudD9cInVuZGVmaW5lZFwiOm4oRWxlbWVudCkpP3QgaW5zdGFuY2VvZiBFbGVtZW50fHx0IGluc3RhbmNlb2YgZS5FbGVtZW50OjE9PT10Lm5vZGVUeXBlJiZcInN0cmluZ1wiPT10eXBlb2YgdC5ub2RlTmFtZX0scGxhaW5PYmplY3Q6ZnVuY3Rpb24odCl7cmV0dXJuIGIodCkmJiEhdC5jb25zdHJ1Y3RvciYmL2Z1bmN0aW9uIE9iamVjdFxcYi8udGVzdCh0LmNvbnN0cnVjdG9yLnRvU3RyaW5nKCkpfSxhcnJheTpmdW5jdGlvbih0KXtyZXR1cm4gYih0KSYmdm9pZCAwIT09dC5sZW5ndGgmJngodC5zcGxpY2UpfX07ZnVuY3Rpb24gRSh0KXt2YXIgZT10LmludGVyYWN0aW9uO2lmKFwiZHJhZ1wiPT09ZS5wcmVwYXJlZC5uYW1lKXt2YXIgbj1lLnByZXBhcmVkLmF4aXM7XCJ4XCI9PT1uPyhlLmNvb3Jkcy5jdXIucGFnZS55PWUuY29vcmRzLnN0YXJ0LnBhZ2UueSxlLmNvb3Jkcy5jdXIuY2xpZW50Lnk9ZS5jb29yZHMuc3RhcnQuY2xpZW50LnksZS5jb29yZHMudmVsb2NpdHkuY2xpZW50Lnk9MCxlLmNvb3Jkcy52ZWxvY2l0eS5wYWdlLnk9MCk6XCJ5XCI9PT1uJiYoZS5jb29yZHMuY3VyLnBhZ2UueD1lLmNvb3Jkcy5zdGFydC5wYWdlLngsZS5jb29yZHMuY3VyLmNsaWVudC54PWUuY29vcmRzLnN0YXJ0LmNsaWVudC54LGUuY29vcmRzLnZlbG9jaXR5LmNsaWVudC54PTAsZS5jb29yZHMudmVsb2NpdHkucGFnZS54PTApfX1mdW5jdGlvbiBUKHQpe3ZhciBlPXQuaUV2ZW50LG49dC5pbnRlcmFjdGlvbjtpZihcImRyYWdcIj09PW4ucHJlcGFyZWQubmFtZSl7dmFyIHI9bi5wcmVwYXJlZC5heGlzO2lmKFwieFwiPT09cnx8XCJ5XCI9PT1yKXt2YXIgaT1cInhcIj09PXI/XCJ5XCI6XCJ4XCI7ZS5wYWdlW2ldPW4uY29vcmRzLnN0YXJ0LnBhZ2VbaV0sZS5jbGllbnRbaV09bi5jb29yZHMuc3RhcnQuY2xpZW50W2ldLGUuZGVsdGFbaV09MH19fXZhciBTPXtpZDpcImFjdGlvbnMvZHJhZ1wiLGluc3RhbGw6ZnVuY3Rpb24odCl7dmFyIGU9dC5hY3Rpb25zLG49dC5JbnRlcmFjdGFibGUscj10LmRlZmF1bHRzO24ucHJvdG90eXBlLmRyYWdnYWJsZT1TLmRyYWdnYWJsZSxlLm1hcC5kcmFnPVMsZS5tZXRob2REaWN0LmRyYWc9XCJkcmFnZ2FibGVcIixyLmFjdGlvbnMuZHJhZz1TLmRlZmF1bHRzfSxsaXN0ZW5lcnM6e1wiaW50ZXJhY3Rpb25zOmJlZm9yZS1hY3Rpb24tbW92ZVwiOkUsXCJpbnRlcmFjdGlvbnM6YWN0aW9uLXJlc3VtZVwiOkUsXCJpbnRlcmFjdGlvbnM6YWN0aW9uLW1vdmVcIjpULFwiYXV0by1zdGFydDpjaGVja1wiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj10LmludGVyYWN0YWJsZSxyPXQuYnV0dG9ucyxpPW4ub3B0aW9ucy5kcmFnO2lmKGkmJmkuZW5hYmxlZCYmKCFlLnBvaW50ZXJJc0Rvd258fCEvbW91c2V8cG9pbnRlci8udGVzdChlLnBvaW50ZXJUeXBlKXx8MCE9KHImbi5vcHRpb25zLmRyYWcubW91c2VCdXR0b25zKSkpcmV0dXJuIHQuYWN0aW9uPXtuYW1lOlwiZHJhZ1wiLGF4aXM6XCJzdGFydFwiPT09aS5sb2NrQXhpcz9pLnN0YXJ0QXhpczppLmxvY2tBeGlzfSwhMX19LGRyYWdnYWJsZTpmdW5jdGlvbih0KXtyZXR1cm4gdy5vYmplY3QodCk/KHRoaXMub3B0aW9ucy5kcmFnLmVuYWJsZWQ9ITEhPT10LmVuYWJsZWQsdGhpcy5zZXRQZXJBY3Rpb24oXCJkcmFnXCIsdCksdGhpcy5zZXRPbkV2ZW50cyhcImRyYWdcIix0KSwvXih4eXx4fHl8c3RhcnQpJC8udGVzdCh0LmxvY2tBeGlzKSYmKHRoaXMub3B0aW9ucy5kcmFnLmxvY2tBeGlzPXQubG9ja0F4aXMpLC9eKHh5fHh8eSkkLy50ZXN0KHQuc3RhcnRBeGlzKSYmKHRoaXMub3B0aW9ucy5kcmFnLnN0YXJ0QXhpcz10LnN0YXJ0QXhpcyksdGhpcyk6dy5ib29sKHQpPyh0aGlzLm9wdGlvbnMuZHJhZy5lbmFibGVkPXQsdGhpcyk6dGhpcy5vcHRpb25zLmRyYWd9LGJlZm9yZU1vdmU6RSxtb3ZlOlQsZGVmYXVsdHM6e3N0YXJ0QXhpczpcInh5XCIsbG9ja0F4aXM6XCJ4eVwifSxnZXRDdXJzb3I6ZnVuY3Rpb24oKXtyZXR1cm5cIm1vdmVcIn0sZmlsdGVyRXZlbnRUeXBlOmZ1bmN0aW9uKHQpe3JldHVybiAwPT09dC5zZWFyY2goXCJkcmFnXCIpfX0sXz1TLFA9e2luaXQ6ZnVuY3Rpb24odCl7dmFyIGU9dDtQLmRvY3VtZW50PWUuZG9jdW1lbnQsUC5Eb2N1bWVudEZyYWdtZW50PWUuRG9jdW1lbnRGcmFnbWVudHx8TyxQLlNWR0VsZW1lbnQ9ZS5TVkdFbGVtZW50fHxPLFAuU1ZHU1ZHRWxlbWVudD1lLlNWR1NWR0VsZW1lbnR8fE8sUC5TVkdFbGVtZW50SW5zdGFuY2U9ZS5TVkdFbGVtZW50SW5zdGFuY2V8fE8sUC5FbGVtZW50PWUuRWxlbWVudHx8TyxQLkhUTUxFbGVtZW50PWUuSFRNTEVsZW1lbnR8fFAuRWxlbWVudCxQLkV2ZW50PWUuRXZlbnQsUC5Ub3VjaD1lLlRvdWNofHxPLFAuUG9pbnRlckV2ZW50PWUuUG9pbnRlckV2ZW50fHxlLk1TUG9pbnRlckV2ZW50fSxkb2N1bWVudDpudWxsLERvY3VtZW50RnJhZ21lbnQ6bnVsbCxTVkdFbGVtZW50Om51bGwsU1ZHU1ZHRWxlbWVudDpudWxsLFNWR0VsZW1lbnRJbnN0YW5jZTpudWxsLEVsZW1lbnQ6bnVsbCxIVE1MRWxlbWVudDpudWxsLEV2ZW50Om51bGwsVG91Y2g6bnVsbCxQb2ludGVyRXZlbnQ6bnVsbH07ZnVuY3Rpb24gTygpe312YXIgaz1QO3ZhciBEPXtpbml0OmZ1bmN0aW9uKHQpe3ZhciBlPWsuRWxlbWVudCxuPXQubmF2aWdhdG9yfHx7fTtELnN1cHBvcnRzVG91Y2g9XCJvbnRvdWNoc3RhcnRcImluIHR8fHcuZnVuYyh0LkRvY3VtZW50VG91Y2gpJiZrLmRvY3VtZW50IGluc3RhbmNlb2YgdC5Eb2N1bWVudFRvdWNoLEQuc3VwcG9ydHNQb2ludGVyRXZlbnQ9ITEhPT1uLnBvaW50ZXJFbmFibGVkJiYhIWsuUG9pbnRlckV2ZW50LEQuaXNJT1M9L2lQKGhvbmV8b2R8YWQpLy50ZXN0KG4ucGxhdGZvcm0pLEQuaXNJT1M3PS9pUChob25lfG9kfGFkKS8udGVzdChuLnBsYXRmb3JtKSYmL09TIDdbXlxcZF0vLnRlc3Qobi5hcHBWZXJzaW9uKSxELmlzSWU5PS9NU0lFIDkvLnRlc3Qobi51c2VyQWdlbnQpLEQuaXNPcGVyYU1vYmlsZT1cIk9wZXJhXCI9PT1uLmFwcE5hbWUmJkQuc3VwcG9ydHNUb3VjaCYmL1ByZXN0by8udGVzdChuLnVzZXJBZ2VudCksRC5wcmVmaXhlZE1hdGNoZXNTZWxlY3Rvcj1cIm1hdGNoZXNcImluIGUucHJvdG90eXBlP1wibWF0Y2hlc1wiOlwid2Via2l0TWF0Y2hlc1NlbGVjdG9yXCJpbiBlLnByb3RvdHlwZT9cIndlYmtpdE1hdGNoZXNTZWxlY3RvclwiOlwibW96TWF0Y2hlc1NlbGVjdG9yXCJpbiBlLnByb3RvdHlwZT9cIm1vek1hdGNoZXNTZWxlY3RvclwiOlwib01hdGNoZXNTZWxlY3RvclwiaW4gZS5wcm90b3R5cGU/XCJvTWF0Y2hlc1NlbGVjdG9yXCI6XCJtc01hdGNoZXNTZWxlY3RvclwiLEQucEV2ZW50VHlwZXM9RC5zdXBwb3J0c1BvaW50ZXJFdmVudD9rLlBvaW50ZXJFdmVudD09PXQuTVNQb2ludGVyRXZlbnQ/e3VwOlwiTVNQb2ludGVyVXBcIixkb3duOlwiTVNQb2ludGVyRG93blwiLG92ZXI6XCJtb3VzZW92ZXJcIixvdXQ6XCJtb3VzZW91dFwiLG1vdmU6XCJNU1BvaW50ZXJNb3ZlXCIsY2FuY2VsOlwiTVNQb2ludGVyQ2FuY2VsXCJ9Ont1cDpcInBvaW50ZXJ1cFwiLGRvd246XCJwb2ludGVyZG93blwiLG92ZXI6XCJwb2ludGVyb3ZlclwiLG91dDpcInBvaW50ZXJvdXRcIixtb3ZlOlwicG9pbnRlcm1vdmVcIixjYW5jZWw6XCJwb2ludGVyY2FuY2VsXCJ9Om51bGwsRC53aGVlbEV2ZW50PWsuZG9jdW1lbnQmJlwib25tb3VzZXdoZWVsXCJpbiBrLmRvY3VtZW50P1wibW91c2V3aGVlbFwiOlwid2hlZWxcIn0sc3VwcG9ydHNUb3VjaDpudWxsLHN1cHBvcnRzUG9pbnRlckV2ZW50Om51bGwsaXNJT1M3Om51bGwsaXNJT1M6bnVsbCxpc0llOTpudWxsLGlzT3BlcmFNb2JpbGU6bnVsbCxwcmVmaXhlZE1hdGNoZXNTZWxlY3RvcjpudWxsLHBFdmVudFR5cGVzOm51bGwsd2hlZWxFdmVudDpudWxsfTt2YXIgST1EO2Z1bmN0aW9uIE0odCxlKXtpZih0LmNvbnRhaW5zKXJldHVybiB0LmNvbnRhaW5zKGUpO2Zvcig7ZTspe2lmKGU9PT10KXJldHVybiEwO2U9ZS5wYXJlbnROb2RlfXJldHVybiExfWZ1bmN0aW9uIHoodCxlKXtmb3IoO3cuZWxlbWVudCh0KTspe2lmKFIodCxlKSlyZXR1cm4gdDt0PUEodCl9cmV0dXJuIG51bGx9ZnVuY3Rpb24gQSh0KXt2YXIgZT10LnBhcmVudE5vZGU7aWYody5kb2NGcmFnKGUpKXtmb3IoOyhlPWUuaG9zdCkmJncuZG9jRnJhZyhlKTspO3JldHVybiBlfXJldHVybiBlfWZ1bmN0aW9uIFIodCxlKXtyZXR1cm4gZyE9PXYmJihlPWUucmVwbGFjZSgvXFwvZGVlcFxcLy9nLFwiIFwiKSksdFtJLnByZWZpeGVkTWF0Y2hlc1NlbGVjdG9yXShlKX12YXIgQz1mdW5jdGlvbih0KXtyZXR1cm4gdC5wYXJlbnROb2RlfHx0Lmhvc3R9O2Z1bmN0aW9uIGoodCxlKXtmb3IodmFyIG4scj1bXSxpPXQ7KG49QyhpKSkmJmkhPT1lJiZuIT09aS5vd25lckRvY3VtZW50OylyLnVuc2hpZnQoaSksaT1uO3JldHVybiByfWZ1bmN0aW9uIEYodCxlLG4pe2Zvcig7dy5lbGVtZW50KHQpOyl7aWYoUih0LGUpKXJldHVybiEwO2lmKCh0PUEodCkpPT09bilyZXR1cm4gUih0LGUpfXJldHVybiExfWZ1bmN0aW9uIFgodCl7cmV0dXJuIHQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnR8fHR9ZnVuY3Rpb24gWSh0KXt2YXIgZT10IGluc3RhbmNlb2Ygay5TVkdFbGVtZW50P3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk6dC5nZXRDbGllbnRSZWN0cygpWzBdO3JldHVybiBlJiZ7bGVmdDplLmxlZnQscmlnaHQ6ZS5yaWdodCx0b3A6ZS50b3AsYm90dG9tOmUuYm90dG9tLHdpZHRoOmUud2lkdGh8fGUucmlnaHQtZS5sZWZ0LGhlaWdodDplLmhlaWdodHx8ZS5ib3R0b20tZS50b3B9fWZ1bmN0aW9uIEwodCl7dmFyIGUsbj1ZKHQpO2lmKCFJLmlzSU9TNyYmbil7dmFyIHI9e3g6KGU9KGU9eSh0KSl8fGcpLnNjcm9sbFh8fGUuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQseTplLnNjcm9sbFl8fGUuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcH07bi5sZWZ0Kz1yLngsbi5yaWdodCs9ci54LG4udG9wKz1yLnksbi5ib3R0b20rPXIueX1yZXR1cm4gbn1mdW5jdGlvbiBxKHQpe2Zvcih2YXIgZT1bXTt0OyllLnB1c2godCksdD1BKHQpO3JldHVybiBlfWZ1bmN0aW9uIEIodCl7cmV0dXJuISF3LnN0cmluZyh0KSYmKGsuZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0KSwhMCl9ZnVuY3Rpb24gVih0LGUpe2Zvcih2YXIgbiBpbiBlKXRbbl09ZVtuXTtyZXR1cm4gdH1mdW5jdGlvbiBXKHQsZSxuKXtyZXR1cm5cInBhcmVudFwiPT09dD9BKG4pOlwic2VsZlwiPT09dD9lLmdldFJlY3Qobik6eihuLHQpfWZ1bmN0aW9uIEcodCxlLG4scil7dmFyIGk9dDtyZXR1cm4gdy5zdHJpbmcoaSk/aT1XKGksZSxuKTp3LmZ1bmMoaSkmJihpPWkuYXBwbHkodm9pZCAwLHIpKSx3LmVsZW1lbnQoaSkmJihpPUwoaSkpLGl9ZnVuY3Rpb24gTih0KXtyZXR1cm4gdCYme3g6XCJ4XCJpbiB0P3QueDp0LmxlZnQseTpcInlcImluIHQ/dC55OnQudG9wfX1mdW5jdGlvbiBVKHQpe3JldHVybiF0fHxcInhcImluIHQmJlwieVwiaW4gdHx8KCh0PVYoe30sdCkpLng9dC5sZWZ0fHwwLHQueT10LnRvcHx8MCx0LndpZHRoPXQud2lkdGh8fCh0LnJpZ2h0fHwwKS10LngsdC5oZWlnaHQ9dC5oZWlnaHR8fCh0LmJvdHRvbXx8MCktdC55KSx0fWZ1bmN0aW9uIEgodCxlLG4pe3QubGVmdCYmKGUubGVmdCs9bi54KSx0LnJpZ2h0JiYoZS5yaWdodCs9bi54KSx0LnRvcCYmKGUudG9wKz1uLnkpLHQuYm90dG9tJiYoZS5ib3R0b20rPW4ueSksZS53aWR0aD1lLnJpZ2h0LWUubGVmdCxlLmhlaWdodD1lLmJvdHRvbS1lLnRvcH1mdW5jdGlvbiBLKHQsZSxuKXt2YXIgcj1uJiZ0Lm9wdGlvbnNbbl07cmV0dXJuIE4oRyhyJiZyLm9yaWdpbnx8dC5vcHRpb25zLm9yaWdpbix0LGUsW3QmJmVdKSl8fHt4OjAseTowfX1mdW5jdGlvbiAkKHQsZSl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOmZ1bmN0aW9uKHQpe3JldHVybiEwfSxyPWFyZ3VtZW50cy5sZW5ndGg+Mz9hcmd1bWVudHNbM106dm9pZCAwO2lmKHI9cnx8e30sdy5zdHJpbmcodCkmJi0xIT09dC5zZWFyY2goXCIgXCIpJiYodD1KKHQpKSx3LmFycmF5KHQpKXJldHVybiB0LmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiAkKHQsZSxuLHIpfSkpLHI7aWYody5vYmplY3QodCkmJihlPXQsdD1cIlwiKSx3LmZ1bmMoZSkmJm4odCkpclt0XT1yW3RdfHxbXSxyW3RdLnB1c2goZSk7ZWxzZSBpZih3LmFycmF5KGUpKWZvcih2YXIgaT0wLG89ZTtpPG8ubGVuZ3RoO2krKyl7dmFyIGE9b1tpXTskKHQsYSxuLHIpfWVsc2UgaWYody5vYmplY3QoZSkpZm9yKHZhciBzIGluIGUpeyQoSihzKS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVyblwiXCIuY29uY2F0KHQpLmNvbmNhdChlKX0pKSxlW3NdLG4scil9cmV0dXJuIHJ9ZnVuY3Rpb24gSih0KXtyZXR1cm4gdC50cmltKCkuc3BsaXQoLyArLyl9dmFyIFE9ZnVuY3Rpb24odCxlKXtyZXR1cm4gTWF0aC5zcXJ0KHQqdCtlKmUpfSxaPVtcIndlYmtpdFwiLFwibW96XCJdO2Z1bmN0aW9uIHR0KHQsZSl7dC5fX3NldHx8KHQuX19zZXQ9e30pO3ZhciBuPWZ1bmN0aW9uKG4pe2lmKFouc29tZSgoZnVuY3Rpb24odCl7cmV0dXJuIDA9PT1uLmluZGV4T2YodCl9KSkpcmV0dXJuIDE7XCJmdW5jdGlvblwiIT10eXBlb2YgdFtuXSYmXCJfX3NldFwiIT09biYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG4gaW4gdC5fX3NldD90Ll9fc2V0W25dOnQuX19zZXRbbl09ZVtuXX0sc2V0OmZ1bmN0aW9uKGUpe3QuX19zZXRbbl09ZX0sY29uZmlndXJhYmxlOiEwfSl9O2Zvcih2YXIgciBpbiBlKW4ocik7cmV0dXJuIHR9ZnVuY3Rpb24gZXQodCxlKXt0LnBhZ2U9dC5wYWdlfHx7fSx0LnBhZ2UueD1lLnBhZ2UueCx0LnBhZ2UueT1lLnBhZ2UueSx0LmNsaWVudD10LmNsaWVudHx8e30sdC5jbGllbnQueD1lLmNsaWVudC54LHQuY2xpZW50Lnk9ZS5jbGllbnQueSx0LnRpbWVTdGFtcD1lLnRpbWVTdGFtcH1mdW5jdGlvbiBudCh0KXt0LnBhZ2UueD0wLHQucGFnZS55PTAsdC5jbGllbnQueD0wLHQuY2xpZW50Lnk9MH1mdW5jdGlvbiBydCh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIGsuRXZlbnR8fHQgaW5zdGFuY2VvZiBrLlRvdWNofWZ1bmN0aW9uIGl0KHQsZSxuKXtyZXR1cm4gdD10fHxcInBhZ2VcIiwobj1ufHx7fSkueD1lW3QrXCJYXCJdLG4ueT1lW3QrXCJZXCJdLG59ZnVuY3Rpb24gb3QodCxlKXtyZXR1cm4gZT1lfHx7eDowLHk6MH0sSS5pc09wZXJhTW9iaWxlJiZydCh0KT8oaXQoXCJzY3JlZW5cIix0LGUpLGUueCs9d2luZG93LnNjcm9sbFgsZS55Kz13aW5kb3cuc2Nyb2xsWSk6aXQoXCJwYWdlXCIsdCxlKSxlfWZ1bmN0aW9uIGF0KHQpe3JldHVybiB3Lm51bWJlcih0LnBvaW50ZXJJZCk/dC5wb2ludGVySWQ6dC5pZGVudGlmaWVyfWZ1bmN0aW9uIHN0KHQsZSxuKXt2YXIgcj1lLmxlbmd0aD4xP2x0KGUpOmVbMF07b3Qocix0LnBhZ2UpLGZ1bmN0aW9uKHQsZSl7ZT1lfHx7fSxJLmlzT3BlcmFNb2JpbGUmJnJ0KHQpP2l0KFwic2NyZWVuXCIsdCxlKTppdChcImNsaWVudFwiLHQsZSl9KHIsdC5jbGllbnQpLHQudGltZVN0YW1wPW59ZnVuY3Rpb24gY3QodCl7dmFyIGU9W107cmV0dXJuIHcuYXJyYXkodCk/KGVbMF09dFswXSxlWzFdPXRbMV0pOlwidG91Y2hlbmRcIj09PXQudHlwZT8xPT09dC50b3VjaGVzLmxlbmd0aD8oZVswXT10LnRvdWNoZXNbMF0sZVsxXT10LmNoYW5nZWRUb3VjaGVzWzBdKTowPT09dC50b3VjaGVzLmxlbmd0aCYmKGVbMF09dC5jaGFuZ2VkVG91Y2hlc1swXSxlWzFdPXQuY2hhbmdlZFRvdWNoZXNbMV0pOihlWzBdPXQudG91Y2hlc1swXSxlWzFdPXQudG91Y2hlc1sxXSksZX1mdW5jdGlvbiBsdCh0KXtmb3IodmFyIGU9e3BhZ2VYOjAscGFnZVk6MCxjbGllbnRYOjAsY2xpZW50WTowLHNjcmVlblg6MCxzY3JlZW5ZOjB9LG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtmb3IodmFyIGkgaW4gZSllW2ldKz1yW2ldfWZvcih2YXIgbyBpbiBlKWVbb10vPXQubGVuZ3RoO3JldHVybiBlfWZ1bmN0aW9uIHV0KHQpe2lmKCF0Lmxlbmd0aClyZXR1cm4gbnVsbDt2YXIgZT1jdCh0KSxuPU1hdGgubWluKGVbMF0ucGFnZVgsZVsxXS5wYWdlWCkscj1NYXRoLm1pbihlWzBdLnBhZ2VZLGVbMV0ucGFnZVkpLGk9TWF0aC5tYXgoZVswXS5wYWdlWCxlWzFdLnBhZ2VYKSxvPU1hdGgubWF4KGVbMF0ucGFnZVksZVsxXS5wYWdlWSk7cmV0dXJue3g6bix5OnIsbGVmdDpuLHRvcDpyLHJpZ2h0OmksYm90dG9tOm8sd2lkdGg6aS1uLGhlaWdodDpvLXJ9fWZ1bmN0aW9uIHB0KHQsZSl7dmFyIG49ZStcIlhcIixyPWUrXCJZXCIsaT1jdCh0KSxvPWlbMF1bbl0taVsxXVtuXSxhPWlbMF1bcl0taVsxXVtyXTtyZXR1cm4gUShvLGEpfWZ1bmN0aW9uIGZ0KHQsZSl7dmFyIG49ZStcIlhcIixyPWUrXCJZXCIsaT1jdCh0KSxvPWlbMV1bbl0taVswXVtuXSxhPWlbMV1bcl0taVswXVtyXTtyZXR1cm4gMTgwKk1hdGguYXRhbjIoYSxvKS9NYXRoLlBJfWZ1bmN0aW9uIGR0KHQpe3JldHVybiB3LnN0cmluZyh0LnBvaW50ZXJUeXBlKT90LnBvaW50ZXJUeXBlOncubnVtYmVyKHQucG9pbnRlclR5cGUpP1t2b2lkIDAsdm9pZCAwLFwidG91Y2hcIixcInBlblwiLFwibW91c2VcIl1bdC5wb2ludGVyVHlwZV06L3RvdWNoLy50ZXN0KHQudHlwZXx8XCJcIil8fHQgaW5zdGFuY2VvZiBrLlRvdWNoP1widG91Y2hcIjpcIm1vdXNlXCJ9ZnVuY3Rpb24gaHQodCl7dmFyIGU9dy5mdW5jKHQuY29tcG9zZWRQYXRoKT90LmNvbXBvc2VkUGF0aCgpOnQucGF0aDtyZXR1cm5bWChlP2VbMF06dC50YXJnZXQpLFgodC5jdXJyZW50VGFyZ2V0KV19dmFyIHZ0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXtyKHRoaXMsdCksdGhpcy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ9ITEsdGhpcy5wcm9wYWdhdGlvblN0b3BwZWQ9ITEsdGhpcy5faW50ZXJhY3Rpb249ZX1yZXR1cm4gbyh0LFt7a2V5OlwicHJldmVudERlZmF1bHRcIix2YWx1ZTpmdW5jdGlvbigpe319LHtrZXk6XCJzdG9wUHJvcGFnYXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucHJvcGFnYXRpb25TdG9wcGVkPSEwfX0se2tleTpcInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ9dGhpcy5wcm9wYWdhdGlvblN0b3BwZWQ9ITB9fV0pLHR9KCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHZ0LnByb3RvdHlwZSxcImludGVyYWN0aW9uXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pbnRlcmFjdGlvbi5fcHJveHl9LHNldDpmdW5jdGlvbigpe319KTt2YXIgZ3Q9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTt0LnB1c2gocil9cmV0dXJuIHR9LG10PWZ1bmN0aW9uKHQpe3JldHVybiBndChbXSx0KX0seXQ9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKylpZihlKHRbbl0sbix0KSlyZXR1cm4gbjtyZXR1cm4tMX0sYnQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdFt5dCh0LGUpXX0seHQ9ZnVuY3Rpb24odCl7cyhuLHQpO3ZhciBlPXAobik7ZnVuY3Rpb24gbih0LGksbyl7dmFyIGE7cih0aGlzLG4pLChhPWUuY2FsbCh0aGlzLGkuX2ludGVyYWN0aW9uKSkuZHJvcHpvbmU9dm9pZCAwLGEuZHJhZ0V2ZW50PXZvaWQgMCxhLnJlbGF0ZWRUYXJnZXQ9dm9pZCAwLGEuZHJhZ2dhYmxlPXZvaWQgMCxhLnByb3BhZ2F0aW9uU3RvcHBlZD0hMSxhLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZD0hMTt2YXIgcz1cImRyYWdsZWF2ZVwiPT09bz90LnByZXY6dC5jdXIsYz1zLmVsZW1lbnQsbD1zLmRyb3B6b25lO3JldHVybiBhLnR5cGU9byxhLnRhcmdldD1jLGEuY3VycmVudFRhcmdldD1jLGEuZHJvcHpvbmU9bCxhLmRyYWdFdmVudD1pLGEucmVsYXRlZFRhcmdldD1pLnRhcmdldCxhLmRyYWdnYWJsZT1pLmludGVyYWN0YWJsZSxhLnRpbWVTdGFtcD1pLnRpbWVTdGFtcCxhfXJldHVybiBvKG4sW3trZXk6XCJyZWplY3RcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT10aGlzLl9pbnRlcmFjdGlvbi5kcm9wU3RhdGU7aWYoXCJkcm9wYWN0aXZhdGVcIj09PXRoaXMudHlwZXx8dGhpcy5kcm9wem9uZSYmZS5jdXIuZHJvcHpvbmU9PT10aGlzLmRyb3B6b25lJiZlLmN1ci5lbGVtZW50PT09dGhpcy50YXJnZXQpaWYoZS5wcmV2LmRyb3B6b25lPXRoaXMuZHJvcHpvbmUsZS5wcmV2LmVsZW1lbnQ9dGhpcy50YXJnZXQsZS5yZWplY3RlZD0hMCxlLmV2ZW50cy5lbnRlcj1udWxsLHRoaXMuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksXCJkcm9wYWN0aXZhdGVcIj09PXRoaXMudHlwZSl7dmFyIHI9ZS5hY3RpdmVEcm9wcyxpPXl0KHIsKGZ1bmN0aW9uKGUpe3ZhciBuPWUuZHJvcHpvbmUscj1lLmVsZW1lbnQ7cmV0dXJuIG49PT10LmRyb3B6b25lJiZyPT09dC50YXJnZXR9KSk7ZS5hY3RpdmVEcm9wcy5zcGxpY2UoaSwxKTt2YXIgbz1uZXcgbihlLHRoaXMuZHJhZ0V2ZW50LFwiZHJvcGRlYWN0aXZhdGVcIik7by5kcm9wem9uZT10aGlzLmRyb3B6b25lLG8udGFyZ2V0PXRoaXMudGFyZ2V0LHRoaXMuZHJvcHpvbmUuZmlyZShvKX1lbHNlIHRoaXMuZHJvcHpvbmUuZmlyZShuZXcgbihlLHRoaXMuZHJhZ0V2ZW50LFwiZHJhZ2xlYXZlXCIpKX19LHtrZXk6XCJwcmV2ZW50RGVmYXVsdFwiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcInN0b3BQcm9wYWdhdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5wcm9wYWdhdGlvblN0b3BwZWQ9ITB9fSx7a2V5Olwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZD10aGlzLnByb3BhZ2F0aW9uU3RvcHBlZD0hMH19XSksbn0odnQpO2Z1bmN0aW9uIHd0KHQsZSl7Zm9yKHZhciBuPTAscj10LnNsaWNlKCk7bjxyLmxlbmd0aDtuKyspe3ZhciBpPXJbbl0sbz1pLmRyb3B6b25lLGE9aS5lbGVtZW50O2UuZHJvcHpvbmU9byxlLnRhcmdldD1hLG8uZmlyZShlKSxlLnByb3BhZ2F0aW9uU3RvcHBlZD1lLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZD0hMX19ZnVuY3Rpb24gRXQodCxlKXtmb3IodmFyIG49ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49W10scj0wLGk9dC5pbnRlcmFjdGFibGVzLmxpc3Q7cjxpLmxlbmd0aDtyKyspe3ZhciBvPWlbcl07aWYoby5vcHRpb25zLmRyb3AuZW5hYmxlZCl7dmFyIGE9by5vcHRpb25zLmRyb3AuYWNjZXB0O2lmKCEody5lbGVtZW50KGEpJiZhIT09ZXx8dy5zdHJpbmcoYSkmJiFSKGUsYSl8fHcuZnVuYyhhKSYmIWEoe2Ryb3B6b25lOm8sZHJhZ2dhYmxlRWxlbWVudDplfSkpKWZvcih2YXIgcz0wLGM9by5nZXRBbGxFbGVtZW50cygpO3M8Yy5sZW5ndGg7cysrKXt2YXIgbD1jW3NdO2whPT1lJiZuLnB1c2goe2Ryb3B6b25lOm8sZWxlbWVudDpsLHJlY3Q6by5nZXRSZWN0KGwpfSl9fX1yZXR1cm4gbn0odCxlKSxyPTA7cjxuLmxlbmd0aDtyKyspe3ZhciBpPW5bcl07aS5yZWN0PWkuZHJvcHpvbmUuZ2V0UmVjdChpLmVsZW1lbnQpfXJldHVybiBufWZ1bmN0aW9uIFR0KHQsZSxuKXtmb3IodmFyIHI9dC5kcm9wU3RhdGUsaT10LmludGVyYWN0YWJsZSxvPXQuZWxlbWVudCxhPVtdLHM9MCxjPXIuYWN0aXZlRHJvcHM7czxjLmxlbmd0aDtzKyspe3ZhciBsPWNbc10sdT1sLmRyb3B6b25lLHA9bC5lbGVtZW50LGY9bC5yZWN0LGQ9dS5kcm9wQ2hlY2soZSxuLGksbyxwLGYpO2EucHVzaChkP3A6bnVsbCl9dmFyIGg9ZnVuY3Rpb24odCl7Zm9yKHZhciBlLG4scixpPVtdLG89MDtvPHQubGVuZ3RoO28rKyl7dmFyIGE9dFtvXSxzPXRbZV07aWYoYSYmbyE9PWUpaWYocyl7dmFyIGM9QyhhKSxsPUMocyk7aWYoYyE9PWEub3duZXJEb2N1bWVudClpZihsIT09YS5vd25lckRvY3VtZW50KWlmKGMhPT1sKXtpPWkubGVuZ3RoP2k6aihzKTt2YXIgdT12b2lkIDA7aWYocyBpbnN0YW5jZW9mIGsuSFRNTEVsZW1lbnQmJmEgaW5zdGFuY2VvZiBrLlNWR0VsZW1lbnQmJiEoYSBpbnN0YW5jZW9mIGsuU1ZHU1ZHRWxlbWVudCkpe2lmKGE9PT1sKWNvbnRpbnVlO3U9YS5vd25lclNWR0VsZW1lbnR9ZWxzZSB1PWE7Zm9yKHZhciBwPWoodSxzLm93bmVyRG9jdW1lbnQpLGY9MDtwW2ZdJiZwW2ZdPT09aVtmXTspZisrO3ZhciBkPVtwW2YtMV0scFtmXSxpW2ZdXTtpZihkWzBdKWZvcih2YXIgaD1kWzBdLmxhc3RDaGlsZDtoOyl7aWYoaD09PWRbMV0pe2U9byxpPXA7YnJlYWt9aWYoaD09PWRbMl0pYnJlYWs7aD1oLnByZXZpb3VzU2libGluZ319ZWxzZSByPXMsdm9pZCAwLHZvaWQgMCwocGFyc2VJbnQoeShuPWEpLmdldENvbXB1dGVkU3R5bGUobikuekluZGV4LDEwKXx8MCk+PShwYXJzZUludCh5KHIpLmdldENvbXB1dGVkU3R5bGUocikuekluZGV4LDEwKXx8MCkmJihlPW8pO2Vsc2UgZT1vfWVsc2UgZT1vfXJldHVybiBlfShhKTtyZXR1cm4gci5hY3RpdmVEcm9wc1toXXx8bnVsbH1mdW5jdGlvbiBTdCh0LGUsbil7dmFyIHI9dC5kcm9wU3RhdGUsaT17ZW50ZXI6bnVsbCxsZWF2ZTpudWxsLGFjdGl2YXRlOm51bGwsZGVhY3RpdmF0ZTpudWxsLG1vdmU6bnVsbCxkcm9wOm51bGx9O3JldHVyblwiZHJhZ3N0YXJ0XCI9PT1uLnR5cGUmJihpLmFjdGl2YXRlPW5ldyB4dChyLG4sXCJkcm9wYWN0aXZhdGVcIiksaS5hY3RpdmF0ZS50YXJnZXQ9bnVsbCxpLmFjdGl2YXRlLmRyb3B6b25lPW51bGwpLFwiZHJhZ2VuZFwiPT09bi50eXBlJiYoaS5kZWFjdGl2YXRlPW5ldyB4dChyLG4sXCJkcm9wZGVhY3RpdmF0ZVwiKSxpLmRlYWN0aXZhdGUudGFyZ2V0PW51bGwsaS5kZWFjdGl2YXRlLmRyb3B6b25lPW51bGwpLHIucmVqZWN0ZWR8fChyLmN1ci5lbGVtZW50IT09ci5wcmV2LmVsZW1lbnQmJihyLnByZXYuZHJvcHpvbmUmJihpLmxlYXZlPW5ldyB4dChyLG4sXCJkcmFnbGVhdmVcIiksbi5kcmFnTGVhdmU9aS5sZWF2ZS50YXJnZXQ9ci5wcmV2LmVsZW1lbnQsbi5wcmV2RHJvcHpvbmU9aS5sZWF2ZS5kcm9wem9uZT1yLnByZXYuZHJvcHpvbmUpLHIuY3VyLmRyb3B6b25lJiYoaS5lbnRlcj1uZXcgeHQocixuLFwiZHJhZ2VudGVyXCIpLG4uZHJhZ0VudGVyPXIuY3VyLmVsZW1lbnQsbi5kcm9wem9uZT1yLmN1ci5kcm9wem9uZSkpLFwiZHJhZ2VuZFwiPT09bi50eXBlJiZyLmN1ci5kcm9wem9uZSYmKGkuZHJvcD1uZXcgeHQocixuLFwiZHJvcFwiKSxuLmRyb3B6b25lPXIuY3VyLmRyb3B6b25lLG4ucmVsYXRlZFRhcmdldD1yLmN1ci5lbGVtZW50KSxcImRyYWdtb3ZlXCI9PT1uLnR5cGUmJnIuY3VyLmRyb3B6b25lJiYoaS5tb3ZlPW5ldyB4dChyLG4sXCJkcm9wbW92ZVwiKSxuLmRyb3B6b25lPXIuY3VyLmRyb3B6b25lKSksaX1mdW5jdGlvbiBfdCh0LGUpe3ZhciBuPXQuZHJvcFN0YXRlLHI9bi5hY3RpdmVEcm9wcyxpPW4uY3VyLG89bi5wcmV2O2UubGVhdmUmJm8uZHJvcHpvbmUuZmlyZShlLmxlYXZlKSxlLmVudGVyJiZpLmRyb3B6b25lLmZpcmUoZS5lbnRlciksZS5tb3ZlJiZpLmRyb3B6b25lLmZpcmUoZS5tb3ZlKSxlLmRyb3AmJmkuZHJvcHpvbmUuZmlyZShlLmRyb3ApLGUuZGVhY3RpdmF0ZSYmd3QocixlLmRlYWN0aXZhdGUpLG4ucHJldi5kcm9wem9uZT1pLmRyb3B6b25lLG4ucHJldi5lbGVtZW50PWkuZWxlbWVudH1mdW5jdGlvbiBQdCh0LGUpe3ZhciBuPXQuaW50ZXJhY3Rpb24scj10LmlFdmVudCxpPXQuZXZlbnQ7aWYoXCJkcmFnbW92ZVwiPT09ci50eXBlfHxcImRyYWdlbmRcIj09PXIudHlwZSl7dmFyIG89bi5kcm9wU3RhdGU7ZS5keW5hbWljRHJvcCYmKG8uYWN0aXZlRHJvcHM9RXQoZSxuLmVsZW1lbnQpKTt2YXIgYT1yLHM9VHQobixhLGkpO28ucmVqZWN0ZWQ9by5yZWplY3RlZCYmISFzJiZzLmRyb3B6b25lPT09by5jdXIuZHJvcHpvbmUmJnMuZWxlbWVudD09PW8uY3VyLmVsZW1lbnQsby5jdXIuZHJvcHpvbmU9cyYmcy5kcm9wem9uZSxvLmN1ci5lbGVtZW50PXMmJnMuZWxlbWVudCxvLmV2ZW50cz1TdChuLDAsYSl9fXZhciBPdD17aWQ6XCJhY3Rpb25zL2Ryb3BcIixpbnN0YWxsOmZ1bmN0aW9uKHQpe3ZhciBlPXQuYWN0aW9ucyxuPXQuaW50ZXJhY3RTdGF0aWMscj10LkludGVyYWN0YWJsZSxpPXQuZGVmYXVsdHM7dC51c2VQbHVnaW4oXyksci5wcm90b3R5cGUuZHJvcHpvbmU9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7aWYody5vYmplY3QoZSkpe2lmKHQub3B0aW9ucy5kcm9wLmVuYWJsZWQ9ITEhPT1lLmVuYWJsZWQsZS5saXN0ZW5lcnMpe3ZhciBuPSQoZS5saXN0ZW5lcnMpLHI9T2JqZWN0LmtleXMobikucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0Wy9eKGVudGVyfGxlYXZlKS8udGVzdChlKT9cImRyYWdcIi5jb25jYXQoZSk6L14oYWN0aXZhdGV8ZGVhY3RpdmF0ZXxtb3ZlKS8udGVzdChlKT9cImRyb3BcIi5jb25jYXQoZSk6ZV09bltlXSx0fSkse30pLGk9dC5vcHRpb25zLmRyb3AubGlzdGVuZXJzO2kmJnQub2ZmKGkpLHQub24ociksdC5vcHRpb25zLmRyb3AubGlzdGVuZXJzPXJ9cmV0dXJuIHcuZnVuYyhlLm9uZHJvcCkmJnQub24oXCJkcm9wXCIsZS5vbmRyb3ApLHcuZnVuYyhlLm9uZHJvcGFjdGl2YXRlKSYmdC5vbihcImRyb3BhY3RpdmF0ZVwiLGUub25kcm9wYWN0aXZhdGUpLHcuZnVuYyhlLm9uZHJvcGRlYWN0aXZhdGUpJiZ0Lm9uKFwiZHJvcGRlYWN0aXZhdGVcIixlLm9uZHJvcGRlYWN0aXZhdGUpLHcuZnVuYyhlLm9uZHJhZ2VudGVyKSYmdC5vbihcImRyYWdlbnRlclwiLGUub25kcmFnZW50ZXIpLHcuZnVuYyhlLm9uZHJhZ2xlYXZlKSYmdC5vbihcImRyYWdsZWF2ZVwiLGUub25kcmFnbGVhdmUpLHcuZnVuYyhlLm9uZHJvcG1vdmUpJiZ0Lm9uKFwiZHJvcG1vdmVcIixlLm9uZHJvcG1vdmUpLC9eKHBvaW50ZXJ8Y2VudGVyKSQvLnRlc3QoZS5vdmVybGFwKT90Lm9wdGlvbnMuZHJvcC5vdmVybGFwPWUub3ZlcmxhcDp3Lm51bWJlcihlLm92ZXJsYXApJiYodC5vcHRpb25zLmRyb3Aub3ZlcmxhcD1NYXRoLm1heChNYXRoLm1pbigxLGUub3ZlcmxhcCksMCkpLFwiYWNjZXB0XCJpbiBlJiYodC5vcHRpb25zLmRyb3AuYWNjZXB0PWUuYWNjZXB0KSxcImNoZWNrZXJcImluIGUmJih0Lm9wdGlvbnMuZHJvcC5jaGVja2VyPWUuY2hlY2tlciksdH1pZih3LmJvb2woZSkpcmV0dXJuIHQub3B0aW9ucy5kcm9wLmVuYWJsZWQ9ZSx0O3JldHVybiB0Lm9wdGlvbnMuZHJvcH0odGhpcyx0KX0sci5wcm90b3R5cGUuZHJvcENoZWNrPWZ1bmN0aW9uKHQsZSxuLHIsaSxvKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4scixpLG8sYSl7dmFyIHM9ITE7aWYoIShhPWF8fHQuZ2V0UmVjdChvKSkpcmV0dXJuISF0Lm9wdGlvbnMuZHJvcC5jaGVja2VyJiZ0Lm9wdGlvbnMuZHJvcC5jaGVja2VyKGUsbixzLHQsbyxyLGkpO3ZhciBjPXQub3B0aW9ucy5kcm9wLm92ZXJsYXA7aWYoXCJwb2ludGVyXCI9PT1jKXt2YXIgbD1LKHIsaSxcImRyYWdcIiksdT1vdChlKTt1LngrPWwueCx1LnkrPWwueTt2YXIgcD11Lng+YS5sZWZ0JiZ1Lng8YS5yaWdodCxmPXUueT5hLnRvcCYmdS55PGEuYm90dG9tO3M9cCYmZn12YXIgZD1yLmdldFJlY3QoaSk7aWYoZCYmXCJjZW50ZXJcIj09PWMpe3ZhciBoPWQubGVmdCtkLndpZHRoLzIsdj1kLnRvcCtkLmhlaWdodC8yO3M9aD49YS5sZWZ0JiZoPD1hLnJpZ2h0JiZ2Pj1hLnRvcCYmdjw9YS5ib3R0b219aWYoZCYmdy5udW1iZXIoYykpe3M9TWF0aC5tYXgoMCxNYXRoLm1pbihhLnJpZ2h0LGQucmlnaHQpLU1hdGgubWF4KGEubGVmdCxkLmxlZnQpKSpNYXRoLm1heCgwLE1hdGgubWluKGEuYm90dG9tLGQuYm90dG9tKS1NYXRoLm1heChhLnRvcCxkLnRvcCkpLyhkLndpZHRoKmQuaGVpZ2h0KT49Y310Lm9wdGlvbnMuZHJvcC5jaGVja2VyJiYocz10Lm9wdGlvbnMuZHJvcC5jaGVja2VyKGUsbixzLHQsbyxyLGkpKTtyZXR1cm4gc30odGhpcyx0LGUsbixyLGksbyl9LG4uZHluYW1pY0Ryb3A9ZnVuY3Rpb24oZSl7cmV0dXJuIHcuYm9vbChlKT8odC5keW5hbWljRHJvcD1lLG4pOnQuZHluYW1pY0Ryb3B9LFYoZS5waGFzZWxlc3NUeXBlcyx7ZHJhZ2VudGVyOiEwLGRyYWdsZWF2ZTohMCxkcm9wYWN0aXZhdGU6ITAsZHJvcGRlYWN0aXZhdGU6ITAsZHJvcG1vdmU6ITAsZHJvcDohMH0pLGUubWV0aG9kRGljdC5kcm9wPVwiZHJvcHpvbmVcIix0LmR5bmFtaWNEcm9wPSExLGkuYWN0aW9ucy5kcm9wPU90LmRlZmF1bHRzfSxsaXN0ZW5lcnM6e1wiaW50ZXJhY3Rpb25zOmJlZm9yZS1hY3Rpb24tc3RhcnRcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uO1wiZHJhZ1wiPT09ZS5wcmVwYXJlZC5uYW1lJiYoZS5kcm9wU3RhdGU9e2N1cjp7ZHJvcHpvbmU6bnVsbCxlbGVtZW50Om51bGx9LHByZXY6e2Ryb3B6b25lOm51bGwsZWxlbWVudDpudWxsfSxyZWplY3RlZDpudWxsLGV2ZW50czpudWxsLGFjdGl2ZURyb3BzOltdfSl9LFwiaW50ZXJhY3Rpb25zOmFmdGVyLWFjdGlvbi1zdGFydFwiOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5pbnRlcmFjdGlvbixyPSh0LmV2ZW50LHQuaUV2ZW50KTtpZihcImRyYWdcIj09PW4ucHJlcGFyZWQubmFtZSl7dmFyIGk9bi5kcm9wU3RhdGU7aS5hY3RpdmVEcm9wcz1bXSxpLmV2ZW50cz17fSxpLmFjdGl2ZURyb3BzPUV0KGUsbi5lbGVtZW50KSxpLmV2ZW50cz1TdChuLDAsciksaS5ldmVudHMuYWN0aXZhdGUmJih3dChpLmFjdGl2ZURyb3BzLGkuZXZlbnRzLmFjdGl2YXRlKSxlLmZpcmUoXCJhY3Rpb25zL2Ryb3A6c3RhcnRcIix7aW50ZXJhY3Rpb246bixkcmFnRXZlbnQ6cn0pKX19LFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1tb3ZlXCI6UHQsXCJpbnRlcmFjdGlvbnM6YWZ0ZXItYWN0aW9uLW1vdmVcIjpmdW5jdGlvbih0LGUpe3ZhciBuPXQuaW50ZXJhY3Rpb24scj10LmlFdmVudDtpZihcImRyYWdcIj09PW4ucHJlcGFyZWQubmFtZSl7dmFyIGk9bi5kcm9wU3RhdGU7X3QobixpLmV2ZW50cyksZS5maXJlKFwiYWN0aW9ucy9kcm9wOm1vdmVcIix7aW50ZXJhY3Rpb246bixkcmFnRXZlbnQ6cn0pLGkuZXZlbnRzPXt9fX0sXCJpbnRlcmFjdGlvbnM6YWN0aW9uLWVuZFwiOmZ1bmN0aW9uKHQsZSl7aWYoXCJkcmFnXCI9PT10LmludGVyYWN0aW9uLnByZXBhcmVkLm5hbWUpe3ZhciBuPXQuaW50ZXJhY3Rpb24scj10LmlFdmVudDtQdCh0LGUpLF90KG4sbi5kcm9wU3RhdGUuZXZlbnRzKSxlLmZpcmUoXCJhY3Rpb25zL2Ryb3A6ZW5kXCIse2ludGVyYWN0aW9uOm4sZHJhZ0V2ZW50OnJ9KX19LFwiaW50ZXJhY3Rpb25zOnN0b3BcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uO2lmKFwiZHJhZ1wiPT09ZS5wcmVwYXJlZC5uYW1lKXt2YXIgbj1lLmRyb3BTdGF0ZTtuJiYobi5hY3RpdmVEcm9wcz1udWxsLG4uZXZlbnRzPW51bGwsbi5jdXIuZHJvcHpvbmU9bnVsbCxuLmN1ci5lbGVtZW50PW51bGwsbi5wcmV2LmRyb3B6b25lPW51bGwsbi5wcmV2LmVsZW1lbnQ9bnVsbCxuLnJlamVjdGVkPSExKX19fSxnZXRBY3RpdmVEcm9wczpFdCxnZXREcm9wOlR0LGdldERyb3BFdmVudHM6U3QsZmlyZURyb3BFdmVudHM6X3QsZmlsdGVyRXZlbnRUeXBlOmZ1bmN0aW9uKHQpe3JldHVybiAwPT09dC5zZWFyY2goXCJkcmFnXCIpfHwwPT09dC5zZWFyY2goXCJkcm9wXCIpfSxkZWZhdWx0czp7ZW5hYmxlZDohMSxhY2NlcHQ6bnVsbCxvdmVybGFwOlwicG9pbnRlclwifX0sa3Q9T3Q7ZnVuY3Rpb24gRHQodCl7dmFyIGU9dC5pbnRlcmFjdGlvbixuPXQuaUV2ZW50LHI9dC5waGFzZTtpZihcImdlc3R1cmVcIj09PWUucHJlcGFyZWQubmFtZSl7dmFyIGk9ZS5wb2ludGVycy5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnBvaW50ZXJ9KSksbz1cInN0YXJ0XCI9PT1yLGE9XCJlbmRcIj09PXIscz1lLmludGVyYWN0YWJsZS5vcHRpb25zLmRlbHRhU291cmNlO2lmKG4udG91Y2hlcz1baVswXSxpWzFdXSxvKW4uZGlzdGFuY2U9cHQoaSxzKSxuLmJveD11dChpKSxuLnNjYWxlPTEsbi5kcz0wLG4uYW5nbGU9ZnQoaSxzKSxuLmRhPTAsZS5nZXN0dXJlLnN0YXJ0RGlzdGFuY2U9bi5kaXN0YW5jZSxlLmdlc3R1cmUuc3RhcnRBbmdsZT1uLmFuZ2xlO2Vsc2UgaWYoYXx8ZS5wb2ludGVycy5sZW5ndGg8Mil7dmFyIGM9ZS5wcmV2RXZlbnQ7bi5kaXN0YW5jZT1jLmRpc3RhbmNlLG4uYm94PWMuYm94LG4uc2NhbGU9Yy5zY2FsZSxuLmRzPTAsbi5hbmdsZT1jLmFuZ2xlLG4uZGE9MH1lbHNlIG4uZGlzdGFuY2U9cHQoaSxzKSxuLmJveD11dChpKSxuLnNjYWxlPW4uZGlzdGFuY2UvZS5nZXN0dXJlLnN0YXJ0RGlzdGFuY2Usbi5hbmdsZT1mdChpLHMpLG4uZHM9bi5zY2FsZS1lLmdlc3R1cmUuc2NhbGUsbi5kYT1uLmFuZ2xlLWUuZ2VzdHVyZS5hbmdsZTtlLmdlc3R1cmUuZGlzdGFuY2U9bi5kaXN0YW5jZSxlLmdlc3R1cmUuYW5nbGU9bi5hbmdsZSx3Lm51bWJlcihuLnNjYWxlKSYmbi5zY2FsZSE9PTEvMCYmIWlzTmFOKG4uc2NhbGUpJiYoZS5nZXN0dXJlLnNjYWxlPW4uc2NhbGUpfX12YXIgSXQ9e2lkOlwiYWN0aW9ucy9nZXN0dXJlXCIsYmVmb3JlOltcImFjdGlvbnMvZHJhZ1wiLFwiYWN0aW9ucy9yZXNpemVcIl0saW5zdGFsbDpmdW5jdGlvbih0KXt2YXIgZT10LmFjdGlvbnMsbj10LkludGVyYWN0YWJsZSxyPXQuZGVmYXVsdHM7bi5wcm90b3R5cGUuZ2VzdHVyYWJsZT1mdW5jdGlvbih0KXtyZXR1cm4gdy5vYmplY3QodCk/KHRoaXMub3B0aW9ucy5nZXN0dXJlLmVuYWJsZWQ9ITEhPT10LmVuYWJsZWQsdGhpcy5zZXRQZXJBY3Rpb24oXCJnZXN0dXJlXCIsdCksdGhpcy5zZXRPbkV2ZW50cyhcImdlc3R1cmVcIix0KSx0aGlzKTp3LmJvb2wodCk/KHRoaXMub3B0aW9ucy5nZXN0dXJlLmVuYWJsZWQ9dCx0aGlzKTp0aGlzLm9wdGlvbnMuZ2VzdHVyZX0sZS5tYXAuZ2VzdHVyZT1JdCxlLm1ldGhvZERpY3QuZ2VzdHVyZT1cImdlc3R1cmFibGVcIixyLmFjdGlvbnMuZ2VzdHVyZT1JdC5kZWZhdWx0c30sbGlzdGVuZXJzOntcImludGVyYWN0aW9uczphY3Rpb24tc3RhcnRcIjpEdCxcImludGVyYWN0aW9uczphY3Rpb24tbW92ZVwiOkR0LFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1lbmRcIjpEdCxcImludGVyYWN0aW9uczpuZXdcIjpmdW5jdGlvbih0KXt0LmludGVyYWN0aW9uLmdlc3R1cmU9e2FuZ2xlOjAsZGlzdGFuY2U6MCxzY2FsZToxLHN0YXJ0QW5nbGU6MCxzdGFydERpc3RhbmNlOjB9fSxcImF1dG8tc3RhcnQ6Y2hlY2tcIjpmdW5jdGlvbih0KXtpZighKHQuaW50ZXJhY3Rpb24ucG9pbnRlcnMubGVuZ3RoPDIpKXt2YXIgZT10LmludGVyYWN0YWJsZS5vcHRpb25zLmdlc3R1cmU7aWYoZSYmZS5lbmFibGVkKXJldHVybiB0LmFjdGlvbj17bmFtZTpcImdlc3R1cmVcIn0sITF9fX0sZGVmYXVsdHM6e30sZ2V0Q3Vyc29yOmZ1bmN0aW9uKCl7cmV0dXJuXCJcIn0sZmlsdGVyRXZlbnRUeXBlOmZ1bmN0aW9uKHQpe3JldHVybiAwPT09dC5zZWFyY2goXCJnZXN0dXJlXCIpfX0sTXQ9SXQ7ZnVuY3Rpb24genQodCxlLG4scixpLG8sYSl7aWYoIWUpcmV0dXJuITE7aWYoITA9PT1lKXt2YXIgcz13Lm51bWJlcihvLndpZHRoKT9vLndpZHRoOm8ucmlnaHQtby5sZWZ0LGM9dy5udW1iZXIoby5oZWlnaHQpP28uaGVpZ2h0Om8uYm90dG9tLW8udG9wO2lmKGE9TWF0aC5taW4oYSxNYXRoLmFicygoXCJsZWZ0XCI9PT10fHxcInJpZ2h0XCI9PT10P3M6YykvMikpLHM8MCYmKFwibGVmdFwiPT09dD90PVwicmlnaHRcIjpcInJpZ2h0XCI9PT10JiYodD1cImxlZnRcIikpLGM8MCYmKFwidG9wXCI9PT10P3Q9XCJib3R0b21cIjpcImJvdHRvbVwiPT09dCYmKHQ9XCJ0b3BcIikpLFwibGVmdFwiPT09dCl7dmFyIGw9cz49MD9vLmxlZnQ6by5yaWdodDtyZXR1cm4gbi54PGwrYX1pZihcInRvcFwiPT09dCl7dmFyIHU9Yz49MD9vLnRvcDpvLmJvdHRvbTtyZXR1cm4gbi55PHUrYX1pZihcInJpZ2h0XCI9PT10KXJldHVybiBuLng+KHM+PTA/by5yaWdodDpvLmxlZnQpLWE7aWYoXCJib3R0b21cIj09PXQpcmV0dXJuIG4ueT4oYz49MD9vLmJvdHRvbTpvLnRvcCktYX1yZXR1cm4hIXcuZWxlbWVudChyKSYmKHcuZWxlbWVudChlKT9lPT09cjpGKHIsZSxpKSl9ZnVuY3Rpb24gQXQodCl7dmFyIGU9dC5pRXZlbnQsbj10LmludGVyYWN0aW9uO2lmKFwicmVzaXplXCI9PT1uLnByZXBhcmVkLm5hbWUmJm4ucmVzaXplQXhlcyl7dmFyIHI9ZTtuLmludGVyYWN0YWJsZS5vcHRpb25zLnJlc2l6ZS5zcXVhcmU/KFwieVwiPT09bi5yZXNpemVBeGVzP3IuZGVsdGEueD1yLmRlbHRhLnk6ci5kZWx0YS55PXIuZGVsdGEueCxyLmF4ZXM9XCJ4eVwiKTooci5heGVzPW4ucmVzaXplQXhlcyxcInhcIj09PW4ucmVzaXplQXhlcz9yLmRlbHRhLnk9MDpcInlcIj09PW4ucmVzaXplQXhlcyYmKHIuZGVsdGEueD0wKSl9fXZhciBSdCxDdCxqdD17aWQ6XCJhY3Rpb25zL3Jlc2l6ZVwiLGJlZm9yZTpbXCJhY3Rpb25zL2RyYWdcIl0saW5zdGFsbDpmdW5jdGlvbih0KXt2YXIgZT10LmFjdGlvbnMsbj10LmJyb3dzZXIscj10LkludGVyYWN0YWJsZSxpPXQuZGVmYXVsdHM7anQuY3Vyc29ycz1mdW5jdGlvbih0KXtyZXR1cm4gdC5pc0llOT97eDpcImUtcmVzaXplXCIseTpcInMtcmVzaXplXCIseHk6XCJzZS1yZXNpemVcIix0b3A6XCJuLXJlc2l6ZVwiLGxlZnQ6XCJ3LXJlc2l6ZVwiLGJvdHRvbTpcInMtcmVzaXplXCIscmlnaHQ6XCJlLXJlc2l6ZVwiLHRvcGxlZnQ6XCJzZS1yZXNpemVcIixib3R0b21yaWdodDpcInNlLXJlc2l6ZVwiLHRvcHJpZ2h0OlwibmUtcmVzaXplXCIsYm90dG9tbGVmdDpcIm5lLXJlc2l6ZVwifTp7eDpcImV3LXJlc2l6ZVwiLHk6XCJucy1yZXNpemVcIix4eTpcIm53c2UtcmVzaXplXCIsdG9wOlwibnMtcmVzaXplXCIsbGVmdDpcImV3LXJlc2l6ZVwiLGJvdHRvbTpcIm5zLXJlc2l6ZVwiLHJpZ2h0OlwiZXctcmVzaXplXCIsdG9wbGVmdDpcIm53c2UtcmVzaXplXCIsYm90dG9tcmlnaHQ6XCJud3NlLXJlc2l6ZVwiLHRvcHJpZ2h0OlwibmVzdy1yZXNpemVcIixib3R0b21sZWZ0OlwibmVzdy1yZXNpemVcIn19KG4pLGp0LmRlZmF1bHRNYXJnaW49bi5zdXBwb3J0c1RvdWNofHxuLnN1cHBvcnRzUG9pbnRlckV2ZW50PzIwOjEwLHIucHJvdG90eXBlLnJlc2l6YWJsZT1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe2lmKHcub2JqZWN0KGUpKXJldHVybiB0Lm9wdGlvbnMucmVzaXplLmVuYWJsZWQ9ITEhPT1lLmVuYWJsZWQsdC5zZXRQZXJBY3Rpb24oXCJyZXNpemVcIixlKSx0LnNldE9uRXZlbnRzKFwicmVzaXplXCIsZSksdy5zdHJpbmcoZS5heGlzKSYmL154JHxeeSR8Xnh5JC8udGVzdChlLmF4aXMpP3Qub3B0aW9ucy5yZXNpemUuYXhpcz1lLmF4aXM6bnVsbD09PWUuYXhpcyYmKHQub3B0aW9ucy5yZXNpemUuYXhpcz1uLmRlZmF1bHRzLmFjdGlvbnMucmVzaXplLmF4aXMpLHcuYm9vbChlLnByZXNlcnZlQXNwZWN0UmF0aW8pP3Qub3B0aW9ucy5yZXNpemUucHJlc2VydmVBc3BlY3RSYXRpbz1lLnByZXNlcnZlQXNwZWN0UmF0aW86dy5ib29sKGUuc3F1YXJlKSYmKHQub3B0aW9ucy5yZXNpemUuc3F1YXJlPWUuc3F1YXJlKSx0O2lmKHcuYm9vbChlKSlyZXR1cm4gdC5vcHRpb25zLnJlc2l6ZS5lbmFibGVkPWUsdDtyZXR1cm4gdC5vcHRpb25zLnJlc2l6ZX0odGhpcyxlLHQpfSxlLm1hcC5yZXNpemU9anQsZS5tZXRob2REaWN0LnJlc2l6ZT1cInJlc2l6YWJsZVwiLGkuYWN0aW9ucy5yZXNpemU9anQuZGVmYXVsdHN9LGxpc3RlbmVyczp7XCJpbnRlcmFjdGlvbnM6bmV3XCI6ZnVuY3Rpb24odCl7dC5pbnRlcmFjdGlvbi5yZXNpemVBeGVzPVwieHlcIn0sXCJpbnRlcmFjdGlvbnM6YWN0aW9uLXN0YXJ0XCI6ZnVuY3Rpb24odCl7IWZ1bmN0aW9uKHQpe3ZhciBlPXQuaUV2ZW50LG49dC5pbnRlcmFjdGlvbjtpZihcInJlc2l6ZVwiPT09bi5wcmVwYXJlZC5uYW1lJiZuLnByZXBhcmVkLmVkZ2VzKXt2YXIgcj1lLGk9bi5yZWN0O24uX3JlY3RzPXtzdGFydDpWKHt9LGkpLGNvcnJlY3RlZDpWKHt9LGkpLHByZXZpb3VzOlYoe30saSksZGVsdGE6e2xlZnQ6MCxyaWdodDowLHdpZHRoOjAsdG9wOjAsYm90dG9tOjAsaGVpZ2h0OjB9fSxyLmVkZ2VzPW4ucHJlcGFyZWQuZWRnZXMsci5yZWN0PW4uX3JlY3RzLmNvcnJlY3RlZCxyLmRlbHRhUmVjdD1uLl9yZWN0cy5kZWx0YX19KHQpLEF0KHQpfSxcImludGVyYWN0aW9uczphY3Rpb24tbW92ZVwiOmZ1bmN0aW9uKHQpeyFmdW5jdGlvbih0KXt2YXIgZT10LmlFdmVudCxuPXQuaW50ZXJhY3Rpb247aWYoXCJyZXNpemVcIj09PW4ucHJlcGFyZWQubmFtZSYmbi5wcmVwYXJlZC5lZGdlcyl7dmFyIHI9ZSxpPW4uaW50ZXJhY3RhYmxlLm9wdGlvbnMucmVzaXplLmludmVydCxvPVwicmVwb3NpdGlvblwiPT09aXx8XCJuZWdhdGVcIj09PWksYT1uLnJlY3Qscz1uLl9yZWN0cyxjPXMuc3RhcnQsbD1zLmNvcnJlY3RlZCx1PXMuZGVsdGEscD1zLnByZXZpb3VzO2lmKFYocCxsKSxvKXtpZihWKGwsYSksXCJyZXBvc2l0aW9uXCI9PT1pKXtpZihsLnRvcD5sLmJvdHRvbSl7dmFyIGY9bC50b3A7bC50b3A9bC5ib3R0b20sbC5ib3R0b209Zn1pZihsLmxlZnQ+bC5yaWdodCl7dmFyIGQ9bC5sZWZ0O2wubGVmdD1sLnJpZ2h0LGwucmlnaHQ9ZH19fWVsc2UgbC50b3A9TWF0aC5taW4oYS50b3AsYy5ib3R0b20pLGwuYm90dG9tPU1hdGgubWF4KGEuYm90dG9tLGMudG9wKSxsLmxlZnQ9TWF0aC5taW4oYS5sZWZ0LGMucmlnaHQpLGwucmlnaHQ9TWF0aC5tYXgoYS5yaWdodCxjLmxlZnQpO2Zvcih2YXIgaCBpbiBsLndpZHRoPWwucmlnaHQtbC5sZWZ0LGwuaGVpZ2h0PWwuYm90dG9tLWwudG9wLGwpdVtoXT1sW2hdLXBbaF07ci5lZGdlcz1uLnByZXBhcmVkLmVkZ2VzLHIucmVjdD1sLHIuZGVsdGFSZWN0PXV9fSh0KSxBdCh0KX0sXCJpbnRlcmFjdGlvbnM6YWN0aW9uLWVuZFwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaUV2ZW50LG49dC5pbnRlcmFjdGlvbjtpZihcInJlc2l6ZVwiPT09bi5wcmVwYXJlZC5uYW1lJiZuLnByZXBhcmVkLmVkZ2VzKXt2YXIgcj1lO3IuZWRnZXM9bi5wcmVwYXJlZC5lZGdlcyxyLnJlY3Q9bi5fcmVjdHMuY29ycmVjdGVkLHIuZGVsdGFSZWN0PW4uX3JlY3RzLmRlbHRhfX0sXCJhdXRvLXN0YXJ0OmNoZWNrXCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbixuPXQuaW50ZXJhY3RhYmxlLHI9dC5lbGVtZW50LGk9dC5yZWN0LG89dC5idXR0b25zO2lmKGkpe3ZhciBhPVYoe30sZS5jb29yZHMuY3VyLnBhZ2UpLHM9bi5vcHRpb25zLnJlc2l6ZTtpZihzJiZzLmVuYWJsZWQmJighZS5wb2ludGVySXNEb3dufHwhL21vdXNlfHBvaW50ZXIvLnRlc3QoZS5wb2ludGVyVHlwZSl8fDAhPShvJnMubW91c2VCdXR0b25zKSkpe2lmKHcub2JqZWN0KHMuZWRnZXMpKXt2YXIgYz17bGVmdDohMSxyaWdodDohMSx0b3A6ITEsYm90dG9tOiExfTtmb3IodmFyIGwgaW4gYyljW2xdPXp0KGwscy5lZGdlc1tsXSxhLGUuX2xhdGVzdFBvaW50ZXIuZXZlbnRUYXJnZXQscixpLHMubWFyZ2lufHxqdC5kZWZhdWx0TWFyZ2luKTtjLmxlZnQ9Yy5sZWZ0JiYhYy5yaWdodCxjLnRvcD1jLnRvcCYmIWMuYm90dG9tLChjLmxlZnR8fGMucmlnaHR8fGMudG9wfHxjLmJvdHRvbSkmJih0LmFjdGlvbj17bmFtZTpcInJlc2l6ZVwiLGVkZ2VzOmN9KX1lbHNle3ZhciB1PVwieVwiIT09cy5heGlzJiZhLng+aS5yaWdodC1qdC5kZWZhdWx0TWFyZ2luLHA9XCJ4XCIhPT1zLmF4aXMmJmEueT5pLmJvdHRvbS1qdC5kZWZhdWx0TWFyZ2luOyh1fHxwKSYmKHQuYWN0aW9uPXtuYW1lOlwicmVzaXplXCIsYXhlczoodT9cInhcIjpcIlwiKSsocD9cInlcIjpcIlwiKX0pfXJldHVybiF0LmFjdGlvbiYmdm9pZCAwfX19fSxkZWZhdWx0czp7c3F1YXJlOiExLHByZXNlcnZlQXNwZWN0UmF0aW86ITEsYXhpczpcInh5XCIsbWFyZ2luOk5hTixlZGdlczpudWxsLGludmVydDpcIm5vbmVcIn0sY3Vyc29yczpudWxsLGdldEN1cnNvcjpmdW5jdGlvbih0KXt2YXIgZT10LmVkZ2VzLG49dC5heGlzLHI9dC5uYW1lLGk9anQuY3Vyc29ycyxvPW51bGw7aWYobilvPWlbcituXTtlbHNlIGlmKGUpe2Zvcih2YXIgYT1cIlwiLHM9MCxjPVtcInRvcFwiLFwiYm90dG9tXCIsXCJsZWZ0XCIsXCJyaWdodFwiXTtzPGMubGVuZ3RoO3MrKyl7dmFyIGw9Y1tzXTtlW2xdJiYoYSs9bCl9bz1pW2FdfXJldHVybiBvfSxmaWx0ZXJFdmVudFR5cGU6ZnVuY3Rpb24odCl7cmV0dXJuIDA9PT10LnNlYXJjaChcInJlc2l6ZVwiKX0sZGVmYXVsdE1hcmdpbjpudWxsfSxGdD1qdCxYdD17aWQ6XCJhY3Rpb25zXCIsaW5zdGFsbDpmdW5jdGlvbih0KXt0LnVzZVBsdWdpbihNdCksdC51c2VQbHVnaW4oRnQpLHQudXNlUGx1Z2luKF8pLHQudXNlUGx1Z2luKGt0KX19LFl0PTA7dmFyIEx0PXtyZXF1ZXN0OmZ1bmN0aW9uKHQpe3JldHVybiBSdCh0KX0sY2FuY2VsOmZ1bmN0aW9uKHQpe3JldHVybiBDdCh0KX0saW5pdDpmdW5jdGlvbih0KXtpZihSdD10LnJlcXVlc3RBbmltYXRpb25GcmFtZSxDdD10LmNhbmNlbEFuaW1hdGlvbkZyYW1lLCFSdClmb3IodmFyIGU9W1wibXNcIixcIm1velwiLFwid2Via2l0XCIsXCJvXCJdLG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHI9ZVtuXTtSdD10W1wiXCIuY29uY2F0KHIsXCJSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIildLEN0PXRbXCJcIi5jb25jYXQocixcIkNhbmNlbEFuaW1hdGlvbkZyYW1lXCIpXXx8dFtcIlwiLmNvbmNhdChyLFwiQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIpXX1SdD1SdCYmUnQuYmluZCh0KSxDdD1DdCYmQ3QuYmluZCh0KSxSdHx8KFJ0PWZ1bmN0aW9uKGUpe3ZhciBuPURhdGUubm93KCkscj1NYXRoLm1heCgwLDE2LShuLVl0KSksaT10LnNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7ZShuK3IpfSkscik7cmV0dXJuIFl0PW4rcixpfSxDdD1mdW5jdGlvbih0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KHQpfSl9fTt2YXIgcXQ9e2RlZmF1bHRzOntlbmFibGVkOiExLG1hcmdpbjo2MCxjb250YWluZXI6bnVsbCxzcGVlZDozMDB9LG5vdzpEYXRlLm5vdyxpbnRlcmFjdGlvbjpudWxsLGk6MCx4OjAseTowLGlzU2Nyb2xsaW5nOiExLHByZXZUaW1lOjAsbWFyZ2luOjAsc3BlZWQ6MCxzdGFydDpmdW5jdGlvbih0KXtxdC5pc1Njcm9sbGluZz0hMCxMdC5jYW5jZWwocXQuaSksdC5hdXRvU2Nyb2xsPXF0LHF0LmludGVyYWN0aW9uPXQscXQucHJldlRpbWU9cXQubm93KCkscXQuaT1MdC5yZXF1ZXN0KHF0LnNjcm9sbCl9LHN0b3A6ZnVuY3Rpb24oKXtxdC5pc1Njcm9sbGluZz0hMSxxdC5pbnRlcmFjdGlvbiYmKHF0LmludGVyYWN0aW9uLmF1dG9TY3JvbGw9bnVsbCksTHQuY2FuY2VsKHF0LmkpfSxzY3JvbGw6ZnVuY3Rpb24oKXt2YXIgdD1xdC5pbnRlcmFjdGlvbixlPXQuaW50ZXJhY3RhYmxlLG49dC5lbGVtZW50LHI9dC5wcmVwYXJlZC5uYW1lLGk9ZS5vcHRpb25zW3JdLmF1dG9TY3JvbGwsbz1CdChpLmNvbnRhaW5lcixlLG4pLGE9cXQubm93KCkscz0oYS1xdC5wcmV2VGltZSkvMWUzLGM9aS5zcGVlZCpzO2lmKGM+PTEpe3ZhciBsPXt4OnF0LngqYyx5OnF0LnkqY307aWYobC54fHxsLnkpe3ZhciB1PVZ0KG8pO3cud2luZG93KG8pP28uc2Nyb2xsQnkobC54LGwueSk6byYmKG8uc2Nyb2xsTGVmdCs9bC54LG8uc2Nyb2xsVG9wKz1sLnkpO3ZhciBwPVZ0KG8pLGY9e3g6cC54LXUueCx5OnAueS11Lnl9OyhmLnh8fGYueSkmJmUuZmlyZSh7dHlwZTpcImF1dG9zY3JvbGxcIix0YXJnZXQ6bixpbnRlcmFjdGFibGU6ZSxkZWx0YTpmLGludGVyYWN0aW9uOnQsY29udGFpbmVyOm99KX1xdC5wcmV2VGltZT1hfXF0LmlzU2Nyb2xsaW5nJiYoTHQuY2FuY2VsKHF0LmkpLHF0Lmk9THQucmVxdWVzdChxdC5zY3JvbGwpKX0sY2hlY2s6ZnVuY3Rpb24odCxlKXt2YXIgbjtyZXR1cm4gbnVsbD09KG49dC5vcHRpb25zW2VdLmF1dG9TY3JvbGwpP3ZvaWQgMDpuLmVuYWJsZWR9LG9uSW50ZXJhY3Rpb25Nb3ZlOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj10LnBvaW50ZXI7aWYoZS5pbnRlcmFjdGluZygpJiZxdC5jaGVjayhlLmludGVyYWN0YWJsZSxlLnByZXBhcmVkLm5hbWUpKWlmKGUuc2ltdWxhdGlvbilxdC54PXF0Lnk9MDtlbHNle3ZhciByLGksbyxhLHM9ZS5pbnRlcmFjdGFibGUsYz1lLmVsZW1lbnQsbD1lLnByZXBhcmVkLm5hbWUsdT1zLm9wdGlvbnNbbF0uYXV0b1Njcm9sbCxwPUJ0KHUuY29udGFpbmVyLHMsYyk7aWYody53aW5kb3cocCkpYT1uLmNsaWVudFg8cXQubWFyZ2luLHI9bi5jbGllbnRZPHF0Lm1hcmdpbixpPW4uY2xpZW50WD5wLmlubmVyV2lkdGgtcXQubWFyZ2luLG89bi5jbGllbnRZPnAuaW5uZXJIZWlnaHQtcXQubWFyZ2luO2Vsc2V7dmFyIGY9WShwKTthPW4uY2xpZW50WDxmLmxlZnQrcXQubWFyZ2luLHI9bi5jbGllbnRZPGYudG9wK3F0Lm1hcmdpbixpPW4uY2xpZW50WD5mLnJpZ2h0LXF0Lm1hcmdpbixvPW4uY2xpZW50WT5mLmJvdHRvbS1xdC5tYXJnaW59cXQueD1pPzE6YT8tMTowLHF0Lnk9bz8xOnI/LTE6MCxxdC5pc1Njcm9sbGluZ3x8KHF0Lm1hcmdpbj11Lm1hcmdpbixxdC5zcGVlZD11LnNwZWVkLHF0LnN0YXJ0KGUpKX19fTtmdW5jdGlvbiBCdCh0LGUsbil7cmV0dXJuKHcuc3RyaW5nKHQpP1codCxlLG4pOnQpfHx5KG4pfWZ1bmN0aW9uIFZ0KHQpe3JldHVybiB3LndpbmRvdyh0KSYmKHQ9d2luZG93LmRvY3VtZW50LmJvZHkpLHt4OnQuc2Nyb2xsTGVmdCx5OnQuc2Nyb2xsVG9wfX12YXIgV3Q9e2lkOlwiYXV0by1zY3JvbGxcIixpbnN0YWxsOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZGVmYXVsdHMsbj10LmFjdGlvbnM7dC5hdXRvU2Nyb2xsPXF0LHF0Lm5vdz1mdW5jdGlvbigpe3JldHVybiB0Lm5vdygpfSxuLnBoYXNlbGVzc1R5cGVzLmF1dG9zY3JvbGw9ITAsZS5wZXJBY3Rpb24uYXV0b1Njcm9sbD1xdC5kZWZhdWx0c30sbGlzdGVuZXJzOntcImludGVyYWN0aW9uczpuZXdcIjpmdW5jdGlvbih0KXt0LmludGVyYWN0aW9uLmF1dG9TY3JvbGw9bnVsbH0sXCJpbnRlcmFjdGlvbnM6ZGVzdHJveVwiOmZ1bmN0aW9uKHQpe3QuaW50ZXJhY3Rpb24uYXV0b1Njcm9sbD1udWxsLHF0LnN0b3AoKSxxdC5pbnRlcmFjdGlvbiYmKHF0LmludGVyYWN0aW9uPW51bGwpfSxcImludGVyYWN0aW9uczpzdG9wXCI6cXQuc3RvcCxcImludGVyYWN0aW9uczphY3Rpb24tbW92ZVwiOmZ1bmN0aW9uKHQpe3JldHVybiBxdC5vbkludGVyYWN0aW9uTW92ZSh0KX19fSxHdD1XdDtmdW5jdGlvbiBOdCh0LGUpe3ZhciBuPSExO3JldHVybiBmdW5jdGlvbigpe3JldHVybiBufHwoZy5jb25zb2xlLndhcm4oZSksbj0hMCksdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fWZ1bmN0aW9uIFV0KHQsZSl7cmV0dXJuIHQubmFtZT1lLm5hbWUsdC5heGlzPWUuYXhpcyx0LmVkZ2VzPWUuZWRnZXMsdH1mdW5jdGlvbiBIdCh0KXtyZXR1cm4gdy5ib29sKHQpPyh0aGlzLm9wdGlvbnMuc3R5bGVDdXJzb3I9dCx0aGlzKTpudWxsPT09dD8oZGVsZXRlIHRoaXMub3B0aW9ucy5zdHlsZUN1cnNvcix0aGlzKTp0aGlzLm9wdGlvbnMuc3R5bGVDdXJzb3J9ZnVuY3Rpb24gS3QodCl7cmV0dXJuIHcuZnVuYyh0KT8odGhpcy5vcHRpb25zLmFjdGlvbkNoZWNrZXI9dCx0aGlzKTpudWxsPT09dD8oZGVsZXRlIHRoaXMub3B0aW9ucy5hY3Rpb25DaGVja2VyLHRoaXMpOnRoaXMub3B0aW9ucy5hY3Rpb25DaGVja2VyfXZhciAkdD17aWQ6XCJhdXRvLXN0YXJ0L2ludGVyYWN0YWJsZU1ldGhvZHNcIixpbnN0YWxsOmZ1bmN0aW9uKHQpe3ZhciBlPXQuSW50ZXJhY3RhYmxlO2UucHJvdG90eXBlLmdldEFjdGlvbj1mdW5jdGlvbihlLG4scixpKXt2YXIgbz1mdW5jdGlvbih0LGUsbixyLGkpe3ZhciBvPXQuZ2V0UmVjdChyKSxhPWUuYnV0dG9uc3x8ezA6MSwxOjQsMzo4LDQ6MTZ9W2UuYnV0dG9uXSxzPXthY3Rpb246bnVsbCxpbnRlcmFjdGFibGU6dCxpbnRlcmFjdGlvbjpuLGVsZW1lbnQ6cixyZWN0Om8sYnV0dG9uczphfTtyZXR1cm4gaS5maXJlKFwiYXV0by1zdGFydDpjaGVja1wiLHMpLHMuYWN0aW9ufSh0aGlzLG4scixpLHQpO3JldHVybiB0aGlzLm9wdGlvbnMuYWN0aW9uQ2hlY2tlcj90aGlzLm9wdGlvbnMuYWN0aW9uQ2hlY2tlcihlLG4sbyx0aGlzLGkscik6b30sZS5wcm90b3R5cGUuaWdub3JlRnJvbT1OdCgoZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2JhY2tDb21wYXRPcHRpb24oXCJpZ25vcmVGcm9tXCIsdCl9KSxcIkludGVyYWN0YWJsZS5pZ25vcmVGcm9tKCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIEludGVyYWN0YmxlLmRyYWdnYWJsZSh7aWdub3JlRnJvbTogbmV3VmFsdWV9KS5cIiksZS5wcm90b3R5cGUuYWxsb3dGcm9tPU50KChmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fYmFja0NvbXBhdE9wdGlvbihcImFsbG93RnJvbVwiLHQpfSksXCJJbnRlcmFjdGFibGUuYWxsb3dGcm9tKCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIEludGVyYWN0YmxlLmRyYWdnYWJsZSh7YWxsb3dGcm9tOiBuZXdWYWx1ZX0pLlwiKSxlLnByb3RvdHlwZS5hY3Rpb25DaGVja2VyPUt0LGUucHJvdG90eXBlLnN0eWxlQ3Vyc29yPUh0fX07ZnVuY3Rpb24gSnQodCxlLG4scixpKXtyZXR1cm4gZS50ZXN0SWdub3JlQWxsb3coZS5vcHRpb25zW3QubmFtZV0sbixyKSYmZS5vcHRpb25zW3QubmFtZV0uZW5hYmxlZCYmZWUoZSxuLHQsaSk/dDpudWxsfWZ1bmN0aW9uIFF0KHQsZSxuLHIsaSxvLGEpe2Zvcih2YXIgcz0wLGM9ci5sZW5ndGg7czxjO3MrKyl7dmFyIGw9cltzXSx1PWlbc10scD1sLmdldEFjdGlvbihlLG4sdCx1KTtpZihwKXt2YXIgZj1KdChwLGwsdSxvLGEpO2lmKGYpcmV0dXJue2FjdGlvbjpmLGludGVyYWN0YWJsZTpsLGVsZW1lbnQ6dX19fXJldHVybnthY3Rpb246bnVsbCxpbnRlcmFjdGFibGU6bnVsbCxlbGVtZW50Om51bGx9fWZ1bmN0aW9uIFp0KHQsZSxuLHIsaSl7dmFyIG89W10sYT1bXSxzPXI7ZnVuY3Rpb24gYyh0KXtvLnB1c2godCksYS5wdXNoKHMpfWZvcig7dy5lbGVtZW50KHMpOyl7bz1bXSxhPVtdLGkuaW50ZXJhY3RhYmxlcy5mb3JFYWNoTWF0Y2gocyxjKTt2YXIgbD1RdCh0LGUsbixvLGEscixpKTtpZihsLmFjdGlvbiYmIWwuaW50ZXJhY3RhYmxlLm9wdGlvbnNbbC5hY3Rpb24ubmFtZV0ubWFudWFsU3RhcnQpcmV0dXJuIGw7cz1BKHMpfXJldHVybnthY3Rpb246bnVsbCxpbnRlcmFjdGFibGU6bnVsbCxlbGVtZW50Om51bGx9fWZ1bmN0aW9uIHRlKHQsZSxuKXt2YXIgcj1lLmFjdGlvbixpPWUuaW50ZXJhY3RhYmxlLG89ZS5lbGVtZW50O3I9cnx8e25hbWU6bnVsbH0sdC5pbnRlcmFjdGFibGU9aSx0LmVsZW1lbnQ9byxVdCh0LnByZXBhcmVkLHIpLHQucmVjdD1pJiZyLm5hbWU/aS5nZXRSZWN0KG8pOm51bGwsaWUodCxuKSxuLmZpcmUoXCJhdXRvU3RhcnQ6cHJlcGFyZWRcIix7aW50ZXJhY3Rpb246dH0pfWZ1bmN0aW9uIGVlKHQsZSxuLHIpe3ZhciBpPXQub3B0aW9ucyxvPWlbbi5uYW1lXS5tYXgsYT1pW24ubmFtZV0ubWF4UGVyRWxlbWVudCxzPXIuYXV0b1N0YXJ0Lm1heEludGVyYWN0aW9ucyxjPTAsbD0wLHU9MDtpZighKG8mJmEmJnMpKXJldHVybiExO2Zvcih2YXIgcD0wLGY9ci5pbnRlcmFjdGlvbnMubGlzdDtwPGYubGVuZ3RoO3ArKyl7dmFyIGQ9ZltwXSxoPWQucHJlcGFyZWQubmFtZTtpZihkLmludGVyYWN0aW5nKCkpe2lmKCsrYz49cylyZXR1cm4hMTtpZihkLmludGVyYWN0YWJsZT09PXQpe2lmKChsKz1oPT09bi5uYW1lPzE6MCk+PW8pcmV0dXJuITE7aWYoZC5lbGVtZW50PT09ZSYmKHUrKyxoPT09bi5uYW1lJiZ1Pj1hKSlyZXR1cm4hMX19fXJldHVybiBzPjB9ZnVuY3Rpb24gbmUodCxlKXtyZXR1cm4gdy5udW1iZXIodCk/KGUuYXV0b1N0YXJ0Lm1heEludGVyYWN0aW9ucz10LHRoaXMpOmUuYXV0b1N0YXJ0Lm1heEludGVyYWN0aW9uc31mdW5jdGlvbiByZSh0LGUsbil7dmFyIHI9bi5hdXRvU3RhcnQuY3Vyc29yRWxlbWVudDtyJiZyIT09dCYmKHIuc3R5bGUuY3Vyc29yPVwiXCIpLHQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuY3Vyc29yPWUsdC5zdHlsZS5jdXJzb3I9ZSxuLmF1dG9TdGFydC5jdXJzb3JFbGVtZW50PWU/dDpudWxsfWZ1bmN0aW9uIGllKHQsZSl7dmFyIG49dC5pbnRlcmFjdGFibGUscj10LmVsZW1lbnQsaT10LnByZXBhcmVkO2lmKFwibW91c2VcIj09PXQucG9pbnRlclR5cGUmJm4mJm4ub3B0aW9ucy5zdHlsZUN1cnNvcil7dmFyIG89XCJcIjtpZihpLm5hbWUpe3ZhciBhPW4ub3B0aW9uc1tpLm5hbWVdLmN1cnNvckNoZWNrZXI7bz13LmZ1bmMoYSk/YShpLG4scix0Ll9pbnRlcmFjdGluZyk6ZS5hY3Rpb25zLm1hcFtpLm5hbWVdLmdldEN1cnNvcihpKX1yZSh0LmVsZW1lbnQsb3x8XCJcIixlKX1lbHNlIGUuYXV0b1N0YXJ0LmN1cnNvckVsZW1lbnQmJnJlKGUuYXV0b1N0YXJ0LmN1cnNvckVsZW1lbnQsXCJcIixlKX12YXIgb2U9e2lkOlwiYXV0by1zdGFydC9iYXNlXCIsYmVmb3JlOltcImFjdGlvbnNcIl0saW5zdGFsbDpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0U3RhdGljLG49dC5kZWZhdWx0czt0LnVzZVBsdWdpbigkdCksbi5iYXNlLmFjdGlvbkNoZWNrZXI9bnVsbCxuLmJhc2Uuc3R5bGVDdXJzb3I9ITAsVihuLnBlckFjdGlvbix7bWFudWFsU3RhcnQ6ITEsbWF4OjEvMCxtYXhQZXJFbGVtZW50OjEsYWxsb3dGcm9tOm51bGwsaWdub3JlRnJvbTpudWxsLG1vdXNlQnV0dG9uczoxfSksZS5tYXhJbnRlcmFjdGlvbnM9ZnVuY3Rpb24oZSl7cmV0dXJuIG5lKGUsdCl9LHQuYXV0b1N0YXJ0PXttYXhJbnRlcmFjdGlvbnM6MS8wLHdpdGhpbkludGVyYWN0aW9uTGltaXQ6ZWUsY3Vyc29yRWxlbWVudDpudWxsfX0sbGlzdGVuZXJzOntcImludGVyYWN0aW9uczpkb3duXCI6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmludGVyYWN0aW9uLHI9dC5wb2ludGVyLGk9dC5ldmVudCxvPXQuZXZlbnRUYXJnZXQ7bi5pbnRlcmFjdGluZygpfHx0ZShuLFp0KG4scixpLG8sZSksZSl9LFwiaW50ZXJhY3Rpb25zOm1vdmVcIjpmdW5jdGlvbih0LGUpeyFmdW5jdGlvbih0LGUpe3ZhciBuPXQuaW50ZXJhY3Rpb24scj10LnBvaW50ZXIsaT10LmV2ZW50LG89dC5ldmVudFRhcmdldDtcIm1vdXNlXCIhPT1uLnBvaW50ZXJUeXBlfHxuLnBvaW50ZXJJc0Rvd258fG4uaW50ZXJhY3RpbmcoKXx8dGUobixadChuLHIsaSxvLGUpLGUpfSh0LGUpLGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5pbnRlcmFjdGlvbjtpZihuLnBvaW50ZXJJc0Rvd24mJiFuLmludGVyYWN0aW5nKCkmJm4ucG9pbnRlcldhc01vdmVkJiZuLnByZXBhcmVkLm5hbWUpe2UuZmlyZShcImF1dG9TdGFydDpiZWZvcmUtc3RhcnRcIix0KTt2YXIgcj1uLmludGVyYWN0YWJsZSxpPW4ucHJlcGFyZWQubmFtZTtpJiZyJiYoci5vcHRpb25zW2ldLm1hbnVhbFN0YXJ0fHwhZWUocixuLmVsZW1lbnQsbi5wcmVwYXJlZCxlKT9uLnN0b3AoKToobi5zdGFydChuLnByZXBhcmVkLHIsbi5lbGVtZW50KSxpZShuLGUpKSl9fSh0LGUpfSxcImludGVyYWN0aW9uczpzdG9wXCI6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmludGVyYWN0aW9uLHI9bi5pbnRlcmFjdGFibGU7ciYmci5vcHRpb25zLnN0eWxlQ3Vyc29yJiZyZShuLmVsZW1lbnQsXCJcIixlKX19LG1heEludGVyYWN0aW9uczpuZSx3aXRoaW5JbnRlcmFjdGlvbkxpbWl0OmVlLHZhbGlkYXRlQWN0aW9uOkp0fSxhZT1vZTt2YXIgc2U9e2lkOlwiYXV0by1zdGFydC9kcmFnQXhpc1wiLGxpc3RlbmVyczp7XCJhdXRvU3RhcnQ6YmVmb3JlLXN0YXJ0XCI6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmludGVyYWN0aW9uLHI9dC5ldmVudFRhcmdldCxpPXQuZHgsbz10LmR5O2lmKFwiZHJhZ1wiPT09bi5wcmVwYXJlZC5uYW1lKXt2YXIgYT1NYXRoLmFicyhpKSxzPU1hdGguYWJzKG8pLGM9bi5pbnRlcmFjdGFibGUub3B0aW9ucy5kcmFnLGw9Yy5zdGFydEF4aXMsdT1hPnM/XCJ4XCI6YTxzP1wieVwiOlwieHlcIjtpZihuLnByZXBhcmVkLmF4aXM9XCJzdGFydFwiPT09Yy5sb2NrQXhpcz91WzBdOmMubG9ja0F4aXMsXCJ4eVwiIT09dSYmXCJ4eVwiIT09bCYmbCE9PXUpe24ucHJlcGFyZWQubmFtZT1udWxsO2Zvcih2YXIgcD1yLGY9ZnVuY3Rpb24odCl7aWYodCE9PW4uaW50ZXJhY3RhYmxlKXt2YXIgaT1uLmludGVyYWN0YWJsZS5vcHRpb25zLmRyYWc7aWYoIWkubWFudWFsU3RhcnQmJnQudGVzdElnbm9yZUFsbG93KGkscCxyKSl7dmFyIG89dC5nZXRBY3Rpb24obi5kb3duUG9pbnRlcixuLmRvd25FdmVudCxuLHApO2lmKG8mJlwiZHJhZ1wiPT09by5uYW1lJiZmdW5jdGlvbih0LGUpe2lmKCFlKXJldHVybiExO3ZhciBuPWUub3B0aW9ucy5kcmFnLnN0YXJ0QXhpcztyZXR1cm5cInh5XCI9PT10fHxcInh5XCI9PT1ufHxuPT09dH0odSx0KSYmYWUudmFsaWRhdGVBY3Rpb24obyx0LHAscixlKSlyZXR1cm4gdH19fTt3LmVsZW1lbnQocCk7KXt2YXIgZD1lLmludGVyYWN0YWJsZXMuZm9yRWFjaE1hdGNoKHAsZik7aWYoZCl7bi5wcmVwYXJlZC5uYW1lPVwiZHJhZ1wiLG4uaW50ZXJhY3RhYmxlPWQsbi5lbGVtZW50PXA7YnJlYWt9cD1BKHApfX19fX19O2Z1bmN0aW9uIGNlKHQpe3ZhciBlPXQucHJlcGFyZWQmJnQucHJlcGFyZWQubmFtZTtpZighZSlyZXR1cm4gbnVsbDt2YXIgbj10LmludGVyYWN0YWJsZS5vcHRpb25zO3JldHVybiBuW2VdLmhvbGR8fG5bZV0uZGVsYXl9dmFyIGxlPXtpZDpcImF1dG8tc3RhcnQvaG9sZFwiLGluc3RhbGw6ZnVuY3Rpb24odCl7dmFyIGU9dC5kZWZhdWx0czt0LnVzZVBsdWdpbihhZSksZS5wZXJBY3Rpb24uaG9sZD0wLGUucGVyQWN0aW9uLmRlbGF5PTB9LGxpc3RlbmVyczp7XCJpbnRlcmFjdGlvbnM6bmV3XCI6ZnVuY3Rpb24odCl7dC5pbnRlcmFjdGlvbi5hdXRvU3RhcnRIb2xkVGltZXI9bnVsbH0sXCJhdXRvU3RhcnQ6cHJlcGFyZWRcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLG49Y2UoZSk7bj4wJiYoZS5hdXRvU3RhcnRIb2xkVGltZXI9c2V0VGltZW91dCgoZnVuY3Rpb24oKXtlLnN0YXJ0KGUucHJlcGFyZWQsZS5pbnRlcmFjdGFibGUsZS5lbGVtZW50KX0pLG4pKX0sXCJpbnRlcmFjdGlvbnM6bW92ZVwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj10LmR1cGxpY2F0ZTtlLmF1dG9TdGFydEhvbGRUaW1lciYmZS5wb2ludGVyV2FzTW92ZWQmJiFuJiYoY2xlYXJUaW1lb3V0KGUuYXV0b1N0YXJ0SG9sZFRpbWVyKSxlLmF1dG9TdGFydEhvbGRUaW1lcj1udWxsKX0sXCJhdXRvU3RhcnQ6YmVmb3JlLXN0YXJ0XCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbjtjZShlKT4wJiYoZS5wcmVwYXJlZC5uYW1lPW51bGwpfX0sZ2V0SG9sZER1cmF0aW9uOmNlfSx1ZT1sZSxwZT17aWQ6XCJhdXRvLXN0YXJ0XCIsaW5zdGFsbDpmdW5jdGlvbih0KXt0LnVzZVBsdWdpbihhZSksdC51c2VQbHVnaW4odWUpLHQudXNlUGx1Z2luKHNlKX19LGZlPWZ1bmN0aW9uKHQpe3JldHVybi9eKGFsd2F5c3xuZXZlcnxhdXRvKSQvLnRlc3QodCk/KHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdD10LHRoaXMpOncuYm9vbCh0KT8odGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0PXQ/XCJhbHdheXNcIjpcIm5ldmVyXCIsdGhpcyk6dGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0fTtmdW5jdGlvbiBkZSh0KXt2YXIgZT10LmludGVyYWN0aW9uLG49dC5ldmVudDtlLmludGVyYWN0YWJsZSYmZS5pbnRlcmFjdGFibGUuY2hlY2tBbmRQcmV2ZW50RGVmYXVsdChuKX12YXIgaGU9e2lkOlwiY29yZS9pbnRlcmFjdGFibGVQcmV2ZW50RGVmYXVsdFwiLGluc3RhbGw6ZnVuY3Rpb24odCl7dmFyIGU9dC5JbnRlcmFjdGFibGU7ZS5wcm90b3R5cGUucHJldmVudERlZmF1bHQ9ZmUsZS5wcm90b3R5cGUuY2hlY2tBbmRQcmV2ZW50RGVmYXVsdD1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe3ZhciByPXQub3B0aW9ucy5wcmV2ZW50RGVmYXVsdDtpZihcIm5ldmVyXCIhPT1yKWlmKFwiYWx3YXlzXCIhPT1yKXtpZihlLmV2ZW50cy5zdXBwb3J0c1Bhc3NpdmUmJi9edG91Y2goc3RhcnR8bW92ZSkkLy50ZXN0KG4udHlwZSkpe3ZhciBpPXkobi50YXJnZXQpLmRvY3VtZW50LG89ZS5nZXREb2NPcHRpb25zKGkpO2lmKCFvfHwhby5ldmVudHN8fCExIT09by5ldmVudHMucGFzc2l2ZSlyZXR1cm59L14obW91c2V8cG9pbnRlcnx0b3VjaCkqKGRvd258c3RhcnQpL2kudGVzdChuLnR5cGUpfHx3LmVsZW1lbnQobi50YXJnZXQpJiZSKG4udGFyZ2V0LFwiaW5wdXQsc2VsZWN0LHRleHRhcmVhLFtjb250ZW50ZWRpdGFibGU9dHJ1ZV0sW2NvbnRlbnRlZGl0YWJsZT10cnVlXSAqXCIpfHxuLnByZXZlbnREZWZhdWx0KCl9ZWxzZSBuLnByZXZlbnREZWZhdWx0KCl9KHRoaXMsdCxlKX0sdC5pbnRlcmFjdGlvbnMuZG9jRXZlbnRzLnB1c2goe3R5cGU6XCJkcmFnc3RhcnRcIixsaXN0ZW5lcjpmdW5jdGlvbihlKXtmb3IodmFyIG49MCxyPXQuaW50ZXJhY3Rpb25zLmxpc3Q7bjxyLmxlbmd0aDtuKyspe3ZhciBpPXJbbl07aWYoaS5lbGVtZW50JiYoaS5lbGVtZW50PT09ZS50YXJnZXR8fE0oaS5lbGVtZW50LGUudGFyZ2V0KSkpcmV0dXJuIHZvaWQgaS5pbnRlcmFjdGFibGUuY2hlY2tBbmRQcmV2ZW50RGVmYXVsdChlKX19fSl9LGxpc3RlbmVyczpbXCJkb3duXCIsXCJtb3ZlXCIsXCJ1cFwiLFwiY2FuY2VsXCJdLnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdFtcImludGVyYWN0aW9uczpcIi5jb25jYXQoZSldPWRlLHR9KSx7fSl9O2Z1bmN0aW9uIHZlKHQsZSl7aWYoZS5waGFzZWxlc3NUeXBlc1t0XSlyZXR1cm4hMDtmb3IodmFyIG4gaW4gZS5tYXApaWYoMD09PXQuaW5kZXhPZihuKSYmdC5zdWJzdHIobi5sZW5ndGgpaW4gZS5waGFzZXMpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gZ2UodCl7dmFyIGU9e307Zm9yKHZhciBuIGluIHQpe3ZhciByPXRbbl07dy5wbGFpbk9iamVjdChyKT9lW25dPWdlKHIpOncuYXJyYXkocik/ZVtuXT1tdChyKTplW25dPXJ9cmV0dXJuIGV9dmFyIG1lPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXtyKHRoaXMsdCksdGhpcy5zdGF0ZXM9W10sdGhpcy5zdGFydE9mZnNldD17bGVmdDowLHJpZ2h0OjAsdG9wOjAsYm90dG9tOjB9LHRoaXMuc3RhcnREZWx0YT12b2lkIDAsdGhpcy5yZXN1bHQ9dm9pZCAwLHRoaXMuZW5kUmVzdWx0PXZvaWQgMCx0aGlzLnN0YXJ0RWRnZXM9dm9pZCAwLHRoaXMuZWRnZXM9dm9pZCAwLHRoaXMuaW50ZXJhY3Rpb249dm9pZCAwLHRoaXMuaW50ZXJhY3Rpb249ZSx0aGlzLnJlc3VsdD15ZSgpLHRoaXMuZWRnZXM9e2xlZnQ6ITEscmlnaHQ6ITEsdG9wOiExLGJvdHRvbTohMX19cmV0dXJuIG8odCxbe2tleTpcInN0YXJ0XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgbixyLGk9dC5waGFzZSxvPXRoaXMuaW50ZXJhY3Rpb24sYT1mdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0YWJsZS5vcHRpb25zW3QucHJlcGFyZWQubmFtZV0sbj1lLm1vZGlmaWVycztpZihuJiZuLmxlbmd0aClyZXR1cm4gbjtyZXR1cm5bXCJzbmFwXCIsXCJzbmFwU2l6ZVwiLFwic25hcEVkZ2VzXCIsXCJyZXN0cmljdFwiLFwicmVzdHJpY3RFZGdlc1wiLFwicmVzdHJpY3RTaXplXCJdLm1hcCgoZnVuY3Rpb24odCl7dmFyIG49ZVt0XTtyZXR1cm4gbiYmbi5lbmFibGVkJiZ7b3B0aW9uczpuLG1ldGhvZHM6bi5fbWV0aG9kc319KSkuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4hIXR9KSl9KG8pO3RoaXMucHJlcGFyZVN0YXRlcyhhKSx0aGlzLnN0YXJ0RWRnZXM9Vih7fSxvLmVkZ2VzKSx0aGlzLmVkZ2VzPVYoe30sdGhpcy5zdGFydEVkZ2VzKSx0aGlzLnN0YXJ0T2Zmc2V0PShuPW8ucmVjdCxyPWUsbj97bGVmdDpyLngtbi5sZWZ0LHRvcDpyLnktbi50b3AscmlnaHQ6bi5yaWdodC1yLngsYm90dG9tOm4uYm90dG9tLXIueX06e2xlZnQ6MCx0b3A6MCxyaWdodDowLGJvdHRvbTowfSksdGhpcy5zdGFydERlbHRhPXt4OjAseTowfTt2YXIgcz10aGlzLmZpbGxBcmcoe3BoYXNlOmkscGFnZUNvb3JkczplLHByZUVuZDohMX0pO3JldHVybiB0aGlzLnJlc3VsdD15ZSgpLHRoaXMuc3RhcnRBbGwocyksdGhpcy5yZXN1bHQ9dGhpcy5zZXRBbGwocyl9fSx7a2V5OlwiZmlsbEFyZ1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuaW50ZXJhY3Rpb247cmV0dXJuIHQuaW50ZXJhY3Rpb249ZSx0LmludGVyYWN0YWJsZT1lLmludGVyYWN0YWJsZSx0LmVsZW1lbnQ9ZS5lbGVtZW50LHQucmVjdHx8KHQucmVjdD1lLnJlY3QpLHQuZWRnZXN8fCh0LmVkZ2VzPXRoaXMuc3RhcnRFZGdlcyksdC5zdGFydE9mZnNldD10aGlzLnN0YXJ0T2Zmc2V0LHR9fSx7a2V5Olwic3RhcnRBbGxcIix2YWx1ZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPXRoaXMuc3RhdGVzO2U8bi5sZW5ndGg7ZSsrKXt2YXIgcj1uW2VdO3IubWV0aG9kcy5zdGFydCYmKHQuc3RhdGU9cixyLm1ldGhvZHMuc3RhcnQodCkpfX19LHtrZXk6XCJzZXRBbGxcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10LnBoYXNlLG49dC5wcmVFbmQscj10LnNraXBNb2RpZmllcnMsaT10LnJlY3Qsbz10LmVkZ2VzO3QuY29vcmRzPVYoe30sdC5wYWdlQ29vcmRzKSx0LnJlY3Q9Vih7fSxpKSx0LmVkZ2VzPVYoe30sbyk7Zm9yKHZhciBhPXI/dGhpcy5zdGF0ZXMuc2xpY2Uocik6dGhpcy5zdGF0ZXMscz15ZSh0LmNvb3Jkcyx0LnJlY3QpLGM9MDtjPGEubGVuZ3RoO2MrKyl7dmFyIGwsdT1hW2NdLHA9dS5vcHRpb25zLGY9Vih7fSx0LmNvb3JkcyksZD1udWxsO251bGwhPShsPXUubWV0aG9kcykmJmwuc2V0JiZ0aGlzLnNob3VsZERvKHAsbixlKSYmKHQuc3RhdGU9dSxkPXUubWV0aG9kcy5zZXQodCksSCh0LmVkZ2VzLHQucmVjdCx7eDp0LmNvb3Jkcy54LWYueCx5OnQuY29vcmRzLnktZi55fSkpLHMuZXZlbnRQcm9wcy5wdXNoKGQpfVYodGhpcy5lZGdlcyx0LmVkZ2VzKSxzLmRlbHRhLng9dC5jb29yZHMueC10LnBhZ2VDb29yZHMueCxzLmRlbHRhLnk9dC5jb29yZHMueS10LnBhZ2VDb29yZHMueSxzLnJlY3REZWx0YS5sZWZ0PXQucmVjdC5sZWZ0LWkubGVmdCxzLnJlY3REZWx0YS5yaWdodD10LnJlY3QucmlnaHQtaS5yaWdodCxzLnJlY3REZWx0YS50b3A9dC5yZWN0LnRvcC1pLnRvcCxzLnJlY3REZWx0YS5ib3R0b209dC5yZWN0LmJvdHRvbS1pLmJvdHRvbTt2YXIgaD10aGlzLnJlc3VsdC5jb29yZHMsdj10aGlzLnJlc3VsdC5yZWN0O2lmKGgmJnYpe3ZhciBnPXMucmVjdC5sZWZ0IT09di5sZWZ0fHxzLnJlY3QucmlnaHQhPT12LnJpZ2h0fHxzLnJlY3QudG9wIT09di50b3B8fHMucmVjdC5ib3R0b20hPT12LmJvdHRvbTtzLmNoYW5nZWQ9Z3x8aC54IT09cy5jb29yZHMueHx8aC55IT09cy5jb29yZHMueX1yZXR1cm4gc319LHtrZXk6XCJhcHBseVRvSW50ZXJhY3Rpb25cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmludGVyYWN0aW9uLG49dC5waGFzZSxyPWUuY29vcmRzLmN1cixpPWUuY29vcmRzLnN0YXJ0LG89dGhpcy5yZXN1bHQsYT10aGlzLnN0YXJ0RGVsdGEscz1vLmRlbHRhO1wic3RhcnRcIj09PW4mJlYodGhpcy5zdGFydERlbHRhLG8uZGVsdGEpO2Zvcih2YXIgYz0wLGw9W1tpLGFdLFtyLHNdXTtjPGwubGVuZ3RoO2MrKyl7dmFyIHU9bFtjXSxwPXVbMF0sZj11WzFdO3AucGFnZS54Kz1mLngscC5wYWdlLnkrPWYueSxwLmNsaWVudC54Kz1mLngscC5jbGllbnQueSs9Zi55fXZhciBkPXRoaXMucmVzdWx0LnJlY3REZWx0YSxoPXQucmVjdHx8ZS5yZWN0O2gubGVmdCs9ZC5sZWZ0LGgucmlnaHQrPWQucmlnaHQsaC50b3ArPWQudG9wLGguYm90dG9tKz1kLmJvdHRvbSxoLndpZHRoPWgucmlnaHQtaC5sZWZ0LGguaGVpZ2h0PWguYm90dG9tLWgudG9wfX0se2tleTpcInNldEFuZEFwcGx5XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5pbnRlcmFjdGlvbixuPXQucGhhc2Uscj10LnByZUVuZCxpPXQuc2tpcE1vZGlmaWVycyxvPXRoaXMuc2V0QWxsKHRoaXMuZmlsbEFyZyh7cHJlRW5kOnIscGhhc2U6bixwYWdlQ29vcmRzOnQubW9kaWZpZWRDb29yZHN8fGUuY29vcmRzLmN1ci5wYWdlfSkpO2lmKHRoaXMucmVzdWx0PW8sIW8uY2hhbmdlZCYmKCFpfHxpPHRoaXMuc3RhdGVzLmxlbmd0aCkmJmUuaW50ZXJhY3RpbmcoKSlyZXR1cm4hMTtpZih0Lm1vZGlmaWVkQ29vcmRzKXt2YXIgYT1lLmNvb3Jkcy5jdXIucGFnZSxzPXt4OnQubW9kaWZpZWRDb29yZHMueC1hLngseTp0Lm1vZGlmaWVkQ29vcmRzLnktYS55fTtvLmNvb3Jkcy54Kz1zLngsby5jb29yZHMueSs9cy55LG8uZGVsdGEueCs9cy54LG8uZGVsdGEueSs9cy55fXRoaXMuYXBwbHlUb0ludGVyYWN0aW9uKHQpfX0se2tleTpcImJlZm9yZUVuZFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj10LmV2ZW50LHI9dGhpcy5zdGF0ZXM7aWYociYmci5sZW5ndGgpe2Zvcih2YXIgaT0hMSxvPTA7bzxyLmxlbmd0aDtvKyspe3ZhciBhPXJbb107dC5zdGF0ZT1hO3ZhciBzPWEub3B0aW9ucyxjPWEubWV0aG9kcyxsPWMuYmVmb3JlRW5kJiZjLmJlZm9yZUVuZCh0KTtpZihsKXJldHVybiB0aGlzLmVuZFJlc3VsdD1sLCExO2k9aXx8IWkmJnRoaXMuc2hvdWxkRG8ocywhMCx0LnBoYXNlLCEwKX1pJiZlLm1vdmUoe2V2ZW50Om4scHJlRW5kOiEwfSl9fX0se2tleTpcInN0b3BcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uO2lmKHRoaXMuc3RhdGVzJiZ0aGlzLnN0YXRlcy5sZW5ndGgpe3ZhciBuPVYoe3N0YXRlczp0aGlzLnN0YXRlcyxpbnRlcmFjdGFibGU6ZS5pbnRlcmFjdGFibGUsZWxlbWVudDplLmVsZW1lbnQscmVjdDpudWxsfSx0KTt0aGlzLmZpbGxBcmcobik7Zm9yKHZhciByPTAsaT10aGlzLnN0YXRlcztyPGkubGVuZ3RoO3IrKyl7dmFyIG89aVtyXTtuLnN0YXRlPW8sby5tZXRob2RzLnN0b3AmJm8ubWV0aG9kcy5zdG9wKG4pfXRoaXMuc3RhdGVzPW51bGwsdGhpcy5lbmRSZXN1bHQ9bnVsbH19fSx7a2V5OlwicHJlcGFyZVN0YXRlc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuc3RhdGVzPVtdO2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKXt2YXIgbj10W2VdLHI9bi5vcHRpb25zLGk9bi5tZXRob2RzLG89bi5uYW1lO3RoaXMuc3RhdGVzLnB1c2goe29wdGlvbnM6cixtZXRob2RzOmksaW5kZXg6ZSxuYW1lOm99KX1yZXR1cm4gdGhpcy5zdGF0ZXN9fSx7a2V5OlwicmVzdG9yZUludGVyYWN0aW9uQ29vcmRzXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbixuPWUuY29vcmRzLHI9ZS5yZWN0LGk9ZS5tb2RpZmljYXRpb247aWYoaS5yZXN1bHQpe2Zvcih2YXIgbz1pLnN0YXJ0RGVsdGEsYT1pLnJlc3VsdCxzPWEuZGVsdGEsYz1hLnJlY3REZWx0YSxsPTAsdT1bW24uc3RhcnQsb10sW24uY3VyLHNdXTtsPHUubGVuZ3RoO2wrKyl7dmFyIHA9dVtsXSxmPXBbMF0sZD1wWzFdO2YucGFnZS54LT1kLngsZi5wYWdlLnktPWQueSxmLmNsaWVudC54LT1kLngsZi5jbGllbnQueS09ZC55fXIubGVmdC09Yy5sZWZ0LHIucmlnaHQtPWMucmlnaHQsci50b3AtPWMudG9wLHIuYm90dG9tLT1jLmJvdHRvbX19fSx7a2V5Olwic2hvdWxkRG9cIix2YWx1ZTpmdW5jdGlvbih0LGUsbixyKXtyZXR1cm4hKCF0fHwhMT09PXQuZW5hYmxlZHx8ciYmIXQuZW5kT25seXx8dC5lbmRPbmx5JiYhZXx8XCJzdGFydFwiPT09biYmIXQuc2V0U3RhcnQpfX0se2tleTpcImNvcHlGcm9tXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5zdGFydE9mZnNldD10LnN0YXJ0T2Zmc2V0LHRoaXMuc3RhcnREZWx0YT10LnN0YXJ0RGVsdGEsdGhpcy5zdGFydEVkZ2VzPXQuc3RhcnRFZGdlcyx0aGlzLmVkZ2VzPXQuZWRnZXMsdGhpcy5zdGF0ZXM9dC5zdGF0ZXMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gZ2UodCl9KSksdGhpcy5yZXN1bHQ9eWUoVih7fSx0LnJlc3VsdC5jb29yZHMpLFYoe30sdC5yZXN1bHQucmVjdCkpfX0se2tleTpcImRlc3Ryb3lcIix2YWx1ZTpmdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzKXRoaXNbdF09bnVsbH19XSksdH0oKTtmdW5jdGlvbiB5ZSh0LGUpe3JldHVybntyZWN0OmUsY29vcmRzOnQsZGVsdGE6e3g6MCx5OjB9LHJlY3REZWx0YTp7bGVmdDowLHJpZ2h0OjAsdG9wOjAsYm90dG9tOjB9LGV2ZW50UHJvcHM6W10sY2hhbmdlZDohMH19ZnVuY3Rpb24gYmUodCxlKXt2YXIgbj10LmRlZmF1bHRzLHI9e3N0YXJ0OnQuc3RhcnQsc2V0OnQuc2V0LGJlZm9yZUVuZDp0LmJlZm9yZUVuZCxzdG9wOnQuc3RvcH0saT1mdW5jdGlvbih0KXt2YXIgaT10fHx7fTtmb3IodmFyIG8gaW4gaS5lbmFibGVkPSExIT09aS5lbmFibGVkLG4pbyBpbiBpfHwoaVtvXT1uW29dKTt2YXIgYT17b3B0aW9uczppLG1ldGhvZHM6cixuYW1lOmUsZW5hYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIGkuZW5hYmxlZD0hMCxhfSxkaXNhYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIGkuZW5hYmxlZD0hMSxhfX07cmV0dXJuIGF9O3JldHVybiBlJiZcInN0cmluZ1wiPT10eXBlb2YgZSYmKGkuX2RlZmF1bHRzPW4saS5fbWV0aG9kcz1yKSxpfWZ1bmN0aW9uIHhlKHQpe3ZhciBlPXQuaUV2ZW50LG49dC5pbnRlcmFjdGlvbi5tb2RpZmljYXRpb24ucmVzdWx0O24mJihlLm1vZGlmaWVycz1uLmV2ZW50UHJvcHMpfXZhciB3ZT17aWQ6XCJtb2RpZmllcnMvYmFzZVwiLGJlZm9yZTpbXCJhY3Rpb25zXCJdLGluc3RhbGw6ZnVuY3Rpb24odCl7dC5kZWZhdWx0cy5wZXJBY3Rpb24ubW9kaWZpZXJzPVtdfSxsaXN0ZW5lcnM6e1wiaW50ZXJhY3Rpb25zOm5ld1wiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb247ZS5tb2RpZmljYXRpb249bmV3IG1lKGUpfSxcImludGVyYWN0aW9uczpiZWZvcmUtYWN0aW9uLXN0YXJ0XCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbixuPXQuaW50ZXJhY3Rpb24ubW9kaWZpY2F0aW9uO24uc3RhcnQodCxlLmNvb3Jkcy5zdGFydC5wYWdlKSxlLmVkZ2VzPW4uZWRnZXMsbi5hcHBseVRvSW50ZXJhY3Rpb24odCl9LFwiaW50ZXJhY3Rpb25zOmJlZm9yZS1hY3Rpb24tbW92ZVwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj1lLm1vZGlmaWNhdGlvbixyPW4uc2V0QW5kQXBwbHkodCk7cmV0dXJuIGUuZWRnZXM9bi5lZGdlcyxyfSxcImludGVyYWN0aW9uczpiZWZvcmUtYWN0aW9uLWVuZFwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj1lLm1vZGlmaWNhdGlvbixyPW4uYmVmb3JlRW5kKHQpO3JldHVybiBlLmVkZ2VzPW4uc3RhcnRFZGdlcyxyfSxcImludGVyYWN0aW9uczphY3Rpb24tc3RhcnRcIjp4ZSxcImludGVyYWN0aW9uczphY3Rpb24tbW92ZVwiOnhlLFwiaW50ZXJhY3Rpb25zOmFjdGlvbi1lbmRcIjp4ZSxcImludGVyYWN0aW9uczphZnRlci1hY3Rpb24tc3RhcnRcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5pbnRlcmFjdGlvbi5tb2RpZmljYXRpb24ucmVzdG9yZUludGVyYWN0aW9uQ29vcmRzKHQpfSxcImludGVyYWN0aW9uczphZnRlci1hY3Rpb24tbW92ZVwiOmZ1bmN0aW9uKHQpe3JldHVybiB0LmludGVyYWN0aW9uLm1vZGlmaWNhdGlvbi5yZXN0b3JlSW50ZXJhY3Rpb25Db29yZHModCl9LFwiaW50ZXJhY3Rpb25zOnN0b3BcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5pbnRlcmFjdGlvbi5tb2RpZmljYXRpb24uc3RvcCh0KX19fSxFZT13ZSxUZT17YmFzZTp7cHJldmVudERlZmF1bHQ6XCJhdXRvXCIsZGVsdGFTb3VyY2U6XCJwYWdlXCJ9LHBlckFjdGlvbjp7ZW5hYmxlZDohMSxvcmlnaW46e3g6MCx5OjB9fSxhY3Rpb25zOnt9fSxTZT1mdW5jdGlvbih0KXtzKG4sdCk7dmFyIGU9cChuKTtmdW5jdGlvbiBuKHQsaSxvLGEscyxjLGwpe3ZhciBwO3IodGhpcyxuKSwocD1lLmNhbGwodGhpcyx0KSkucmVsYXRlZFRhcmdldD1udWxsLHAuc2NyZWVuWD12b2lkIDAscC5zY3JlZW5ZPXZvaWQgMCxwLmJ1dHRvbj12b2lkIDAscC5idXR0b25zPXZvaWQgMCxwLmN0cmxLZXk9dm9pZCAwLHAuc2hpZnRLZXk9dm9pZCAwLHAuYWx0S2V5PXZvaWQgMCxwLm1ldGFLZXk9dm9pZCAwLHAucGFnZT12b2lkIDAscC5jbGllbnQ9dm9pZCAwLHAuZGVsdGE9dm9pZCAwLHAucmVjdD12b2lkIDAscC54MD12b2lkIDAscC55MD12b2lkIDAscC50MD12b2lkIDAscC5kdD12b2lkIDAscC5kdXJhdGlvbj12b2lkIDAscC5jbGllbnRYMD12b2lkIDAscC5jbGllbnRZMD12b2lkIDAscC52ZWxvY2l0eT12b2lkIDAscC5zcGVlZD12b2lkIDAscC5zd2lwZT12b2lkIDAscC5heGVzPXZvaWQgMCxwLnByZUVuZD12b2lkIDAscz1zfHx0LmVsZW1lbnQ7dmFyIGY9dC5pbnRlcmFjdGFibGUsZD0oZiYmZi5vcHRpb25zfHxUZSkuZGVsdGFTb3VyY2UsaD1LKGYscyxvKSx2PVwic3RhcnRcIj09PWEsZz1cImVuZFwiPT09YSxtPXY/dShwKTp0LnByZXZFdmVudCx5PXY/dC5jb29yZHMuc3RhcnQ6Zz97cGFnZTptLnBhZ2UsY2xpZW50Om0uY2xpZW50LHRpbWVTdGFtcDp0LmNvb3Jkcy5jdXIudGltZVN0YW1wfTp0LmNvb3Jkcy5jdXI7cmV0dXJuIHAucGFnZT1WKHt9LHkucGFnZSkscC5jbGllbnQ9Vih7fSx5LmNsaWVudCkscC5yZWN0PVYoe30sdC5yZWN0KSxwLnRpbWVTdGFtcD15LnRpbWVTdGFtcCxnfHwocC5wYWdlLngtPWgueCxwLnBhZ2UueS09aC55LHAuY2xpZW50LngtPWgueCxwLmNsaWVudC55LT1oLnkpLHAuY3RybEtleT1pLmN0cmxLZXkscC5hbHRLZXk9aS5hbHRLZXkscC5zaGlmdEtleT1pLnNoaWZ0S2V5LHAubWV0YUtleT1pLm1ldGFLZXkscC5idXR0b249aS5idXR0b24scC5idXR0b25zPWkuYnV0dG9ucyxwLnRhcmdldD1zLHAuY3VycmVudFRhcmdldD1zLHAucHJlRW5kPWMscC50eXBlPWx8fG8rKGF8fFwiXCIpLHAuaW50ZXJhY3RhYmxlPWYscC50MD12P3QucG9pbnRlcnNbdC5wb2ludGVycy5sZW5ndGgtMV0uZG93blRpbWU6bS50MCxwLngwPXQuY29vcmRzLnN0YXJ0LnBhZ2UueC1oLngscC55MD10LmNvb3Jkcy5zdGFydC5wYWdlLnktaC55LHAuY2xpZW50WDA9dC5jb29yZHMuc3RhcnQuY2xpZW50LngtaC54LHAuY2xpZW50WTA9dC5jb29yZHMuc3RhcnQuY2xpZW50LnktaC55LHAuZGVsdGE9dnx8Zz97eDowLHk6MH06e3g6cFtkXS54LW1bZF0ueCx5OnBbZF0ueS1tW2RdLnl9LHAuZHQ9dC5jb29yZHMuZGVsdGEudGltZVN0YW1wLHAuZHVyYXRpb249cC50aW1lU3RhbXAtcC50MCxwLnZlbG9jaXR5PVYoe30sdC5jb29yZHMudmVsb2NpdHlbZF0pLHAuc3BlZWQ9UShwLnZlbG9jaXR5LngscC52ZWxvY2l0eS55KSxwLnN3aXBlPWd8fFwiaW5lcnRpYXN0YXJ0XCI9PT1hP3AuZ2V0U3dpcGUoKTpudWxsLHB9cmV0dXJuIG8obixbe2tleTpcImdldFN3aXBlXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9pbnRlcmFjdGlvbjtpZih0LnByZXZFdmVudC5zcGVlZDw2MDB8fHRoaXMudGltZVN0YW1wLXQucHJldkV2ZW50LnRpbWVTdGFtcD4xNTApcmV0dXJuIG51bGw7dmFyIGU9MTgwKk1hdGguYXRhbjIodC5wcmV2RXZlbnQudmVsb2NpdHlZLHQucHJldkV2ZW50LnZlbG9jaXR5WCkvTWF0aC5QSTtlPDAmJihlKz0zNjApO3ZhciBuPTExMi41PD1lJiZlPDI0Ny41LHI9MjAyLjU8PWUmJmU8MzM3LjU7cmV0dXJue3VwOnIsZG93bjohciYmMjIuNTw9ZSYmZTwxNTcuNSxsZWZ0Om4scmlnaHQ6IW4mJigyOTIuNTw9ZXx8ZTw2Ny41KSxhbmdsZTplLHNwZWVkOnQucHJldkV2ZW50LnNwZWVkLHZlbG9jaXR5Ont4OnQucHJldkV2ZW50LnZlbG9jaXR5WCx5OnQucHJldkV2ZW50LnZlbG9jaXR5WX19fX0se2tleTpcInByZXZlbnREZWZhdWx0XCIsdmFsdWU6ZnVuY3Rpb24oKXt9fSx7a2V5Olwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZD10aGlzLnByb3BhZ2F0aW9uU3RvcHBlZD0hMH19LHtrZXk6XCJzdG9wUHJvcGFnYXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMucHJvcGFnYXRpb25TdG9wcGVkPSEwfX1dKSxufSh2dCk7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoU2UucHJvdG90eXBlLHtwYWdlWDp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFnZS54fSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5wYWdlLng9dH19LHBhZ2VZOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYWdlLnl9LHNldDpmdW5jdGlvbih0KXt0aGlzLnBhZ2UueT10fX0sY2xpZW50WDp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2xpZW50Lnh9LHNldDpmdW5jdGlvbih0KXt0aGlzLmNsaWVudC54PXR9fSxjbGllbnRZOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbGllbnQueX0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuY2xpZW50Lnk9dH19LGR4OntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWx0YS54fSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5kZWx0YS54PXR9fSxkeTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsdGEueX0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuZGVsdGEueT10fX0sdmVsb2NpdHlYOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52ZWxvY2l0eS54fSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy52ZWxvY2l0eS54PXR9fSx2ZWxvY2l0eVk6e2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZlbG9jaXR5Lnl9LHNldDpmdW5jdGlvbih0KXt0aGlzLnZlbG9jaXR5Lnk9dH19fSk7dmFyIF9lPW8oKGZ1bmN0aW9uIHQoZSxuLGksbyxhKXtyKHRoaXMsdCksdGhpcy5pZD12b2lkIDAsdGhpcy5wb2ludGVyPXZvaWQgMCx0aGlzLmV2ZW50PXZvaWQgMCx0aGlzLmRvd25UaW1lPXZvaWQgMCx0aGlzLmRvd25UYXJnZXQ9dm9pZCAwLHRoaXMuaWQ9ZSx0aGlzLnBvaW50ZXI9bix0aGlzLmV2ZW50PWksdGhpcy5kb3duVGltZT1vLHRoaXMuZG93blRhcmdldD1hfSkpLFBlPWZ1bmN0aW9uKHQpe3JldHVybiB0LmludGVyYWN0YWJsZT1cIlwiLHQuZWxlbWVudD1cIlwiLHQucHJlcGFyZWQ9XCJcIix0LnBvaW50ZXJJc0Rvd249XCJcIix0LnBvaW50ZXJXYXNNb3ZlZD1cIlwiLHQuX3Byb3h5PVwiXCIsdH0oe30pLE9lPWZ1bmN0aW9uKHQpe3JldHVybiB0LnN0YXJ0PVwiXCIsdC5tb3ZlPVwiXCIsdC5lbmQ9XCJcIix0LnN0b3A9XCJcIix0LmludGVyYWN0aW5nPVwiXCIsdH0oe30pLGtlPTAsRGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUpe3ZhciBuPXRoaXMsaT1lLnBvaW50ZXJUeXBlLG89ZS5zY29wZUZpcmU7cih0aGlzLHQpLHRoaXMuaW50ZXJhY3RhYmxlPW51bGwsdGhpcy5lbGVtZW50PW51bGwsdGhpcy5yZWN0PW51bGwsdGhpcy5fcmVjdHM9dm9pZCAwLHRoaXMuZWRnZXM9bnVsbCx0aGlzLl9zY29wZUZpcmU9dm9pZCAwLHRoaXMucHJlcGFyZWQ9e25hbWU6bnVsbCxheGlzOm51bGwsZWRnZXM6bnVsbH0sdGhpcy5wb2ludGVyVHlwZT12b2lkIDAsdGhpcy5wb2ludGVycz1bXSx0aGlzLmRvd25FdmVudD1udWxsLHRoaXMuZG93blBvaW50ZXI9e30sdGhpcy5fbGF0ZXN0UG9pbnRlcj17cG9pbnRlcjpudWxsLGV2ZW50Om51bGwsZXZlbnRUYXJnZXQ6bnVsbH0sdGhpcy5wcmV2RXZlbnQ9bnVsbCx0aGlzLnBvaW50ZXJJc0Rvd249ITEsdGhpcy5wb2ludGVyV2FzTW92ZWQ9ITEsdGhpcy5faW50ZXJhY3Rpbmc9ITEsdGhpcy5fZW5kaW5nPSExLHRoaXMuX3N0b3BwZWQ9ITAsdGhpcy5fcHJveHk9dm9pZCAwLHRoaXMuc2ltdWxhdGlvbj1udWxsLHRoaXMuZG9Nb3ZlPU50KChmdW5jdGlvbih0KXt0aGlzLm1vdmUodCl9KSxcIlRoZSBpbnRlcmFjdGlvbi5kb01vdmUoKSBtZXRob2QgaGFzIGJlZW4gcmVuYW1lZCB0byBpbnRlcmFjdGlvbi5tb3ZlKClcIiksdGhpcy5jb29yZHM9e3N0YXJ0OntwYWdlOnt4OjAseTowfSxjbGllbnQ6e3g6MCx5OjB9LHRpbWVTdGFtcDowfSxwcmV2OntwYWdlOnt4OjAseTowfSxjbGllbnQ6e3g6MCx5OjB9LHRpbWVTdGFtcDowfSxjdXI6e3BhZ2U6e3g6MCx5OjB9LGNsaWVudDp7eDowLHk6MH0sdGltZVN0YW1wOjB9LGRlbHRhOntwYWdlOnt4OjAseTowfSxjbGllbnQ6e3g6MCx5OjB9LHRpbWVTdGFtcDowfSx2ZWxvY2l0eTp7cGFnZTp7eDowLHk6MH0sY2xpZW50Ont4OjAseTowfSx0aW1lU3RhbXA6MH19LHRoaXMuX2lkPWtlKyssdGhpcy5fc2NvcGVGaXJlPW8sdGhpcy5wb2ludGVyVHlwZT1pO3ZhciBhPXRoaXM7dGhpcy5fcHJveHk9e307dmFyIHM9ZnVuY3Rpb24odCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4uX3Byb3h5LHQse2dldDpmdW5jdGlvbigpe3JldHVybiBhW3RdfX0pfTtmb3IodmFyIGMgaW4gUGUpcyhjKTt2YXIgbD1mdW5jdGlvbih0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkobi5fcHJveHksdCx7dmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gYVt0XS5hcHBseShhLGFyZ3VtZW50cyl9fSl9O2Zvcih2YXIgdSBpbiBPZSlsKHUpO3RoaXMuX3Njb3BlRmlyZShcImludGVyYWN0aW9uczpuZXdcIix7aW50ZXJhY3Rpb246dGhpc30pfXJldHVybiBvKHQsW3trZXk6XCJwb2ludGVyTW92ZVRvbGVyYW5jZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiAxfX0se2tleTpcInBvaW50ZXJEb3duXCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXMudXBkYXRlUG9pbnRlcih0LGUsbiwhMCksaT10aGlzLnBvaW50ZXJzW3JdO3RoaXMuX3Njb3BlRmlyZShcImludGVyYWN0aW9uczpkb3duXCIse3BvaW50ZXI6dCxldmVudDplLGV2ZW50VGFyZ2V0Om4scG9pbnRlckluZGV4OnIscG9pbnRlckluZm86aSx0eXBlOlwiZG93blwiLGludGVyYWN0aW9uOnRoaXN9KX19LHtrZXk6XCJzdGFydFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4hKHRoaXMuaW50ZXJhY3RpbmcoKXx8IXRoaXMucG9pbnRlcklzRG93bnx8dGhpcy5wb2ludGVycy5sZW5ndGg8KFwiZ2VzdHVyZVwiPT09dC5uYW1lPzI6MSl8fCFlLm9wdGlvbnNbdC5uYW1lXS5lbmFibGVkKSYmKFV0KHRoaXMucHJlcGFyZWQsdCksdGhpcy5pbnRlcmFjdGFibGU9ZSx0aGlzLmVsZW1lbnQ9bix0aGlzLnJlY3Q9ZS5nZXRSZWN0KG4pLHRoaXMuZWRnZXM9dGhpcy5wcmVwYXJlZC5lZGdlcz9WKHt9LHRoaXMucHJlcGFyZWQuZWRnZXMpOntsZWZ0OiEwLHJpZ2h0OiEwLHRvcDohMCxib3R0b206ITB9LHRoaXMuX3N0b3BwZWQ9ITEsdGhpcy5faW50ZXJhY3Rpbmc9dGhpcy5fZG9QaGFzZSh7aW50ZXJhY3Rpb246dGhpcyxldmVudDp0aGlzLmRvd25FdmVudCxwaGFzZTpcInN0YXJ0XCJ9KSYmIXRoaXMuX3N0b3BwZWQsdGhpcy5faW50ZXJhY3RpbmcpfX0se2tleTpcInBvaW50ZXJNb3ZlXCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4pe3RoaXMuc2ltdWxhdGlvbnx8dGhpcy5tb2RpZmljYXRpb24mJnRoaXMubW9kaWZpY2F0aW9uLmVuZFJlc3VsdHx8dGhpcy51cGRhdGVQb2ludGVyKHQsZSxuLCExKTt2YXIgcixpLG89dGhpcy5jb29yZHMuY3VyLnBhZ2UueD09PXRoaXMuY29vcmRzLnByZXYucGFnZS54JiZ0aGlzLmNvb3Jkcy5jdXIucGFnZS55PT09dGhpcy5jb29yZHMucHJldi5wYWdlLnkmJnRoaXMuY29vcmRzLmN1ci5jbGllbnQueD09PXRoaXMuY29vcmRzLnByZXYuY2xpZW50LngmJnRoaXMuY29vcmRzLmN1ci5jbGllbnQueT09PXRoaXMuY29vcmRzLnByZXYuY2xpZW50Lnk7dGhpcy5wb2ludGVySXNEb3duJiYhdGhpcy5wb2ludGVyV2FzTW92ZWQmJihyPXRoaXMuY29vcmRzLmN1ci5jbGllbnQueC10aGlzLmNvb3Jkcy5zdGFydC5jbGllbnQueCxpPXRoaXMuY29vcmRzLmN1ci5jbGllbnQueS10aGlzLmNvb3Jkcy5zdGFydC5jbGllbnQueSx0aGlzLnBvaW50ZXJXYXNNb3ZlZD1RKHIsaSk+dGhpcy5wb2ludGVyTW92ZVRvbGVyYW5jZSk7dmFyIGEscyxjLGw9dGhpcy5nZXRQb2ludGVySW5kZXgodCksdT17cG9pbnRlcjp0LHBvaW50ZXJJbmRleDpsLHBvaW50ZXJJbmZvOnRoaXMucG9pbnRlcnNbbF0sZXZlbnQ6ZSx0eXBlOlwibW92ZVwiLGV2ZW50VGFyZ2V0Om4sZHg6cixkeTppLGR1cGxpY2F0ZTpvLGludGVyYWN0aW9uOnRoaXN9O298fChhPXRoaXMuY29vcmRzLnZlbG9jaXR5LHM9dGhpcy5jb29yZHMuZGVsdGEsYz1NYXRoLm1heChzLnRpbWVTdGFtcC8xZTMsLjAwMSksYS5wYWdlLng9cy5wYWdlLngvYyxhLnBhZ2UueT1zLnBhZ2UueS9jLGEuY2xpZW50Lng9cy5jbGllbnQueC9jLGEuY2xpZW50Lnk9cy5jbGllbnQueS9jLGEudGltZVN0YW1wPWMpLHRoaXMuX3Njb3BlRmlyZShcImludGVyYWN0aW9uczptb3ZlXCIsdSksb3x8dGhpcy5zaW11bGF0aW9ufHwodGhpcy5pbnRlcmFjdGluZygpJiYodS50eXBlPW51bGwsdGhpcy5tb3ZlKHUpKSx0aGlzLnBvaW50ZXJXYXNNb3ZlZCYmZXQodGhpcy5jb29yZHMucHJldix0aGlzLmNvb3Jkcy5jdXIpKX19LHtrZXk6XCJtb3ZlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dCYmdC5ldmVudHx8bnQodGhpcy5jb29yZHMuZGVsdGEpLCh0PVYoe3BvaW50ZXI6dGhpcy5fbGF0ZXN0UG9pbnRlci5wb2ludGVyLGV2ZW50OnRoaXMuX2xhdGVzdFBvaW50ZXIuZXZlbnQsZXZlbnRUYXJnZXQ6dGhpcy5fbGF0ZXN0UG9pbnRlci5ldmVudFRhcmdldCxpbnRlcmFjdGlvbjp0aGlzfSx0fHx7fSkpLnBoYXNlPVwibW92ZVwiLHRoaXMuX2RvUGhhc2UodCl9fSx7a2V5OlwicG9pbnRlclVwXCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9dGhpcy5nZXRQb2ludGVySW5kZXgodCk7LTE9PT1pJiYoaT10aGlzLnVwZGF0ZVBvaW50ZXIodCxlLG4sITEpKTt2YXIgbz0vY2FuY2VsJC9pLnRlc3QoZS50eXBlKT9cImNhbmNlbFwiOlwidXBcIjt0aGlzLl9zY29wZUZpcmUoXCJpbnRlcmFjdGlvbnM6XCIuY29uY2F0KG8pLHtwb2ludGVyOnQscG9pbnRlckluZGV4OmkscG9pbnRlckluZm86dGhpcy5wb2ludGVyc1tpXSxldmVudDplLGV2ZW50VGFyZ2V0Om4sdHlwZTpvLGN1ckV2ZW50VGFyZ2V0OnIsaW50ZXJhY3Rpb246dGhpc30pLHRoaXMuc2ltdWxhdGlvbnx8dGhpcy5lbmQoZSksdGhpcy5yZW1vdmVQb2ludGVyKHQsZSl9fSx7a2V5OlwiZG9jdW1lbnRCbHVyXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5lbmQodCksdGhpcy5fc2NvcGVGaXJlKFwiaW50ZXJhY3Rpb25zOmJsdXJcIix7ZXZlbnQ6dCx0eXBlOlwiYmx1clwiLGludGVyYWN0aW9uOnRoaXN9KX19LHtrZXk6XCJlbmRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZTt0aGlzLl9lbmRpbmc9ITAsdD10fHx0aGlzLl9sYXRlc3RQb2ludGVyLmV2ZW50LHRoaXMuaW50ZXJhY3RpbmcoKSYmKGU9dGhpcy5fZG9QaGFzZSh7ZXZlbnQ6dCxpbnRlcmFjdGlvbjp0aGlzLHBoYXNlOlwiZW5kXCJ9KSksdGhpcy5fZW5kaW5nPSExLCEwPT09ZSYmdGhpcy5zdG9wKCl9fSx7a2V5OlwiY3VycmVudEFjdGlvblwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2ludGVyYWN0aW5nP3RoaXMucHJlcGFyZWQubmFtZTpudWxsfX0se2tleTpcImludGVyYWN0aW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faW50ZXJhY3Rpbmd9fSx7a2V5Olwic3RvcFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fc2NvcGVGaXJlKFwiaW50ZXJhY3Rpb25zOnN0b3BcIix7aW50ZXJhY3Rpb246dGhpc30pLHRoaXMuaW50ZXJhY3RhYmxlPXRoaXMuZWxlbWVudD1udWxsLHRoaXMuX2ludGVyYWN0aW5nPSExLHRoaXMuX3N0b3BwZWQ9ITAsdGhpcy5wcmVwYXJlZC5uYW1lPXRoaXMucHJldkV2ZW50PW51bGx9fSx7a2V5OlwiZ2V0UG9pbnRlckluZGV4XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9YXQodCk7cmV0dXJuXCJtb3VzZVwiPT09dGhpcy5wb2ludGVyVHlwZXx8XCJwZW5cIj09PXRoaXMucG9pbnRlclR5cGU/dGhpcy5wb2ludGVycy5sZW5ndGgtMTp5dCh0aGlzLnBvaW50ZXJzLChmdW5jdGlvbih0KXtyZXR1cm4gdC5pZD09PWV9KSl9fSx7a2V5OlwiZ2V0UG9pbnRlckluZm9cIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5wb2ludGVyc1t0aGlzLmdldFBvaW50ZXJJbmRleCh0KV19fSx7a2V5OlwidXBkYXRlUG9pbnRlclwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBpLG8sYSxzPWF0KHQpLGM9dGhpcy5nZXRQb2ludGVySW5kZXgodCksbD10aGlzLnBvaW50ZXJzW2NdO3JldHVybiByPSExIT09ciYmKHJ8fC8oZG93bnxzdGFydCkkL2kudGVzdChlLnR5cGUpKSxsP2wucG9pbnRlcj10OihsPW5ldyBfZShzLHQsZSxudWxsLG51bGwpLGM9dGhpcy5wb2ludGVycy5sZW5ndGgsdGhpcy5wb2ludGVycy5wdXNoKGwpKSxzdCh0aGlzLmNvb3Jkcy5jdXIsdGhpcy5wb2ludGVycy5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnBvaW50ZXJ9KSksdGhpcy5fbm93KCkpLGk9dGhpcy5jb29yZHMuZGVsdGEsbz10aGlzLmNvb3Jkcy5wcmV2LGE9dGhpcy5jb29yZHMuY3VyLGkucGFnZS54PWEucGFnZS54LW8ucGFnZS54LGkucGFnZS55PWEucGFnZS55LW8ucGFnZS55LGkuY2xpZW50Lng9YS5jbGllbnQueC1vLmNsaWVudC54LGkuY2xpZW50Lnk9YS5jbGllbnQueS1vLmNsaWVudC55LGkudGltZVN0YW1wPWEudGltZVN0YW1wLW8udGltZVN0YW1wLHImJih0aGlzLnBvaW50ZXJJc0Rvd249ITAsbC5kb3duVGltZT10aGlzLmNvb3Jkcy5jdXIudGltZVN0YW1wLGwuZG93blRhcmdldD1uLHR0KHRoaXMuZG93blBvaW50ZXIsdCksdGhpcy5pbnRlcmFjdGluZygpfHwoZXQodGhpcy5jb29yZHMuc3RhcnQsdGhpcy5jb29yZHMuY3VyKSxldCh0aGlzLmNvb3Jkcy5wcmV2LHRoaXMuY29vcmRzLmN1ciksdGhpcy5kb3duRXZlbnQ9ZSx0aGlzLnBvaW50ZXJXYXNNb3ZlZD0hMSkpLHRoaXMuX3VwZGF0ZUxhdGVzdFBvaW50ZXIodCxlLG4pLHRoaXMuX3Njb3BlRmlyZShcImludGVyYWN0aW9uczp1cGRhdGUtcG9pbnRlclwiLHtwb2ludGVyOnQsZXZlbnQ6ZSxldmVudFRhcmdldDpuLGRvd246cixwb2ludGVySW5mbzpsLHBvaW50ZXJJbmRleDpjLGludGVyYWN0aW9uOnRoaXN9KSxjfX0se2tleTpcInJlbW92ZVBvaW50ZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2V0UG9pbnRlckluZGV4KHQpO2lmKC0xIT09bil7dmFyIHI9dGhpcy5wb2ludGVyc1tuXTt0aGlzLl9zY29wZUZpcmUoXCJpbnRlcmFjdGlvbnM6cmVtb3ZlLXBvaW50ZXJcIix7cG9pbnRlcjp0LGV2ZW50OmUsZXZlbnRUYXJnZXQ6bnVsbCxwb2ludGVySW5kZXg6bixwb2ludGVySW5mbzpyLGludGVyYWN0aW9uOnRoaXN9KSx0aGlzLnBvaW50ZXJzLnNwbGljZShuLDEpLHRoaXMucG9pbnRlcklzRG93bj0hMX19fSx7a2V5OlwiX3VwZGF0ZUxhdGVzdFBvaW50ZXJcIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7dGhpcy5fbGF0ZXN0UG9pbnRlci5wb2ludGVyPXQsdGhpcy5fbGF0ZXN0UG9pbnRlci5ldmVudD1lLHRoaXMuX2xhdGVzdFBvaW50ZXIuZXZlbnRUYXJnZXQ9bn19LHtrZXk6XCJkZXN0cm95XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9sYXRlc3RQb2ludGVyLnBvaW50ZXI9bnVsbCx0aGlzLl9sYXRlc3RQb2ludGVyLmV2ZW50PW51bGwsdGhpcy5fbGF0ZXN0UG9pbnRlci5ldmVudFRhcmdldD1udWxsfX0se2tleTpcIl9jcmVhdGVQcmVwYXJlZEV2ZW50XCIsdmFsdWU6ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIG5ldyBTZSh0aGlzLHQsdGhpcy5wcmVwYXJlZC5uYW1lLGUsdGhpcy5lbGVtZW50LG4scil9fSx7a2V5OlwiX2ZpcmVFdmVudFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlO251bGw9PShlPXRoaXMuaW50ZXJhY3RhYmxlKXx8ZS5maXJlKHQpLCghdGhpcy5wcmV2RXZlbnR8fHQudGltZVN0YW1wPj10aGlzLnByZXZFdmVudC50aW1lU3RhbXApJiYodGhpcy5wcmV2RXZlbnQ9dCl9fSx7a2V5OlwiX2RvUGhhc2VcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10LmV2ZW50LG49dC5waGFzZSxyPXQucHJlRW5kLGk9dC50eXBlLG89dGhpcy5yZWN0O2lmKG8mJlwibW92ZVwiPT09biYmKEgodGhpcy5lZGdlcyxvLHRoaXMuY29vcmRzLmRlbHRhW3RoaXMuaW50ZXJhY3RhYmxlLm9wdGlvbnMuZGVsdGFTb3VyY2VdKSxvLndpZHRoPW8ucmlnaHQtby5sZWZ0LG8uaGVpZ2h0PW8uYm90dG9tLW8udG9wKSwhMT09PXRoaXMuX3Njb3BlRmlyZShcImludGVyYWN0aW9uczpiZWZvcmUtYWN0aW9uLVwiLmNvbmNhdChuKSx0KSlyZXR1cm4hMTt2YXIgYT10LmlFdmVudD10aGlzLl9jcmVhdGVQcmVwYXJlZEV2ZW50KGUsbixyLGkpO3JldHVybiB0aGlzLl9zY29wZUZpcmUoXCJpbnRlcmFjdGlvbnM6YWN0aW9uLVwiLmNvbmNhdChuKSx0KSxcInN0YXJ0XCI9PT1uJiYodGhpcy5wcmV2RXZlbnQ9YSksdGhpcy5fZmlyZUV2ZW50KGEpLHRoaXMuX3Njb3BlRmlyZShcImludGVyYWN0aW9uczphZnRlci1hY3Rpb24tXCIuY29uY2F0KG4pLHQpLCEwfX0se2tleTpcIl9ub3dcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfX1dKSx0fSgpO2Z1bmN0aW9uIEllKHQpe01lKHQuaW50ZXJhY3Rpb24pfWZ1bmN0aW9uIE1lKHQpe2lmKCFmdW5jdGlvbih0KXtyZXR1cm4hKCF0Lm9mZnNldC5wZW5kaW5nLngmJiF0Lm9mZnNldC5wZW5kaW5nLnkpfSh0KSlyZXR1cm4hMTt2YXIgZT10Lm9mZnNldC5wZW5kaW5nO3JldHVybiBBZSh0LmNvb3Jkcy5jdXIsZSksQWUodC5jb29yZHMuZGVsdGEsZSksSCh0LmVkZ2VzLHQucmVjdCxlKSxlLng9MCxlLnk9MCwhMH1mdW5jdGlvbiB6ZSh0KXt2YXIgZT10Lngsbj10Lnk7dGhpcy5vZmZzZXQucGVuZGluZy54Kz1lLHRoaXMub2Zmc2V0LnBlbmRpbmcueSs9bix0aGlzLm9mZnNldC50b3RhbC54Kz1lLHRoaXMub2Zmc2V0LnRvdGFsLnkrPW59ZnVuY3Rpb24gQWUodCxlKXt2YXIgbj10LnBhZ2Uscj10LmNsaWVudCxpPWUueCxvPWUueTtuLngrPWksbi55Kz1vLHIueCs9aSxyLnkrPW99T2Uub2Zmc2V0Qnk9XCJcIjt2YXIgUmU9e2lkOlwib2Zmc2V0XCIsYmVmb3JlOltcIm1vZGlmaWVyc1wiLFwicG9pbnRlci1ldmVudHNcIixcImFjdGlvbnNcIixcImluZXJ0aWFcIl0saW5zdGFsbDpmdW5jdGlvbih0KXt0LkludGVyYWN0aW9uLnByb3RvdHlwZS5vZmZzZXRCeT16ZX0sbGlzdGVuZXJzOntcImludGVyYWN0aW9uczpuZXdcIjpmdW5jdGlvbih0KXt0LmludGVyYWN0aW9uLm9mZnNldD17dG90YWw6e3g6MCx5OjB9LHBlbmRpbmc6e3g6MCx5OjB9fX0sXCJpbnRlcmFjdGlvbnM6dXBkYXRlLXBvaW50ZXJcIjpmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24odCl7dC5wb2ludGVySXNEb3duJiYoQWUodC5jb29yZHMuY3VyLHQub2Zmc2V0LnRvdGFsKSx0Lm9mZnNldC5wZW5kaW5nLng9MCx0Lm9mZnNldC5wZW5kaW5nLnk9MCl9KHQuaW50ZXJhY3Rpb24pfSxcImludGVyYWN0aW9uczpiZWZvcmUtYWN0aW9uLXN0YXJ0XCI6SWUsXCJpbnRlcmFjdGlvbnM6YmVmb3JlLWFjdGlvbi1tb3ZlXCI6SWUsXCJpbnRlcmFjdGlvbnM6YmVmb3JlLWFjdGlvbi1lbmRcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uO2lmKE1lKGUpKXJldHVybiBlLm1vdmUoe29mZnNldDohMH0pLGUuZW5kKCksITF9LFwiaW50ZXJhY3Rpb25zOnN0b3BcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uO2Uub2Zmc2V0LnRvdGFsLng9MCxlLm9mZnNldC50b3RhbC55PTAsZS5vZmZzZXQucGVuZGluZy54PTAsZS5vZmZzZXQucGVuZGluZy55PTB9fX0sQ2U9UmU7dmFyIGplPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXtyKHRoaXMsdCksdGhpcy5hY3RpdmU9ITEsdGhpcy5pc01vZGlmaWVkPSExLHRoaXMuc21vb3RoRW5kPSExLHRoaXMuYWxsb3dSZXN1bWU9ITEsdGhpcy5tb2RpZmljYXRpb249dm9pZCAwLHRoaXMubW9kaWZpZXJDb3VudD0wLHRoaXMubW9kaWZpZXJBcmc9dm9pZCAwLHRoaXMuc3RhcnRDb29yZHM9dm9pZCAwLHRoaXMudDA9MCx0aGlzLnYwPTAsdGhpcy50ZT0wLHRoaXMudGFyZ2V0T2Zmc2V0PXZvaWQgMCx0aGlzLm1vZGlmaWVkT2Zmc2V0PXZvaWQgMCx0aGlzLmN1cnJlbnRPZmZzZXQ9dm9pZCAwLHRoaXMubGFtYmRhX3YwPTAsdGhpcy5vbmVfdmVfdjA9MCx0aGlzLnRpbWVvdXQ9dm9pZCAwLHRoaXMuaW50ZXJhY3Rpb249dm9pZCAwLHRoaXMuaW50ZXJhY3Rpb249ZX1yZXR1cm4gbyh0LFt7a2V5Olwic3RhcnRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmludGVyYWN0aW9uLG49RmUoZSk7aWYoIW58fCFuLmVuYWJsZWQpcmV0dXJuITE7dmFyIHI9ZS5jb29yZHMudmVsb2NpdHkuY2xpZW50LGk9UShyLngsci55KSxvPXRoaXMubW9kaWZpY2F0aW9ufHwodGhpcy5tb2RpZmljYXRpb249bmV3IG1lKGUpKTtpZihvLmNvcHlGcm9tKGUubW9kaWZpY2F0aW9uKSx0aGlzLnQwPWUuX25vdygpLHRoaXMuYWxsb3dSZXN1bWU9bi5hbGxvd1Jlc3VtZSx0aGlzLnYwPWksdGhpcy5jdXJyZW50T2Zmc2V0PXt4OjAseTowfSx0aGlzLnN0YXJ0Q29vcmRzPWUuY29vcmRzLmN1ci5wYWdlLHRoaXMubW9kaWZpZXJBcmc9by5maWxsQXJnKHtwYWdlQ29vcmRzOnRoaXMuc3RhcnRDb29yZHMscHJlRW5kOiEwLHBoYXNlOlwiaW5lcnRpYXN0YXJ0XCJ9KSx0aGlzLnQwLWUuY29vcmRzLmN1ci50aW1lU3RhbXA8NTAmJmk+bi5taW5TcGVlZCYmaT5uLmVuZFNwZWVkKXRoaXMuc3RhcnRJbmVydGlhKCk7ZWxzZXtpZihvLnJlc3VsdD1vLnNldEFsbCh0aGlzLm1vZGlmaWVyQXJnKSwhby5yZXN1bHQuY2hhbmdlZClyZXR1cm4hMTt0aGlzLnN0YXJ0U21vb3RoRW5kKCl9cmV0dXJuIGUubW9kaWZpY2F0aW9uLnJlc3VsdC5yZWN0PW51bGwsZS5vZmZzZXRCeSh0aGlzLnRhcmdldE9mZnNldCksZS5fZG9QaGFzZSh7aW50ZXJhY3Rpb246ZSxldmVudDp0LHBoYXNlOlwiaW5lcnRpYXN0YXJ0XCJ9KSxlLm9mZnNldEJ5KHt4Oi10aGlzLnRhcmdldE9mZnNldC54LHk6LXRoaXMudGFyZ2V0T2Zmc2V0Lnl9KSxlLm1vZGlmaWNhdGlvbi5yZXN1bHQucmVjdD1udWxsLHRoaXMuYWN0aXZlPSEwLGUuc2ltdWxhdGlvbj10aGlzLCEwfX0se2tleTpcInN0YXJ0SW5lcnRpYVwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXRoaXMuaW50ZXJhY3Rpb24uY29vcmRzLnZlbG9jaXR5LmNsaWVudCxuPUZlKHRoaXMuaW50ZXJhY3Rpb24pLHI9bi5yZXNpc3RhbmNlLGk9LU1hdGgubG9nKG4uZW5kU3BlZWQvdGhpcy52MCkvcjt0aGlzLnRhcmdldE9mZnNldD17eDooZS54LWkpL3IseTooZS55LWkpL3J9LHRoaXMudGU9aSx0aGlzLmxhbWJkYV92MD1yL3RoaXMudjAsdGhpcy5vbmVfdmVfdjA9MS1uLmVuZFNwZWVkL3RoaXMudjA7dmFyIG89dGhpcy5tb2RpZmljYXRpb24sYT10aGlzLm1vZGlmaWVyQXJnO2EucGFnZUNvb3Jkcz17eDp0aGlzLnN0YXJ0Q29vcmRzLngrdGhpcy50YXJnZXRPZmZzZXQueCx5OnRoaXMuc3RhcnRDb29yZHMueSt0aGlzLnRhcmdldE9mZnNldC55fSxvLnJlc3VsdD1vLnNldEFsbChhKSxvLnJlc3VsdC5jaGFuZ2VkJiYodGhpcy5pc01vZGlmaWVkPSEwLHRoaXMubW9kaWZpZWRPZmZzZXQ9e3g6dGhpcy50YXJnZXRPZmZzZXQueCtvLnJlc3VsdC5kZWx0YS54LHk6dGhpcy50YXJnZXRPZmZzZXQueStvLnJlc3VsdC5kZWx0YS55fSksdGhpcy5vbk5leHRGcmFtZSgoZnVuY3Rpb24oKXtyZXR1cm4gdC5pbmVydGlhVGljaygpfSkpfX0se2tleTpcInN0YXJ0U21vb3RoRW5kXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuc21vb3RoRW5kPSEwLHRoaXMuaXNNb2RpZmllZD0hMCx0aGlzLnRhcmdldE9mZnNldD17eDp0aGlzLm1vZGlmaWNhdGlvbi5yZXN1bHQuZGVsdGEueCx5OnRoaXMubW9kaWZpY2F0aW9uLnJlc3VsdC5kZWx0YS55fSx0aGlzLm9uTmV4dEZyYW1lKChmdW5jdGlvbigpe3JldHVybiB0LnNtb290aEVuZFRpY2soKX0pKX19LHtrZXk6XCJvbk5leHRGcmFtZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7dGhpcy50aW1lb3V0PUx0LnJlcXVlc3QoKGZ1bmN0aW9uKCl7ZS5hY3RpdmUmJnQoKX0pKX19LHtrZXk6XCJpbmVydGlhVGlja1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQsZSxuLHIsaSxvLGEscz10aGlzLGM9dGhpcy5pbnRlcmFjdGlvbixsPUZlKGMpLnJlc2lzdGFuY2UsdT0oYy5fbm93KCktdGhpcy50MCkvMWUzO2lmKHU8dGhpcy50ZSl7dmFyIHAsZj0xLShNYXRoLmV4cCgtbCp1KS10aGlzLmxhbWJkYV92MCkvdGhpcy5vbmVfdmVfdjA7dGhpcy5pc01vZGlmaWVkPyh0PTAsZT0wLG49dGhpcy50YXJnZXRPZmZzZXQueCxyPXRoaXMudGFyZ2V0T2Zmc2V0LnksaT10aGlzLm1vZGlmaWVkT2Zmc2V0Lngsbz10aGlzLm1vZGlmaWVkT2Zmc2V0LnkscD17eDpZZShhPWYsdCxuLGkpLHk6WWUoYSxlLHIsbyl9KTpwPXt4OnRoaXMudGFyZ2V0T2Zmc2V0LngqZix5OnRoaXMudGFyZ2V0T2Zmc2V0LnkqZn07dmFyIGQ9e3g6cC54LXRoaXMuY3VycmVudE9mZnNldC54LHk6cC55LXRoaXMuY3VycmVudE9mZnNldC55fTt0aGlzLmN1cnJlbnRPZmZzZXQueCs9ZC54LHRoaXMuY3VycmVudE9mZnNldC55Kz1kLnksYy5vZmZzZXRCeShkKSxjLm1vdmUoKSx0aGlzLm9uTmV4dEZyYW1lKChmdW5jdGlvbigpe3JldHVybiBzLmluZXJ0aWFUaWNrKCl9KSl9ZWxzZSBjLm9mZnNldEJ5KHt4OnRoaXMubW9kaWZpZWRPZmZzZXQueC10aGlzLmN1cnJlbnRPZmZzZXQueCx5OnRoaXMubW9kaWZpZWRPZmZzZXQueS10aGlzLmN1cnJlbnRPZmZzZXQueX0pLHRoaXMuZW5kKCl9fSx7a2V5Olwic21vb3RoRW5kVGlja1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxlPXRoaXMuaW50ZXJhY3Rpb24sbj1lLl9ub3coKS10aGlzLnQwLHI9RmUoZSkuc21vb3RoRW5kRHVyYXRpb247aWYobjxyKXt2YXIgaT17eDpMZShuLDAsdGhpcy50YXJnZXRPZmZzZXQueCxyKSx5OkxlKG4sMCx0aGlzLnRhcmdldE9mZnNldC55LHIpfSxvPXt4OmkueC10aGlzLmN1cnJlbnRPZmZzZXQueCx5OmkueS10aGlzLmN1cnJlbnRPZmZzZXQueX07dGhpcy5jdXJyZW50T2Zmc2V0LngrPW8ueCx0aGlzLmN1cnJlbnRPZmZzZXQueSs9by55LGUub2Zmc2V0QnkobyksZS5tb3ZlKHtza2lwTW9kaWZpZXJzOnRoaXMubW9kaWZpZXJDb3VudH0pLHRoaXMub25OZXh0RnJhbWUoKGZ1bmN0aW9uKCl7cmV0dXJuIHQuc21vb3RoRW5kVGljaygpfSkpfWVsc2UgZS5vZmZzZXRCeSh7eDp0aGlzLnRhcmdldE9mZnNldC54LXRoaXMuY3VycmVudE9mZnNldC54LHk6dGhpcy50YXJnZXRPZmZzZXQueS10aGlzLmN1cnJlbnRPZmZzZXQueX0pLHRoaXMuZW5kKCl9fSx7a2V5OlwicmVzdW1lXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dC5wb2ludGVyLG49dC5ldmVudCxyPXQuZXZlbnRUYXJnZXQsaT10aGlzLmludGVyYWN0aW9uO2kub2Zmc2V0Qnkoe3g6LXRoaXMuY3VycmVudE9mZnNldC54LHk6LXRoaXMuY3VycmVudE9mZnNldC55fSksaS51cGRhdGVQb2ludGVyKGUsbixyLCEwKSxpLl9kb1BoYXNlKHtpbnRlcmFjdGlvbjppLGV2ZW50Om4scGhhc2U6XCJyZXN1bWVcIn0pLGV0KGkuY29vcmRzLnByZXYsaS5jb29yZHMuY3VyKSx0aGlzLnN0b3AoKX19LHtrZXk6XCJlbmRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuaW50ZXJhY3Rpb24ubW92ZSgpLHRoaXMuaW50ZXJhY3Rpb24uZW5kKCksdGhpcy5zdG9wKCl9fSx7a2V5Olwic3RvcFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5hY3RpdmU9dGhpcy5zbW9vdGhFbmQ9ITEsdGhpcy5pbnRlcmFjdGlvbi5zaW11bGF0aW9uPW51bGwsTHQuY2FuY2VsKHRoaXMudGltZW91dCl9fV0pLHR9KCk7ZnVuY3Rpb24gRmUodCl7dmFyIGU9dC5pbnRlcmFjdGFibGUsbj10LnByZXBhcmVkO3JldHVybiBlJiZlLm9wdGlvbnMmJm4ubmFtZSYmZS5vcHRpb25zW24ubmFtZV0uaW5lcnRpYX12YXIgWGU9e2lkOlwiaW5lcnRpYVwiLGJlZm9yZTpbXCJtb2RpZmllcnNcIixcImFjdGlvbnNcIl0saW5zdGFsbDpmdW5jdGlvbih0KXt2YXIgZT10LmRlZmF1bHRzO3QudXNlUGx1Z2luKENlKSx0LnVzZVBsdWdpbihFZSksdC5hY3Rpb25zLnBoYXNlcy5pbmVydGlhc3RhcnQ9ITAsdC5hY3Rpb25zLnBoYXNlcy5yZXN1bWU9ITAsZS5wZXJBY3Rpb24uaW5lcnRpYT17ZW5hYmxlZDohMSxyZXNpc3RhbmNlOjEwLG1pblNwZWVkOjEwMCxlbmRTcGVlZDoxMCxhbGxvd1Jlc3VtZTohMCxzbW9vdGhFbmREdXJhdGlvbjozMDB9fSxsaXN0ZW5lcnM6e1wiaW50ZXJhY3Rpb25zOm5ld1wiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb247ZS5pbmVydGlhPW5ldyBqZShlKX0sXCJpbnRlcmFjdGlvbnM6YmVmb3JlLWFjdGlvbi1lbmRcIjpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0aW9uLG49dC5ldmVudDtyZXR1cm4oIWUuX2ludGVyYWN0aW5nfHxlLnNpbXVsYXRpb258fCFlLmluZXJ0aWEuc3RhcnQobikpJiZudWxsfSxcImludGVyYWN0aW9uczpkb3duXCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbixuPXQuZXZlbnRUYXJnZXQscj1lLmluZXJ0aWE7aWYoci5hY3RpdmUpZm9yKHZhciBpPW47dy5lbGVtZW50KGkpOyl7aWYoaT09PWUuZWxlbWVudCl7ci5yZXN1bWUodCk7YnJlYWt9aT1BKGkpfX0sXCJpbnRlcmFjdGlvbnM6c3RvcFwiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24uaW5lcnRpYTtlLmFjdGl2ZSYmZS5zdG9wKCl9LFwiaW50ZXJhY3Rpb25zOmJlZm9yZS1hY3Rpb24tcmVzdW1lXCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbi5tb2RpZmljYXRpb247ZS5zdG9wKHQpLGUuc3RhcnQodCx0LmludGVyYWN0aW9uLmNvb3Jkcy5jdXIucGFnZSksZS5hcHBseVRvSW50ZXJhY3Rpb24odCl9LFwiaW50ZXJhY3Rpb25zOmJlZm9yZS1hY3Rpb24taW5lcnRpYXN0YXJ0XCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuaW50ZXJhY3Rpb24ubW9kaWZpY2F0aW9uLnNldEFuZEFwcGx5KHQpfSxcImludGVyYWN0aW9uczphY3Rpb24tcmVzdW1lXCI6eGUsXCJpbnRlcmFjdGlvbnM6YWN0aW9uLWluZXJ0aWFzdGFydFwiOnhlLFwiaW50ZXJhY3Rpb25zOmFmdGVyLWFjdGlvbi1pbmVydGlhc3RhcnRcIjpmdW5jdGlvbih0KXtyZXR1cm4gdC5pbnRlcmFjdGlvbi5tb2RpZmljYXRpb24ucmVzdG9yZUludGVyYWN0aW9uQ29vcmRzKHQpfSxcImludGVyYWN0aW9uczphZnRlci1hY3Rpb24tcmVzdW1lXCI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuaW50ZXJhY3Rpb24ubW9kaWZpY2F0aW9uLnJlc3RvcmVJbnRlcmFjdGlvbkNvb3Jkcyh0KX19fTtmdW5jdGlvbiBZZSh0LGUsbixyKXt2YXIgaT0xLXQ7cmV0dXJuIGkqaSplKzIqaSp0Km4rdCp0KnJ9ZnVuY3Rpb24gTGUodCxlLG4scil7cmV0dXJuLW4qKHQvPXIpKih0LTIpK2V9dmFyIHFlPVhlO2Z1bmN0aW9uIEJlKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWVbbl07aWYodC5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQpYnJlYWs7cih0KX19dmFyIFZlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXtyKHRoaXMsdCksdGhpcy5vcHRpb25zPXZvaWQgMCx0aGlzLnR5cGVzPXt9LHRoaXMucHJvcGFnYXRpb25TdG9wcGVkPSExLHRoaXMuaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkPSExLHRoaXMuZ2xvYmFsPXZvaWQgMCx0aGlzLm9wdGlvbnM9Vih7fSxlfHx7fSl9cmV0dXJuIG8odCxbe2tleTpcImZpcmVcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZSxuPXRoaXMuZ2xvYmFsOyhlPXRoaXMudHlwZXNbdC50eXBlXSkmJkJlKHQsZSksIXQucHJvcGFnYXRpb25TdG9wcGVkJiZuJiYoZT1uW3QudHlwZV0pJiZCZSh0LGUpfX0se2tleTpcIm9uXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgbj0kKHQsZSk7Zm9yKHQgaW4gbil0aGlzLnR5cGVzW3RdPWd0KHRoaXMudHlwZXNbdF18fFtdLG5bdF0pfX0se2tleTpcIm9mZlwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIG49JCh0LGUpO2Zvcih0IGluIG4pe3ZhciByPXRoaXMudHlwZXNbdF07aWYociYmci5sZW5ndGgpZm9yKHZhciBpPTAsbz1uW3RdO2k8by5sZW5ndGg7aSsrKXt2YXIgYT1vW2ldLHM9ci5pbmRleE9mKGEpOy0xIT09cyYmci5zcGxpY2UocywxKX19fX0se2tleTpcImdldFJlY3RcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gbnVsbH19XSksdH0oKTt2YXIgV2U9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUpe3IodGhpcyx0KSx0aGlzLmN1cnJlbnRUYXJnZXQ9dm9pZCAwLHRoaXMub3JpZ2luYWxFdmVudD12b2lkIDAsdGhpcy50eXBlPXZvaWQgMCx0aGlzLm9yaWdpbmFsRXZlbnQ9ZSx0dCh0aGlzLGUpfXJldHVybiBvKHQsW3trZXk6XCJwcmV2ZW50T3JpZ2luYWxEZWZhdWx0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLm9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKX19LHtrZXk6XCJzdG9wUHJvcGFnYXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMub3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24oKX19LHtrZXk6XCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMub3JpZ2luYWxFdmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKX19XSksdH0oKTtmdW5jdGlvbiBHZSh0KXtyZXR1cm4gdy5vYmplY3QodCk/e2NhcHR1cmU6ISF0LmNhcHR1cmUscGFzc2l2ZTohIXQucGFzc2l2ZX06e2NhcHR1cmU6ISF0LHBhc3NpdmU6ITF9fWZ1bmN0aW9uIE5lKHQsZSl7cmV0dXJuIHQ9PT1lfHwoXCJib29sZWFuXCI9PXR5cGVvZiB0PyEhZS5jYXB0dXJlPT09dCYmITE9PSEhZS5wYXNzaXZlOiEhdC5jYXB0dXJlPT0hIWUuY2FwdHVyZSYmISF0LnBhc3NpdmU9PSEhZS5wYXNzaXZlKX12YXIgVWU9e2lkOlwiZXZlbnRzXCIsaW5zdGFsbDpmdW5jdGlvbih0KXt2YXIgZSxuPVtdLHI9e30saT1bXSxvPXthZGQ6YSxyZW1vdmU6cyxhZGREZWxlZ2F0ZTpmdW5jdGlvbih0LGUsbixvLHMpe3ZhciB1PUdlKHMpO2lmKCFyW25dKXtyW25dPVtdO2Zvcih2YXIgcD0wO3A8aS5sZW5ndGg7cCsrKXt2YXIgZj1pW3BdO2EoZixuLGMpLGEoZixuLGwsITApfX12YXIgZD1yW25dLGg9YnQoZCwoZnVuY3Rpb24obil7cmV0dXJuIG4uc2VsZWN0b3I9PT10JiZuLmNvbnRleHQ9PT1lfSkpO2h8fChoPXtzZWxlY3Rvcjp0LGNvbnRleHQ6ZSxsaXN0ZW5lcnM6W119LGQucHVzaChoKSk7aC5saXN0ZW5lcnMucHVzaCh7ZnVuYzpvLG9wdGlvbnM6dX0pfSxyZW1vdmVEZWxlZ2F0ZTpmdW5jdGlvbih0LGUsbixpLG8pe3ZhciBhLHU9R2UobykscD1yW25dLGY9ITE7aWYoIXApcmV0dXJuO2ZvcihhPXAubGVuZ3RoLTE7YT49MDthLS0pe3ZhciBkPXBbYV07aWYoZC5zZWxlY3Rvcj09PXQmJmQuY29udGV4dD09PWUpe2Zvcih2YXIgaD1kLmxpc3RlbmVycyx2PWgubGVuZ3RoLTE7dj49MDt2LS0pe3ZhciBnPWhbdl07aWYoZy5mdW5jPT09aSYmTmUoZy5vcHRpb25zLHUpKXtoLnNwbGljZSh2LDEpLGgubGVuZ3RofHwocC5zcGxpY2UoYSwxKSxzKGUsbixjKSxzKGUsbixsLCEwKSksZj0hMDticmVha319aWYoZilicmVha319fSxkZWxlZ2F0ZUxpc3RlbmVyOmMsZGVsZWdhdGVVc2VDYXB0dXJlOmwsZGVsZWdhdGVkRXZlbnRzOnIsZG9jdW1lbnRzOmksdGFyZ2V0czpuLHN1cHBvcnRzT3B0aW9uczohMSxzdXBwb3J0c1Bhc3NpdmU6ITF9O2Z1bmN0aW9uIGEodCxlLHIsaSl7aWYodC5hZGRFdmVudExpc3RlbmVyKXt2YXIgYT1HZShpKSxzPWJ0KG4sKGZ1bmN0aW9uKGUpe3JldHVybiBlLmV2ZW50VGFyZ2V0PT09dH0pKTtzfHwocz17ZXZlbnRUYXJnZXQ6dCxldmVudHM6e319LG4ucHVzaChzKSkscy5ldmVudHNbZV18fChzLmV2ZW50c1tlXT1bXSksYnQocy5ldmVudHNbZV0sKGZ1bmN0aW9uKHQpe3JldHVybiB0LmZ1bmM9PT1yJiZOZSh0Lm9wdGlvbnMsYSl9KSl8fCh0LmFkZEV2ZW50TGlzdGVuZXIoZSxyLG8uc3VwcG9ydHNPcHRpb25zP2E6YS5jYXB0dXJlKSxzLmV2ZW50c1tlXS5wdXNoKHtmdW5jOnIsb3B0aW9uczphfSkpfX1mdW5jdGlvbiBzKHQsZSxyLGkpe2lmKHQuYWRkRXZlbnRMaXN0ZW5lciYmdC5yZW1vdmVFdmVudExpc3RlbmVyKXt2YXIgYT15dChuLChmdW5jdGlvbihlKXtyZXR1cm4gZS5ldmVudFRhcmdldD09PXR9KSksYz1uW2FdO2lmKGMmJmMuZXZlbnRzKWlmKFwiYWxsXCIhPT1lKXt2YXIgbD0hMSx1PWMuZXZlbnRzW2VdO2lmKHUpe2lmKFwiYWxsXCI9PT1yKXtmb3IodmFyIHA9dS5sZW5ndGgtMTtwPj0wO3AtLSl7dmFyIGY9dVtwXTtzKHQsZSxmLmZ1bmMsZi5vcHRpb25zKX1yZXR1cm59Zm9yKHZhciBkPUdlKGkpLGg9MDtoPHUubGVuZ3RoO2grKyl7dmFyIHY9dVtoXTtpZih2LmZ1bmM9PT1yJiZOZSh2Lm9wdGlvbnMsZCkpe3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLHIsby5zdXBwb3J0c09wdGlvbnM/ZDpkLmNhcHR1cmUpLHUuc3BsaWNlKGgsMSksMD09PXUubGVuZ3RoJiYoZGVsZXRlIGMuZXZlbnRzW2VdLGw9ITApO2JyZWFrfX19bCYmIU9iamVjdC5rZXlzKGMuZXZlbnRzKS5sZW5ndGgmJm4uc3BsaWNlKGEsMSl9ZWxzZSBmb3IoZSBpbiBjLmV2ZW50cyljLmV2ZW50cy5oYXNPd25Qcm9wZXJ0eShlKSYmcyh0LGUsXCJhbGxcIil9fWZ1bmN0aW9uIGModCxlKXtmb3IodmFyIG49R2UoZSksaT1uZXcgV2UodCksbz1yW3QudHlwZV0sYT1odCh0KVswXSxzPWE7dy5lbGVtZW50KHMpOyl7Zm9yKHZhciBjPTA7YzxvLmxlbmd0aDtjKyspe3ZhciBsPW9bY10sdT1sLnNlbGVjdG9yLHA9bC5jb250ZXh0O2lmKFIocyx1KSYmTShwLGEpJiZNKHAscykpe3ZhciBmPWwubGlzdGVuZXJzO2kuY3VycmVudFRhcmdldD1zO2Zvcih2YXIgZD0wO2Q8Zi5sZW5ndGg7ZCsrKXt2YXIgaD1mW2RdO05lKGgub3B0aW9ucyxuKSYmaC5mdW5jKGkpfX19cz1BKHMpfX1mdW5jdGlvbiBsKHQpe3JldHVybiBjKHQsITApfXJldHVybiBudWxsPT0oZT10LmRvY3VtZW50KXx8ZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsbnVsbCx7Z2V0IGNhcHR1cmUoKXtyZXR1cm4gby5zdXBwb3J0c09wdGlvbnM9ITB9LGdldCBwYXNzaXZlKCl7cmV0dXJuIG8uc3VwcG9ydHNQYXNzaXZlPSEwfX0pLHQuZXZlbnRzPW8sb319LEhlPXttZXRob2RPcmRlcjpbXCJzaW11bGF0aW9uUmVzdW1lXCIsXCJtb3VzZU9yUGVuXCIsXCJoYXNQb2ludGVyXCIsXCJpZGxlXCJdLHNlYXJjaDpmdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPUhlLm1ldGhvZE9yZGVyO2U8bi5sZW5ndGg7ZSsrKXt2YXIgcj1uW2VdLGk9SGVbcl0odCk7aWYoaSlyZXR1cm4gaX1yZXR1cm4gbnVsbH0sc2ltdWxhdGlvblJlc3VtZTpmdW5jdGlvbih0KXt2YXIgZT10LnBvaW50ZXJUeXBlLG49dC5ldmVudFR5cGUscj10LmV2ZW50VGFyZ2V0LGk9dC5zY29wZTtpZighL2Rvd258c3RhcnQvaS50ZXN0KG4pKXJldHVybiBudWxsO2Zvcih2YXIgbz0wLGE9aS5pbnRlcmFjdGlvbnMubGlzdDtvPGEubGVuZ3RoO28rKyl7dmFyIHM9YVtvXSxjPXI7aWYocy5zaW11bGF0aW9uJiZzLnNpbXVsYXRpb24uYWxsb3dSZXN1bWUmJnMucG9pbnRlclR5cGU9PT1lKWZvcig7Yzspe2lmKGM9PT1zLmVsZW1lbnQpcmV0dXJuIHM7Yz1BKGMpfX1yZXR1cm4gbnVsbH0sbW91c2VPclBlbjpmdW5jdGlvbih0KXt2YXIgZSxuPXQucG9pbnRlcklkLHI9dC5wb2ludGVyVHlwZSxpPXQuZXZlbnRUeXBlLG89dC5zY29wZTtpZihcIm1vdXNlXCIhPT1yJiZcInBlblwiIT09cilyZXR1cm4gbnVsbDtmb3IodmFyIGE9MCxzPW8uaW50ZXJhY3Rpb25zLmxpc3Q7YTxzLmxlbmd0aDthKyspe3ZhciBjPXNbYV07aWYoYy5wb2ludGVyVHlwZT09PXIpe2lmKGMuc2ltdWxhdGlvbiYmIUtlKGMsbikpY29udGludWU7aWYoYy5pbnRlcmFjdGluZygpKXJldHVybiBjO2V8fChlPWMpfX1pZihlKXJldHVybiBlO2Zvcih2YXIgbD0wLHU9by5pbnRlcmFjdGlvbnMubGlzdDtsPHUubGVuZ3RoO2wrKyl7dmFyIHA9dVtsXTtpZighKHAucG9pbnRlclR5cGUhPT1yfHwvZG93bi9pLnRlc3QoaSkmJnAuc2ltdWxhdGlvbikpcmV0dXJuIHB9cmV0dXJuIG51bGx9LGhhc1BvaW50ZXI6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQucG9pbnRlcklkLG49MCxyPXQuc2NvcGUuaW50ZXJhY3Rpb25zLmxpc3Q7bjxyLmxlbmd0aDtuKyspe3ZhciBpPXJbbl07aWYoS2UoaSxlKSlyZXR1cm4gaX1yZXR1cm4gbnVsbH0saWRsZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5wb2ludGVyVHlwZSxuPTAscj10LnNjb3BlLmludGVyYWN0aW9ucy5saXN0O248ci5sZW5ndGg7bisrKXt2YXIgaT1yW25dO2lmKDE9PT1pLnBvaW50ZXJzLmxlbmd0aCl7dmFyIG89aS5pbnRlcmFjdGFibGU7aWYobyYmKCFvLm9wdGlvbnMuZ2VzdHVyZXx8IW8ub3B0aW9ucy5nZXN0dXJlLmVuYWJsZWQpKWNvbnRpbnVlfWVsc2UgaWYoaS5wb2ludGVycy5sZW5ndGg+PTIpY29udGludWU7aWYoIWkuaW50ZXJhY3RpbmcoKSYmZT09PWkucG9pbnRlclR5cGUpcmV0dXJuIGl9cmV0dXJuIG51bGx9fTtmdW5jdGlvbiBLZSh0LGUpe3JldHVybiB0LnBvaW50ZXJzLnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlkPT09ZX0pKX12YXIgJGU9SGUsSmU9W1wicG9pbnRlckRvd25cIixcInBvaW50ZXJNb3ZlXCIsXCJwb2ludGVyVXBcIixcInVwZGF0ZVBvaW50ZXJcIixcInJlbW92ZVBvaW50ZXJcIixcIndpbmRvd0JsdXJcIl07ZnVuY3Rpb24gUWUodCxlKXtyZXR1cm4gZnVuY3Rpb24obil7dmFyIHI9ZS5pbnRlcmFjdGlvbnMubGlzdCxpPWR0KG4pLG89aHQobiksYT1vWzBdLHM9b1sxXSxjPVtdO2lmKC9edG91Y2gvLnRlc3Qobi50eXBlKSl7ZS5wcmV2VG91Y2hUaW1lPWUubm93KCk7Zm9yKHZhciBsPTAsdT1uLmNoYW5nZWRUb3VjaGVzO2w8dS5sZW5ndGg7bCsrKXt2YXIgcD11W2xdLGY9e3BvaW50ZXI6cCxwb2ludGVySWQ6YXQocCkscG9pbnRlclR5cGU6aSxldmVudFR5cGU6bi50eXBlLGV2ZW50VGFyZ2V0OmEsY3VyRXZlbnRUYXJnZXQ6cyxzY29wZTplfSxkPVplKGYpO2MucHVzaChbZi5wb2ludGVyLGYuZXZlbnRUYXJnZXQsZi5jdXJFdmVudFRhcmdldCxkXSl9fWVsc2V7dmFyIGg9ITE7aWYoIUkuc3VwcG9ydHNQb2ludGVyRXZlbnQmJi9tb3VzZS8udGVzdChuLnR5cGUpKXtmb3IodmFyIHY9MDt2PHIubGVuZ3RoJiYhaDt2KyspaD1cIm1vdXNlXCIhPT1yW3ZdLnBvaW50ZXJUeXBlJiZyW3ZdLnBvaW50ZXJJc0Rvd247aD1ofHxlLm5vdygpLWUucHJldlRvdWNoVGltZTw1MDB8fDA9PT1uLnRpbWVTdGFtcH1pZighaCl7dmFyIGc9e3BvaW50ZXI6bixwb2ludGVySWQ6YXQobikscG9pbnRlclR5cGU6aSxldmVudFR5cGU6bi50eXBlLGN1ckV2ZW50VGFyZ2V0OnMsZXZlbnRUYXJnZXQ6YSxzY29wZTplfSxtPVplKGcpO2MucHVzaChbZy5wb2ludGVyLGcuZXZlbnRUYXJnZXQsZy5jdXJFdmVudFRhcmdldCxtXSl9fWZvcih2YXIgeT0wO3k8Yy5sZW5ndGg7eSsrKXt2YXIgYj1jW3ldLHg9YlswXSx3PWJbMV0sRT1iWzJdO2JbM11bdF0oeCxuLHcsRSl9fX1mdW5jdGlvbiBaZSh0KXt2YXIgZT10LnBvaW50ZXJUeXBlLG49dC5zY29wZSxyPXtpbnRlcmFjdGlvbjokZS5zZWFyY2godCksc2VhcmNoRGV0YWlsczp0fTtyZXR1cm4gbi5maXJlKFwiaW50ZXJhY3Rpb25zOmZpbmRcIixyKSxyLmludGVyYWN0aW9ufHxuLmludGVyYWN0aW9ucy5uZXcoe3BvaW50ZXJUeXBlOmV9KX1mdW5jdGlvbiB0bih0LGUpe3ZhciBuPXQuZG9jLHI9dC5zY29wZSxpPXQub3B0aW9ucyxvPXIuaW50ZXJhY3Rpb25zLmRvY0V2ZW50cyxhPXIuZXZlbnRzLHM9YVtlXTtmb3IodmFyIGMgaW4gci5icm93c2VyLmlzSU9TJiYhaS5ldmVudHMmJihpLmV2ZW50cz17cGFzc2l2ZTohMX0pLGEuZGVsZWdhdGVkRXZlbnRzKXMobixjLGEuZGVsZWdhdGVMaXN0ZW5lcikscyhuLGMsYS5kZWxlZ2F0ZVVzZUNhcHR1cmUsITApO2Zvcih2YXIgbD1pJiZpLmV2ZW50cyx1PTA7dTxvLmxlbmd0aDt1Kyspe3ZhciBwPW9bdV07cyhuLHAudHlwZSxwLmxpc3RlbmVyLGwpfX12YXIgZW49e2lkOlwiY29yZS9pbnRlcmFjdGlvbnNcIixpbnN0YWxsOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT17fSxuPTA7bjxKZS5sZW5ndGg7bisrKXt2YXIgaT1KZVtuXTtlW2ldPVFlKGksdCl9dmFyIGEsYz1JLnBFdmVudFR5cGVzO2Z1bmN0aW9uIGwoKXtmb3IodmFyIGU9MCxuPXQuaW50ZXJhY3Rpb25zLmxpc3Q7ZTxuLmxlbmd0aDtlKyspe3ZhciByPW5bZV07aWYoci5wb2ludGVySXNEb3duJiZcInRvdWNoXCI9PT1yLnBvaW50ZXJUeXBlJiYhci5faW50ZXJhY3RpbmcpZm9yKHZhciBpPWZ1bmN0aW9uKCl7dmFyIGU9YVtvXTt0LmRvY3VtZW50cy5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4gTSh0LmRvYyxlLmRvd25UYXJnZXQpfSkpfHxyLnJlbW92ZVBvaW50ZXIoZS5wb2ludGVyLGUuZXZlbnQpfSxvPTAsYT1yLnBvaW50ZXJzO288YS5sZW5ndGg7bysrKWkoKX19KGE9ay5Qb2ludGVyRXZlbnQ/W3t0eXBlOmMuZG93bixsaXN0ZW5lcjpsfSx7dHlwZTpjLmRvd24sbGlzdGVuZXI6ZS5wb2ludGVyRG93bn0se3R5cGU6Yy5tb3ZlLGxpc3RlbmVyOmUucG9pbnRlck1vdmV9LHt0eXBlOmMudXAsbGlzdGVuZXI6ZS5wb2ludGVyVXB9LHt0eXBlOmMuY2FuY2VsLGxpc3RlbmVyOmUucG9pbnRlclVwfV06W3t0eXBlOlwibW91c2Vkb3duXCIsbGlzdGVuZXI6ZS5wb2ludGVyRG93bn0se3R5cGU6XCJtb3VzZW1vdmVcIixsaXN0ZW5lcjplLnBvaW50ZXJNb3ZlfSx7dHlwZTpcIm1vdXNldXBcIixsaXN0ZW5lcjplLnBvaW50ZXJVcH0se3R5cGU6XCJ0b3VjaHN0YXJ0XCIsbGlzdGVuZXI6bH0se3R5cGU6XCJ0b3VjaHN0YXJ0XCIsbGlzdGVuZXI6ZS5wb2ludGVyRG93bn0se3R5cGU6XCJ0b3VjaG1vdmVcIixsaXN0ZW5lcjplLnBvaW50ZXJNb3ZlfSx7dHlwZTpcInRvdWNoZW5kXCIsbGlzdGVuZXI6ZS5wb2ludGVyVXB9LHt0eXBlOlwidG91Y2hjYW5jZWxcIixsaXN0ZW5lcjplLnBvaW50ZXJVcH1dKS5wdXNoKHt0eXBlOlwiYmx1clwiLGxpc3RlbmVyOmZ1bmN0aW9uKGUpe2Zvcih2YXIgbj0wLHI9dC5pbnRlcmFjdGlvbnMubGlzdDtuPHIubGVuZ3RoO24rKyl7cltuXS5kb2N1bWVudEJsdXIoZSl9fX0pLHQucHJldlRvdWNoVGltZT0wLHQuSW50ZXJhY3Rpb249ZnVuY3Rpb24oZSl7cyhpLGUpO3ZhciBuPXAoaSk7ZnVuY3Rpb24gaSgpe3JldHVybiByKHRoaXMsaSksbi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIG8oaSxbe2tleTpcInBvaW50ZXJNb3ZlVG9sZXJhbmNlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHQuaW50ZXJhY3Rpb25zLnBvaW50ZXJNb3ZlVG9sZXJhbmNlfSxzZXQ6ZnVuY3Rpb24oZSl7dC5pbnRlcmFjdGlvbnMucG9pbnRlck1vdmVUb2xlcmFuY2U9ZX19LHtrZXk6XCJfbm93XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdC5ub3coKX19XSksaX0oRGUpLHQuaW50ZXJhY3Rpb25zPXtsaXN0OltdLG5ldzpmdW5jdGlvbihlKXtlLnNjb3BlRmlyZT1mdW5jdGlvbihlLG4pe3JldHVybiB0LmZpcmUoZSxuKX07dmFyIG49bmV3IHQuSW50ZXJhY3Rpb24oZSk7cmV0dXJuIHQuaW50ZXJhY3Rpb25zLmxpc3QucHVzaChuKSxufSxsaXN0ZW5lcnM6ZSxkb2NFdmVudHM6YSxwb2ludGVyTW92ZVRvbGVyYW5jZToxfSx0LnVzZVBsdWdpbihoZSl9LGxpc3RlbmVyczp7XCJzY29wZTphZGQtZG9jdW1lbnRcIjpmdW5jdGlvbih0KXtyZXR1cm4gdG4odCxcImFkZFwiKX0sXCJzY29wZTpyZW1vdmUtZG9jdW1lbnRcIjpmdW5jdGlvbih0KXtyZXR1cm4gdG4odCxcInJlbW92ZVwiKX0sXCJpbnRlcmFjdGFibGU6dW5zZXRcIjpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LmludGVyYWN0YWJsZSxyPWUuaW50ZXJhY3Rpb25zLmxpc3QubGVuZ3RoLTE7cj49MDtyLS0pe3ZhciBpPWUuaW50ZXJhY3Rpb25zLmxpc3Rbcl07aS5pbnRlcmFjdGFibGU9PT1uJiYoaS5zdG9wKCksZS5maXJlKFwiaW50ZXJhY3Rpb25zOmRlc3Ryb3lcIix7aW50ZXJhY3Rpb246aX0pLGkuZGVzdHJveSgpLGUuaW50ZXJhY3Rpb25zLmxpc3QubGVuZ3RoPjImJmUuaW50ZXJhY3Rpb25zLmxpc3Quc3BsaWNlKHIsMSkpfX19LG9uRG9jU2lnbmFsOnRuLGRvT25JbnRlcmFjdGlvbnM6UWUsbWV0aG9kTmFtZXM6SmV9LG5uPWVuLHJuPWZ1bmN0aW9uKHQpe3JldHVybiB0W3QuT249MF09XCJPblwiLHRbdC5PZmY9MV09XCJPZmZcIix0fShybnx8e30pLG9uPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlLG4saSxvKXtyKHRoaXMsdCksdGhpcy50YXJnZXQ9dm9pZCAwLHRoaXMub3B0aW9ucz12b2lkIDAsdGhpcy5fYWN0aW9ucz12b2lkIDAsdGhpcy5ldmVudHM9bmV3IFZlLHRoaXMuX2NvbnRleHQ9dm9pZCAwLHRoaXMuX3dpbj12b2lkIDAsdGhpcy5fZG9jPXZvaWQgMCx0aGlzLl9zY29wZUV2ZW50cz12b2lkIDAsdGhpcy5fYWN0aW9ucz1uLmFjdGlvbnMsdGhpcy50YXJnZXQ9ZSx0aGlzLl9jb250ZXh0PW4uY29udGV4dHx8aSx0aGlzLl93aW49eShCKGUpP3RoaXMuX2NvbnRleHQ6ZSksdGhpcy5fZG9jPXRoaXMuX3dpbi5kb2N1bWVudCx0aGlzLl9zY29wZUV2ZW50cz1vLHRoaXMuc2V0KG4pfXJldHVybiBvKHQsW3trZXk6XCJfZGVmYXVsdHNcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm57YmFzZTp7fSxwZXJBY3Rpb246e30sYWN0aW9uczp7fX19fSx7a2V5Olwic2V0T25FdmVudHNcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiB3LmZ1bmMoZS5vbnN0YXJ0KSYmdGhpcy5vbihcIlwiLmNvbmNhdCh0LFwic3RhcnRcIiksZS5vbnN0YXJ0KSx3LmZ1bmMoZS5vbm1vdmUpJiZ0aGlzLm9uKFwiXCIuY29uY2F0KHQsXCJtb3ZlXCIpLGUub25tb3ZlKSx3LmZ1bmMoZS5vbmVuZCkmJnRoaXMub24oXCJcIi5jb25jYXQodCxcImVuZFwiKSxlLm9uZW5kKSx3LmZ1bmMoZS5vbmluZXJ0aWFzdGFydCkmJnRoaXMub24oXCJcIi5jb25jYXQodCxcImluZXJ0aWFzdGFydFwiKSxlLm9uaW5lcnRpYXN0YXJ0KSx0aGlzfX0se2tleTpcInVwZGF0ZVBlckFjdGlvbkxpc3RlbmVyc1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcixpPXRoaXMsbz1udWxsPT0ocj10aGlzLl9hY3Rpb25zLm1hcFt0XSk/dm9pZCAwOnIuZmlsdGVyRXZlbnRUeXBlLGE9ZnVuY3Rpb24odCl7cmV0dXJuKG51bGw9PW98fG8odCkpJiZ2ZSh0LGkuX2FjdGlvbnMpfTsody5hcnJheShlKXx8dy5vYmplY3QoZSkpJiZ0aGlzLl9vbk9mZihybi5PZmYsdCxlLHZvaWQgMCxhKSwody5hcnJheShuKXx8dy5vYmplY3QobikpJiZ0aGlzLl9vbk9mZihybi5Pbix0LG4sdm9pZCAwLGEpfX0se2tleTpcInNldFBlckFjdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5fZGVmYXVsdHM7Zm9yKHZhciByIGluIGUpe3ZhciBpPXIsbz10aGlzLm9wdGlvbnNbdF0sYT1lW2ldO1wibGlzdGVuZXJzXCI9PT1pJiZ0aGlzLnVwZGF0ZVBlckFjdGlvbkxpc3RlbmVycyh0LG8ubGlzdGVuZXJzLGEpLHcuYXJyYXkoYSk/b1tpXT1tdChhKTp3LnBsYWluT2JqZWN0KGEpPyhvW2ldPVYob1tpXXx8e30sZ2UoYSkpLHcub2JqZWN0KG4ucGVyQWN0aW9uW2ldKSYmXCJlbmFibGVkXCJpbiBuLnBlckFjdGlvbltpXSYmKG9baV0uZW5hYmxlZD0hMSE9PWEuZW5hYmxlZCkpOncuYm9vbChhKSYmdy5vYmplY3Qobi5wZXJBY3Rpb25baV0pP29baV0uZW5hYmxlZD1hOm9baV09YX19fSx7a2V5OlwiZ2V0UmVjdFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0PXR8fCh3LmVsZW1lbnQodGhpcy50YXJnZXQpP3RoaXMudGFyZ2V0Om51bGwpLHcuc3RyaW5nKHRoaXMudGFyZ2V0KSYmKHQ9dHx8dGhpcy5fY29udGV4dC5xdWVyeVNlbGVjdG9yKHRoaXMudGFyZ2V0KSksTCh0KX19LHtrZXk6XCJyZWN0Q2hlY2tlclwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7cmV0dXJuIHcuZnVuYyh0KT8odGhpcy5nZXRSZWN0PWZ1bmN0aW9uKG4pe3ZhciByPVYoe30sdC5hcHBseShlLG4pKTtyZXR1cm5cIndpZHRoXCJpbiByfHwoci53aWR0aD1yLnJpZ2h0LXIubGVmdCxyLmhlaWdodD1yLmJvdHRvbS1yLnRvcCkscn0sdGhpcyk6bnVsbD09PXQ/KGRlbGV0ZSB0aGlzLmdldFJlY3QsdGhpcyk6dGhpcy5nZXRSZWN0fX0se2tleTpcIl9iYWNrQ29tcGF0T3B0aW9uXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtpZihCKGUpfHx3Lm9iamVjdChlKSl7Zm9yKHZhciBuIGluIHRoaXMub3B0aW9uc1t0XT1lLHRoaXMuX2FjdGlvbnMubWFwKXRoaXMub3B0aW9uc1tuXVt0XT1lO3JldHVybiB0aGlzfXJldHVybiB0aGlzLm9wdGlvbnNbdF19fSx7a2V5Olwib3JpZ2luXCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2JhY2tDb21wYXRPcHRpb24oXCJvcmlnaW5cIix0KX19LHtrZXk6XCJkZWx0YVNvdXJjZVwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVyblwicGFnZVwiPT09dHx8XCJjbGllbnRcIj09PXQ/KHRoaXMub3B0aW9ucy5kZWx0YVNvdXJjZT10LHRoaXMpOnRoaXMub3B0aW9ucy5kZWx0YVNvdXJjZX19LHtrZXk6XCJnZXRBbGxFbGVtZW50c1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy50YXJnZXQ7cmV0dXJuIHcuc3RyaW5nKHQpP0FycmF5LmZyb20odGhpcy5fY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKHQpKTp3LmZ1bmModCkmJnQuZ2V0QWxsRWxlbWVudHM/dC5nZXRBbGxFbGVtZW50cygpOncuZWxlbWVudCh0KT9bdF06W119fSx7a2V5OlwiY29udGV4dFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2NvbnRleHR9fSx7a2V5OlwiaW5Db250ZXh0XCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2NvbnRleHQ9PT10Lm93bmVyRG9jdW1lbnR8fE0odGhpcy5fY29udGV4dCx0KX19LHtrZXk6XCJ0ZXN0SWdub3JlQWxsb3dcIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7cmV0dXJuIXRoaXMudGVzdElnbm9yZSh0Lmlnbm9yZUZyb20sZSxuKSYmdGhpcy50ZXN0QWxsb3codC5hbGxvd0Zyb20sZSxuKX19LHtrZXk6XCJ0ZXN0QWxsb3dcIix2YWx1ZTpmdW5jdGlvbih0LGUsbil7cmV0dXJuIXR8fCEhdy5lbGVtZW50KG4pJiYody5zdHJpbmcodCk/RihuLHQsZSk6ISF3LmVsZW1lbnQodCkmJk0odCxuKSl9fSx7a2V5OlwidGVzdElnbm9yZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4hKCF0fHwhdy5lbGVtZW50KG4pKSYmKHcuc3RyaW5nKHQpP0Yobix0LGUpOiEhdy5lbGVtZW50KHQpJiZNKHQsbikpfX0se2tleTpcImZpcmVcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5ldmVudHMuZmlyZSh0KSx0aGlzfX0se2tleTpcIl9vbk9mZlwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuLHIsaSl7dy5vYmplY3QoZSkmJiF3LmFycmF5KGUpJiYocj1uLG49bnVsbCk7dmFyIG89JChlLG4saSk7Zm9yKHZhciBhIGluIG8pe1wid2hlZWxcIj09PWEmJihhPUkud2hlZWxFdmVudCk7Zm9yKHZhciBzPTAsYz1vW2FdO3M8Yy5sZW5ndGg7cysrKXt2YXIgbD1jW3NdO3ZlKGEsdGhpcy5fYWN0aW9ucyk/dGhpcy5ldmVudHNbdD09PXJuLk9uP1wib25cIjpcIm9mZlwiXShhLGwpOncuc3RyaW5nKHRoaXMudGFyZ2V0KT90aGlzLl9zY29wZUV2ZW50c1t0PT09cm4uT24/XCJhZGREZWxlZ2F0ZVwiOlwicmVtb3ZlRGVsZWdhdGVcIl0odGhpcy50YXJnZXQsdGhpcy5fY29udGV4dCxhLGwscik6dGhpcy5fc2NvcGVFdmVudHNbdD09PXJuLk9uP1wiYWRkXCI6XCJyZW1vdmVcIl0odGhpcy50YXJnZXQsYSxsLHIpfX1yZXR1cm4gdGhpc319LHtrZXk6XCJvblwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy5fb25PZmYocm4uT24sdCxlLG4pfX0se2tleTpcIm9mZlwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy5fb25PZmYocm4uT2ZmLHQsZSxuKX19LHtrZXk6XCJzZXRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLl9kZWZhdWx0cztmb3IodmFyIG4gaW4gdy5vYmplY3QodCl8fCh0PXt9KSx0aGlzLm9wdGlvbnM9Z2UoZS5iYXNlKSx0aGlzLl9hY3Rpb25zLm1ldGhvZERpY3Qpe3ZhciByPW4saT10aGlzLl9hY3Rpb25zLm1ldGhvZERpY3Rbcl07dGhpcy5vcHRpb25zW3JdPXt9LHRoaXMuc2V0UGVyQWN0aW9uKHIsVihWKHt9LGUucGVyQWN0aW9uKSxlLmFjdGlvbnNbcl0pKSx0aGlzW2ldKHRbcl0pfWZvcih2YXIgbyBpbiB0KVwiZ2V0UmVjdFwiIT09bz93LmZ1bmModGhpc1tvXSkmJnRoaXNbb10odFtvXSk6dGhpcy5yZWN0Q2hlY2tlcih0LmdldFJlY3QpO3JldHVybiB0aGlzfX0se2tleTpcInVuc2V0XCIsdmFsdWU6ZnVuY3Rpb24oKXtpZih3LnN0cmluZyh0aGlzLnRhcmdldCkpZm9yKHZhciB0IGluIHRoaXMuX3Njb3BlRXZlbnRzLmRlbGVnYXRlZEV2ZW50cylmb3IodmFyIGU9dGhpcy5fc2NvcGVFdmVudHMuZGVsZWdhdGVkRXZlbnRzW3RdLG49ZS5sZW5ndGgtMTtuPj0wO24tLSl7dmFyIHI9ZVtuXSxpPXIuc2VsZWN0b3Isbz1yLmNvbnRleHQsYT1yLmxpc3RlbmVycztpPT09dGhpcy50YXJnZXQmJm89PT10aGlzLl9jb250ZXh0JiZlLnNwbGljZShuLDEpO2Zvcih2YXIgcz1hLmxlbmd0aC0xO3M+PTA7cy0tKXRoaXMuX3Njb3BlRXZlbnRzLnJlbW92ZURlbGVnYXRlKHRoaXMudGFyZ2V0LHRoaXMuX2NvbnRleHQsdCxhW3NdWzBdLGFbc11bMV0pfWVsc2UgdGhpcy5fc2NvcGVFdmVudHMucmVtb3ZlKHRoaXMudGFyZ2V0LFwiYWxsXCIpfX1dKSx0fSgpLGFuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXt2YXIgbj10aGlzO3IodGhpcyx0KSx0aGlzLmxpc3Q9W10sdGhpcy5zZWxlY3Rvck1hcD17fSx0aGlzLnNjb3BlPXZvaWQgMCx0aGlzLnNjb3BlPWUsZS5hZGRMaXN0ZW5lcnMoe1wiaW50ZXJhY3RhYmxlOnVuc2V0XCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGFibGUscj1lLnRhcmdldCxpPXcuc3RyaW5nKHIpP24uc2VsZWN0b3JNYXBbcl06cltuLnNjb3BlLmlkXSxvPXl0KGksKGZ1bmN0aW9uKHQpe3JldHVybiB0PT09ZX0pKTtpLnNwbGljZShvLDEpfX0pfXJldHVybiBvKHQsW3trZXk6XCJuZXdcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2U9VihlfHx7fSx7YWN0aW9uczp0aGlzLnNjb3BlLmFjdGlvbnN9KTt2YXIgbj1uZXcgdGhpcy5zY29wZS5JbnRlcmFjdGFibGUodCxlLHRoaXMuc2NvcGUuZG9jdW1lbnQsdGhpcy5zY29wZS5ldmVudHMpO3JldHVybiB0aGlzLnNjb3BlLmFkZERvY3VtZW50KG4uX2RvYyksdGhpcy5saXN0LnB1c2gobiksdy5zdHJpbmcodCk/KHRoaXMuc2VsZWN0b3JNYXBbdF18fCh0aGlzLnNlbGVjdG9yTWFwW3RdPVtdKSx0aGlzLnNlbGVjdG9yTWFwW3RdLnB1c2gobikpOihuLnRhcmdldFt0aGlzLnNjb3BlLmlkXXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsdGhpcy5zY29wZS5pZCx7dmFsdWU6W10sY29uZmlndXJhYmxlOiEwfSksdFt0aGlzLnNjb3BlLmlkXS5wdXNoKG4pKSx0aGlzLnNjb3BlLmZpcmUoXCJpbnRlcmFjdGFibGU6bmV3XCIse3RhcmdldDp0LG9wdGlvbnM6ZSxpbnRlcmFjdGFibGU6bix3aW46dGhpcy5zY29wZS5fd2lufSksbn19LHtrZXk6XCJnZXRFeGlzdGluZ1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dmFyIG49ZSYmZS5jb250ZXh0fHx0aGlzLnNjb3BlLmRvY3VtZW50LHI9dy5zdHJpbmcodCksaT1yP3RoaXMuc2VsZWN0b3JNYXBbdF06dFt0aGlzLnNjb3BlLmlkXTtpZihpKXJldHVybiBidChpLChmdW5jdGlvbihlKXtyZXR1cm4gZS5fY29udGV4dD09PW4mJihyfHxlLmluQ29udGV4dCh0KSl9KSl9fSx7a2V5OlwiZm9yRWFjaE1hdGNoXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MCxyPXRoaXMubGlzdDtuPHIubGVuZ3RoO24rKyl7dmFyIGk9cltuXSxvPXZvaWQgMDtpZigody5zdHJpbmcoaS50YXJnZXQpP3cuZWxlbWVudCh0KSYmUih0LGkudGFyZ2V0KTp0PT09aS50YXJnZXQpJiZpLmluQ29udGV4dCh0KSYmKG89ZShpKSksdm9pZCAwIT09bylyZXR1cm4gb319fV0pLHR9KCk7dmFyIHNuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3ZhciBlPXRoaXM7cih0aGlzLHQpLHRoaXMuaWQ9XCJfX2ludGVyYWN0X3Njb3BlX1wiLmNvbmNhdChNYXRoLmZsb29yKDEwMCpNYXRoLnJhbmRvbSgpKSksdGhpcy5pc0luaXRpYWxpemVkPSExLHRoaXMubGlzdGVuZXJNYXBzPVtdLHRoaXMuYnJvd3Nlcj1JLHRoaXMuZGVmYXVsdHM9Z2UoVGUpLHRoaXMuRXZlbnRhYmxlPVZlLHRoaXMuYWN0aW9ucz17bWFwOnt9LHBoYXNlczp7c3RhcnQ6ITAsbW92ZTohMCxlbmQ6ITB9LG1ldGhvZERpY3Q6e30scGhhc2VsZXNzVHlwZXM6e319LHRoaXMuaW50ZXJhY3RTdGF0aWM9ZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24gZShuLHIpe3ZhciBpPXQuaW50ZXJhY3RhYmxlcy5nZXRFeGlzdGluZyhuLHIpO3JldHVybiBpfHwoKGk9dC5pbnRlcmFjdGFibGVzLm5ldyhuLHIpKS5ldmVudHMuZ2xvYmFsPWUuZ2xvYmFsRXZlbnRzKSxpfTtyZXR1cm4gZS5nZXRQb2ludGVyQXZlcmFnZT1sdCxlLmdldFRvdWNoQkJveD11dCxlLmdldFRvdWNoRGlzdGFuY2U9cHQsZS5nZXRUb3VjaEFuZ2xlPWZ0LGUuZ2V0RWxlbWVudFJlY3Q9TCxlLmdldEVsZW1lbnRDbGllbnRSZWN0PVksZS5tYXRjaGVzU2VsZWN0b3I9UixlLmNsb3Nlc3Q9eixlLmdsb2JhbEV2ZW50cz17fSxlLnZlcnNpb249XCIxLjEwLjI3XCIsZS5zY29wZT10LGUudXNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuc2NvcGUudXNlUGx1Z2luKHQsZSksdGhpc30sZS5pc1NldD1mdW5jdGlvbih0LGUpe3JldHVybiEhdGhpcy5zY29wZS5pbnRlcmFjdGFibGVzLmdldCh0LGUmJmUuY29udGV4dCl9LGUub249TnQoKGZ1bmN0aW9uKHQsZSxuKXtpZih3LnN0cmluZyh0KSYmLTEhPT10LnNlYXJjaChcIiBcIikmJih0PXQudHJpbSgpLnNwbGl0KC8gKy8pKSx3LmFycmF5KHQpKXtmb3IodmFyIHI9MCxpPXQ7cjxpLmxlbmd0aDtyKyspe3ZhciBvPWlbcl07dGhpcy5vbihvLGUsbil9cmV0dXJuIHRoaXN9aWYody5vYmplY3QodCkpe2Zvcih2YXIgYSBpbiB0KXRoaXMub24oYSx0W2FdLGUpO3JldHVybiB0aGlzfXJldHVybiB2ZSh0LHRoaXMuc2NvcGUuYWN0aW9ucyk/dGhpcy5nbG9iYWxFdmVudHNbdF0/dGhpcy5nbG9iYWxFdmVudHNbdF0ucHVzaChlKTp0aGlzLmdsb2JhbEV2ZW50c1t0XT1bZV06dGhpcy5zY29wZS5ldmVudHMuYWRkKHRoaXMuc2NvcGUuZG9jdW1lbnQsdCxlLHtvcHRpb25zOm59KSx0aGlzfSksXCJUaGUgaW50ZXJhY3Qub24oKSBtZXRob2QgaXMgYmVpbmcgZGVwcmVjYXRlZFwiKSxlLm9mZj1OdCgoZnVuY3Rpb24odCxlLG4pe2lmKHcuc3RyaW5nKHQpJiYtMSE9PXQuc2VhcmNoKFwiIFwiKSYmKHQ9dC50cmltKCkuc3BsaXQoLyArLykpLHcuYXJyYXkodCkpe2Zvcih2YXIgcj0wLGk9dDtyPGkubGVuZ3RoO3IrKyl7dmFyIG89aVtyXTt0aGlzLm9mZihvLGUsbil9cmV0dXJuIHRoaXN9aWYody5vYmplY3QodCkpe2Zvcih2YXIgYSBpbiB0KXRoaXMub2ZmKGEsdFthXSxlKTtyZXR1cm4gdGhpc312YXIgcztyZXR1cm4gdmUodCx0aGlzLnNjb3BlLmFjdGlvbnMpP3QgaW4gdGhpcy5nbG9iYWxFdmVudHMmJi0xIT09KHM9dGhpcy5nbG9iYWxFdmVudHNbdF0uaW5kZXhPZihlKSkmJnRoaXMuZ2xvYmFsRXZlbnRzW3RdLnNwbGljZShzLDEpOnRoaXMuc2NvcGUuZXZlbnRzLnJlbW92ZSh0aGlzLnNjb3BlLmRvY3VtZW50LHQsZSxuKSx0aGlzfSksXCJUaGUgaW50ZXJhY3Qub2ZmKCkgbWV0aG9kIGlzIGJlaW5nIGRlcHJlY2F0ZWRcIiksZS5kZWJ1Zz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNjb3BlfSxlLnN1cHBvcnRzVG91Y2g9ZnVuY3Rpb24oKXtyZXR1cm4gSS5zdXBwb3J0c1RvdWNofSxlLnN1cHBvcnRzUG9pbnRlckV2ZW50PWZ1bmN0aW9uKCl7cmV0dXJuIEkuc3VwcG9ydHNQb2ludGVyRXZlbnR9LGUuc3RvcD1mdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9dGhpcy5zY29wZS5pbnRlcmFjdGlvbnMubGlzdDt0PGUubGVuZ3RoO3QrKyllW3RdLnN0b3AoKTtyZXR1cm4gdGhpc30sZS5wb2ludGVyTW92ZVRvbGVyYW5jZT1mdW5jdGlvbih0KXtyZXR1cm4gdy5udW1iZXIodCk/KHRoaXMuc2NvcGUuaW50ZXJhY3Rpb25zLnBvaW50ZXJNb3ZlVG9sZXJhbmNlPXQsdGhpcyk6dGhpcy5zY29wZS5pbnRlcmFjdGlvbnMucG9pbnRlck1vdmVUb2xlcmFuY2V9LGUuYWRkRG9jdW1lbnQ9ZnVuY3Rpb24odCxlKXt0aGlzLnNjb3BlLmFkZERvY3VtZW50KHQsZSl9LGUucmVtb3ZlRG9jdW1lbnQ9ZnVuY3Rpb24odCl7dGhpcy5zY29wZS5yZW1vdmVEb2N1bWVudCh0KX0sZX0odGhpcyksdGhpcy5JbnRlcmFjdEV2ZW50PVNlLHRoaXMuSW50ZXJhY3RhYmxlPXZvaWQgMCx0aGlzLmludGVyYWN0YWJsZXM9bmV3IGFuKHRoaXMpLHRoaXMuX3dpbj12b2lkIDAsdGhpcy5kb2N1bWVudD12b2lkIDAsdGhpcy53aW5kb3c9dm9pZCAwLHRoaXMuZG9jdW1lbnRzPVtdLHRoaXMuX3BsdWdpbnM9e2xpc3Q6W10sbWFwOnt9fSx0aGlzLm9uV2luZG93VW5sb2FkPWZ1bmN0aW9uKHQpe3JldHVybiBlLnJlbW92ZURvY3VtZW50KHQudGFyZ2V0KX07dmFyIG49dGhpczt0aGlzLkludGVyYWN0YWJsZT1mdW5jdGlvbih0KXtzKGksdCk7dmFyIGU9cChpKTtmdW5jdGlvbiBpKCl7cmV0dXJuIHIodGhpcyxpKSxlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gbyhpLFt7a2V5OlwiX2RlZmF1bHRzXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG4uZGVmYXVsdHN9fSx7a2V5Olwic2V0XCIsdmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuIGYoYyhpLnByb3RvdHlwZSksXCJzZXRcIix0aGlzKS5jYWxsKHRoaXMsdCksbi5maXJlKFwiaW50ZXJhY3RhYmxlOnNldFwiLHtvcHRpb25zOnQsaW50ZXJhY3RhYmxlOnRoaXN9KSx0aGlzfX0se2tleTpcInVuc2V0XCIsdmFsdWU6ZnVuY3Rpb24oKXtmKGMoaS5wcm90b3R5cGUpLFwidW5zZXRcIix0aGlzKS5jYWxsKHRoaXMpO3ZhciB0PW4uaW50ZXJhY3RhYmxlcy5saXN0LmluZGV4T2YodGhpcyk7dDwwfHwobi5pbnRlcmFjdGFibGVzLmxpc3Quc3BsaWNlKHQsMSksbi5maXJlKFwiaW50ZXJhY3RhYmxlOnVuc2V0XCIse2ludGVyYWN0YWJsZTp0aGlzfSkpfX1dKSxpfShvbil9cmV0dXJuIG8odCxbe2tleTpcImFkZExpc3RlbmVyc1wiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7dGhpcy5saXN0ZW5lck1hcHMucHVzaCh7aWQ6ZSxtYXA6dH0pfX0se2tleTpcImZpcmVcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wLHI9dGhpcy5saXN0ZW5lck1hcHM7bjxyLmxlbmd0aDtuKyspe3ZhciBpPXJbbl0ubWFwW3RdO2lmKGkmJiExPT09aShlLHRoaXMsdCkpcmV0dXJuITF9fX0se2tleTpcImluaXRcIix2YWx1ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5pc0luaXRpYWxpemVkP3RoaXM6ZnVuY3Rpb24odCxlKXt0LmlzSW5pdGlhbGl6ZWQ9ITAsdy53aW5kb3coZSkmJm0oZSk7cmV0dXJuIGsuaW5pdChlKSxJLmluaXQoZSksTHQuaW5pdChlKSx0LndpbmRvdz1lLHQuZG9jdW1lbnQ9ZS5kb2N1bWVudCx0LnVzZVBsdWdpbihubiksdC51c2VQbHVnaW4oVWUpLHR9KHRoaXMsdCl9fSx7a2V5OlwicGx1Z2luSXNJbnN0YWxsZWRcIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10LmlkO3JldHVybiBlPyEhdGhpcy5fcGx1Z2lucy5tYXBbZV06LTEhPT10aGlzLl9wbHVnaW5zLmxpc3QuaW5kZXhPZih0KX19LHtrZXk6XCJ1c2VQbHVnaW5cIix2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKCF0aGlzLmlzSW5pdGlhbGl6ZWQpcmV0dXJuIHRoaXM7aWYodGhpcy5wbHVnaW5Jc0luc3RhbGxlZCh0KSlyZXR1cm4gdGhpcztpZih0LmlkJiYodGhpcy5fcGx1Z2lucy5tYXBbdC5pZF09dCksdGhpcy5fcGx1Z2lucy5saXN0LnB1c2godCksdC5pbnN0YWxsJiZ0Lmluc3RhbGwodGhpcyxlKSx0Lmxpc3RlbmVycyYmdC5iZWZvcmUpe2Zvcih2YXIgbj0wLHI9dGhpcy5saXN0ZW5lck1hcHMubGVuZ3RoLGk9dC5iZWZvcmUucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0W2VdPSEwLHRbY24oZSldPSEwLHR9KSx7fSk7bjxyO24rKyl7dmFyIG89dGhpcy5saXN0ZW5lck1hcHNbbl0uaWQ7aWYobyYmKGlbb118fGlbY24obyldKSlicmVha310aGlzLmxpc3RlbmVyTWFwcy5zcGxpY2UobiwwLHtpZDp0LmlkLG1hcDp0Lmxpc3RlbmVyc30pfWVsc2UgdC5saXN0ZW5lcnMmJnRoaXMubGlzdGVuZXJNYXBzLnB1c2goe2lkOnQuaWQsbWFwOnQubGlzdGVuZXJzfSk7cmV0dXJuIHRoaXN9fSx7a2V5OlwiYWRkRG9jdW1lbnRcIix2YWx1ZTpmdW5jdGlvbih0LGUpe2lmKC0xIT09dGhpcy5nZXREb2NJbmRleCh0KSlyZXR1cm4hMTt2YXIgbj15KHQpO2U9ZT9WKHt9LGUpOnt9LHRoaXMuZG9jdW1lbnRzLnB1c2goe2RvYzp0LG9wdGlvbnM6ZX0pLHRoaXMuZXZlbnRzLmRvY3VtZW50cy5wdXNoKHQpLHQhPT10aGlzLmRvY3VtZW50JiZ0aGlzLmV2ZW50cy5hZGQobixcInVubG9hZFwiLHRoaXMub25XaW5kb3dVbmxvYWQpLHRoaXMuZmlyZShcInNjb3BlOmFkZC1kb2N1bWVudFwiLHtkb2M6dCx3aW5kb3c6bixzY29wZTp0aGlzLG9wdGlvbnM6ZX0pfX0se2tleTpcInJlbW92ZURvY3VtZW50XCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXREb2NJbmRleCh0KSxuPXkodCkscj10aGlzLmRvY3VtZW50c1tlXS5vcHRpb25zO3RoaXMuZXZlbnRzLnJlbW92ZShuLFwidW5sb2FkXCIsdGhpcy5vbldpbmRvd1VubG9hZCksdGhpcy5kb2N1bWVudHMuc3BsaWNlKGUsMSksdGhpcy5ldmVudHMuZG9jdW1lbnRzLnNwbGljZShlLDEpLHRoaXMuZmlyZShcInNjb3BlOnJlbW92ZS1kb2N1bWVudFwiLHtkb2M6dCx3aW5kb3c6bixzY29wZTp0aGlzLG9wdGlvbnM6cn0pfX0se2tleTpcImdldERvY0luZGV4XCIsdmFsdWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0aGlzLmRvY3VtZW50cy5sZW5ndGg7ZSsrKWlmKHRoaXMuZG9jdW1lbnRzW2VdLmRvYz09PXQpcmV0dXJuIGU7cmV0dXJuLTF9fSx7a2V5OlwiZ2V0RG9jT3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0RG9jSW5kZXgodCk7cmV0dXJuLTE9PT1lP251bGw6dGhpcy5kb2N1bWVudHNbZV0ub3B0aW9uc319LHtrZXk6XCJub3dcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybih0aGlzLndpbmRvdy5EYXRlfHxEYXRlKS5ub3coKX19XSksdH0oKTtmdW5jdGlvbiBjbih0KXtyZXR1cm4gdCYmdC5yZXBsYWNlKC9cXC8uKiQvLFwiXCIpfXZhciBsbj1uZXcgc24sdW49bG4uaW50ZXJhY3RTdGF0aWMscG49XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczp3aW5kb3c7bG4uaW5pdChwbik7dmFyIGZuPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGVkZ2VUYXJnZXQ6ZnVuY3Rpb24oKXt9LGVsZW1lbnRzOmZ1bmN0aW9uKCl7fSxncmlkOmZ1bmN0aW9uKHQpe3ZhciBlPVtbXCJ4XCIsXCJ5XCJdLFtcImxlZnRcIixcInRvcFwiXSxbXCJyaWdodFwiLFwiYm90dG9tXCJdLFtcIndpZHRoXCIsXCJoZWlnaHRcIl1dLmZpbHRlcigoZnVuY3Rpb24oZSl7dmFyIG49ZVswXSxyPWVbMV07cmV0dXJuIG4gaW4gdHx8ciBpbiB0fSkpLG49ZnVuY3Rpb24obixyKXtmb3IodmFyIGk9dC5yYW5nZSxvPXQubGltaXRzLGE9dm9pZCAwPT09bz97bGVmdDotMS8wLHJpZ2h0OjEvMCx0b3A6LTEvMCxib3R0b206MS8wfTpvLHM9dC5vZmZzZXQsYz12b2lkIDA9PT1zP3t4OjAseTowfTpzLGw9e3JhbmdlOmksZ3JpZDp0LHg6bnVsbCx5Om51bGx9LHU9MDt1PGUubGVuZ3RoO3UrKyl7dmFyIHA9ZVt1XSxmPXBbMF0sZD1wWzFdLGg9TWF0aC5yb3VuZCgobi1jLngpL3RbZl0pLHY9TWF0aC5yb3VuZCgoci1jLnkpL3RbZF0pO2xbZl09TWF0aC5tYXgoYS5sZWZ0LE1hdGgubWluKGEucmlnaHQsaCp0W2ZdK2MueCkpLGxbZF09TWF0aC5tYXgoYS50b3AsTWF0aC5taW4oYS5ib3R0b20sdip0W2RdK2MueSkpfXJldHVybiBsfTtyZXR1cm4gbi5ncmlkPXQsbi5jb29yZEZpZWxkcz1lLG59fSksZG49e2lkOlwic25hcHBlcnNcIixpbnN0YWxsOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3RTdGF0aWM7ZS5zbmFwcGVycz1WKGUuc25hcHBlcnN8fHt9LGZuKSxlLmNyZWF0ZVNuYXBHcmlkPWUuc25hcHBlcnMuZ3JpZH19LGhuPWRuLHZuPXtzdGFydDpmdW5jdGlvbih0KXt2YXIgbj10LnN0YXRlLHI9dC5yZWN0LGk9dC5lZGdlcyxvPXQucGFnZUNvb3JkcyxhPW4ub3B0aW9ucyxzPWEucmF0aW8sYz1hLmVuYWJsZWQsbD1uLm9wdGlvbnMsdT1sLmVxdWFsRGVsdGEscD1sLm1vZGlmaWVycztcInByZXNlcnZlXCI9PT1zJiYocz1yLndpZHRoL3IuaGVpZ2h0KSxuLnN0YXJ0Q29vcmRzPVYoe30sbyksbi5zdGFydFJlY3Q9Vih7fSxyKSxuLnJhdGlvPXMsbi5lcXVhbERlbHRhPXU7dmFyIGY9bi5saW5rZWRFZGdlcz17dG9wOmkudG9wfHxpLmxlZnQmJiFpLmJvdHRvbSxsZWZ0OmkubGVmdHx8aS50b3AmJiFpLnJpZ2h0LGJvdHRvbTppLmJvdHRvbXx8aS5yaWdodCYmIWkudG9wLHJpZ2h0OmkucmlnaHR8fGkuYm90dG9tJiYhaS5sZWZ0fTtpZihuLnhJc1ByaW1hcnlBeGlzPSEoIWkubGVmdCYmIWkucmlnaHQpLG4uZXF1YWxEZWx0YSl7dmFyIGQ9KGYubGVmdD8xOi0xKSooZi50b3A/MTotMSk7bi5lZGdlU2lnbj17eDpkLHk6ZH19ZWxzZSBuLmVkZ2VTaWduPXt4OmYubGVmdD8tMToxLHk6Zi50b3A/LTE6MX07aWYoITEhPT1jJiZWKGksZiksbnVsbCE9cCYmcC5sZW5ndGgpe3ZhciBoPW5ldyBtZSh0LmludGVyYWN0aW9uKTtoLmNvcHlGcm9tKHQuaW50ZXJhY3Rpb24ubW9kaWZpY2F0aW9uKSxoLnByZXBhcmVTdGF0ZXMocCksbi5zdWJNb2RpZmljYXRpb249aCxoLnN0YXJ0QWxsKGUoe30sdCkpfX0sc2V0OmZ1bmN0aW9uKHQpe3ZhciBuPXQuc3RhdGUscj10LnJlY3QsaT10LmNvb3JkcyxvPW4ubGlua2VkRWRnZXMsYT1WKHt9LGkpLHM9bi5lcXVhbERlbHRhP2duOm1uO2lmKFYodC5lZGdlcyxvKSxzKG4sbi54SXNQcmltYXJ5QXhpcyxpLHIpLCFuLnN1Yk1vZGlmaWNhdGlvbilyZXR1cm4gbnVsbDt2YXIgYz1WKHt9LHIpO0gobyxjLHt4OmkueC1hLngseTppLnktYS55fSk7dmFyIGw9bi5zdWJNb2RpZmljYXRpb24uc2V0QWxsKGUoZSh7fSx0KSx7fSx7cmVjdDpjLGVkZ2VzOm8scGFnZUNvb3JkczppLHByZXZDb29yZHM6aSxwcmV2UmVjdDpjfSkpLHU9bC5kZWx0YTtsLmNoYW5nZWQmJihzKG4sTWF0aC5hYnModS54KT5NYXRoLmFicyh1LnkpLGwuY29vcmRzLGwucmVjdCksVihpLGwuY29vcmRzKSk7cmV0dXJuIGwuZXZlbnRQcm9wc30sZGVmYXVsdHM6e3JhdGlvOlwicHJlc2VydmVcIixlcXVhbERlbHRhOiExLG1vZGlmaWVyczpbXSxlbmFibGVkOiExfX07ZnVuY3Rpb24gZ24odCxlLG4pe3ZhciByPXQuc3RhcnRDb29yZHMsaT10LmVkZ2VTaWduO2U/bi55PXIueSsobi54LXIueCkqaS55Om4ueD1yLngrKG4ueS1yLnkpKmkueH1mdW5jdGlvbiBtbih0LGUsbixyKXt2YXIgaT10LnN0YXJ0UmVjdCxvPXQuc3RhcnRDb29yZHMsYT10LnJhdGlvLHM9dC5lZGdlU2lnbjtpZihlKXt2YXIgYz1yLndpZHRoL2E7bi55PW8ueSsoYy1pLmhlaWdodCkqcy55fWVsc2V7dmFyIGw9ci5oZWlnaHQqYTtuLng9by54KyhsLWkud2lkdGgpKnMueH19dmFyIHluPWJlKHZuLFwiYXNwZWN0UmF0aW9cIiksYm49ZnVuY3Rpb24oKXt9O2JuLl9kZWZhdWx0cz17fTt2YXIgeG49Ym47ZnVuY3Rpb24gd24odCxlLG4pe3JldHVybiB3LmZ1bmModCk/Ryh0LGUuaW50ZXJhY3RhYmxlLGUuZWxlbWVudCxbbi54LG4ueSxlXSk6Ryh0LGUuaW50ZXJhY3RhYmxlLGUuZWxlbWVudCl9dmFyIEVuPXtzdGFydDpmdW5jdGlvbih0KXt2YXIgZT10LnJlY3Qsbj10LnN0YXJ0T2Zmc2V0LHI9dC5zdGF0ZSxpPXQuaW50ZXJhY3Rpb24sbz10LnBhZ2VDb29yZHMsYT1yLm9wdGlvbnMscz1hLmVsZW1lbnRSZWN0LGM9Vih7bGVmdDowLHRvcDowLHJpZ2h0OjAsYm90dG9tOjB9LGEub2Zmc2V0fHx7fSk7aWYoZSYmcyl7dmFyIGw9d24oYS5yZXN0cmljdGlvbixpLG8pO2lmKGwpe3ZhciB1PWwucmlnaHQtbC5sZWZ0LWUud2lkdGgscD1sLmJvdHRvbS1sLnRvcC1lLmhlaWdodDt1PDAmJihjLmxlZnQrPXUsYy5yaWdodCs9dSkscDwwJiYoYy50b3ArPXAsYy5ib3R0b20rPXApfWMubGVmdCs9bi5sZWZ0LWUud2lkdGgqcy5sZWZ0LGMudG9wKz1uLnRvcC1lLmhlaWdodCpzLnRvcCxjLnJpZ2h0Kz1uLnJpZ2h0LWUud2lkdGgqKDEtcy5yaWdodCksYy5ib3R0b20rPW4uYm90dG9tLWUuaGVpZ2h0KigxLXMuYm90dG9tKX1yLm9mZnNldD1jfSxzZXQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5jb29yZHMsbj10LmludGVyYWN0aW9uLHI9dC5zdGF0ZSxpPXIub3B0aW9ucyxvPXIub2Zmc2V0LGE9d24oaS5yZXN0cmljdGlvbixuLGUpO2lmKGEpe3ZhciBzPWZ1bmN0aW9uKHQpe3JldHVybiF0fHxcImxlZnRcImluIHQmJlwidG9wXCJpbiB0fHwoKHQ9Vih7fSx0KSkubGVmdD10Lnh8fDAsdC50b3A9dC55fHwwLHQucmlnaHQ9dC5yaWdodHx8dC5sZWZ0K3Qud2lkdGgsdC5ib3R0b209dC5ib3R0b218fHQudG9wK3QuaGVpZ2h0KSx0fShhKTtlLng9TWF0aC5tYXgoTWF0aC5taW4ocy5yaWdodC1vLnJpZ2h0LGUueCkscy5sZWZ0K28ubGVmdCksZS55PU1hdGgubWF4KE1hdGgubWluKHMuYm90dG9tLW8uYm90dG9tLGUueSkscy50b3Arby50b3ApfX0sZGVmYXVsdHM6e3Jlc3RyaWN0aW9uOm51bGwsZWxlbWVudFJlY3Q6bnVsbCxvZmZzZXQ6bnVsbCxlbmRPbmx5OiExLGVuYWJsZWQ6ITF9fSxUbj1iZShFbixcInJlc3RyaWN0XCIpLFNuPXt0b3A6MS8wLGxlZnQ6MS8wLGJvdHRvbTotMS8wLHJpZ2h0Oi0xLzB9LF9uPXt0b3A6LTEvMCxsZWZ0Oi0xLzAsYm90dG9tOjEvMCxyaWdodDoxLzB9O2Z1bmN0aW9uIFBuKHQsZSl7Zm9yKHZhciBuPTAscj1bXCJ0b3BcIixcImxlZnRcIixcImJvdHRvbVwiLFwicmlnaHRcIl07bjxyLmxlbmd0aDtuKyspe3ZhciBpPXJbbl07aSBpbiB0fHwodFtpXT1lW2ldKX1yZXR1cm4gdH12YXIgT249e25vSW5uZXI6U24sbm9PdXRlcjpfbixzdGFydDpmdW5jdGlvbih0KXt2YXIgZSxuPXQuaW50ZXJhY3Rpb24scj10LnN0YXJ0T2Zmc2V0LGk9dC5zdGF0ZSxvPWkub3B0aW9ucztvJiYoZT1OKHduKG8ub2Zmc2V0LG4sbi5jb29yZHMuc3RhcnQucGFnZSkpKSxlPWV8fHt4OjAseTowfSxpLm9mZnNldD17dG9wOmUueStyLnRvcCxsZWZ0OmUueCtyLmxlZnQsYm90dG9tOmUueS1yLmJvdHRvbSxyaWdodDplLngtci5yaWdodH19LHNldDpmdW5jdGlvbih0KXt2YXIgZT10LmNvb3JkcyxuPXQuZWRnZXMscj10LmludGVyYWN0aW9uLGk9dC5zdGF0ZSxvPWkub2Zmc2V0LGE9aS5vcHRpb25zO2lmKG4pe3ZhciBzPVYoe30sZSksYz13bihhLmlubmVyLHIscyl8fHt9LGw9d24oYS5vdXRlcixyLHMpfHx7fTtQbihjLFNuKSxQbihsLF9uKSxuLnRvcD9lLnk9TWF0aC5taW4oTWF0aC5tYXgobC50b3Arby50b3Ascy55KSxjLnRvcCtvLnRvcCk6bi5ib3R0b20mJihlLnk9TWF0aC5tYXgoTWF0aC5taW4obC5ib3R0b20rby5ib3R0b20scy55KSxjLmJvdHRvbStvLmJvdHRvbSkpLG4ubGVmdD9lLng9TWF0aC5taW4oTWF0aC5tYXgobC5sZWZ0K28ubGVmdCxzLngpLGMubGVmdCtvLmxlZnQpOm4ucmlnaHQmJihlLng9TWF0aC5tYXgoTWF0aC5taW4obC5yaWdodCtvLnJpZ2h0LHMueCksYy5yaWdodCtvLnJpZ2h0KSl9fSxkZWZhdWx0czp7aW5uZXI6bnVsbCxvdXRlcjpudWxsLG9mZnNldDpudWxsLGVuZE9ubHk6ITEsZW5hYmxlZDohMX19LGtuPWJlKE9uLFwicmVzdHJpY3RFZGdlc1wiKSxEbj1WKHtnZXQgZWxlbWVudFJlY3QoKXtyZXR1cm57dG9wOjAsbGVmdDowLGJvdHRvbToxLHJpZ2h0OjF9fSxzZXQgZWxlbWVudFJlY3QodCl7fX0sRW4uZGVmYXVsdHMpLEluPWJlKHtzdGFydDpFbi5zdGFydCxzZXQ6RW4uc2V0LGRlZmF1bHRzOkRufSxcInJlc3RyaWN0UmVjdFwiKSxNbj17d2lkdGg6LTEvMCxoZWlnaHQ6LTEvMH0sem49e3dpZHRoOjEvMCxoZWlnaHQ6MS8wfTt2YXIgQW49YmUoe3N0YXJ0OmZ1bmN0aW9uKHQpe3JldHVybiBPbi5zdGFydCh0KX0sc2V0OmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj10LnN0YXRlLHI9dC5yZWN0LGk9dC5lZGdlcyxvPW4ub3B0aW9ucztpZihpKXt2YXIgYT1VKHduKG8ubWluLGUsdC5jb29yZHMpKXx8TW4scz1VKHduKG8ubWF4LGUsdC5jb29yZHMpKXx8em47bi5vcHRpb25zPXtlbmRPbmx5Om8uZW5kT25seSxpbm5lcjpWKHt9LE9uLm5vSW5uZXIpLG91dGVyOlYoe30sT24ubm9PdXRlcil9LGkudG9wPyhuLm9wdGlvbnMuaW5uZXIudG9wPXIuYm90dG9tLWEuaGVpZ2h0LG4ub3B0aW9ucy5vdXRlci50b3A9ci5ib3R0b20tcy5oZWlnaHQpOmkuYm90dG9tJiYobi5vcHRpb25zLmlubmVyLmJvdHRvbT1yLnRvcCthLmhlaWdodCxuLm9wdGlvbnMub3V0ZXIuYm90dG9tPXIudG9wK3MuaGVpZ2h0KSxpLmxlZnQ/KG4ub3B0aW9ucy5pbm5lci5sZWZ0PXIucmlnaHQtYS53aWR0aCxuLm9wdGlvbnMub3V0ZXIubGVmdD1yLnJpZ2h0LXMud2lkdGgpOmkucmlnaHQmJihuLm9wdGlvbnMuaW5uZXIucmlnaHQ9ci5sZWZ0K2Eud2lkdGgsbi5vcHRpb25zLm91dGVyLnJpZ2h0PXIubGVmdCtzLndpZHRoKSxPbi5zZXQodCksbi5vcHRpb25zPW99fSxkZWZhdWx0czp7bWluOm51bGwsbWF4Om51bGwsZW5kT25seTohMSxlbmFibGVkOiExfX0sXCJyZXN0cmljdFNpemVcIik7dmFyIFJuPXtzdGFydDpmdW5jdGlvbih0KXt2YXIgZSxuPXQuaW50ZXJhY3Rpb24scj10LmludGVyYWN0YWJsZSxpPXQuZWxlbWVudCxvPXQucmVjdCxhPXQuc3RhdGUscz10LnN0YXJ0T2Zmc2V0LGM9YS5vcHRpb25zLGw9Yy5vZmZzZXRXaXRoT3JpZ2luP2Z1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24uZWxlbWVudCxuPU4oRyh0LnN0YXRlLm9wdGlvbnMub3JpZ2luLG51bGwsbnVsbCxbZV0pKSxyPW58fEsodC5pbnRlcmFjdGFibGUsZSx0LmludGVyYWN0aW9uLnByZXBhcmVkLm5hbWUpO3JldHVybiByfSh0KTp7eDowLHk6MH07aWYoXCJzdGFydENvb3Jkc1wiPT09Yy5vZmZzZXQpZT17eDpuLmNvb3Jkcy5zdGFydC5wYWdlLngseTpuLmNvb3Jkcy5zdGFydC5wYWdlLnl9O2Vsc2V7dmFyIHU9RyhjLm9mZnNldCxyLGksW25dKTsoZT1OKHUpfHx7eDowLHk6MH0pLngrPWwueCxlLnkrPWwueX12YXIgcD1jLnJlbGF0aXZlUG9pbnRzO2Eub2Zmc2V0cz1vJiZwJiZwLmxlbmd0aD9wLm1hcCgoZnVuY3Rpb24odCxuKXtyZXR1cm57aW5kZXg6bixyZWxhdGl2ZVBvaW50OnQseDpzLmxlZnQtby53aWR0aCp0LngrZS54LHk6cy50b3Atby5oZWlnaHQqdC55K2UueX19KSk6W3tpbmRleDowLHJlbGF0aXZlUG9pbnQ6bnVsbCx4OmUueCx5OmUueX1dfSxzZXQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbnRlcmFjdGlvbixuPXQuY29vcmRzLHI9dC5zdGF0ZSxpPXIub3B0aW9ucyxvPXIub2Zmc2V0cyxhPUsoZS5pbnRlcmFjdGFibGUsZS5lbGVtZW50LGUucHJlcGFyZWQubmFtZSkscz1WKHt9LG4pLGM9W107aS5vZmZzZXRXaXRoT3JpZ2lufHwocy54LT1hLngscy55LT1hLnkpO2Zvcih2YXIgbD0wLHU9bztsPHUubGVuZ3RoO2wrKylmb3IodmFyIHA9dVtsXSxmPXMueC1wLngsZD1zLnktcC55LGg9MCx2PWkudGFyZ2V0cy5sZW5ndGg7aDx2O2grKyl7dmFyIGc9aS50YXJnZXRzW2hdLG09dm9pZCAwOyhtPXcuZnVuYyhnKT9nKGYsZCxlLl9wcm94eSxwLGgpOmcpJiZjLnB1c2goe3g6KHcubnVtYmVyKG0ueCk/bS54OmYpK3AueCx5Oih3Lm51bWJlcihtLnkpP20ueTpkKStwLnkscmFuZ2U6dy5udW1iZXIobS5yYW5nZSk/bS5yYW5nZTppLnJhbmdlLHNvdXJjZTpnLGluZGV4Omgsb2Zmc2V0OnB9KX1mb3IodmFyIHk9e3RhcmdldDpudWxsLGluUmFuZ2U6ITEsZGlzdGFuY2U6MCxyYW5nZTowLGRlbHRhOnt4OjAseTowfX0sYj0wO2I8Yy5sZW5ndGg7YisrKXt2YXIgeD1jW2JdLEU9eC5yYW5nZSxUPXgueC1zLngsUz14Lnktcy55LF89UShULFMpLFA9Xzw9RTtFPT09MS8wJiZ5LmluUmFuZ2UmJnkucmFuZ2UhPT0xLzAmJihQPSExKSx5LnRhcmdldCYmIShQP3kuaW5SYW5nZSYmRSE9PTEvMD9fL0U8eS5kaXN0YW5jZS95LnJhbmdlOkU9PT0xLzAmJnkucmFuZ2UhPT0xLzB8fF88eS5kaXN0YW5jZToheS5pblJhbmdlJiZfPHkuZGlzdGFuY2UpfHwoeS50YXJnZXQ9eCx5LmRpc3RhbmNlPV8seS5yYW5nZT1FLHkuaW5SYW5nZT1QLHkuZGVsdGEueD1ULHkuZGVsdGEueT1TKX1yZXR1cm4geS5pblJhbmdlJiYobi54PXkudGFyZ2V0Lngsbi55PXkudGFyZ2V0LnkpLHIuY2xvc2VzdD15LHl9LGRlZmF1bHRzOntyYW5nZToxLzAsdGFyZ2V0czpudWxsLG9mZnNldDpudWxsLG9mZnNldFdpdGhPcmlnaW46ITAsb3JpZ2luOm51bGwscmVsYXRpdmVQb2ludHM6bnVsbCxlbmRPbmx5OiExLGVuYWJsZWQ6ITF9fSxDbj1iZShSbixcInNuYXBcIik7dmFyIGpuPXtzdGFydDpmdW5jdGlvbih0KXt2YXIgZT10LnN0YXRlLG49dC5lZGdlcyxyPWUub3B0aW9ucztpZighbilyZXR1cm4gbnVsbDt0LnN0YXRlPXtvcHRpb25zOnt0YXJnZXRzOm51bGwscmVsYXRpdmVQb2ludHM6W3t4Om4ubGVmdD8wOjEseTpuLnRvcD8wOjF9XSxvZmZzZXQ6ci5vZmZzZXR8fFwic2VsZlwiLG9yaWdpbjp7eDowLHk6MH0scmFuZ2U6ci5yYW5nZX19LGUudGFyZ2V0RmllbGRzPWUudGFyZ2V0RmllbGRzfHxbW1wid2lkdGhcIixcImhlaWdodFwiXSxbXCJ4XCIsXCJ5XCJdXSxSbi5zdGFydCh0KSxlLm9mZnNldHM9dC5zdGF0ZS5vZmZzZXRzLHQuc3RhdGU9ZX0sc2V0OmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj10LnN0YXRlLHI9dC5jb29yZHMsaT1uLm9wdGlvbnMsbz1uLm9mZnNldHMsYT17eDpyLngtb1swXS54LHk6ci55LW9bMF0ueX07bi5vcHRpb25zPVYoe30saSksbi5vcHRpb25zLnRhcmdldHM9W107Zm9yKHZhciBzPTAsYz1pLnRhcmdldHN8fFtdO3M8Yy5sZW5ndGg7cysrKXt2YXIgbD1jW3NdLHU9dm9pZCAwO2lmKHU9dy5mdW5jKGwpP2woYS54LGEueSxlKTpsKXtmb3IodmFyIHA9MCxmPW4udGFyZ2V0RmllbGRzO3A8Zi5sZW5ndGg7cCsrKXt2YXIgZD1mW3BdLGg9ZFswXSx2PWRbMV07aWYoaCBpbiB1fHx2IGluIHUpe3UueD11W2hdLHUueT11W3ZdO2JyZWFrfX1uLm9wdGlvbnMudGFyZ2V0cy5wdXNoKHUpfX12YXIgZz1Sbi5zZXQodCk7cmV0dXJuIG4ub3B0aW9ucz1pLGd9LGRlZmF1bHRzOntyYW5nZToxLzAsdGFyZ2V0czpudWxsLG9mZnNldDpudWxsLGVuZE9ubHk6ITEsZW5hYmxlZDohMX19LEZuPWJlKGpuLFwic25hcFNpemVcIik7dmFyIFhuPXthc3BlY3RSYXRpbzp5bixyZXN0cmljdEVkZ2VzOmtuLHJlc3RyaWN0OlRuLHJlc3RyaWN0UmVjdDpJbixyZXN0cmljdFNpemU6QW4sc25hcEVkZ2VzOmJlKHtzdGFydDpmdW5jdGlvbih0KXt2YXIgZT10LmVkZ2VzO3JldHVybiBlPyh0LnN0YXRlLnRhcmdldEZpZWxkcz10LnN0YXRlLnRhcmdldEZpZWxkc3x8W1tlLmxlZnQ/XCJsZWZ0XCI6XCJyaWdodFwiLGUudG9wP1widG9wXCI6XCJib3R0b21cIl1dLGpuLnN0YXJ0KHQpKTpudWxsfSxzZXQ6am4uc2V0LGRlZmF1bHRzOlYoZ2Uoam4uZGVmYXVsdHMpLHt0YXJnZXRzOnZvaWQgMCxyYW5nZTp2b2lkIDAsb2Zmc2V0Ont4OjAseTowfX0pfSxcInNuYXBFZGdlc1wiKSxzbmFwOkNuLHNuYXBTaXplOkZuLHNwcmluZzp4bixhdm9pZDp4bix0cmFuc2Zvcm06eG4scnViYmVyYmFuZDp4bn0sWW49e2lkOlwibW9kaWZpZXJzXCIsaW5zdGFsbDpmdW5jdGlvbih0KXt2YXIgZT10LmludGVyYWN0U3RhdGljO2Zvcih2YXIgbiBpbiB0LnVzZVBsdWdpbihFZSksdC51c2VQbHVnaW4oaG4pLGUubW9kaWZpZXJzPVhuLFhuKXt2YXIgcj1YbltuXSxpPXIuX2RlZmF1bHRzLG89ci5fbWV0aG9kcztpLl9tZXRob2RzPW8sdC5kZWZhdWx0cy5wZXJBY3Rpb25bbl09aX19fSxMbj1Zbixxbj1mdW5jdGlvbih0KXtzKG4sdCk7dmFyIGU9cChuKTtmdW5jdGlvbiBuKHQsaSxvLGEscyxjKXt2YXIgbDtpZihyKHRoaXMsbiksdHQodShsPWUuY2FsbCh0aGlzLHMpKSxvKSxvIT09aSYmdHQodShsKSxpKSxsLnRpbWVTdGFtcD1jLGwub3JpZ2luYWxFdmVudD1vLGwudHlwZT10LGwucG9pbnRlcklkPWF0KGkpLGwucG9pbnRlclR5cGU9ZHQoaSksbC50YXJnZXQ9YSxsLmN1cnJlbnRUYXJnZXQ9bnVsbCxcInRhcFwiPT09dCl7dmFyIHA9cy5nZXRQb2ludGVySW5kZXgoaSk7bC5kdD1sLnRpbWVTdGFtcC1zLnBvaW50ZXJzW3BdLmRvd25UaW1lO3ZhciBmPWwudGltZVN0YW1wLXMudGFwVGltZTtsLmRvdWJsZT0hIXMucHJldlRhcCYmXCJkb3VibGV0YXBcIiE9PXMucHJldlRhcC50eXBlJiZzLnByZXZUYXAudGFyZ2V0PT09bC50YXJnZXQmJmY8NTAwfWVsc2VcImRvdWJsZXRhcFwiPT09dCYmKGwuZHQ9aS50aW1lU3RhbXAtcy50YXBUaW1lLGwuZG91YmxlPSEwKTtyZXR1cm4gbH1yZXR1cm4gbyhuLFt7a2V5OlwiX3N1YnRyYWN0T3JpZ2luXCIsdmFsdWU6ZnVuY3Rpb24odCl7dmFyIGU9dC54LG49dC55O3JldHVybiB0aGlzLnBhZ2VYLT1lLHRoaXMucGFnZVktPW4sdGhpcy5jbGllbnRYLT1lLHRoaXMuY2xpZW50WS09bix0aGlzfX0se2tleTpcIl9hZGRPcmlnaW5cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZT10Lngsbj10Lnk7cmV0dXJuIHRoaXMucGFnZVgrPWUsdGhpcy5wYWdlWSs9bix0aGlzLmNsaWVudFgrPWUsdGhpcy5jbGllbnRZKz1uLHRoaXN9fSx7a2V5OlwicHJldmVudERlZmF1bHRcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMub3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpfX1dKSxufSh2dCksQm49e2lkOlwicG9pbnRlci1ldmVudHMvYmFzZVwiLGJlZm9yZTpbXCJpbmVydGlhXCIsXCJtb2RpZmllcnNcIixcImF1dG8tc3RhcnRcIixcImFjdGlvbnNcIl0saW5zdGFsbDpmdW5jdGlvbih0KXt0LnBvaW50ZXJFdmVudHM9Qm4sdC5kZWZhdWx0cy5hY3Rpb25zLnBvaW50ZXJFdmVudHM9Qm4uZGVmYXVsdHMsVih0LmFjdGlvbnMucGhhc2VsZXNzVHlwZXMsQm4udHlwZXMpfSxsaXN0ZW5lcnM6e1wiaW50ZXJhY3Rpb25zOm5ld1wiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb247ZS5wcmV2VGFwPW51bGwsZS50YXBUaW1lPTB9LFwiaW50ZXJhY3Rpb25zOnVwZGF0ZS1wb2ludGVyXCI6ZnVuY3Rpb24odCl7dmFyIGU9dC5kb3duLG49dC5wb2ludGVySW5mbztpZighZSYmbi5ob2xkKXJldHVybjtuLmhvbGQ9e2R1cmF0aW9uOjEvMCx0aW1lb3V0Om51bGx9fSxcImludGVyYWN0aW9uczptb3ZlXCI6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmludGVyYWN0aW9uLHI9dC5wb2ludGVyLGk9dC5ldmVudCxvPXQuZXZlbnRUYXJnZXQ7dC5kdXBsaWNhdGV8fG4ucG9pbnRlcklzRG93biYmIW4ucG9pbnRlcldhc01vdmVkfHwobi5wb2ludGVySXNEb3duJiZHbih0KSxWbih7aW50ZXJhY3Rpb246bixwb2ludGVyOnIsZXZlbnQ6aSxldmVudFRhcmdldDpvLHR5cGU6XCJtb3ZlXCJ9LGUpKX0sXCJpbnRlcmFjdGlvbnM6ZG93blwiOmZ1bmN0aW9uKHQsZSl7IWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuaW50ZXJhY3Rpb24scj10LnBvaW50ZXIsaT10LmV2ZW50LG89dC5ldmVudFRhcmdldCxhPXQucG9pbnRlckluZGV4LHM9bi5wb2ludGVyc1thXS5ob2xkLGM9cShvKSxsPXtpbnRlcmFjdGlvbjpuLHBvaW50ZXI6cixldmVudDppLGV2ZW50VGFyZ2V0Om8sdHlwZTpcImhvbGRcIix0YXJnZXRzOltdLHBhdGg6Yyxub2RlOm51bGx9LHU9MDt1PGMubGVuZ3RoO3UrKyl7dmFyIHA9Y1t1XTtsLm5vZGU9cCxlLmZpcmUoXCJwb2ludGVyRXZlbnRzOmNvbGxlY3QtdGFyZ2V0c1wiLGwpfWlmKCFsLnRhcmdldHMubGVuZ3RoKXJldHVybjtmb3IodmFyIGY9MS8wLGQ9MCxoPWwudGFyZ2V0cztkPGgubGVuZ3RoO2QrKyl7dmFyIHY9aFtkXS5ldmVudGFibGUub3B0aW9ucy5ob2xkRHVyYXRpb247djxmJiYoZj12KX1zLmR1cmF0aW9uPWYscy50aW1lb3V0PXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7Vm4oe2ludGVyYWN0aW9uOm4sZXZlbnRUYXJnZXQ6byxwb2ludGVyOnIsZXZlbnQ6aSx0eXBlOlwiaG9sZFwifSxlKX0pLGYpfSh0LGUpLFZuKHQsZSl9LFwiaW50ZXJhY3Rpb25zOnVwXCI6ZnVuY3Rpb24odCxlKXtHbih0KSxWbih0LGUpLGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5pbnRlcmFjdGlvbixyPXQucG9pbnRlcixpPXQuZXZlbnQsbz10LmV2ZW50VGFyZ2V0O24ucG9pbnRlcldhc01vdmVkfHxWbih7aW50ZXJhY3Rpb246bixldmVudFRhcmdldDpvLHBvaW50ZXI6cixldmVudDppLHR5cGU6XCJ0YXBcIn0sZSl9KHQsZSl9LFwiaW50ZXJhY3Rpb25zOmNhbmNlbFwiOmZ1bmN0aW9uKHQsZSl7R24odCksVm4odCxlKX19LFBvaW50ZXJFdmVudDpxbixmaXJlOlZuLGNvbGxlY3RFdmVudFRhcmdldHM6V24sZGVmYXVsdHM6e2hvbGREdXJhdGlvbjo2MDAsaWdub3JlRnJvbTpudWxsLGFsbG93RnJvbTpudWxsLG9yaWdpbjp7eDowLHk6MH19LHR5cGVzOntkb3duOiEwLG1vdmU6ITAsdXA6ITAsY2FuY2VsOiEwLHRhcDohMCxkb3VibGV0YXA6ITAsaG9sZDohMH19O2Z1bmN0aW9uIFZuKHQsZSl7dmFyIG49dC5pbnRlcmFjdGlvbixyPXQucG9pbnRlcixpPXQuZXZlbnQsbz10LmV2ZW50VGFyZ2V0LGE9dC50eXBlLHM9dC50YXJnZXRzLGM9dm9pZCAwPT09cz9Xbih0LGUpOnMsbD1uZXcgcW4oYSxyLGksbyxuLGUubm93KCkpO2UuZmlyZShcInBvaW50ZXJFdmVudHM6bmV3XCIse3BvaW50ZXJFdmVudDpsfSk7Zm9yKHZhciB1PXtpbnRlcmFjdGlvbjpuLHBvaW50ZXI6cixldmVudDppLGV2ZW50VGFyZ2V0Om8sdGFyZ2V0czpjLHR5cGU6YSxwb2ludGVyRXZlbnQ6bH0scD0wO3A8Yy5sZW5ndGg7cCsrKXt2YXIgZj1jW3BdO2Zvcih2YXIgZCBpbiBmLnByb3BzfHx7fSlsW2RdPWYucHJvcHNbZF07dmFyIGg9SyhmLmV2ZW50YWJsZSxmLm5vZGUpO2lmKGwuX3N1YnRyYWN0T3JpZ2luKGgpLGwuZXZlbnRhYmxlPWYuZXZlbnRhYmxlLGwuY3VycmVudFRhcmdldD1mLm5vZGUsZi5ldmVudGFibGUuZmlyZShsKSxsLl9hZGRPcmlnaW4oaCksbC5pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWR8fGwucHJvcGFnYXRpb25TdG9wcGVkJiZwKzE8Yy5sZW5ndGgmJmNbcCsxXS5ub2RlIT09bC5jdXJyZW50VGFyZ2V0KWJyZWFrfWlmKGUuZmlyZShcInBvaW50ZXJFdmVudHM6ZmlyZWRcIix1KSxcInRhcFwiPT09YSl7dmFyIHY9bC5kb3VibGU/Vm4oe2ludGVyYWN0aW9uOm4scG9pbnRlcjpyLGV2ZW50OmksZXZlbnRUYXJnZXQ6byx0eXBlOlwiZG91YmxldGFwXCJ9LGUpOmw7bi5wcmV2VGFwPXYsbi50YXBUaW1lPXYudGltZVN0YW1wfXJldHVybiBsfWZ1bmN0aW9uIFduKHQsZSl7dmFyIG49dC5pbnRlcmFjdGlvbixyPXQucG9pbnRlcixpPXQuZXZlbnQsbz10LmV2ZW50VGFyZ2V0LGE9dC50eXBlLHM9bi5nZXRQb2ludGVySW5kZXgociksYz1uLnBvaW50ZXJzW3NdO2lmKFwidGFwXCI9PT1hJiYobi5wb2ludGVyV2FzTW92ZWR8fCFjfHxjLmRvd25UYXJnZXQhPT1vKSlyZXR1cm5bXTtmb3IodmFyIGw9cShvKSx1PXtpbnRlcmFjdGlvbjpuLHBvaW50ZXI6cixldmVudDppLGV2ZW50VGFyZ2V0Om8sdHlwZTphLHBhdGg6bCx0YXJnZXRzOltdLG5vZGU6bnVsbH0scD0wO3A8bC5sZW5ndGg7cCsrKXt2YXIgZj1sW3BdO3Uubm9kZT1mLGUuZmlyZShcInBvaW50ZXJFdmVudHM6Y29sbGVjdC10YXJnZXRzXCIsdSl9cmV0dXJuXCJob2xkXCI9PT1hJiYodS50YXJnZXRzPXUudGFyZ2V0cy5maWx0ZXIoKGZ1bmN0aW9uKHQpe3ZhciBlLHI7cmV0dXJuIHQuZXZlbnRhYmxlLm9wdGlvbnMuaG9sZER1cmF0aW9uPT09KG51bGw9PShlPW4ucG9pbnRlcnNbc10pfHxudWxsPT0ocj1lLmhvbGQpP3ZvaWQgMDpyLmR1cmF0aW9uKX0pKSksdS50YXJnZXRzfWZ1bmN0aW9uIEduKHQpe3ZhciBlPXQuaW50ZXJhY3Rpb24sbj10LnBvaW50ZXJJbmRleCxyPWUucG9pbnRlcnNbbl0uaG9sZDtyJiZyLnRpbWVvdXQmJihjbGVhclRpbWVvdXQoci50aW1lb3V0KSxyLnRpbWVvdXQ9bnVsbCl9dmFyIE5uPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGRlZmF1bHQ6Qm59KTtmdW5jdGlvbiBVbih0KXt2YXIgZT10LmludGVyYWN0aW9uO2UuaG9sZEludGVydmFsSGFuZGxlJiYoY2xlYXJJbnRlcnZhbChlLmhvbGRJbnRlcnZhbEhhbmRsZSksZS5ob2xkSW50ZXJ2YWxIYW5kbGU9bnVsbCl9dmFyIEhuPXtpZDpcInBvaW50ZXItZXZlbnRzL2hvbGRSZXBlYXRcIixpbnN0YWxsOmZ1bmN0aW9uKHQpe3QudXNlUGx1Z2luKEJuKTt2YXIgZT10LnBvaW50ZXJFdmVudHM7ZS5kZWZhdWx0cy5ob2xkUmVwZWF0SW50ZXJ2YWw9MCxlLnR5cGVzLmhvbGRyZXBlYXQ9dC5hY3Rpb25zLnBoYXNlbGVzc1R5cGVzLmhvbGRyZXBlYXQ9ITB9LGxpc3RlbmVyczpbXCJtb3ZlXCIsXCJ1cFwiLFwiY2FuY2VsXCIsXCJlbmRhbGxcIl0ucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0W1wicG9pbnRlckV2ZW50czpcIi5jb25jYXQoZSldPVVuLHR9KSx7XCJwb2ludGVyRXZlbnRzOm5ld1wiOmZ1bmN0aW9uKHQpe3ZhciBlPXQucG9pbnRlckV2ZW50O1wiaG9sZFwiPT09ZS50eXBlJiYoZS5jb3VudD0oZS5jb3VudHx8MCkrMSl9LFwicG9pbnRlckV2ZW50czpmaXJlZFwiOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5pbnRlcmFjdGlvbixyPXQucG9pbnRlckV2ZW50LGk9dC5ldmVudFRhcmdldCxvPXQudGFyZ2V0cztpZihcImhvbGRcIj09PXIudHlwZSYmby5sZW5ndGgpe3ZhciBhPW9bMF0uZXZlbnRhYmxlLm9wdGlvbnMuaG9sZFJlcGVhdEludGVydmFsO2E8PTB8fChuLmhvbGRJbnRlcnZhbEhhbmRsZT1zZXRUaW1lb3V0KChmdW5jdGlvbigpe2UucG9pbnRlckV2ZW50cy5maXJlKHtpbnRlcmFjdGlvbjpuLGV2ZW50VGFyZ2V0OmksdHlwZTpcImhvbGRcIixwb2ludGVyOnIsZXZlbnQ6cn0sZSl9KSxhKSl9fX0pfSxLbj1Ibjt2YXIgJG49e2lkOlwicG9pbnRlci1ldmVudHMvaW50ZXJhY3RhYmxlVGFyZ2V0c1wiLGluc3RhbGw6ZnVuY3Rpb24odCl7dmFyIGU9dC5JbnRlcmFjdGFibGU7ZS5wcm90b3R5cGUucG9pbnRlckV2ZW50cz1mdW5jdGlvbih0KXtyZXR1cm4gVih0aGlzLmV2ZW50cy5vcHRpb25zLHQpLHRoaXN9O3ZhciBuPWUucHJvdG90eXBlLl9iYWNrQ29tcGF0T3B0aW9uO2UucHJvdG90eXBlLl9iYWNrQ29tcGF0T3B0aW9uPWZ1bmN0aW9uKHQsZSl7dmFyIHI9bi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gcj09PXRoaXMmJih0aGlzLmV2ZW50cy5vcHRpb25zW3RdPWUpLHJ9fSxsaXN0ZW5lcnM6e1wicG9pbnRlckV2ZW50czpjb2xsZWN0LXRhcmdldHNcIjpmdW5jdGlvbih0LGUpe3ZhciBuPXQudGFyZ2V0cyxyPXQubm9kZSxpPXQudHlwZSxvPXQuZXZlbnRUYXJnZXQ7ZS5pbnRlcmFjdGFibGVzLmZvckVhY2hNYXRjaChyLChmdW5jdGlvbih0KXt2YXIgZT10LmV2ZW50cyxhPWUub3B0aW9ucztlLnR5cGVzW2ldJiZlLnR5cGVzW2ldLmxlbmd0aCYmdC50ZXN0SWdub3JlQWxsb3coYSxyLG8pJiZuLnB1c2goe25vZGU6cixldmVudGFibGU6ZSxwcm9wczp7aW50ZXJhY3RhYmxlOnR9fSl9KSl9LFwiaW50ZXJhY3RhYmxlOm5ld1wiOmZ1bmN0aW9uKHQpe3ZhciBlPXQuaW50ZXJhY3RhYmxlO2UuZXZlbnRzLmdldFJlY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIGUuZ2V0UmVjdCh0KX19LFwiaW50ZXJhY3RhYmxlOnNldFwiOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5pbnRlcmFjdGFibGUscj10Lm9wdGlvbnM7VihuLmV2ZW50cy5vcHRpb25zLGUucG9pbnRlckV2ZW50cy5kZWZhdWx0cyksVihuLmV2ZW50cy5vcHRpb25zLHIucG9pbnRlckV2ZW50c3x8e30pfX19LEpuPSRuLFFuPXtpZDpcInBvaW50ZXItZXZlbnRzXCIsaW5zdGFsbDpmdW5jdGlvbih0KXt0LnVzZVBsdWdpbihObiksdC51c2VQbHVnaW4oS24pLHQudXNlUGx1Z2luKEpuKX19LFpuPVFuO3ZhciB0cj17aWQ6XCJyZWZsb3dcIixpbnN0YWxsOmZ1bmN0aW9uKHQpe3ZhciBlPXQuSW50ZXJhY3RhYmxlO3QuYWN0aW9ucy5waGFzZXMucmVmbG93PSEwLGUucHJvdG90eXBlLnJlZmxvdz1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgcj10LmdldEFsbEVsZW1lbnRzKCksaT1uLndpbmRvdy5Qcm9taXNlLG89aT9bXTpudWxsLGE9ZnVuY3Rpb24oKXt2YXIgYT1yW3NdLGM9dC5nZXRSZWN0KGEpO2lmKCFjKXJldHVybiAxO3ZhciBsLHU9YnQobi5pbnRlcmFjdGlvbnMubGlzdCwoZnVuY3Rpb24obil7cmV0dXJuIG4uaW50ZXJhY3RpbmcoKSYmbi5pbnRlcmFjdGFibGU9PT10JiZuLmVsZW1lbnQ9PT1hJiZuLnByZXBhcmVkLm5hbWU9PT1lLm5hbWV9KSk7aWYodSl1Lm1vdmUoKSxvJiYobD11Ll9yZWZsb3dQcm9taXNlfHxuZXcgaSgoZnVuY3Rpb24odCl7dS5fcmVmbG93UmVzb2x2ZT10fSkpKTtlbHNle3ZhciBwPVUoYyksZj1mdW5jdGlvbih0KXtyZXR1cm57Y29vcmRzOnQsZ2V0IHBhZ2UoKXtyZXR1cm4gdGhpcy5jb29yZHMucGFnZX0sZ2V0IGNsaWVudCgpe3JldHVybiB0aGlzLmNvb3Jkcy5jbGllbnR9LGdldCB0aW1lU3RhbXAoKXtyZXR1cm4gdGhpcy5jb29yZHMudGltZVN0YW1wfSxnZXQgcGFnZVgoKXtyZXR1cm4gdGhpcy5jb29yZHMucGFnZS54fSxnZXQgcGFnZVkoKXtyZXR1cm4gdGhpcy5jb29yZHMucGFnZS55fSxnZXQgY2xpZW50WCgpe3JldHVybiB0aGlzLmNvb3Jkcy5jbGllbnQueH0sZ2V0IGNsaWVudFkoKXtyZXR1cm4gdGhpcy5jb29yZHMuY2xpZW50Lnl9LGdldCBwb2ludGVySWQoKXtyZXR1cm4gdGhpcy5jb29yZHMucG9pbnRlcklkfSxnZXQgdGFyZ2V0KCl7cmV0dXJuIHRoaXMuY29vcmRzLnRhcmdldH0sZ2V0IHR5cGUoKXtyZXR1cm4gdGhpcy5jb29yZHMudHlwZX0sZ2V0IHBvaW50ZXJUeXBlKCl7cmV0dXJuIHRoaXMuY29vcmRzLnBvaW50ZXJUeXBlfSxnZXQgYnV0dG9ucygpe3JldHVybiB0aGlzLmNvb3Jkcy5idXR0b25zfSxwcmV2ZW50RGVmYXVsdDpmdW5jdGlvbigpe319fSh7cGFnZTp7eDpwLngseTpwLnl9LGNsaWVudDp7eDpwLngseTpwLnl9LHRpbWVTdGFtcDpuLm5vdygpfSk7bD1mdW5jdGlvbih0LGUsbixyLGkpe3ZhciBvPXQuaW50ZXJhY3Rpb25zLm5ldyh7cG9pbnRlclR5cGU6XCJyZWZsb3dcIn0pLGE9e2ludGVyYWN0aW9uOm8sZXZlbnQ6aSxwb2ludGVyOmksZXZlbnRUYXJnZXQ6bixwaGFzZTpcInJlZmxvd1wifTtvLmludGVyYWN0YWJsZT1lLG8uZWxlbWVudD1uLG8ucHJldkV2ZW50PWksby51cGRhdGVQb2ludGVyKGksaSxuLCEwKSxudChvLmNvb3Jkcy5kZWx0YSksVXQoby5wcmVwYXJlZCxyKSxvLl9kb1BoYXNlKGEpO3ZhciBzPXQud2luZG93LGM9cy5Qcm9taXNlLGw9Yz9uZXcgYygoZnVuY3Rpb24odCl7by5fcmVmbG93UmVzb2x2ZT10fSkpOnZvaWQgMDtvLl9yZWZsb3dQcm9taXNlPWwsby5zdGFydChyLGUsbiksby5faW50ZXJhY3Rpbmc/KG8ubW92ZShhKSxvLmVuZChpKSk6KG8uc3RvcCgpLG8uX3JlZmxvd1Jlc29sdmUoKSk7cmV0dXJuIG8ucmVtb3ZlUG9pbnRlcihpLGkpLGx9KG4sdCxhLGUsZil9byYmby5wdXNoKGwpfSxzPTA7czxyLmxlbmd0aCYmIWEoKTtzKyspO3JldHVybiBvJiZpLmFsbChvKS50aGVuKChmdW5jdGlvbigpe3JldHVybiB0fSkpfSh0aGlzLGUsdCl9fSxsaXN0ZW5lcnM6e1wiaW50ZXJhY3Rpb25zOnN0b3BcIjpmdW5jdGlvbih0LGUpe3ZhciBuPXQuaW50ZXJhY3Rpb247XCJyZWZsb3dcIj09PW4ucG9pbnRlclR5cGUmJihuLl9yZWZsb3dSZXNvbHZlJiZuLl9yZWZsb3dSZXNvbHZlKCksZnVuY3Rpb24odCxlKXt0LnNwbGljZSh0LmluZGV4T2YoZSksMSl9KGUuaW50ZXJhY3Rpb25zLmxpc3QsbikpfX19LGVyPXRyO2lmKHVuLnVzZShoZSksdW4udXNlKENlKSx1bi51c2UoWm4pLHVuLnVzZShxZSksdW4udXNlKExuKSx1bi51c2UocGUpLHVuLnVzZShYdCksdW4udXNlKEd0KSx1bi51c2UoZXIpLHVuLmRlZmF1bHQ9dW4sXCJvYmplY3RcIj09PShcInVuZGVmaW5lZFwiPT10eXBlb2YgbW9kdWxlP1widW5kZWZpbmVkXCI6bihtb2R1bGUpKSYmbW9kdWxlKXRyeXttb2R1bGUuZXhwb3J0cz11bn1jYXRjaCh0KXt9cmV0dXJuIHVuLmRlZmF1bHQ9dW4sdW59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmFjdC5taW4uanMubWFwXG4iLCIvKiFcbiAqIGlzZWN0IHYzLjAuMFxuICogKGMpIDIwMTggQW5kcmVpIEthc2hjaGEuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKGdsb2JhbC5pc2VjdCA9IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qIGZvbGxvd3MgXCJBbiBpbXBsZW1lbnRhdGlvbiBvZiB0b3AtZG93biBzcGxheWluZ1wiXG4gICAqIGJ5IEQuIFNsZWF0b3IgPHNsZWF0b3JAY3MuY211LmVkdT4gTWFyY2ggMTk5MlxuICAgKi9cblxuICAvKipcbiAgICogQHR5cGVkZWYgeyp9IEtleVxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7Kn0gVmFsdWVcbiAgICovXG5cblxuICAvKipcbiAgICogQHR5cGVkZWYge2Z1bmN0aW9uKG5vZGU6Tm9kZSk6dm9pZH0gVmlzaXRvclxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7ZnVuY3Rpb24oYTpLZXksIGI6S2V5KTpudW1iZXJ9IENvbXBhcmF0b3JcbiAgICovXG5cblxuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbihub2RlOk5vZGUpOnN0cmluZ30gTm9kZVByaW50ZXJcbiAgICovXG5cblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gIE5vZGVcbiAgICogQHByb3BlcnR5IHtLZXl9ICAgIEtleVxuICAgKiBAcHJvcGVydHkge1ZhbHVlPX0gZGF0YVxuICAgKiBAcHJvcGVydHkge05vZGV9ICAgbGVmdFxuICAgKiBAcHJvcGVydHkge05vZGV9ICAgcmlnaHRcbiAgICovXG5cbiAgdmFyIE5vZGUgPSBmdW5jdGlvbiBOb2RlIChrZXksIGRhdGEpIHtcbiAgICB0aGlzLmtleSAgPSBrZXk7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmxlZnQgPSBudWxsO1xuICAgIHRoaXMucmlnaHQ9IG51bGw7XG4gIH07XG5cbiAgZnVuY3Rpb24gREVGQVVMVF9DT01QQVJFIChhLCBiKSB7IHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDsgfVxuXG5cbiAgLyoqXG4gICAqIFNpbXBsZSB0b3AgZG93biBzcGxheSwgbm90IHJlcXVpcmluZyBpIHRvIGJlIGluIHRoZSB0cmVlIHQuXG4gICAqIEBwYXJhbSB7S2V5fSBpXG4gICAqIEBwYXJhbSB7Tm9kZT99IHRcbiAgICogQHBhcmFtIHtDb21wYXJhdG9yfSBjb21wYXJhdG9yXG4gICAqL1xuICBmdW5jdGlvbiBzcGxheSAoaSwgdCwgY29tcGFyYXRvcikge1xuICAgIGlmICh0ID09PSBudWxsKSB7IHJldHVybiB0OyB9XG4gICAgdmFyIGwsIHIsIHk7XG4gICAgdmFyIE4gPSBuZXcgTm9kZSgpO1xuICAgIGwgPSByID0gTjtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgY21wID0gY29tcGFyYXRvcihpLCB0LmtleSk7XG4gICAgICAvL2lmIChpIDwgdC5rZXkpIHtcbiAgICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICAgIGlmICh0LmxlZnQgPT09IG51bGwpIHsgYnJlYWs7IH1cbiAgICAgICAgLy9pZiAoaSA8IHQubGVmdC5rZXkpIHtcbiAgICAgICAgaWYgKGNvbXBhcmF0b3IoaSwgdC5sZWZ0LmtleSkgPCAwKSB7XG4gICAgICAgICAgeSA9IHQubGVmdDsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiByb3RhdGUgcmlnaHQgKi9cbiAgICAgICAgICB0LmxlZnQgPSB5LnJpZ2h0O1xuICAgICAgICAgIHkucmlnaHQgPSB0O1xuICAgICAgICAgIHQgPSB5O1xuICAgICAgICAgIGlmICh0LmxlZnQgPT09IG51bGwpIHsgYnJlYWs7IH1cbiAgICAgICAgfVxuICAgICAgICByLmxlZnQgPSB0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsaW5rIHJpZ2h0ICovXG4gICAgICAgIHIgPSB0O1xuICAgICAgICB0ID0gdC5sZWZ0O1xuICAgICAgLy99IGVsc2UgaWYgKGkgPiB0LmtleSkge1xuICAgICAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICAgIGlmICh0LnJpZ2h0ID09PSBudWxsKSB7IGJyZWFrOyB9XG4gICAgICAgIC8vaWYgKGkgPiB0LnJpZ2h0LmtleSkge1xuICAgICAgICBpZiAoY29tcGFyYXRvcihpLCB0LnJpZ2h0LmtleSkgPiAwKSB7XG4gICAgICAgICAgeSA9IHQucmlnaHQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiByb3RhdGUgbGVmdCAqL1xuICAgICAgICAgIHQucmlnaHQgPSB5LmxlZnQ7XG4gICAgICAgICAgeS5sZWZ0ID0gdDtcbiAgICAgICAgICB0ID0geTtcbiAgICAgICAgICBpZiAodC5yaWdodCA9PT0gbnVsbCkgeyBicmVhazsgfVxuICAgICAgICB9XG4gICAgICAgIGwucmlnaHQgPSB0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxpbmsgbGVmdCAqL1xuICAgICAgICBsID0gdDtcbiAgICAgICAgdCA9IHQucmlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLyogYXNzZW1ibGUgKi9cbiAgICBsLnJpZ2h0ID0gdC5sZWZ0O1xuICAgIHIubGVmdCA9IHQucmlnaHQ7XG4gICAgdC5sZWZ0ID0gTi5yaWdodDtcbiAgICB0LnJpZ2h0ID0gTi5sZWZ0O1xuICAgIHJldHVybiB0O1xuICB9XG5cblxuICAvKipcbiAgICogQHBhcmFtICB7S2V5fSAgICAgICAgaVxuICAgKiBAcGFyYW0gIHtWYWx1ZX0gICAgICBkYXRhXG4gICAqIEBwYXJhbSAge0NvbXBhcmF0b3J9IGNvbXBhcmF0b3JcbiAgICogQHBhcmFtICB7VHJlZX0gICAgICAgdHJlZVxuICAgKiBAcmV0dXJuIHtOb2RlfSAgICAgIHJvb3RcbiAgICovXG4gIGZ1bmN0aW9uIGluc2VydCAoaSwgZGF0YSwgdCwgY29tcGFyYXRvciwgdHJlZSkge1xuICAgIHZhciBub2RlID0gbmV3IE5vZGUoaSwgZGF0YSk7XG5cbiAgICB0cmVlLl9zaXplKys7XG5cbiAgICBpZiAodCA9PT0gbnVsbCkge1xuICAgICAgbm9kZS5sZWZ0ID0gbm9kZS5yaWdodCA9IG51bGw7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICB0ID0gc3BsYXkoaSwgdCwgY29tcGFyYXRvcik7XG4gICAgdmFyIGNtcCA9IGNvbXBhcmF0b3IoaSwgdC5rZXkpO1xuICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICBub2RlLmxlZnQgPSB0LmxlZnQ7XG4gICAgICBub2RlLnJpZ2h0ID0gdDtcbiAgICAgIHQubGVmdCA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChjbXAgPj0gMCkge1xuICAgICAgbm9kZS5yaWdodCA9IHQucmlnaHQ7XG4gICAgICBub2RlLmxlZnQgPSB0O1xuICAgICAgdC5yaWdodCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cblxuICAvKipcbiAgICogSW5zZXJ0IGkgaW50byB0aGUgdHJlZSB0LCB1bmxlc3MgaXQncyBhbHJlYWR5IHRoZXJlLlxuICAgKiBAcGFyYW0gIHtLZXl9ICAgICAgICBpXG4gICAqIEBwYXJhbSAge1ZhbHVlfSAgICAgIGRhdGFcbiAgICogQHBhcmFtICB7Q29tcGFyYXRvcn0gY29tcGFyYXRvclxuICAgKiBAcGFyYW0gIHtUcmVlfSAgICAgICB0cmVlXG4gICAqIEByZXR1cm4ge05vZGV9ICAgICAgIHJvb3RcbiAgICovXG4gIGZ1bmN0aW9uIGFkZCAoaSwgZGF0YSwgdCwgY29tcGFyYXRvciwgdHJlZSkge1xuICAgIHZhciBub2RlID0gbmV3IE5vZGUoaSwgZGF0YSk7XG5cbiAgICBpZiAodCA9PT0gbnVsbCkge1xuICAgICAgbm9kZS5sZWZ0ID0gbm9kZS5yaWdodCA9IG51bGw7XG4gICAgICB0cmVlLl9zaXplKys7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICB0ID0gc3BsYXkoaSwgdCwgY29tcGFyYXRvcik7XG4gICAgdmFyIGNtcCA9IGNvbXBhcmF0b3IoaSwgdC5rZXkpO1xuICAgIGlmIChjbXAgPT09IDApIHsgcmV0dXJuIHQ7IH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICAgIG5vZGUubGVmdCA9IHQubGVmdDtcbiAgICAgICAgbm9kZS5yaWdodCA9IHQ7XG4gICAgICAgIHQubGVmdCA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgICAgbm9kZS5yaWdodCA9IHQucmlnaHQ7XG4gICAgICAgIG5vZGUubGVmdCA9IHQ7XG4gICAgICAgIHQucmlnaHQgPSBudWxsO1xuICAgICAgfVxuICAgICAgdHJlZS5fc2l6ZSsrO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogRGVsZXRlcyBpIGZyb20gdGhlIHRyZWUgaWYgaXQncyB0aGVyZVxuICAgKiBAcGFyYW0ge0tleX0gICAgICAgIGlcbiAgICogQHBhcmFtIHtUcmVlfSAgICAgICB0cmVlXG4gICAqIEBwYXJhbSB7Q29tcGFyYXRvcn0gY29tcGFyYXRvclxuICAgKiBAcGFyYW0ge1RyZWV9ICAgICAgIHRyZWVcbiAgICogQHJldHVybiB7Tm9kZX0gICAgICBuZXcgcm9vdFxuICAgKi9cbiAgZnVuY3Rpb24gcmVtb3ZlIChpLCB0LCBjb21wYXJhdG9yLCB0cmVlKSB7XG4gICAgdmFyIHg7XG4gICAgaWYgKHQgPT09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB0ID0gc3BsYXkoaSwgdCwgY29tcGFyYXRvcik7XG4gICAgdmFyIGNtcCA9IGNvbXBhcmF0b3IoaSwgdC5rZXkpO1xuICAgIGlmIChjbXAgPT09IDApIHsgICAgICAgICAgICAgICAvKiBmb3VuZCBpdCAqL1xuICAgICAgaWYgKHQubGVmdCA9PT0gbnVsbCkge1xuICAgICAgICB4ID0gdC5yaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSBzcGxheShpLCB0LmxlZnQsIGNvbXBhcmF0b3IpO1xuICAgICAgICB4LnJpZ2h0ID0gdC5yaWdodDtcbiAgICAgIH1cbiAgICAgIHRyZWUuX3NpemUtLTtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICByZXR1cm4gdDsgICAgICAgICAgICAgICAgICAgICAgICAgLyogSXQgd2Fzbid0IHRoZXJlICovXG4gIH1cblxuXG4gIGZ1bmN0aW9uIHNwbGl0IChrZXksIHYsIGNvbXBhcmF0b3IpIHtcbiAgICB2YXIgbGVmdCwgcmlnaHQ7XG4gICAgaWYgKHYgPT09IG51bGwpIHtcbiAgICAgIGxlZnQgPSByaWdodCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHYgPSBzcGxheShrZXksIHYsIGNvbXBhcmF0b3IpO1xuXG4gICAgICB2YXIgY21wID0gY29tcGFyYXRvcih2LmtleSwga2V5KTtcbiAgICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgbGVmdCAgPSB2LmxlZnQ7XG4gICAgICAgIHJpZ2h0ID0gdi5yaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoY21wIDwgMCkge1xuICAgICAgICByaWdodCAgID0gdi5yaWdodDtcbiAgICAgICAgdi5yaWdodCA9IG51bGw7XG4gICAgICAgIGxlZnQgICAgPSB2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdCAgID0gdi5sZWZ0O1xuICAgICAgICB2LmxlZnQgPSBudWxsO1xuICAgICAgICByaWdodCAgPSB2O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBsZWZ0OiBsZWZ0LCByaWdodDogcmlnaHQgfTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gbWVyZ2UgKGxlZnQsIHJpZ2h0LCBjb21wYXJhdG9yKSB7XG4gICAgaWYgKHJpZ2h0ID09PSBudWxsKSB7IHJldHVybiBsZWZ0OyB9XG4gICAgaWYgKGxlZnQgID09PSBudWxsKSB7IHJldHVybiByaWdodDsgfVxuXG4gICAgcmlnaHQgPSBzcGxheShsZWZ0LmtleSwgcmlnaHQsIGNvbXBhcmF0b3IpO1xuICAgIHJpZ2h0LmxlZnQgPSBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFByaW50cyBsZXZlbCBvZiB0aGUgdHJlZVxuICAgKiBAcGFyYW0gIHtOb2RlfSAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgICAgICAgICAgICAgICAgICAgICBwcmVmaXhcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICAgICBpc1RhaWxcbiAgICogQHBhcmFtICB7QXJyYXk8c3RyaW5nPn0gICAgICAgICAgICAgICBvdXRcbiAgICogQHBhcmFtICB7RnVuY3Rpb24obm9kZTpOb2RlKTpTdHJpbmd9ICBwcmludE5vZGVcbiAgICovXG4gIGZ1bmN0aW9uIHByaW50Um93IChyb290LCBwcmVmaXgsIGlzVGFpbCwgb3V0LCBwcmludE5vZGUpIHtcbiAgICBpZiAocm9vdCkge1xuICAgICAgb3V0KChcIlwiICsgcHJlZml4ICsgKGlzVGFpbCA/ICfilJTilIDilIAgJyA6ICfilJzilIDilIAgJykgKyAocHJpbnROb2RlKHJvb3QpKSArIFwiXFxuXCIpKTtcbiAgICAgIHZhciBpbmRlbnQgPSBwcmVmaXggKyAoaXNUYWlsID8gJyAgICAnIDogJ+KUgiAgICcpO1xuICAgICAgaWYgKHJvb3QubGVmdCkgIHsgcHJpbnRSb3cocm9vdC5sZWZ0LCAgaW5kZW50LCBmYWxzZSwgb3V0LCBwcmludE5vZGUpOyB9XG4gICAgICBpZiAocm9vdC5yaWdodCkgeyBwcmludFJvdyhyb290LnJpZ2h0LCBpbmRlbnQsIHRydWUsICBvdXQsIHByaW50Tm9kZSk7IH1cbiAgICB9XG4gIH1cblxuXG4gIHZhciBUcmVlID0gZnVuY3Rpb24gVHJlZSAoY29tcGFyYXRvcikge1xuICAgIGlmICggY29tcGFyYXRvciA9PT0gdm9pZCAwICkgY29tcGFyYXRvciA9IERFRkFVTFRfQ09NUEFSRTtcblxuICAgIHRoaXMuX2NvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgIHRoaXMuX3NpemUgPSAwO1xuICB9O1xuXG4gIHZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IHNpemU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIGEga2V5LCBhbGxvd3MgZHVwbGljYXRlc1xuICAgKiBAcGFyYW17S2V5fSAga2V5XG4gICAqIEBwYXJhbXtWYWx1ZT19IGRhdGFcbiAgICogQHJldHVybiB7Tm9kZXxudWxsfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gaW5zZXJ0JDEgKGtleSwgZGF0YSkge1xuICAgIHJldHVybiB0aGlzLl9yb290ID0gaW5zZXJ0KGtleSwgZGF0YSwgdGhpcy5fcm9vdCwgdGhpcy5fY29tcGFyYXRvciwgdGhpcyk7XG4gIH07XG5cblxuICAvKipcbiAgICogQWRkcyBhIGtleSwgaWYgaXQgaXMgbm90IHByZXNlbnQgaW4gdGhlIHRyZWVcbiAgICogQHBhcmFte0tleX0gIGtleVxuICAgKiBAcGFyYW17VmFsdWU9fSBkYXRhXG4gICAqIEByZXR1cm4ge05vZGV8bnVsbH1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCQxIChrZXksIGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdCA9IGFkZChrZXksIGRhdGEsIHRoaXMuX3Jvb3QsIHRoaXMuX2NvbXBhcmF0b3IsIHRoaXMpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbXtLZXl9IGtleVxuICAgKiBAcmV0dXJuIHtOb2RlfG51bGx9XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUkMSAoa2V5KSB7XG4gICAgdGhpcy5fcm9vdCA9IHJlbW92ZShrZXksIHRoaXMuX3Jvb3QsIHRoaXMuX2NvbXBhcmF0b3IsIHRoaXMpO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW5kIHJldHVybnMgdGhlIG5vZGUgd2l0aCBzbWFsbGVzdCBrZXlcbiAgICogQHJldHVybiB7P05vZGV9XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiBwb3AgKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5fcm9vdDtcbiAgICBpZiAobm9kZSkge1xuICAgICAgd2hpbGUgKG5vZGUubGVmdCkgeyBub2RlID0gbm9kZS5sZWZ0OyB9XG4gICAgICB0aGlzLl9yb290ID0gc3BsYXkobm9kZS5rZXksdGhpcy5fcm9vdCwgdGhpcy5fY29tcGFyYXRvcik7XG4gICAgICB0aGlzLl9yb290ID0gcmVtb3ZlKG5vZGUua2V5LCB0aGlzLl9yb290LCB0aGlzLl9jb21wYXJhdG9yLCB0aGlzKTtcbiAgICAgIHJldHVybiB7IGtleTogbm9kZS5rZXksIGRhdGE6IG5vZGUuZGF0YSB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW17S2V5fSBrZXlcbiAgICogQHJldHVybiB7Tm9kZXxudWxsfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUuZmluZFN0YXRpYyA9IGZ1bmN0aW9uIGZpbmRTdGF0aWMgKGtleSkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5fcm9vdDtcbiAgICB2YXIgY29tcGFyZSA9IHRoaXMuX2NvbXBhcmF0b3I7XG4gICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgIHZhciBjbXAgPSBjb21wYXJlKGtleSwgY3VycmVudC5rZXkpO1xuICAgICAgaWYgKGNtcCA9PT0gMCkgIHsgcmV0dXJuIGN1cnJlbnQ7IH1cbiAgICAgIGVsc2UgaWYgKGNtcCA8IDApIHsgY3VycmVudCA9IGN1cnJlbnQubGVmdDsgfVxuICAgICAgZWxzZSAgICAgICAgICAgIHsgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7IH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cblxuICAvKipcbiAgICogQHBhcmFte0tleX0ga2V5XG4gICAqIEByZXR1cm4ge05vZGV8bnVsbH1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiBmaW5kIChrZXkpIHtcbiAgICBpZiAodGhpcy5fcm9vdCkge1xuICAgICAgdGhpcy5fcm9vdCA9IHNwbGF5KGtleSwgdGhpcy5fcm9vdCwgdGhpcy5fY29tcGFyYXRvcik7XG4gICAgICBpZiAodGhpcy5fY29tcGFyYXRvcihrZXksIHRoaXMuX3Jvb3Qua2V5KSAhPT0gMCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcm9vdDtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW17S2V5fSBrZXlcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gY29udGFpbnMgKGtleSkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5fcm9vdDtcbiAgICB2YXIgY29tcGFyZSA9IHRoaXMuX2NvbXBhcmF0b3I7XG4gICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgIHZhciBjbXAgPSBjb21wYXJlKGtleSwgY3VycmVudC5rZXkpO1xuICAgICAgaWYgKGNtcCA9PT0gMCkgIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgIGVsc2UgaWYgKGNtcCA8IDApIHsgY3VycmVudCA9IGN1cnJlbnQubGVmdDsgfVxuICAgICAgZWxzZSAgICAgICAgICAgIHsgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7IH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBwYXJhbXtWaXNpdG9yfSB2aXNpdG9yXG4gICAqIEBwYXJhbXsqPX0gICAgY3R4XG4gICAqIEByZXR1cm4ge1NwbGF5VHJlZX1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoICh2aXNpdG9yLCBjdHgpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuX3Jvb3Q7XG4gICAgdmFyIFEgPSBbXTsvKiBJbml0aWFsaXplIHN0YWNrIHMgKi9cbiAgICB2YXIgZG9uZSA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICBpZiAoY3VycmVudCAhPT1udWxsKSB7XG4gICAgICAgIFEucHVzaChjdXJyZW50KTtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChRLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIGN1cnJlbnQgPSBRLnBvcCgpO1xuICAgICAgICAgIHZpc2l0b3IuY2FsbChjdHgsIGN1cnJlbnQpO1xuXG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XG4gICAgICAgIH0gZWxzZSB7IGRvbmUgPSB0cnVlOyB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFdhbGsga2V5IHJhbmdlIGZyb20gYGxvd2AgdG8gYGhpZ2hgLiBTdG9wcyBpZiBgZm5gIHJldHVybnMgYSB2YWx1ZS5cbiAgICogQHBhcmFte0tleX0gICAgbG93XG4gICAqIEBwYXJhbXtLZXl9ICAgIGhpZ2hcbiAgICogQHBhcmFte0Z1bmN0aW9ufSBmblxuICAgKiBAcGFyYW17Kj99ICAgICBjdHhcbiAgICogQHJldHVybiB7U3BsYXlUcmVlfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUucmFuZ2UgPSBmdW5jdGlvbiByYW5nZSAobG93LCBoaWdoLCBmbiwgY3R4KSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBRID0gW107XG4gICAgdmFyIGNvbXBhcmUgPSB0aGlzLl9jb21wYXJhdG9yO1xuICAgIHZhciBub2RlID0gdGhpcy5fcm9vdCwgY21wO1xuXG4gICAgd2hpbGUgKFEubGVuZ3RoICE9PSAwIHx8IG5vZGUpIHtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIFEucHVzaChub2RlKTtcbiAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBRLnBvcCgpO1xuICAgICAgICBjbXAgPSBjb21wYXJlKG5vZGUua2V5LCBoaWdoKTtcbiAgICAgICAgaWYgKGNtcCA+IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChjb21wYXJlKG5vZGUua2V5LCBsb3cpID49IDApIHtcbiAgICAgICAgICBpZiAoZm4uY2FsbChjdHgsIG5vZGUpKSB7IHJldHVybiB0aGlzJDE7IH0gLy8gc3RvcCBpZiBzbXRoIGlzIHJldHVybmVkXG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYXJyYXkgb2Yga2V5c1xuICAgKiBAcmV0dXJuIHtBcnJheTxLZXk+fVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uIGtleXMgKCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgdmFyIGtleSA9IHJlZi5rZXk7XG5cbiAgICAgICAgcmV0dXJuIGtleXMucHVzaChrZXkpO1xuICAgICAgfSk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cblxuICAvKipcbiAgICogUmV0dXJucyBhcnJheSBvZiBhbGwgdGhlIGRhdGEgaW4gdGhlIG5vZGVzXG4gICAqIEByZXR1cm4ge0FycmF5PFZhbHVlPn1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uIHZhbHVlcyAoKSB7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlcy5wdXNoKGRhdGEpO1xuICAgICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtLZXl8bnVsbH1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uIG1pbiAoKSB7XG4gICAgaWYgKHRoaXMuX3Jvb3QpIHsgcmV0dXJuIHRoaXMubWluTm9kZSh0aGlzLl9yb290KS5rZXk7IH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtLZXl8bnVsbH1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uIG1heCAoKSB7XG4gICAgaWYgKHRoaXMuX3Jvb3QpIHsgcmV0dXJuIHRoaXMubWF4Tm9kZSh0aGlzLl9yb290KS5rZXk7IH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtOb2RlfG51bGx9XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS5taW5Ob2RlID0gZnVuY3Rpb24gbWluTm9kZSAodCkge1xuICAgICAgaWYgKCB0ID09PSB2b2lkIDAgKSB0ID0gdGhpcy5fcm9vdDtcblxuICAgIGlmICh0KSB7IHdoaWxlICh0LmxlZnQpIHsgdCA9IHQubGVmdDsgfSB9XG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cblxuICAvKipcbiAgICogQHJldHVybiB7Tm9kZXxudWxsfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUubWF4Tm9kZSA9IGZ1bmN0aW9uIG1heE5vZGUgKHQpIHtcbiAgICAgIGlmICggdCA9PT0gdm9pZCAwICkgdCA9IHRoaXMuX3Jvb3Q7XG5cbiAgICBpZiAodCkgeyB3aGlsZSAodC5yaWdodCkgeyB0ID0gdC5yaWdodDsgfSB9XG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cblxuICAvKipcbiAgICogUmV0dXJucyBub2RlIGF0IGdpdmVuIGluZGV4XG4gICAqIEBwYXJhbXtudW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm4gez9Ob2RlfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBhdCAoaW5kZXgpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuX3Jvb3QsIGRvbmUgPSBmYWxzZSwgaSA9IDA7XG4gICAgdmFyIFEgPSBbXTtcblxuICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgUS5wdXNoKGN1cnJlbnQpO1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5sZWZ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKFEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGN1cnJlbnQgPSBRLnBvcCgpO1xuICAgICAgICAgIGlmIChpID09PSBpbmRleCkgeyByZXR1cm4gY3VycmVudDsgfVxuICAgICAgICAgIGkrKztcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcbiAgICAgICAgfSBlbHNlIHsgZG9uZSA9IHRydWU7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cblxuICAvKipcbiAgICogQHBhcmFte05vZGV9IGRcbiAgICogQHJldHVybiB7Tm9kZXxudWxsfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIG5leHQgKGQpIHtcbiAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3Q7XG4gICAgdmFyIHN1Y2Nlc3NvciA9IG51bGw7XG5cbiAgICBpZiAoZC5yaWdodCkge1xuICAgICAgc3VjY2Vzc29yID0gZC5yaWdodDtcbiAgICAgIHdoaWxlIChzdWNjZXNzb3IubGVmdCkgeyBzdWNjZXNzb3IgPSBzdWNjZXNzb3IubGVmdDsgfVxuICAgICAgcmV0dXJuIHN1Y2Nlc3NvcjtcbiAgICB9XG5cbiAgICB2YXIgY29tcGFyYXRvciA9IHRoaXMuX2NvbXBhcmF0b3I7XG4gICAgd2hpbGUgKHJvb3QpIHtcbiAgICAgIHZhciBjbXAgPSBjb21wYXJhdG9yKGQua2V5LCByb290LmtleSk7XG4gICAgICBpZiAoY21wID09PSAwKSB7IGJyZWFrOyB9XG4gICAgICBlbHNlIGlmIChjbXAgPCAwKSB7XG4gICAgICAgIHN1Y2Nlc3NvciA9IHJvb3Q7XG4gICAgICAgIHJvb3QgPSByb290LmxlZnQ7XG4gICAgICB9IGVsc2UgeyByb290ID0gcm9vdC5yaWdodDsgfVxuICAgIH1cblxuICAgIHJldHVybiBzdWNjZXNzb3I7XG4gIH07XG5cblxuICAvKipcbiAgICogQHBhcmFte05vZGV9IGRcbiAgICogQHJldHVybiB7Tm9kZXxudWxsfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uIHByZXYgKGQpIHtcbiAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3Q7XG4gICAgdmFyIHByZWRlY2Vzc29yID0gbnVsbDtcblxuICAgIGlmIChkLmxlZnQgIT09IG51bGwpIHtcbiAgICAgIHByZWRlY2Vzc29yID0gZC5sZWZ0O1xuICAgICAgd2hpbGUgKHByZWRlY2Vzc29yLnJpZ2h0KSB7IHByZWRlY2Vzc29yID0gcHJlZGVjZXNzb3IucmlnaHQ7IH1cbiAgICAgIHJldHVybiBwcmVkZWNlc3NvcjtcbiAgICB9XG5cbiAgICB2YXIgY29tcGFyYXRvciA9IHRoaXMuX2NvbXBhcmF0b3I7XG4gICAgd2hpbGUgKHJvb3QpIHtcbiAgICAgIHZhciBjbXAgPSBjb21wYXJhdG9yKGQua2V5LCByb290LmtleSk7XG4gICAgICBpZiAoY21wID09PSAwKSB7IGJyZWFrOyB9XG4gICAgICBlbHNlIGlmIChjbXAgPCAwKSB7IHJvb3QgPSByb290LmxlZnQ7IH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwcmVkZWNlc3NvciA9IHJvb3Q7XG4gICAgICAgIHJvb3QgPSByb290LnJpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJlZGVjZXNzb3I7XG4gIH07XG5cblxuICAvKipcbiAgICogQHJldHVybiB7U3BsYXlUcmVlfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogQHJldHVybiB7Tm9kZUxpc3R9XG4gICAqL1xuICBUcmVlLnByb3RvdHlwZS50b0xpc3QgPSBmdW5jdGlvbiB0b0xpc3QkMSAoKSB7XG4gICAgcmV0dXJuIHRvTGlzdCh0aGlzLl9yb290KTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBCdWxrLWxvYWQgaXRlbXMuIEJvdGggYXJyYXkgaGF2ZSB0byBiZSBzYW1lIHNpemVcbiAgICogQHBhcmFte0FycmF5PEtleT59ICBrZXlzXG4gICAqIEBwYXJhbXtBcnJheTxWYWx1ZT59W3ZhbHVlc11cbiAgICogQHBhcmFte0Jvb2xlYW59ICAgICBbcHJlc29ydD1mYWxzZV0gUHJlLXNvcnQga2V5cyBhbmQgdmFsdWVzLCB1c2luZ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWUncyBjb21wYXJhdG9yLiBTb3J0aW5nIGlzIGRvbmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbi1wbGFjZVxuICAgKiBAcmV0dXJuIHtBVkxUcmVlfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIGxvYWQgKGtleXMsIHZhbHVlcywgcHJlc29ydCkge1xuICAgICAgaWYgKCBrZXlzID09PSB2b2lkIDAgKSBrZXlzID0gW107XG4gICAgICBpZiAoIHZhbHVlcyA9PT0gdm9pZCAwICkgdmFsdWVzID0gW107XG4gICAgICBpZiAoIHByZXNvcnQgPT09IHZvaWQgMCApIHByZXNvcnQgPSBmYWxzZTtcblxuICAgIHZhciBzaXplID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGNvbXBhcmF0b3IgPSB0aGlzLl9jb21wYXJhdG9yO1xuXG4gICAgLy8gc29ydCBpZiBuZWVkZWRcbiAgICBpZiAocHJlc29ydCkgeyBzb3J0KGtleXMsIHZhbHVlcywgMCwgc2l6ZSAtIDEsIGNvbXBhcmF0b3IpOyB9XG5cbiAgICBpZiAodGhpcy5fcm9vdCA9PT0gbnVsbCkgeyAvLyBlbXB0eSB0cmVlXG4gICAgICB0aGlzLl9yb290ID0gbG9hZFJlY3Vyc2l2ZSh0aGlzLl9yb290LCBrZXlzLCB2YWx1ZXMsIDAsIHNpemUpO1xuICAgICAgdGhpcy5fc2l6ZSA9IHNpemU7XG4gICAgfSBlbHNlIHsgLy8gdGhhdCByZS1idWlsZHMgdGhlIHdob2xlIHRyZWUgZnJvbSB0d28gaW4tb3JkZXIgdHJhdmVyc2Fsc1xuICAgICAgdmFyIG1lcmdlZExpc3QgPSBtZXJnZUxpc3RzKHRoaXMudG9MaXN0KCksIGNyZWF0ZUxpc3Qoa2V5cywgdmFsdWVzKSwgY29tcGFyYXRvcik7XG4gICAgICBzaXplID0gdGhpcy5fc2l6ZSArIHNpemU7XG4gICAgICB0aGlzLl9yb290ID0gc29ydGVkTGlzdFRvQlNUKHsgaGVhZDogbWVyZ2VkTGlzdCB9LCAwLCBzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIFRyZWUucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5ICgpIHsgcmV0dXJuIHRoaXMuX3Jvb3QgPT09IG51bGw7IH07XG5cbiAgcHJvdG90eXBlQWNjZXNzb3JzLnNpemUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc2l6ZTsgfTtcblxuXG4gIC8qKlxuICAgKiBAcGFyYW17Tm9kZVByaW50ZXI9fSBwcmludE5vZGVcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgVHJlZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAocHJpbnROb2RlKSB7XG4gICAgICBpZiAoIHByaW50Tm9kZSA9PT0gdm9pZCAwICkgcHJpbnROb2RlID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4ua2V5OyB9O1xuXG4gICAgdmFyIG91dCA9IFtdO1xuICAgIHByaW50Um93KHRoaXMuX3Jvb3QsICcnLCB0cnVlLCBmdW5jdGlvbiAodikgeyByZXR1cm4gb3V0LnB1c2godik7IH0sIHByaW50Tm9kZSk7XG4gICAgcmV0dXJuIG91dC5qb2luKCcnKTtcbiAgfTtcblxuXG4gIFRyZWUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoa2V5LCBuZXdLZXksIG5ld0RhdGEpIHtcbiAgICB2YXIgY29tcGFyYXRvciA9IHRoaXMuX2NvbXBhcmF0b3I7XG4gICAgdmFyIHJlZiA9IHNwbGl0KGtleSwgdGhpcy5fcm9vdCwgY29tcGFyYXRvcik7XG4gICAgICB2YXIgbGVmdCA9IHJlZi5sZWZ0O1xuICAgICAgdmFyIHJpZ2h0ID0gcmVmLnJpZ2h0O1xuICAgIHRoaXMuX3NpemUtLTtcbiAgICBpZiAoY29tcGFyYXRvcihrZXksIG5ld0tleSkgPCAwKSB7XG4gICAgICByaWdodCA9IGluc2VydChuZXdLZXksIG5ld0RhdGEsIHJpZ2h0LCBjb21wYXJhdG9yLCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IGluc2VydChuZXdLZXksIG5ld0RhdGEsIGxlZnQsIGNvbXBhcmF0b3IsIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLl9yb290ID0gbWVyZ2UobGVmdCwgcmlnaHQsIGNvbXBhcmF0b3IpO1xuICB9O1xuXG5cbiAgVHJlZS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCQxIChrZXkpIHtcbiAgICByZXR1cm4gc3BsaXQoa2V5LCB0aGlzLl9yb290LCB0aGlzLl9jb21wYXJhdG9yKTtcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggVHJlZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG5cbiAgZnVuY3Rpb24gbG9hZFJlY3Vyc2l2ZSAocGFyZW50LCBrZXlzLCB2YWx1ZXMsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgc2l6ZSA9IGVuZCAtIHN0YXJ0O1xuICAgIGlmIChzaXplID4gMCkge1xuICAgICAgdmFyIG1pZGRsZSA9IHN0YXJ0ICsgTWF0aC5mbG9vcihzaXplIC8gMik7XG4gICAgICB2YXIga2V5ICAgID0ga2V5c1ttaWRkbGVdO1xuICAgICAgdmFyIGRhdGEgICA9IHZhbHVlc1ttaWRkbGVdO1xuICAgICAgdmFyIG5vZGUgICA9IHsga2V5OiBrZXksIGRhdGE6IGRhdGEsIHBhcmVudDogcGFyZW50IH07XG4gICAgICBub2RlLmxlZnQgICAgPSBsb2FkUmVjdXJzaXZlKG5vZGUsIGtleXMsIHZhbHVlcywgc3RhcnQsIG1pZGRsZSk7XG4gICAgICBub2RlLnJpZ2h0ICAgPSBsb2FkUmVjdXJzaXZlKG5vZGUsIGtleXMsIHZhbHVlcywgbWlkZGxlICsgMSwgZW5kKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gY3JlYXRlTGlzdChrZXlzLCB2YWx1ZXMpIHtcbiAgICB2YXIgaGVhZCA9IHsgbmV4dDogbnVsbCB9O1xuICAgIHZhciBwID0gaGVhZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHAgPSBwLm5leHQgPSB7IGtleToga2V5c1tpXSwgZGF0YTogdmFsdWVzW2ldIH07XG4gICAgfVxuICAgIHAubmV4dCA9IG51bGw7XG4gICAgcmV0dXJuIGhlYWQubmV4dDtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gdG9MaXN0IChyb290KSB7XG4gICAgdmFyIGN1cnJlbnQgPSByb290O1xuICAgIHZhciBRID0gW10sIGRvbmUgPSBmYWxzZTtcblxuICAgIHZhciBoZWFkID0geyBuZXh0OiBudWxsIH07XG4gICAgdmFyIHAgPSBoZWFkO1xuXG4gICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICBRLnB1c2goY3VycmVudCk7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoUS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY3VycmVudCA9IHAgPSBwLm5leHQgPSBRLnBvcCgpO1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJpZ2h0O1xuICAgICAgICB9IGVsc2UgeyBkb25lID0gdHJ1ZTsgfVxuICAgICAgfVxuICAgIH1cbiAgICBwLm5leHQgPSBudWxsOyAvLyB0aGF0J2xsIHdvcmsgZXZlbiBpZiB0aGUgdHJlZSB3YXMgZW1wdHlcbiAgICByZXR1cm4gaGVhZC5uZXh0O1xuICB9XG5cblxuICBmdW5jdGlvbiBzb3J0ZWRMaXN0VG9CU1QobGlzdCwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBzaXplID0gZW5kIC0gc3RhcnQ7XG4gICAgaWYgKHNpemUgPiAwKSB7XG4gICAgICB2YXIgbWlkZGxlID0gc3RhcnQgKyBNYXRoLmZsb29yKHNpemUgLyAyKTtcbiAgICAgIHZhciBsZWZ0ID0gc29ydGVkTGlzdFRvQlNUKGxpc3QsIHN0YXJ0LCBtaWRkbGUpO1xuXG4gICAgICB2YXIgcm9vdCA9IGxpc3QuaGVhZDtcbiAgICAgIHJvb3QubGVmdCA9IGxlZnQ7XG5cbiAgICAgIGxpc3QuaGVhZCA9IGxpc3QuaGVhZC5uZXh0O1xuXG4gICAgICByb290LnJpZ2h0ID0gc29ydGVkTGlzdFRvQlNUKGxpc3QsIG1pZGRsZSArIDEsIGVuZCk7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG1lcmdlTGlzdHMgKGwxLCBsMiwgY29tcGFyZSkge1xuICAgIGlmICggY29tcGFyZSA9PT0gdm9pZCAwICkgY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC0gYjsgfTtcblxuICAgIHZhciBoZWFkID0ge307IC8vIGR1bW15XG4gICAgdmFyIHAgPSBoZWFkO1xuXG4gICAgdmFyIHAxID0gbDE7XG4gICAgdmFyIHAyID0gbDI7XG5cbiAgICB3aGlsZSAocDEgIT09IG51bGwgJiYgcDIgIT09IG51bGwpIHtcbiAgICAgIGlmIChjb21wYXJlKHAxLmtleSwgcDIua2V5KSA8IDApIHtcbiAgICAgICAgcC5uZXh0ID0gcDE7XG4gICAgICAgIHAxID0gcDEubmV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHAubmV4dCA9IHAyO1xuICAgICAgICBwMiA9IHAyLm5leHQ7XG4gICAgICB9XG4gICAgICBwID0gcC5uZXh0O1xuICAgIH1cblxuICAgIGlmIChwMSAhPT0gbnVsbCkgICAgICB7IHAubmV4dCA9IHAxOyB9XG4gICAgZWxzZSBpZiAocDIgIT09IG51bGwpIHsgcC5uZXh0ID0gcDI7IH1cblxuICAgIHJldHVybiBoZWFkLm5leHQ7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHNvcnQoa2V5cywgdmFsdWVzLCBsZWZ0LCByaWdodCwgY29tcGFyZSkge1xuICAgIGlmIChsZWZ0ID49IHJpZ2h0KSB7IHJldHVybjsgfVxuXG4gICAgdmFyIHBpdm90ID0ga2V5c1sobGVmdCArIHJpZ2h0KSA+PiAxXTtcbiAgICB2YXIgaSA9IGxlZnQgLSAxO1xuICAgIHZhciBqID0gcmlnaHQgKyAxO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGRvIHsgaSsrOyB9IHdoaWxlIChjb21wYXJlKGtleXNbaV0sIHBpdm90KSA8IDApO1xuICAgICAgZG8geyBqLS07IH0gd2hpbGUgKGNvbXBhcmUoa2V5c1tqXSwgcGl2b3QpID4gMCk7XG4gICAgICBpZiAoaSA+PSBqKSB7IGJyZWFrOyB9XG5cbiAgICAgIHZhciB0bXAgPSBrZXlzW2ldO1xuICAgICAga2V5c1tpXSA9IGtleXNbal07XG4gICAgICBrZXlzW2pdID0gdG1wO1xuXG4gICAgICB0bXAgPSB2YWx1ZXNbaV07XG4gICAgICB2YWx1ZXNbaV0gPSB2YWx1ZXNbal07XG4gICAgICB2YWx1ZXNbal0gPSB0bXA7XG4gICAgfVxuXG4gICAgc29ydChrZXlzLCB2YWx1ZXMsICBsZWZ0LCAgICAgaiwgY29tcGFyZSk7XG4gICAgc29ydChrZXlzLCB2YWx1ZXMsIGogKyAxLCByaWdodCwgY29tcGFyZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFdmVudFF1ZXVlKGJ5WSkge1xuICAgIHZhciBxID0gbmV3IFRyZWUoYnlZKTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc0VtcHR5OiBpc0VtcHR5LFxuICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgIHBvcDogcG9wLFxuICAgICAgZmluZDogZmluZCxcbiAgICAgIGluc2VydDogaW5zZXJ0XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmluZChwKSB7XG4gICAgICByZXR1cm4gcS5maW5kKHApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNpemUoKSB7XG4gICAgICByZXR1cm4gcS5zaXplO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgICByZXR1cm4gcS5pc0VtcHR5KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zZXJ0KGV2ZW50KSB7XG4gICAgICAvLyBkZWJ1Z2dlcjtcbiAgICAgIHEuYWRkKGV2ZW50LnBvaW50LCBldmVudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9wKCkge1xuICAgICAgdmFyIG5vZGUgPSBxLnBvcCgpO1xuICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5kYXRhO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBKdXN0IGEgY29sbGVjdGlvbiBvZiBnZW9tZXRyeSByZWxhdGVkIHV0aWxpdGllc1xuICAgKi9cblxuICAvLyBUaGlzIGlzIHVzZWQgZm9yIHByZWNpc2lvbiBjaGVja2luZyAoZS5nLiB0d28gbnVtYmVycyBhcmUgZXF1YWxcbiAgLy8gaWYgdGhlaXIgZGlmZmVyZW5jZSBpcyBzbWFsbGVyIHRoYW4gdGhpcyBudW1iZXIpLiBUaGUgdmFsdWUgaXMgXG4gIC8vIGNob3NlbiBlbXBpcmljYWxseS4gV2Ugc3RpbGwgbWF5IHJ1biBpbnRvIHByZWNpc2lvbiByZWxhdGVkIGlzc3Vlcy5cbiAgLy8gVE9ETzogd2Ugc2hvdWxkIGFsbG93IGNvbnN1bWVycyB0byBjb25maWd1cmUgdGhpcy5cbiAgdmFyIEVQUyA9IDFlLTk7Ly8xMDtcblxuICBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25YUG9pbnQoc2VnbWVudCwgeFBvcywgeVBvcykge1xuICAgIHZhciBkeTEgPSBzZWdtZW50LmZyb20ueSAtIHlQb3M7XG4gICAgdmFyIGR5MiA9IHlQb3MgLSBzZWdtZW50LnRvLnk7XG4gICAgdmFyIGR5ID0gc2VnbWVudC50by55IC0gc2VnbWVudC5mcm9tLnk7XG4gICAgaWYgKE1hdGguYWJzKGR5MSkgPCBFUFMpIHtcbiAgICAgIC8vIFRoZSBzZWdtZW50IHN0YXJ0cyBvbiB0aGUgc3dlZXAgbGluZVxuICAgICAgaWYgKE1hdGguYWJzKGR5KSA8IEVQUykge1xuICAgICAgICAvLyB0aGUgc2VnbWVudCBpcyBob3Jpem9udGFsLiBJbnRlcnNlY3Rpb24gaXMgYXQgdGhlIHBvaW50XG4gICAgICAgIGlmICh4UG9zIDw9IHNlZ21lbnQuZnJvbS54KSB7IHJldHVybiBzZWdtZW50LmZyb20ueDsgfVxuICAgICAgICBpZiAoeFBvcyA+IHNlZ21lbnQudG8ueCkgeyByZXR1cm4gc2VnbWVudC50by54OyB9XG4gICAgICAgIHJldHVybiB4UG9zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlZ21lbnQuZnJvbS54O1xuICAgIH1cbiAgICBcbiAgICB2YXIgZHggPSAoc2VnbWVudC50by54IC0gc2VnbWVudC5mcm9tLngpOyBcbiAgICB2YXIgeE9mZnNldDsgXG4gICAgaWYgKGR5MSA+PSBkeTIpIHtcbiAgICAgIHhPZmZzZXQgPSBkeTEgKiAoZHggLyBkeSk7IFxuICAgICAgcmV0dXJuIChzZWdtZW50LmZyb20ueCAtIHhPZmZzZXQpO1xuICAgIH0gXG4gICAgeE9mZnNldCA9IGR5MiAqIChkeCAvIGR5KTtcbiAgICByZXR1cm4gKHNlZ21lbnQudG8ueCArIHhPZmZzZXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gYW5nbGUoZHgsIGR5KSB7XG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTY1NDIwNDIvZmFzdGVzdC13YXktdG8tc29ydC12ZWN0b3JzLWJ5LWFuZ2xlLXdpdGhvdXQtYWN0dWFsbHktY29tcHV0aW5nLXRoYXQtYW5nbGVcbiAgICB2YXIgcCA9IGR4LyhNYXRoLmFicyhkeCkgKyBNYXRoLmFicyhkeSkpOyAvLyAtMSAuLiAxIGluY3JlYXNpbmcgd2l0aCB4XG5cbiAgICBpZiAoZHkgPCAwKSB7IHJldHVybiBwIC0gMTsgfSAgLy8gLTIgLi4gMCBpbmNyZWFzaW5nIHdpdGggeFxuICAgIHJldHVybiAxIC0gcCAgICAgICAgICAgICAgIC8vICAwIC4uIDIgZGVjcmVhc2luZyB3aXRoIHhcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVyc2VjdFNlZ21lbnRzKGEsIGIpIHtcbiAgICAvLyAgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE5NjgzNDUvMTI1MzUxXG4gICAgdmFyIGFTdGFydCA9IGEuZnJvbSwgYlN0YXJ0ID0gYi5mcm9tO1xuICAgIHZhciBwMF94ID0gYVN0YXJ0LngsIHAwX3kgPSBhU3RhcnQueSxcbiAgICAgICAgcDJfeCA9IGJTdGFydC54LCBwMl95ID0gYlN0YXJ0Lnk7XG5cbiAgICB2YXIgczFfeCA9IGEuZHgsIHMxX3kgPSBhLmR5LCBzMl94ID0gYi5keCwgczJfeSA9IGIuZHk7XG4gICAgdmFyIGRpdiA9IHMxX3ggKiBzMl95IC0gczJfeCAqIHMxX3k7XG5cbiAgICB2YXIgcyA9IChzMV95ICogKHAwX3ggLSBwMl94KSAtIHMxX3ggKiAocDBfeSAtIHAyX3kpKSAvIGRpdjtcbiAgICBpZiAocyA8IDAgfHwgcyA+IDEpIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgdCA9IChzMl94ICogKHAyX3kgLSBwMF95KSArIHMyX3kgKiAocDBfeCAtIHAyX3gpKSAvIGRpdjtcblxuICAgIGlmICh0ID49IDAgJiYgdCA8PSAxKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBwMF94IC0gKHQgKiBzMV94KSxcbiAgICAgICAgeTogcDBfeSAtICh0ICogczFfeSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzYW1lUG9pbnQoYSwgYikge1xuICAgIHJldHVybiBNYXRoLmFicyhhLnggLSBiLngpIDwgRVBTICYmIE1hdGguYWJzKGEueSAtIGIueSkgPCBFUFM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBzd2VlcCBzdGF0dXMgZGF0YSBzdHJ1Y3R1cmUuXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVTd2VlcFN0YXR1cyhvbkVycm9yLCBFUFMkJDEpIHtcbiAgICB2YXIgbGFzdFBvaW50WSwgcHJldlk7XG4gICAgdmFyIGxhc3RQb2ludFgsIHByZXZYO1xuICAgIHZhciB1c2VCZWxvdyA9IGZhbHNlO1xuICAgIHZhciBzdGF0dXMgPSBuZXcgVHJlZShjb21wYXJlU2VnbWVudHMpO1xuXG4gICAgLy8gVG8gc2F2ZSBvbiBHQyB3ZSByZXR1cm4gbXV0YWJsZSBvYmplY3QuXG4gICAgdmFyIGN1cnJlbnRCb3VuZGFyeSA9IHtcbiAgICAgIGJlZm9yZUxlZnQ6IG51bGwsXG4gICAgICBsZWZ0OiBudWxsLFxuICAgICAgcmlnaHQ6IG51bGwsXG4gICAgICBhZnRlclJpZ2h0OiBudWxsLFxuICAgIH07XG5cbiAgICB2YXIgY3VycmVudExlZnRSaWdodCA9IHtsZWZ0OiBudWxsLCByaWdodDogbnVsbH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBBZGQgbmV3IHNlZ21lbnRzIGludG8gdGhlIHN0YXR1cyB0cmVlLlxuICAgICAgICovXG4gICAgICBpbnNlcnRTZWdtZW50czogaW5zZXJ0U2VnbWVudHMsXG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlIHNlZ21lbnRzIGZyb20gdGhlIHN0YXR1cyB0cmVlLlxuICAgICAgICovXG4gICAgICBkZWxldGVTZWdtZW50czogZGVsZXRlU2VnbWVudHMsXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyBzZWdtZW50cyB0aGF0IGFyZSB0byB0aGUgbGVmdCBhbmQgcmlnaHQgZnJvbSBhIGdpdmVuIHBvaW50LlxuICAgICAgICovXG4gICAgICBnZXRMZWZ0UmlnaHRQb2ludDogZ2V0TGVmdFJpZ2h0UG9pbnQsXG5cbiAgICAgIC8qKlxuICAgICAgICogRm9yIGEgZ2l2ZW4gY29sbGVjdGlvbnMgb2Ygc2VnbWVudHMgZmluZHMgdGhlIG1vc3QgbGVmdCBhbmQgdGhlIG1vc3QgcmlnaHRcbiAgICAgICAqIHNlZ21lbnRzLiBBbHNvIHJldHVybnMgc2VnbWVudHMgaW1tZWRpYXRlbHkgYmVmb3JlIGxlZnQsIGFuZCBhZnRlciByaWdodCBzZWdtZW50cy5cbiAgICAgICAqL1xuICAgICAgZ2V0Qm91bmRhcnlTZWdtZW50czogZ2V0Qm91bmRhcnlTZWdtZW50cyxcblxuICAgICAgZmluZFNlZ21lbnRzV2l0aFBvaW50OiBmaW5kU2VnbWVudHNXaXRoUG9pbnQsXG5cbiAgICAgIC8qKlxuICAgICAgICogQ3VycmVudCBiaW5hcnkgc2VhcmNoIHRyZWUgd2l0aCBzZWdtZW50c1xuICAgICAgICovXG4gICAgICBzdGF0dXM6IHN0YXR1cyxcblxuICAgICAgLyoqXG4gICAgICAgKiBJbnRyb3NwZWN0aW9uIG1ldGhvZCB0aGF0IHZlcmlmaWVzIGlmIHRoZXJlIGFyZSBkdXBsaWNhdGVzIGluIHRoZSBzZWdtZW50IHRyZWUuXG4gICAgICAgKiBJZiB0aGVyZSBhcmUgLSBgb25FcnJvcigpYCBpcyBjYWxsZWQuXG4gICAgICAgKi9cbiAgICAgIGNoZWNrRHVwbGljYXRlOiBjaGVja0R1cGxpY2F0ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQcmludHMgY3VycmVudCBzZWdtZW50cyBpbiBvcmRlciBvZiB0aGVpciBpbnRlcnNlY3Rpb24gd2l0aCBzd2VlcCBsaW5lLiBJbnRyb3NwZWN0aW9uIG1ldGhvZC5cbiAgICAgICAqL1xuICAgICAgcHJpbnRTdGF0dXM6IHByaW50U3RhdHVzLFxuXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgc3dlZXAgbGluZS5cbiAgICAgICAqL1xuICAgICAgZ2V0TGFzdFBvaW50OiBmdW5jdGlvbiBnZXRMYXN0UG9pbnQoKSB7XG4gICAgICAgIHJldHVybiB7eDogbGFzdFBvaW50WCwgeTogbGFzdFBvaW50WX07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGFyZVNlZ21lbnRzKGEsIGIpIHtcbiAgICAgIGlmIChhID09PSBiKSB7IHJldHVybiAwOyB9XG5cbiAgICAgIHZhciBhayA9IGdldEludGVyc2VjdGlvblhQb2ludChhLCBsYXN0UG9pbnRYLCBsYXN0UG9pbnRZKTtcbiAgICAgIHZhciBiayA9IGdldEludGVyc2VjdGlvblhQb2ludChiLCBsYXN0UG9pbnRYLCBsYXN0UG9pbnRZKTtcblxuICAgICAgdmFyIHJlcyA9IGFrIC0gYms7XG4gICAgICBpZiAoTWF0aC5hYnMocmVzKSA+PSBFUFMkJDEpIHtcbiAgICAgICAgLy8gV2UgYXJlIG9rYXkgZmluZS4gSW50ZXJzZWN0aW9uIGRpc3RhbmNlIGJldHdlZW4gdHdvIHNlZ21lbnRzXG4gICAgICAgIC8vIGlzIGdvb2QgdG8gZ2l2ZSBjb25jbHVzaXZlIGFuc3dlclxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuXG4gICAgICB2YXIgYUlzSG9yaXpvbnRhbCA9IE1hdGguYWJzKGEuZHkpIDwgRVBTJCQxO1xuICAgICAgdmFyIGJJc0hvcml6b250YWwgPSBNYXRoLmFicyhiLmR5KSA8IEVQUyQkMTtcbiAgICAgIGlmIChhSXNIb3Jpem9udGFsICYmIGJJc0hvcml6b250YWwpIHtcbiAgICAgICAgcmV0dXJuIGIudG8ueCAtIGEudG8ueDtcbiAgICAgIH1cbiAgICAgIC8vIFRPRE86IFdoYXQgaWYgYm90aCBhIGFuZCBiIGlzIGhvcml6b250YWw/XG4gICAgICAvLyBtb3ZlIGhvcml6b250YWwgdG8gZW5kXG4gICAgICBpZiAoYUlzSG9yaXpvbnRhbCkgeyBcbiAgICAgICAgcmV0dXJuIHVzZUJlbG93ID8gLTEgOiAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoYklzSG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAodXNlQmVsb3cpIHtcbiAgICAgICAgICByZXR1cm4gKGIuZnJvbS54ID49IGxhc3RQb2ludFgpID8gLTEgOiAxXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAvLyByZXR1cm4gdXNlQmVsb3cgPyAxIDogLTE7XG4gICAgICB9XG4gICAgICB2YXIgcGEgPSBhLmFuZ2xlO1xuICAgICAgdmFyIHBiID0gYi5hbmdsZTtcbiAgICAgIGlmIChNYXRoLmFicyhwYSAtIHBiKSA+PSBFUFMkJDEpIHtcbiAgICAgICAgcmV0dXJuIHVzZUJlbG93ID8gcGEgLSBwYiA6IHBiIC0gcGE7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWdEaXN0ID0gYS5mcm9tLnkgLSBiLmZyb20ueTtcbiAgICAgIGlmIChNYXRoLmFicyhzZWdEaXN0KSA+PSBFUFMkJDEpIHtcbiAgICAgICAgcmV0dXJuIC1zZWdEaXN0O1xuICAgICAgfVxuICAgICAgc2VnRGlzdCA9IGEudG8ueSAtIGIudG8ueTtcbiAgICAgIGlmIChNYXRoLmFicyhzZWdEaXN0KSA+PSBFUFMkJDEpIHtcbiAgICAgICAgLy8gVE9ETzogSXMgdGhpcyBhY2N1cmF0ZT9cbiAgICAgICAgcmV0dXJuIC1zZWdEaXN0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICAgIC8vIENvdWxkIGFsc28gdXNlOlxuICAgICAgLy8gdmFyIGFBbmdsZSA9IE1hdGguYXRhbjIoYS5mcm9tLnkgLSBhLnRvLnksIGEuZnJvbS54IC0gYS50by54KTtcbiAgICAgIC8vIHZhciBiQW5nbGUgPSBNYXRoLmF0YW4yKGIuZnJvbS55IC0gYi50by55LCBiLmZyb20ueCAtIGIudG8ueCk7XG4gICAgICAvLyByZXR1cm4gdXNlQmVsb3cgPyBiQW5nbGUgLSBhQW5nbGUgOiBhQW5nbGUgLSBiQW5nbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Qm91bmRhcnlTZWdtZW50cyh1cHBlciwgaW50ZXJpb3IpIHtcbiAgICAgIHZhciBsZWZ0TW9zdCwgcmlnaHRNb3N0LCBpO1xuICAgICAgdmFyIHVMZW5ndGggPSB1cHBlci5sZW5ndGg7XG5cbiAgICAgIGlmICh1TGVuZ3RoID4gMCkge1xuICAgICAgICBsZWZ0TW9zdCA9IHJpZ2h0TW9zdCA9IHVwcGVyWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdE1vc3QgPSByaWdodE1vc3QgPSBpbnRlcmlvclswXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMTsgaSA8IHVMZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcyA9IHVwcGVyW2ldO1xuICAgICAgICB2YXIgY21wID0gY29tcGFyZVNlZ21lbnRzKGxlZnRNb3N0LCBzKTtcbiAgICAgICAgaWYgKGNtcCA+IDApIHsgbGVmdE1vc3QgPSBzOyB9XG5cbiAgICAgICAgY21wID0gY29tcGFyZVNlZ21lbnRzKHJpZ2h0TW9zdCwgcyk7XG4gICAgICAgIGlmIChjbXAgPCAwKSB7IHJpZ2h0TW9zdCA9IHM7IH1cbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0RnJvbSA9IHVMZW5ndGggPiAwID8gMCA6IDE7XG4gICAgICBmb3IgKGkgPSBzdGFydEZyb207IGkgPCBpbnRlcmlvci5sZW5ndGg7ICsraSkge1xuICAgICAgICBzID0gaW50ZXJpb3JbaV07XG4gICAgICAgIGNtcCA9IGNvbXBhcmVTZWdtZW50cyhsZWZ0TW9zdCwgcyk7XG4gICAgICAgIGlmIChjbXAgPiAwKSB7IGxlZnRNb3N0ID0gczsgfVxuXG4gICAgICAgIGNtcCA9IGNvbXBhcmVTZWdtZW50cyhyaWdodE1vc3QsIHMpO1xuICAgICAgICBpZiAoY21wIDwgMCkgeyByaWdodE1vc3QgPSBzOyB9XG4gICAgICB9XG5cbiAgICAgIC8vIGF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBvdXIgbGVmdC9yaWdodCBzZWdtZW50cyBpbiB0aGUgc3RhdHVzLlxuICAgICAgLy8gTGV0J3MgZmluZCB0aGVpciBwcmV2L25leHQgZWxlbWVudHMgYW5kIHJlcG9ydCB0aGVtIGJhY2s6XG4gICAgICB2YXIgbGVmdCA9IHN0YXR1cy5maW5kKGxlZnRNb3N0KTtcbiAgICAgIGlmICghbGVmdCkge1xuICAgICAgICBvbkVycm9yKCdMZWZ0IGlzIG1pc3NpbmcuIFByZWNpc2lvbiBlcnJvcj8nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJpZ2h0ID0gc3RhdHVzLmZpbmQocmlnaHRNb3N0KTtcbiAgICAgIGlmICghcmlnaHQpIHtcbiAgICAgICAgb25FcnJvcignUmlnaHQgaXMgbWlzc2luZy4gUHJlY2lzaW9uIGVycm9yPycpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmVmb3JlTGVmdCA9IGxlZnQgJiYgc3RhdHVzLnByZXYobGVmdCk7XG4gICAgICB2YXIgYWZ0ZXJSaWdodCA9IHJpZ2h0ICYmIHN0YXR1cy5uZXh0KHJpZ2h0KTtcblxuICAgICAgd2hpbGUgKGFmdGVyUmlnaHQgJiYgcmlnaHQua2V5LmR5ID09PSAwICYmIGFmdGVyUmlnaHQua2V5LmR5ID09PSAwKSB7XG4gICAgICAgIC8vIGhvcml6b250YWwgc2VnbWVudHMgYXJlIHNwZWNpYWwgOihcbiAgICAgICAgYWZ0ZXJSaWdodCA9IHN0YXR1cy5uZXh0KGFmdGVyUmlnaHQpO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50Qm91bmRhcnkuYmVmb3JlTGVmdCA9IGJlZm9yZUxlZnQgJiYgYmVmb3JlTGVmdC5rZXk7XG4gICAgICBjdXJyZW50Qm91bmRhcnkubGVmdCA9IGxlZnQgJiYgbGVmdC5rZXk7XG4gICAgICBjdXJyZW50Qm91bmRhcnkucmlnaHQgPSByaWdodCAmJiByaWdodC5rZXk7XG4gICAgICBjdXJyZW50Qm91bmRhcnkuYWZ0ZXJSaWdodCA9IGFmdGVyUmlnaHQgJiYgYWZ0ZXJSaWdodC5rZXk7XG5cbiAgICAgIHJldHVybiBjdXJyZW50Qm91bmRhcnk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TGVmdFJpZ2h0UG9pbnQocCkge1xuICAgICAgLy8gV2UgYXJlIHRyeWluZyB0byBmaW5kIGxlZnQgYW5kIHJpZ2h0IHNlZ21lbnRzIHRoYXQgYXJlIG5lYXJlc3QgdG8gdGhlXG4gICAgICAvLyBwb2ludCBwLiBGb3IgdGhpcyB3ZSB0cmF2ZXJzZSB0aGUgYmluYXJ5IHNlYXJjaCB0cmVlLCBhbmQgcmVtZW1iZXJcbiAgICAgIC8vIG5vZGUgd2l0aCB0aGUgc2hvcnRlc3QgZGlzdGFuY2UgdG8gcC5cbiAgICAgIHZhciBsYXN0TGVmdDtcbiAgICAgIHZhciBjdXJyZW50ID0gc3RhdHVzLl9yb290O1xuICAgICAgdmFyIG1pblggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICB2YXIgeCA9IGdldEludGVyc2VjdGlvblhQb2ludChjdXJyZW50LmtleSwgcC54LCBwLnkpO1xuICAgICAgICB2YXIgZHggPSBwLnggLSB4O1xuICAgICAgICBpZiAoZHggPj0gMCkge1xuICAgICAgICAgIGlmIChkeCA8IG1pblgpIHtcbiAgICAgICAgICAgIG1pblggPSBkeDtcbiAgICAgICAgICAgIGxhc3RMZWZ0ID0gY3VycmVudDtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoLWR4IDwgbWluWCkge1xuICAgICAgICAgICAgbWluWCA9IC1keDtcbiAgICAgICAgICAgIGxhc3RMZWZ0ID0gY3VycmVudDtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3VycmVudExlZnRSaWdodC5sZWZ0ID0gbGFzdExlZnQgJiYgbGFzdExlZnQua2V5O1xuICAgICAgdmFyIG5leHQgPSBsYXN0TGVmdCAmJiBzdGF0dXMubmV4dChsYXN0TGVmdCk7XG4gICAgICBjdXJyZW50TGVmdFJpZ2h0LnJpZ2h0ID0gbmV4dCAmJiBuZXh0LmtleTtcbiAgICAgIHJldHVybiBjdXJyZW50TGVmdFJpZ2h0O1xuXG4gICAgICAvLyBDb25jZXB0dWFsbHksIHRoZSBjb2RlIGFib3ZlIHNob3VsZCBiZSBlcXVpdmFsZW50IHRvIHRoZSBjb2RlIGJlbG93O1xuICAgICAgLy8gVGhlIGNvZGUgYmVsb3cgaXMgZWFzaWVyIHRvIHVuZGVyc3RhbmQsIGJ1dCBpbnR1aXRpdmVseSwgdGhlIGNvZGUgYWJvdmVcbiAgICAgIC8vIHNob3VsZCBoYXZlIGJldHRlciBwZXJmb3JtYW5jZSAoYXMgd2UgZG8gbm90IHRyYXZlcnNlIHRoZSBlbnRpcmUgc3RhdHVzXG4gICAgICAvLyB0cmVlKVxuXG4gICAgICAvLyB2YXIgcmlnaHQsIGxlZnQsICB4O1xuICAgICAgLy8gdmFyIGFsbCA9IHN0YXR1cy5rZXlzKClcbiAgICAgIC8vIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgKytpKSB7XG4gICAgICAvLyAgIHZhciBzZWdtZW50ID0gYWxsW2ldO1xuICAgICAgLy8gICB4ID0gZ2V0SW50ZXJzZWN0aW9uWFBvaW50KHNlZ21lbnQsIHAueCwgcC55KTtcbiAgICAgIC8vICAgaWYgKHggPiBwLnggJiYgIXJpZ2h0KSB7XG4gICAgICAvLyAgICAgcmlnaHQgPSBzZWdtZW50O1xuICAgICAgLy8gICAgIGJyZWFrO1xuICAgICAgLy8gICB9IGVsc2UgaWYgKHggPCBwLngpIHtcbiAgICAgIC8vICAgICBsZWZ0ID0gc2VnbWVudDtcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfVxuXG4gICAgICAvLyBjdXJyZW50TGVmdFJpZ2h0LmxlZnQgPSBsZWZ0O1xuICAgICAgLy8gY3VycmVudExlZnRSaWdodC5yaWdodCA9IHJpZ2h0O1xuXG4gICAgICAvLyByZXR1cm4gY3VycmVudExlZnRSaWdodDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kU2VnbWVudHNXaXRoUG9pbnQocCwgb25Gb3VuZCkge1xuICAgICAgLy8gT3B0aW9uIDEuXG4gICAgICAvLyB2YXIgYXJyUmVzdWx0cyA9IFtdO1xuICAgICAgLy8gc3RhdHVzLmZvckVhY2goY3VycmVudCA9PiB7XG4gICAgICAvLyAgIHZhciB4ID0gZ2V0SW50ZXJzZWN0aW9uWFBvaW50KGN1cnJlbnQua2V5LCBwLngsIHAueSk7XG4gICAgICAvLyAgIHZhciBkeCA9IHAueCAtIHg7XG4gICAgICAvLyAgIGlmIChNYXRoLmFicyhkeCkgPCBFUFMpIHtcbiAgICAgIC8vICAgICBvbkZvdW5kKGN1cnJlbnQua2V5KTtcbiAgICAgIC8vICAgIC8vIGFyclJlc3VsdHMucHVzaChjdXJyZW50LmtleSlcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfSk7XG4gICAgICAvLyByZXR1cm4gYXJyUmVzdWx0cztcblxuICAgICAgLy8gT3B0aW9uIDIuXG5cbiAgICAgIC8vIGxldCBjdXJyZW50ID0gc3RhdHVzLl9yb290O1xuICAgICAgLy8gY29uc3QgUSA9IFtdOyAgLyogSW5pdGlhbGl6ZSBzdGFjayBzICovXG4gICAgICAvLyBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgLy8gdmFyIHJlcyA9IFtdO1xuICAgICAgLy8gdmFyIGJyZWFrRWFybHkgPSBmYWxzZTtcblxuICAgICAgLy8gd2hpbGUgKCFkb25lKSB7XG4gICAgICAvLyAgIGlmIChjdXJyZW50ICE9PSAgbnVsbCkge1xuICAgICAgLy8gICAgIFEucHVzaChjdXJyZW50KTtcbiAgICAgIC8vICAgICBjdXJyZW50ID0gY3VycmVudC5sZWZ0O1xuICAgICAgLy8gICB9IGVsc2Uge1xuICAgICAgLy8gICAgIGlmIChRLmxlbmd0aCAhPT0gMCkge1xuICAgICAgLy8gICAgICAgY3VycmVudCA9IFEucG9wKCk7XG5cbiAgICAgIC8vICAgICAgIHZhciB4ID0gZ2V0SW50ZXJzZWN0aW9uWFBvaW50KGN1cnJlbnQua2V5LCBwLngsIHAueSk7XG4gICAgICAvLyAgICAgICB2YXIgZHggPSBwLnggLSB4O1xuICAgICAgLy8gICAgICAgaWYgKE1hdGguYWJzKGR4KSA8IEVQUykge1xuICAgICAgLy8gICAgICAgICByZXMucHVzaChjdXJyZW50LmtleSlcbiAgICAgIC8vICAgICAgICAgYnJlYWtFYXJseSA9IHRydWU7XG4gICAgICAvLyAgICAgICB9IGVsc2UgaWYgKGJyZWFrRWFybHkpIHtcbiAgICAgIC8vICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAvLyAgICAgICB9XG5cbiAgICAgIC8vICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJpZ2h0O1xuICAgICAgLy8gICAgIH0gZWxzZSBkb25lID0gdHJ1ZTtcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfVxuXG4gICAgICAvLyByZXR1cm4gcmVzO1xuXG4gICAgICAvLyBvcHRpb24gMy5cbiAgICAgIHZhciBjdXJyZW50ID0gc3RhdHVzLl9yb290O1xuXG4gICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICB2YXIgeCA9IGdldEludGVyc2VjdGlvblhQb2ludChjdXJyZW50LmtleSwgcC54LCBwLnkpO1xuICAgICAgICB2YXIgZHggPSBwLnggLSB4O1xuICAgICAgICBpZiAoTWF0aC5hYnMoZHgpIDwgRVBTJCQxKSB7XG4gICAgICAgICAgY29sbGVjdEFkamFjZW50Tm9kZXMoY3VycmVudCwgcCwgb25Gb3VuZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoZHggPCAwKSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbGxlY3RBZGphY2VudE5vZGVzKHJvb3QsIHAsIG9uRm91bmQpIHtcbiAgICAgIG9uRm91bmQocm9vdC5rZXkpO1xuICAgICAgZ29PdmVyUHJlZGVjZXNzb3JzKHJvb3QubGVmdCwgcCwgb25Gb3VuZCk7XG4gICAgICBnb092ZXJTdWNjZXNzb3JzKHJvb3QucmlnaHQsIHAsIG9uRm91bmQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdvT3ZlclByZWRlY2Vzc29ycyhyb290LCBwLCByZXMpIHtcbiAgICAgIGlmICghcm9vdCkgeyByZXR1cm47IH1cbiAgICAgIHZhciB4ID0gZ2V0SW50ZXJzZWN0aW9uWFBvaW50KHJvb3Qua2V5LCBwLngsIHAueSk7XG4gICAgICB2YXIgZHggPSBwLnggLSB4O1xuICAgICAgaWYgKE1hdGguYWJzKGR4KSA8IEVQUyQkMSkge1xuICAgICAgICBjb2xsZWN0QWRqYWNlbnROb2Rlcyhyb290LCBwLCByZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ29PdmVyUHJlZGVjZXNzb3JzKHJvb3QucmlnaHQsIHAsIHJlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ29PdmVyU3VjY2Vzc29ycyhyb290LCBwLCByZXMpIHtcbiAgICAgIGlmICghcm9vdCkgeyByZXR1cm47IH1cbiAgICAgIHZhciB4ID0gZ2V0SW50ZXJzZWN0aW9uWFBvaW50KHJvb3Qua2V5LCBwLngsIHAueSk7XG4gICAgICB2YXIgZHggPSBwLnggLSB4O1xuICAgICAgaWYgKE1hdGguYWJzKGR4KSA8IEVQUyQkMSkge1xuICAgICAgICBjb2xsZWN0QWRqYWNlbnROb2Rlcyhyb290LCBwLCByZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ29PdmVyU3VjY2Vzc29ycyhyb290LmxlZnQsIHAsIHJlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGUoKSB7XG4gICAgICB2YXIgcHJldjtcbiAgICAgIHN0YXR1cy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbm9kZS5rZXk7XG5cbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICBpZiAoc2FtZVBvaW50KHByZXYuZnJvbSwgY3VycmVudC5mcm9tKSAmJiBzYW1lUG9pbnQocHJldi50bywgY3VycmVudC50bykpIHtcbiAgICAgICAgICAgIC8vIExpa2VseSB5b3UgaGF2ZSByZWNlaXZlZCBlcnJvciBiZWZvcmUgZHVyaW5nIHNlZ21lbnQgcmVtb3ZhbC5cbiAgICAgICAgICAgIG9uRXJyb3IoJ0R1cGxpY2F0ZSBrZXkgaW4gdGhlIHN0YXR1cyEgVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IEZsb2F0aW5nIFBvaW50IHJvdW5kaW5nIGVycm9yJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByZXYgPSBjdXJyZW50O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJpbnRTdGF0dXMocHJlZml4KSB7XG4gICAgICBpZiAoIHByZWZpeCA9PT0gdm9pZCAwICkgcHJlZml4ID0gJyc7XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgY29uc29sZS5sb2cocHJlZml4LCAnc3RhdHVzIGxpbmU6ICcsIGxhc3RQb2ludFgsIGxhc3RQb2ludFkpO1xuICAgICAgc3RhdHVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIHggPSBnZXRJbnRlcnNlY3Rpb25YUG9pbnQobm9kZS5rZXksIGxhc3RQb2ludFgsIGxhc3RQb2ludFkpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgY29uc29sZS5sb2coeCArICcgJyArIG5vZGUua2V5Lm5hbWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zZXJ0U2VnbWVudHMoaW50ZXJpb3IsIHVwcGVyLCBzd2VlcExpbmVQb3MpIHtcbiAgICAgIGxhc3RQb2ludFkgPSBzd2VlcExpbmVQb3MueTtcbiAgICAgIGxhc3RQb2ludFggPSBzd2VlcExpbmVQb3MueDtcbiAgICAgIHZhciBrZXk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50ZXJpb3IubGVuZ3RoOyArK2kpIHtcbiAgICAgICAga2V5ID0gaW50ZXJpb3JbaV07XG4gICAgICAgIHN0YXR1cy5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB1cHBlci5sZW5ndGg7ICsraSkge1xuICAgICAgICBrZXkgPSB1cHBlcltpXTtcbiAgICAgICAgc3RhdHVzLmFkZChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlbGV0ZVNlZ21lbnRzKGxvd2VyLCBpbnRlcmlvciwgc3dlZXBMaW5lUG9zKSB7XG4gICAgICAvLyBJIHNwZW50IG1vc3Qgb2YgdGhlIHRpbWUgZGVidWdnaW5nIHRoaXMgbWV0aG9kLiBEZXBlbmRpbmcgb24gdGhlXG4gICAgICAvLyBhbGdvcml0aG0gc3RhdGUgd2UgY2FuIHJ1biBpbnRvIHNpdHVhdGlvbiB3aGVuIGR5bmFtaWMga2V5cyBvZiB0aGVcbiAgICAgIC8vIGBzdGF0dXNgIHRyZWUgcHJlZGljdCB3cm9uZyBicmFuY2gsIGFuZCB0aHVzIHdlIGFyZSBub3QgYWJsZSB0byBmaW5kXG4gICAgICAvLyB0aGUgc2VnbWVudCB0aGF0IG5lZWRzIHRvIGJlIGRlbGV0ZWQuIElmIHRoYXQgaGFwcGVucyBJJ20gdHJ5aW5nIHRvXG4gICAgICAvLyB1c2UgcHJldmlvdXMgcG9pbnQgYW5kIHJlcGVhdCB0aGUgcHJvY2Vzcy4gVGhpcyBtYXkgcmVzdWx0IGluIFxuICAgICAgLy8gaW5jb3JyZWN0IHN0YXRlLiBJbiB0aGF0IGNhc2UgSSByZXBvcnQgYW4gZXJyb3IuIFxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgcHJldkNvdW50ID0gc3RhdHVzLl9zaXplO1xuICAgICAgcHJldlggPSBsYXN0UG9pbnRYO1xuICAgICAgcHJldlkgPSBsYXN0UG9pbnRZO1xuICAgICAgbGFzdFBvaW50WSA9IHN3ZWVwTGluZVBvcy55O1xuICAgICAgbGFzdFBvaW50WCA9IHN3ZWVwTGluZVBvcy54O1xuXG4gICAgICB1c2VCZWxvdyA9IHRydWU7XG4gICAgICBmb3IoaSA9IDA7IGkgPCBsb3dlci5sZW5ndGg7ICsraSkge1xuICAgICAgICByZW1vdmVTZWdtZW50KGxvd2VyW2ldLCBzd2VlcExpbmVQb3MpO1xuICAgICAgfVxuICAgICAgZm9yKGkgPSAwOyBpIDwgaW50ZXJpb3IubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcmVtb3ZlU2VnbWVudChpbnRlcmlvcltpXSwgc3dlZXBMaW5lUG9zKTtcbiAgICAgIH1cbiAgICAgIHVzZUJlbG93ID0gZmFsc2U7XG5cbiAgICAgIGlmIChzdGF0dXMuX3NpemUgIT09IHByZXZDb3VudCAtIGludGVyaW9yLmxlbmd0aCAtIGxvd2VyLmxlbmd0aCkge1xuICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiByb3VuZGluZyBlcnJvciBvY2N1cnMuIFlvdSBjYW4gdHJ5IHNjYWxpbmcgeW91ciBpbnB1dFxuICAgICAgICBvbkVycm9yKCdTZWdtZW50cyB3ZXJlIG5vdCByZW1vdmVkIGZyb20gYSB0cmVlIHByb3Blcmx5LiBQcmVjaXNpb24gZXJyb3I/Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlU2VnbWVudChrZXksIHN3ZWVwTGluZVBvcykge1xuICAgICAgaWYgKHN0YXR1cy5maW5kKGtleSkpIHtcbiAgICAgICAgc3RhdHVzLnJlbW92ZShrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdFBvaW50WCA9IHByZXZYO1xuICAgICAgICBsYXN0UG9pbnRZID0gcHJldlk7XG4gICAgICAgIGlmIChzdGF0dXMuZmluZChrZXkpKSB7XG4gICAgICAgICAgc3RhdHVzLnJlbW92ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQb2ludFkgPSBzd2VlcExpbmVQb3MueTtcbiAgICAgICAgbGFzdFBvaW50WCA9IHN3ZWVwTGluZVBvcy54O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgc2luZ2xlIGV2ZW50IGluIHRoZSBzd2VlcC1saW5lIGFsZ29yaXRobVxuICAgKi9cbiAgdmFyIFN3ZWVwRXZlbnQgPSBmdW5jdGlvbiBTd2VlcEV2ZW50KHBvaW50LCBzZWdtZW50KSB7XG4gICAgdGhpcy5wb2ludCA9IHBvaW50O1xuICAgIGlmIChzZWdtZW50KSB7IHRoaXMuZnJvbSA9IFtzZWdtZW50XTsgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBIHBvaW50IG9uIGEgbGluZVxuICAgKiBcbiAgICogQHR5cGVkZWYge09iamVjdH0gUG9pbnRcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHggY29vcmRpbmF0ZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0geSBjb29yZGluYXRlXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IFNlZ21lbnQgXG4gICAqIEBwcm9wZXJ0eSB7UG9pbnR9IGZyb20gc3RhcnQgb2YgdGhlIHNlZ21lbnRcbiAgICogQHByb3BlcnR5IHtQb2ludH0gdG8gZW5kIG9mIHRoZSBzZWdtZW50XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7ZnVuY3Rpb24ocG9pbnQgOiBQb2ludCwgaW50ZXJpb3IgOiBTZWdtZW50W10sIGxvd2VyIDogU2VnbWVudFtdLCB1cHBlciA6IFNlZ21lbnRbXSl9IFJlcG9ydEludGVyc2VjdGlvbkNhbGxiYWNrXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBJU2VjdE9wdGlvbnMgXG4gICAqIEBwcm9wZXJ0eSB7UmVwb3J0SW50ZXJzZWN0aW9uQ2FsbGJhY2t9IG9uRm91bmQgXG4gICAqL1xuXG4gICAvKipcbiAgICAqIEB0eXBlZGVmIHtPYmplY3R9IElTZWN0UmVzdWx0XG4gICAgKi9cblxuICAvLyBXZSB1c2UgRU1QVFkgYXJyYXkgdG8gYXZvaWQgcHJlc3N1cmUgb24gZ2FyYmFnZSBjb2xsZWN0b3IuIE5lZWQgdG8gYmVcbiAgLy8gdmVyeSBjYXV0aW91cyB0byBub3QgbXV0YXRlIHRoaXMgYXJyYXkuXG4gIHZhciBFTVBUWSA9IFtdO1xuXG4gIC8qKlxuICAgKiBGaW5kcyBhbGwgaW50ZXJzZWN0aW9ucyBhbW9uZyBnaXZlbiBzZWdtZW50cy5cbiAgICogXG4gICAqIFRoZSBhbGdvcml0aG0gZm9sbG93cyBcIkNvbXB1dGF0aW9uIEdlb21ldHJ5LCBBbGdvcml0aG1zIGFuZCBBcHBsaWNhdGlvbnNcIiBib29rXG4gICAqIGJ5IE1hcmsgZGUgQmVyZywgT3RmcmllZCBDaGVvbmcsIE1hcmMgdmFuIEtyZXZlbGQsIGFuZCBNYXJrIE92ZXJtYXJzLlxuICAgKiBcbiAgICogTGluZSBpcyBzd2VwdCB0b3AtZG93blxuICAgKiBcbiAgICogQHBhcmFtIHtTZWdtZW50W119IHNlZ21lbnRzXG4gICAqIEBwYXJhbSB7SVNlY3RPcHRpb25zPX0gb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7SVNlY3RSZXN1bHR9XG4gICAqL1xuICBmdW5jdGlvbiBpc2VjdChzZWdtZW50cywgb3B0aW9ucykge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdmFyIHJlcG9ydEludGVyc2VjdGlvbiA9IChvcHRpb25zICYmIG9wdGlvbnMub25Gb3VuZCkgfHwgZGVmYXVsdEludGVyc2VjdGlvblJlcG9ydGVyO1xuXG4gICAgdmFyIG9uRXJyb3IgPSAob3B0aW9ucyAmJiBvcHRpb25zLm9uRXJyb3IpIHx8IGRlZmF1bHRFcnJvclJlcG9ydGVyO1xuXG4gICAgdmFyIGV2ZW50UXVldWUgPSBjcmVhdGVFdmVudFF1ZXVlKGJ5WSk7XG4gICAgdmFyIHN3ZWVwU3RhdHVzID0gY3JlYXRlU3dlZXBTdGF0dXMob25FcnJvciwgRVBTKTtcbiAgICB2YXIgbG93ZXIsIGludGVyaW9yLCBsYXN0UG9pbnQ7XG5cbiAgICBzZWdtZW50cy5mb3JFYWNoKGFkZFNlZ21lbnQpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogRmluZCBhbGwgaW50ZXJzZWN0aW9ucyBzeW5jaHJvbm91c2x5LlxuICAgICAgICogXG4gICAgICAgKiBAcmV0dXJucyBhcnJheSBvZiBmb3VuZCBpbnRlcnNlY3Rpb25zLlxuICAgICAgICovXG4gICAgICBydW46IHJ1bixcblxuICAgICAgLyoqXG4gICAgICAgKiBQZXJmb3JtcyBhIHNpbmdsZSBzdGVwIGluIHRoZSBzd2VlcCBsaW5lIGFsZ29yaXRobVxuICAgICAgICogXG4gICAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZXJlIHdhcyBzb21ldGhpbmcgdG8gcHJvY2VzczsgRmFsc2UgaWYgbm8gbW9yZSB3b3JrIHRvIGRvXG4gICAgICAgKi9cbiAgICAgIHN0ZXA6IHN0ZXAsXG5cbiAgICAgIC8vIE1ldGhvZHMgYmVsb3cgYXJlIGxvdyBsZXZlbCBBUEkgZm9yIGZpbmUtZ3JhaW5lZCBjb250cm9sLlxuICAgICAgLy8gRG9uJ3QgdXNlIGl0IHVubGVzcyB5b3UgdW5kZXJzdGFuZCB0aGlzIGNvZGUgdGhvcm91Z2hseVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZCBzZWdtZW50IGludG8gdGhlIFxuICAgICAgICovXG4gICAgICBhZGRTZWdtZW50OiBhZGRTZWdtZW50LFxuXG4gICAgICAvKipcbiAgICAgICAqIERpcmVjdCBhY2Nlc3MgdG8gZXZlbnQgcXVldWUuIFF1ZXVlIGNvbnRhaW5zIHNlZ21lbnQgZW5kcG9pbnRzIGFuZFxuICAgICAgICogcGVuZGluZyBkZXRlY3RlZCBpbnRlcnNlY3Rpb25zLlxuICAgICAgICovXG4gICAgICBldmVudFF1ZXVlOiBldmVudFF1ZXVlLCBcblxuICAgICAgLyoqXG4gICAgICAgKiBEaXJlY3QgYWNjZXNzIHRvIHN3ZWVwIGxpbmUgc3RhdHVzLiBcIlN0YXR1c1wiIGhvbGRzIGluZm9ybWF0aW9uIGFib3V0XG4gICAgICAgKiBhbGwgaW50ZXJzZWN0ZWQgc2VnbWVudHMuXG4gICAgICAgKi9cbiAgICAgIHN3ZWVwU3RhdHVzOiBzd2VlcFN0YXR1cyxcblxuICAgICAgLyoqXG4gICAgICAgKiBBY2Nlc3MgdG8gcmVzdWx0cyBhcnJheS4gV29ya3Mgb25seSB3aGVuIHlvdSB1c2UgZGVmYXVsdCBvbkZvdW5kKCkgaGFuZGxlclxuICAgICAgICovXG4gICAgICByZXN1bHRzOiByZXN1bHRzXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKCkge1xuICAgICAgd2hpbGUgKCFldmVudFF1ZXVlLmlzRW1wdHkoKSkge1xuICAgICAgICB2YXIgZXZlbnRQb2ludCA9IGV2ZW50UXVldWUucG9wKCk7XG4gICAgICAgIGlmIChoYW5kbGVFdmVudFBvaW50KGV2ZW50UG9pbnQpKSB7XG4gICAgICAgICAgLy8gdGhleSBkZWNpZGVkIHRvIHN0b3AuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9ICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgIGlmICghZXZlbnRRdWV1ZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgdmFyIGV2ZW50UG9pbnQgPSBldmVudFF1ZXVlLnBvcCgpO1xuICAgICAgICBoYW5kbGVFdmVudFBvaW50KGV2ZW50UG9pbnQpO1xuICAgICAgICAvLyBOb3RlOiB3ZSBkb24ndCBjaGVjayByZXN1bHRzIG9mIGBoYW5kbGVFdmVudFBvaW50KClgXG4gICAgICAgIC8vIGFzc3VtcHRpb24gaXMgdGhhdCBjbGllbnQgY29udHJvbHMgYHN0ZXAoKWAgYW5kIHRodXMgdGhleSBcbiAgICAgICAgLy8ga25vdyBiZXR0ZXIgaWYgdGhleSB3YW50IHRvIHN0b3AuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZUV2ZW50UG9pbnQocCkge1xuICAgICAgbGFzdFBvaW50ID0gcC5wb2ludDtcbiAgICAgIHZhciB1cHBlciA9IHAuZnJvbSB8fCBFTVBUWTtcblxuICAgICAgbG93ZXIgPSBpbnRlcmlvciA9IHVuZGVmaW5lZDtcbiAgICAgIC8vIFRPRE86IG1vdmUgbG93ZXIvaW50ZXJpb3IgaW50byBzd2VlcCBzdGF0dXMgbWV0aG9kP1xuXG4gICAgICBzd2VlcFN0YXR1cy5maW5kU2VnbWVudHNXaXRoUG9pbnQobGFzdFBvaW50LCBhZGRMb3dlck9ySW50ZXJpb3IpO1xuICAgICAgLy8gaWYgKHNlZ21lbnRzV2l0aFBvaW50KSB7XG4gICAgICAvLyAgIHNlZ21lbnRzV2l0aFBvaW50LmZvckVhY2goKVxuICAgICAgLy8gfSBcblxuICAgICAgaWYgKCFsb3dlcikgeyBsb3dlciA9IEVNUFRZOyB9XG4gICAgICBpZiAoIWludGVyaW9yKSB7IGludGVyaW9yID0gRU1QVFk7IH1cblxuICAgICAgdmFyIHVMZW5ndGggPSB1cHBlci5sZW5ndGg7XG4gICAgICB2YXIgaUxlbmd0aCA9IGludGVyaW9yLmxlbmd0aDtcbiAgICAgIHZhciBsTGVuZ3RoID0gbG93ZXIubGVuZ3RoO1xuICAgICAgdmFyIGhhc0ludGVyc2VjdGlvbiA9IHVMZW5ndGggKyBpTGVuZ3RoICsgbExlbmd0aCA+IDE7XG4gICAgICB2YXIgaGFzUG9pbnRJbnRlcnNlY3Rpb24gPSAhaGFzSW50ZXJzZWN0aW9uICYmICh1TGVuZ3RoID09PSAwICYmIGxMZW5ndGggPT09IDAgJiYgaUxlbmd0aCA+IDApO1xuXG4gICAgICBpZiAoaGFzSW50ZXJzZWN0aW9uIHx8IGhhc1BvaW50SW50ZXJzZWN0aW9uKSB7XG4gICAgICAgIHAuaXNSZXBvcnRlZCA9IHRydWU7XG4gICAgICAgIGlmIChyZXBvcnRJbnRlcnNlY3Rpb24obGFzdFBvaW50LCB1bmlvbihpbnRlcmlvciwgdW5pb24obG93ZXIsIHVwcGVyKSkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dlZXBTdGF0dXMuZGVsZXRlU2VnbWVudHMobG93ZXIsIGludGVyaW9yLCBsYXN0UG9pbnQpO1xuICAgICAgc3dlZXBTdGF0dXMuaW5zZXJ0U2VnbWVudHMoaW50ZXJpb3IsIHVwcGVyLCBsYXN0UG9pbnQpO1xuXG4gICAgICB2YXIgc0xlZnQsIHNSaWdodDtcblxuICAgICAgdmFyIGhhc05vQ3Jvc3NpbmcgPSAodUxlbmd0aCArIGlMZW5ndGggPT09IDApO1xuXG4gICAgICBpZiAoaGFzTm9Dcm9zc2luZykge1xuICAgICAgICB2YXIgbGVmdFJpZ2h0ID0gc3dlZXBTdGF0dXMuZ2V0TGVmdFJpZ2h0UG9pbnQobGFzdFBvaW50KTtcbiAgICAgICAgc0xlZnQgPSBsZWZ0UmlnaHQubGVmdDtcbiAgICAgICAgaWYgKCFzTGVmdCkgeyByZXR1cm47IH1cblxuICAgICAgICBzUmlnaHQgPSBsZWZ0UmlnaHQucmlnaHQ7XG4gICAgICAgIGlmICghc1JpZ2h0KSB7IHJldHVybjsgfVxuXG4gICAgICAgIGZpbmROZXdFdmVudChzTGVmdCwgc1JpZ2h0LCBwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBib3VuZGFyeVNlZ21lbnRzID0gc3dlZXBTdGF0dXMuZ2V0Qm91bmRhcnlTZWdtZW50cyh1cHBlciwgaW50ZXJpb3IpO1xuXG4gICAgICAgIGZpbmROZXdFdmVudChib3VuZGFyeVNlZ21lbnRzLmJlZm9yZUxlZnQsIGJvdW5kYXJ5U2VnbWVudHMubGVmdCwgcCk7XG4gICAgICAgIGZpbmROZXdFdmVudChib3VuZGFyeVNlZ21lbnRzLnJpZ2h0LCBib3VuZGFyeVNlZ21lbnRzLmFmdGVyUmlnaHQsIHApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkTG93ZXJPckludGVyaW9yKHMpIHtcbiAgICAgIGlmIChzYW1lUG9pbnQocy50bywgbGFzdFBvaW50KSkge1xuICAgICAgICBpZiAoIWxvd2VyKSB7IGxvd2VyID0gW3NdOyB9XG4gICAgICAgIGVsc2UgeyBsb3dlci5wdXNoKHMpOyB9XG4gICAgICB9IGVsc2UgaWYgKCFzYW1lUG9pbnQocy5mcm9tLCBsYXN0UG9pbnQpKSB7XG4gICAgICAgIGlmICghaW50ZXJpb3IpIHsgaW50ZXJpb3IgPSBbc107IH1cbiAgICAgICAgZWxzZSB7IGludGVyaW9yLnB1c2gocyk7IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kTmV3RXZlbnQobGVmdCwgcmlnaHQsIHApIHtcbiAgICAgIGlmICghbGVmdCB8fCAhcmlnaHQpIHsgcmV0dXJuOyB9XG5cbiAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RTZWdtZW50cyhsZWZ0LCByaWdodCk7XG4gICAgICBpZiAoIWludGVyc2VjdGlvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGR5ID0gcC5wb2ludC55IC0gaW50ZXJzZWN0aW9uLnk7XG4gICAgICAvLyBUT0RPOiBzaG91bGQgSSBhZGQgZHkgdG8gaW50ZXJzZWN0aW9uLnk/XG4gICAgICBpZiAoZHkgPCAtRVBTKSB7XG4gICAgICAgIC8vIHRoaXMgbWVhbnMgaW50ZXJzZWN0aW9uIGhhcHBlbmVkIGFmdGVyIHRoZSBzd2VlcCBsaW5lLiBcbiAgICAgICAgLy8gV2UgYWxyZWFkeSBwcm9jZXNzZWQgaXQuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChNYXRoLmFicyhkeSkgPCBFUFMgJiYgaW50ZXJzZWN0aW9uLnggPD0gcC5wb2ludC54KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTmVlZCB0byBhZGp1c3QgZmxvYXRpbmcgcG9pbnQgZm9yIHRoaXMgc3BlY2lhbCBjYXNlLFxuICAgICAgLy8gc2luY2Ugb3RoZXJ3aXNlIGl0IGdpdmVzIHJvdW5kaW5nIGVycm9yczpcbiAgICAgIHJvdW5kTmVhclplcm8oaW50ZXJzZWN0aW9uKTtcblxuICAgICAgdmFyIGN1cnJlbnQgPSBldmVudFF1ZXVlLmZpbmQoaW50ZXJzZWN0aW9uKTtcblxuICAgICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudC5pc1JlcG9ydGVkKSB7XG4gICAgICAgIC8vIFdlIGFscmVhZHkgcmVwb3J0ZWQgdGhpcyBldmVudC4gTm8gbmVlZCB0byBhZGQgaXQgb25lIG1vcmUgdGltZVxuICAgICAgICAvLyBUT0RPOiBJcyB0aGlzIGNhc2UgZXZlbiBwb3NzaWJsZT9cbiAgICAgICAgb25FcnJvcignV2UgYWxyZWFkeSByZXBvcnRlZCB0aGlzIGV2ZW50LicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgU3dlZXBFdmVudChpbnRlcnNlY3Rpb24pO1xuICAgICAgICBldmVudFF1ZXVlLmluc2VydChldmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdEludGVyc2VjdGlvblJlcG9ydGVyKHAsIHNlZ21lbnRzKSB7XG4gICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICBwb2ludDogcCwgXG4gICAgICAgIHNlZ21lbnRzOiBzZWdtZW50c1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkU2VnbWVudChzZWdtZW50KSB7XG4gICAgICB2YXIgZnJvbSA9IHNlZ21lbnQuZnJvbTtcbiAgICAgIHZhciB0byA9IHNlZ21lbnQudG87XG5cbiAgICAgIC8vIFNtYWxsIG51bWJlcnMgZ2l2ZSBtb3JlIHByZWNpc2lvbiBlcnJvcnMuIFJvdW5kaW5nIHRoZW0gdG8gMC5cbiAgICAgIHJvdW5kTmVhclplcm8oZnJvbSk7XG4gICAgICByb3VuZE5lYXJaZXJvKHRvKTtcblxuICAgICAgdmFyIGR5ID0gZnJvbS55IC0gdG8ueTtcblxuICAgICAgLy8gTm90ZTogZHkgaXMgbXVjaCBzbWFsbGVyIHRoZW4gRVBTIG9uIHB1cnBvc2UuIEkgZm91bmQgdGhhdCBoaWdoZXJcbiAgICAgIC8vIHByZWNpc2lvbiBoZXJlIGRvZXMgbGVzcyBnb29kIC0gZ2V0dGluZyB3YXkgbW9yZSByb3VuZGluZyBlcnJvcnMuXG4gICAgICBpZiAoTWF0aC5hYnMoZHkpIDwgMWUtNSkge1xuICAgICAgICBmcm9tLnkgPSB0by55O1xuICAgICAgICBzZWdtZW50LmR5ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICgoZnJvbS55IDwgdG8ueSkgfHwgKFxuICAgICAgICAgIChmcm9tLnkgPT09IHRvLnkpICYmIChmcm9tLnggPiB0by54KSlcbiAgICAgICAgKSB7XG4gICAgICAgIHZhciB0ZW1wID0gZnJvbTtcbiAgICAgICAgZnJvbSA9IHNlZ21lbnQuZnJvbSA9IHRvOyBcbiAgICAgICAgdG8gPSBzZWdtZW50LnRvID0gdGVtcDtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgcHJlLWNvbXB1dGUgc29tZSBpbW11dGFibGUgcHJvcGVydGllcyBvZiB0aGUgc2VnbWVudFxuICAgICAgLy8gVGhleSBhcmUgdXNlZCBxdWl0ZSBvZnRlbiBpbiB0aGUgdHJlZSB0cmF2ZXJzYWwsIGFuZCBwcmUtY29tcHV0YXRpb25cbiAgICAgIC8vIGdpdmVzIHNpZ25pZmljYW50IGJvb3N0OlxuICAgICAgc2VnbWVudC5keSA9IGZyb20ueSAtIHRvLnk7XG4gICAgICBzZWdtZW50LmR4ID0gZnJvbS54IC0gdG8ueDtcbiAgICAgIHNlZ21lbnQuYW5nbGUgPSBhbmdsZShzZWdtZW50LmR5LCBzZWdtZW50LmR4KTtcblxuICAgICAgdmFyIGlzUG9pbnQgPSBzZWdtZW50LmR5ID09PSBzZWdtZW50LmR4ICYmIHNlZ21lbnQuZHkgPT09IDA7XG4gICAgICB2YXIgcHJldiA9IGV2ZW50UXVldWUuZmluZChmcm9tKTtcbiAgICAgIGlmIChwcmV2ICYmICFpc1BvaW50KSB7XG4gICAgICAgIC8vIHRoaXMgZGV0ZWN0cyBpZGVudGljYWwgc2VnbWVudHMgZWFybHkuIFdpdGhvdXQgdGhpcyBjaGVja1xuICAgICAgICAvLyB0aGUgYWxnb3JpdGhtIHdvdWxkIGJyZWFrIHNpbmNlIHN3ZWVwIGxpbmUgaGFzIG5vIG1lYW5zIHRvXG4gICAgICAgIC8vIGRldGVjdCBpZGVudGljYWwgc2VnbWVudHMuXG4gICAgICAgIHZhciBwcmV2RnJvbSA9IHByZXYuZGF0YS5mcm9tO1xuICAgICAgICBpZiAocHJldkZyb20pIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZGcm9tLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHByZXZGcm9tW2ldO1xuICAgICAgICAgICAgaWYgKHNhbWVQb2ludChzLnRvLCB0bykpIHtcbiAgICAgICAgICAgICAgcmVwb3J0SW50ZXJzZWN0aW9uKHMuZnJvbSwgW3MuZnJvbSwgcy50b10pO1xuICAgICAgICAgICAgICByZXBvcnRJbnRlcnNlY3Rpb24ocy50bywgW3MuZnJvbSwgcy50b10pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNQb2ludCkge1xuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgIGlmIChwcmV2LmRhdGEuZnJvbSkgeyBwcmV2LmRhdGEuZnJvbS5wdXNoKHNlZ21lbnQpOyB9XG4gICAgICAgICAgZWxzZSB7IHByZXYuZGF0YS5mcm9tID0gW3NlZ21lbnRdOyB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGUgPSBuZXcgU3dlZXBFdmVudChmcm9tLCBzZWdtZW50KTtcbiAgICAgICAgICBldmVudFF1ZXVlLmluc2VydChlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgU3dlZXBFdmVudCh0byk7XG4gICAgICAgIGV2ZW50UXVldWUuaW5zZXJ0KGV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBTd2VlcEV2ZW50KHRvKTtcbiAgICAgICAgZXZlbnRRdWV1ZS5pbnNlcnQoZXZlbnQpO1xuICAgICAgfVxuICAgIH0gXG4gIH1cblxuICBmdW5jdGlvbiByb3VuZE5lYXJaZXJvKHBvaW50KSB7XG4gICAgaWYgKE1hdGguYWJzKHBvaW50LngpIDwgRVBTKSB7IHBvaW50LnggPSAwOyB9XG4gICAgaWYgKE1hdGguYWJzKHBvaW50LnkpIDwgRVBTKSB7IHBvaW50LnkgPSAwOyB9XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0RXJyb3JSZXBvcnRlcihlcnJvck1lc3NhZ2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuaW9uKGEsIGIpIHtcbiAgICBpZiAoIWEpIHsgcmV0dXJuIGI7IH1cbiAgICBpZiAoIWIpIHsgcmV0dXJuIGE7IH1cblxuICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ5WShhLCBiKSB7XG4gICAgLy8gZGVjcmVhc2luZyBZIFxuICAgIHZhciByZXMgPSBiLnkgLSBhLnk7XG4gICAgLy8gVE9ETzogVGhpcyBtaWdodCBtZXNzIHVwIHRoZSBzdGF0dXMgdHJlZS5cbiAgICBpZiAoTWF0aC5hYnMocmVzKSA8IEVQUykge1xuICAgICAgLy8gaW5jcmVhc2luZyB4LlxuICAgICAgcmVzID0gYS54IC0gYi54O1xuICAgICAgaWYgKE1hdGguYWJzKHJlcykgPCBFUFMpIHsgcmVzID0gMDsgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcnNlY3RTZWdtZW50cyQxKGEsIGIpIHtcbiAgICAvLyBOb3RlOiB0aGlzIGlzIGFsbW9zdCB0aGUgc2FtZSBhcyBnZW9tLmludGVyc2VjdFNlZ21lbnRzKClcbiAgICAvLyBUaGUgbWFpbiBkaWZmZXJlbmNlIGlzIHRoYXQgd2UgZG9uJ3QgaGF2ZSBhIHByZS1jb21wdXRlZFxuICAgIC8vIHZhbHVlIGZvciBkeC9keSBvbiB0aGUgc2VnbWVudHMuXG4gICAgLy8gIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xOTY4MzQ1LzEyNTM1MVxuICAgIHZhciBhU3RhcnQgPSBhLmZyb20sIGJTdGFydCA9IGIuZnJvbTtcbiAgICB2YXIgcDBfeCA9IGFTdGFydC54LCBwMF95ID0gYVN0YXJ0LnksXG4gICAgICAgIHAyX3ggPSBiU3RhcnQueCwgcDJfeSA9IGJTdGFydC55O1xuXG4gICAgdmFyIHMxX3ggPSBhLmZyb20ueCAtIGEudG8ueCwgczFfeSA9IGEuZnJvbS55IC0gYS50by55LCBzMl94ID0gYi5mcm9tLnggLSBiLnRvLngsIHMyX3kgPSBiLmZyb20ueSAtIGIudG8ueTtcbiAgICB2YXIgZGl2ID0gczFfeCAqIHMyX3kgLSBzMl94ICogczFfeTtcblxuICAgIHZhciBzID0gKHMxX3kgKiAocDBfeCAtIHAyX3gpIC0gczFfeCAqIChwMF95IC0gcDJfeSkpIC8gZGl2O1xuICAgIGlmIChzIDwgMCB8fCBzID4gMSkgeyByZXR1cm47IH1cblxuICAgIHZhciB0ID0gKHMyX3ggKiAocDJfeSAtIHAwX3kpICsgczJfeSAqIChwMF94IC0gcDJfeCkpIC8gZGl2O1xuXG4gICAgaWYgKHQgPj0gMCAmJiB0IDw9IDEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHAwX3ggLSAodCAqIHMxX3gpLFxuICAgICAgICB5OiBwMF95IC0gKHQgKiBzMV95KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgYnJ1dGUgZm9yY2Ugc29sdXRpb24gd2l0aCBPKG5eMikgcGVyZm9ybWFuY2UuXG4gICAqIChgbmAgaXMgbnVtYmVyIG9mIHNlZ21lbnRzKS5cbiAgICogXG4gICAqIFVzZSB0aGlzIHdoZW4gbnVtYmVyIG9mIGxpbmVzIGlzIGxvdywgYW5kIG51bWJlciBvZiBpbnRlcnNlY3Rpb25zXG4gICAqIGlzIGhpZ2guXG4gICAqL1xuICBmdW5jdGlvbiBicnV0ZShsaW5lcywgb3B0aW9ucykge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdmFyIHJlcG9ydEludGVyc2VjdGlvbiA9IChvcHRpb25zICYmIG9wdGlvbnMub25Gb3VuZCkgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0SW50ZXJzZWN0aW9uUmVwb3J0ZXI7XG4gICAgdmFyIGFzeW5jU3RhdGU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBFeGVjdXRlIGJydXRlIGZvcmNlIG9mIHRoZSBzZWdtZW50IGludGVyc2VjdGlvbiBzZWFyY2hcbiAgICAgICAqL1xuICAgICAgcnVuOiBydW4sXG4gICAgICAvKipcbiAgICAgICAqIEFjY2VzcyB0byByZXN1bHRzIGFycmF5LiBXb3JrcyBvbmx5IHdoZW4geW91IHVzZSBkZWZhdWx0IG9uRm91bmQoKSBoYW5kbGVyXG4gICAgICAgKi9cbiAgICAgIHJlc3VsdHM6IHJlc3VsdHMsXG5cbiAgICAgIC8qKlxuICAgICAgICogUGVyZm9ybXMgYSBzaW5nbGUgc3RlcCBpbiB0aGUgYnJ1dGUgZm9yY2UgYWxnb3JpdGhtICgpXG4gICAgICAgKi9cbiAgICAgIHN0ZXA6IHN0ZXBcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgaWYgKCFhc3luY1N0YXRlKSB7XG4gICAgICAgIGFzeW5jU3RhdGUgPSB7XG4gICAgICAgICAgaTogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIHRlc3QgPSBsaW5lc1thc3luY1N0YXRlLmldO1xuICAgICAgZm9yICh2YXIgaiA9IGFzeW5jU3RhdGUuaSArIDE7IGogPCBsaW5lcy5sZW5ndGg7ICsraikge1xuICAgICAgICB2YXIgb3RoZXIgPSBsaW5lc1tqXTtcbiAgICAgICAgdmFyIHB0ID0gaW50ZXJzZWN0U2VnbWVudHMkMSh0ZXN0LCBvdGhlcik7XG4gICAgICAgIGlmIChwdCkge1xuICAgICAgICAgIGlmIChyZXBvcnRJbnRlcnNlY3Rpb24ocHQsIFt0ZXN0LCBvdGhlcl0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhc3luY1N0YXRlLmkgKz0gMTtcbiAgICAgIHJldHVybiBhc3luY1N0YXRlLmkgPCBsaW5lcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKCkge1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciB0ZXN0ID0gbGluZXNbaV07XG4gICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IGxpbmVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgdmFyIG90aGVyID0gbGluZXNbal07XG4gICAgICAgICAgdmFyIHB0ID0gaW50ZXJzZWN0U2VnbWVudHMkMSh0ZXN0LCBvdGhlcik7XG4gICAgICAgICAgaWYgKHB0KSB7XG4gICAgICAgICAgICBpZiAocmVwb3J0SW50ZXJzZWN0aW9uKHB0LCBbdGVzdCwgb3RoZXJdKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0SW50ZXJzZWN0aW9uUmVwb3J0ZXIocCwgaW50ZXJpb3IpIHtcbiAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgIHBvaW50OiBwLCBcbiAgICAgICAgc2VnbWVudHM6IGludGVyaW9yXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICB2YXIgQVJSQVlfVFlQRVMgPSBbXG4gICAgICBJbnQ4QXJyYXksIFVpbnQ4QXJyYXksIFVpbnQ4Q2xhbXBlZEFycmF5LCBJbnQxNkFycmF5LCBVaW50MTZBcnJheSxcbiAgICAgIEludDMyQXJyYXksIFVpbnQzMkFycmF5LCBGbG9hdDMyQXJyYXksIEZsb2F0NjRBcnJheVxuICBdO1xuXG4gIHZhciBWRVJTSU9OID0gMzsgLy8gc2VyaWFsaXplZCBmb3JtYXQgdmVyc2lvblxuXG4gIHZhciBGbGF0YnVzaCA9IGZ1bmN0aW9uIEZsYXRidXNoKG51bUl0ZW1zLCBub2RlU2l6ZSwgQXJyYXlUeXBlLCBkYXRhKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgaWYgKG51bUl0ZW1zID09PSB1bmRlZmluZWQpIHsgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50OiBudW1JdGVtcy4nKTsgfVxuICAgICAgaWYgKGlzTmFOKG51bUl0ZW1zKSB8fCBudW1JdGVtcyA8PSAwKSB7IHRocm93IG5ldyBFcnJvcigoXCJVbnBleHBlY3RlZCBudW1JdGVtcyB2YWx1ZTogXCIgKyBudW1JdGVtcyArIFwiLlwiKSk7IH1cblxuICAgICAgdGhpcy5udW1JdGVtcyA9ICtudW1JdGVtcztcbiAgICAgIHRoaXMubm9kZVNpemUgPSBNYXRoLm1pbihNYXRoLm1heCgrbm9kZVNpemUgfHwgMTYsIDIpLCA2NTUzNSk7XG5cbiAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgdG90YWwgbnVtYmVyIG9mIG5vZGVzIGluIHRoZSBSLXRyZWUgdG8gYWxsb2NhdGUgc3BhY2UgZm9yXG4gICAgICAvLyBhbmQgdGhlIGluZGV4IG9mIGVhY2ggdHJlZSBsZXZlbCAodXNlZCBpbiBzZWFyY2ggbGF0ZXIpXG4gICAgICB2YXIgbiA9IG51bUl0ZW1zO1xuICAgICAgdmFyIG51bU5vZGVzID0gbjtcbiAgICAgIHRoaXMuX2xldmVsQm91bmRzID0gW24gKiA0XTtcbiAgICAgIGRvIHtcbiAgICAgICAgICBuID0gTWF0aC5jZWlsKG4gLyB0aGlzJDEubm9kZVNpemUpO1xuICAgICAgICAgIG51bU5vZGVzICs9IG47XG4gICAgICAgICAgdGhpcyQxLl9sZXZlbEJvdW5kcy5wdXNoKG51bU5vZGVzICogNCk7XG4gICAgICB9IHdoaWxlIChuICE9PSAxKTtcblxuICAgICAgdGhpcy5BcnJheVR5cGUgPSBBcnJheVR5cGUgfHwgRmxvYXQ2NEFycmF5O1xuICAgICAgdGhpcy5JbmRleEFycmF5VHlwZSA9IG51bU5vZGVzIDwgMTYzODQgPyBVaW50MTZBcnJheSA6IFVpbnQzMkFycmF5O1xuXG4gICAgICB2YXIgYXJyYXlUeXBlSW5kZXggPSBBUlJBWV9UWVBFUy5pbmRleE9mKHRoaXMuQXJyYXlUeXBlKTtcbiAgICAgIHZhciBub2Rlc0J5dGVTaXplID0gbnVtTm9kZXMgKiA0ICogdGhpcy5BcnJheVR5cGUuQllURVNfUEVSX0VMRU1FTlQ7XG5cbiAgICAgIGlmIChhcnJheVR5cGVJbmRleCA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiVW5leHBlY3RlZCB0eXBlZCBhcnJheSBjbGFzczogXCIgKyBBcnJheVR5cGUgKyBcIi5cIikpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YSAmJiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgdGhpcy5fYm94ZXMgPSBuZXcgdGhpcy5BcnJheVR5cGUodGhpcy5kYXRhLCA4LCBudW1Ob2RlcyAqIDQpO1xuICAgICAgICAgIHRoaXMuX2luZGljZXMgPSBuZXcgdGhpcy5JbmRleEFycmF5VHlwZSh0aGlzLmRhdGEsIDggKyBub2Rlc0J5dGVTaXplLCBudW1Ob2Rlcyk7XG5cbiAgICAgICAgICB0aGlzLl9wb3MgPSBudW1Ob2RlcyAqIDQ7XG4gICAgICAgICAgdGhpcy5taW5YID0gdGhpcy5fYm94ZXNbdGhpcy5fcG9zIC0gNF07XG4gICAgICAgICAgdGhpcy5taW5ZID0gdGhpcy5fYm94ZXNbdGhpcy5fcG9zIC0gM107XG4gICAgICAgICAgdGhpcy5tYXhYID0gdGhpcy5fYm94ZXNbdGhpcy5fcG9zIC0gMl07XG4gICAgICAgICAgdGhpcy5tYXhZID0gdGhpcy5fYm94ZXNbdGhpcy5fcG9zIC0gMV07XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kYXRhID0gbmV3IEFycmF5QnVmZmVyKDggKyBub2Rlc0J5dGVTaXplICsgbnVtTm9kZXMgKiB0aGlzLkluZGV4QXJyYXlUeXBlLkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgICAgICAgICB0aGlzLl9ib3hlcyA9IG5ldyB0aGlzLkFycmF5VHlwZSh0aGlzLmRhdGEsIDgsIG51bU5vZGVzICogNCk7XG4gICAgICAgICAgdGhpcy5faW5kaWNlcyA9IG5ldyB0aGlzLkluZGV4QXJyYXlUeXBlKHRoaXMuZGF0YSwgOCArIG5vZGVzQnl0ZVNpemUsIG51bU5vZGVzKTtcbiAgICAgICAgICB0aGlzLl9wb3MgPSAwO1xuICAgICAgICAgIHRoaXMubWluWCA9IEluZmluaXR5O1xuICAgICAgICAgIHRoaXMubWluWSA9IEluZmluaXR5O1xuICAgICAgICAgIHRoaXMubWF4WCA9IC1JbmZpbml0eTtcbiAgICAgICAgICB0aGlzLm1heFkgPSAtSW5maW5pdHk7XG5cbiAgICAgICAgICBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEsIDAsIDIpLnNldChbMHhmYiwgKFZFUlNJT04gPDwgNCkgKyBhcnJheVR5cGVJbmRleF0pO1xuICAgICAgICAgIG5ldyBVaW50MTZBcnJheSh0aGlzLmRhdGEsIDIsIDEpWzBdID0gbm9kZVNpemU7XG4gICAgICAgICAgbmV3IFVpbnQzMkFycmF5KHRoaXMuZGF0YSwgNCwgMSlbMF0gPSBudW1JdGVtcztcbiAgICAgIH1cbiAgfTtcblxuICBGbGF0YnVzaC5mcm9tID0gZnVuY3Rpb24gZnJvbSAoZGF0YSkge1xuICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEFycmF5QnVmZmVyLicpO1xuICAgICAgfVxuICAgICAgdmFyIHJlZiA9IG5ldyBVaW50OEFycmF5KGRhdGEsIDAsIDIpO1xuICAgICAgICAgIHZhciBtYWdpYyA9IHJlZlswXTtcbiAgICAgICAgICB2YXIgdmVyc2lvbkFuZFR5cGUgPSByZWZbMV07XG4gICAgICBpZiAobWFnaWMgIT09IDB4ZmIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgZG9lcyBub3QgYXBwZWFyIHRvIGJlIGluIGEgRmxhdGJ1c2ggZm9ybWF0LicpO1xuICAgICAgfVxuICAgICAgaWYgKHZlcnNpb25BbmRUeXBlID4+IDQgIT09IFZFUlNJT04pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiR290IHZcIiArICh2ZXJzaW9uQW5kVHlwZSA+PiA0KSArIFwiIGRhdGEgd2hlbiBleHBlY3RlZCB2XCIgKyBWRVJTSU9OICsgXCIuXCIpKTtcbiAgICAgIH1cbiAgICAgIHZhciByZWYkMSA9IG5ldyBVaW50MTZBcnJheShkYXRhLCAyLCAxKTtcbiAgICAgICAgICB2YXIgbm9kZVNpemUgPSByZWYkMVswXTtcbiAgICAgIHZhciByZWYkMiA9IG5ldyBVaW50MzJBcnJheShkYXRhLCA0LCAxKTtcbiAgICAgICAgICB2YXIgbnVtSXRlbXMgPSByZWYkMlswXTtcblxuICAgICAgcmV0dXJuIG5ldyBGbGF0YnVzaChudW1JdGVtcywgbm9kZVNpemUsIEFSUkFZX1RZUEVTW3ZlcnNpb25BbmRUeXBlICYgMHgwZl0sIGRhdGEpO1xuICB9O1xuXG4gIEZsYXRidXNoLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKG1pblgsIG1pblksIG1heFgsIG1heFkpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX3BvcyA+PiAyO1xuICAgICAgdGhpcy5faW5kaWNlc1tpbmRleF0gPSBpbmRleDtcbiAgICAgIHRoaXMuX2JveGVzW3RoaXMuX3BvcysrXSA9IG1pblg7XG4gICAgICB0aGlzLl9ib3hlc1t0aGlzLl9wb3MrK10gPSBtaW5ZO1xuICAgICAgdGhpcy5fYm94ZXNbdGhpcy5fcG9zKytdID0gbWF4WDtcbiAgICAgIHRoaXMuX2JveGVzW3RoaXMuX3BvcysrXSA9IG1heFk7XG5cbiAgICAgIGlmIChtaW5YIDwgdGhpcy5taW5YKSB7IHRoaXMubWluWCA9IG1pblg7IH1cbiAgICAgIGlmIChtaW5ZIDwgdGhpcy5taW5ZKSB7IHRoaXMubWluWSA9IG1pblk7IH1cbiAgICAgIGlmIChtYXhYID4gdGhpcy5tYXhYKSB7IHRoaXMubWF4WCA9IG1heFg7IH1cbiAgICAgIGlmIChtYXhZID4gdGhpcy5tYXhZKSB7IHRoaXMubWF4WSA9IG1heFk7IH1cbiAgfTtcblxuICBGbGF0YnVzaC5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gZmluaXNoICgpIHtcbiAgICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX3BvcyA+PiAyICE9PSB0aGlzLm51bUl0ZW1zKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIkFkZGVkIFwiICsgKHRoaXMuX3BvcyA+PiAyKSArIFwiIGl0ZW1zIHdoZW4gZXhwZWN0ZWQgXCIgKyAodGhpcy5udW1JdGVtcykgKyBcIi5cIikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgd2lkdGggPSB0aGlzLm1heFggLSB0aGlzLm1pblg7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5tYXhZIC0gdGhpcy5taW5ZO1xuICAgICAgdmFyIGhpbGJlcnRWYWx1ZXMgPSBuZXcgVWludDMyQXJyYXkodGhpcy5udW1JdGVtcyk7XG4gICAgICB2YXIgaGlsYmVydE1heCA9ICgxIDw8IDE2KSAtIDE7XG5cbiAgICAgIC8vIG1hcCBpdGVtIGNlbnRlcnMgaW50byBIaWxiZXJ0IGNvb3JkaW5hdGUgc3BhY2UgYW5kIGNhbGN1bGF0ZSBIaWxiZXJ0IHZhbHVlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm51bUl0ZW1zOyBpKyspIHtcbiAgICAgICAgICB2YXIgcG9zID0gNCAqIGk7XG4gICAgICAgICAgdmFyIG1pblggPSB0aGlzJDEuX2JveGVzW3BvcysrXTtcbiAgICAgICAgICB2YXIgbWluWSA9IHRoaXMkMS5fYm94ZXNbcG9zKytdO1xuICAgICAgICAgIHZhciBtYXhYID0gdGhpcyQxLl9ib3hlc1twb3MrK107XG4gICAgICAgICAgdmFyIG1heFkgPSB0aGlzJDEuX2JveGVzW3BvcysrXTtcbiAgICAgICAgICB2YXIgeCA9IE1hdGguZmxvb3IoaGlsYmVydE1heCAqICgobWluWCArIG1heFgpIC8gMiAtIHRoaXMkMS5taW5YKSAvIHdpZHRoKTtcbiAgICAgICAgICB2YXIgeSA9IE1hdGguZmxvb3IoaGlsYmVydE1heCAqICgobWluWSArIG1heFkpIC8gMiAtIHRoaXMkMS5taW5ZKSAvIGhlaWdodCk7XG4gICAgICAgICAgaGlsYmVydFZhbHVlc1tpXSA9IGhpbGJlcnQoeCwgeSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNvcnQgaXRlbXMgYnkgdGhlaXIgSGlsYmVydCB2YWx1ZSAoZm9yIHBhY2tpbmcgbGF0ZXIpXG4gICAgICBzb3J0JDEoaGlsYmVydFZhbHVlcywgdGhpcy5fYm94ZXMsIHRoaXMuX2luZGljZXMsIDAsIHRoaXMubnVtSXRlbXMgLSAxKTtcblxuICAgICAgLy8gZ2VuZXJhdGUgbm9kZXMgYXQgZWFjaCB0cmVlIGxldmVsLCBib3R0b20tdXBcbiAgICAgIGZvciAodmFyIGkkMSA9IDAsIHBvcyQxID0gMDsgaSQxIDwgdGhpcy5fbGV2ZWxCb3VuZHMubGVuZ3RoIC0gMTsgaSQxKyspIHtcbiAgICAgICAgICB2YXIgZW5kID0gdGhpcyQxLl9sZXZlbEJvdW5kc1tpJDFdO1xuXG4gICAgICAgICAgLy8gZ2VuZXJhdGUgYSBwYXJlbnQgbm9kZSBmb3IgZWFjaCBibG9jayBvZiBjb25zZWN1dGl2ZSA8bm9kZVNpemU+IG5vZGVzXG4gICAgICAgICAgd2hpbGUgKHBvcyQxIDwgZW5kKSB7XG4gICAgICAgICAgICAgIHZhciBub2RlTWluWCA9IEluZmluaXR5O1xuICAgICAgICAgICAgICB2YXIgbm9kZU1pblkgPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgdmFyIG5vZGVNYXhYID0gLUluZmluaXR5O1xuICAgICAgICAgICAgICB2YXIgbm9kZU1heFkgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICAgIHZhciBub2RlSW5kZXggPSBwb3MkMTtcblxuICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgYmJveCBmb3IgdGhlIG5ldyBub2RlXG4gICAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHRoaXMubm9kZVNpemUgJiYgcG9zJDEgPCBlbmQ7IGkkMisrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbWluWCQxID0gdGhpcyQxLl9ib3hlc1twb3MkMSsrXTtcbiAgICAgICAgICAgICAgICAgIHZhciBtaW5ZJDEgPSB0aGlzJDEuX2JveGVzW3BvcyQxKytdO1xuICAgICAgICAgICAgICAgICAgdmFyIG1heFgkMSA9IHRoaXMkMS5fYm94ZXNbcG9zJDErK107XG4gICAgICAgICAgICAgICAgICB2YXIgbWF4WSQxID0gdGhpcyQxLl9ib3hlc1twb3MkMSsrXTtcbiAgICAgICAgICAgICAgICAgIGlmIChtaW5YJDEgPCBub2RlTWluWCkgeyBub2RlTWluWCA9IG1pblgkMTsgfVxuICAgICAgICAgICAgICAgICAgaWYgKG1pblkkMSA8IG5vZGVNaW5ZKSB7IG5vZGVNaW5ZID0gbWluWSQxOyB9XG4gICAgICAgICAgICAgICAgICBpZiAobWF4WCQxID4gbm9kZU1heFgpIHsgbm9kZU1heFggPSBtYXhYJDE7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChtYXhZJDEgPiBub2RlTWF4WSkgeyBub2RlTWF4WSA9IG1heFkkMTsgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gYWRkIHRoZSBuZXcgbm9kZSB0byB0aGUgdHJlZSBkYXRhXG4gICAgICAgICAgICAgIHRoaXMkMS5faW5kaWNlc1t0aGlzJDEuX3BvcyA+PiAyXSA9IG5vZGVJbmRleDtcbiAgICAgICAgICAgICAgdGhpcyQxLl9ib3hlc1t0aGlzJDEuX3BvcysrXSA9IG5vZGVNaW5YO1xuICAgICAgICAgICAgICB0aGlzJDEuX2JveGVzW3RoaXMkMS5fcG9zKytdID0gbm9kZU1pblk7XG4gICAgICAgICAgICAgIHRoaXMkMS5fYm94ZXNbdGhpcyQxLl9wb3MrK10gPSBub2RlTWF4WDtcbiAgICAgICAgICAgICAgdGhpcyQxLl9ib3hlc1t0aGlzJDEuX3BvcysrXSA9IG5vZGVNYXhZO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfTtcblxuICBGbGF0YnVzaC5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24gc2VhcmNoIChtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCBmaWx0ZXJGbikge1xuICAgICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5fcG9zICE9PSB0aGlzLl9ib3hlcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgbm90IHlldCBpbmRleGVkIC0gY2FsbCBpbmRleC5maW5pc2goKS4nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGVJbmRleCA9IHRoaXMuX2JveGVzLmxlbmd0aCAtIDQ7XG4gICAgICB2YXIgbGV2ZWwgPSB0aGlzLl9sZXZlbEJvdW5kcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgICB3aGlsZSAobm9kZUluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBmaW5kIHRoZSBlbmQgaW5kZXggb2YgdGhlIG5vZGVcbiAgICAgICAgICB2YXIgZW5kID0gTWF0aC5taW4obm9kZUluZGV4ICsgdGhpcyQxLm5vZGVTaXplICogNCwgdGhpcyQxLl9sZXZlbEJvdW5kc1tsZXZlbF0pO1xuXG4gICAgICAgICAgLy8gc2VhcmNoIHRocm91Z2ggY2hpbGQgbm9kZXNcbiAgICAgICAgICBmb3IgKHZhciBwb3MgPSBub2RlSW5kZXg7IHBvcyA8IGVuZDsgcG9zICs9IDQpIHtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcyQxLl9pbmRpY2VzW3BvcyA+PiAyXTtcblxuICAgICAgICAgICAgICAvLyBjaGVjayBpZiBub2RlIGJib3ggaW50ZXJzZWN0cyB3aXRoIHF1ZXJ5IGJib3hcbiAgICAgICAgICAgICAgaWYgKG1heFggPCB0aGlzJDEuX2JveGVzW3Bvc10pIHsgY29udGludWU7IH0gLy8gbWF4WCA8IG5vZGVNaW5YXG4gICAgICAgICAgICAgIGlmIChtYXhZIDwgdGhpcyQxLl9ib3hlc1twb3MgKyAxXSkgeyBjb250aW51ZTsgfSAvLyBtYXhZIDwgbm9kZU1pbllcbiAgICAgICAgICAgICAgaWYgKG1pblggPiB0aGlzJDEuX2JveGVzW3BvcyArIDJdKSB7IGNvbnRpbnVlOyB9IC8vIG1pblggPiBub2RlTWF4WFxuICAgICAgICAgICAgICBpZiAobWluWSA+IHRoaXMkMS5fYm94ZXNbcG9zICsgM10pIHsgY29udGludWU7IH0gLy8gbWluWSA+IG5vZGVNYXhZXG5cbiAgICAgICAgICAgICAgaWYgKG5vZGVJbmRleCA8IHRoaXMkMS5udW1JdGVtcyAqIDQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJGbiA9PT0gdW5kZWZpbmVkIHx8IGZpbHRlckZuKGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChpbmRleCk7IC8vIGxlYWYgaXRlbVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKGluZGV4KTsgLy8gbm9kZTsgYWRkIGl0IHRvIHRoZSBzZWFyY2ggcXVldWVcbiAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2gobGV2ZWwgLSAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldmVsID0gcXVldWUucG9wKCk7XG4gICAgICAgICAgbm9kZUluZGV4ID0gcXVldWUucG9wKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIGN1c3RvbSBxdWlja3NvcnQgdGhhdCBzb3J0cyBiYm94IGRhdGEgYWxvbmdzaWRlIHRoZSBoaWxiZXJ0IHZhbHVlc1xuICBmdW5jdGlvbiBzb3J0JDEodmFsdWVzLCBib3hlcywgaW5kaWNlcywgbGVmdCwgcmlnaHQpIHtcbiAgICAgIGlmIChsZWZ0ID49IHJpZ2h0KSB7IHJldHVybjsgfVxuXG4gICAgICB2YXIgcGl2b3QgPSB2YWx1ZXNbKGxlZnQgKyByaWdodCkgPj4gMV07XG4gICAgICB2YXIgaSA9IGxlZnQgLSAxO1xuICAgICAgdmFyIGogPSByaWdodCArIDE7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgZG8geyBpKys7IH0gd2hpbGUgKHZhbHVlc1tpXSA8IHBpdm90KTtcbiAgICAgICAgICBkbyB7IGotLTsgfSB3aGlsZSAodmFsdWVzW2pdID4gcGl2b3QpO1xuICAgICAgICAgIGlmIChpID49IGopIHsgYnJlYWs7IH1cbiAgICAgICAgICBzd2FwKHZhbHVlcywgYm94ZXMsIGluZGljZXMsIGksIGopO1xuICAgICAgfVxuXG4gICAgICBzb3J0JDEodmFsdWVzLCBib3hlcywgaW5kaWNlcywgbGVmdCwgaik7XG4gICAgICBzb3J0JDEodmFsdWVzLCBib3hlcywgaW5kaWNlcywgaiArIDEsIHJpZ2h0KTtcbiAgfVxuXG4gIC8vIHN3YXAgdHdvIHZhbHVlcyBhbmQgdHdvIGNvcnJlc3BvbmRpbmcgYm94ZXNcbiAgZnVuY3Rpb24gc3dhcCh2YWx1ZXMsIGJveGVzLCBpbmRpY2VzLCBpLCBqKSB7XG4gICAgICB2YXIgdGVtcCA9IHZhbHVlc1tpXTtcbiAgICAgIHZhbHVlc1tpXSA9IHZhbHVlc1tqXTtcbiAgICAgIHZhbHVlc1tqXSA9IHRlbXA7XG5cbiAgICAgIHZhciBrID0gNCAqIGk7XG4gICAgICB2YXIgbSA9IDQgKiBqO1xuXG4gICAgICB2YXIgYSA9IGJveGVzW2tdO1xuICAgICAgdmFyIGIgPSBib3hlc1trICsgMV07XG4gICAgICB2YXIgYyA9IGJveGVzW2sgKyAyXTtcbiAgICAgIHZhciBkID0gYm94ZXNbayArIDNdO1xuICAgICAgYm94ZXNba10gPSBib3hlc1ttXTtcbiAgICAgIGJveGVzW2sgKyAxXSA9IGJveGVzW20gKyAxXTtcbiAgICAgIGJveGVzW2sgKyAyXSA9IGJveGVzW20gKyAyXTtcbiAgICAgIGJveGVzW2sgKyAzXSA9IGJveGVzW20gKyAzXTtcbiAgICAgIGJveGVzW21dID0gYTtcbiAgICAgIGJveGVzW20gKyAxXSA9IGI7XG4gICAgICBib3hlc1ttICsgMl0gPSBjO1xuICAgICAgYm94ZXNbbSArIDNdID0gZDtcblxuICAgICAgdmFyIGUgPSBpbmRpY2VzW2ldO1xuICAgICAgaW5kaWNlc1tpXSA9IGluZGljZXNbal07XG4gICAgICBpbmRpY2VzW2pdID0gZTtcbiAgfVxuXG4gIC8vIEZhc3QgSGlsYmVydCBjdXJ2ZSBhbGdvcml0aG0gYnkgaHR0cDovL3RocmVhZGxvY2FsbXV0ZXguY29tL1xuICAvLyBQb3J0ZWQgZnJvbSBDKysgaHR0cHM6Ly9naXRodWIuY29tL3Jhd3J1bnByb3RlY3RlZC9oaWxiZXJ0X2N1cnZlcyAocHVibGljIGRvbWFpbilcbiAgZnVuY3Rpb24gaGlsYmVydCh4LCB5KSB7XG4gICAgICB2YXIgYSA9IHggXiB5O1xuICAgICAgdmFyIGIgPSAweEZGRkYgXiBhO1xuICAgICAgdmFyIGMgPSAweEZGRkYgXiAoeCB8IHkpO1xuICAgICAgdmFyIGQgPSB4ICYgKHkgXiAweEZGRkYpO1xuXG4gICAgICB2YXIgQSA9IGEgfCAoYiA+PiAxKTtcbiAgICAgIHZhciBCID0gKGEgPj4gMSkgXiBhO1xuICAgICAgdmFyIEMgPSAoKGMgPj4gMSkgXiAoYiAmIChkID4+IDEpKSkgXiBjO1xuICAgICAgdmFyIEQgPSAoKGEgJiAoYyA+PiAxKSkgXiAoZCA+PiAxKSkgXiBkO1xuXG4gICAgICBhID0gQTsgYiA9IEI7IGMgPSBDOyBkID0gRDtcbiAgICAgIEEgPSAoKGEgJiAoYSA+PiAyKSkgXiAoYiAmIChiID4+IDIpKSk7XG4gICAgICBCID0gKChhICYgKGIgPj4gMikpIF4gKGIgJiAoKGEgXiBiKSA+PiAyKSkpO1xuICAgICAgQyBePSAoKGEgJiAoYyA+PiAyKSkgXiAoYiAmIChkID4+IDIpKSk7XG4gICAgICBEIF49ICgoYiAmIChjID4+IDIpKSBeICgoYSBeIGIpICYgKGQgPj4gMikpKTtcblxuICAgICAgYSA9IEE7IGIgPSBCOyBjID0gQzsgZCA9IEQ7XG4gICAgICBBID0gKChhICYgKGEgPj4gNCkpIF4gKGIgJiAoYiA+PiA0KSkpO1xuICAgICAgQiA9ICgoYSAmIChiID4+IDQpKSBeIChiICYgKChhIF4gYikgPj4gNCkpKTtcbiAgICAgIEMgXj0gKChhICYgKGMgPj4gNCkpIF4gKGIgJiAoZCA+PiA0KSkpO1xuICAgICAgRCBePSAoKGIgJiAoYyA+PiA0KSkgXiAoKGEgXiBiKSAmIChkID4+IDQpKSk7XG5cbiAgICAgIGEgPSBBOyBiID0gQjsgYyA9IEM7IGQgPSBEO1xuICAgICAgQyBePSAoKGEgJiAoYyA+PiA4KSkgXiAoYiAmIChkID4+IDgpKSk7XG4gICAgICBEIF49ICgoYiAmIChjID4+IDgpKSBeICgoYSBeIGIpICYgKGQgPj4gOCkpKTtcblxuICAgICAgYSA9IEMgXiAoQyA+PiAxKTtcbiAgICAgIGIgPSBEIF4gKEQgPj4gMSk7XG5cbiAgICAgIHZhciBpMCA9IHggXiB5O1xuICAgICAgdmFyIGkxID0gYiB8ICgweEZGRkYgXiAoaTAgfCBhKSk7XG5cbiAgICAgIGkwID0gKGkwIHwgKGkwIDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgICBpMCA9IChpMCB8IChpMCA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgICAgaTAgPSAoaTAgfCAoaTAgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICAgIGkwID0gKGkwIHwgKGkwIDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICAgIGkxID0gKGkxIHwgKGkxIDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgICBpMSA9IChpMSB8IChpMSA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgICAgaTEgPSAoaTEgfCAoaTEgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICAgIGkxID0gKGkxIHwgKGkxIDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICAgIHJldHVybiAoKGkxIDw8IDEpIHwgaTApID4+PiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgaW5zcGlyZWQgYnkgZGlzY3Vzc2lvbiBoZXJlIFxuICAgKiBodHRwczovL3R3aXR0ZXIuY29tL21vdXJuZXIvc3RhdHVzLzEwNDkzMjUxOTk2MTc5MjEwMjQgYW5kIFxuICAgKiBoZXJlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnZha2EvaXNlY3QvaXNzdWVzLzFcbiAgICogXG4gICAqIEl0IGJ1aWxkcyBhbiBpbmRleCBvZiBhbGwgc2VnbWVudHMgdXNpbmcgc3RhdGljIHNwYXRpYWwgaW5kZXhcbiAgICogYW5kIHRoZW4gZm9yIGVhY2ggc2VnbWVudCBpdCBxdWVyaWVzIG92ZXJsYXBwaW5nIHJlY3RhbmdsZXMuXG4gICAqL1xuICBmdW5jdGlvbiBidXNoKGxpbmVzLCBvcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgcmVwb3J0SW50ZXJzZWN0aW9uID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5vbkZvdW5kKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRJbnRlcnNlY3Rpb25SZXBvcnRlcjtcbiAgICB2YXIgYXN5bmNTdGF0ZTtcblxuICAgIHZhciBpbmRleCA9IG5ldyBGbGF0YnVzaChsaW5lcy5sZW5ndGgpO1xuICAgIGxpbmVzLmZvckVhY2goYWRkVG9JbmRleCk7XG4gICAgaW5kZXguZmluaXNoKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcnVuOiBydW4sXG4gICAgICBzdGVwOiBzdGVwLFxuICAgICAgcmVzdWx0czogcmVzdWx0cyxcblxuICAgICAgLy8gdW5kb2N1bWVudGVkLCBkb24ndCB1c2UgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZzpcbiAgICAgIGNoZWNrSW50ZXJzZWN0aW9uOiBjaGVja0ludGVyc2VjdGlvblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bigpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGNoZWNrSW50ZXJzZWN0aW9uKGxpbmVzW2ldLCBpKSkge1xuICAgICAgICAgIHJldHVybjsgLy8gc3RvcCBlYXJseVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0ludGVyc2VjdGlvbihjdXJyZW50U2VnbWVudCwgY3VycmVudElkKSB7XG4gICAgICAvLyBzb3JyeSBhYm91dCBjb2RlIGR1cGxpY2F0aW9uLlxuICAgICAgdmFyIG1pblggPSBjdXJyZW50U2VnbWVudC5mcm9tLng7IHZhciBtYXhYID0gY3VycmVudFNlZ21lbnQudG8ueDtcbiAgICAgIHZhciBtaW5ZID0gY3VycmVudFNlZ21lbnQuZnJvbS55OyB2YXIgbWF4WSA9IGN1cnJlbnRTZWdtZW50LnRvLnk7XG4gICAgICB2YXIgdDtcbiAgICAgIGlmIChtaW5YID4gbWF4WCkgeyB0ID0gbWluWDsgbWluWCA9IG1heFg7IG1heFggPSB0OyB9XG4gICAgICBpZiAobWluWSA+IG1heFkpIHsgdCA9IG1pblk7IG1pblkgPSBtYXhZOyBtYXhZID0gdDsgfVxuXG4gICAgICB2YXIgaWRzID0gaW5kZXguc2VhcmNoKG1pblgsIG1pblksIG1heFgsIG1heFkpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgc2VnbWVudEluZGV4ID0gaWRzW2ldO1xuICAgICAgICBpZiAoc2VnbWVudEluZGV4IDw9IGN1cnJlbnRJZCkgeyBjb250aW51ZTsgfSAvLyB3ZSBoYXZlIGVpdGhlciByZXBvcnRlZCBpdCwgb3IgaXQgaXMgY3VycmVudC5cblxuICAgICAgICB2YXIgb3RoZXJTZWdtZW50ID0gbGluZXNbc2VnbWVudEluZGV4XTtcbiAgICAgICAgdmFyIHBvaW50ID0gaW50ZXJzZWN0U2VnbWVudHMkMShvdGhlclNlZ21lbnQsIGN1cnJlbnRTZWdtZW50KTtcblxuICAgICAgICBpZiAocG9pbnQpIHtcbiAgICAgICAgICBpZiAocmVwb3J0SW50ZXJzZWN0aW9uKHBvaW50LCBbY3VycmVudFNlZ21lbnQsIG90aGVyU2VnbWVudF0pKSB7XG4gICAgICAgICAgICAvLyBzdG9wIGVhcmx5XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgaWYgKCFhc3luY1N0YXRlKSB7XG4gICAgICAgIGFzeW5jU3RhdGUgPSB7aTogMH07XG4gICAgICB9XG4gICAgICB2YXIgdGVzdCA9IGxpbmVzW2FzeW5jU3RhdGUuaV07XG4gICAgICBjaGVja0ludGVyc2VjdGlvbih0ZXN0LCBhc3luY1N0YXRlLmkpO1xuICAgICAgYXN5bmNTdGF0ZS5pICs9IDE7XG4gICAgICByZXR1cm4gYXN5bmNTdGF0ZS5pIDwgbGluZXMubGVuZ3RoO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gYWRkVG9JbmRleChsaW5lKSB7XG4gICAgICB2YXIgbWluWCA9IGxpbmUuZnJvbS54OyB2YXIgbWF4WCA9IGxpbmUudG8ueDtcbiAgICAgIHZhciBtaW5ZID0gbGluZS5mcm9tLnk7IHZhciBtYXhZID0gbGluZS50by55O1xuICAgICAgdmFyIHQ7XG4gICAgICBpZiAobWluWCA+IG1heFgpIHsgdCA9IG1pblg7IG1pblggPSBtYXhYOyBtYXhYID0gdDsgfVxuICAgICAgaWYgKG1pblkgPiBtYXhZKSB7IHQgPSBtaW5ZOyBtaW5ZID0gbWF4WTsgbWF4WSA9IHQ7IH1cbiAgICAgIGluZGV4LmFkZChtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0SW50ZXJzZWN0aW9uUmVwb3J0ZXIocCwgaW50ZXJpb3IpIHtcbiAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgIHBvaW50OiBwLCBcbiAgICAgICAgc2VnbWVudHM6IGludGVyaW9yXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBleHBvcnRzLnN3ZWVwID0gaXNlY3Q7XG4gIGV4cG9ydHMuYnJ1dGUgPSBicnV0ZTtcbiAgZXhwb3J0cy5idXNoID0gYnVzaDtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNlY3QuanMubWFwXG4iLCIvKipcbiAqIEpTVFMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYmpvcm5oYXJydGVsbC9qc3RzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmpvcm5oYXJydGVsbC9qc3RzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VfRURMdjEudHh0XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmpvcm5oYXJydGVsbC9qc3RzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VfRVBMdjEudHh0XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmpvcm5oYXJydGVsbC9qc3RzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VfTElDRU5TRV9FUzZfQ09MTEVDVElPTlMudHh0XG4gKiBAbGljZW5zZVxuICovXG4hZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9lKGV4cG9ydHMpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wiZXhwb3J0c1wiXSxlKTplKCh0PXR8fHNlbGYpLmpzdHM9e30pfSh0aGlzLChmdW5jdGlvbih0KXtcInVzZSBzdHJpY3RcIjtjbGFzcyBle2NvbnN0cnVjdG9yKCl7ZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBlcXVhbHNXaXRoVG9sZXJhbmNlKHQsZSxuKXtyZXR1cm4gTWF0aC5hYnModC1lKTw9bn1nZXRDbGFzcygpe3JldHVybiBlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1mdW5jdGlvbiBuKHQpe3RoaXMubWVzc2FnZT10fWZ1bmN0aW9uIHModCxlKXt0aGlzLmxvdz0wfGUsdGhpcy5oaWdoPTB8dH1mdW5jdGlvbiBpKCl7fWZ1bmN0aW9uIHIoKXt9ZnVuY3Rpb24gbygpe31mdW5jdGlvbiBsKCl7fWZ1bmN0aW9uIGEoKXt9ZnVuY3Rpb24gYyh0KXt0aGlzLm5hbWU9XCJSdW50aW1lRXhjZXB0aW9uXCIsdGhpcy5tZXNzYWdlPXQsdGhpcy5zdGFjaz0obmV3IEVycm9yKS5zdGFjayxFcnJvci5jYWxsKHRoaXMsdCl9ZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LHMudG9CaW5hcnlTdHJpbmc9ZnVuY3Rpb24odCl7bGV0IGUsbj1cIlwiO2ZvcihlPTIxNDc0ODM2NDg7ZT4wO2U+Pj49MSluKz0odC5oaWdoJmUpPT09ZT9cIjFcIjpcIjBcIjtmb3IoZT0yMTQ3NDgzNjQ4O2U+MDtlPj4+PTEpbis9KHQubG93JmUpPT09ZT9cIjFcIjpcIjBcIjtyZXR1cm4gbn0saS5pc05hTj10PT5OdW1iZXIuaXNOYU4odCksaS5pc0luZmluaXRlPXQ9PiFOdW1iZXIuaXNGaW5pdGUodCksaS5NQVhfVkFMVUU9TnVtYmVyLk1BWF9WQUxVRSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBGbG9hdDY0QXJyYXkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIEludDMyQXJyYXk/ZnVuY3Rpb24oKXtjb25zdCB0PW5ldyBGbG9hdDY0QXJyYXkoMSksZT1uZXcgSW50MzJBcnJheSh0LmJ1ZmZlcik7aS5kb3VibGVUb0xvbmdCaXRzPWZ1bmN0aW9uKG4pe3RbMF09bjtsZXQgaT0wfGVbMF0scj0wfGVbMV07cmV0dXJuIDIxNDY0MzUwNzI9PSgyMTQ2NDM1MDcyJnIpJiYwIT0oMTA0ODU3NSZyKSYmMCE9PWkmJihpPTAscj0yMTQ2OTU5MzYwKSxuZXcgcyhyLGkpfSxpLmxvbmdCaXRzVG9Eb3VibGU9ZnVuY3Rpb24obil7cmV0dXJuIGVbMF09bi5sb3csZVsxXT1uLmhpZ2gsdFswXX19KCk6ZnVuY3Rpb24oKXtjb25zdCB0PU1hdGgubG9nMixlPU1hdGguZmxvb3Isbj1NYXRoLnBvdyxyPWZ1bmN0aW9uKCl7Zm9yKGxldCBzPTUzO3M+MDtzLS0pe2NvbnN0IGk9bigyLHMpLTE7aWYoZSh0KGkpKSsxPT09cylyZXR1cm4gaX1yZXR1cm4gMH0oKTtpLmRvdWJsZVRvTG9uZ0JpdHM9ZnVuY3Rpb24oaSl7bGV0IG8sbCxhLGMsaCx1LGcsZCxfO2lmKGk8MHx8MS9pPT09TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZPyh1PTE8PDMxLGk9LWkpOnU9MCwwPT09aSlyZXR1cm4gXz0wLGQ9dSxuZXcgcyhkLF8pO2lmKGk9PT0xLzApcmV0dXJuIF89MCxkPTIxNDY0MzUwNzJ8dSxuZXcgcyhkLF8pO2lmKGkhPWkpcmV0dXJuIF89MCxkPTIxNDY5NTkzNjAsbmV3IHMoZCxfKTtpZihjPTAsXz0wLG89ZShpKSxvPjEpaWYobzw9ciljPWUodChvKSksYzw9MjA/KF89MCxkPW88PDIwLWMmMTA0ODU3NSk6KGE9Yy0yMCxsPW4oMixhKSxfPW8lbDw8MzItYSxkPW8vbCYxMDQ4NTc1KTtlbHNlIGZvcihhPW8sXz0wO2w9YS8yLGE9ZShsKSwwIT09YTspYysrLF8+Pj49MSxffD0oMSZkKTw8MzEsZD4+Pj0xLGwhPT1hJiYoZHw9NTI0Mjg4KTtpZihnPWMrMTAyMyxoPTA9PT1vLG89aS1vLGM8NTImJjAhPT1vKWZvcihhPTA7Oyl7aWYobD0yKm8sbD49MT8obz1sLTEsaD8oZy0tLGg9ITEpOihhPDw9MSxhfD0xLGMrKykpOihvPWwsaD8wPT0tLWcmJihjKyssaD0hMSk6KGE8PD0xLGMrKykpLDIwPT09YylkfD1hLGE9MDtlbHNlIGlmKDUyPT09Yyl7X3w9YTticmVha31pZigxPT09bCl7YzwyMD9kfD1hPDwyMC1jOmM8NTImJihffD1hPDw1Mi1jKTticmVha319cmV0dXJuIGR8PWc8PDIwLGR8PXUsbmV3IHMoZCxfKX0saS5sb25nQml0c1RvRG91YmxlPWZ1bmN0aW9uKHQpe2xldCBlLHMsaSxyLG87Y29uc3QgbD10LmhpZ2gsYT10Lmxvdztmb3IoaT1sJjE8PDMxPy0xOjEscj0oKDIxNDY0MzUwNzImbCk+PjIwKS0xMDIzLG89MCxzPTE8PDE5LGU9MTtlPD0yMDtlKyspbCZzJiYobys9bigyLC1lKSkscz4+Pj0xO2ZvcihzPTE8PDMxLGU9MjE7ZTw9NTI7ZSsrKWEmcyYmKG8rPW4oMiwtZSkpLHM+Pj49MTtpZigtMTAyMz09PXIpe2lmKDA9PT1vKXJldHVybiAwKmk7cj0tMTAyMn1lbHNle2lmKDEwMjQ9PT1yKXJldHVybiAwPT09bz9pLzA6TmFOO28rPTF9cmV0dXJuIGkqbypuKDIscil9fSgpLGMucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKSxjLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1FcnJvcjtjbGFzcyBoIGV4dGVuZHMgY3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksaC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENsYXNzKCl7cmV0dXJuIGh9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWguY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpYy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtjLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9fTtjbGFzcyB1e2NvbnN0cnVjdG9yKCl7dS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBzaG91bGROZXZlclJlYWNoSGVyZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXUuc2hvdWxkTmV2ZXJSZWFjaEhlcmUobnVsbCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhyb3cgbmV3IGgoXCJTaG91bGQgbmV2ZXIgcmVhY2ggaGVyZVwiKyhudWxsIT09dD9cIjogXCIrdDpcIlwiKSl9fXN0YXRpYyBpc1RydWUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dS5pc1RydWUodCxudWxsKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZighdCl0aHJvdyBudWxsPT09ZT9uZXcgaDpuZXcgaChlKX19c3RhdGljIGVxdWFscygpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt1LmVxdWFscyh0LGUsbnVsbCl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYoIWUuZXF1YWxzKHQpKXRocm93IG5ldyBoKFwiRXhwZWN0ZWQgXCIrdCtcIiBidXQgZW5jb3VudGVyZWQgXCIrZSsobnVsbCE9PW4/XCI6IFwiK246XCJcIikpfX1nZXRDbGFzcygpe3JldHVybiB1fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX11LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgZ3tjb25zdHJ1Y3Rvcigpe2cuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaGFzaENvZGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1pLmRvdWJsZVRvTG9uZ0JpdHModCk7cmV0dXJuIE1hdGgudHJ1bmMoZV5lPj4+MzIpfX1zZXRPcmRpbmF0ZSh0LGUpe3N3aXRjaCh0KXtjYXNlIGcuWDp0aGlzLng9ZTticmVhaztjYXNlIGcuWTp0aGlzLnk9ZTticmVhaztjYXNlIGcuWjp0aGlzLno9ZTticmVhaztkZWZhdWx0OnRocm93IG5ldyBuKFwiSW52YWxpZCBvcmRpbmF0ZSBpbmRleDogXCIrdCl9fWVxdWFsczJEKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLng9PT10LngmJnRoaXMueT09PXQueX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07cmV0dXJuISFlLmVxdWFsc1dpdGhUb2xlcmFuY2UodGhpcy54LHQueCxuKSYmISFlLmVxdWFsc1dpdGhUb2xlcmFuY2UodGhpcy55LHQueSxuKX19Z2V0T3JkaW5hdGUodCl7c3dpdGNoKHQpe2Nhc2UgZy5YOnJldHVybiB0aGlzLng7Y2FzZSBnLlk6cmV0dXJuIHRoaXMueTtjYXNlIGcuWjpyZXR1cm4gdGhpcy56fXRocm93IG5ldyBuKFwiSW52YWxpZCBvcmRpbmF0ZSBpbmRleDogXCIrdCl9ZXF1YWxzM0QodCl7cmV0dXJuIHRoaXMueD09PXQueCYmdGhpcy55PT09dC55JiYodGhpcy56PT09dC56fHxpLmlzTmFOKHRoaXMueikmJmkuaXNOYU4odC56KSl9ZXF1YWxzKHQpe3JldHVybiB0IGluc3RhbmNlb2YgZyYmdGhpcy5lcXVhbHMyRCh0KX1lcXVhbEluWih0LG4pe3JldHVybiBlLmVxdWFsc1dpdGhUb2xlcmFuY2UodGhpcy56LHQueixuKX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLng8ZS54Py0xOnRoaXMueD5lLng/MTp0aGlzLnk8ZS55Py0xOnRoaXMueT5lLnk/MTowfWNsb25lKCl7dHJ5e3JldHVybiBudWxsfWNhdGNoKHQpe2lmKHQgaW5zdGFuY2VvZiBDbG9uZU5vdFN1cHBvcnRlZEV4Y2VwdGlvbilyZXR1cm4gdS5zaG91bGROZXZlclJlYWNoSGVyZShcInRoaXMgc2hvdWxkbid0IGhhcHBlbiBiZWNhdXNlIHRoaXMgY2xhc3MgaXMgQ2xvbmVhYmxlXCIpLG51bGw7dGhyb3cgdH19Y29weSgpe3JldHVybiBuZXcgZyh0aGlzKX10b1N0cmluZygpe3JldHVyblwiKFwiK3RoaXMueCtcIiwgXCIrdGhpcy55K1wiLCBcIit0aGlzLnorXCIpXCJ9ZGlzdGFuY2UzRCh0KXtjb25zdCBlPXRoaXMueC10Lngsbj10aGlzLnktdC55LHM9dGhpcy56LXQuejtyZXR1cm4gTWF0aC5zcXJ0KGUqZStuKm4rcypzKX1kaXN0YW5jZSh0KXtjb25zdCBlPXRoaXMueC10Lngsbj10aGlzLnktdC55O3JldHVybiBNYXRoLnNxcnQoZSplK24qbil9aGFzaENvZGUoKXtsZXQgdD0xNztyZXR1cm4gdD0zNyp0K2cuaGFzaENvZGUodGhpcy54KSx0PTM3KnQrZy5oYXNoQ29kZSh0aGlzLnkpLHR9c2V0Q29vcmRpbmF0ZSh0KXt0aGlzLng9dC54LHRoaXMueT10LnksdGhpcy56PXQuen1nZXRDbGFzcygpe3JldHVybiBnfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltyLG8sYV19fWNsYXNzIGR7Y29uc3RydWN0b3IoKXtkLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbXBhcmUodCxlKXtyZXR1cm4gdDxlPy0xOnQ+ZT8xOmkuaXNOYU4odCk/aS5pc05hTihlKT8wOi0xOmkuaXNOYU4oZSk/MTowfWNvbXBhcmUodCxlKXtjb25zdCBuPXQscz1lLGk9ZC5jb21wYXJlKG4ueCxzLngpO2lmKDAhPT1pKXJldHVybiBpO2NvbnN0IHI9ZC5jb21wYXJlKG4ueSxzLnkpO3JldHVybiAwIT09cj9yOnRoaXMuX2RpbWVuc2lvbnNUb1Rlc3Q8PTI/MDpkLmNvbXBhcmUobi56LHMueil9Z2V0Q2xhc3MoKXtyZXR1cm4gZH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bbF19fWZ1bmN0aW9uIF8odCxlKXtyZXR1cm4gdC5pbnRlcmZhY2VzXyYmdC5pbnRlcmZhY2VzXy5pbmRleE9mKGUpPi0xfWZ1bmN0aW9uIGYoKXt9ZnVuY3Rpb24gcCh0KXt0aGlzLm1lc3NhZ2U9dHx8XCJcIn1mdW5jdGlvbiBtKCl7fWZ1bmN0aW9uIHkodCl7dGhpcy5tZXNzYWdlPXR8fFwiXCJ9ZnVuY3Rpb24geCgpe3RoaXMuYXJyYXlfPVtdLGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZiYmdGhpcy5hZGRBbGwoYXJndW1lbnRzWzBdKX1kLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2RpbWVuc2lvbnNUb1Rlc3Q9MiwwPT09YXJndW1lbnRzLmxlbmd0aClkLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsMik7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYoMiE9PXQmJjMhPT10KXRocm93IG5ldyBuKFwib25seSAyIG9yIDMgZGltZW5zaW9ucyBtYXkgYmUgc3BlY2lmaWVkXCIpO3RoaXMuX2RpbWVuc2lvbnNUb1Rlc3Q9dH19LGcuRGltZW5zaW9uYWxDb21wYXJhdG9yPWQsZy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLng9bnVsbCx0aGlzLnk9bnVsbCx0aGlzLno9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aClnLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsMCwwKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtnLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdC54LHQueSx0LnopfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2cuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsZy5OVUxMX09SRElOQVRFKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLng9dCx0aGlzLnk9ZSx0aGlzLno9bn19LGcuc2VyaWFsVmVyc2lvblVJRD0weDVjYmYyYzIzNWM3ZTU4MDAsZy5OVUxMX09SRElOQVRFPWkuTmFOLGcuWD0wLGcuWT0xLGcuWj0yLGYucHJvdG90eXBlLmFkZD1mdW5jdGlvbigpe30sZi5wcm90b3R5cGUuYWRkQWxsPWZ1bmN0aW9uKCl7fSxmLnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7fSxmLnByb3RvdHlwZS5pdGVyYXRvcj1mdW5jdGlvbigpe30sZi5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe30sZi5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe30sZi5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7fSxwLnByb3RvdHlwZT1uZXcgRXJyb3IscC5wcm90b3R5cGUubmFtZT1cIkluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb25cIixtLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGYucHJvdG90eXBlKSxtLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1tLG0ucHJvdG90eXBlLmdldD1mdW5jdGlvbigpe30sbS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKCl7fSxtLnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7fSx5LnByb3RvdHlwZT1uZXcgRXJyb3IseS5wcm90b3R5cGUubmFtZT1cIk5vU3VjaEVsZW1lbnRFeGNlcHRpb25cIix4LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKG0ucHJvdG90eXBlKSx4LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj14LHgucHJvdG90eXBlLmVuc3VyZUNhcGFjaXR5PWZ1bmN0aW9uKCl7fSx4LnByb3RvdHlwZS5pbnRlcmZhY2VzXz1bbSxmXSx4LnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7cmV0dXJuIDE9PT1hcmd1bWVudHMubGVuZ3RoP3RoaXMuYXJyYXlfLnB1c2godCk6dGhpcy5hcnJheV8uc3BsaWNlKGFyZ3VtZW50c1swXSwwLGFyZ3VtZW50c1sxXSksITB9LHgucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5hcnJheV89W119LHgucHJvdG90eXBlLmFkZEFsbD1mdW5jdGlvbih0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLmFkZChlLm5leHQoKSk7cmV0dXJuITB9LHgucHJvdG90eXBlLnNldD1mdW5jdGlvbih0LGUpe2NvbnN0IG49dGhpcy5hcnJheV9bdF07cmV0dXJuIHRoaXMuYXJyYXlfW3RdPWUsbn0seC5wcm90b3R5cGUuaXRlcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEUodGhpcyl9LHgucHJvdG90eXBlLmdldD1mdW5jdGlvbih0KXtpZih0PDB8fHQ+PXRoaXMuc2l6ZSgpKXRocm93IG5ldyBwO3JldHVybiB0aGlzLmFycmF5X1t0XX0seC5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5hcnJheV8ubGVuZ3RofSx4LnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXJyYXlfLmxlbmd0aH0seC5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe2NvbnN0IHQ9W107Zm9yKGxldCBlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7ZTxuO2UrKyl0LnB1c2godGhpcy5hcnJheV9bZV0pO3JldHVybiB0fSx4LnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24odCl7bGV0IGU9ITE7Zm9yKGxldCBuPTAscz10aGlzLmFycmF5Xy5sZW5ndGg7bjxzO24rKylpZih0aGlzLmFycmF5X1tuXT09PXQpe3RoaXMuYXJyYXlfLnNwbGljZShuLDEpLGU9ITA7YnJlYWt9cmV0dXJuIGV9LHgucHJvdG90eXBlLnJlbW92ZUFsbD1mdW5jdGlvbih0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLnJlbW92ZShlLm5leHQoKSk7cmV0dXJuITB9O2NvbnN0IEU9ZnVuY3Rpb24odCl7dGhpcy5hcnJheUxpc3RfPXQsdGhpcy5wb3NpdGlvbl89MH07RS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe2lmKHRoaXMucG9zaXRpb25fPT09dGhpcy5hcnJheUxpc3RfLnNpemUoKSl0aHJvdyBuZXcgeTtyZXR1cm4gdGhpcy5hcnJheUxpc3RfLmdldCh0aGlzLnBvc2l0aW9uXysrKX0sRS5wcm90b3R5cGUuaGFzTmV4dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBvc2l0aW9uXzx0aGlzLmFycmF5TGlzdF8uc2l6ZSgpfSxFLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYXJyYXlMaXN0Xy5zZXQodGhpcy5wb3NpdGlvbl8tMSx0KX0sRS5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7dGhpcy5hcnJheUxpc3RfLnJlbW92ZSh0aGlzLmFycmF5TGlzdF8uZ2V0KHRoaXMucG9zaXRpb25fKSl9O2NsYXNzIEkgZXh0ZW5kcyB4e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxJLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q29vcmRpbmF0ZSh0KXtyZXR1cm4gdGhpcy5nZXQodCl9YWRkQWxsKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdJiZfKGFyZ3VtZW50c1swXSxmKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bGV0IG49ITE7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspdGhpcy5hZGQocy5uZXh0KCksZSksbj0hMDtyZXR1cm4gbn1yZXR1cm4gc3VwZXIuYWRkQWxsLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jbG9uZSgpe2NvbnN0IHQ9c3VwZXIuY2xvbmUuY2FsbCh0aGlzKTtmb3IobGV0IGU9MDtlPHRoaXMuc2l6ZSgpO2UrKyl0LmFkZChlLHRoaXMuZ2V0KGUpLmNsb25lKCkpO3JldHVybiB0fXRvQ29vcmRpbmF0ZUFycmF5KCl7cmV0dXJuIHRoaXMudG9BcnJheShJLmNvb3JkQXJyYXlUeXBlKX1hZGQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07c3VwZXIuYWRkLmNhbGwodGhpcyx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuYWRkKHQsZSwhMCksITB9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYoIWFyZ3VtZW50c1sxXSYmdGhpcy5zaXplKCk+PTEpe2lmKHRoaXMuZ2V0KHRoaXMuc2l6ZSgpLTEpLmVxdWFsczJEKHQpKXJldHVybiBudWxsfXN1cGVyLmFkZC5jYWxsKHRoaXMsdCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE9iamVjdCYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmFkZCh0LGUpLCEwfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKGFyZ3VtZW50c1syXSlmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyl0aGlzLmFkZCh0W25dLGUpO2Vsc2UgZm9yKGxldCBuPXQubGVuZ3RoLTE7bj49MDtuLS0pdGhpcy5hZGQodFtuXSxlKTtyZXR1cm4hMH1pZihcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKCFhcmd1bWVudHNbMl0pe2NvbnN0IG49dGhpcy5zaXplKCk7aWYobj4wKXtpZih0PjApe2lmKHRoaXMuZ2V0KHQtMSkuZXF1YWxzMkQoZSkpcmV0dXJuIG51bGx9aWYodDxuKXtpZih0aGlzLmdldCh0KS5lcXVhbHMyRChlKSlyZXR1cm4gbnVsbH19fXN1cGVyLmFkZC5jYWxsKHRoaXMsdCxlKX19ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107bGV0IGk9MTtuPnMmJihpPS0xKTtmb3IobGV0IHI9bjtyIT09cztyKz1pKXRoaXMuYWRkKHRbcl0sZSk7cmV0dXJuITB9fWNsb3NlUmluZygpe3RoaXMuc2l6ZSgpPjAmJnRoaXMuYWRkKG5ldyBnKHRoaXMuZ2V0KDApKSwhMSl9Z2V0Q2xhc3MoKXtyZXR1cm4gSX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19SS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5lbnN1cmVDYXBhY2l0eSh0Lmxlbmd0aCksdGhpcy5hZGQodCwhMCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5lbnN1cmVDYXBhY2l0eSh0Lmxlbmd0aCksdGhpcy5hZGQodCxlKX19LEkuY29vcmRBcnJheVR5cGU9bmV3IEFycmF5KDApLmZpbGwobnVsbCk7Y2xhc3MgTntjb25zdHJ1Y3Rvcigpe04uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaW50ZXJzZWN0cygpe2lmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gbi54Pj0odC54PGUueD90Lng6ZS54KSYmbi54PD0odC54PmUueD90Lng6ZS54KSYmbi55Pj0odC55PGUueT90Lnk6ZS55KSYmbi55PD0odC55PmUueT90Lnk6ZS55KX1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107bGV0IGk9TWF0aC5taW4obi54LHMueCkscj1NYXRoLm1heChuLngscy54KSxvPU1hdGgubWluKHQueCxlLngpLGw9TWF0aC5tYXgodC54LGUueCk7cmV0dXJuIShvPnIpJiYoIShsPGkpJiYoaT1NYXRoLm1pbihuLnkscy55KSxyPU1hdGgubWF4KG4ueSxzLnkpLG89TWF0aC5taW4odC55LGUueSksbD1NYXRoLm1heCh0LnksZS55KSwhKG8+cikmJiEobDxpKSkpfX1nZXRBcmVhKCl7cmV0dXJuIHRoaXMuZ2V0V2lkdGgoKSp0aGlzLmdldEhlaWdodCgpfWVxdWFscyh0KXtpZighKHQgaW5zdGFuY2VvZiBOKSlyZXR1cm4hMTtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuaXNOdWxsKCk/ZS5pc051bGwoKTp0aGlzLl9tYXh4PT09ZS5nZXRNYXhYKCkmJnRoaXMuX21heHk9PT1lLmdldE1heFkoKSYmdGhpcy5fbWlueD09PWUuZ2V0TWluWCgpJiZ0aGlzLl9taW55PT09ZS5nZXRNaW5ZKCl9aW50ZXJzZWN0aW9uKHQpe2lmKHRoaXMuaXNOdWxsKCl8fHQuaXNOdWxsKCl8fCF0aGlzLmludGVyc2VjdHModCkpcmV0dXJuIG5ldyBOO2NvbnN0IGU9dGhpcy5fbWlueD50Ll9taW54P3RoaXMuX21pbng6dC5fbWlueCxuPXRoaXMuX21pbnk+dC5fbWlueT90aGlzLl9taW55OnQuX21pbnkscz10aGlzLl9tYXh4PHQuX21heHg/dGhpcy5fbWF4eDp0Ll9tYXh4LGk9dGhpcy5fbWF4eTx0Ll9tYXh5P3RoaXMuX21heHk6dC5fbWF4eTtyZXR1cm4gbmV3IE4oZSxzLG4saSl9aXNOdWxsKCl7cmV0dXJuIHRoaXMuX21heHg8dGhpcy5fbWlueH1nZXRNYXhYKCl7cmV0dXJuIHRoaXMuX21heHh9Y292ZXJzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY292ZXJzKHQueCx0LnkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTil7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIXRoaXMuaXNOdWxsKCkmJiF0LmlzTnVsbCgpJiYodC5nZXRNaW5YKCk+PXRoaXMuX21pbngmJnQuZ2V0TWF4WCgpPD10aGlzLl9tYXh4JiZ0LmdldE1pblkoKT49dGhpcy5fbWlueSYmdC5nZXRNYXhZKCk8PXRoaXMuX21heHkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4hdGhpcy5pc051bGwoKSYmKHQ+PXRoaXMuX21pbngmJnQ8PXRoaXMuX21heHgmJmU+PXRoaXMuX21pbnkmJmU8PXRoaXMuX21heHkpfX1pbnRlcnNlY3RzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTil7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIXRoaXMuaXNOdWxsKCkmJiF0LmlzTnVsbCgpJiYhKHQuX21pbng+dGhpcy5fbWF4eHx8dC5fbWF4eDx0aGlzLl9taW54fHx0Ll9taW55PnRoaXMuX21heHl8fHQuX21heHk8dGhpcy5fbWlueSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pbnRlcnNlY3RzKHQueCx0LnkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIXRoaXMuaXNOdWxsKCkmJighKCh0Lng8ZS54P3QueDplLngpPnRoaXMuX21heHgpJiYoISgodC54PmUueD90Lng6ZS54KTx0aGlzLl9taW54KSYmKCEoKHQueTxlLnk/dC55OmUueSk+dGhpcy5fbWF4eSkmJiEoKHQueT5lLnk/dC55OmUueSk8dGhpcy5fbWlueSkpKSl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIXRoaXMuaXNOdWxsKCkmJiEodD50aGlzLl9tYXh4fHx0PHRoaXMuX21pbnh8fGU+dGhpcy5fbWF4eXx8ZTx0aGlzLl9taW55KX19fWdldE1pblkoKXtyZXR1cm4gdGhpcy5fbWlueX1nZXRNaW5YKCl7cmV0dXJuIHRoaXMuX21pbnh9ZXhwYW5kVG9JbmNsdWRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5leHBhbmRUb0luY2x1ZGUodC54LHQueSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE4pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHQuaXNOdWxsKCkpcmV0dXJuIG51bGw7dGhpcy5pc051bGwoKT8odGhpcy5fbWlueD10LmdldE1pblgoKSx0aGlzLl9tYXh4PXQuZ2V0TWF4WCgpLHRoaXMuX21pbnk9dC5nZXRNaW5ZKCksdGhpcy5fbWF4eT10LmdldE1heFkoKSk6KHQuX21pbng8dGhpcy5fbWlueCYmKHRoaXMuX21pbng9dC5fbWlueCksdC5fbWF4eD50aGlzLl9tYXh4JiYodGhpcy5fbWF4eD10Ll9tYXh4KSx0Ll9taW55PHRoaXMuX21pbnkmJih0aGlzLl9taW55PXQuX21pbnkpLHQuX21heHk+dGhpcy5fbWF4eSYmKHRoaXMuX21heHk9dC5fbWF4eSkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmlzTnVsbCgpPyh0aGlzLl9taW54PXQsdGhpcy5fbWF4eD10LHRoaXMuX21pbnk9ZSx0aGlzLl9tYXh5PWUpOih0PHRoaXMuX21pbngmJih0aGlzLl9taW54PXQpLHQ+dGhpcy5fbWF4eCYmKHRoaXMuX21heHg9dCksZTx0aGlzLl9taW55JiYodGhpcy5fbWlueT1lKSxlPnRoaXMuX21heHkmJih0aGlzLl9tYXh5PWUpKX19bWluRXh0ZW50KCl7aWYodGhpcy5pc051bGwoKSlyZXR1cm4gMDtjb25zdCB0PXRoaXMuZ2V0V2lkdGgoKSxlPXRoaXMuZ2V0SGVpZ2h0KCk7cmV0dXJuIHQ8ZT90OmV9Z2V0V2lkdGgoKXtyZXR1cm4gdGhpcy5pc051bGwoKT8wOnRoaXMuX21heHgtdGhpcy5fbWlueH1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLmlzTnVsbCgpP2UuaXNOdWxsKCk/MDotMTplLmlzTnVsbCgpPzE6dGhpcy5fbWlueDxlLl9taW54Py0xOnRoaXMuX21pbng+ZS5fbWlueD8xOnRoaXMuX21pbnk8ZS5fbWlueT8tMTp0aGlzLl9taW55PmUuX21pbnk/MTp0aGlzLl9tYXh4PGUuX21heHg/LTE6dGhpcy5fbWF4eD5lLl9tYXh4PzE6dGhpcy5fbWF4eTxlLl9tYXh5Py0xOnRoaXMuX21heHk+ZS5fbWF4eT8xOjB9dHJhbnNsYXRlKHQsZSl7aWYodGhpcy5pc051bGwoKSlyZXR1cm4gbnVsbDt0aGlzLmluaXQodGhpcy5nZXRNaW5YKCkrdCx0aGlzLmdldE1heFgoKSt0LHRoaXMuZ2V0TWluWSgpK2UsdGhpcy5nZXRNYXhZKCkrZSl9dG9TdHJpbmcoKXtyZXR1cm5cIkVudltcIit0aGlzLl9taW54K1wiIDogXCIrdGhpcy5fbWF4eCtcIiwgXCIrdGhpcy5fbWlueStcIiA6IFwiK3RoaXMuX21heHkrXCJdXCJ9c2V0VG9OdWxsKCl7dGhpcy5fbWlueD0wLHRoaXMuX21heHg9LTEsdGhpcy5fbWlueT0wLHRoaXMuX21heHk9LTF9Z2V0SGVpZ2h0KCl7cmV0dXJuIHRoaXMuaXNOdWxsKCk/MDp0aGlzLl9tYXh5LXRoaXMuX21pbnl9bWF4RXh0ZW50KCl7aWYodGhpcy5pc051bGwoKSlyZXR1cm4gMDtjb25zdCB0PXRoaXMuZ2V0V2lkdGgoKSxlPXRoaXMuZ2V0SGVpZ2h0KCk7cmV0dXJuIHQ+ZT90OmV9ZXhwYW5kQnkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5leHBhbmRCeSh0LHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHRoaXMuaXNOdWxsKCkpcmV0dXJuIG51bGw7dGhpcy5fbWlueC09dCx0aGlzLl9tYXh4Kz10LHRoaXMuX21pbnktPWUsdGhpcy5fbWF4eSs9ZSwodGhpcy5fbWlueD50aGlzLl9tYXh4fHx0aGlzLl9taW55PnRoaXMuX21heHkpJiZ0aGlzLnNldFRvTnVsbCgpfX1jb250YWlucygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE4pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNvdmVycyh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNvdmVycyh0KX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuY292ZXJzKHQsZSl9fWNlbnRyZSgpe3JldHVybiB0aGlzLmlzTnVsbCgpP251bGw6bmV3IGcoKHRoaXMuZ2V0TWluWCgpK3RoaXMuZ2V0TWF4WCgpKS8yLCh0aGlzLmdldE1pblkoKSt0aGlzLmdldE1heFkoKSkvMil9aW5pdCgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuc2V0VG9OdWxsKCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodC54LHQueCx0LnksdC55KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTil7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbWlueD10Ll9taW54LHRoaXMuX21heHg9dC5fbWF4eCx0aGlzLl9taW55PXQuX21pbnksdGhpcy5fbWF4eT10Ll9tYXh5fX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmluaXQodC54LGUueCx0LnksZS55KX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0PGU/KHRoaXMuX21pbng9dCx0aGlzLl9tYXh4PWUpOih0aGlzLl9taW54PWUsdGhpcy5fbWF4eD10KSxuPHM/KHRoaXMuX21pbnk9bix0aGlzLl9tYXh5PXMpOih0aGlzLl9taW55PXMsdGhpcy5fbWF4eT1uKX19Z2V0TWF4WSgpe3JldHVybiB0aGlzLl9tYXh5fWRpc3RhbmNlKHQpe2lmKHRoaXMuaW50ZXJzZWN0cyh0KSlyZXR1cm4gMDtsZXQgZT0wO3RoaXMuX21heHg8dC5fbWlueD9lPXQuX21pbngtdGhpcy5fbWF4eDp0aGlzLl9taW54PnQuX21heHgmJihlPXRoaXMuX21pbngtdC5fbWF4eCk7bGV0IG49MDtyZXR1cm4gdGhpcy5fbWF4eTx0Ll9taW55P249dC5fbWlueS10aGlzLl9tYXh5OnRoaXMuX21pbnk+dC5fbWF4eSYmKG49dGhpcy5fbWlueS10Ll9tYXh5KSwwPT09ZT9uOjA9PT1uP2U6TWF0aC5zcXJ0KGUqZStuKm4pfWhhc2hDb2RlKCl7bGV0IHQ9MTc7cmV0dXJuIHQ9MzcqdCtnLmhhc2hDb2RlKHRoaXMuX21pbngpLHQ9MzcqdCtnLmhhc2hDb2RlKHRoaXMuX21heHgpLHQ9MzcqdCtnLmhhc2hDb2RlKHRoaXMuX21pbnkpLHQ9MzcqdCtnLmhhc2hDb2RlKHRoaXMuX21heHkpLHR9Z2V0Q2xhc3MoKXtyZXR1cm4gTn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bcixhXX19ZnVuY3Rpb24gQygpe31OLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX21pbng9bnVsbCx0aGlzLl9tYXh4PW51bGwsdGhpcy5fbWlueT1udWxsLHRoaXMuX21heHk9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLmluaXQoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0LngsdC54LHQueSx0LnkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBOKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuaW5pdCh0LngsZS54LHQueSxlLnkpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuaW5pdCh0LGUsbixzKX19LE4uc2VyaWFsVmVyc2lvblVJRD0weDUxODQ1Y2Q1NTIxODk4MDA7Y2xhc3MgUyBleHRlbmRzIEN7Y29uc3RydWN0b3IoKXtzdXBlcigpLFMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDbGFzcygpe3JldHVybiBTfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1mdW5jdGlvbiB3KHQpe3RoaXMuc3RyPXR9ZnVuY3Rpb24gTCh0KXt0aGlzLnZhbHVlPXR9ZnVuY3Rpb24gVCgpe31TLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe0MuY29uc3RydWN0b3JfLmNhbGwodGhpcyxcIlByb2plY3RpdmUgcG9pbnQgbm90IHJlcHJlc2VudGFibGUgb24gdGhlIENhcnRlc2lhbiBwbGFuZS5cIil9LHcucHJvdG90eXBlLmFwcGVuZD1mdW5jdGlvbih0KXt0aGlzLnN0cis9dH0sdy5wcm90b3R5cGUuc2V0Q2hhckF0PWZ1bmN0aW9uKHQsZSl7dGhpcy5zdHI9dGhpcy5zdHIuc3Vic3RyKDAsdCkrZSt0aGlzLnN0ci5zdWJzdHIodCsxKX0sdy5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc3RyfSxMLnByb3RvdHlwZS5pbnRWYWx1ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlfSxMLnByb3RvdHlwZS5jb21wYXJlVG89ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudmFsdWU8dD8tMTp0aGlzLnZhbHVlPnQ/MTowfSxMLmlzTmFOPXQ9Pk51bWJlci5pc05hTih0KSxULmlzV2hpdGVzcGFjZT10PT50PD0zMiYmdD49MHx8MTI3PT09dCxULnRvVXBwZXJDYXNlPXQ9PnQudG9VcHBlckNhc2UoKTtjbGFzcyBSe2NvbnN0cnVjdG9yKCl7Ui5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBzcXIodCl7cmV0dXJuIFIudmFsdWVPZih0KS5zZWxmTXVsdGlwbHkodCl9c3RhdGljIHZhbHVlT2YoKXtpZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gUi5wYXJzZSh0KX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IFIodCl9fXN0YXRpYyBzcXJ0KHQpe3JldHVybiBSLnZhbHVlT2YodCkuc3FydCgpfXN0YXRpYyBwYXJzZSh0KXtsZXQgZT0wO2NvbnN0IG49dC5sZW5ndGg7Zm9yKDtULmlzV2hpdGVzcGFjZSh0LmNoYXJBdChlKSk7KWUrKztsZXQgcz0hMTtpZihlPG4pe2NvbnN0IG49dC5jaGFyQXQoZSk7XCItXCIhPT1uJiZcIitcIiE9PW58fChlKyssXCItXCI9PT1uJiYocz0hMCkpfWNvbnN0IGk9bmV3IFI7bGV0IHI9MCxvPTAsbD0wO2Zvcig7IShlPj1uKTspe2NvbnN0IG49dC5jaGFyQXQoZSk7aWYoZSsrLFQuaXNEaWdpdChuKSl7Y29uc3QgdD1uLVwiMFwiO2kuc2VsZk11bHRpcGx5KFIuVEVOKSxpLnNlbGZBZGQodCkscisrfWVsc2V7aWYoXCIuXCIhPT1uKXtpZihcImVcIj09PW58fFwiRVwiPT09bil7Y29uc3Qgbj10LnN1YnN0cmluZyhlKTt0cnl7bD1MLnBhcnNlSW50KG4pfWNhdGNoKGUpe3Rocm93IGUgaW5zdGFuY2VvZiBOdW1iZXJGb3JtYXRFeGNlcHRpb24/bmV3IE51bWJlckZvcm1hdEV4Y2VwdGlvbihcIkludmFsaWQgZXhwb25lbnQgXCIrbitcIiBpbiBzdHJpbmcgXCIrdCk6ZX1icmVha310aHJvdyBuZXcgTnVtYmVyRm9ybWF0RXhjZXB0aW9uKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiK24rXCInIGF0IHBvc2l0aW9uIFwiK2UrXCIgaW4gc3RyaW5nIFwiK3QpfW89cn19bGV0IGE9aTtjb25zdCBjPXItby1sO2lmKDA9PT1jKWE9aTtlbHNlIGlmKGM+MCl7Y29uc3QgdD1SLlRFTi5wb3coYyk7YT1pLmRpdmlkZSh0KX1lbHNlIGlmKGM8MCl7Y29uc3QgdD1SLlRFTi5wb3coLWMpO2E9aS5tdWx0aXBseSh0KX1yZXR1cm4gcz9hLm5lZ2F0ZSgpOmF9c3RhdGljIGNyZWF0ZU5hTigpe3JldHVybiBuZXcgUihpLk5hTixpLk5hTil9c3RhdGljIGNvcHkodCl7cmV0dXJuIG5ldyBSKHQpfXN0YXRpYyBtYWduaXR1ZGUodCl7Y29uc3QgZT1NYXRoLmFicyh0KSxuPU1hdGgubG9nKGUpL01hdGgubG9nKDEwKTtsZXQgcz1NYXRoLnRydW5jKE1hdGguZmxvb3IobikpO3JldHVybiAxMCpNYXRoLnBvdygxMCxzKTw9ZSYmKHMrPTEpLHN9c3RhdGljIHN0cmluZ09mQ2hhcih0LGUpe2NvbnN0IG49bmV3IHc7Zm9yKGxldCBzPTA7czxlO3MrKyluLmFwcGVuZCh0KTtyZXR1cm4gbi50b1N0cmluZygpfWxlKHQpe3JldHVybiB0aGlzLl9oaTx0Ll9oaXx8dGhpcy5faGk9PT10Ll9oaSYmdGhpcy5fbG88PXQuX2xvfWV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyh0LGUpe2xldCBuPXRoaXMuYWJzKCkscz1SLm1hZ25pdHVkZShuLl9oaSk7Y29uc3QgaT1SLlRFTi5wb3cocyk7bj1uLmRpdmlkZShpKSxuLmd0KFIuVEVOKT8obj1uLmRpdmlkZShSLlRFTikscys9MSk6bi5sdChSLk9ORSkmJihuPW4ubXVsdGlwbHkoUi5URU4pLHMtPTEpO2NvbnN0IHI9cysxLG89bmV3IHcsbD1SLk1BWF9QUklOVF9ESUdJVFMtMTtmb3IobGV0IGU9MDtlPD1sO2UrKyl7dCYmZT09PXImJm8uYXBwZW5kKFwiLlwiKTtjb25zdCBzPU1hdGgudHJ1bmMobi5faGkpO2lmKHM8MClicmVhaztsZXQgaT0hMSxhPTA7cz45PyhpPSEwLGE9XCI5XCIpOmE9XCIwXCIrcyxvLmFwcGVuZChhKSxuPW4uc3VidHJhY3QoUi52YWx1ZU9mKHMpKS5tdWx0aXBseShSLlRFTiksaSYmbi5zZWxmQWRkKFIuVEVOKTtsZXQgYz0hMDtjb25zdCBoPVIubWFnbml0dWRlKG4uX2hpKTtpZihoPDAmJk1hdGguYWJzKGgpPj1sLWUmJihjPSExKSwhYylicmVha31yZXR1cm4gZVswXT1zLG8udG9TdHJpbmcoKX1zcXIoKXtyZXR1cm4gdGhpcy5tdWx0aXBseSh0aGlzKX1kb3VibGVWYWx1ZSgpe3JldHVybiB0aGlzLl9oaSt0aGlzLl9sb31zdWJ0cmFjdCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUil7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuYWRkKHQubmVnYXRlKCkpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmFkZCgtdCl9fWVxdWFscygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFIpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9oaT09PXQuX2hpJiZ0aGlzLl9sbz09PXQuX2xvfX1pc1plcm8oKXtyZXR1cm4gMD09PXRoaXMuX2hpJiYwPT09dGhpcy5fbG99c2VsZlN1YnRyYWN0KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBSKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pc05hTigpP3RoaXM6dGhpcy5zZWxmQWRkKC10Ll9oaSwtdC5fbG8pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmlzTmFOKCk/dGhpczp0aGlzLnNlbGZBZGQoLXQsMCl9fWdldFNwZWNpYWxOdW1iZXJTdHJpbmcoKXtyZXR1cm4gdGhpcy5pc1plcm8oKT9cIjAuMFwiOnRoaXMuaXNOYU4oKT9cIk5hTiBcIjpudWxsfW1pbih0KXtyZXR1cm4gdGhpcy5sZSh0KT90aGlzOnR9c2VsZkRpdmlkZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFIpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNlbGZEaXZpZGUodC5faGksdC5fbG8pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNlbGZEaXZpZGUodCwwKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bGV0IG49bnVsbCxzPW51bGwsaT1udWxsLHI9bnVsbCxvPW51bGwsbD1udWxsLGE9bnVsbCxjPW51bGw7cmV0dXJuIG89dGhpcy5faGkvdCxsPVIuU1BMSVQqbyxuPWwtbyxjPVIuU1BMSVQqdCxuPWwtbixzPW8tbixpPWMtdCxhPW8qdCxpPWMtaSxyPXQtaSxjPW4qaS1hK24qcitzKmkrcypyLGw9KHRoaXMuX2hpLWEtYyt0aGlzLl9sby1vKmUpL3QsYz1vK2wsdGhpcy5faGk9Yyx0aGlzLl9sbz1vLWMrbCx0aGlzfX1kdW1wKCl7cmV0dXJuXCJERDxcIit0aGlzLl9oaStcIiwgXCIrdGhpcy5fbG8rXCI+XCJ9ZGl2aWRlKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBSKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT1udWxsLG49bnVsbCxzPW51bGwsaT1udWxsLHI9bnVsbCxvPW51bGwsbD1udWxsLGE9bnVsbDtyZXR1cm4gcj10aGlzLl9oaS90Ll9oaSxvPVIuU1BMSVQqcixlPW8tcixhPVIuU1BMSVQqdC5faGksZT1vLWUsbj1yLWUscz1hLXQuX2hpLGw9cip0Ll9oaSxzPWEtcyxpPXQuX2hpLXMsYT1lKnMtbCtlKmkrbipzK24qaSxvPSh0aGlzLl9oaS1sLWErdGhpcy5fbG8tcip0Ll9sbykvdC5faGksYT1yK28sbmV3IFIoYSxyLWErbyl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIGkuaXNOYU4odCk/Ui5jcmVhdGVOYU4oKTpSLmNvcHkodGhpcykuc2VsZkRpdmlkZSh0LDApfX1nZSh0KXtyZXR1cm4gdGhpcy5faGk+dC5faGl8fHRoaXMuX2hpPT09dC5faGkmJnRoaXMuX2xvPj10Ll9sb31wb3codCl7aWYoMD09PXQpcmV0dXJuIFIudmFsdWVPZigxKTtsZXQgZT1uZXcgUih0aGlzKSxuPVIudmFsdWVPZigxKSxzPU1hdGguYWJzKHQpO2lmKHM+MSlmb3IoO3M+MDspcyUyPT0xJiZuLnNlbGZNdWx0aXBseShlKSxzLz0yLHM+MCYmKGU9ZS5zcXIoKSk7ZWxzZSBuPWU7cmV0dXJuIHQ8MD9uLnJlY2lwcm9jYWwoKTpufWNlaWwoKXtpZih0aGlzLmlzTmFOKCkpcmV0dXJuIFIuTmFOO2NvbnN0IHQ9TWF0aC5jZWlsKHRoaXMuX2hpKTtsZXQgZT0wO3JldHVybiB0PT09dGhpcy5faGkmJihlPU1hdGguY2VpbCh0aGlzLl9sbykpLG5ldyBSKHQsZSl9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5faGk8ZS5faGk/LTE6dGhpcy5faGk+ZS5faGk/MTp0aGlzLl9sbzxlLl9sbz8tMTp0aGlzLl9sbz5lLl9sbz8xOjB9cmludCgpe2lmKHRoaXMuaXNOYU4oKSlyZXR1cm4gdGhpcztyZXR1cm4gdGhpcy5hZGQoLjUpLmZsb29yKCl9c2V0VmFsdWUoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFIpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmluaXQodCksdGhpc31pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pbml0KHQpLHRoaXN9fW1heCh0KXtyZXR1cm4gdGhpcy5nZSh0KT90aGlzOnR9c3FydCgpe2lmKHRoaXMuaXNaZXJvKCkpcmV0dXJuIFIudmFsdWVPZigwKTtpZih0aGlzLmlzTmVnYXRpdmUoKSlyZXR1cm4gUi5OYU47Y29uc3QgdD0xL01hdGguc3FydCh0aGlzLl9oaSksZT10aGlzLl9oaSp0LG49Ui52YWx1ZU9mKGUpLHM9dGhpcy5zdWJ0cmFjdChuLnNxcigpKS5faGkqKC41KnQpO3JldHVybiBuLmFkZChzKX1zZWxmQWRkKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUil7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZkFkZCh0Ll9oaSx0Ll9sbyl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGU9bnVsbCxuPW51bGwscz1udWxsLGk9bnVsbCxyPW51bGwsbz1udWxsO3JldHVybiBzPXRoaXMuX2hpK3Qscj1zLXRoaXMuX2hpLGk9cy1yLGk9dC1yKyh0aGlzLl9oaS1pKSxvPWkrdGhpcy5fbG8sZT1zK28sbj1vKyhzLWUpLHRoaXMuX2hpPWUrbix0aGlzLl9sbz1uKyhlLXRoaXMuX2hpKSx0aGlzfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtsZXQgbj1udWxsLHM9bnVsbCxpPW51bGwscj1udWxsLG89bnVsbCxsPW51bGwsYT1udWxsLGM9bnVsbDtvPXRoaXMuX2hpK3QsaT10aGlzLl9sbytlLGE9by10aGlzLl9oaSxjPWktdGhpcy5fbG8sbD1vLWEscj1pLWMsbD10LWErKHRoaXMuX2hpLWwpLHI9ZS1jKyh0aGlzLl9sby1yKSxhPWwraSxuPW8rYSxzPWErKG8tbiksYT1yK3M7Y29uc3QgaD1uK2EsdT1hKyhuLWgpO3JldHVybiB0aGlzLl9oaT1oLHRoaXMuX2xvPXUsdGhpc319c2VsZk11bHRpcGx5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUil7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZk11bHRpcGx5KHQuX2hpLHQuX2xvKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZWxmTXVsdGlwbHkodCwwKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bGV0IG49bnVsbCxzPW51bGwsaT1udWxsLHI9bnVsbCxvPW51bGwsbD1udWxsO289Ui5TUExJVCp0aGlzLl9oaSxuPW8tdGhpcy5faGksbD1SLlNQTElUKnQsbj1vLW4scz10aGlzLl9oaS1uLGk9bC10LG89dGhpcy5faGkqdCxpPWwtaSxyPXQtaSxsPW4qaS1vK24qcitzKmkrcypyKyh0aGlzLl9oaSplK3RoaXMuX2xvKnQpO2NvbnN0IGE9bytsO249by1hO2NvbnN0IGM9bCtuO3JldHVybiB0aGlzLl9oaT1hLHRoaXMuX2xvPWMsdGhpc319c2VsZlNxcigpe3JldHVybiB0aGlzLnNlbGZNdWx0aXBseSh0aGlzKX1mbG9vcigpe2lmKHRoaXMuaXNOYU4oKSlyZXR1cm4gUi5OYU47Y29uc3QgdD1NYXRoLmZsb29yKHRoaXMuX2hpKTtsZXQgZT0wO3JldHVybiB0PT09dGhpcy5faGkmJihlPU1hdGguZmxvb3IodGhpcy5fbG8pKSxuZXcgUih0LGUpfW5lZ2F0ZSgpe3JldHVybiB0aGlzLmlzTmFOKCk/dGhpczpuZXcgUigtdGhpcy5faGksLXRoaXMuX2xvKX1jbG9uZSgpe3RyeXtyZXR1cm4gbnVsbH1jYXRjaCh0KXtpZih0IGluc3RhbmNlb2YgQ2xvbmVOb3RTdXBwb3J0ZWRFeGNlcHRpb24pcmV0dXJuIG51bGw7dGhyb3cgdH19bXVsdGlwbHkoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFIpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0LmlzTmFOKCk/Ui5jcmVhdGVOYU4oKTpSLmNvcHkodGhpcykuc2VsZk11bHRpcGx5KHQpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBpLmlzTmFOKHQpP1IuY3JlYXRlTmFOKCk6Ui5jb3B5KHRoaXMpLnNlbGZNdWx0aXBseSh0LDApfX1pc05hTigpe3JldHVybiBpLmlzTmFOKHRoaXMuX2hpKX1pbnRWYWx1ZSgpe3JldHVybiBNYXRoLnRydW5jKHRoaXMuX2hpKX10b1N0cmluZygpe2NvbnN0IHQ9Ui5tYWduaXR1ZGUodGhpcy5faGkpO3JldHVybiB0Pj0tMyYmdDw9MjA/dGhpcy50b1N0YW5kYXJkTm90YXRpb24oKTp0aGlzLnRvU2NpTm90YXRpb24oKX10b1N0YW5kYXJkTm90YXRpb24oKXtjb25zdCB0PXRoaXMuZ2V0U3BlY2lhbE51bWJlclN0cmluZygpO2lmKG51bGwhPT10KXJldHVybiB0O2NvbnN0IGU9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksbj10aGlzLmV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyghMCxlKSxzPWVbMF0rMTtsZXQgaT1uO2lmKFwiLlwiPT09bi5jaGFyQXQoMCkpaT1cIjBcIituO2Vsc2UgaWYoczwwKWk9XCIwLlwiK1Iuc3RyaW5nT2ZDaGFyKFwiMFwiLC1zKStuO2Vsc2UgaWYoLTE9PT1uLmluZGV4T2YoXCIuXCIpKXtjb25zdCB0PXMtbi5sZW5ndGg7aT1uK1Iuc3RyaW5nT2ZDaGFyKFwiMFwiLHQpK1wiLjBcIn1yZXR1cm4gdGhpcy5pc05lZ2F0aXZlKCk/XCItXCIraTppfXJlY2lwcm9jYWwoKXtsZXQgdD1udWxsLGU9bnVsbCxuPW51bGwscz1udWxsLGk9bnVsbCxyPW51bGwsbz1udWxsLGw9bnVsbDtpPTEvdGhpcy5faGkscj1SLlNQTElUKmksdD1yLWksbD1SLlNQTElUKnRoaXMuX2hpLHQ9ci10LGU9aS10LG49bC10aGlzLl9oaSxvPWkqdGhpcy5faGksbj1sLW4scz10aGlzLl9oaS1uLGw9dCpuLW8rdCpzK2UqbitlKnMscj0oMS1vLWwtaSp0aGlzLl9sbykvdGhpcy5faGk7Y29uc3QgYT1pK3I7cmV0dXJuIG5ldyBSKGEsaS1hK3IpfXRvU2NpTm90YXRpb24oKXtpZih0aGlzLmlzWmVybygpKXJldHVybiBSLlNDSV9OT1RfWkVSTztjb25zdCB0PXRoaXMuZ2V0U3BlY2lhbE51bWJlclN0cmluZygpO2lmKG51bGwhPT10KXJldHVybiB0O2NvbnN0IGU9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksbj10aGlzLmV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyghMSxlKSxzPVIuU0NJX05PVF9FWFBPTkVOVF9DSEFSK2VbMF07aWYoXCIwXCI9PT1uLmNoYXJBdCgwKSl0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKFwiRm91bmQgbGVhZGluZyB6ZXJvOiBcIituKTtsZXQgaT1cIlwiO24ubGVuZ3RoPjEmJihpPW4uc3Vic3RyaW5nKDEpKTtjb25zdCByPW4uY2hhckF0KDApK1wiLlwiK2k7cmV0dXJuIHRoaXMuaXNOZWdhdGl2ZSgpP1wiLVwiK3IrczpyK3N9YWJzKCl7cmV0dXJuIHRoaXMuaXNOYU4oKT9SLk5hTjp0aGlzLmlzTmVnYXRpdmUoKT90aGlzLm5lZ2F0ZSgpOm5ldyBSKHRoaXMpfWlzUG9zaXRpdmUoKXtyZXR1cm4gdGhpcy5faGk+MHx8MD09PXRoaXMuX2hpJiZ0aGlzLl9sbz4wfWx0KHQpe3JldHVybiB0aGlzLl9oaTx0Ll9oaXx8dGhpcy5faGk9PT10Ll9oaSYmdGhpcy5fbG88dC5fbG99YWRkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBSKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gUi5jb3B5KHRoaXMpLnNlbGZBZGQodCl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIFIuY29weSh0aGlzKS5zZWxmQWRkKHQpfX1pbml0KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2hpPXQsdGhpcy5fbG89MH1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUil7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faGk9dC5faGksdGhpcy5fbG89dC5fbG99fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2hpPXQsdGhpcy5fbG89ZX19Z3QodCl7cmV0dXJuIHRoaXMuX2hpPnQuX2hpfHx0aGlzLl9oaT09PXQuX2hpJiZ0aGlzLl9sbz50Ll9sb31pc05lZ2F0aXZlKCl7cmV0dXJuIHRoaXMuX2hpPDB8fDA9PT10aGlzLl9oaSYmdGhpcy5fbG88MH10cnVuYygpe3JldHVybiB0aGlzLmlzTmFOKCk/Ui5OYU46dGhpcy5pc1Bvc2l0aXZlKCk/dGhpcy5mbG9vcigpOnRoaXMuY2VpbCgpfXNpZ251bSgpe3JldHVybiB0aGlzLl9oaT4wPzE6dGhpcy5faGk8MD8tMTp0aGlzLl9sbz4wPzE6dGhpcy5fbG88MD8tMTowfWdldENsYXNzKCl7cmV0dXJuIFJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2EscixvXX19Ui5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9oaT0wLHRoaXMuX2xvPTAsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5pbml0KDApO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUil7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQpfWVsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07Ui5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLFIucGFyc2UodCkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmluaXQodCxlKX19LFIuUEk9bmV3IFIoMy4xNDE1OTI2NTM1ODk3OTMsMTIyNDY0Njc5OTE0NzM1MzJlLTMyKSxSLlRXT19QST1uZXcgUig2LjI4MzE4NTMwNzE3OTU4NiwyNDQ5MjkzNTk4Mjk0NzA2NGUtMzIpLFIuUElfMj1uZXcgUigxLjU3MDc5NjMyNjc5NDg5NjYsNjEyMzIzMzk5NTczNjc2NmUtMzIpLFIuRT1uZXcgUigyLjcxODI4MTgyODQ1OTA0NSwxNDQ1NjQ2ODkxNzI5MjUwMmUtMzIpLFIuTmFOPW5ldyBSKGkuTmFOLGkuTmFOKSxSLkVQUz0xMjMyNTk1MTY0NDA3ODNlLTQ2LFIuU1BMSVQ9MTM0MjE3NzI5LFIuTUFYX1BSSU5UX0RJR0lUUz0zMixSLlRFTj1SLnZhbHVlT2YoMTApLFIuT05FPVIudmFsdWVPZigxKSxSLlNDSV9OT1RfRVhQT05FTlRfQ0hBUj1cIkVcIixSLlNDSV9OT1RfWkVSTz1cIjAuMEUwXCI7Y2xhc3MgUHtjb25zdHJ1Y3Rvcigpe1AuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgb3JpZW50YXRpb25JbmRleCh0LGUsbil7Y29uc3Qgcz1QLm9yaWVudGF0aW9uSW5kZXhGaWx0ZXIodCxlLG4pO2lmKHM8PTEpcmV0dXJuIHM7Y29uc3QgaT1SLnZhbHVlT2YoZS54KS5zZWxmQWRkKC10LngpLHI9Ui52YWx1ZU9mKGUueSkuc2VsZkFkZCgtdC55KSxvPVIudmFsdWVPZihuLngpLnNlbGZBZGQoLWUueCksbD1SLnZhbHVlT2Yobi55KS5zZWxmQWRkKC1lLnkpO3JldHVybiBpLnNlbGZNdWx0aXBseShsKS5zZWxmU3VidHJhY3Qoci5zZWxmTXVsdGlwbHkobykpLnNpZ251bSgpfXN0YXRpYyBzaWduT2ZEZXQyeDIoKXtpZihhcmd1bWVudHNbM11pbnN0YW5jZW9mIFImJmFyZ3VtZW50c1syXWluc3RhbmNlb2YgUiYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBSJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIFIpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3JldHVybiB0Lm11bHRpcGx5KHMpLnNlbGZTdWJ0cmFjdChlLm11bHRpcGx5KG4pKS5zaWdudW0oKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzNdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPVIudmFsdWVPZih0KSxyPVIudmFsdWVPZihlKSxvPVIudmFsdWVPZihuKSxsPVIudmFsdWVPZihzKTtyZXR1cm4gaS5tdWx0aXBseShsKS5zZWxmU3VidHJhY3Qoci5tdWx0aXBseShvKSkuc2lnbnVtKCl9fXN0YXRpYyBpbnRlcnNlY3Rpb24odCxlLG4scyl7Y29uc3QgaT1SLnZhbHVlT2Yocy55KS5zZWxmU3VidHJhY3Qobi55KS5zZWxmTXVsdGlwbHkoUi52YWx1ZU9mKGUueCkuc2VsZlN1YnRyYWN0KHQueCkpLHI9Ui52YWx1ZU9mKHMueCkuc2VsZlN1YnRyYWN0KG4ueCkuc2VsZk11bHRpcGx5KFIudmFsdWVPZihlLnkpLnNlbGZTdWJ0cmFjdCh0LnkpKSxvPWkuc3VidHJhY3QociksbD1SLnZhbHVlT2Yocy54KS5zZWxmU3VidHJhY3Qobi54KS5zZWxmTXVsdGlwbHkoUi52YWx1ZU9mKHQueSkuc2VsZlN1YnRyYWN0KG4ueSkpLGE9Ui52YWx1ZU9mKHMueSkuc2VsZlN1YnRyYWN0KG4ueSkuc2VsZk11bHRpcGx5KFIudmFsdWVPZih0LngpLnNlbGZTdWJ0cmFjdChuLngpKSxjPWwuc3VidHJhY3QoYSkuc2VsZkRpdmlkZShvKS5kb3VibGVWYWx1ZSgpLGg9Ui52YWx1ZU9mKHQueCkuc2VsZkFkZChSLnZhbHVlT2YoZS54KS5zZWxmU3VidHJhY3QodC54KS5zZWxmTXVsdGlwbHkoYykpLmRvdWJsZVZhbHVlKCksdT1SLnZhbHVlT2YoZS54KS5zZWxmU3VidHJhY3QodC54KS5zZWxmTXVsdGlwbHkoUi52YWx1ZU9mKHQueSkuc2VsZlN1YnRyYWN0KG4ueSkpLGQ9Ui52YWx1ZU9mKGUueSkuc2VsZlN1YnRyYWN0KHQueSkuc2VsZk11bHRpcGx5KFIudmFsdWVPZih0LngpLnNlbGZTdWJ0cmFjdChuLngpKSxfPXUuc3VidHJhY3QoZCkuc2VsZkRpdmlkZShvKS5kb3VibGVWYWx1ZSgpLGY9Ui52YWx1ZU9mKG4ueSkuc2VsZkFkZChSLnZhbHVlT2Yocy55KS5zZWxmU3VidHJhY3Qobi55KS5zZWxmTXVsdGlwbHkoXykpLmRvdWJsZVZhbHVlKCk7cmV0dXJuIG5ldyBnKGgsZil9c3RhdGljIG9yaWVudGF0aW9uSW5kZXhGaWx0ZXIodCxlLG4pe2xldCBzPW51bGw7Y29uc3QgaT0odC54LW4ueCkqKGUueS1uLnkpLHI9KHQueS1uLnkpKihlLngtbi54KSxvPWktcjtpZihpPjApe2lmKHI8PTApcmV0dXJuIFAuc2lnbnVtKG8pO3M9aStyfWVsc2V7aWYoIShpPDApKXJldHVybiBQLnNpZ251bShvKTtpZihyPj0wKXJldHVybiBQLnNpZ251bShvKTtzPS1pLXJ9Y29uc3QgbD1QLkRQX1NBRkVfRVBTSUxPTipzO3JldHVybiBvPj1sfHwtbz49bD9QLnNpZ251bShvKToyfXN0YXRpYyBzaWdudW0odCl7cmV0dXJuIHQ+MD8xOnQ8MD8tMTowfWdldENsYXNzKCl7cmV0dXJuIFB9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVAuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxQLkRQX1NBRkVfRVBTSUxPTj0xZS0xNTtjbGFzcyB2e2NvbnN0cnVjdG9yKCl7di5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpbmRleCh0LGUsbil7cmV0dXJuIFAub3JpZW50YXRpb25JbmRleCh0LGUsbil9c3RhdGljIGlzQ0NXKHQpe2NvbnN0IGU9dC5sZW5ndGgtMTtpZihlPDMpdGhyb3cgbmV3IG4oXCJSaW5nIGhhcyBmZXdlciB0aGFuIDQgcG9pbnRzLCBzbyBvcmllbnRhdGlvbiBjYW5ub3QgYmUgZGV0ZXJtaW5lZFwiKTtsZXQgcz10WzBdLGk9MDtmb3IobGV0IG49MTtuPD1lO24rKyl7Y29uc3QgZT10W25dO2UueT5zLnkmJihzPWUsaT1uKX1sZXQgcj1pO2Rve3ItPTEscjwwJiYocj1lKX13aGlsZSh0W3JdLmVxdWFsczJEKHMpJiZyIT09aSk7bGV0IG89aTtkb3tvPShvKzEpJWV9d2hpbGUodFtvXS5lcXVhbHMyRChzKSYmbyE9PWkpO2NvbnN0IGw9dFtyXSxhPXRbb107aWYobC5lcXVhbHMyRChzKXx8YS5lcXVhbHMyRChzKXx8bC5lcXVhbHMyRChhKSlyZXR1cm4hMTtjb25zdCBjPXYuaW5kZXgobCxzLGEpO2xldCBoPW51bGw7cmV0dXJuIGg9MD09PWM/bC54PmEueDpjPjAsaH1nZXRDbGFzcygpe3JldHVybiB2fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1mdW5jdGlvbiBPKCl7fXYuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSx2LkNMT0NLV0lTRT0tMSx2LlJJR0hUPXYuQ0xPQ0tXSVNFLHYuQ09VTlRFUkNMT0NLV0lTRT0xLHYuTEVGVD12LkNPVU5URVJDTE9DS1dJU0Usdi5DT0xMSU5FQVI9MCx2LlNUUkFJR0hUPXYuQ09MTElORUFSLE8uYXJyYXljb3B5PSh0LGUsbixzLGkpPT57bGV0IHI9MDtmb3IobGV0IG89ZTtvPGUraTtvKyspbltzK3JdPXRbb10scisrfSxPLmdldFByb3BlcnR5PXQ9Pih7XCJsaW5lLnNlcGFyYXRvclwiOlwiXFxuXCJ9W3RdKTtjbGFzcyBie2NvbnN0cnVjdG9yKCl7Yi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpbnRlcnNlY3Rpb24odCxlLG4scyl7Y29uc3Qgcj10LnktZS55LG89ZS54LXQueCxsPXQueCplLnktZS54KnQueSxhPW4ueS1zLnksYz1zLngtbi54LGg9bi54KnMueS1zLngqbi55LHU9cipjLWEqbyxkPShvKmgtYypsKS91LF89KGEqbC1yKmgpL3U7aWYoaS5pc05hTihkKXx8aS5pc0luZmluaXRlKGQpfHxpLmlzTmFOKF8pfHxpLmlzSW5maW5pdGUoXykpdGhyb3cgbmV3IFM7cmV0dXJuIG5ldyBnKGQsXyl9Z2V0WSgpe2NvbnN0IHQ9dGhpcy55L3RoaXMudztpZihpLmlzTmFOKHQpfHxpLmlzSW5maW5pdGUodCkpdGhyb3cgbmV3IFM7cmV0dXJuIHR9Z2V0WCgpe2NvbnN0IHQ9dGhpcy54L3RoaXMudztpZihpLmlzTmFOKHQpfHxpLmlzSW5maW5pdGUodCkpdGhyb3cgbmV3IFM7cmV0dXJuIHR9Z2V0Q29vcmRpbmF0ZSgpe2NvbnN0IHQ9bmV3IGc7cmV0dXJuIHQueD10aGlzLmdldFgoKSx0Lnk9dGhpcy5nZXRZKCksdH1nZXRDbGFzcygpe3JldHVybiBifWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1iLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMueD1udWxsLHRoaXMueT1udWxsLHRoaXMudz1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMueD0wLHRoaXMueT0wLHRoaXMudz0xO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMueD10LngsdGhpcy55PXQueSx0aGlzLnc9MX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLng9dCx0aGlzLnk9ZSx0aGlzLnc9MX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgYiYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBiKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLng9dC55KmUudy1lLnkqdC53LHRoaXMueT1lLngqdC53LXQueCplLncsdGhpcy53PXQueCplLnktZS54KnQueX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLng9dC55LWUueSx0aGlzLnk9ZS54LXQueCx0aGlzLnc9dC54KmUueS1lLngqdC55fX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLng9dCx0aGlzLnk9ZSx0aGlzLnc9bn1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPXQueS1lLnkscj1lLngtdC54LG89dC54KmUueS1lLngqdC55LGw9bi55LXMueSxhPXMueC1uLngsYz1uLngqcy55LXMueCpuLnk7dGhpcy54PXIqYy1hKm8sdGhpcy55PWwqby1pKmMsdGhpcy53PWkqYS1sKnJ9fTtjbGFzcyBNe2NvbnN0cnVjdG9yKCl7TS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBsb2cxMCh0KXtjb25zdCBlPU1hdGgubG9nKHQpO3JldHVybiBpLmlzSW5maW5pdGUoZSl8fGkuaXNOYU4oZSk/ZTplL00uTE9HXzEwfXN0YXRpYyBtaW4odCxlLG4scyl7bGV0IGk9dDtyZXR1cm4gZTxpJiYoaT1lKSxuPGkmJihpPW4pLHM8aSYmKGk9cyksaX1zdGF0aWMgY2xhbXAoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gdDxlP2U6dD5uP246dH1pZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1syXSkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gdDxlP2U6dD5uP246dH19c3RhdGljIHdyYXAodCxlKXtyZXR1cm4gdDwwP2UtIC10JWU6dCVlfXN0YXRpYyBtYXgoKXtpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07bGV0IHM9dDtyZXR1cm4gZT5zJiYocz1lKSxuPnMmJihzPW4pLHN9aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO2xldCBpPXQ7cmV0dXJuIGU+aSYmKGk9ZSksbj5pJiYoaT1uKSxzPmkmJihpPXMpLGl9fXN0YXRpYyBhdmVyYWdlKHQsZSl7cmV0dXJuKHQrZSkvMn1nZXRDbGFzcygpe3JldHVybiBNfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1NLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sTS5MT0dfMTA9TWF0aC5sb2coMTApO2NsYXNzIER7Y29uc3RydWN0b3IoKXtELmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHNlZ21lbnRUb1NlZ21lbnQodCxlLG4scyl7aWYodC5lcXVhbHMoZSkpcmV0dXJuIEQucG9pbnRUb1NlZ21lbnQodCxuLHMpO2lmKG4uZXF1YWxzKHMpKXJldHVybiBELnBvaW50VG9TZWdtZW50KHMsdCxlKTtsZXQgaT0hMTtpZihOLmludGVyc2VjdHModCxlLG4scykpe2NvbnN0IHI9KGUueC10LngpKihzLnktbi55KS0oZS55LXQueSkqKHMueC1uLngpO2lmKDA9PT1yKWk9ITA7ZWxzZXtjb25zdCBvPSh0Lnktbi55KSoocy54LW4ueCktKHQueC1uLngpKihzLnktbi55KSxsPSgodC55LW4ueSkqKGUueC10LngpLSh0Lngtbi54KSooZS55LXQueSkpL3IsYT1vL3I7KGE8MHx8YT4xfHxsPDB8fGw+MSkmJihpPSEwKX19ZWxzZSBpPSEwO3JldHVybiBpP00ubWluKEQucG9pbnRUb1NlZ21lbnQodCxuLHMpLEQucG9pbnRUb1NlZ21lbnQoZSxuLHMpLEQucG9pbnRUb1NlZ21lbnQobix0LGUpLEQucG9pbnRUb1NlZ21lbnQocyx0LGUpKTowfXN0YXRpYyBwb2ludFRvU2VnbWVudCh0LGUsbil7aWYoZS54PT09bi54JiZlLnk9PT1uLnkpcmV0dXJuIHQuZGlzdGFuY2UoZSk7Y29uc3Qgcz0obi54LWUueCkqKG4ueC1lLngpKyhuLnktZS55KSoobi55LWUueSksaT0oKHQueC1lLngpKihuLngtZS54KSsodC55LWUueSkqKG4ueS1lLnkpKS9zO2lmKGk8PTApcmV0dXJuIHQuZGlzdGFuY2UoZSk7aWYoaT49MSlyZXR1cm4gdC5kaXN0YW5jZShuKTtjb25zdCByPSgoZS55LXQueSkqKG4ueC1lLngpLShlLngtdC54KSoobi55LWUueSkpL3M7cmV0dXJuIE1hdGguYWJzKHIpKk1hdGguc3FydChzKX1zdGF0aWMgcG9pbnRUb0xpbmVQZXJwZW5kaWN1bGFyKHQsZSxuKXtjb25zdCBzPShuLngtZS54KSoobi54LWUueCkrKG4ueS1lLnkpKihuLnktZS55KSxpPSgoZS55LXQueSkqKG4ueC1lLngpLShlLngtdC54KSoobi55LWUueSkpL3M7cmV0dXJuIE1hdGguYWJzKGkpKk1hdGguc3FydChzKX1zdGF0aWMgcG9pbnRUb1NlZ21lbnRTdHJpbmcodCxlKXtpZigwPT09ZS5sZW5ndGgpdGhyb3cgbmV3IG4oXCJMaW5lIGFycmF5IG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgdmVydGV4XCIpO2xldCBzPXQuZGlzdGFuY2UoZVswXSk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aC0xO24rKyl7Y29uc3QgaT1ELnBvaW50VG9TZWdtZW50KHQsZVtuXSxlW24rMV0pO2k8cyYmKHM9aSl9cmV0dXJuIHN9Z2V0Q2xhc3MoKXtyZXR1cm4gRH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19RC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIEF7Y29uc3RydWN0b3IoKXtBLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c2V0T3JkaW5hdGUodCxlLG4pe31zaXplKCl7fWdldE9yZGluYXRlKHQsZSl7fWdldENvb3JkaW5hdGUoKXt9Z2V0Q29vcmRpbmF0ZUNvcHkodCl7fWdldERpbWVuc2lvbigpe31nZXRYKHQpe31leHBhbmRFbnZlbG9wZSh0KXt9Y29weSgpe31nZXRZKHQpe310b0Nvb3JkaW5hdGVBcnJheSgpe31nZXRDbGFzcygpe3JldHVybiBBfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvXX19QS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LEEuWD0wLEEuWT0xLEEuWj0yLEEuTT0zO2NsYXNzIEZ7Y29uc3RydWN0b3IoKXtGLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y3JlYXRlKCl7MT09PWFyZ3VtZW50cy5sZW5ndGgmJihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5fHxfKGFyZ3VtZW50c1swXSxBKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gRn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Ri5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIEd7Y29uc3RydWN0b3IoKXtHLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmlsdGVyKHQpe31nZXRDbGFzcygpe3JldHVybiBHfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1HLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgcXtjb25zdHJ1Y3Rvcigpe3EuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pc0dlb21ldHJ5Q29sbGVjdGlvbigpe3JldHVybiB0aGlzLmdldFR5cGVDb2RlKCk9PT1xLlRZUEVDT0RFX0dFT01FVFJZQ09MTEVDVElPTn1nZXRGYWN0b3J5KCl7cmV0dXJuIHRoaXMuX2ZhY3Rvcnl9Z2V0R2VvbWV0cnlOKHQpe3JldHVybiB0aGlzfWdldEFyZWEoKXtyZXR1cm4gMH1pc1JlY3RhbmdsZSgpe3JldHVybiExfWVxdWFscygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIG51bGwhPT10JiZ0aGlzLmVxdWFsc1RvcG8odCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPYmplY3Qpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKCEodCBpbnN0YW5jZW9mIHEpKXJldHVybiExO2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5lcXVhbHNFeGFjdChlKX19ZXF1YWxzRXhhY3QodCl7cmV0dXJuIHRoaXM9PT10fHx0aGlzLmVxdWFsc0V4YWN0KHQsMCl9Z2VvbWV0cnlDaGFuZ2VkKCl7dGhpcy5hcHBseShxLmdlb21ldHJ5Q2hhbmdlZEZpbHRlcil9Z2VvbWV0cnlDaGFuZ2VkQWN0aW9uKCl7dGhpcy5fZW52ZWxvcGU9bnVsbH1lcXVhbHNOb3JtKHQpe3JldHVybiBudWxsIT09dCYmdGhpcy5ub3JtKCkuZXF1YWxzRXhhY3QodC5ub3JtKCkpfWdldExlbmd0aCgpe3JldHVybiAwfWdldE51bUdlb21ldHJpZXMoKXtyZXR1cm4gMX1jb21wYXJlVG8oKXtsZXQgdDtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgZT1hcmd1bWVudHNbMF07cmV0dXJuIHQ9ZSx0aGlzLmdldFR5cGVDb2RlKCkhPT10LmdldFR5cGVDb2RlKCk/dGhpcy5nZXRUeXBlQ29kZSgpLXQuZ2V0VHlwZUNvZGUoKTp0aGlzLmlzRW1wdHkoKSYmdC5pc0VtcHR5KCk/MDp0aGlzLmlzRW1wdHkoKT8tMTp0LmlzRW1wdHkoKT8xOnRoaXMuY29tcGFyZVRvU2FtZUNsYXNzKGUpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtyZXR1cm4gdD1lLHRoaXMuZ2V0VHlwZUNvZGUoKSE9PXQuZ2V0VHlwZUNvZGUoKT90aGlzLmdldFR5cGVDb2RlKCktdC5nZXRUeXBlQ29kZSgpOnRoaXMuaXNFbXB0eSgpJiZ0LmlzRW1wdHkoKT8wOnRoaXMuaXNFbXB0eSgpPy0xOnQuaXNFbXB0eSgpPzE6dGhpcy5jb21wYXJlVG9TYW1lQ2xhc3MoZSxuKX19Z2V0VXNlckRhdGEoKXtyZXR1cm4gdGhpcy5fdXNlckRhdGF9Z2V0U1JJRCgpe3JldHVybiB0aGlzLl9TUklEfWdldEVudmVsb3BlKCl7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLnRvR2VvbWV0cnkodGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCkpfWNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHQpe2lmKHQuZ2V0VHlwZUNvZGUoKT09PXEuVFlQRUNPREVfR0VPTUVUUllDT0xMRUNUSU9OKXRocm93IG5ldyBuKFwiVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBHZW9tZXRyeUNvbGxlY3Rpb24gYXJndW1lbnRzXCIpfWVxdWFsKHQsZSxuKXtyZXR1cm4gMD09PW4/dC5lcXVhbHMoZSk6dC5kaXN0YW5jZShlKTw9bn1ub3JtKCl7Y29uc3QgdD10aGlzLmNvcHkoKTtyZXR1cm4gdC5ub3JtYWxpemUoKSx0fWdldFByZWNpc2lvbk1vZGVsKCl7cmV0dXJuIHRoaXMuX2ZhY3RvcnkuZ2V0UHJlY2lzaW9uTW9kZWwoKX1nZXRFbnZlbG9wZUludGVybmFsKCl7cmV0dXJuIG51bGw9PT10aGlzLl9lbnZlbG9wZSYmKHRoaXMuX2VudmVsb3BlPXRoaXMuY29tcHV0ZUVudmVsb3BlSW50ZXJuYWwoKSksbmV3IE4odGhpcy5fZW52ZWxvcGUpfXNldFNSSUQodCl7dGhpcy5fU1JJRD10fXNldFVzZXJEYXRhKHQpe3RoaXMuX3VzZXJEYXRhPXR9Y29tcGFyZSh0LGUpe2NvbnN0IG49dC5pdGVyYXRvcigpLHM9ZS5pdGVyYXRvcigpO2Zvcig7bi5oYXNOZXh0KCkmJnMuaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKSxlPXMubmV4dCgpLGk9dC5jb21wYXJlVG8oZSk7aWYoMCE9PWkpcmV0dXJuIGl9cmV0dXJuIG4uaGFzTmV4dCgpPzE6cy5oYXNOZXh0KCk/LTE6MH1oYXNoQ29kZSgpe3JldHVybiB0aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKS5oYXNoQ29kZSgpfWlzR2VvbWV0cnlDb2xsZWN0aW9uT3JEZXJpdmVkKCl7cmV0dXJuIHRoaXMuZ2V0VHlwZUNvZGUoKT09PXEuVFlQRUNPREVfR0VPTUVUUllDT0xMRUNUSU9OfHx0aGlzLmdldFR5cGVDb2RlKCk9PT1xLlRZUEVDT0RFX01VTFRJUE9JTlR8fHRoaXMuZ2V0VHlwZUNvZGUoKT09PXEuVFlQRUNPREVfTVVMVElMSU5FU1RSSU5HfHx0aGlzLmdldFR5cGVDb2RlKCk9PT1xLlRZUEVDT0RFX01VTFRJUE9MWUdPTn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bbyxyLGFdfWdldENsYXNzKCl7cmV0dXJuIHF9c3RhdGljIGhhc05vbkVtcHR5RWxlbWVudHModCl7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspaWYoIXRbZV0uaXNFbXB0eSgpKXJldHVybiEwO3JldHVybiExfXN0YXRpYyBoYXNOdWxsRWxlbWVudHModCl7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspaWYobnVsbD09PXRbZV0pcmV0dXJuITA7cmV0dXJuITF9fXEuY29uc3RydWN0b3JfPWZ1bmN0aW9uKHQpe3QmJih0aGlzLl9lbnZlbG9wZT1udWxsLHRoaXMuX3VzZXJEYXRhPW51bGwsdGhpcy5fZmFjdG9yeT10LHRoaXMuX1NSSUQ9dC5nZXRTUklEKCkpfSxxLnNlcmlhbFZlcnNpb25VSUQ9MHg3OTllYTQ2NTIyODU0YzAwLHEuVFlQRUNPREVfUE9JTlQ9MCxxLlRZUEVDT0RFX01VTFRJUE9JTlQ9MSxxLlRZUEVDT0RFX0xJTkVTVFJJTkc9MixxLlRZUEVDT0RFX0xJTkVBUlJJTkc9MyxxLlRZUEVDT0RFX01VTFRJTElORVNUUklORz00LHEuVFlQRUNPREVfUE9MWUdPTj01LHEuVFlQRUNPREVfTVVMVElQT0xZR09OPTYscS5UWVBFQ09ERV9HRU9NRVRSWUNPTExFQ1RJT049NyxxLlRZUEVOQU1FX1BPSU5UPVwiUG9pbnRcIixxLlRZUEVOQU1FX01VTFRJUE9JTlQ9XCJNdWx0aVBvaW50XCIscS5UWVBFTkFNRV9MSU5FU1RSSU5HPVwiTGluZVN0cmluZ1wiLHEuVFlQRU5BTUVfTElORUFSUklORz1cIkxpbmVhclJpbmdcIixxLlRZUEVOQU1FX01VTFRJTElORVNUUklORz1cIk11bHRpTGluZVN0cmluZ1wiLHEuVFlQRU5BTUVfUE9MWUdPTj1cIlBvbHlnb25cIixxLlRZUEVOQU1FX01VTFRJUE9MWUdPTj1cIk11bHRpUG9seWdvblwiLHEuVFlQRU5BTUVfR0VPTUVUUllDT0xMRUNUSU9OPVwiR2VvbWV0cnlDb2xsZWN0aW9uXCIscS5nZW9tZXRyeUNoYW5nZWRGaWx0ZXI9e2dldCBpbnRlcmZhY2VzXygpe3JldHVybltHXX0sZmlsdGVyKHQpe3QuZ2VvbWV0cnlDaGFuZ2VkQWN0aW9uKCl9fTtjbGFzcyBCe2NvbnN0cnVjdG9yKCl7Qi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbHRlcih0KXt9Z2V0Q2xhc3MoKXtyZXR1cm4gQn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Qi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIFZ7Y29uc3RydWN0b3IoKXtWLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNJbkJvdW5kYXJ5KHQpe31nZXRDbGFzcygpe3JldHVybiBWfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyB6e2NvbnN0cnVjdG9yKCl7ei5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWlzSW5Cb3VuZGFyeSh0KXtyZXR1cm4gdCUyPT0xfWdldENsYXNzKCl7cmV0dXJuIHp9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW1ZdfX16LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgWXtjb25zdHJ1Y3Rvcigpe1kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pc0luQm91bmRhcnkodCl7cmV0dXJuIHQ+MH1nZXRDbGFzcygpe3JldHVybiBZfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltWXX19WS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIFV7Y29uc3RydWN0b3IoKXtVLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNJbkJvdW5kYXJ5KHQpe3JldHVybiB0PjF9Z2V0Q2xhc3MoKXtyZXR1cm4gVX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bVl19fVUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBre2NvbnN0cnVjdG9yKCl7ay5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWlzSW5Cb3VuZGFyeSh0KXtyZXR1cm4gMT09PXR9Z2V0Q2xhc3MoKXtyZXR1cm4ga31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bVl19fWsuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxWLk1vZDJCb3VuZGFyeU5vZGVSdWxlPXosVi5FbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGU9WSxWLk11bHRpVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlPVUsVi5Nb25vVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlPWssVi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LFYuTU9EMl9CT1VOREFSWV9SVUxFPW5ldyB6LFYuRU5EUE9JTlRfQk9VTkRBUllfUlVMRT1uZXcgWSxWLk1VTFRJVkFMRU5UX0VORFBPSU5UX0JPVU5EQVJZX1JVTEU9bmV3IFUsVi5NT05PVkFMRU5UX0VORFBPSU5UX0JPVU5EQVJZX1JVTEU9bmV3IGssVi5PR0NfU0ZTX0JPVU5EQVJZX1JVTEU9Vi5NT0QyX0JPVU5EQVJZX1JVTEU7Y2xhc3MgWHtjb25zdHJ1Y3Rvcigpe1guY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaXNSaW5nKHQpe3JldHVybiEodC5sZW5ndGg8NCkmJiEhdFswXS5lcXVhbHMyRCh0W3QubGVuZ3RoLTFdKX1zdGF0aWMgcHROb3RJbkxpc3QodCxlKXtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyl7Y29uc3Qgcz10W25dO2lmKFguaW5kZXhPZihzLGUpPDApcmV0dXJuIHN9cmV0dXJuIG51bGx9c3RhdGljIHNjcm9sbCh0LGUpe2NvbnN0IG49WC5pbmRleE9mKGUsdCk7aWYobjwwKXJldHVybiBudWxsO2NvbnN0IHM9bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpO08uYXJyYXljb3B5KHQsbixzLDAsdC5sZW5ndGgtbiksTy5hcnJheWNvcHkodCwwLHMsdC5sZW5ndGgtbixuKSxPLmFycmF5Y29weShzLDAsdCwwLHQubGVuZ3RoKX1zdGF0aWMgZXF1YWxzKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHQ9PT1lKXJldHVybiEwO2lmKG51bGw9PT10fHxudWxsPT09ZSlyZXR1cm4hMTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKWlmKCF0W25dLmVxdWFscyhlW25dKSlyZXR1cm4hMTtyZXR1cm4hMH1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYodD09PWUpcmV0dXJuITA7aWYobnVsbD09PXR8fG51bGw9PT1lKXJldHVybiExO2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpcmV0dXJuITE7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspaWYoMCE9PW4uY29tcGFyZSh0W3NdLGVbc10pKXJldHVybiExO3JldHVybiEwfX1zdGF0aWMgaW50ZXJzZWN0aW9uKHQsZSl7Y29uc3Qgbj1uZXcgSTtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrKyllLmludGVyc2VjdHModFtzXSkmJm4uYWRkKHRbc10sITApO3JldHVybiBuLnRvQ29vcmRpbmF0ZUFycmF5KCl9c3RhdGljIGhhc1JlcGVhdGVkUG9pbnRzKHQpe2ZvcihsZXQgZT0xO2U8dC5sZW5ndGg7ZSsrKWlmKHRbZS0xXS5lcXVhbHModFtlXSkpcmV0dXJuITA7cmV0dXJuITF9c3RhdGljIHJlbW92ZVJlcGVhdGVkUG9pbnRzKHQpe2lmKCFYLmhhc1JlcGVhdGVkUG9pbnRzKHQpKXJldHVybiB0O3JldHVybiBuZXcgSSh0LCExKS50b0Nvb3JkaW5hdGVBcnJheSgpfXN0YXRpYyByZXZlcnNlKHQpe2NvbnN0IGU9dC5sZW5ndGgtMSxuPU1hdGgudHJ1bmMoZS8yKTtmb3IobGV0IHM9MDtzPD1uO3MrKyl7Y29uc3Qgbj10W3NdO3Rbc109dFtlLXNdLHRbZS1zXT1ufX1zdGF0aWMgcmVtb3ZlTnVsbCh0KXtsZXQgZT0wO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKW51bGwhPT10W25dJiZlKys7Y29uc3Qgbj1uZXcgQXJyYXkoZSkuZmlsbChudWxsKTtpZigwPT09ZSlyZXR1cm4gbjtsZXQgcz0wO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKW51bGwhPT10W2VdJiYobltzKytdPXRbZV0pO3JldHVybiBufXN0YXRpYyBjb3B5RGVlcCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyllW25dPW5ldyBnKHRbbl0pO3JldHVybiBlfWlmKDU9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWFyZ3VtZW50c1s0XTtmb3IobGV0IHI9MDtyPGk7cisrKW5bcytyXT1uZXcgZyh0W2Urcl0pfX1zdGF0aWMgaXNFcXVhbFJldmVyc2VkKHQsZSl7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspe2NvbnN0IHM9dFtuXSxpPWVbdC5sZW5ndGgtbi0xXTtpZigwIT09cy5jb21wYXJlVG8oaSkpcmV0dXJuITF9cmV0dXJuITB9c3RhdGljIGVudmVsb3BlKHQpe2NvbnN0IGU9bmV3IE47Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspZS5leHBhbmRUb0luY2x1ZGUodFtuXSk7cmV0dXJuIGV9c3RhdGljIHRvQ29vcmRpbmF0ZUFycmF5KHQpe3JldHVybiB0LnRvQXJyYXkoWC5jb29yZEFycmF5VHlwZSl9c3RhdGljIGF0TGVhc3ROQ29vcmRpbmF0ZXNPck5vdGhpbmcodCxlKXtyZXR1cm4gZS5sZW5ndGg+PXQ/ZTpbXX1zdGF0aWMgaW5kZXhPZih0LGUpe2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKWlmKHQuZXF1YWxzKGVbbl0pKXJldHVybiBuO3JldHVybi0xfXN0YXRpYyBpbmNyZWFzaW5nRGlyZWN0aW9uKHQpe2ZvcihsZXQgZT0wO2U8TWF0aC50cnVuYyh0Lmxlbmd0aC8yKTtlKyspe2NvbnN0IG49dC5sZW5ndGgtMS1lLHM9dFtlXS5jb21wYXJlVG8odFtuXSk7aWYoMCE9PXMpcmV0dXJuIHN9cmV0dXJuIDF9c3RhdGljIGNvbXBhcmUodCxlKXtsZXQgbj0wO2Zvcig7bjx0Lmxlbmd0aCYmbjxlLmxlbmd0aDspe2NvbnN0IHM9dFtuXS5jb21wYXJlVG8oZVtuXSk7aWYoMCE9PXMpcmV0dXJuIHM7bisrfXJldHVybiBuPGUubGVuZ3RoPy0xOm48dC5sZW5ndGg/MTowfXN0YXRpYyBtaW5Db29yZGluYXRlKHQpe2xldCBlPW51bGw7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspKG51bGw9PT1lfHxlLmNvbXBhcmVUbyh0W25dKT4wKSYmKGU9dFtuXSk7cmV0dXJuIGV9c3RhdGljIGV4dHJhY3QodCxlLG4pe2U9TS5jbGFtcChlLDAsdC5sZW5ndGgpO2xldCBzPShuPU0uY2xhbXAobiwtMSx0Lmxlbmd0aCkpLWUrMTtuPDAmJihzPTApLGU+PXQubGVuZ3RoJiYocz0wKSxuPGUmJihzPTApO2NvbnN0IGk9bmV3IEFycmF5KHMpLmZpbGwobnVsbCk7aWYoMD09PXMpcmV0dXJuIGk7bGV0IHI9MDtmb3IobGV0IHM9ZTtzPD1uO3MrKylpW3IrK109dFtzXTtyZXR1cm4gaX1nZXRDbGFzcygpe3JldHVybiBYfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyBIe2NvbnN0cnVjdG9yKCl7SC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNvbXBhcmUodCxlKXtjb25zdCBuPXQscz1lO3JldHVybiBYLmNvbXBhcmUobixzKX1nZXRDbGFzcygpe3JldHVybiBIfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltsXX19SC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIFd7Y29uc3RydWN0b3IoKXtXLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y29tcGFyZSh0LGUpe2NvbnN0IG49dCxzPWU7aWYobi5sZW5ndGg8cy5sZW5ndGgpcmV0dXJuLTE7aWYobi5sZW5ndGg+cy5sZW5ndGgpcmV0dXJuIDE7aWYoMD09PW4ubGVuZ3RoKXJldHVybiAwO2NvbnN0IGk9WC5jb21wYXJlKG4scyk7cmV0dXJuIFguaXNFcXVhbFJldmVyc2VkKG4scyk/MDppfU9MRGNvbXBhcmUodCxlKXtjb25zdCBuPXQscz1lO2lmKG4ubGVuZ3RoPHMubGVuZ3RoKXJldHVybi0xO2lmKG4ubGVuZ3RoPnMubGVuZ3RoKXJldHVybiAxO2lmKDA9PT1uLmxlbmd0aClyZXR1cm4gMDtjb25zdCBpPVguaW5jcmVhc2luZ0RpcmVjdGlvbihuKSxyPVguaW5jcmVhc2luZ0RpcmVjdGlvbihzKTtsZXQgbz1pPjA/MDpuLmxlbmd0aC0xLGw9cj4wPzA6bi5sZW5ndGgtMTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoO3QrKyl7Y29uc3QgdD1uW29dLmNvbXBhcmVUbyhzW2xdKTtpZigwIT09dClyZXR1cm4gdDtvKz1pLGwrPXJ9cmV0dXJuIDB9Z2V0Q2xhc3MoKXtyZXR1cm4gV31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bbF19fWZ1bmN0aW9uIGooKXt9ZnVuY3Rpb24gSygpe31mdW5jdGlvbiBaKHQpe3RoaXMubWVzc2FnZT10fHxcIlwifWZ1bmN0aW9uIFEoKXt9ZnVuY3Rpb24gSigpe3RoaXMuYXJyYXlfPVtdLGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZiYmdGhpcy5hZGRBbGwoYXJndW1lbnRzWzBdKX1XLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sWC5Gb3J3YXJkQ29tcGFyYXRvcj1ILFguQmlkaXJlY3Rpb25hbENvbXBhcmF0b3I9VyxYLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sWC5jb29yZEFycmF5VHlwZT1uZXcgQXJyYXkoMCkuZmlsbChudWxsKSxqLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oKXt9LGoucHJvdG90eXBlLnB1dD1mdW5jdGlvbigpe30sai5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe30sai5wcm90b3R5cGUudmFsdWVzPWZ1bmN0aW9uKCl7fSxqLnByb3RvdHlwZS5lbnRyeVNldD1mdW5jdGlvbigpe30sSy5wcm90b3R5cGU9bmV3IGosWi5wcm90b3R5cGU9bmV3IEVycm9yLFoucHJvdG90eXBlLm5hbWU9XCJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRcIixRLnByb3RvdHlwZT1uZXcgZixRLnByb3RvdHlwZS5jb250YWlucz1mdW5jdGlvbigpe30sSi5wcm90b3R5cGU9bmV3IFEsSi5wcm90b3R5cGUuY29udGFpbnM9ZnVuY3Rpb24odCl7Zm9yKGxldCBlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7ZTxuO2UrKyl7aWYodGhpcy5hcnJheV9bZV09PT10KXJldHVybiEwfXJldHVybiExfSxKLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7cmV0dXJuIXRoaXMuY29udGFpbnModCkmJih0aGlzLmFycmF5Xy5wdXNoKHQpLCEwKX0sSi5wcm90b3R5cGUuYWRkQWxsPWZ1bmN0aW9uKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuYWRkKGUubmV4dCgpKTtyZXR1cm4hMH0sSi5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBafSxKLnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXJyYXlfLmxlbmd0aH0sSi5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5hcnJheV8ubGVuZ3RofSxKLnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKCl7Y29uc3QgdD1bXTtmb3IobGV0IGU9MCxuPXRoaXMuYXJyYXlfLmxlbmd0aDtlPG47ZSsrKXQucHVzaCh0aGlzLmFycmF5X1tlXSk7cmV0dXJuIHR9LEoucHJvdG90eXBlLml0ZXJhdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyAkKHRoaXMpfTtjb25zdCAkPWZ1bmN0aW9uKHQpe3RoaXMuaGFzaFNldF89dCx0aGlzLnBvc2l0aW9uXz0wfTskLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7aWYodGhpcy5wb3NpdGlvbl89PT10aGlzLmhhc2hTZXRfLnNpemUoKSl0aHJvdyBuZXcgeTtyZXR1cm4gdGhpcy5oYXNoU2V0Xy5hcnJheV9bdGhpcy5wb3NpdGlvbl8rK119LCQucHJvdG90eXBlLmhhc05leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb3NpdGlvbl88dGhpcy5oYXNoU2V0Xy5zaXplKCl9LCQucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbigpe3Rocm93IG5ldyBafTtmdW5jdGlvbiB0dCh0KXtyZXR1cm4gbnVsbD09dD8wOnQuY29sb3J9ZnVuY3Rpb24gZXQodCl7cmV0dXJuIG51bGw9PXQ/bnVsbDp0LnBhcmVudH1mdW5jdGlvbiBudCh0LGUpe251bGwhPT10JiYodC5jb2xvcj1lKX1mdW5jdGlvbiBzdCh0KXtyZXR1cm4gbnVsbD09dD9udWxsOnQubGVmdH1mdW5jdGlvbiBpdCh0KXtyZXR1cm4gbnVsbD09dD9udWxsOnQucmlnaHR9ZnVuY3Rpb24gcnQoKXt0aGlzLnJvb3RfPW51bGwsdGhpcy5zaXplXz0wfXJ0LnByb3RvdHlwZT1uZXcgSyxydC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLnJvb3RfO251bGwhPT1lOyl7dmFyIG49dC5jb21wYXJlVG8oZS5rZXkpO2lmKG48MCllPWUubGVmdDtlbHNle2lmKCEobj4wKSlyZXR1cm4gZS52YWx1ZTtlPWUucmlnaHR9fXJldHVybiBudWxsfSxydC5wcm90b3R5cGUucHV0PWZ1bmN0aW9uKHQsZSl7aWYobnVsbD09PXRoaXMucm9vdF8pcmV0dXJuIHRoaXMucm9vdF89e2tleTp0LHZhbHVlOmUsbGVmdDpudWxsLHJpZ2h0Om51bGwscGFyZW50Om51bGwsY29sb3I6MCxnZXRWYWx1ZSgpe3JldHVybiB0aGlzLnZhbHVlfSxnZXRLZXkoKXtyZXR1cm4gdGhpcy5rZXl9fSx0aGlzLnNpemVfPTEsbnVsbDt2YXIgbixzLGk9dGhpcy5yb290Xztkb3tpZihuPWksKHM9dC5jb21wYXJlVG8oaS5rZXkpKTwwKWk9aS5sZWZ0O2Vsc2V7aWYoIShzPjApKXt2YXIgcj1pLnZhbHVlO3JldHVybiBpLnZhbHVlPWUscn1pPWkucmlnaHR9fXdoaWxlKG51bGwhPT1pKTt2YXIgbz17a2V5OnQsbGVmdDpudWxsLHJpZ2h0Om51bGwsdmFsdWU6ZSxwYXJlbnQ6bixjb2xvcjowLGdldFZhbHVlKCl7cmV0dXJuIHRoaXMudmFsdWV9LGdldEtleSgpe3JldHVybiB0aGlzLmtleX19O3JldHVybiBzPDA/bi5sZWZ0PW86bi5yaWdodD1vLHRoaXMuZml4QWZ0ZXJJbnNlcnRpb24obyksdGhpcy5zaXplXysrLG51bGx9LHJ0LnByb3RvdHlwZS5maXhBZnRlckluc2VydGlvbj1mdW5jdGlvbih0KXtsZXQgZTtmb3IodC5jb2xvcj0xO251bGwhPXQmJnQhPT10aGlzLnJvb3RfJiYxPT09dC5wYXJlbnQuY29sb3I7KWV0KHQpPT09c3QoZXQoZXQodCkpKT8oZT1pdChldChldCh0KSkpLDE9PT10dChlKT8obnQoZXQodCksMCksbnQoZSwwKSxudChldChldCh0KSksMSksdD1ldChldCh0KSkpOih0PT09aXQoZXQodCkpJiYodD1ldCh0KSx0aGlzLnJvdGF0ZUxlZnQodCkpLG50KGV0KHQpLDApLG50KGV0KGV0KHQpKSwxKSx0aGlzLnJvdGF0ZVJpZ2h0KGV0KGV0KHQpKSkpKTooZT1zdChldChldCh0KSkpLDE9PT10dChlKT8obnQoZXQodCksMCksbnQoZSwwKSxudChldChldCh0KSksMSksdD1ldChldCh0KSkpOih0PT09c3QoZXQodCkpJiYodD1ldCh0KSx0aGlzLnJvdGF0ZVJpZ2h0KHQpKSxudChldCh0KSwwKSxudChldChldCh0KSksMSksdGhpcy5yb3RhdGVMZWZ0KGV0KGV0KHQpKSkpKTt0aGlzLnJvb3RfLmNvbG9yPTB9LHJ0LnByb3RvdHlwZS52YWx1ZXM9ZnVuY3Rpb24oKXt2YXIgdD1uZXcgeCxlPXRoaXMuZ2V0Rmlyc3RFbnRyeSgpO2lmKG51bGwhPT1lKWZvcih0LmFkZChlLnZhbHVlKTtudWxsIT09KGU9cnQuc3VjY2Vzc29yKGUpKTspdC5hZGQoZS52YWx1ZSk7cmV0dXJuIHR9LHJ0LnByb3RvdHlwZS5lbnRyeVNldD1mdW5jdGlvbigpe3ZhciB0PW5ldyBKLGU9dGhpcy5nZXRGaXJzdEVudHJ5KCk7aWYobnVsbCE9PWUpZm9yKHQuYWRkKGUpO251bGwhPT0oZT1ydC5zdWNjZXNzb3IoZSkpOyl0LmFkZChlKTtyZXR1cm4gdH0scnQucHJvdG90eXBlLnJvdGF0ZUxlZnQ9ZnVuY3Rpb24odCl7aWYobnVsbCE9dCl7dmFyIGU9dC5yaWdodDt0LnJpZ2h0PWUubGVmdCxudWxsIT1lLmxlZnQmJihlLmxlZnQucGFyZW50PXQpLGUucGFyZW50PXQucGFyZW50LG51bGw9PXQucGFyZW50P3RoaXMucm9vdF89ZTp0LnBhcmVudC5sZWZ0PT09dD90LnBhcmVudC5sZWZ0PWU6dC5wYXJlbnQucmlnaHQ9ZSxlLmxlZnQ9dCx0LnBhcmVudD1lfX0scnQucHJvdG90eXBlLnJvdGF0ZVJpZ2h0PWZ1bmN0aW9uKHQpe2lmKG51bGwhPXQpe3ZhciBlPXQubGVmdDt0LmxlZnQ9ZS5yaWdodCxudWxsIT1lLnJpZ2h0JiYoZS5yaWdodC5wYXJlbnQ9dCksZS5wYXJlbnQ9dC5wYXJlbnQsbnVsbD09dC5wYXJlbnQ/dGhpcy5yb290Xz1lOnQucGFyZW50LnJpZ2h0PT09dD90LnBhcmVudC5yaWdodD1lOnQucGFyZW50LmxlZnQ9ZSxlLnJpZ2h0PXQsdC5wYXJlbnQ9ZX19LHJ0LnByb3RvdHlwZS5nZXRGaXJzdEVudHJ5PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5yb290XztpZihudWxsIT10KWZvcig7bnVsbCE9dC5sZWZ0Oyl0PXQubGVmdDtyZXR1cm4gdH0scnQuc3VjY2Vzc29yPWZ1bmN0aW9uKHQpe2xldCBlO2lmKG51bGw9PT10KXJldHVybiBudWxsO2lmKG51bGwhPT10LnJpZ2h0KXtmb3IoZT10LnJpZ2h0O251bGwhPT1lLmxlZnQ7KWU9ZS5sZWZ0O3JldHVybiBlfWU9dC5wYXJlbnQ7Zm9yKHZhciBuPXQ7bnVsbCE9PWUmJm49PT1lLnJpZ2h0OyluPWUsZT1lLnBhcmVudDtyZXR1cm4gZX0scnQucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaXplX30scnQucHJvdG90eXBlLmNvbnRhaW5zS2V5PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLnJvb3RfO251bGwhPT1lOyl7dmFyIG49dC5jb21wYXJlVG8oZS5rZXkpO2lmKG48MCllPWUubGVmdDtlbHNle2lmKCEobj4wKSlyZXR1cm4hMDtlPWUucmlnaHR9fXJldHVybiExfTtjbGFzcyBvdHtjb25zdHJ1Y3Rvcigpe290LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q2xhc3MoKXtyZXR1cm4gb3R9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWZ1bmN0aW9uIGx0KCl7fWZ1bmN0aW9uIGF0KCl7dGhpcy5hcnJheV89W10sYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBmJiZ0aGlzLmFkZEFsbChhcmd1bWVudHNbMF0pfW90LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sbHQucHJvdG90eXBlPW5ldyBRLGF0LnByb3RvdHlwZT1uZXcgbHQsYXQucHJvdG90eXBlLmNvbnRhaW5zPWZ1bmN0aW9uKHQpe2ZvcihsZXQgZT0wLG49dGhpcy5hcnJheV8ubGVuZ3RoO2U8bjtlKyspe2lmKDA9PT10aGlzLmFycmF5X1tlXS5jb21wYXJlVG8odCkpcmV0dXJuITB9cmV0dXJuITF9LGF0LnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7aWYodGhpcy5jb250YWlucyh0KSlyZXR1cm4hMTtmb3IobGV0IGU9MCxuPXRoaXMuYXJyYXlfLmxlbmd0aDtlPG47ZSsrKXtpZigxPT09dGhpcy5hcnJheV9bZV0uY29tcGFyZVRvKHQpKXJldHVybiB0aGlzLmFycmF5Xy5zcGxpY2UoZSwwLHQpLCEwfXJldHVybiB0aGlzLmFycmF5Xy5wdXNoKHQpLCEwfSxhdC5wcm90b3R5cGUuYWRkQWxsPWZ1bmN0aW9uKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuYWRkKGUubmV4dCgpKTtyZXR1cm4hMH0sYXQucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbih0KXt0aHJvdyBuZXcgWn0sYXQucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hcnJheV8ubGVuZ3RofSxhdC5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5hcnJheV8ubGVuZ3RofSxhdC5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe2NvbnN0IHQ9W107Zm9yKGxldCBlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7ZTxuO2UrKyl0LnB1c2godGhpcy5hcnJheV9bZV0pO3JldHVybiB0fSxhdC5wcm90b3R5cGUuaXRlcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGN0KHRoaXMpfTtjb25zdCBjdD1mdW5jdGlvbih0KXt0aGlzLnRyZWVTZXRfPXQsdGhpcy5wb3NpdGlvbl89MH07ZnVuY3Rpb24gaHQoKXt9Y3QucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtpZih0aGlzLnBvc2l0aW9uXz09PXRoaXMudHJlZVNldF8uc2l6ZSgpKXRocm93IG5ldyB5O3JldHVybiB0aGlzLnRyZWVTZXRfLmFycmF5X1t0aGlzLnBvc2l0aW9uXysrXX0sY3QucHJvdG90eXBlLmhhc05leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb3NpdGlvbl88dGhpcy50cmVlU2V0Xy5zaXplKCl9LGN0LnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgWn0saHQuc29ydD1mdW5jdGlvbigpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlLG4scyxpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKWk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5jb21wYXJlVG8oZSl9LHQuc29ydChpKTtlbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXM9YXJndW1lbnRzWzFdLGk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gcy5jb21wYXJlKHQsZSl9LHQuc29ydChpKTtlbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtuPXQuc2xpY2UoYXJndW1lbnRzWzFdLGFyZ3VtZW50c1syXSksbi5zb3J0KCk7Y29uc3Qgcz10LnNsaWNlKDAsYXJndW1lbnRzWzFdKS5jb25jYXQobix0LnNsaWNlKGFyZ3VtZW50c1syXSx0Lmxlbmd0aCkpO2Zvcih0LnNwbGljZSgwLHQubGVuZ3RoKSxlPTA7ZTxzLmxlbmd0aDtlKyspdC5wdXNoKHNbZV0pfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe249dC5zbGljZShhcmd1bWVudHNbMV0sYXJndW1lbnRzWzJdKSxzPWFyZ3VtZW50c1szXSxpPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHMuY29tcGFyZSh0LGUpfSxuLnNvcnQoaSk7Y29uc3Qgcj10LnNsaWNlKDAsYXJndW1lbnRzWzFdKS5jb25jYXQobix0LnNsaWNlKGFyZ3VtZW50c1syXSx0Lmxlbmd0aCkpO2Zvcih0LnNwbGljZSgwLHQubGVuZ3RoKSxlPTA7ZTxyLmxlbmd0aDtlKyspdC5wdXNoKHJbZV0pfX0saHQuYXNMaXN0PWZ1bmN0aW9uKHQpe2NvbnN0IGU9bmV3IHg7Zm9yKGxldCBuPTAscz10Lmxlbmd0aDtuPHM7bisrKWUuYWRkKHRbbl0pO3JldHVybiBlfTtjbGFzcyB1dHtjb25zdHJ1Y3Rvcigpe3V0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHRvRGltZW5zaW9uU3ltYm9sKHQpe3N3aXRjaCh0KXtjYXNlIHV0LkZBTFNFOnJldHVybiB1dC5TWU1fRkFMU0U7Y2FzZSB1dC5UUlVFOnJldHVybiB1dC5TWU1fVFJVRTtjYXNlIHV0LkRPTlRDQVJFOnJldHVybiB1dC5TWU1fRE9OVENBUkU7Y2FzZSB1dC5QOnJldHVybiB1dC5TWU1fUDtjYXNlIHV0Lkw6cmV0dXJuIHV0LlNZTV9MO2Nhc2UgdXQuQTpyZXR1cm4gdXQuU1lNX0F9dGhyb3cgbmV3IG4oXCJVbmtub3duIGRpbWVuc2lvbiB2YWx1ZTogXCIrdCl9c3RhdGljIHRvRGltZW5zaW9uVmFsdWUodCl7c3dpdGNoKFQudG9VcHBlckNhc2UodCkpe2Nhc2UgdXQuU1lNX0ZBTFNFOnJldHVybiB1dC5GQUxTRTtjYXNlIHV0LlNZTV9UUlVFOnJldHVybiB1dC5UUlVFO2Nhc2UgdXQuU1lNX0RPTlRDQVJFOnJldHVybiB1dC5ET05UQ0FSRTtjYXNlIHV0LlNZTV9QOnJldHVybiB1dC5QO2Nhc2UgdXQuU1lNX0w6cmV0dXJuIHV0Lkw7Y2FzZSB1dC5TWU1fQTpyZXR1cm4gdXQuQX10aHJvdyBuZXcgbihcIlVua25vd24gZGltZW5zaW9uIHN5bWJvbDogXCIrdCl9Z2V0Q2xhc3MoKXtyZXR1cm4gdXR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXV0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sdXQuUD0wLHV0Lkw9MSx1dC5BPTIsdXQuRkFMU0U9LTEsdXQuVFJVRT0tMix1dC5ET05UQ0FSRT0tMyx1dC5TWU1fRkFMU0U9XCJGXCIsdXQuU1lNX1RSVUU9XCJUXCIsdXQuU1lNX0RPTlRDQVJFPVwiKlwiLHV0LlNZTV9QPVwiMFwiLHV0LlNZTV9MPVwiMVwiLHV0LlNZTV9BPVwiMlwiO2NsYXNzIGd0e2NvbnN0cnVjdG9yKCl7Z3QuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maWx0ZXIodCl7fWdldENsYXNzKCl7cmV0dXJuIGd0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1ndC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIGR0e2NvbnN0cnVjdG9yKCl7ZHQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maWx0ZXIodCxlKXt9aXNEb25lKCl7fWlzR2VvbWV0cnlDaGFuZ2VkKCl7fWdldENsYXNzKCl7cmV0dXJuIGR0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1kdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIF90IGV4dGVuZHMgcXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksX3QuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jb21wdXRlRW52ZWxvcGVJbnRlcm5hbCgpe2NvbnN0IHQ9bmV3IE47Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspdC5leHBhbmRUb0luY2x1ZGUodGhpcy5fZ2VvbWV0cmllc1tlXS5nZXRFbnZlbG9wZUludGVybmFsKCkpO3JldHVybiB0fWdldEdlb21ldHJ5Tih0KXtyZXR1cm4gdGhpcy5fZ2VvbWV0cmllc1t0XX1nZXRDb29yZGluYXRlcygpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuZ2V0TnVtUG9pbnRzKCkpLmZpbGwobnVsbCk7bGV0IGU9LTE7Zm9yKGxldCBuPTA7bjx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtuKyspe2NvbnN0IHM9dGhpcy5fZ2VvbWV0cmllc1tuXS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgbj0wO248cy5sZW5ndGg7bisrKWUrKyx0W2VdPXNbbl19cmV0dXJuIHR9Z2V0QXJlYSgpe2xldCB0PTA7Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspdCs9dGhpcy5fZ2VvbWV0cmllc1tlXS5nZXRBcmVhKCk7cmV0dXJuIHR9ZXF1YWxzRXhhY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZighdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSlyZXR1cm4hMTtjb25zdCBuPXQ7aWYodGhpcy5fZ2VvbWV0cmllcy5sZW5ndGghPT1uLl9nZW9tZXRyaWVzLmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IHQ9MDt0PHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO3QrKylpZighdGhpcy5fZ2VvbWV0cmllc1t0XS5lcXVhbHNFeGFjdChuLl9nZW9tZXRyaWVzW3RdLGUpKXJldHVybiExO3JldHVybiEwfXJldHVybiBzdXBlci5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9bm9ybWFsaXplKCl7Zm9yKGxldCB0PTA7dDx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDt0KyspdGhpcy5fZ2VvbWV0cmllc1t0XS5ub3JtYWxpemUoKTtodC5zb3J0KHRoaXMuX2dlb21ldHJpZXMpfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bnVsbDp0aGlzLl9nZW9tZXRyaWVzWzBdLmdldENvb3JkaW5hdGUoKX1nZXRCb3VuZGFyeURpbWVuc2lvbigpe2xldCB0PXV0LkZBTFNFO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQ9TWF0aC5tYXgodCx0aGlzLl9nZW9tZXRyaWVzW2VdLmdldEJvdW5kYXJ5RGltZW5zaW9uKCkpO3JldHVybiB0fWdldFR5cGVDb2RlKCl7cmV0dXJuIHEuVFlQRUNPREVfR0VPTUVUUllDT0xMRUNUSU9OfWdldERpbWVuc2lvbigpe2xldCB0PXV0LkZBTFNFO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQ9TWF0aC5tYXgodCx0aGlzLl9nZW9tZXRyaWVzW2VdLmdldERpbWVuc2lvbigpKTtyZXR1cm4gdH1nZXRMZW5ndGgoKXtsZXQgdD0wO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQrPXRoaXMuX2dlb21ldHJpZXNbZV0uZ2V0TGVuZ3RoKCk7cmV0dXJuIHR9Z2V0TnVtUG9pbnRzKCl7bGV0IHQ9MDtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0Kz10aGlzLl9nZW9tZXRyaWVzW2VdLmdldE51bVBvaW50cygpO3JldHVybiB0fWdldE51bUdlb21ldHJpZXMoKXtyZXR1cm4gdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGh9cmV2ZXJzZSgpe2NvbnN0IHQ9dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgsZT1uZXcgQXJyYXkodCkuZmlsbChudWxsKTtmb3IobGV0IHQ9MDt0PHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO3QrKyllW3RdPXRoaXMuX2dlb21ldHJpZXNbdF0ucmV2ZXJzZSgpO3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oZSl9Y29tcGFyZVRvU2FtZUNsYXNzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IGF0KGh0LmFzTGlzdCh0aGlzLl9nZW9tZXRyaWVzKSksbj1uZXcgYXQoaHQuYXNMaXN0KHQuX2dlb21ldHJpZXMpKTtyZXR1cm4gdGhpcy5jb21wYXJlKGUsbil9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dCxzPXRoaXMuZ2V0TnVtR2VvbWV0cmllcygpLGk9bi5nZXROdW1HZW9tZXRyaWVzKCk7bGV0IHI9MDtmb3IoO3I8cyYmcjxpOyl7Y29uc3QgdD10aGlzLmdldEdlb21ldHJ5TihyKSxzPW4uZ2V0R2VvbWV0cnlOKHIpLGk9dC5jb21wYXJlVG9TYW1lQ2xhc3MocyxlKTtpZigwIT09aSlyZXR1cm4gaTtyKyt9cmV0dXJuIHI8cz8xOnI8aT8tMTowfX1hcHBseSgpe2lmKF8oYXJndW1lbnRzWzBdLEIpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0aGlzLl9nZW9tZXRyaWVzW2VdLmFwcGx5KHQpfWVsc2UgaWYoXyhhcmd1bWVudHNbMF0sZHQpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZigwPT09dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgpcmV0dXJuIG51bGw7Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCYmKHRoaXMuX2dlb21ldHJpZXNbZV0uYXBwbHkodCksIXQuaXNEb25lKCkpO2UrKyk7dC5pc0dlb21ldHJ5Q2hhbmdlZCgpJiZ0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpfWVsc2UgaWYoXyhhcmd1bWVudHNbMF0sZ3QpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0LmZpbHRlcih0aGlzKTtmb3IobGV0IGU9MDtlPHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO2UrKyl0aGlzLl9nZW9tZXRyaWVzW2VdLmFwcGx5KHQpfWVsc2UgaWYoXyhhcmd1bWVudHNbMF0sRykpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3QuZmlsdGVyKHRoaXMpO2ZvcihsZXQgZT0wO2U8dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXRoaXMuX2dlb21ldHJpZXNbZV0uYXBwbHkodCl9fWdldEJvdW5kYXJ5KCl7cmV0dXJuIHRoaXMuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odGhpcyksdS5zaG91bGROZXZlclJlYWNoSGVyZSgpLG51bGx9Z2V0R2VvbWV0cnlUeXBlKCl7cmV0dXJuIHEuVFlQRU5BTUVfR0VPTUVUUllDT0xMRUNUSU9OfWNvcHkoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuX2dlb21ldHJpZXNbZV0uY29weSgpO3JldHVybiBuZXcgX3QodCx0aGlzLl9mYWN0b3J5KX1pc0VtcHR5KCl7Zm9yKGxldCB0PTA7dDx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDt0KyspaWYoIXRoaXMuX2dlb21ldHJpZXNbdF0uaXNFbXB0eSgpKXJldHVybiExO3JldHVybiEwfWdldENsYXNzKCl7cmV0dXJuIF90fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1fdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9nZW9tZXRyaWVzPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2xldCB0PWFyZ3VtZW50c1swXTtjb25zdCBlPWFyZ3VtZW50c1sxXTtpZihxLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsZSksbnVsbD09PXQmJih0PVtdKSxxLmhhc051bGxFbGVtZW50cyh0KSl0aHJvdyBuZXcgbihcImdlb21ldHJpZXMgbXVzdCBub3QgY29udGFpbiBudWxsIGVsZW1lbnRzXCIpO3RoaXMuX2dlb21ldHJpZXM9dH19LF90LnNlcmlhbFZlcnNpb25VSUQ9LTB4NGYwN2JjYjFmODU3ZDgwMDtjbGFzcyBmdCBleHRlbmRzIF90e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxmdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWVxdWFsc0V4YWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuISF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpJiZzdXBlci5lcXVhbHNFeGFjdC5jYWxsKHRoaXMsdCxlKX1yZXR1cm4gc3VwZXIuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldEJvdW5kYXJ5RGltZW5zaW9uKCl7cmV0dXJuIHRoaXMuaXNDbG9zZWQoKT91dC5GQUxTRTowfWlzQ2xvc2VkKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuITE7Zm9yKGxldCB0PTA7dDx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDt0KyspaWYoIXRoaXMuX2dlb21ldHJpZXNbdF0uaXNDbG9zZWQoKSlyZXR1cm4hMTtyZXR1cm4hMH1nZXRUeXBlQ29kZSgpe3JldHVybiBxLlRZUEVDT0RFX01VTFRJTElORVNUUklOR31nZXREaW1lbnNpb24oKXtyZXR1cm4gMX1yZXZlcnNlKCl7Y29uc3QgdD10aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCxlPW5ldyBBcnJheSh0KS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248dGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7bisrKWVbdC0xLW5dPXRoaXMuX2dlb21ldHJpZXNbbl0ucmV2ZXJzZSgpO3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoZSl9Z2V0Qm91bmRhcnkoKXtyZXR1cm4gbmV3IHB0KHRoaXMpLmdldEJvdW5kYXJ5KCl9Z2V0R2VvbWV0cnlUeXBlKCl7cmV0dXJuIHEuVFlQRU5BTUVfTVVMVElMSU5FU1RSSU5HfWNvcHkoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuX2dlb21ldHJpZXNbZV0uY29weSgpO3JldHVybiBuZXcgZnQodCx0aGlzLl9mYWN0b3J5KX1nZXRDbGFzcygpe3JldHVybiBmdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bb3RdfX1mdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtfdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSl9LGZ0LnNlcmlhbFZlcnNpb25VSUQ9MHg3MTU1ZDJhYjRhZmE4MDAwO2NsYXNzIHB0e2NvbnN0cnVjdG9yKCl7cHQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZ2V0Qm91bmRhcnkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBwdCh0KS5nZXRCb3VuZGFyeSgpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IHB0KHQsZSkuZ2V0Qm91bmRhcnkoKX19Ym91bmRhcnlNdWx0aUxpbmVTdHJpbmcodCl7aWYodGhpcy5fZ2VvbS5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZ2V0RW1wdHlNdWx0aVBvaW50KCk7Y29uc3QgZT10aGlzLmNvbXB1dGVCb3VuZGFyeUNvb3JkaW5hdGVzKHQpO3JldHVybiAxPT09ZS5sZW5ndGg/dGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9pbnQoZVswXSk6dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludEZyb21Db29yZHMoZSl9Z2V0Qm91bmRhcnkoKXtyZXR1cm4gdGhpcy5fZ2VvbSBpbnN0YW5jZW9mIFR0P3RoaXMuYm91bmRhcnlMaW5lU3RyaW5nKHRoaXMuX2dlb20pOnRoaXMuX2dlb20gaW5zdGFuY2VvZiBmdD90aGlzLmJvdW5kYXJ5TXVsdGlMaW5lU3RyaW5nKHRoaXMuX2dlb20pOnRoaXMuX2dlb20uZ2V0Qm91bmRhcnkoKX1ib3VuZGFyeUxpbmVTdHJpbmcodCl7aWYodGhpcy5fZ2VvbS5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZ2V0RW1wdHlNdWx0aVBvaW50KCk7aWYodC5pc0Nsb3NlZCgpKXtyZXR1cm4gdGhpcy5fYm5SdWxlLmlzSW5Cb3VuZGFyeSgyKT90LmdldFN0YXJ0UG9pbnQoKTp0aGlzLl9nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50KCl9cmV0dXJuIHRoaXMuX2dlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnQoW3QuZ2V0U3RhcnRQb2ludCgpLHQuZ2V0RW5kUG9pbnQoKV0pfWdldEVtcHR5TXVsdGlQb2ludCgpe3JldHVybiB0aGlzLl9nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50KCl9Y29tcHV0ZUJvdW5kYXJ5Q29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcgeDt0aGlzLl9lbmRwb2ludE1hcD1uZXcgcnQ7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7MCE9PW4uZ2V0TnVtUG9pbnRzKCkmJih0aGlzLmFkZEVuZHBvaW50KG4uZ2V0Q29vcmRpbmF0ZU4oMCkpLHRoaXMuYWRkRW5kcG9pbnQobi5nZXRDb29yZGluYXRlTihuLmdldE51bVBvaW50cygpLTEpKSl9Zm9yKGxldCB0PXRoaXMuX2VuZHBvaW50TWFwLmVudHJ5U2V0KCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IG49dC5uZXh0KCkscz1uLmdldFZhbHVlKCkuY291bnQ7dGhpcy5fYm5SdWxlLmlzSW5Cb3VuZGFyeShzKSYmZS5hZGQobi5nZXRLZXkoKSl9cmV0dXJuIFgudG9Db29yZGluYXRlQXJyYXkoZSl9YWRkRW5kcG9pbnQodCl7bGV0IGU9dGhpcy5fZW5kcG9pbnRNYXAuZ2V0KHQpO251bGw9PT1lJiYoZT1uZXcgbXQsdGhpcy5fZW5kcG9pbnRNYXAucHV0KHQsZSkpLGUuY291bnQrK31nZXRDbGFzcygpe3JldHVybiBwdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19cHQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fZ2VvbT1udWxsLHRoaXMuX2dlb21GYWN0PW51bGwsdGhpcy5fYm5SdWxlPW51bGwsdGhpcy5fZW5kcG9pbnRNYXA9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cHQuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LFYuTU9EMl9CT1VOREFSWV9SVUxFKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9nZW9tPXQsdGhpcy5fZ2VvbUZhY3Q9dC5nZXRGYWN0b3J5KCksdGhpcy5fYm5SdWxlPWV9fTtjbGFzcyBtdHtjb25zdHJ1Y3Rvcigpe210LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q2xhc3MoKXtyZXR1cm4gbXR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fW10LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuY291bnQ9bnVsbH07Y2xhc3MgeXR7Y29uc3RydWN0b3IoKXt5dC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBvZkxpbmUodCl7Y29uc3QgZT10LnNpemUoKTtpZihlPD0xKXJldHVybiAwO2xldCBuPTA7Y29uc3Qgcz1uZXcgZzt0LmdldENvb3JkaW5hdGUoMCxzKTtsZXQgaT1zLngscj1zLnk7Zm9yKGxldCBvPTE7bzxlO28rKyl7dC5nZXRDb29yZGluYXRlKG8scyk7Y29uc3QgZT1zLngsbD1zLnksYT1lLWksYz1sLXI7bis9TWF0aC5zcXJ0KGEqYStjKmMpLGk9ZSxyPWx9cmV0dXJuIG59Z2V0Q2xhc3MoKXtyZXR1cm4geXR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWZ1bmN0aW9uIHh0KCl7fWZ1bmN0aW9uIEV0KCl7fWZ1bmN0aW9uIEl0KCl7fWZ1bmN0aW9uIE50KCl7fWZ1bmN0aW9uIEN0KCl7fXl0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgU3R7Y29uc3RydWN0b3IoKXtTdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjaGFycyh0LGUpe2NvbnN0IG49bmV3IEFycmF5KGUpLmZpbGwobnVsbCk7Zm9yKGxldCBzPTA7czxlO3MrKyluW3NdPXQ7cmV0dXJuIG5ldyBTdHJpbmcobil9c3RhdGljIGdldFN0YWNrVHJhY2UoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgSXQsbj1uZXcgeHQoZSk7cmV0dXJuIHQucHJpbnRTdGFja1RyYWNlKG4pLGUudG9TdHJpbmcoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bGV0IG49XCJcIjtjb25zdCBzPW5ldyBDdChuZXcgRXQoU3QuZ2V0U3RhY2tUcmFjZSh0KSkpO2ZvcihsZXQgdD0wO3Q8ZTt0KyspdHJ5e24rPXMucmVhZExpbmUoKStTdC5ORVdMSU5FfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIE50KSl0aHJvdyB0O3Uuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKX1yZXR1cm4gbn19c3RhdGljIHNwbGl0KHQsZSl7Y29uc3Qgbj1lLmxlbmd0aCxzPW5ldyB4O2xldCBpPVwiXCIrdCxyPWkuaW5kZXhPZihlKTtmb3IoO3I+PTA7KXtjb25zdCB0PWkuc3Vic3RyaW5nKDAscik7cy5hZGQodCksaT1pLnN1YnN0cmluZyhyK24pLHI9aS5pbmRleE9mKGUpfWkubGVuZ3RoPjAmJnMuYWRkKGkpO2NvbnN0IG89bmV3IEFycmF5KHMuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgdD0wO3Q8by5sZW5ndGg7dCsrKW9bdF09cy5nZXQodCk7cmV0dXJuIG99c3RhdGljIHRvU3RyaW5nKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBTdC5TSU1QTEVfT1JESU5BVEVfRk9STUFULmZvcm1hdCh0KX19c3RhdGljIHNwYWNlcyh0KXtyZXR1cm4gU3QuY2hhcnMoXCIgXCIsdCl9Z2V0Q2xhc3MoKXtyZXR1cm4gU3R9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWZ1bmN0aW9uIHd0KHQpe3RoaXMuc3RyPXR9U3QuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxTdC5ORVdMSU5FPU8uZ2V0UHJvcGVydHkoXCJsaW5lLnNlcGFyYXRvclwiKSxTdC5TSU1QTEVfT1JESU5BVEVfRk9STUFUPW5ldyBmdW5jdGlvbigpe30oXCIwLiNcIiksd3QucHJvdG90eXBlLmFwcGVuZD1mdW5jdGlvbih0KXt0aGlzLnN0cis9dH0sd3QucHJvdG90eXBlLnNldENoYXJBdD1mdW5jdGlvbih0LGUpe3RoaXMuc3RyPXRoaXMuc3RyLnN1YnN0cigwLHQpK2UrdGhpcy5zdHIuc3Vic3RyKHQrMSl9LHd0LnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5zdHJ9O2NsYXNzIEx0e2NvbnN0cnVjdG9yKCl7THQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29weUNvb3JkKHQsZSxuLHMpe2NvbnN0IGk9TWF0aC5taW4odC5nZXREaW1lbnNpb24oKSxuLmdldERpbWVuc2lvbigpKTtmb3IobGV0IHI9MDtyPGk7cisrKW4uc2V0T3JkaW5hdGUocyxyLHQuZ2V0T3JkaW5hdGUoZSxyKSl9c3RhdGljIGlzUmluZyh0KXtjb25zdCBlPXQuc2l6ZSgpO3JldHVybiAwPT09ZXx8IShlPD0zKSYmKHQuZ2V0T3JkaW5hdGUoMCxBLlgpPT09dC5nZXRPcmRpbmF0ZShlLTEsQS5YKSYmdC5nZXRPcmRpbmF0ZSgwLEEuWSk9PT10LmdldE9yZGluYXRlKGUtMSxBLlkpKX1zdGF0aWMgaXNFcXVhbCh0LGUpe2NvbnN0IG49dC5zaXplKCk7aWYobiE9PWUuc2l6ZSgpKXJldHVybiExO2NvbnN0IHM9TWF0aC5taW4odC5nZXREaW1lbnNpb24oKSxlLmdldERpbWVuc2lvbigpKTtmb3IobGV0IHI9MDtyPG47cisrKWZvcihsZXQgbj0wO248cztuKyspe2NvbnN0IHM9dC5nZXRPcmRpbmF0ZShyLG4pLG89ZS5nZXRPcmRpbmF0ZShyLG4pO2lmKHQuZ2V0T3JkaW5hdGUocixuKSE9PWUuZ2V0T3JkaW5hdGUocixuKSYmKCFpLmlzTmFOKHMpfHwhaS5pc05hTihvKSkpcmV0dXJuITF9cmV0dXJuITB9c3RhdGljIGV4dGVuZCh0LGUsbil7Y29uc3Qgcz10LmNyZWF0ZShuLGUuZ2V0RGltZW5zaW9uKCkpLGk9ZS5zaXplKCk7aWYoTHQuY29weShlLDAscywwLGkpLGk+MClmb3IobGV0IHQ9aTt0PG47dCsrKUx0LmNvcHkoZSxpLTEscyx0LDEpO3JldHVybiBzfXN0YXRpYyByZXZlcnNlKHQpe2NvbnN0IGU9dC5zaXplKCktMSxuPU1hdGgudHJ1bmMoZS8yKTtmb3IobGV0IHM9MDtzPD1uO3MrKylMdC5zd2FwKHQscyxlLXMpfXN0YXRpYyBzd2FwKHQsZSxuKXtpZihlPT09bilyZXR1cm4gbnVsbDtmb3IobGV0IHM9MDtzPHQuZ2V0RGltZW5zaW9uKCk7cysrKXtjb25zdCBpPXQuZ2V0T3JkaW5hdGUoZSxzKTt0LnNldE9yZGluYXRlKGUscyx0LmdldE9yZGluYXRlKG4scykpLHQuc2V0T3JkaW5hdGUobixzLGkpfX1zdGF0aWMgY29weSh0LGUsbixzLGkpe2ZvcihsZXQgcj0wO3I8aTtyKyspTHQuY29weUNvb3JkKHQsZStyLG4scytyKX1zdGF0aWMgdG9TdHJpbmcoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCYmXyhhcmd1bWVudHNbMF0sQSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dC5zaXplKCk7aWYoMD09PWUpcmV0dXJuXCIoKVwiO2NvbnN0IG49dC5nZXREaW1lbnNpb24oKSxzPW5ldyB3dDtzLmFwcGVuZChcIihcIik7Zm9yKGxldCBpPTA7aTxlO2krKyl7aT4wJiZzLmFwcGVuZChcIiBcIik7Zm9yKGxldCBlPTA7ZTxuO2UrKyllPjAmJnMuYXBwZW5kKFwiLFwiKSxzLmFwcGVuZChTdC50b1N0cmluZyh0LmdldE9yZGluYXRlKGksZSkpKX1yZXR1cm4gcy5hcHBlbmQoXCIpXCIpLHMudG9TdHJpbmcoKX19c3RhdGljIGVuc3VyZVZhbGlkUmluZyh0LGUpe2NvbnN0IG49ZS5zaXplKCk7cmV0dXJuIDA9PT1uP2U6bjw9Mz9MdC5jcmVhdGVDbG9zZWRSaW5nKHQsZSw0KTplLmdldE9yZGluYXRlKDAsQS5YKT09PWUuZ2V0T3JkaW5hdGUobi0xLEEuWCkmJmUuZ2V0T3JkaW5hdGUoMCxBLlkpPT09ZS5nZXRPcmRpbmF0ZShuLTEsQS5ZKT9lOkx0LmNyZWF0ZUNsb3NlZFJpbmcodCxlLG4rMSl9c3RhdGljIGNyZWF0ZUNsb3NlZFJpbmcodCxlLG4pe2NvbnN0IHM9dC5jcmVhdGUobixlLmdldERpbWVuc2lvbigpKSxpPWUuc2l6ZSgpO0x0LmNvcHkoZSwwLHMsMCxpKTtmb3IobGV0IHQ9aTt0PG47dCsrKUx0LmNvcHkoZSwwLHMsdCwxKTtyZXR1cm4gc31nZXRDbGFzcygpe3JldHVybiBMdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19THQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBUdCBleHRlbmRzIHF7Y29uc3RydWN0b3IoKXtzdXBlcigpLFR0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y29tcHV0ZUVudmVsb3BlSW50ZXJuYWwoKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bmV3IE46dGhpcy5fcG9pbnRzLmV4cGFuZEVudmVsb3BlKG5ldyBOKX1pc1JpbmcoKXtyZXR1cm4gdGhpcy5pc0Nsb3NlZCgpJiZ0aGlzLmlzU2ltcGxlKCl9Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5fcG9pbnRzLnRvQ29vcmRpbmF0ZUFycmF5KCl9ZXF1YWxzRXhhY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZighdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSlyZXR1cm4hMTtjb25zdCBuPXQ7aWYodGhpcy5fcG9pbnRzLnNpemUoKSE9PW4uX3BvaW50cy5zaXplKCkpcmV0dXJuITE7Zm9yKGxldCB0PTA7dDx0aGlzLl9wb2ludHMuc2l6ZSgpO3QrKylpZighdGhpcy5lcXVhbCh0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KSxuLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KSxlKSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4gc3VwZXIuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfW5vcm1hbGl6ZSgpe2ZvcihsZXQgdD0wO3Q8TWF0aC50cnVuYyh0aGlzLl9wb2ludHMuc2l6ZSgpLzIpO3QrKyl7Y29uc3QgZT10aGlzLl9wb2ludHMuc2l6ZSgpLTEtdDtpZighdGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUodCkuZXF1YWxzKHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKGUpKSl7aWYodGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUodCkuY29tcGFyZVRvKHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKGUpKT4wKXtjb25zdCB0PXRoaXMuX3BvaW50cy5jb3B5KCk7THQucmV2ZXJzZSh0KSx0aGlzLl9wb2ludHM9dH1yZXR1cm4gbnVsbH19fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bnVsbDp0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZSgwKX1nZXRCb3VuZGFyeURpbWVuc2lvbigpe3JldHVybiB0aGlzLmlzQ2xvc2VkKCk/dXQuRkFMU0U6MH1pc0Nsb3NlZCgpe3JldHVybiF0aGlzLmlzRW1wdHkoKSYmdGhpcy5nZXRDb29yZGluYXRlTigwKS5lcXVhbHMyRCh0aGlzLmdldENvb3JkaW5hdGVOKHRoaXMuZ2V0TnVtUG9pbnRzKCktMSkpfWdldEVuZFBvaW50KCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP251bGw6dGhpcy5nZXRQb2ludE4odGhpcy5nZXROdW1Qb2ludHMoKS0xKX1nZXRUeXBlQ29kZSgpe3JldHVybiBxLlRZUEVDT0RFX0xJTkVTVFJJTkd9Z2V0RGltZW5zaW9uKCl7cmV0dXJuIDF9Z2V0TGVuZ3RoKCl7cmV0dXJuIHl0Lm9mTGluZSh0aGlzLl9wb2ludHMpfWdldE51bVBvaW50cygpe3JldHVybiB0aGlzLl9wb2ludHMuc2l6ZSgpfXJldmVyc2UoKXtjb25zdCB0PXRoaXMuX3BvaW50cy5jb3B5KCk7cmV0dXJuIEx0LnJldmVyc2UodCksdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyh0KX1jb21wYXJlVG9TYW1lQ2xhc3MoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bGV0IGU9MCxuPTA7Zm9yKDtlPHRoaXMuX3BvaW50cy5zaXplKCkmJm48dC5fcG9pbnRzLnNpemUoKTspe2NvbnN0IHM9dGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUoZSkuY29tcGFyZVRvKHQuX3BvaW50cy5nZXRDb29yZGluYXRlKG4pKTtpZigwIT09cylyZXR1cm4gcztlKyssbisrfXJldHVybiBlPHRoaXMuX3BvaW50cy5zaXplKCk/MTpuPHQuX3BvaW50cy5zaXplKCk/LTE6MH1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIGFyZ3VtZW50c1sxXS5jb21wYXJlKHRoaXMuX3BvaW50cyx0Ll9wb2ludHMpfX1hcHBseSgpe2lmKF8oYXJndW1lbnRzWzBdLEIpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHRoaXMuX3BvaW50cy5zaXplKCk7ZSsrKXQuZmlsdGVyKHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKGUpKX1lbHNlIGlmKF8oYXJndW1lbnRzWzBdLGR0KSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYoMD09PXRoaXMuX3BvaW50cy5zaXplKCkpcmV0dXJuIG51bGw7Zm9yKGxldCBlPTA7ZTx0aGlzLl9wb2ludHMuc2l6ZSgpJiYodC5maWx0ZXIodGhpcy5fcG9pbnRzLGUpLCF0LmlzRG9uZSgpKTtlKyspO3QuaXNHZW9tZXRyeUNoYW5nZWQoKSYmdGhpcy5nZW9tZXRyeUNoYW5nZWQoKX1lbHNlIGlmKF8oYXJndW1lbnRzWzBdLGd0KSl7YXJndW1lbnRzWzBdLmZpbHRlcih0aGlzKX1lbHNlIGlmKF8oYXJndW1lbnRzWzBdLEcpKXthcmd1bWVudHNbMF0uZmlsdGVyKHRoaXMpfX1nZXRCb3VuZGFyeSgpe3JldHVybiBuZXcgcHQodGhpcykuZ2V0Qm91bmRhcnkoKX1pc0VxdWl2YWxlbnRDbGFzcyh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIFR0fWdldENvb3JkaW5hdGVOKHQpe3JldHVybiB0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KX1nZXRHZW9tZXRyeVR5cGUoKXtyZXR1cm4gcS5UWVBFTkFNRV9MSU5FU1RSSU5HfWNvcHkoKXtyZXR1cm4gbmV3IFR0KHRoaXMuX3BvaW50cy5jb3B5KCksdGhpcy5fZmFjdG9yeSl9Z2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCl7cmV0dXJuIHRoaXMuX3BvaW50c31pc0VtcHR5KCl7cmV0dXJuIDA9PT10aGlzLl9wb2ludHMuc2l6ZSgpfWluaXQodCl7aWYobnVsbD09PXQmJih0PXRoaXMuZ2V0RmFjdG9yeSgpLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKSwxPT09dC5zaXplKCkpdGhyb3cgbmV3IG4oXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gTGluZVN0cmluZyAoZm91bmQgXCIrdC5zaXplKCkrXCIgLSBtdXN0IGJlIDAgb3IgPj0gMilcIik7dGhpcy5fcG9pbnRzPXR9aXNDb29yZGluYXRlKHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5fcG9pbnRzLnNpemUoKTtlKyspaWYodGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUoZSkuZXF1YWxzKHQpKXJldHVybiEwO3JldHVybiExfWdldFN0YXJ0UG9pbnQoKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bnVsbDp0aGlzLmdldFBvaW50TigwKX1nZXRQb2ludE4odCl7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKHQpKX1nZXRDbGFzcygpe3JldHVybiBUdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bb3RdfX1UdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9wb2ludHM9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLGUpLHRoaXMuaW5pdCh0KX19LFR0LnNlcmlhbFZlcnNpb25VSUQ9MHgyYjJiNTFiYTQzNWM4ZTAwO2NsYXNzIFJ0e2NvbnN0cnVjdG9yKCl7UnQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDbGFzcygpe3JldHVybiBSdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19UnQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBQdCBleHRlbmRzIHF7Y29uc3RydWN0b3IoKXtzdXBlcigpLFB0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y29tcHV0ZUVudmVsb3BlSW50ZXJuYWwoKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbmV3IE47Y29uc3QgdD1uZXcgTjtyZXR1cm4gdC5leHBhbmRUb0luY2x1ZGUodGhpcy5fY29vcmRpbmF0ZXMuZ2V0WCgwKSx0aGlzLl9jb29yZGluYXRlcy5nZXRZKDApKSx0fWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP1tdOlt0aGlzLmdldENvb3JkaW5hdGUoKV19ZXF1YWxzRXhhY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4hIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCkmJighKCF0aGlzLmlzRW1wdHkoKXx8IXQuaXNFbXB0eSgpKXx8dGhpcy5pc0VtcHR5KCk9PT10LmlzRW1wdHkoKSYmdGhpcy5lcXVhbCh0LmdldENvb3JkaW5hdGUoKSx0aGlzLmdldENvb3JkaW5hdGUoKSxlKSl9cmV0dXJuIHN1cGVyLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1ub3JtYWxpemUoKXt9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiAwIT09dGhpcy5fY29vcmRpbmF0ZXMuc2l6ZSgpP3RoaXMuX2Nvb3JkaW5hdGVzLmdldENvb3JkaW5hdGUoMCk6bnVsbH1nZXRCb3VuZGFyeURpbWVuc2lvbigpe3JldHVybiB1dC5GQUxTRX1nZXRUeXBlQ29kZSgpe3JldHVybiBxLlRZUEVDT0RFX1BPSU5UfWdldERpbWVuc2lvbigpe3JldHVybiAwfWdldE51bVBvaW50cygpe3JldHVybiB0aGlzLmlzRW1wdHkoKT8wOjF9cmV2ZXJzZSgpe3JldHVybiB0aGlzLmNvcHkoKX1nZXRYKCl7aWYobnVsbD09PXRoaXMuZ2V0Q29vcmRpbmF0ZSgpKXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJnZXRYIGNhbGxlZCBvbiBlbXB0eSBQb2ludFwiKTtyZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlKCkueH1jb21wYXJlVG9TYW1lQ2xhc3MoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLmNvbXBhcmVUbyh0LmdldENvb3JkaW5hdGUoKSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBhcmd1bWVudHNbMV0uY29tcGFyZSh0aGlzLl9jb29yZGluYXRlcyx0Ll9jb29yZGluYXRlcyl9fWFwcGx5KCl7aWYoXyhhcmd1bWVudHNbMF0sQikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBudWxsO3QuZmlsdGVyKHRoaXMuZ2V0Q29vcmRpbmF0ZSgpKX1lbHNlIGlmKF8oYXJndW1lbnRzWzBdLGR0KSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dC5maWx0ZXIodGhpcy5fY29vcmRpbmF0ZXMsMCksdC5pc0dlb21ldHJ5Q2hhbmdlZCgpJiZ0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpfWVsc2UgaWYoXyhhcmd1bWVudHNbMF0sZ3QpKXthcmd1bWVudHNbMF0uZmlsdGVyKHRoaXMpfWVsc2UgaWYoXyhhcmd1bWVudHNbMF0sRykpe2FyZ3VtZW50c1swXS5maWx0ZXIodGhpcyl9fWdldEJvdW5kYXJ5KCl7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBxLlRZUEVOQU1FX1BPSU5UfWNvcHkoKXtyZXR1cm4gbmV3IFB0KHRoaXMuX2Nvb3JkaW5hdGVzLmNvcHkoKSx0aGlzLl9mYWN0b3J5KX1nZXRDb29yZGluYXRlU2VxdWVuY2UoKXtyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXN9Z2V0WSgpe2lmKG51bGw9PT10aGlzLmdldENvb3JkaW5hdGUoKSl0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKFwiZ2V0WSBjYWxsZWQgb24gZW1wdHkgUG9pbnRcIik7cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLnl9aXNFbXB0eSgpe3JldHVybiAwPT09dGhpcy5fY29vcmRpbmF0ZXMuc2l6ZSgpfWluaXQodCl7bnVsbD09PXQmJih0PXRoaXMuZ2V0RmFjdG9yeSgpLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKSx1LmlzVHJ1ZSh0LnNpemUoKTw9MSksdGhpcy5fY29vcmRpbmF0ZXM9dH1pc1NpbXBsZSgpe3JldHVybiEwfWdldENsYXNzKCl7cmV0dXJuIFB0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltSdF19fVB0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2Nvb3JkaW5hdGVzPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLGUpLHRoaXMuaW5pdCh0KX0sUHQuc2VyaWFsVmVyc2lvblVJRD0weDQ0MDc3YmFkMTYxY2JjMDA7Y2xhc3MgdnR7Y29uc3RydWN0b3IoKXt2dC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBvZlJpbmcoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gTWF0aC5hYnModnQub2ZSaW5nU2lnbmVkKHQpKX1pZihfKGFyZ3VtZW50c1swXSxBKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIE1hdGguYWJzKHZ0Lm9mUmluZ1NpZ25lZCh0KSl9fXN0YXRpYyBvZlJpbmdTaWduZWQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0Lmxlbmd0aDwzKXJldHVybiAwO2xldCBlPTA7Y29uc3Qgbj10WzBdLng7Zm9yKGxldCBzPTE7czx0Lmxlbmd0aC0xO3MrKyl7Y29uc3QgaT10W3NdLngtbixyPXRbcysxXS55O2UrPWkqKHRbcy0xXS55LXIpfXJldHVybiBlLzJ9aWYoXyhhcmd1bWVudHNbMF0sQSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dC5zaXplKCk7aWYoZTwzKXJldHVybiAwO2NvbnN0IG49bmV3IGcscz1uZXcgZyxpPW5ldyBnO3QuZ2V0Q29vcmRpbmF0ZSgwLHMpLHQuZ2V0Q29vcmRpbmF0ZSgxLGkpO2NvbnN0IHI9cy54O2kueC09cjtsZXQgbz0wO2ZvcihsZXQgbD0xO2w8ZS0xO2wrKyluLnk9cy55LHMueD1pLngscy55PWkueSx0LmdldENvb3JkaW5hdGUobCsxLGkpLGkueC09cixvKz1zLngqKG4ueS1pLnkpO3JldHVybiBvLzJ9fWdldENsYXNzKCl7cmV0dXJuIHZ0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX12dC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIE90e2NvbnN0cnVjdG9yKCl7T3QuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDbGFzcygpe3JldHVybiBPdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19T3QuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBidCBleHRlbmRzIHF7Y29uc3RydWN0b3IoKXtzdXBlcigpLGJ0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y29tcHV0ZUVudmVsb3BlSW50ZXJuYWwoKXtyZXR1cm4gdGhpcy5fc2hlbGwuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpfWdldENvb3JkaW5hdGVzKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuW107Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5nZXROdW1Qb2ludHMoKSkuZmlsbChudWxsKTtsZXQgZT0tMTtjb25zdCBuPXRoaXMuX3NoZWxsLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBzPTA7czxuLmxlbmd0aDtzKyspZSsrLHRbZV09bltzXTtmb3IobGV0IG49MDtuPHRoaXMuX2hvbGVzLmxlbmd0aDtuKyspe2NvbnN0IHM9dGhpcy5faG9sZXNbbl0uZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IG49MDtuPHMubGVuZ3RoO24rKyllKyssdFtlXT1zW25dfXJldHVybiB0fWdldEFyZWEoKXtsZXQgdD0wO3QrPXZ0Lm9mUmluZyh0aGlzLl9zaGVsbC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9ob2xlcy5sZW5ndGg7ZSsrKXQtPXZ0Lm9mUmluZyh0aGlzLl9ob2xlc1tlXS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSk7cmV0dXJuIHR9aXNSZWN0YW5nbGUoKXtpZigwIT09dGhpcy5nZXROdW1JbnRlcmlvclJpbmcoKSlyZXR1cm4hMTtpZihudWxsPT09dGhpcy5fc2hlbGwpcmV0dXJuITE7aWYoNSE9PXRoaXMuX3NoZWxsLmdldE51bVBvaW50cygpKXJldHVybiExO2NvbnN0IHQ9dGhpcy5fc2hlbGwuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksZT10aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKTtmb3IobGV0IG49MDtuPDU7bisrKXtjb25zdCBzPXQuZ2V0WChuKTtpZihzIT09ZS5nZXRNaW5YKCkmJnMhPT1lLmdldE1heFgoKSlyZXR1cm4hMTtjb25zdCBpPXQuZ2V0WShuKTtpZihpIT09ZS5nZXRNaW5ZKCkmJmkhPT1lLmdldE1heFkoKSlyZXR1cm4hMX1sZXQgbj10LmdldFgoMCkscz10LmdldFkoMCk7Zm9yKGxldCBlPTE7ZTw9NDtlKyspe2NvbnN0IGk9dC5nZXRYKGUpLHI9dC5nZXRZKGUpO2lmKGkhPT1uPT09KHIhPT1zKSlyZXR1cm4hMTtuPWkscz1yfXJldHVybiEwfWVxdWFsc0V4YWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCkpcmV0dXJuITE7Y29uc3Qgbj10LHM9dGhpcy5fc2hlbGwsaT1uLl9zaGVsbDtpZighcy5lcXVhbHNFeGFjdChpLGUpKXJldHVybiExO2lmKHRoaXMuX2hvbGVzLmxlbmd0aCE9PW4uX2hvbGVzLmxlbmd0aClyZXR1cm4hMTtmb3IobGV0IHQ9MDt0PHRoaXMuX2hvbGVzLmxlbmd0aDt0KyspaWYoIXRoaXMuX2hvbGVzW3RdLmVxdWFsc0V4YWN0KG4uX2hvbGVzW3RdLGUpKXJldHVybiExO3JldHVybiEwfXJldHVybiBzdXBlci5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9bm9ybWFsaXplKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe3RoaXMubm9ybWFsaXplKHRoaXMuX3NoZWxsLCEwKTtmb3IobGV0IHQ9MDt0PHRoaXMuX2hvbGVzLmxlbmd0aDt0KyspdGhpcy5ub3JtYWxpemUodGhpcy5faG9sZXNbdF0sITEpO2h0LnNvcnQodGhpcy5faG9sZXMpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IG49bmV3IEFycmF5KHQuZ2V0Q29vcmRpbmF0ZXMoKS5sZW5ndGgtMSkuZmlsbChudWxsKTtPLmFycmF5Y29weSh0LmdldENvb3JkaW5hdGVzKCksMCxuLDAsbi5sZW5ndGgpO2NvbnN0IHM9WC5taW5Db29yZGluYXRlKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7WC5zY3JvbGwobixzKSxPLmFycmF5Y29weShuLDAsdC5nZXRDb29yZGluYXRlcygpLDAsbi5sZW5ndGgpLHQuZ2V0Q29vcmRpbmF0ZXMoKVtuLmxlbmd0aF09blswXSx2LmlzQ0NXKHQuZ2V0Q29vcmRpbmF0ZXMoKSk9PT1lJiZYLnJldmVyc2UodC5nZXRDb29yZGluYXRlcygpKX19Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9zaGVsbC5nZXRDb29yZGluYXRlKCl9Z2V0TnVtSW50ZXJpb3JSaW5nKCl7cmV0dXJuIHRoaXMuX2hvbGVzLmxlbmd0aH1nZXRCb3VuZGFyeURpbWVuc2lvbigpe3JldHVybiAxfWdldFR5cGVDb2RlKCl7cmV0dXJuIHEuVFlQRUNPREVfUE9MWUdPTn1nZXREaW1lbnNpb24oKXtyZXR1cm4gMn1nZXRMZW5ndGgoKXtsZXQgdD0wO3QrPXRoaXMuX3NoZWxsLmdldExlbmd0aCgpO2ZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMubGVuZ3RoO2UrKyl0Kz10aGlzLl9ob2xlc1tlXS5nZXRMZW5ndGgoKTtyZXR1cm4gdH1nZXROdW1Qb2ludHMoKXtsZXQgdD10aGlzLl9zaGVsbC5nZXROdW1Qb2ludHMoKTtmb3IobGV0IGU9MDtlPHRoaXMuX2hvbGVzLmxlbmd0aDtlKyspdCs9dGhpcy5faG9sZXNbZV0uZ2V0TnVtUG9pbnRzKCk7cmV0dXJuIHR9cmV2ZXJzZSgpe2NvbnN0IHQ9dGhpcy5jb3B5KCk7dC5fc2hlbGw9dGhpcy5fc2hlbGwuY29weSgpLnJldmVyc2UoKSx0Ll9ob2xlcz1uZXcgQXJyYXkodGhpcy5faG9sZXMubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMubGVuZ3RoO2UrKyl0Ll9ob2xlc1tlXT10aGlzLl9ob2xlc1tlXS5jb3B5KCkucmV2ZXJzZSgpO3JldHVybiB0fWNvbnZleEh1bGwoKXtyZXR1cm4gdGhpcy5nZXRFeHRlcmlvclJpbmcoKS5jb252ZXhIdWxsKCl9Y29tcGFyZVRvU2FtZUNsYXNzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5fc2hlbGwsbj10Ll9zaGVsbDtyZXR1cm4gZS5jb21wYXJlVG9TYW1lQ2xhc3Mobil9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dCxzPXRoaXMuX3NoZWxsLGk9bi5fc2hlbGwscj1zLmNvbXBhcmVUb1NhbWVDbGFzcyhpLGUpO2lmKDAhPT1yKXJldHVybiByO2NvbnN0IG89dGhpcy5nZXROdW1JbnRlcmlvclJpbmcoKSxsPW4uZ2V0TnVtSW50ZXJpb3JSaW5nKCk7bGV0IGE9MDtmb3IoO2E8byYmYTxsOyl7Y29uc3QgdD10aGlzLmdldEludGVyaW9yUmluZ04oYSkscz1uLmdldEludGVyaW9yUmluZ04oYSksaT10LmNvbXBhcmVUb1NhbWVDbGFzcyhzLGUpO2lmKDAhPT1pKXJldHVybiBpO2ErK31yZXR1cm4gYTxvPzE6YTxsPy0xOjB9fWFwcGx5KCl7aWYoXyhhcmd1bWVudHNbMF0sQikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NoZWxsLmFwcGx5KHQpO2ZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMubGVuZ3RoO2UrKyl0aGlzLl9ob2xlc1tlXS5hcHBseSh0KX1lbHNlIGlmKF8oYXJndW1lbnRzWzBdLGR0KSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5fc2hlbGwuYXBwbHkodCksIXQuaXNEb25lKCkpZm9yKGxldCBlPTA7ZTx0aGlzLl9ob2xlcy5sZW5ndGgmJih0aGlzLl9ob2xlc1tlXS5hcHBseSh0KSwhdC5pc0RvbmUoKSk7ZSsrKTt0LmlzR2VvbWV0cnlDaGFuZ2VkKCkmJnRoaXMuZ2VvbWV0cnlDaGFuZ2VkKCl9ZWxzZSBpZihfKGFyZ3VtZW50c1swXSxndCkpe2FyZ3VtZW50c1swXS5maWx0ZXIodGhpcyl9ZWxzZSBpZihfKGFyZ3VtZW50c1swXSxHKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dC5maWx0ZXIodGhpcyksdGhpcy5fc2hlbGwuYXBwbHkodCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9ob2xlcy5sZW5ndGg7ZSsrKXRoaXMuX2hvbGVzW2VdLmFwcGx5KHQpfX1nZXRCb3VuZGFyeSgpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoKTtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9ob2xlcy5sZW5ndGgrMSkuZmlsbChudWxsKTt0WzBdPXRoaXMuX3NoZWxsO2ZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMubGVuZ3RoO2UrKyl0W2UrMV09dGhpcy5faG9sZXNbZV07cmV0dXJuIHQubGVuZ3RoPD0xP3RoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcodFswXS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSk6dGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKHQpfWdldEdlb21ldHJ5VHlwZSgpe3JldHVybiBxLlRZUEVOQU1FX1BPTFlHT059Y29weSgpe2NvbnN0IHQ9dGhpcy5fc2hlbGwuY29weSgpLGU9bmV3IEFycmF5KHRoaXMuX2hvbGVzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IHQ9MDt0PHRoaXMuX2hvbGVzLmxlbmd0aDt0KyspZVt0XT10aGlzLl9ob2xlc1t0XS5jb3B5KCk7cmV0dXJuIG5ldyBidCh0LGUsdGhpcy5fZmFjdG9yeSl9Z2V0RXh0ZXJpb3JSaW5nKCl7cmV0dXJuIHRoaXMuX3NoZWxsfWlzRW1wdHkoKXtyZXR1cm4gdGhpcy5fc2hlbGwuaXNFbXB0eSgpfWdldEludGVyaW9yUmluZ04odCl7cmV0dXJuIHRoaXMuX2hvbGVzW3RdfWdldENsYXNzKCl7cmV0dXJuIGJ0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltPdF19fWJ0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3NoZWxsPW51bGwsdGhpcy5faG9sZXM9bnVsbDtsZXQgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Y29uc3Qgcz1hcmd1bWVudHNbMl07aWYocS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHMpLG51bGw9PT10JiYodD10aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKCkpLG51bGw9PT1lJiYoZT1bXSkscS5oYXNOdWxsRWxlbWVudHMoZSkpdGhyb3cgbmV3IG4oXCJob2xlcyBtdXN0IG5vdCBjb250YWluIG51bGwgZWxlbWVudHNcIik7aWYodC5pc0VtcHR5KCkmJnEuaGFzTm9uRW1wdHlFbGVtZW50cyhlKSl0aHJvdyBuZXcgbihcInNoZWxsIGlzIGVtcHR5IGJ1dCBob2xlcyBhcmUgbm90XCIpO3RoaXMuX3NoZWxsPXQsdGhpcy5faG9sZXM9ZX0sYnQuc2VyaWFsVmVyc2lvblVJRD0tMHgzMDdmZmVmZDhkYzk3MjAwO2NsYXNzIE10IGV4dGVuZHMgX3R7Y29uc3RydWN0b3IoKXtzdXBlcigpLE10LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNWYWxpZCgpe3JldHVybiEwfWVxdWFsc0V4YWN0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuISF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpJiZzdXBlci5lcXVhbHNFeGFjdC5jYWxsKHRoaXMsdCxlKX1yZXR1cm4gc3VwZXIuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENvb3JkaW5hdGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fZ2VvbWV0cmllc1t0XS5nZXRDb29yZGluYXRlKCl9cmV0dXJuIHN1cGVyLmdldENvb3JkaW5hdGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldEJvdW5kYXJ5RGltZW5zaW9uKCl7cmV0dXJuIHV0LkZBTFNFfWdldFR5cGVDb2RlKCl7cmV0dXJuIHEuVFlQRUNPREVfTVVMVElQT0lOVH1nZXREaW1lbnNpb24oKXtyZXR1cm4gMH1nZXRCb3VuZGFyeSgpe3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKX1nZXRHZW9tZXRyeVR5cGUoKXtyZXR1cm4gcS5UWVBFTkFNRV9NVUxUSVBPSU5UfWNvcHkoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuX2dlb21ldHJpZXNbZV0uY29weSgpO3JldHVybiBuZXcgTXQodCx0aGlzLl9mYWN0b3J5KX1nZXRDbGFzcygpe3JldHVybiBNdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bUnRdfX1NdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtfdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSl9LE10LnNlcmlhbFZlcnNpb25VSUQ9LTB4NmZiMWVkNDE2MmUwZmMwMDtjbGFzcyBEdCBleHRlbmRzIFR0e2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxEdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldEJvdW5kYXJ5RGltZW5zaW9uKCl7cmV0dXJuIHV0LkZBTFNFfWlzQ2xvc2VkKCl7cmV0dXJuISF0aGlzLmlzRW1wdHkoKXx8c3VwZXIuaXNDbG9zZWQuY2FsbCh0aGlzKX1nZXRUeXBlQ29kZSgpe3JldHVybiBxLlRZUEVDT0RFX0xJTkVBUlJJTkd9cmV2ZXJzZSgpe2NvbnN0IHQ9dGhpcy5fcG9pbnRzLmNvcHkoKTtyZXR1cm4gTHQucmV2ZXJzZSh0KSx0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKHQpfXZhbGlkYXRlQ29uc3RydWN0aW9uKCl7aWYoIXRoaXMuaXNFbXB0eSgpJiYhc3VwZXIuaXNDbG9zZWQuY2FsbCh0aGlzKSl0aHJvdyBuZXcgbihcIlBvaW50cyBvZiBMaW5lYXJSaW5nIGRvIG5vdCBmb3JtIGEgY2xvc2VkIGxpbmVzdHJpbmdcIik7aWYodGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2UoKS5zaXplKCk+PTEmJnRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkuc2l6ZSgpPER0Lk1JTklNVU1fVkFMSURfU0laRSl0aHJvdyBuZXcgbihcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBMaW5lYXJSaW5nIChmb3VuZCBcIit0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLnNpemUoKStcIiAtIG11c3QgYmUgMCBvciA+PSA0KVwiKX1nZXRHZW9tZXRyeVR5cGUoKXtyZXR1cm4gcS5UWVBFTkFNRV9MSU5FQVJSSU5HfWNvcHkoKXtyZXR1cm4gbmV3IER0KHRoaXMuX3BvaW50cy5jb3B5KCksdGhpcy5fZmFjdG9yeSl9Z2V0Q2xhc3MoKXtyZXR1cm4gRHR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUR0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgSHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO0R0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsZS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHQpLGUpfWVsc2UgaWYoXyhhcmd1bWVudHNbMF0sQSkmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgSHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO1R0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKSx0aGlzLnZhbGlkYXRlQ29uc3RydWN0aW9uKCl9fSxEdC5NSU5JTVVNX1ZBTElEX1NJWkU9NCxEdC5zZXJpYWxWZXJzaW9uVUlEPS0weDNiMjI5ZTI2MjM2N2E2MDA7Y2xhc3MgQXQgZXh0ZW5kcyBfdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksQXQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1lcXVhbHNFeGFjdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiEhdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSYmc3VwZXIuZXF1YWxzRXhhY3QuY2FsbCh0aGlzLHQsZSl9cmV0dXJuIHN1cGVyLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRCb3VuZGFyeURpbWVuc2lvbigpe3JldHVybiAxfWdldFR5cGVDb2RlKCl7cmV0dXJuIHEuVFlQRUNPREVfTVVMVElQT0xZR09OfWdldERpbWVuc2lvbigpe3JldHVybiAyfXJldmVyc2UoKXtjb25zdCB0PXRoaXMuX2dlb21ldHJpZXMubGVuZ3RoLGU9bmV3IEFycmF5KHQpLmZpbGwobnVsbCk7Zm9yKGxldCB0PTA7dDx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDt0KyspZVt0XT10aGlzLl9nZW9tZXRyaWVzW3RdLnJldmVyc2UoKTtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlQb2x5Z29uKGUpfWdldEJvdW5kYXJ5KCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZygpO2NvbnN0IHQ9bmV3IHg7Zm9yKGxldCBlPTA7ZTx0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtlKyspe2NvbnN0IG49dGhpcy5fZ2VvbWV0cmllc1tlXS5nZXRCb3VuZGFyeSgpO2ZvcihsZXQgZT0wO2U8bi5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXQuYWRkKG4uZ2V0R2VvbWV0cnlOKGUpKX1jb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKHQudG9BcnJheShlKSl9Z2V0R2VvbWV0cnlUeXBlKCl7cmV0dXJuIHEuVFlQRU5BTUVfTVVMVElQT0xZR09OfWNvcHkoKXtjb25zdCB0PW5ldyBBcnJheSh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuX2dlb21ldHJpZXNbZV0uY29weSgpO3JldHVybiBuZXcgQXQodCx0aGlzLl9mYWN0b3J5KX1nZXRDbGFzcygpe3JldHVybiBBdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bT3RdfX1BdC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtfdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSl9LEF0LnNlcmlhbFZlcnNpb25VSUQ9LTB4N2E1YWExMzY5MTcxOTgwO2NsYXNzIEZ0e2NvbnN0cnVjdG9yKCl7RnQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zZXRDb3B5VXNlckRhdGEodCl7dGhpcy5faXNVc2VyRGF0YUNvcGllZD10fWVkaXQodCxlKXtpZihudWxsPT09dClyZXR1cm4gbnVsbDtjb25zdCBuPXRoaXMuZWRpdEludGVybmFsKHQsZSk7cmV0dXJuIHRoaXMuX2lzVXNlckRhdGFDb3BpZWQmJm4uc2V0VXNlckRhdGEodC5nZXRVc2VyRGF0YSgpKSxufWVkaXRJbnRlcm5hbCh0LGUpe3JldHVybiBudWxsPT09dGhpcy5fZmFjdG9yeSYmKHRoaXMuX2ZhY3Rvcnk9dC5nZXRGYWN0b3J5KCkpLHQgaW5zdGFuY2VvZiBfdD90aGlzLmVkaXRHZW9tZXRyeUNvbGxlY3Rpb24odCxlKTp0IGluc3RhbmNlb2YgYnQ/dGhpcy5lZGl0UG9seWdvbih0LGUpOnQgaW5zdGFuY2VvZiBQdHx8dCBpbnN0YW5jZW9mIFR0P2UuZWRpdCh0LHRoaXMuX2ZhY3RvcnkpOih1LnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiVW5zdXBwb3J0ZWQgR2VvbWV0cnkgY2xhc3M6IFwiK3QuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpLG51bGwpfWVkaXRHZW9tZXRyeUNvbGxlY3Rpb24odCxlKXtjb25zdCBuPWUuZWRpdCh0LHRoaXMuX2ZhY3RvcnkpLHM9bmV3IHg7Zm9yKGxldCB0PTA7dDxuLmdldE51bUdlb21ldHJpZXMoKTt0Kyspe2NvbnN0IGk9dGhpcy5lZGl0KG4uZ2V0R2VvbWV0cnlOKHQpLGUpO251bGw9PT1pfHxpLmlzRW1wdHkoKXx8cy5hZGQoaSl9cmV0dXJuIG4uZ2V0Q2xhc3MoKT09PU10P3RoaXMuX2ZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChzLnRvQXJyYXkoW10pKTpuLmdldENsYXNzKCk9PT1mdD90aGlzLl9mYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZyhzLnRvQXJyYXkoW10pKTpuLmdldENsYXNzKCk9PT1BdD90aGlzLl9mYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbihzLnRvQXJyYXkoW10pKTp0aGlzLl9mYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihzLnRvQXJyYXkoW10pKX1lZGl0UG9seWdvbih0LGUpe2xldCBuPWUuZWRpdCh0LHRoaXMuX2ZhY3RvcnkpO2lmKG51bGw9PT1uJiYobj10aGlzLl9mYWN0b3J5LmNyZWF0ZVBvbHlnb24oKSksbi5pc0VtcHR5KCkpcmV0dXJuIG47Y29uc3Qgcz10aGlzLmVkaXQobi5nZXRFeHRlcmlvclJpbmcoKSxlKTtpZihudWxsPT09c3x8cy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9seWdvbigpO2NvbnN0IGk9bmV3IHg7Zm9yKGxldCB0PTA7dDxuLmdldE51bUludGVyaW9yUmluZygpO3QrKyl7Y29uc3Qgcz10aGlzLmVkaXQobi5nZXRJbnRlcmlvclJpbmdOKHQpLGUpO251bGw9PT1zfHxzLmlzRW1wdHkoKXx8aS5hZGQocyl9cmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9seWdvbihzLGkudG9BcnJheShbXSkpfWdldENsYXNzKCl7cmV0dXJuIEZ0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1mdW5jdGlvbiBHdCgpe31GdC5HZW9tZXRyeUVkaXRvck9wZXJhdGlvbj1HdDtjbGFzcyBxdHtjb25zdHJ1Y3Rvcigpe3F0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZWRpdCh0LGUpe3JldHVybiB0fWdldENsYXNzKCl7cmV0dXJuIHF0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltHdF19fXF0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgQnR7Y29uc3RydWN0b3IoKXtCdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWVkaXQodCxlKXtjb25zdCBuPXRoaXMuZWRpdCh0LmdldENvb3JkaW5hdGVzKCksdCk7cmV0dXJuIHQgaW5zdGFuY2VvZiBEdD9udWxsPT09bj9lLmNyZWF0ZUxpbmVhclJpbmcoKTplLmNyZWF0ZUxpbmVhclJpbmcobik6dCBpbnN0YW5jZW9mIFR0P251bGw9PT1uP2UuY3JlYXRlTGluZVN0cmluZygpOmUuY3JlYXRlTGluZVN0cmluZyhuKTp0IGluc3RhbmNlb2YgUHQ/bnVsbD09PW58fDA9PT1uLmxlbmd0aD9lLmNyZWF0ZVBvaW50KCk6ZS5jcmVhdGVQb2ludChuWzBdKTp0fWdldENsYXNzKCl7cmV0dXJuIEJ0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltHdF19fUJ0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgVnR7Y29uc3RydWN0b3IoKXtWdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWVkaXQodCxlKXtyZXR1cm4gdCBpbnN0YW5jZW9mIER0P2UuY3JlYXRlTGluZWFyUmluZyh0aGlzLmVkaXQodC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSk6dCBpbnN0YW5jZW9mIFR0P2UuY3JlYXRlTGluZVN0cmluZyh0aGlzLmVkaXQodC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSk6dCBpbnN0YW5jZW9mIFB0P2UuY3JlYXRlUG9pbnQodGhpcy5lZGl0KHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCkpOnR9Z2V0Q2xhc3MoKXtyZXR1cm4gVnR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0d0XX19VnQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxGdC5Ob09wR2VvbWV0cnlPcGVyYXRpb249cXQsRnQuQ29vcmRpbmF0ZU9wZXJhdGlvbj1CdCxGdC5Db29yZGluYXRlU2VxdWVuY2VPcGVyYXRpb249VnQsRnQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fZmFjdG9yeT1udWxsLHRoaXMuX2lzVXNlckRhdGFDb3BpZWQ9ITEsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2ZhY3Rvcnk9dH19O2NsYXNzIHp0e2NvbnN0cnVjdG9yKCl7enQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zZXRPcmRpbmF0ZSh0LGUscyl7c3dpdGNoKGUpe2Nhc2UgQS5YOnRoaXMuX2Nvb3JkaW5hdGVzW3RdLng9czticmVhaztjYXNlIEEuWTp0aGlzLl9jb29yZGluYXRlc1t0XS55PXM7YnJlYWs7Y2FzZSBBLlo6dGhpcy5fY29vcmRpbmF0ZXNbdF0uej1zO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IG4oXCJpbnZhbGlkIG9yZGluYXRlSW5kZXhcIil9fXNpemUoKXtyZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RofWdldE9yZGluYXRlKHQsZSl7c3dpdGNoKGUpe2Nhc2UgQS5YOnJldHVybiB0aGlzLl9jb29yZGluYXRlc1t0XS54O2Nhc2UgQS5ZOnJldHVybiB0aGlzLl9jb29yZGluYXRlc1t0XS55O2Nhc2UgQS5aOnJldHVybiB0aGlzLl9jb29yZGluYXRlc1t0XS56fXJldHVybiBpLk5hTn1nZXRDb29yZGluYXRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9jb29yZGluYXRlc1t0XX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07ZS54PXRoaXMuX2Nvb3JkaW5hdGVzW3RdLngsZS55PXRoaXMuX2Nvb3JkaW5hdGVzW3RdLnksZS56PXRoaXMuX2Nvb3JkaW5hdGVzW3RdLnp9fWdldENvb3JkaW5hdGVDb3B5KHQpe3JldHVybiBuZXcgZyh0aGlzLl9jb29yZGluYXRlc1t0XSl9Z2V0RGltZW5zaW9uKCl7cmV0dXJuIHRoaXMuX2RpbWVuc2lvbn1nZXRYKHQpe3JldHVybiB0aGlzLl9jb29yZGluYXRlc1t0XS54fWV4cGFuZEVudmVsb3BlKHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoO2UrKyl0LmV4cGFuZFRvSW5jbHVkZSh0aGlzLl9jb29yZGluYXRlc1tlXSk7cmV0dXJuIHR9Y29weSgpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoO2UrKyl0W2VdPXRoaXMuX2Nvb3JkaW5hdGVzW2VdLmNvcHkoKTtyZXR1cm4gbmV3IHp0KHQsdGhpcy5fZGltZW5zaW9uKX10b1N0cmluZygpe2lmKHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aD4wKXtjb25zdCB0PW5ldyB3dCgxNyp0aGlzLl9jb29yZGluYXRlcy5sZW5ndGgpO3QuYXBwZW5kKFwiKFwiKSx0LmFwcGVuZCh0aGlzLl9jb29yZGluYXRlc1swXSk7Zm9yKGxldCBlPTE7ZTx0aGlzLl9jb29yZGluYXRlcy5sZW5ndGg7ZSsrKXQuYXBwZW5kKFwiLCBcIiksdC5hcHBlbmQodGhpcy5fY29vcmRpbmF0ZXNbZV0pO3JldHVybiB0LmFwcGVuZChcIilcIiksdC50b1N0cmluZygpfXJldHVyblwiKClcIn1nZXRZKHQpe3JldHVybiB0aGlzLl9jb29yZGluYXRlc1t0XS55fXRvQ29vcmRpbmF0ZUFycmF5KCl7cmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzfWdldENsYXNzKCl7cmV0dXJuIHp0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltBLGFdfX16dC5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9kaW1lbnNpb249Myx0aGlzLl9jb29yZGluYXRlcz1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTt6dC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsMyl9ZWxzZSBpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2Nvb3JkaW5hdGVzPW5ldyBBcnJheSh0KS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dDtlKyspdGhpcy5fY29vcmRpbmF0ZXNbZV09bmV3IGd9ZWxzZSBpZihfKGFyZ3VtZW50c1swXSxBKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYobnVsbD09PXQpcmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzPW5ldyBBcnJheSgwKS5maWxsKG51bGwpLG51bGw7dGhpcy5fZGltZW5zaW9uPXQuZ2V0RGltZW5zaW9uKCksdGhpcy5fY29vcmRpbmF0ZXM9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoO2UrKyl0aGlzLl9jb29yZGluYXRlc1tlXT10LmdldENvb3JkaW5hdGVDb3B5KGUpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fY29vcmRpbmF0ZXM9dCx0aGlzLl9kaW1lbnNpb249ZSxudWxsPT09dCYmKHRoaXMuX2Nvb3JkaW5hdGVzPW5ldyBBcnJheSgwKS5maWxsKG51bGwpKX1lbHNlIGlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9jb29yZGluYXRlcz1uZXcgQXJyYXkodCkuZmlsbChudWxsKSx0aGlzLl9kaW1lbnNpb249ZTtmb3IobGV0IGU9MDtlPHQ7ZSsrKXRoaXMuX2Nvb3JkaW5hdGVzW2VdPW5ldyBnfX0senQuc2VyaWFsVmVyc2lvblVJRD0tMHhjYjQ0YTc3OGRiMThlMDA7Y2xhc3MgWXR7Y29uc3RydWN0b3IoKXtZdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpbnN0YW5jZSgpe3JldHVybiBZdC5pbnN0YW5jZU9iamVjdH1yZWFkUmVzb2x2ZSgpe3JldHVybiBZdC5pbnN0YW5jZSgpfWNyZWF0ZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IHp0KHQpfWlmKF8oYXJndW1lbnRzWzBdLEEpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IHp0KHQpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT1hcmd1bWVudHNbMV07cmV0dXJuIGU+MyYmKGU9MyksZTwyP25ldyB6dCh0KTpuZXcgenQodCxlKX19Z2V0Q2xhc3MoKXtyZXR1cm4gWXR9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0YsYV19fWZ1bmN0aW9uIFV0KCl7dGhpcy5tYXBfPW5ldyBNYXB9WXQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxZdC5zZXJpYWxWZXJzaW9uVUlEPS0weDM4ZTQ5ZmE2Y2Y2ZjJlMDAsWXQuaW5zdGFuY2VPYmplY3Q9bmV3IFl0LFV0LnByb3RvdHlwZT1uZXcgaixVdC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm1hcF8uZ2V0KHQpfHxudWxsfSxVdC5wcm90b3R5cGUucHV0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMubWFwXy5zZXQodCxlKSxlfSxVdC5wcm90b3R5cGUudmFsdWVzPWZ1bmN0aW9uKCl7Y29uc3QgdD1uZXcgeCxlPXRoaXMubWFwXy52YWx1ZXMoKTtsZXQgbj1lLm5leHQoKTtmb3IoOyFuLmRvbmU7KXQuYWRkKG4udmFsdWUpLG49ZS5uZXh0KCk7cmV0dXJuIHR9LFV0LnByb3RvdHlwZS5lbnRyeVNldD1mdW5jdGlvbigpe2NvbnN0IHQ9bmV3IEo7cmV0dXJuIHRoaXMubWFwXy5lbnRyaWVzKCkuZm9yRWFjaChlPT50LmFkZChlKSksdH0sVXQucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXBfLnNpemUoKX07Y2xhc3Mga3R7Y29uc3RydWN0b3IoKXtrdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBtb3N0UHJlY2lzZSh0LGUpe3JldHVybiB0LmNvbXBhcmVUbyhlKT49MD90OmV9ZXF1YWxzKHQpe2lmKCEodCBpbnN0YW5jZW9mIGt0KSlyZXR1cm4hMTtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuX21vZGVsVHlwZT09PWUuX21vZGVsVHlwZSYmdGhpcy5fc2NhbGU9PT1lLl9zY2FsZX1jb21wYXJlVG8odCl7Y29uc3QgZT10LG49dGhpcy5nZXRNYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMoKSxzPWUuZ2V0TWF4aW11bVNpZ25pZmljYW50RGlnaXRzKCk7cmV0dXJuIG5ldyBMKG4pLmNvbXBhcmVUbyhuZXcgTChzKSl9Z2V0U2NhbGUoKXtyZXR1cm4gdGhpcy5fc2NhbGV9aXNGbG9hdGluZygpe3JldHVybiB0aGlzLl9tb2RlbFR5cGU9PT1rdC5GTE9BVElOR3x8dGhpcy5fbW9kZWxUeXBlPT09a3QuRkxPQVRJTkdfU0lOR0xFfWdldFR5cGUoKXtyZXR1cm4gdGhpcy5fbW9kZWxUeXBlfXRvU3RyaW5nKCl7bGV0IHQ9XCJVTktOT1dOXCI7cmV0dXJuIHRoaXMuX21vZGVsVHlwZT09PWt0LkZMT0FUSU5HP3Q9XCJGbG9hdGluZ1wiOnRoaXMuX21vZGVsVHlwZT09PWt0LkZMT0FUSU5HX1NJTkdMRT90PVwiRmxvYXRpbmctU2luZ2xlXCI6dGhpcy5fbW9kZWxUeXBlPT09a3QuRklYRUQmJih0PVwiRml4ZWQgKFNjYWxlPVwiK3RoaXMuZ2V0U2NhbGUoKStcIilcIiksdH1tYWtlUHJlY2lzZSgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKGkuaXNOYU4odCkpcmV0dXJuIHQ7aWYodGhpcy5fbW9kZWxUeXBlPT09a3QuRkxPQVRJTkdfU0lOR0xFKXtyZXR1cm4gdH1yZXR1cm4gdGhpcy5fbW9kZWxUeXBlPT09a3QuRklYRUQ/TWF0aC5yb3VuZCh0KnRoaXMuX3NjYWxlKS90aGlzLl9zY2FsZTp0fWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5fbW9kZWxUeXBlPT09a3QuRkxPQVRJTkcpcmV0dXJuIG51bGw7dC54PXRoaXMubWFrZVByZWNpc2UodC54KSx0Lnk9dGhpcy5tYWtlUHJlY2lzZSh0LnkpfX1nZXRNYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMoKXtsZXQgdD0xNjtyZXR1cm4gdGhpcy5fbW9kZWxUeXBlPT09a3QuRkxPQVRJTkc/dD0xNjp0aGlzLl9tb2RlbFR5cGU9PT1rdC5GTE9BVElOR19TSU5HTEU/dD02OnRoaXMuX21vZGVsVHlwZT09PWt0LkZJWEVEJiYodD0xK01hdGgudHJ1bmMoTWF0aC5jZWlsKE1hdGgubG9nKHRoaXMuZ2V0U2NhbGUoKSkvTWF0aC5sb2coMTApKSkpLHR9c2V0U2NhbGUodCl7dGhpcy5fc2NhbGU9TWF0aC5hYnModCl9Z2V0Q2xhc3MoKXtyZXR1cm4ga3R9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2Escl19fWNsYXNzIFh0e2NvbnN0cnVjdG9yKCl7WHQuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZWFkUmVzb2x2ZSgpe3JldHVybiBYdC5uYW1lVG9UeXBlTWFwLmdldCh0aGlzLl9uYW1lKX10b1N0cmluZygpe3JldHVybiB0aGlzLl9uYW1lfWdldENsYXNzKCl7cmV0dXJuIFh0fWdldCBpbnRlcmZhY2VzXygpe3JldHVyblthXX19WHQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbmFtZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX25hbWU9dCxYdC5uYW1lVG9UeXBlTWFwLnB1dCh0LHRoaXMpfSxYdC5zZXJpYWxWZXJzaW9uVUlEPS01NTI4NjAyNjMxNzMxNTllNCxYdC5uYW1lVG9UeXBlTWFwPW5ldyBVdCxrdC5UeXBlPVh0LGt0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX21vZGVsVHlwZT1udWxsLHRoaXMuX3NjYWxlPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5fbW9kZWxUeXBlPWt0LkZMT0FUSU5HO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBYdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbW9kZWxUeXBlPXQsdD09PWt0LkZJWEVEJiZ0aGlzLnNldFNjYWxlKDEpfWVsc2UgaWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbW9kZWxUeXBlPWt0LkZJWEVELHRoaXMuc2V0U2NhbGUodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGt0KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9tb2RlbFR5cGU9dC5fbW9kZWxUeXBlLHRoaXMuX3NjYWxlPXQuX3NjYWxlfX0sa3Quc2VyaWFsVmVyc2lvblVJRD0weDZiZWU2NDA0ZTlhMjVjMDAsa3QuRklYRUQ9bmV3IFh0KFwiRklYRURcIiksa3QuRkxPQVRJTkc9bmV3IFh0KFwiRkxPQVRJTkdcIiksa3QuRkxPQVRJTkdfU0lOR0xFPW5ldyBYdChcIkZMT0FUSU5HIFNJTkdMRVwiKSxrdC5tYXhpbXVtUHJlY2lzZVZhbHVlPTkwMDcxOTkyNTQ3NDA5OTI7Y2xhc3MgSHR7Y29uc3RydWN0b3IoKXtIdC5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyB0b011bHRpUG9seWdvbkFycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9c3RhdGljIHRvR2VvbWV0cnlBcnJheSh0KXtpZihudWxsPT09dClyZXR1cm4gbnVsbDtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfXN0YXRpYyBnZXREZWZhdWx0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpe3JldHVybiBZdC5pbnN0YW5jZSgpfXN0YXRpYyB0b011bHRpTGluZVN0cmluZ0FycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9c3RhdGljIHRvTGluZVN0cmluZ0FycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9c3RhdGljIHRvTXVsdGlQb2ludEFycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9c3RhdGljIHRvTGluZWFyUmluZ0FycmF5KHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9c3RhdGljIHRvUG9pbnRBcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfXN0YXRpYyB0b1BvbHlnb25BcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfXN0YXRpYyBjcmVhdGVQb2ludEZyb21JbnRlcm5hbENvb3JkKHQsZSl7cmV0dXJuIGUuZ2V0UHJlY2lzaW9uTW9kZWwoKS5tYWtlUHJlY2lzZSh0KSxlLmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0KX10b0dlb21ldHJ5KHQpe3JldHVybiB0LmlzTnVsbCgpP3RoaXMuY3JlYXRlUG9pbnQoKTp0LmdldE1pblgoKT09PXQuZ2V0TWF4WCgpJiZ0LmdldE1pblkoKT09PXQuZ2V0TWF4WSgpP3RoaXMuY3JlYXRlUG9pbnQobmV3IGcodC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpKTp0LmdldE1pblgoKT09PXQuZ2V0TWF4WCgpfHx0LmdldE1pblkoKT09PXQuZ2V0TWF4WSgpP3RoaXMuY3JlYXRlTGluZVN0cmluZyhbbmV3IGcodC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpLG5ldyBnKHQuZ2V0TWF4WCgpLHQuZ2V0TWF4WSgpKV0pOnRoaXMuY3JlYXRlUG9seWdvbih0aGlzLmNyZWF0ZUxpbmVhclJpbmcoW25ldyBnKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKSxuZXcgZyh0LmdldE1pblgoKSx0LmdldE1heFkoKSksbmV3IGcodC5nZXRNYXhYKCksdC5nZXRNYXhZKCkpLG5ldyBnKHQuZ2V0TWF4WCgpLHQuZ2V0TWluWSgpKSxuZXcgZyh0LmdldE1pblgoKSx0LmdldE1pblkoKSldKSxudWxsKX1jcmVhdGVMaW5lU3RyaW5nKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuY3JlYXRlTGluZVN0cmluZyh0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlTGluZVN0cmluZyhudWxsIT09dD90aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUodCk6bnVsbCl9aWYoXyhhcmd1bWVudHNbMF0sQSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgVHQodCx0aGlzKX19fWNyZWF0ZU11bHRpTGluZVN0cmluZygpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBuZXcgZnQobnVsbCx0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBmdCh0LHRoaXMpfX1idWlsZEdlb21ldHJ5KHQpe2xldCBlPW51bGwsbj0hMSxzPSExO2ZvcihsZXQgaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXtjb25zdCB0PWkubmV4dCgpLHI9dC5nZXRDbGFzcygpO251bGw9PT1lJiYoZT1yKSxyIT09ZSYmKG49ITApLHQgaW5zdGFuY2VvZiBfdCYmKHM9ITApfWlmKG51bGw9PT1lKXJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpO2lmKG58fHMpcmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKEh0LnRvR2VvbWV0cnlBcnJheSh0KSk7Y29uc3QgaT10Lml0ZXJhdG9yKCkubmV4dCgpO2lmKHQuc2l6ZSgpPjEpe2lmKGkgaW5zdGFuY2VvZiBidClyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvbHlnb24oSHQudG9Qb2x5Z29uQXJyYXkodCkpO2lmKGkgaW5zdGFuY2VvZiBUdClyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoSHQudG9MaW5lU3RyaW5nQXJyYXkodCkpO2lmKGkgaW5zdGFuY2VvZiBQdClyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KEh0LnRvUG9pbnRBcnJheSh0KSk7dS5zaG91bGROZXZlclJlYWNoSGVyZShcIlVuaGFuZGxlZCBjbGFzczogXCIraS5nZXRDbGFzcygpLmdldE5hbWUoKSl9cmV0dXJuIGl9Y3JlYXRlTXVsdGlQb2ludEZyb21Db29yZHModCl7cmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChudWxsIT09dD90aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUodCk6bnVsbCl9Y3JlYXRlUG9pbnQoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5jcmVhdGVQb2ludCh0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVQb2ludChudWxsIT09dD90aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW3RdKTpudWxsKX1pZihfKGFyZ3VtZW50c1swXSxBKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBQdCh0LHRoaXMpfX19Z2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpe3JldHVybiB0aGlzLl9jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5fWNyZWF0ZVBvbHlnb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKG51bGwsbnVsbCk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKF8oYXJndW1lbnRzWzBdLEEpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKHRoaXMuY3JlYXRlTGluZWFyUmluZyh0KSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlUG9seWdvbih0aGlzLmNyZWF0ZUxpbmVhclJpbmcodCkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZVBvbHlnb24odCxudWxsKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIG5ldyBidCh0LGUsdGhpcyl9fWdldFNSSUQoKXtyZXR1cm4gdGhpcy5fU1JJRH1jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbmV3IF90KG51bGwsdGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgX3QodCx0aGlzKX19Y3JlYXRlR2VvbWV0cnkodCl7cmV0dXJuIG5ldyBGdCh0aGlzKS5lZGl0KHQsbmV3IFd0KHRoaXMuX2Nvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkpKX1nZXRQcmVjaXNpb25Nb2RlbCgpe3JldHVybiB0aGlzLl9wcmVjaXNpb25Nb2RlbH1jcmVhdGVMaW5lYXJSaW5nKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuY3JlYXRlTGluZWFyUmluZyh0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlTGluZWFyUmluZyhudWxsIT09dD90aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUodCk6bnVsbCl9aWYoXyhhcmd1bWVudHNbMF0sQSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgRHQodCx0aGlzKX19fWNyZWF0ZU11bHRpUG9seWdvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBuZXcgQXQobnVsbCx0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBBdCh0LHRoaXMpfX1jcmVhdGVNdWx0aVBvaW50KCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG5ldyBNdChudWxsLHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IE10KHQsdGhpcyl9aWYoXyhhcmd1bWVudHNbMF0sQSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKG51bGw9PT10KXJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQobmV3IEFycmF5KDApLmZpbGwobnVsbCkpO2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgbj0wO248dC5zaXplKCk7bisrKXtjb25zdCBzPXRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSgxLHQuZ2V0RGltZW5zaW9uKCkpO0x0LmNvcHkodCxuLHMsMCwxKSxlW25dPXRoaXMuY3JlYXRlUG9pbnQocyl9cmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChlKX19fWdldENsYXNzKCl7cmV0dXJuIEh0fWdldCBpbnRlcmZhY2VzXygpe3JldHVyblthXX19Y2xhc3MgV3QgZXh0ZW5kcyBGdC5Db29yZGluYXRlU2VxdWVuY2VPcGVyYXRpb257Y29uc3RydWN0b3IoKXtzdXBlcigpLFd0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZWRpdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIHEmJl8oYXJndW1lbnRzWzBdLEEpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5LmNyZWF0ZSh0KX1yZXR1cm4gc3VwZXIuZWRpdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q2xhc3MoKXtyZXR1cm4gV3R9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVd0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeT10fSxIdC5DbG9uZU9wPVd0LEh0LmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX3ByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5fY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeT1udWxsLHRoaXMuX1NSSUQ9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aClIdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG5ldyBrdCwwKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihfKGFyZ3VtZW50c1swXSxGKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07SHQuY29uc3RydWN0b3JfLmNhbGwodGhpcyxuZXcga3QsMCx0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2Yga3Qpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO0h0LmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCwwLEh0LmdldERlZmF1bHRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtIdC5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxIdC5nZXREZWZhdWx0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9wcmVjaXNpb25Nb2RlbD10LHRoaXMuX2Nvb3JkaW5hdGVTZXF1ZW5jZUZhY3Rvcnk9bix0aGlzLl9TUklEPWV9fSxIdC5zZXJpYWxWZXJzaW9uVUlEPS0weDVlYTc1ZjIwNTFlZWI0MDA7Y29uc3QganQ9e3R5cGVTdHI6L15cXHMqKFxcdyspXFxzKlxcKFxccyooLiopXFxzKlxcKVxccyokLyxlbXB0eVR5cGVTdHI6L15cXHMqKFxcdyspXFxzKkVNUFRZXFxzKiQvLHNwYWNlczovXFxzKy8scGFyZW5Db21tYTovXFwpXFxzKixcXHMqXFwoLyxkb3VibGVQYXJlbkNvbW1hOi9cXClcXHMqXFwpXFxzKixcXHMqXFwoXFxzKlxcKC8sdHJpbVBhcmVuczovXlxccypcXCg/KC4qPylcXCk/XFxzKiQvfTtjbGFzcyBLdHtjb25zdHJ1Y3Rvcih0KXt0aGlzLmdlb21ldHJ5RmFjdG9yeT10fHxuZXcgSHQsdGhpcy5wcmVjaXNpb25Nb2RlbD10aGlzLmdlb21ldHJ5RmFjdG9yeS5nZXRQcmVjaXNpb25Nb2RlbCgpfXJlYWQodCl7dmFyIGUsbixzO3Q9dC5yZXBsYWNlKC9bXFxuXFxyXS9nLFwiIFwiKTt2YXIgaT1qdC50eXBlU3RyLmV4ZWModCk7aWYoLTEhPT10LnNlYXJjaChcIkVNUFRZXCIpJiYoKGk9anQuZW1wdHlUeXBlU3RyLmV4ZWModCkpWzJdPXZvaWQgMCksaSYmKG49aVsxXS50b0xvd2VyQ2FzZSgpLHM9aVsyXSxRdFtuXSYmKGU9UXRbbl0uY2FsbCh0aGlzLHMpKSksdm9pZCAwPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcGFyc2UgV0tUIFwiK3QpO3JldHVybiBlfXdyaXRlKHQpe3JldHVybiB0aGlzLmV4dHJhY3RHZW9tZXRyeSh0KX1leHRyYWN0R2VvbWV0cnkodCl7dmFyIGU9dC5nZXRHZW9tZXRyeVR5cGUoKS50b0xvd2VyQ2FzZSgpO2lmKCFadFtlXSlyZXR1cm4gbnVsbDt2YXIgbj1lLnRvVXBwZXJDYXNlKCk7cmV0dXJuIHQuaXNFbXB0eSgpP24rXCIgRU1QVFlcIjpuK1wiKFwiK1p0W2VdLmNhbGwodGhpcyx0KStcIilcIn19Y29uc3QgWnQ9e2Nvb3JkaW5hdGUodCl7cmV0dXJuIHRoaXMucHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2UodCksdC54K1wiIFwiK3QueX0scG9pbnQodCl7cmV0dXJuIFp0LmNvb3JkaW5hdGUuY2FsbCh0aGlzLHQuX2Nvb3JkaW5hdGVzLl9jb29yZGluYXRlc1swXSl9LG11bHRpcG9pbnQodCl7dmFyIGU9W107Zm9yKGxldCBuPTAscz10Ll9nZW9tZXRyaWVzLmxlbmd0aDtuPHM7KytuKWUucHVzaChcIihcIitadC5wb2ludC5jYWxsKHRoaXMsdC5fZ2VvbWV0cmllc1tuXSkrXCIpXCIpO3JldHVybiBlLmpvaW4oXCIsXCIpfSxsaW5lc3RyaW5nKHQpe3ZhciBlPVtdO2ZvcihsZXQgbj0wLHM9dC5fcG9pbnRzLl9jb29yZGluYXRlcy5sZW5ndGg7bjxzOysrbillLnB1c2goWnQuY29vcmRpbmF0ZS5jYWxsKHRoaXMsdC5fcG9pbnRzLl9jb29yZGluYXRlc1tuXSkpO3JldHVybiBlLmpvaW4oXCIsXCIpfSxsaW5lYXJyaW5nKHQpe3ZhciBlPVtdO2ZvcihsZXQgbj0wLHM9dC5fcG9pbnRzLl9jb29yZGluYXRlcy5sZW5ndGg7bjxzOysrbillLnB1c2goWnQuY29vcmRpbmF0ZS5jYWxsKHRoaXMsdC5fcG9pbnRzLl9jb29yZGluYXRlc1tuXSkpO3JldHVybiBlLmpvaW4oXCIsXCIpfSxtdWx0aWxpbmVzdHJpbmcodCl7dmFyIGU9W107Zm9yKGxldCBuPTAscz10Ll9nZW9tZXRyaWVzLmxlbmd0aDtuPHM7KytuKWUucHVzaChcIihcIitadC5saW5lc3RyaW5nLmNhbGwodGhpcyx0Ll9nZW9tZXRyaWVzW25dKStcIilcIik7cmV0dXJuIGUuam9pbihcIixcIil9LHBvbHlnb24odCl7dmFyIGU9W107ZS5wdXNoKFwiKFwiK1p0LmxpbmVzdHJpbmcuY2FsbCh0aGlzLHQuX3NoZWxsKStcIilcIik7Zm9yKGxldCBuPTAscz10Ll9ob2xlcy5sZW5ndGg7bjxzOysrbillLnB1c2goXCIoXCIrWnQubGluZXN0cmluZy5jYWxsKHRoaXMsdC5faG9sZXNbbl0pK1wiKVwiKTtyZXR1cm4gZS5qb2luKFwiLFwiKX0sbXVsdGlwb2x5Z29uKHQpe3ZhciBlPVtdO2ZvcihsZXQgbj0wLHM9dC5fZ2VvbWV0cmllcy5sZW5ndGg7bjxzOysrbillLnB1c2goXCIoXCIrWnQucG9seWdvbi5jYWxsKHRoaXMsdC5fZ2VvbWV0cmllc1tuXSkrXCIpXCIpO3JldHVybiBlLmpvaW4oXCIsXCIpfSxnZW9tZXRyeWNvbGxlY3Rpb24odCl7dmFyIGU9W107Zm9yKGxldCBuPTAscz10Ll9nZW9tZXRyaWVzLmxlbmd0aDtuPHM7KytuKWUucHVzaCh0aGlzLmV4dHJhY3RHZW9tZXRyeSh0Ll9nZW9tZXRyaWVzW25dKSk7cmV0dXJuIGUuam9pbihcIixcIil9fSxRdD17Y29vcmQodCl7dmFyIGU9dC50cmltKCkuc3BsaXQoanQuc3BhY2VzKSxuPW5ldyBnKE51bWJlci5wYXJzZUZsb2F0KGVbMF0pLE51bWJlci5wYXJzZUZsb2F0KGVbMV0pKTtyZXR1cm4gdGhpcy5wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZShuKSxufSxwb2ludCh0KXtyZXR1cm4gdm9pZCAwPT09dD90aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludCgpOnRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KFF0LmNvb3JkLmNhbGwodGhpcyx0KSl9LG11bHRpcG9pbnQodCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludCgpO3ZhciBlLG49dC50cmltKCkuc3BsaXQoXCIsXCIpLHM9W107Zm9yKGxldCB0PTAsaT1uLmxlbmd0aDt0PGk7Kyt0KWU9blt0XS5yZXBsYWNlKGp0LnRyaW1QYXJlbnMsXCIkMVwiKSxzLnB1c2goUXQucG9pbnQuY2FsbCh0aGlzLGUpKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChzKX0sbGluZXN0cmluZyh0KXtpZih2b2lkIDA9PT10KXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKCk7dmFyIGU9dC50cmltKCkuc3BsaXQoXCIsXCIpLG49W107Zm9yKGxldCB0PTAscz1lLmxlbmd0aDt0PHM7Kyt0KW4ucHVzaChRdC5jb29yZC5jYWxsKHRoaXMsZVt0XSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKG4pfSxsaW5lYXJyaW5nKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoKTt2YXIgZT10LnRyaW0oKS5zcGxpdChcIixcIiksbj1bXTtmb3IobGV0IHQ9MCxzPWUubGVuZ3RoO3Q8czsrK3Qpbi5wdXNoKFF0LmNvb3JkLmNhbGwodGhpcyxlW3RdKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcobil9LG11bHRpbGluZXN0cmluZyh0KXtpZih2b2lkIDA9PT10KXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoKTt2YXIgZSxuPXQudHJpbSgpLnNwbGl0KGp0LnBhcmVuQ29tbWEpLHM9W107Zm9yKGxldCB0PTAsaT1uLmxlbmd0aDt0PGk7Kyt0KWU9blt0XS5yZXBsYWNlKGp0LnRyaW1QYXJlbnMsXCIkMVwiKSxzLnB1c2goUXQubGluZXN0cmluZy5jYWxsKHRoaXMsZSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcocyl9LHBvbHlnb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbigpO3ZhciBlLG4scyxpLHI9dC50cmltKCkuc3BsaXQoanQucGFyZW5Db21tYSksbz1bXTtmb3IobGV0IHQ9MCxsPXIubGVuZ3RoO3Q8bDsrK3QpZT1yW3RdLnJlcGxhY2UoanQudHJpbVBhcmVucyxcIiQxXCIpLG49UXQubGluZXN0cmluZy5jYWxsKHRoaXMsZSkscz10aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKG4uX3BvaW50cyksMD09PXQ/aT1zOm8ucHVzaChzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbihpLG8pfSxtdWx0aXBvbHlnb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKCk7dmFyIGUsbj10LnRyaW0oKS5zcGxpdChqdC5kb3VibGVQYXJlbkNvbW1hKSxzPVtdO2ZvcihsZXQgdD0wLGk9bi5sZW5ndGg7dDxpOysrdCllPW5bdF0ucmVwbGFjZShqdC50cmltUGFyZW5zLFwiJDFcIikscy5wdXNoKFF0LnBvbHlnb24uY2FsbCh0aGlzLGUpKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKHMpfSxnZW9tZXRyeWNvbGxlY3Rpb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk7dmFyIGU9KHQ9dC5yZXBsYWNlKC8sXFxzKihbQS1aYS16XSkvZyxcInwkMVwiKSkudHJpbSgpLnNwbGl0KFwifFwiKSxuPVtdO2ZvcihsZXQgdD0wLHM9ZS5sZW5ndGg7dDxzOysrdCluLnB1c2godGhpcy5yZWFkKGVbdF0pKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKG4pfX07Y2xhc3MgSnR7Y29uc3RydWN0b3IodCl7dGhpcy5wYXJzZXI9bmV3IEt0KHQpfXdyaXRlKHQpe3JldHVybiB0aGlzLnBhcnNlci53cml0ZSh0KX1zdGF0aWMgdG9MaW5lU3RyaW5nKHQsZSl7aWYoMiE9PWFyZ3VtZW50cy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO3JldHVyblwiTElORVNUUklORyAoIFwiK3QueCtcIiBcIit0LnkrXCIsIFwiK2UueCtcIiBcIitlLnkrXCIgKVwifX1jbGFzcyAkdHtjb25zdHJ1Y3RvcigpeyR0LmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbXB1dGVFZGdlRGlzdGFuY2UodCxlLG4pe2NvbnN0IHM9TWF0aC5hYnMobi54LWUueCksaT1NYXRoLmFicyhuLnktZS55KTtsZXQgcj0tMTtpZih0LmVxdWFscyhlKSlyPTA7ZWxzZSBpZih0LmVxdWFscyhuKSlyPXM+aT9zOmk7ZWxzZXtjb25zdCBuPU1hdGguYWJzKHQueC1lLngpLG89TWF0aC5hYnModC55LWUueSk7cj1zPmk/bjpvLDAhPT1yfHx0LmVxdWFscyhlKXx8KHI9TWF0aC5tYXgobixvKSl9cmV0dXJuIHUuaXNUcnVlKCEoMD09PXImJiF0LmVxdWFscyhlKSksXCJCYWQgZGlzdGFuY2UgY2FsY3VsYXRpb25cIikscn1zdGF0aWMgbm9uUm9idXN0Q29tcHV0ZUVkZ2VEaXN0YW5jZSh0LGUsbil7Y29uc3Qgcz10LngtZS54LGk9dC55LWUueSxyPU1hdGguc3FydChzKnMraSppKTtyZXR1cm4gdS5pc1RydWUoISgwPT09ciYmIXQuZXF1YWxzKGUpKSxcIkludmFsaWQgZGlzdGFuY2UgY2FsY3VsYXRpb25cIikscn1nZXRJbmRleEFsb25nU2VnbWVudCh0LGUpe3JldHVybiB0aGlzLmNvbXB1dGVJbnRMaW5lSW5kZXgoKSx0aGlzLl9pbnRMaW5lSW5kZXhbdF1bZV19Z2V0VG9wb2xvZ3lTdW1tYXJ5KCl7Y29uc3QgdD1uZXcgd3Q7cmV0dXJuIHRoaXMuaXNFbmRQb2ludCgpJiZ0LmFwcGVuZChcIiBlbmRwb2ludFwiKSx0aGlzLl9pc1Byb3BlciYmdC5hcHBlbmQoXCIgcHJvcGVyXCIpLHRoaXMuaXNDb2xsaW5lYXIoKSYmdC5hcHBlbmQoXCIgY29sbGluZWFyXCIpLHQudG9TdHJpbmcoKX1jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSxuLHMpe3RoaXMuX2lucHV0TGluZXNbMF1bMF09dCx0aGlzLl9pbnB1dExpbmVzWzBdWzFdPWUsdGhpcy5faW5wdXRMaW5lc1sxXVswXT1uLHRoaXMuX2lucHV0TGluZXNbMV1bMV09cyx0aGlzLl9yZXN1bHQ9dGhpcy5jb21wdXRlSW50ZXJzZWN0KHQsZSxuLHMpfWdldEludGVyc2VjdGlvbk51bSgpe3JldHVybiB0aGlzLl9yZXN1bHR9Y29tcHV0ZUludExpbmVJbmRleCgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKW51bGw9PT10aGlzLl9pbnRMaW5lSW5kZXgmJih0aGlzLl9pbnRMaW5lSW5kZXg9QXJyYXkoMikuZmlsbCgpLm1hcCgoKT0+QXJyYXkoMikpLHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgwKSx0aGlzLmNvbXB1dGVJbnRMaW5lSW5kZXgoMSkpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZ2V0RWRnZURpc3RhbmNlKHQsMCk+dGhpcy5nZXRFZGdlRGlzdGFuY2UodCwxKT8odGhpcy5faW50TGluZUluZGV4W3RdWzBdPTAsdGhpcy5faW50TGluZUluZGV4W3RdWzFdPTEpOih0aGlzLl9pbnRMaW5lSW5kZXhbdF1bMF09MSx0aGlzLl9pbnRMaW5lSW5kZXhbdF1bMV09MCl9fWlzUHJvcGVyKCl7cmV0dXJuIHRoaXMuaGFzSW50ZXJzZWN0aW9uKCkmJnRoaXMuX2lzUHJvcGVyfXNldFByZWNpc2lvbk1vZGVsKHQpe3RoaXMuX3ByZWNpc2lvbk1vZGVsPXR9aXNJbnRlcmlvckludGVyc2VjdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiEhdGhpcy5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKDApfHwhIXRoaXMuaXNJbnRlcmlvckludGVyc2VjdGlvbigxKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0aGlzLl9yZXN1bHQ7ZSsrKWlmKCF0aGlzLl9pbnRQdFtlXS5lcXVhbHMyRCh0aGlzLl9pbnB1dExpbmVzW3RdWzBdKSYmIXRoaXMuX2ludFB0W2VdLmVxdWFsczJEKHRoaXMuX2lucHV0TGluZXNbdF1bMV0pKXJldHVybiEwO3JldHVybiExfX1nZXRJbnRlcnNlY3Rpb24odCl7cmV0dXJuIHRoaXMuX2ludFB0W3RdfWlzRW5kUG9pbnQoKXtyZXR1cm4gdGhpcy5oYXNJbnRlcnNlY3Rpb24oKSYmIXRoaXMuX2lzUHJvcGVyfWhhc0ludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9yZXN1bHQhPT0kdC5OT19JTlRFUlNFQ1RJT059Z2V0RWRnZURpc3RhbmNlKHQsZSl7cmV0dXJuICR0LmNvbXB1dGVFZGdlRGlzdGFuY2UodGhpcy5faW50UHRbZV0sdGhpcy5faW5wdXRMaW5lc1t0XVswXSx0aGlzLl9pbnB1dExpbmVzW3RdWzFdKX1pc0NvbGxpbmVhcigpe3JldHVybiB0aGlzLl9yZXN1bHQ9PT0kdC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OfXRvU3RyaW5nKCl7cmV0dXJuIEp0LnRvTGluZVN0cmluZyh0aGlzLl9pbnB1dExpbmVzWzBdWzBdLHRoaXMuX2lucHV0TGluZXNbMF1bMV0pK1wiIC0gXCIrSnQudG9MaW5lU3RyaW5nKHRoaXMuX2lucHV0TGluZXNbMV1bMF0sdGhpcy5faW5wdXRMaW5lc1sxXVsxXSkrdGhpcy5nZXRUb3BvbG9neVN1bW1hcnkoKX1nZXRFbmRwb2ludCh0LGUpe3JldHVybiB0aGlzLl9pbnB1dExpbmVzW3RdW2VdfWlzSW50ZXJzZWN0aW9uKHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5fcmVzdWx0O2UrKylpZih0aGlzLl9pbnRQdFtlXS5lcXVhbHMyRCh0KSlyZXR1cm4hMDtyZXR1cm4hMX1nZXRJbnRlcnNlY3Rpb25BbG9uZ1NlZ21lbnQodCxlKXtyZXR1cm4gdGhpcy5jb21wdXRlSW50TGluZUluZGV4KCksdGhpcy5faW50UHRbdGhpcy5faW50TGluZUluZGV4W3RdW2VdXX1nZXRDbGFzcygpe3JldHVybiAkdH1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19JHQuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcmVzdWx0PW51bGwsdGhpcy5faW5wdXRMaW5lcz1BcnJheSgyKS5maWxsKCkubWFwKCgpPT5BcnJheSgyKSksdGhpcy5faW50UHQ9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5faW50TGluZUluZGV4PW51bGwsdGhpcy5faXNQcm9wZXI9bnVsbCx0aGlzLl9wYT1udWxsLHRoaXMuX3BiPW51bGwsdGhpcy5fcHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLl9pbnRQdFswXT1uZXcgZyx0aGlzLl9pbnRQdFsxXT1uZXcgZyx0aGlzLl9wYT10aGlzLl9pbnRQdFswXSx0aGlzLl9wYj10aGlzLl9pbnRQdFsxXSx0aGlzLl9yZXN1bHQ9MH0sJHQuRE9OVF9JTlRFUlNFQ1Q9MCwkdC5ET19JTlRFUlNFQ1Q9MSwkdC5DT0xMSU5FQVI9MiwkdC5OT19JTlRFUlNFQ1RJT049MCwkdC5QT0lOVF9JTlRFUlNFQ1RJT049MSwkdC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OPTI7Y2xhc3MgdGUgZXh0ZW5kcyAkdHtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksdGUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgbmVhcmVzdEVuZHBvaW50KHQsZSxuLHMpe2xldCBpPXQscj1ELnBvaW50VG9TZWdtZW50KHQsbixzKSxvPUQucG9pbnRUb1NlZ21lbnQoZSxuLHMpO3JldHVybiBvPHImJihyPW8saT1lKSxvPUQucG9pbnRUb1NlZ21lbnQobix0LGUpLG88ciYmKHI9byxpPW4pLG89RC5wb2ludFRvU2VnbWVudChzLHQsZSksbzxyJiYocj1vLGk9cyksaX1pc0luU2VnbWVudEVudmVsb3Blcyh0KXtjb25zdCBlPW5ldyBOKHRoaXMuX2lucHV0TGluZXNbMF1bMF0sdGhpcy5faW5wdXRMaW5lc1swXVsxXSksbj1uZXcgTih0aGlzLl9pbnB1dExpbmVzWzFdWzBdLHRoaXMuX2lucHV0TGluZXNbMV1bMV0pO3JldHVybiBlLmNvbnRhaW5zKHQpJiZuLmNvbnRhaW5zKHQpfWNvbXB1dGVJbnRlcnNlY3Rpb24oKXtpZigzIT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gc3VwZXIuY29tcHV0ZUludGVyc2VjdGlvbi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7e2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKHRoaXMuX2lzUHJvcGVyPSExLE4uaW50ZXJzZWN0cyhlLG4sdCkmJjA9PT12LmluZGV4KGUsbix0KSYmMD09PXYuaW5kZXgobixlLHQpKXJldHVybiB0aGlzLl9pc1Byb3Blcj0hMCwodC5lcXVhbHMoZSl8fHQuZXF1YWxzKG4pKSYmKHRoaXMuX2lzUHJvcGVyPSExKSx0aGlzLl9yZXN1bHQ9JHQuUE9JTlRfSU5URVJTRUNUSU9OLG51bGw7dGhpcy5fcmVzdWx0PSR0Lk5PX0lOVEVSU0VDVElPTn19bm9ybWFsaXplVG9NaW5pbXVtKHQsZSxuLHMsaSl7aS54PXRoaXMuc21hbGxlc3RJbkFic1ZhbHVlKHQueCxlLngsbi54LHMueCksaS55PXRoaXMuc21hbGxlc3RJbkFic1ZhbHVlKHQueSxlLnksbi55LHMueSksdC54LT1pLngsdC55LT1pLnksZS54LT1pLngsZS55LT1pLnksbi54LT1pLngsbi55LT1pLnkscy54LT1pLngscy55LT1pLnl9c2FmZUhDb29yZGluYXRlSW50ZXJzZWN0aW9uKHQsZSxuLHMpe2xldCBpPW51bGw7dHJ5e2k9Yi5pbnRlcnNlY3Rpb24odCxlLG4scyl9Y2F0Y2gocil7aWYoIShyIGluc3RhbmNlb2YgUykpdGhyb3cgcjtpPXRlLm5lYXJlc3RFbmRwb2ludCh0LGUsbixzKX1yZXR1cm4gaX1pbnRlcnNlY3Rpb24odCxlLG4scyl7bGV0IGk9dGhpcy5pbnRlcnNlY3Rpb25XaXRoTm9ybWFsaXphdGlvbih0LGUsbixzKTtyZXR1cm4gdGhpcy5pc0luU2VnbWVudEVudmVsb3BlcyhpKXx8KGk9bmV3IGcodGUubmVhcmVzdEVuZHBvaW50KHQsZSxuLHMpKSksbnVsbCE9PXRoaXMuX3ByZWNpc2lvbk1vZGVsJiZ0aGlzLl9wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZShpKSxpfXNtYWxsZXN0SW5BYnNWYWx1ZSh0LGUsbixzKXtsZXQgaT10LHI9TWF0aC5hYnMoaSk7cmV0dXJuIE1hdGguYWJzKGUpPHImJihpPWUscj1NYXRoLmFicyhlKSksTWF0aC5hYnMobik8ciYmKGk9bixyPU1hdGguYWJzKG4pKSxNYXRoLmFicyhzKTxyJiYoaT1zKSxpfWNoZWNrREQodCxlLG4scyxpKXtjb25zdCByPVAuaW50ZXJzZWN0aW9uKHQsZSxuLHMpLG89dGhpcy5pc0luU2VnbWVudEVudmVsb3BlcyhyKTtPLm91dC5wcmludGxuKFwiREQgaW4gZW52ID0gXCIrbytcIiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFwiK3IpLGkuZGlzdGFuY2Uocik+MWUtNCYmTy5vdXQucHJpbnRsbihcIkRpc3RhbmNlID0gXCIraS5kaXN0YW5jZShyKSl9aW50ZXJzZWN0aW9uV2l0aE5vcm1hbGl6YXRpb24odCxlLG4scyl7Y29uc3QgaT1uZXcgZyh0KSxyPW5ldyBnKGUpLG89bmV3IGcobiksbD1uZXcgZyhzKSxhPW5ldyBnO3RoaXMubm9ybWFsaXplVG9FbnZDZW50cmUoaSxyLG8sbCxhKTtjb25zdCBjPXRoaXMuc2FmZUhDb29yZGluYXRlSW50ZXJzZWN0aW9uKGkscixvLGwpO3JldHVybiBjLngrPWEueCxjLnkrPWEueSxjfWNvbXB1dGVDb2xsaW5lYXJJbnRlcnNlY3Rpb24odCxlLG4scyl7Y29uc3QgaT1OLmludGVyc2VjdHModCxlLG4pLHI9Ti5pbnRlcnNlY3RzKHQsZSxzKSxvPU4uaW50ZXJzZWN0cyhuLHMsdCksbD1OLmludGVyc2VjdHMobixzLGUpO3JldHVybiBpJiZyPyh0aGlzLl9pbnRQdFswXT1uLHRoaXMuX2ludFB0WzFdPXMsJHQuQ09MTElORUFSX0lOVEVSU0VDVElPTik6byYmbD8odGhpcy5faW50UHRbMF09dCx0aGlzLl9pbnRQdFsxXT1lLCR0LkNPTExJTkVBUl9JTlRFUlNFQ1RJT04pOmkmJm8/KHRoaXMuX2ludFB0WzBdPW4sdGhpcy5faW50UHRbMV09dCwhbi5lcXVhbHModCl8fHJ8fGw/JHQuQ09MTElORUFSX0lOVEVSU0VDVElPTjokdC5QT0lOVF9JTlRFUlNFQ1RJT04pOmkmJmw/KHRoaXMuX2ludFB0WzBdPW4sdGhpcy5faW50UHRbMV09ZSwhbi5lcXVhbHMoZSl8fHJ8fG8/JHQuQ09MTElORUFSX0lOVEVSU0VDVElPTjokdC5QT0lOVF9JTlRFUlNFQ1RJT04pOnImJm8/KHRoaXMuX2ludFB0WzBdPXMsdGhpcy5faW50UHRbMV09dCwhcy5lcXVhbHModCl8fGl8fGw/JHQuQ09MTElORUFSX0lOVEVSU0VDVElPTjokdC5QT0lOVF9JTlRFUlNFQ1RJT04pOnImJmw/KHRoaXMuX2ludFB0WzBdPXMsdGhpcy5faW50UHRbMV09ZSwhcy5lcXVhbHMoZSl8fGl8fG8/JHQuQ09MTElORUFSX0lOVEVSU0VDVElPTjokdC5QT0lOVF9JTlRFUlNFQ1RJT04pOiR0Lk5PX0lOVEVSU0VDVElPTn1ub3JtYWxpemVUb0VudkNlbnRyZSh0LGUsbixzLGkpe2NvbnN0IHI9dC54PGUueD90Lng6ZS54LG89dC55PGUueT90Lnk6ZS55LGw9dC54PmUueD90Lng6ZS54LGE9dC55PmUueT90Lnk6ZS55LGM9bi54PHMueD9uLng6cy54LGg9bi55PHMueT9uLnk6cy55LHU9bi54PnMueD9uLng6cy54LGc9bi55PnMueT9uLnk6cy55LGQ9KChyPmM/cjpjKSsobDx1P2w6dSkpLzIsXz0oKG8+aD9vOmgpKyhhPGc/YTpnKSkvMjtpLng9ZCxpLnk9Xyx0LngtPWkueCx0LnktPWkueSxlLngtPWkueCxlLnktPWkueSxuLngtPWkueCxuLnktPWkueSxzLngtPWkueCxzLnktPWkueX1jb21wdXRlSW50ZXJzZWN0KHQsZSxuLHMpe2lmKHRoaXMuX2lzUHJvcGVyPSExLCFOLmludGVyc2VjdHModCxlLG4scykpcmV0dXJuICR0Lk5PX0lOVEVSU0VDVElPTjtjb25zdCBpPXYuaW5kZXgodCxlLG4pLHI9di5pbmRleCh0LGUscyk7aWYoaT4wJiZyPjB8fGk8MCYmcjwwKXJldHVybiAkdC5OT19JTlRFUlNFQ1RJT047Y29uc3Qgbz12LmluZGV4KG4scyx0KSxsPXYuaW5kZXgobixzLGUpO3JldHVybiBvPjAmJmw+MHx8bzwwJiZsPDA/JHQuTk9fSU5URVJTRUNUSU9OOjA9PT1pJiYwPT09ciYmMD09PW8mJjA9PT1sP3RoaXMuY29tcHV0ZUNvbGxpbmVhckludGVyc2VjdGlvbih0LGUsbixzKTooMD09PWl8fDA9PT1yfHwwPT09b3x8MD09PWw/KHRoaXMuX2lzUHJvcGVyPSExLHQuZXF1YWxzMkQobil8fHQuZXF1YWxzMkQocyk/dGhpcy5faW50UHRbMF09dDplLmVxdWFsczJEKG4pfHxlLmVxdWFsczJEKHMpP3RoaXMuX2ludFB0WzBdPWU6MD09PWk/dGhpcy5faW50UHRbMF09bmV3IGcobik6MD09PXI/dGhpcy5faW50UHRbMF09bmV3IGcocyk6MD09PW8/dGhpcy5faW50UHRbMF09bmV3IGcodCk6MD09PWwmJih0aGlzLl9pbnRQdFswXT1uZXcgZyhlKSkpOih0aGlzLl9pc1Byb3Blcj0hMCx0aGlzLl9pbnRQdFswXT10aGlzLmludGVyc2VjdGlvbih0LGUsbixzKSksJHQuUE9JTlRfSU5URVJTRUNUSU9OKX1nZXRDbGFzcygpe3JldHVybiB0ZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19dGUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBlZXtjb25zdHJ1Y3Rvcigpe2VlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIG1pZFBvaW50KHQsZSl7cmV0dXJuIG5ldyBnKCh0LngrZS54KS8yLCh0LnkrZS55KS8yKX1taW5YKCl7cmV0dXJuIE1hdGgubWluKHRoaXMucDAueCx0aGlzLnAxLngpfW9yaWVudGF0aW9uSW5kZXgoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGVlKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXYuaW5kZXgodGhpcy5wMCx0aGlzLnAxLHQucDApLG49di5pbmRleCh0aGlzLnAwLHRoaXMucDEsdC5wMSk7cmV0dXJuIGU+PTAmJm4+PTB8fGU8PTAmJm48PTA/TWF0aC5tYXgoZSxuKTowfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHYuaW5kZXgodGhpcy5wMCx0aGlzLnAxLHQpfX10b0dlb21ldHJ5KHQpe3JldHVybiB0LmNyZWF0ZUxpbmVTdHJpbmcoW3RoaXMucDAsdGhpcy5wMV0pfWlzVmVydGljYWwoKXtyZXR1cm4gdGhpcy5wMC54PT09dGhpcy5wMS54fWVxdWFscyh0KXtpZighKHQgaW5zdGFuY2VvZiBlZSkpcmV0dXJuITE7Y29uc3QgZT10O3JldHVybiB0aGlzLnAwLmVxdWFscyhlLnAwKSYmdGhpcy5wMS5lcXVhbHMoZS5wMSl9aW50ZXJzZWN0aW9uKHQpe2NvbnN0IGU9bmV3IHRlO3JldHVybiBlLmNvbXB1dGVJbnRlcnNlY3Rpb24odGhpcy5wMCx0aGlzLnAxLHQucDAsdC5wMSksZS5oYXNJbnRlcnNlY3Rpb24oKT9lLmdldEludGVyc2VjdGlvbigwKTpudWxsfXByb2plY3QoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHQuZXF1YWxzKHRoaXMucDApfHx0LmVxdWFscyh0aGlzLnAxKSlyZXR1cm4gbmV3IGcodCk7Y29uc3QgZT10aGlzLnByb2plY3Rpb25GYWN0b3IodCksbj1uZXcgZztyZXR1cm4gbi54PXRoaXMucDAueCtlKih0aGlzLnAxLngtdGhpcy5wMC54KSxuLnk9dGhpcy5wMC55K2UqKHRoaXMucDEueS10aGlzLnAwLnkpLG59aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBlZSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT10aGlzLnByb2plY3Rpb25GYWN0b3IodC5wMCksbj10aGlzLnByb2plY3Rpb25GYWN0b3IodC5wMSk7aWYoZT49MSYmbj49MSlyZXR1cm4gbnVsbDtpZihlPD0wJiZuPD0wKXJldHVybiBudWxsO2xldCBzPXRoaXMucHJvamVjdCh0LnAwKTtlPDAmJihzPXRoaXMucDApLGU+MSYmKHM9dGhpcy5wMSk7bGV0IGk9dGhpcy5wcm9qZWN0KHQucDEpO3JldHVybiBuPDAmJihpPXRoaXMucDApLG4+MSYmKGk9dGhpcy5wMSksbmV3IGVlKHMsaSl9fW5vcm1hbGl6ZSgpe3RoaXMucDEuY29tcGFyZVRvKHRoaXMucDApPDAmJnRoaXMucmV2ZXJzZSgpfWFuZ2xlKCl7cmV0dXJuIE1hdGguYXRhbjIodGhpcy5wMS55LXRoaXMucDAueSx0aGlzLnAxLngtdGhpcy5wMC54KX1nZXRDb29yZGluYXRlKHQpe3JldHVybiAwPT09dD90aGlzLnAwOnRoaXMucDF9ZGlzdGFuY2VQZXJwZW5kaWN1bGFyKHQpe3JldHVybiBELnBvaW50VG9MaW5lUGVycGVuZGljdWxhcih0LHRoaXMucDAsdGhpcy5wMSl9bWluWSgpe3JldHVybiBNYXRoLm1pbih0aGlzLnAwLnksdGhpcy5wMS55KX1taWRQb2ludCgpe3JldHVybiBlZS5taWRQb2ludCh0aGlzLnAwLHRoaXMucDEpfXByb2plY3Rpb25GYWN0b3IodCl7aWYodC5lcXVhbHModGhpcy5wMCkpcmV0dXJuIDA7aWYodC5lcXVhbHModGhpcy5wMSkpcmV0dXJuIDE7Y29uc3QgZT10aGlzLnAxLngtdGhpcy5wMC54LG49dGhpcy5wMS55LXRoaXMucDAueSxzPWUqZStuKm47cmV0dXJuIHM8PTA/aS5OYU46KCh0LngtdGhpcy5wMC54KSplKyh0LnktdGhpcy5wMC55KSpuKS9zfWNsb3Nlc3RQb2ludHModCl7Y29uc3QgZT10aGlzLmludGVyc2VjdGlvbih0KTtpZihudWxsIT09ZSlyZXR1cm5bZSxlXTtjb25zdCBuPW5ldyBBcnJheSgyKS5maWxsKG51bGwpO2xldCBzPWkuTUFYX1ZBTFVFLHI9bnVsbDtjb25zdCBvPXRoaXMuY2xvc2VzdFBvaW50KHQucDApO3M9by5kaXN0YW5jZSh0LnAwKSxuWzBdPW8sblsxXT10LnAwO2NvbnN0IGw9dGhpcy5jbG9zZXN0UG9pbnQodC5wMSk7cj1sLmRpc3RhbmNlKHQucDEpLHI8cyYmKHM9cixuWzBdPWwsblsxXT10LnAxKTtjb25zdCBhPXQuY2xvc2VzdFBvaW50KHRoaXMucDApO3I9YS5kaXN0YW5jZSh0aGlzLnAwKSxyPHMmJihzPXIsblswXT10aGlzLnAwLG5bMV09YSk7Y29uc3QgYz10LmNsb3Nlc3RQb2ludCh0aGlzLnAxKTtyZXR1cm4gcj1jLmRpc3RhbmNlKHRoaXMucDEpLHI8cyYmKHM9cixuWzBdPXRoaXMucDEsblsxXT1jKSxufWNsb3Nlc3RQb2ludCh0KXtjb25zdCBlPXRoaXMucHJvamVjdGlvbkZhY3Rvcih0KTtyZXR1cm4gZT4wJiZlPDE/dGhpcy5wcm9qZWN0KHQpOnRoaXMucDAuZGlzdGFuY2UodCk8dGhpcy5wMS5kaXN0YW5jZSh0KT90aGlzLnAwOnRoaXMucDF9bWF4WCgpe3JldHVybiBNYXRoLm1heCh0aGlzLnAwLngsdGhpcy5wMS54KX1nZXRMZW5ndGgoKXtyZXR1cm4gdGhpcy5wMC5kaXN0YW5jZSh0aGlzLnAxKX1jb21wYXJlVG8odCl7Y29uc3QgZT10LG49dGhpcy5wMC5jb21wYXJlVG8oZS5wMCk7cmV0dXJuIDAhPT1uP246dGhpcy5wMS5jb21wYXJlVG8oZS5wMSl9cmV2ZXJzZSgpe2NvbnN0IHQ9dGhpcy5wMDt0aGlzLnAwPXRoaXMucDEsdGhpcy5wMT10fWVxdWFsc1RvcG8odCl7cmV0dXJuIHRoaXMucDAuZXF1YWxzKHQucDApJiZ0aGlzLnAxLmVxdWFscyh0LnAxKXx8dGhpcy5wMC5lcXVhbHModC5wMSkmJnRoaXMucDEuZXF1YWxzKHQucDApfWxpbmVJbnRlcnNlY3Rpb24odCl7dHJ5e3JldHVybiBiLmludGVyc2VjdGlvbih0aGlzLnAwLHRoaXMucDEsdC5wMCx0LnAxKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBTKSl0aHJvdyB0fXJldHVybiBudWxsfW1heFkoKXtyZXR1cm4gTWF0aC5tYXgodGhpcy5wMC55LHRoaXMucDEueSl9cG9pbnRBbG9uZ09mZnNldCh0LGUpe2NvbnN0IG49dGhpcy5wMC54K3QqKHRoaXMucDEueC10aGlzLnAwLngpLHM9dGhpcy5wMC55K3QqKHRoaXMucDEueS10aGlzLnAwLnkpLGk9dGhpcy5wMS54LXRoaXMucDAueCxyPXRoaXMucDEueS10aGlzLnAwLnksbz1NYXRoLnNxcnQoaSppK3Iqcik7bGV0IGw9MCxhPTA7aWYoMCE9PWUpe2lmKG88PTApdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcIkNhbm5vdCBjb21wdXRlIG9mZnNldCBmcm9tIHplcm8tbGVuZ3RoIGxpbmUgc2VnbWVudFwiKTtsPWUqaS9vLGE9ZSpyL299cmV0dXJuIG5ldyBnKG4tYSxzK2wpfXNldENvb3JkaW5hdGVzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0Q29vcmRpbmF0ZXModC5wMCx0LnAxKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnAwLng9dC54LHRoaXMucDAueT10LnksdGhpcy5wMS54PWUueCx0aGlzLnAxLnk9ZS55fX1zZWdtZW50RnJhY3Rpb24odCl7bGV0IGU9dGhpcy5wcm9qZWN0aW9uRmFjdG9yKHQpO3JldHVybiBlPDA/ZT0wOihlPjF8fGkuaXNOYU4oZSkpJiYoZT0xKSxlfXRvU3RyaW5nKCl7cmV0dXJuXCJMSU5FU1RSSU5HKCBcIit0aGlzLnAwLngrXCIgXCIrdGhpcy5wMC55K1wiLCBcIit0aGlzLnAxLngrXCIgXCIrdGhpcy5wMS55K1wiKVwifWlzSG9yaXpvbnRhbCgpe3JldHVybiB0aGlzLnAwLnk9PT10aGlzLnAxLnl9ZGlzdGFuY2UoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGVlKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gRC5zZWdtZW50VG9TZWdtZW50KHRoaXMucDAsdGhpcy5wMSx0LnAwLHQucDEpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIEQucG9pbnRUb1NlZ21lbnQodCx0aGlzLnAwLHRoaXMucDEpfX1wb2ludEFsb25nKHQpe2NvbnN0IGU9bmV3IGc7cmV0dXJuIGUueD10aGlzLnAwLngrdCoodGhpcy5wMS54LXRoaXMucDAueCksZS55PXRoaXMucDAueSt0Kih0aGlzLnAxLnktdGhpcy5wMC55KSxlfWhhc2hDb2RlKCl7bGV0IHQ9amF2YS5sYW5nLkRvdWJsZS5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDAueCk7dF49MzEqamF2YS5sYW5nLkRvdWJsZS5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDAueSk7Y29uc3QgZT1NYXRoLnRydW5jKHQpXk1hdGgudHJ1bmModD4+MzIpO2xldCBuPWphdmEubGFuZy5Eb3VibGUuZG91YmxlVG9Mb25nQml0cyh0aGlzLnAxLngpO3JldHVybiBuXj0zMSpqYXZhLmxhbmcuRG91YmxlLmRvdWJsZVRvTG9uZ0JpdHModGhpcy5wMS55KSxlXihNYXRoLnRydW5jKG4pXk1hdGgudHJ1bmMobj4+MzIpKX1nZXRDbGFzcygpe3JldHVybiBlZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bcixhXX19ZWUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5wMD1udWxsLHRoaXMucDE9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCllZS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG5ldyBnLG5ldyBnKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtlZS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQucDAsdC5wMSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5wMD10LHRoaXMucDE9ZX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtlZS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG5ldyBnKHQsZSksbmV3IGcobixzKSl9fSxlZS5zZXJpYWxWZXJzaW9uVUlEPTB4MmQyMTcyMTM1ZjQxMWMwMDtjbGFzcyBuZXtjb25zdHJ1Y3Rvcigpe25lLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHRvTG9jYXRpb25TeW1ib2wodCl7c3dpdGNoKHQpe2Nhc2UgbmUuRVhURVJJT1I6cmV0dXJuXCJlXCI7Y2FzZSBuZS5CT1VOREFSWTpyZXR1cm5cImJcIjtjYXNlIG5lLklOVEVSSU9SOnJldHVyblwiaVwiO2Nhc2UgbmUuTk9ORTpyZXR1cm5cIi1cIn10aHJvdyBuZXcgbihcIlVua25vd24gbG9jYXRpb24gdmFsdWU6IFwiK3QpfWdldENsYXNzKCl7cmV0dXJuIG5lfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1uZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LG5lLklOVEVSSU9SPTAsbmUuQk9VTkRBUlk9MSxuZS5FWFRFUklPUj0yLG5lLk5PTkU9LTE7Y2xhc3Mgc2V7Y29uc3RydWN0b3IoKXtzZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBtYXRjaGVzKCl7aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pJiZcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gZT09PXV0LlNZTV9ET05UQ0FSRXx8KGU9PT11dC5TWU1fVFJVRSYmKHQ+PTB8fHQ9PT11dC5UUlVFKXx8KGU9PT11dC5TWU1fRkFMU0UmJnQ9PT11dC5GQUxTRXx8KGU9PT11dC5TWU1fUCYmdD09PXV0LlB8fChlPT09dXQuU1lNX0wmJnQ9PT11dC5MfHxlPT09dXQuU1lNX0EmJnQ9PT11dC5BKSkpKX1pZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IHNlKHQpLm1hdGNoZXMoZSl9fXN0YXRpYyBpc1RydWUodCl7cmV0dXJuIHQ+PTB8fHQ9PT11dC5UUlVFfWlzSW50ZXJzZWN0cygpe3JldHVybiF0aGlzLmlzRGlzam9pbnQoKX1pc0NvdmVycygpe3JldHVybihzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5JTlRFUklPUl0pfHxzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5CT1VOREFSWV0pfHxzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLkJPVU5EQVJZXVtuZS5JTlRFUklPUl0pfHxzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLkJPVU5EQVJZXVtuZS5CT1VOREFSWV0pKSYmdGhpcy5fbWF0cml4W25lLkVYVEVSSU9SXVtuZS5JTlRFUklPUl09PT11dC5GQUxTRSYmdGhpcy5fbWF0cml4W25lLkVYVEVSSU9SXVtuZS5CT1VOREFSWV09PT11dC5GQUxTRX1pc0NvdmVyZWRCeSgpe3JldHVybihzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5JTlRFUklPUl0pfHxzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5CT1VOREFSWV0pfHxzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLkJPVU5EQVJZXVtuZS5JTlRFUklPUl0pfHxzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLkJPVU5EQVJZXVtuZS5CT1VOREFSWV0pKSYmdGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5FWFRFUklPUl09PT11dC5GQUxTRSYmdGhpcy5fbWF0cml4W25lLkJPVU5EQVJZXVtuZS5FWFRFUklPUl09PT11dC5GQUxTRX1zZXQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspe2NvbnN0IG49TWF0aC50cnVuYyhlLzMpLHM9ZSUzO3RoaXMuX21hdHJpeFtuXVtzXT11dC50b0RpbWVuc2lvblZhbHVlKHQuY2hhckF0KGUpKX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fbWF0cml4W3RdW2VdPW59fWlzQ29udGFpbnMoKXtyZXR1cm4gc2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuSU5URVJJT1JdKSYmdGhpcy5fbWF0cml4W25lLkVYVEVSSU9SXVtuZS5JTlRFUklPUl09PT11dC5GQUxTRSYmdGhpcy5fbWF0cml4W25lLkVYVEVSSU9SXVtuZS5CT1VOREFSWV09PT11dC5GQUxTRX1zZXRBdExlYXN0KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXtjb25zdCBuPU1hdGgudHJ1bmMoZS8zKSxzPWUlMzt0aGlzLnNldEF0TGVhc3QobixzLHV0LnRvRGltZW5zaW9uVmFsdWUodC5jaGFyQXQoZSkpKX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fbWF0cml4W3RdW2VdPG4mJih0aGlzLl9tYXRyaXhbdF1bZV09bil9fXNldEF0TGVhc3RJZlZhbGlkKHQsZSxuKXt0Pj0wJiZlPj0wJiZ0aGlzLnNldEF0TGVhc3QodCxlLG4pfWlzV2l0aGluKCl7cmV0dXJuIHNlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLklOVEVSSU9SXSkmJnRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuRVhURVJJT1JdPT09dXQuRkFMU0UmJnRoaXMuX21hdHJpeFtuZS5CT1VOREFSWV1bbmUuRVhURVJJT1JdPT09dXQuRkFMU0V9aXNUb3VjaGVzKHQsZSl7cmV0dXJuIHQ+ZT90aGlzLmlzVG91Y2hlcyhlLHQpOih0PT09dXQuQSYmZT09PXV0LkF8fHQ9PT11dC5MJiZlPT09dXQuTHx8dD09PXV0LkwmJmU9PT11dC5BfHx0PT09dXQuUCYmZT09PXV0LkF8fHQ9PT11dC5QJiZlPT09dXQuTCkmJih0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLklOVEVSSU9SXT09PXV0LkZBTFNFJiYoc2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuQk9VTkRBUlldKXx8c2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5CT1VOREFSWV1bbmUuSU5URVJJT1JdKXx8c2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5CT1VOREFSWV1bbmUuQk9VTkRBUlldKSkpfWlzT3ZlcmxhcHModCxlKXtyZXR1cm4gdD09PXV0LlAmJmU9PT11dC5QfHx0PT09dXQuQSYmZT09PXV0LkE/c2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuSU5URVJJT1JdKSYmc2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuRVhURVJJT1JdKSYmc2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5FWFRFUklPUl1bbmUuSU5URVJJT1JdKTp0PT09dXQuTCYmZT09PXV0LkwmJigxPT09dGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5JTlRFUklPUl0mJnNlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLkVYVEVSSU9SXSkmJnNlLmlzVHJ1ZSh0aGlzLl9tYXRyaXhbbmUuRVhURVJJT1JdW25lLklOVEVSSU9SXSkpfWlzRXF1YWxzKHQsZSl7cmV0dXJuIHQ9PT1lJiYoc2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuSU5URVJJT1JdKSYmdGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5FWFRFUklPUl09PT11dC5GQUxTRSYmdGhpcy5fbWF0cml4W25lLkJPVU5EQVJZXVtuZS5FWFRFUklPUl09PT11dC5GQUxTRSYmdGhpcy5fbWF0cml4W25lLkVYVEVSSU9SXVtuZS5JTlRFUklPUl09PT11dC5GQUxTRSYmdGhpcy5fbWF0cml4W25lLkVYVEVSSU9SXVtuZS5CT1VOREFSWV09PT11dC5GQUxTRSl9dG9TdHJpbmcoKXtjb25zdCB0PW5ldyB3dChcIjEyMzQ1Njc4OVwiKTtmb3IobGV0IGU9MDtlPDM7ZSsrKWZvcihsZXQgbj0wO248MztuKyspdC5zZXRDaGFyQXQoMyplK24sdXQudG9EaW1lbnNpb25TeW1ib2wodGhpcy5fbWF0cml4W2VdW25dKSk7cmV0dXJuIHQudG9TdHJpbmcoKX1zZXRBbGwodCl7Zm9yKGxldCBlPTA7ZTwzO2UrKylmb3IobGV0IG49MDtuPDM7bisrKXRoaXMuX21hdHJpeFtlXVtuXT10fWdldCh0LGUpe3JldHVybiB0aGlzLl9tYXRyaXhbdF1bZV19dHJhbnNwb3NlKCl7bGV0IHQ9dGhpcy5fbWF0cml4WzFdWzBdO3JldHVybiB0aGlzLl9tYXRyaXhbMV1bMF09dGhpcy5fbWF0cml4WzBdWzFdLHRoaXMuX21hdHJpeFswXVsxXT10LHQ9dGhpcy5fbWF0cml4WzJdWzBdLHRoaXMuX21hdHJpeFsyXVswXT10aGlzLl9tYXRyaXhbMF1bMl0sdGhpcy5fbWF0cml4WzBdWzJdPXQsdD10aGlzLl9tYXRyaXhbMl1bMV0sdGhpcy5fbWF0cml4WzJdWzFdPXRoaXMuX21hdHJpeFsxXVsyXSx0aGlzLl9tYXRyaXhbMV1bMl09dCx0aGlzfW1hdGNoZXModCl7aWYoOSE9PXQubGVuZ3RoKXRocm93IG5ldyBuKFwiU2hvdWxkIGJlIGxlbmd0aCA5OiBcIit0KTtmb3IobGV0IGU9MDtlPDM7ZSsrKWZvcihsZXQgbj0wO248MztuKyspaWYoIXNlLm1hdGNoZXModGhpcy5fbWF0cml4W2VdW25dLHQuY2hhckF0KDMqZStuKSkpcmV0dXJuITE7cmV0dXJuITB9YWRkKHQpe2ZvcihsZXQgZT0wO2U8MztlKyspZm9yKGxldCBuPTA7bjwzO24rKyl0aGlzLnNldEF0TGVhc3QoZSxuLHQuZ2V0KGUsbikpfWlzRGlzam9pbnQoKXtyZXR1cm4gdGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5JTlRFUklPUl09PT11dC5GQUxTRSYmdGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5CT1VOREFSWV09PT11dC5GQUxTRSYmdGhpcy5fbWF0cml4W25lLkJPVU5EQVJZXVtuZS5JTlRFUklPUl09PT11dC5GQUxTRSYmdGhpcy5fbWF0cml4W25lLkJPVU5EQVJZXVtuZS5CT1VOREFSWV09PT11dC5GQUxTRX1pc0Nyb3NzZXModCxlKXtyZXR1cm4gdD09PXV0LlAmJmU9PT11dC5MfHx0PT09dXQuUCYmZT09PXV0LkF8fHQ9PT11dC5MJiZlPT09dXQuQT9zZS5pc1RydWUodGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5JTlRFUklPUl0pJiZzZS5pc1RydWUodGhpcy5fbWF0cml4W25lLklOVEVSSU9SXVtuZS5FWFRFUklPUl0pOnQ9PT11dC5MJiZlPT09dXQuUHx8dD09PXV0LkEmJmU9PT11dC5QfHx0PT09dXQuQSYmZT09PXV0Lkw/c2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5JTlRFUklPUl1bbmUuSU5URVJJT1JdKSYmc2UuaXNUcnVlKHRoaXMuX21hdHJpeFtuZS5FWFRFUklPUl1bbmUuSU5URVJJT1JdKTp0PT09dXQuTCYmZT09PXV0LkwmJjA9PT10aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLklOVEVSSU9SXX1nZXRDbGFzcygpe3JldHVybiBzZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bb119fXNlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX21hdHJpeD1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuX21hdHJpeD1BcnJheSgzKS5maWxsKCkubWFwKCgpPT5BcnJheSgzKSksdGhpcy5zZXRBbGwodXQuRkFMU0UpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpaWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7Y29uc3QgdD1hcmd1bWVudHNbMF07c2UuY29uc3RydWN0b3JfLmNhbGwodGhpcyksdGhpcy5zZXQodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHNlKXtjb25zdCB0PWFyZ3VtZW50c1swXTtzZS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzKSx0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLklOVEVSSU9SXT10Ll9tYXRyaXhbbmUuSU5URVJJT1JdW25lLklOVEVSSU9SXSx0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLkJPVU5EQVJZXT10Ll9tYXRyaXhbbmUuSU5URVJJT1JdW25lLkJPVU5EQVJZXSx0aGlzLl9tYXRyaXhbbmUuSU5URVJJT1JdW25lLkVYVEVSSU9SXT10Ll9tYXRyaXhbbmUuSU5URVJJT1JdW25lLkVYVEVSSU9SXSx0aGlzLl9tYXRyaXhbbmUuQk9VTkRBUlldW25lLklOVEVSSU9SXT10Ll9tYXRyaXhbbmUuQk9VTkRBUlldW25lLklOVEVSSU9SXSx0aGlzLl9tYXRyaXhbbmUuQk9VTkRBUlldW25lLkJPVU5EQVJZXT10Ll9tYXRyaXhbbmUuQk9VTkRBUlldW25lLkJPVU5EQVJZXSx0aGlzLl9tYXRyaXhbbmUuQk9VTkRBUlldW25lLkVYVEVSSU9SXT10Ll9tYXRyaXhbbmUuQk9VTkRBUlldW25lLkVYVEVSSU9SXSx0aGlzLl9tYXRyaXhbbmUuRVhURVJJT1JdW25lLklOVEVSSU9SXT10Ll9tYXRyaXhbbmUuRVhURVJJT1JdW25lLklOVEVSSU9SXSx0aGlzLl9tYXRyaXhbbmUuRVhURVJJT1JdW25lLkJPVU5EQVJZXT10Ll9tYXRyaXhbbmUuRVhURVJJT1JdW25lLkJPVU5EQVJZXSx0aGlzLl9tYXRyaXhbbmUuRVhURVJJT1JdW25lLkVYVEVSSU9SXT10Ll9tYXRyaXhbbmUuRVhURVJJT1JdW25lLkVYVEVSSU9SXX19O2NsYXNzIGlle2NvbnN0cnVjdG9yKCl7aWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgdG9EZWdyZWVzKHQpe3JldHVybiAxODAqdC9NYXRoLlBJfXN0YXRpYyBub3JtYWxpemUodCl7Zm9yKDt0Pk1hdGguUEk7KXQtPWllLlBJX1RJTUVTXzI7Zm9yKDt0PD0tTWF0aC5QSTspdCs9aWUuUElfVElNRVNfMjtyZXR1cm4gdH1zdGF0aWMgYW5nbGUoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIE1hdGguYXRhbjIodC55LHQueCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49ZS54LXQueCxzPWUueS10Lnk7cmV0dXJuIE1hdGguYXRhbjIocyxuKX19c3RhdGljIGlzQWN1dGUodCxlLG4pe2NvbnN0IHM9dC54LWUueCxpPXQueS1lLnk7cmV0dXJuIHMqKG4ueC1lLngpK2kqKG4ueS1lLnkpPjB9c3RhdGljIGlzT2J0dXNlKHQsZSxuKXtjb25zdCBzPXQueC1lLngsaT10LnktZS55O3JldHVybiBzKihuLngtZS54KStpKihuLnktZS55KTwwfXN0YXRpYyBpbnRlcmlvckFuZ2xlKHQsZSxuKXtjb25zdCBzPWllLmFuZ2xlKGUsdCksaT1pZS5hbmdsZShlLG4pO3JldHVybiBNYXRoLmFicyhpLXMpfXN0YXRpYyBub3JtYWxpemVQb3NpdGl2ZSh0KXtpZih0PDApe2Zvcig7dDwwOyl0Kz1pZS5QSV9USU1FU18yO3Q+PWllLlBJX1RJTUVTXzImJih0PTApfWVsc2V7Zm9yKDt0Pj1pZS5QSV9USU1FU18yOyl0LT1pZS5QSV9USU1FU18yO3Q8MCYmKHQ9MCl9cmV0dXJuIHR9c3RhdGljIGFuZ2xlQmV0d2Vlbih0LGUsbil7Y29uc3Qgcz1pZS5hbmdsZShlLHQpLGk9aWUuYW5nbGUoZSxuKTtyZXR1cm4gaWUuZGlmZihzLGkpfXN0YXRpYyBkaWZmKHQsZSl7bGV0IG49bnVsbDtyZXR1cm4gbj10PGU/ZS10OnQtZSxuPk1hdGguUEkmJihuPTIqTWF0aC5QSS1uKSxufXN0YXRpYyB0b1JhZGlhbnModCl7cmV0dXJuIHQqTWF0aC5QSS8xODB9c3RhdGljIGdldFR1cm4odCxlKXtjb25zdCBuPU1hdGguc2luKGUtdCk7cmV0dXJuIG4+MD9pZS5DT1VOVEVSQ0xPQ0tXSVNFOm48MD9pZS5DTE9DS1dJU0U6aWUuTk9ORX1zdGF0aWMgYW5nbGVCZXR3ZWVuT3JpZW50ZWQodCxlLG4pe2NvbnN0IHM9aWUuYW5nbGUoZSx0KSxpPWllLmFuZ2xlKGUsbiktcztyZXR1cm4gaTw9LU1hdGguUEk/aStpZS5QSV9USU1FU18yOmk+TWF0aC5QST9pLWllLlBJX1RJTUVTXzI6aX1nZXRDbGFzcygpe3JldHVybiBpZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19aWUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxpZS5QSV9USU1FU18yPTIqTWF0aC5QSSxpZS5QSV9PVkVSXzI9TWF0aC5QSS8yLGllLlBJX09WRVJfND1NYXRoLlBJLzQsaWUuQ09VTlRFUkNMT0NLV0lTRT12LkNPVU5URVJDTE9DS1dJU0UsaWUuQ0xPQ0tXSVNFPXYuQ0xPQ0tXSVNFLGllLk5PTkU9di5DT0xMSU5FQVI7Y2xhc3MgcmV7Y29uc3RydWN0b3IoKXtyZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBhcmVhKHQsZSxuKXtyZXR1cm4gTWF0aC5hYnMoKChuLngtdC54KSooZS55LXQueSktKGUueC10LngpKihuLnktdC55KSkvMil9c3RhdGljIHNpZ25lZEFyZWEodCxlLG4pe3JldHVybigobi54LXQueCkqKGUueS10LnkpLShlLngtdC54KSoobi55LXQueSkpLzJ9c3RhdGljIGRldCh0LGUsbixzKXtyZXR1cm4gdCpzLWUqbn1zdGF0aWMgaW50ZXJwb2xhdGVaKHQsZSxuLHMpe2NvbnN0IGk9ZS54LHI9ZS55LG89bi54LWksbD1zLngtaSxhPW4ueS1yLGM9cy55LXIsaD1vKmMtbCphLHU9dC54LWksZz10LnktcixkPShjKnUtbCpnKS9oLF89KC1hKnUrbypnKS9oO3JldHVybiBlLnorZCoobi56LWUueikrXyoocy56LWUueil9c3RhdGljIGxvbmdlc3RTaWRlTGVuZ3RoKHQsZSxuKXtjb25zdCBzPXQuZGlzdGFuY2UoZSksaT1lLmRpc3RhbmNlKG4pLHI9bi5kaXN0YW5jZSh0KTtsZXQgbz1zO3JldHVybiBpPm8mJihvPWkpLHI+byYmKG89ciksb31zdGF0aWMgaXNBY3V0ZSh0LGUsbil7cmV0dXJuISFpZS5pc0FjdXRlKHQsZSxuKSYmKCEhaWUuaXNBY3V0ZShlLG4sdCkmJiEhaWUuaXNBY3V0ZShuLHQsZSkpfXN0YXRpYyBjaXJjdW1jZW50cmUodCxlLG4pe2NvbnN0IHM9bi54LGk9bi55LHI9dC54LXMsbz10LnktaSxsPWUueC1zLGE9ZS55LWksYz0yKnJlLmRldChyLG8sbCxhKSxoPXJlLmRldChvLHIqcitvKm8sYSxsKmwrYSphKSx1PXJlLmRldChyLHIqcitvKm8sbCxsKmwrYSphKTtyZXR1cm4gbmV3IGcocy1oL2MsaSt1L2MpfXN0YXRpYyBwZXJwZW5kaWN1bGFyQmlzZWN0b3IodCxlKXtjb25zdCBuPWUueC10Lngscz1lLnktdC55LGk9bmV3IGIodC54K24vMix0Lnkrcy8yLDEpLHI9bmV3IGIodC54LXMrbi8yLHQueStuK3MvMiwxKTtyZXR1cm4gbmV3IGIoaSxyKX1zdGF0aWMgYW5nbGVCaXNlY3Rvcih0LGUsbil7Y29uc3Qgcz1lLmRpc3RhbmNlKHQpLGk9cy8ocytlLmRpc3RhbmNlKG4pKSxyPW4ueC10Lngsbz1uLnktdC55O3JldHVybiBuZXcgZyh0LngraSpyLHQueStpKm8pfXN0YXRpYyBhcmVhM0QodCxlLG4pe2NvbnN0IHM9ZS54LXQueCxpPWUueS10Lnkscj1lLnotdC56LG89bi54LXQueCxsPW4ueS10LnksYT1uLnotdC56LGM9aSphLXIqbCxoPXIqby1zKmEsdT1zKmwtaSpvLGc9YypjK2gqaCt1KnU7cmV0dXJuIE1hdGguc3FydChnKS8yfXN0YXRpYyBjZW50cm9pZCh0LGUsbil7Y29uc3Qgcz0odC54K2UueCtuLngpLzMsaT0odC55K2UueStuLnkpLzM7cmV0dXJuIG5ldyBnKHMsaSl9c3RhdGljIGluQ2VudHJlKHQsZSxuKXtjb25zdCBzPWUuZGlzdGFuY2UobiksaT10LmRpc3RhbmNlKG4pLHI9dC5kaXN0YW5jZShlKSxvPXMraStyLGw9KHMqdC54K2kqZS54K3Iqbi54KS9vLGE9KHMqdC55K2kqZS55K3Iqbi55KS9vO3JldHVybiBuZXcgZyhsLGEpfWFyZWEoKXtyZXR1cm4gcmUuYXJlYSh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9c2lnbmVkQXJlYSgpe3JldHVybiByZS5zaWduZWRBcmVhKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX1pbnRlcnBvbGF0ZVoodCl7aWYobnVsbD09PXQpdGhyb3cgbmV3IG4oXCJTdXBwbGllZCBwb2ludCBpcyBudWxsLlwiKTtyZXR1cm4gcmUuaW50ZXJwb2xhdGVaKHQsdGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfWxvbmdlc3RTaWRlTGVuZ3RoKCl7cmV0dXJuIHJlLmxvbmdlc3RTaWRlTGVuZ3RoKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX1pc0FjdXRlKCl7cmV0dXJuIHJlLmlzQWN1dGUodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfWNpcmN1bWNlbnRyZSgpe3JldHVybiByZS5jaXJjdW1jZW50cmUodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfWFyZWEzRCgpe3JldHVybiByZS5hcmVhM0QodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfWNlbnRyb2lkKCl7cmV0dXJuIHJlLmNlbnRyb2lkKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX1pbkNlbnRyZSgpe3JldHVybiByZS5pbkNlbnRyZSh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9Z2V0Q2xhc3MoKXtyZXR1cm4gcmV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXJlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMucDA9bnVsbCx0aGlzLnAxPW51bGwsdGhpcy5wMj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMucDA9dCx0aGlzLnAxPWUsdGhpcy5wMj1ufTtjbGFzcyBvZSBleHRlbmRzIEN7Y29uc3RydWN0b3IoKXtzdXBlcigpLG9lLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q2xhc3MoKXtyZXR1cm4gb2V9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fW9lLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKUMuY29uc3RydWN0b3JfLmNhbGwodGhpcyk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Qy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfX07Y2xhc3MgbGV7Y29uc3RydWN0b3IoKXtsZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyB0cmFuc2xhdGlvbkluc3RhbmNlKHQsZSl7Y29uc3Qgbj1uZXcgbGU7cmV0dXJuIG4uc2V0VG9UcmFuc2xhdGlvbih0LGUpLG59c3RhdGljIHNoZWFySW5zdGFuY2UodCxlKXtjb25zdCBuPW5ldyBsZTtyZXR1cm4gbi5zZXRUb1NoZWFyKHQsZSksbn1zdGF0aWMgcmVmbGVjdGlvbkluc3RhbmNlKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IGxlO3JldHVybiBuLnNldFRvUmVmbGVjdGlvbih0LGUpLG59aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9bmV3IGxlO3JldHVybiBpLnNldFRvUmVmbGVjdGlvbih0LGUsbixzKSxpfX1zdGF0aWMgcm90YXRpb25JbnN0YW5jZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbGUucm90YXRpb25JbnN0YW5jZShNYXRoLnNpbih0KSxNYXRoLmNvcyh0KSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IGxlO3JldHVybiBuLnNldFRvUm90YXRpb24odCxlKSxufWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gbGUucm90YXRpb25JbnN0YW5jZShNYXRoLnNpbih0KSxNYXRoLmNvcyh0KSxlLG4pfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPW5ldyBsZTtyZXR1cm4gaS5zZXRUb1JvdGF0aW9uKHQsZSxuLHMpLGl9fXN0YXRpYyBzY2FsZUluc3RhbmNlKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IGxlO3JldHVybiBuLnNldFRvU2NhbGUodCxlKSxufWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPW5ldyBsZTtyZXR1cm4gaS50cmFuc2xhdGUoLW4sLXMpLGkuc2NhbGUodCxlKSxpLnRyYW5zbGF0ZShuLHMpLGl9fXNldFRvUmVmbGVjdGlvbkJhc2ljKHQsZSxzLGkpe2lmKHQ9PT1zJiZlPT09aSl0aHJvdyBuZXcgbihcIlJlZmxlY3Rpb24gbGluZSBwb2ludHMgbXVzdCBiZSBkaXN0aW5jdFwiKTtjb25zdCByPXMtdCxvPWktZSxsPU1hdGguc3FydChyKnIrbypvKSxhPW8vbCxjPXIvbCxoPTIqYSpjLHU9YypjLWEqYTtyZXR1cm4gdGhpcy5fbTAwPXUsdGhpcy5fbTAxPWgsdGhpcy5fbTAyPTAsdGhpcy5fbTEwPWgsdGhpcy5fbTExPS11LHRoaXMuX20xMj0wLHRoaXN9Z2V0SW52ZXJzZSgpe2NvbnN0IHQ9dGhpcy5nZXREZXRlcm1pbmFudCgpO2lmKDA9PT10KXRocm93IG5ldyBvZShcIlRyYW5zZm9ybWF0aW9uIGlzIG5vbi1pbnZlcnRpYmxlXCIpO2NvbnN0IGU9dGhpcy5fbTExL3Qsbj0tdGhpcy5fbTEwL3Qscz0tdGhpcy5fbTAxL3QsaT10aGlzLl9tMDAvdCxyPSh0aGlzLl9tMDEqdGhpcy5fbTEyLXRoaXMuX20wMip0aGlzLl9tMTEpL3Qsbz0oLXRoaXMuX20wMCp0aGlzLl9tMTIrdGhpcy5fbTEwKnRoaXMuX20wMikvdDtyZXR1cm4gbmV3IGxlKGUscyxyLG4saSxvKX1jb21wb3NlKHQpe2NvbnN0IGU9dC5fbTAwKnRoaXMuX20wMCt0Ll9tMDEqdGhpcy5fbTEwLG49dC5fbTAwKnRoaXMuX20wMSt0Ll9tMDEqdGhpcy5fbTExLHM9dC5fbTAwKnRoaXMuX20wMit0Ll9tMDEqdGhpcy5fbTEyK3QuX20wMixpPXQuX20xMCp0aGlzLl9tMDArdC5fbTExKnRoaXMuX20xMCxyPXQuX20xMCp0aGlzLl9tMDErdC5fbTExKnRoaXMuX20xMSxvPXQuX20xMCp0aGlzLl9tMDIrdC5fbTExKnRoaXMuX20xMit0Ll9tMTI7cmV0dXJuIHRoaXMuX20wMD1lLHRoaXMuX20wMT1uLHRoaXMuX20wMj1zLHRoaXMuX20xMD1pLHRoaXMuX20xMT1yLHRoaXMuX20xMj1vLHRoaXN9ZXF1YWxzKHQpe2lmKG51bGw9PT10KXJldHVybiExO2lmKCEodCBpbnN0YW5jZW9mIGxlKSlyZXR1cm4hMTtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuX20wMD09PWUuX20wMCYmdGhpcy5fbTAxPT09ZS5fbTAxJiZ0aGlzLl9tMDI9PT1lLl9tMDImJnRoaXMuX20xMD09PWUuX20xMCYmdGhpcy5fbTExPT09ZS5fbTExJiZ0aGlzLl9tMTI9PT1lLl9tMTJ9c2V0VG9TY2FsZSh0LGUpe3JldHVybiB0aGlzLl9tMDA9dCx0aGlzLl9tMDE9MCx0aGlzLl9tMDI9MCx0aGlzLl9tMTA9MCx0aGlzLl9tMTE9ZSx0aGlzLl9tMTI9MCx0aGlzfWlzSWRlbnRpdHkoKXtyZXR1cm4gMT09PXRoaXMuX20wMCYmMD09PXRoaXMuX20wMSYmMD09PXRoaXMuX20wMiYmMD09PXRoaXMuX20xMCYmMT09PXRoaXMuX20xMSYmMD09PXRoaXMuX20xMn1zY2FsZSh0LGUpe3JldHVybiB0aGlzLmNvbXBvc2UobGUuc2NhbGVJbnN0YW5jZSh0LGUpKSx0aGlzfXNldFRvSWRlbnRpdHkoKXtyZXR1cm4gdGhpcy5fbTAwPTEsdGhpcy5fbTAxPTAsdGhpcy5fbTAyPTAsdGhpcy5fbTEwPTAsdGhpcy5fbTExPTEsdGhpcy5fbTEyPTAsdGhpc31pc0dlb21ldHJ5Q2hhbmdlZCgpe3JldHVybiEwfXNldFRyYW5zZm9ybWF0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9tMDA9dC5fbTAwLHRoaXMuX20wMT10Ll9tMDEsdGhpcy5fbTAyPXQuX20wMix0aGlzLl9tMTA9dC5fbTEwLHRoaXMuX20xMT10Ll9tMTEsdGhpcy5fbTEyPXQuX20xMix0aGlzfWlmKDY9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWFyZ3VtZW50c1s0XSxyPWFyZ3VtZW50c1s1XTtyZXR1cm4gdGhpcy5fbTAwPXQsdGhpcy5fbTAxPWUsdGhpcy5fbTAyPW4sdGhpcy5fbTEwPXMsdGhpcy5fbTExPWksdGhpcy5fbTEyPXIsdGhpc319c2V0VG9Sb3RhdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZXRUb1JvdGF0aW9uKE1hdGguc2luKHQpLE1hdGguY29zKHQpKSx0aGlzfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5fbTAwPWUsdGhpcy5fbTAxPS10LHRoaXMuX20wMj0wLHRoaXMuX20xMD10LHRoaXMuX20xMT1lLHRoaXMuX20xMj0wLHRoaXN9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiB0aGlzLnNldFRvUm90YXRpb24oTWF0aC5zaW4odCksTWF0aC5jb3ModCksZSxuKSx0aGlzfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtyZXR1cm4gdGhpcy5fbTAwPWUsdGhpcy5fbTAxPS10LHRoaXMuX20wMj1uLW4qZStzKnQsdGhpcy5fbTEwPXQsdGhpcy5fbTExPWUsdGhpcy5fbTEyPXMtbip0LXMqZSx0aGlzfX1nZXRNYXRyaXhFbnRyaWVzKCl7cmV0dXJuW3RoaXMuX20wMCx0aGlzLl9tMDEsdGhpcy5fbTAyLHRoaXMuX20xMCx0aGlzLl9tMTEsdGhpcy5fbTEyXX1maWx0ZXIodCxlKXt0aGlzLnRyYW5zZm9ybSh0LGUpfXJvdGF0ZSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jb21wb3NlKGxlLnJvdGF0aW9uSW5zdGFuY2UodCkpLHRoaXN9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmNvbXBvc2UobGUucm90YXRpb25JbnN0YW5jZSh0LGUpKSx0aGlzfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gdGhpcy5jb21wb3NlKGxlLnJvdGF0aW9uSW5zdGFuY2UodCxlLG4pKSx0aGlzfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5jb21wb3NlKGxlLnJvdGF0aW9uSW5zdGFuY2UodCxlKSksdGhpc319Z2V0RGV0ZXJtaW5hbnQoKXtyZXR1cm4gdGhpcy5fbTAwKnRoaXMuX20xMS10aGlzLl9tMDEqdGhpcy5fbTEwfWNvbXBvc2VCZWZvcmUodCl7Y29uc3QgZT10aGlzLl9tMDAqdC5fbTAwK3RoaXMuX20wMSp0Ll9tMTAsbj10aGlzLl9tMDAqdC5fbTAxK3RoaXMuX20wMSp0Ll9tMTEscz10aGlzLl9tMDAqdC5fbTAyK3RoaXMuX20wMSp0Ll9tMTIrdGhpcy5fbTAyLGk9dGhpcy5fbTEwKnQuX20wMCt0aGlzLl9tMTEqdC5fbTEwLHI9dGhpcy5fbTEwKnQuX20wMSt0aGlzLl9tMTEqdC5fbTExLG89dGhpcy5fbTEwKnQuX20wMit0aGlzLl9tMTEqdC5fbTEyK3RoaXMuX20xMjtyZXR1cm4gdGhpcy5fbTAwPWUsdGhpcy5fbTAxPW4sdGhpcy5fbTAyPXMsdGhpcy5fbTEwPWksdGhpcy5fbTExPXIsdGhpcy5fbTEyPW8sdGhpc31zZXRUb1NoZWFyKHQsZSl7cmV0dXJuIHRoaXMuX20wMD0xLHRoaXMuX20wMT10LHRoaXMuX20wMj0wLHRoaXMuX20xMD1lLHRoaXMuX20xMT0xLHRoaXMuX20xMj0wLHRoaXN9aXNEb25lKCl7cmV0dXJuITF9Y2xvbmUoKXt0cnl7cmV0dXJuIG51bGx9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgQykpdGhyb3cgdDt1LnNob3VsZE5ldmVyUmVhY2hIZXJlKCl9cmV0dXJuIG51bGx9dHJhbnNsYXRlKHQsZSl7cmV0dXJuIHRoaXMuY29tcG9zZShsZS50cmFuc2xhdGlvbkluc3RhbmNlKHQsZSkpLHRoaXN9c2V0VG9SZWZsZWN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKDA9PT10JiYwPT09ZSl0aHJvdyBuZXcgbihcIlJlZmxlY3Rpb24gdmVjdG9yIG11c3QgYmUgbm9uLXplcm9cIik7aWYodD09PWUpcmV0dXJuIHRoaXMuX20wMD0wLHRoaXMuX20wMT0xLHRoaXMuX20wMj0wLHRoaXMuX20xMD0xLHRoaXMuX20xMT0wLHRoaXMuX20xMj0wLHRoaXM7Y29uc3Qgcz1NYXRoLnNxcnQodCp0K2UqZSksaT1lL3Mscj10L3M7cmV0dXJuIHRoaXMucm90YXRlKC1pLHIpLHRoaXMuc2NhbGUoMSwtMSksdGhpcy5yb3RhdGUoaSxyKSx0aGlzfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXSxpPWFyZ3VtZW50c1szXTtpZih0PT09cyYmZT09PWkpdGhyb3cgbmV3IG4oXCJSZWZsZWN0aW9uIGxpbmUgcG9pbnRzIG11c3QgYmUgZGlzdGluY3RcIik7dGhpcy5zZXRUb1RyYW5zbGF0aW9uKC10LC1lKTtjb25zdCByPXMtdCxvPWktZSxsPU1hdGguc3FydChyKnIrbypvKSxhPW8vbCxjPXIvbDtyZXR1cm4gdGhpcy5yb3RhdGUoLWEsYyksdGhpcy5zY2FsZSgxLC0xKSx0aGlzLnJvdGF0ZShhLGMpLHRoaXMudHJhbnNsYXRlKHQsZSksdGhpc319dG9TdHJpbmcoKXtyZXR1cm5cIkFmZmluZVRyYW5zZm9ybWF0aW9uW1tcIit0aGlzLl9tMDArXCIsIFwiK3RoaXMuX20wMStcIiwgXCIrdGhpcy5fbTAyK1wiXSwgW1wiK3RoaXMuX20xMCtcIiwgXCIrdGhpcy5fbTExK1wiLCBcIit0aGlzLl9tMTIrXCJdXVwifXNldFRvVHJhbnNsYXRpb24odCxlKXtyZXR1cm4gdGhpcy5fbTAwPTEsdGhpcy5fbTAxPTAsdGhpcy5fbTAyPXQsdGhpcy5fbTEwPTAsdGhpcy5fbTExPTEsdGhpcy5fbTEyPWUsdGhpc31zaGVhcih0LGUpe3JldHVybiB0aGlzLmNvbXBvc2UobGUuc2hlYXJJbnN0YW5jZSh0LGUpKSx0aGlzfXRyYW5zZm9ybSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXS5jb3B5KCk7cmV0dXJuIHQuYXBwbHkodGhpcyksdH1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dGhpcy5fbTAwKnQueCt0aGlzLl9tMDEqdC55K3RoaXMuX20wMixzPXRoaXMuX20xMCp0LngrdGhpcy5fbTExKnQueSt0aGlzLl9tMTI7cmV0dXJuIGUueD1uLGUueT1zLGV9aWYoXyhhcmd1bWVudHNbMF0sQSkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10aGlzLl9tMDAqdC5nZXRPcmRpbmF0ZShlLDApK3RoaXMuX20wMSp0LmdldE9yZGluYXRlKGUsMSkrdGhpcy5fbTAyLHM9dGhpcy5fbTEwKnQuZ2V0T3JkaW5hdGUoZSwwKSt0aGlzLl9tMTEqdC5nZXRPcmRpbmF0ZShlLDEpK3RoaXMuX20xMjt0LnNldE9yZGluYXRlKGUsMCxuKSx0LnNldE9yZGluYXRlKGUsMSxzKX19fXJlZmxlY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuY29tcG9zZShsZS5yZWZsZWN0aW9uSW5zdGFuY2UodCxlKSksdGhpc31pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107cmV0dXJuIHRoaXMuY29tcG9zZShsZS5yZWZsZWN0aW9uSW5zdGFuY2UodCxlLG4scykpLHRoaXN9fWdldENsYXNzKCl7cmV0dXJuIGxlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltvLGR0XX19bGUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fbTAwPW51bGwsdGhpcy5fbTAxPW51bGwsdGhpcy5fbTAyPW51bGwsdGhpcy5fbTEwPW51bGwsdGhpcy5fbTExPW51bGwsdGhpcy5fbTEyPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5zZXRUb0lkZW50aXR5KCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbTAwPXRbMF0sdGhpcy5fbTAxPXRbMV0sdGhpcy5fbTAyPXRbMl0sdGhpcy5fbTEwPXRbM10sdGhpcy5fbTExPXRbNF0sdGhpcy5fbTEyPXRbNV19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGxlKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldFRyYW5zZm9ybWF0aW9uKHQpfX1lbHNlIGlmKDY9PT1hcmd1bWVudHMubGVuZ3RoJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzVdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzRdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzNdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWFyZ3VtZW50c1s0XSxyPWFyZ3VtZW50c1s1XTt0aGlzLnNldFRyYW5zZm9ybWF0aW9uKHQsZSxuLHMsaSxyKX19O2NsYXNzIGFle2NvbnN0cnVjdG9yKCl7YWUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgc29sdmUodCxlKXtjb25zdCBzPWUubGVuZ3RoO2lmKHQubGVuZ3RoIT09c3x8dFswXS5sZW5ndGghPT1zKXRocm93IG5ldyBuKFwiTWF0cml4IEEgaXMgaW5jb3JyZWN0bHkgc2l6ZWRcIik7Zm9yKGxldCBuPTA7bjxzO24rKyl7bGV0IGk9bjtmb3IobGV0IGU9bisxO2U8cztlKyspTWF0aC5hYnModFtlXVtuXSk+TWF0aC5hYnModFtpXVtuXSkmJihpPWUpO2lmKDA9PT10W2ldW25dKXJldHVybiBudWxsO2FlLnN3YXBSb3dzKHQsbixpKSxhZS5zd2FwUm93cyhlLG4saSk7Zm9yKGxldCBpPW4rMTtpPHM7aSsrKXtjb25zdCByPXRbaV1bbl0vdFtuXVtuXTtmb3IobGV0IGU9cy0xO2U+PW47ZS0tKXRbaV1bZV0tPXRbbl1bZV0qcjtlW2ldLT1lW25dKnJ9fWNvbnN0IGk9bmV3IEFycmF5KHMpLmZpbGwobnVsbCk7Zm9yKGxldCBuPXMtMTtuPj0wO24tLSl7bGV0IHI9MDtmb3IobGV0IGU9bisxO2U8cztlKyspcis9dFtuXVtlXSppW2VdO2lbbl09KGVbbl0tcikvdFtuXVtuXX1yZXR1cm4gaX1zdGF0aWMgc3dhcFJvd3MoKXtpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1syXSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYoZT09PW4pcmV0dXJuIG51bGw7Zm9yKGxldCBzPTA7czx0WzBdLmxlbmd0aDtzKyspe2NvbnN0IGk9dFtlXVtzXTt0W2VdW3NdPXRbbl1bc10sdFtuXVtzXT1pfX1lbHNlIGlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzJdKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZihlPT09bilyZXR1cm4gbnVsbDtjb25zdCBzPXRbZV07dFtlXT10W25dLHRbbl09c319Z2V0Q2xhc3MoKXtyZXR1cm4gYWV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWFlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgY2V7Y29uc3RydWN0b3IoKXtjZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXNvbHZlKHQpe2NvbnN0IGU9W1t0aGlzLl9zcmMwLngsdGhpcy5fc3JjMC55LDFdLFt0aGlzLl9zcmMxLngsdGhpcy5fc3JjMS55LDFdLFt0aGlzLl9zcmMyLngsdGhpcy5fc3JjMi55LDFdXTtyZXR1cm4gYWUuc29sdmUoZSx0KX1jb21wdXRlKCl7Y29uc3QgdD1bdGhpcy5fZGVzdDAueCx0aGlzLl9kZXN0MS54LHRoaXMuX2Rlc3QyLnhdLGU9dGhpcy5zb2x2ZSh0KTtpZihudWxsPT09ZSlyZXR1cm4hMTt0aGlzLl9tMDA9ZVswXSx0aGlzLl9tMDE9ZVsxXSx0aGlzLl9tMDI9ZVsyXTtjb25zdCBuPVt0aGlzLl9kZXN0MC55LHRoaXMuX2Rlc3QxLnksdGhpcy5fZGVzdDIueV0scz10aGlzLnNvbHZlKG4pO3JldHVybiBudWxsIT09cyYmKHRoaXMuX20xMD1zWzBdLHRoaXMuX20xMT1zWzFdLHRoaXMuX20xMj1zWzJdLCEwKX1nZXRUcmFuc2Zvcm1hdGlvbigpe3JldHVybiB0aGlzLmNvbXB1dGUoKT9uZXcgbGUodGhpcy5fbTAwLHRoaXMuX20wMSx0aGlzLl9tMDIsdGhpcy5fbTEwLHRoaXMuX20xMSx0aGlzLl9tMTIpOm51bGx9Z2V0Q2xhc3MoKXtyZXR1cm4gY2V9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3NyYzA9bnVsbCx0aGlzLl9zcmMxPW51bGwsdGhpcy5fc3JjMj1udWxsLHRoaXMuX2Rlc3QwPW51bGwsdGhpcy5fZGVzdDE9bnVsbCx0aGlzLl9kZXN0Mj1udWxsLHRoaXMuX20wMD1udWxsLHRoaXMuX20wMT1udWxsLHRoaXMuX20wMj1udWxsLHRoaXMuX20xMD1udWxsLHRoaXMuX20xMT1udWxsLHRoaXMuX20xMj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLHI9YXJndW1lbnRzWzVdO3RoaXMuX3NyYzA9dCx0aGlzLl9zcmMxPWUsdGhpcy5fc3JjMj1uLHRoaXMuX2Rlc3QwPXMsdGhpcy5fZGVzdDE9aSx0aGlzLl9kZXN0Mj1yfTtjbGFzcyBoZXtjb25zdHJ1Y3Rvcigpe2hlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNyZWF0ZUZyb21CYXNlTGluZXModCxlLG4scyl7Y29uc3QgaT1uZXcgZyh0Lngrcy54LW4ueCx0Lnkrcy55LW4ueSkscj1pZS5hbmdsZUJldHdlZW5PcmllbnRlZChlLHQsaSksbz1lLmRpc3RhbmNlKHQpLGw9cy5kaXN0YW5jZShuKTtpZigwPT09bylyZXR1cm4gbmV3IGxlO2NvbnN0IGE9bC9vLGM9bGUudHJhbnNsYXRpb25JbnN0YW5jZSgtdC54LC10LnkpO3JldHVybiBjLnJvdGF0ZShyKSxjLnNjYWxlKGEsYSksYy50cmFuc2xhdGUobi54LG4ueSksY31zdGF0aWMgY3JlYXRlRnJvbUNvbnRyb2xWZWN0b3JzKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWUueC10Lngscz1lLnktdC55O3JldHVybiBsZS50cmFuc2xhdGlvbkluc3RhbmNlKG4scyl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgbihcIlNyYyBhbmQgRGVzdCBhcnJheXMgYXJlIG5vdCB0aGUgc2FtZSBsZW5ndGhcIik7aWYodC5sZW5ndGg8PTApdGhyb3cgbmV3IG4oXCJUb28gZmV3IGNvbnRyb2wgcG9pbnRzXCIpO2lmKHQubGVuZ3RoPjMpdGhyb3cgbmV3IG4oXCJUb28gbWFueSBjb250cm9sIHBvaW50c1wiKTtyZXR1cm4gMT09PXQubGVuZ3RoP2hlLmNyZWF0ZUZyb21Db250cm9sVmVjdG9ycyh0WzBdLGVbMF0pOjI9PT10Lmxlbmd0aD9oZS5jcmVhdGVGcm9tQ29udHJvbFZlY3RvcnModFswXSx0WzFdLGVbMF0sZVsxXSk6aGUuY3JlYXRlRnJvbUNvbnRyb2xWZWN0b3JzKHRbMF0sdFsxXSx0WzJdLGVbMF0sZVsxXSxlWzJdKX19ZWxzZXtpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1uZXcgZyhzLngtbi54LHMueS1uLnkpLHI9aWUuYW5nbGVCZXR3ZWVuT3JpZW50ZWQoZSx0LGkpLG89ZS5kaXN0YW5jZSh0KSxsPXMuZGlzdGFuY2Uobik7aWYoMD09PW8pcmV0dXJuIG51bGw7Y29uc3QgYT1sL28sYz1sZS50cmFuc2xhdGlvbkluc3RhbmNlKC10LngsLXQueSk7cmV0dXJuIGMucm90YXRlKHIpLGMuc2NhbGUoYSxhKSxjLnRyYW5zbGF0ZShuLngsbi55KSxjfWlmKDY9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPWFyZ3VtZW50c1s0XSxyPWFyZ3VtZW50c1s1XTtyZXR1cm4gbmV3IGNlKHQsZSxuLHMsaSxyKS5nZXRUcmFuc2Zvcm1hdGlvbigpfX19Z2V0Q2xhc3MoKXtyZXR1cm4gaGV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWhlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgdWV7Y29uc3RydWN0b3IoKXt1ZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBnZXRDb29yZGluYXRlcyh0KXtjb25zdCBlPW5ldyB4O3JldHVybiB0LmFwcGx5KG5ldyB1ZShlKSksZX1maWx0ZXIodCl7KHQgaW5zdGFuY2VvZiBUdHx8dCBpbnN0YW5jZW9mIFB0KSYmdGhpcy5fY29vcmRzLmFkZCh0LmdldENvb3JkaW5hdGUoKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gdWV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0ddfX11ZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9jb29yZHM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9jb29yZHM9dH07Y2xhc3MgZ2V7Y29uc3RydWN0b3IoKXtnZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBtYXAodCxlKXtyZXR1cm4gbmV3IGdlKGUpLm1hcCh0KX1tYXAodCl7Y29uc3QgZT1uZXcgeDtmb3IobGV0IG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7Y29uc3Qgcz10aGlzLl9tYXBPcC5tYXAodC5nZXRHZW9tZXRyeU4obikpO3MuaXNFbXB0eSgpfHxlLmFkZChzKX1yZXR1cm4gdC5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKEh0LnRvR2VvbWV0cnlBcnJheShlKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gZ2V9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWdlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX21hcE9wPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbWFwT3A9dH07Y2xhc3MgZGV7Y29uc3RydWN0b3IoKXtkZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb21iaW5lKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgZGUodCkuY29tYmluZSgpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IGRlKGRlLmNyZWF0ZUxpc3QodCxlKSkuY29tYmluZSgpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gbmV3IGRlKGRlLmNyZWF0ZUxpc3QodCxlLG4pKS5jb21iaW5lKCl9fXN0YXRpYyBleHRyYWN0RmFjdG9yeSh0KXtyZXR1cm4gdC5pc0VtcHR5KCk/bnVsbDp0Lml0ZXJhdG9yKCkubmV4dCgpLmdldEZhY3RvcnkoKX1zdGF0aWMgY3JlYXRlTGlzdCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyB4O3JldHVybiBuLmFkZCh0KSxuLmFkZChlKSxufWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPW5ldyB4O3JldHVybiBzLmFkZCh0KSxzLmFkZChlKSxzLmFkZChuKSxzfX1leHRyYWN0RWxlbWVudHModCxlKXtpZihudWxsPT09dClyZXR1cm4gbnVsbDtmb3IobGV0IG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7Y29uc3Qgcz10LmdldEdlb21ldHJ5TihuKTt0aGlzLl9za2lwRW1wdHkmJnMuaXNFbXB0eSgpfHxlLmFkZChzKX19Y29tYmluZSgpe2NvbnN0IHQ9bmV3IHg7Zm9yKGxldCBlPXRoaXMuX2lucHV0R2VvbXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dGhpcy5leHRyYWN0RWxlbWVudHMobix0KX1yZXR1cm4gMD09PXQuc2l6ZSgpP251bGwhPT10aGlzLl9nZW9tRmFjdG9yeT90aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKTpudWxsOnRoaXMuX2dlb21GYWN0b3J5LmJ1aWxkR2VvbWV0cnkodCl9Z2V0Q2xhc3MoKXtyZXR1cm4gZGV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWRlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2dlb21GYWN0b3J5PW51bGwsdGhpcy5fc2tpcEVtcHR5PSExLHRoaXMuX2lucHV0R2VvbXM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tRmFjdG9yeT1kZS5leHRyYWN0RmFjdG9yeSh0KSx0aGlzLl9pbnB1dEdlb21zPXR9O2NsYXNzIF9le2NvbnN0cnVjdG9yKCl7X2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaXNPZlR5cGUodCxlKXtyZXR1cm4gdC5nZXRHZW9tZXRyeVR5cGUoKT09PWV8fGU9PT1xLlRZUEVOQU1FX0xJTkVTVFJJTkcmJnQuZ2V0R2VvbWV0cnlUeXBlKCk9PT1xLlRZUEVOQU1FX0xJTkVBUlJJTkd9c3RhdGljIGV4dHJhY3QoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIF9lLmV4dHJhY3QodCxlLG5ldyB4KX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXyhhcmd1bWVudHNbMl0sbSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSYmXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIHQuZ2V0R2VvbWV0cnlUeXBlKCk9PT1lP24uYWRkKHQpOnQgaW5zdGFuY2VvZiBfdCYmdC5hcHBseShuZXcgX2UoZSxuKSksbn1pZihfKGFyZ3VtZW50c1syXSxtKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIENsYXNzKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gX2UuZXh0cmFjdCh0LF9lLnRvR2VvbWV0cnlUeXBlKGUpLG4pfX19ZmlsdGVyKHQpeyhudWxsPT09dGhpcy5fZ2VvbWV0cnlUeXBlfHxfZS5pc09mVHlwZSh0LHRoaXMuX2dlb21ldHJ5VHlwZSkpJiZ0aGlzLl9jb21wcy5hZGQodCl9Z2V0Q2xhc3MoKXtyZXR1cm4gX2V9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2d0XX19X2UuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZ2VvbWV0cnlUeXBlPW51bGwsdGhpcy5fY29tcHM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9nZW9tZXRyeVR5cGU9dCx0aGlzLl9jb21wcz1lfTtjbGFzcyBmZXtjb25zdHJ1Y3Rvcigpe2ZlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9bWFwKHQpe31nZXRDbGFzcygpe3JldHVybiBmZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZmUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBwZXtjb25zdHJ1Y3Rvcigpe3BlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIG1hcCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSYmXyhhcmd1bWVudHNbMV0sZmUpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyB4O2ZvcihsZXQgcz0wO3M8dC5nZXROdW1HZW9tZXRyaWVzKCk7cysrKXtjb25zdCBpPWUubWFwKHQuZ2V0R2VvbWV0cnlOKHMpKTtudWxsIT09aSYmbi5hZGQoaSl9cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmJ1aWxkR2VvbWV0cnkobil9aWYoXyhhcmd1bWVudHNbMF0sZikmJl8oYXJndW1lbnRzWzFdLGZlKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgeDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKSxpPWUubWFwKHQpO251bGwhPT1pJiZuLmFkZChpKX1yZXR1cm4gbn19Z2V0Q2xhc3MoKXtyZXR1cm4gcGV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXBlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgbWV7Y29uc3RydWN0b3IoKXttZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXRyYW5zZm9ybVBvaW50KHQsZSl7cmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9pbnQodGhpcy50cmFuc2Zvcm1Db29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpKX10cmFuc2Zvcm1Qb2x5Z29uKHQsZSl7bGV0IG49ITA7Y29uc3Qgcz10aGlzLnRyYW5zZm9ybUxpbmVhclJpbmcodC5nZXRFeHRlcmlvclJpbmcoKSx0KTtudWxsIT09cyYmcyBpbnN0YW5jZW9mIER0JiYhcy5pc0VtcHR5KCl8fChuPSExKTtjb25zdCBpPW5ldyB4O2ZvcihsZXQgZT0wO2U8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspe2NvbnN0IHM9dGhpcy50cmFuc2Zvcm1MaW5lYXJSaW5nKHQuZ2V0SW50ZXJpb3JSaW5nTihlKSx0KTtudWxsPT09c3x8cy5pc0VtcHR5KCl8fChzIGluc3RhbmNlb2YgRHR8fChuPSExKSxpLmFkZChzKSl9aWYobilyZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2x5Z29uKHMsaS50b0FycmF5KFtdKSk7e2NvbnN0IHQ9bmV3IHg7cmV0dXJuIG51bGwhPT1zJiZ0LmFkZChzKSx0LmFkZEFsbChpKSx0aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkodCl9fWNyZWF0ZUNvb3JkaW5hdGVTZXF1ZW5jZSh0KXtyZXR1cm4gdGhpcy5fZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHQpfWdldElucHV0R2VvbWV0cnkoKXtyZXR1cm4gdGhpcy5faW5wdXRHZW9tfXRyYW5zZm9ybU11bHRpTGluZVN0cmluZyh0LGUpe2NvbnN0IG49bmV3IHg7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IHM9dGhpcy50cmFuc2Zvcm1MaW5lU3RyaW5nKHQuZ2V0R2VvbWV0cnlOKGUpLHQpO251bGwhPT1zJiYocy5pc0VtcHR5KCl8fG4uYWRkKHMpKX1yZXR1cm4gdGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KG4pfXRyYW5zZm9ybUNvb3JkaW5hdGVzKHQsZSl7cmV0dXJuIHRoaXMuY29weSh0KX10cmFuc2Zvcm1MaW5lU3RyaW5nKHQsZSl7cmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0aGlzLnRyYW5zZm9ybUNvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCkpfXRyYW5zZm9ybU11bHRpUG9pbnQodCxlKXtjb25zdCBuPW5ldyB4O2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBzPXRoaXMudHJhbnNmb3JtUG9pbnQodC5nZXRHZW9tZXRyeU4oZSksdCk7bnVsbCE9PXMmJihzLmlzRW1wdHkoKXx8bi5hZGQocykpfXJldHVybiB0aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkobil9dHJhbnNmb3JtTXVsdGlQb2x5Z29uKHQsZSl7Y29uc3Qgbj1uZXcgeDtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgcz10aGlzLnRyYW5zZm9ybVBvbHlnb24odC5nZXRHZW9tZXRyeU4oZSksdCk7bnVsbCE9PXMmJihzLmlzRW1wdHkoKXx8bi5hZGQocykpfXJldHVybiB0aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkobil9Y29weSh0KXtyZXR1cm4gdC5jb3B5KCl9dHJhbnNmb3JtR2VvbWV0cnlDb2xsZWN0aW9uKHQsZSl7Y29uc3Qgbj1uZXcgeDtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgcz10aGlzLnRyYW5zZm9ybSh0LmdldEdlb21ldHJ5TihlKSk7bnVsbCE9PXMmJih0aGlzLl9wcnVuZUVtcHR5R2VvbWV0cnkmJnMuaXNFbXB0eSgpfHxuLmFkZChzKSl9cmV0dXJuIHRoaXMuX3ByZXNlcnZlR2VvbWV0cnlDb2xsZWN0aW9uVHlwZT90aGlzLl9mYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihIdC50b0dlb21ldHJ5QXJyYXkobikpOnRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeShuKX10cmFuc2Zvcm0odCl7aWYodGhpcy5faW5wdXRHZW9tPXQsdGhpcy5fZmFjdG9yeT10LmdldEZhY3RvcnkoKSx0IGluc3RhbmNlb2YgUHQpcmV0dXJuIHRoaXMudHJhbnNmb3JtUG9pbnQodCxudWxsKTtpZih0IGluc3RhbmNlb2YgTXQpcmV0dXJuIHRoaXMudHJhbnNmb3JtTXVsdGlQb2ludCh0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBEdClyZXR1cm4gdGhpcy50cmFuc2Zvcm1MaW5lYXJSaW5nKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIFR0KXJldHVybiB0aGlzLnRyYW5zZm9ybUxpbmVTdHJpbmcodCxudWxsKTtpZih0IGluc3RhbmNlb2YgZnQpcmV0dXJuIHRoaXMudHJhbnNmb3JtTXVsdGlMaW5lU3RyaW5nKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIGJ0KXJldHVybiB0aGlzLnRyYW5zZm9ybVBvbHlnb24odCxudWxsKTtpZih0IGluc3RhbmNlb2YgQXQpcmV0dXJuIHRoaXMudHJhbnNmb3JtTXVsdGlQb2x5Z29uKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIF90KXJldHVybiB0aGlzLnRyYW5zZm9ybUdlb21ldHJ5Q29sbGVjdGlvbih0LG51bGwpO3Rocm93IG5ldyBuKFwiVW5rbm93biBHZW9tZXRyeSBzdWJ0eXBlOiBcIit0LmdldENsYXNzKCkuZ2V0TmFtZSgpKX10cmFuc2Zvcm1MaW5lYXJSaW5nKHQsZSl7Y29uc3Qgbj10aGlzLnRyYW5zZm9ybUNvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCk7aWYobnVsbD09PW4pcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhudWxsKTtjb25zdCBzPW4uc2l6ZSgpO3JldHVybiBzPjAmJnM8NCYmIXRoaXMuX3ByZXNlcnZlVHlwZT90aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcobik6dGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKG4pfWdldENsYXNzKCl7cmV0dXJuIG1lfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1tZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9mYWN0b3J5PW51bGwsdGhpcy5fcHJ1bmVFbXB0eUdlb21ldHJ5PSEwLHRoaXMuX3ByZXNlcnZlR2VvbWV0cnlDb2xsZWN0aW9uVHlwZT0hMCx0aGlzLl9wcmVzZXJ2ZUNvbGxlY3Rpb25zPSExLHRoaXMuX3ByZXNlcnZlVHlwZT0hMX07Y2xhc3MgeWV7Y29uc3RydWN0b3IoKXt5ZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBnZXRHZW9tZXRyeSh0KXtyZXR1cm4gdC5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeSh5ZS5nZXRMaW5lcyh0KSl9c3RhdGljIGdldExpbmVzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB5ZS5nZXRMaW5lcyh0LG5ldyB4KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHQgaW5zdGFuY2VvZiBUdD9lLmFkZCh0KTp0IGluc3RhbmNlb2YgX3QmJnQuYXBwbHkobmV3IHllKGUpKSxlfX1maWx0ZXIodCl7dCBpbnN0YW5jZW9mIFR0JiZ0aGlzLl9jb21wcy5hZGQodCl9Z2V0Q2xhc3MoKXtyZXR1cm4geWV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2d0XX19eWUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fY29tcHM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9jb21wcz10fTtjbGFzcyB4ZXtjb25zdHJ1Y3Rvcigpe3hlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGdldEdlb21ldHJ5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0LmdldEZhY3RvcnkoKS5idWlsZEdlb21ldHJ5KHhlLmdldExpbmVzKHQpKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmJ1aWxkR2VvbWV0cnkoeGUuZ2V0TGluZXModCxlKSl9fXN0YXRpYyBnZXRMaW5lcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4geGUuZ2V0TGluZXModCwhMSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKF8oYXJndW1lbnRzWzBdLGYpJiZfKGFyZ3VtZW50c1sxXSxmKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7eGUuZ2V0TGluZXModCxlKX1yZXR1cm4gZX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEmJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyB4O3JldHVybiB0LmFwcGx5KG5ldyB4ZShuLGUpKSxufWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSYmXyhhcmd1bWVudHNbMV0sZikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0IGluc3RhbmNlb2YgVHQ/ZS5hZGQodCk6dC5hcHBseShuZXcgeGUoZSkpLGV9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZfKGFyZ3VtZW50c1swXSxmKSYmXyhhcmd1bWVudHNbMV0sZikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO3hlLmdldExpbmVzKHQsZSxuKX1yZXR1cm4gZX1pZihcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxJiZfKGFyZ3VtZW50c1sxXSxmKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIHQuYXBwbHkobmV3IHhlKGUsbikpLGV9fX1maWx0ZXIodCl7aWYodGhpcy5faXNGb3JjZWRUb0xpbmVTdHJpbmcmJnQgaW5zdGFuY2VvZiBEdCl7Y29uc3QgZT10LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpO3JldHVybiB0aGlzLl9saW5lcy5hZGQoZSksbnVsbH10IGluc3RhbmNlb2YgVHQmJnRoaXMuX2xpbmVzLmFkZCh0KX1zZXRGb3JjZVRvTGluZVN0cmluZyh0KXt0aGlzLl9pc0ZvcmNlZFRvTGluZVN0cmluZz10fWdldENsYXNzKCl7cmV0dXJuIHhlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltHXX19eGUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fbGluZXM9bnVsbCx0aGlzLl9pc0ZvcmNlZFRvTGluZVN0cmluZz0hMSwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZXM9dH1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9saW5lcz10LHRoaXMuX2lzRm9yY2VkVG9MaW5lU3RyaW5nPWV9fTtjb25zdCBFZT17cmV2ZXJzZU9yZGVyOmZ1bmN0aW9uKCl7cmV0dXJue2NvbXBhcmU6KHQsZSk9PmUuY29tcGFyZVRvKHQpfX0sbWluOmZ1bmN0aW9uKHQpe3JldHVybiBFZS5zb3J0KHQpLHQuZ2V0KDApfSxzb3J0OmZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj10LnRvQXJyYXkoKTtlP2h0LnNvcnQobixlKTpodC5zb3J0KG4pO2NvbnN0IHM9dC5pdGVyYXRvcigpO2ZvcihsZXQgdD0wLGU9bi5sZW5ndGg7dDxlO3QrKylzLm5leHQoKSxzLnNldChuW3RdKX0sc2luZ2xldG9uTGlzdDpmdW5jdGlvbih0KXtjb25zdCBlPW5ldyB4O3JldHVybiBlLmFkZCh0KSxlfX07Y2xhc3MgSWV7Y29uc3RydWN0b3IoKXtJZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBnZXRQb2ludHMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHQgaW5zdGFuY2VvZiBQdD9FZS5zaW5nbGV0b25MaXN0KHQpOkllLmdldFBvaW50cyh0LG5ldyB4KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHQgaW5zdGFuY2VvZiBQdD9lLmFkZCh0KTp0IGluc3RhbmNlb2YgX3QmJnQuYXBwbHkobmV3IEllKGUpKSxlfX1maWx0ZXIodCl7dCBpbnN0YW5jZW9mIFB0JiZ0aGlzLl9wdHMuYWRkKHQpfWdldENsYXNzKCl7cmV0dXJuIEllfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltndF19fUllLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3B0cz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3B0cz10fTtjbGFzcyBOZXtjb25zdHJ1Y3Rvcigpe05lLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGdldFBvbHlnb25zKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBOZS5nZXRQb2x5Z29ucyh0LG5ldyB4KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHQgaW5zdGFuY2VvZiBidD9lLmFkZCh0KTp0IGluc3RhbmNlb2YgX3QmJnQuYXBwbHkobmV3IE5lKGUpKSxlfX1maWx0ZXIodCl7dCBpbnN0YW5jZW9mIGJ0JiZ0aGlzLl9jb21wcy5hZGQodCl9Z2V0Q2xhc3MoKXtyZXR1cm4gTmV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2d0XX19TmUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fY29tcHM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9jb21wcz10fTtjbGFzcyBDZXtjb25zdHJ1Y3Rvcigpe0NlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9YXBwbHlUbyh0KXtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpJiYhdGhpcy5faXNEb25lO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTtpZihuIGluc3RhbmNlb2YgX3QpdGhpcy5hcHBseVRvKG4pO2Vsc2UgaWYodGhpcy52aXNpdChuKSx0aGlzLmlzRG9uZSgpKXJldHVybiB0aGlzLl9pc0RvbmU9ITAsbnVsbH19Z2V0Q2xhc3MoKXtyZXR1cm4gQ2V9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUNlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2lzRG9uZT0hMX07Y2xhc3MgU2V7Y29uc3RydWN0b3IoKXtTZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNyZWF0ZVN1cGVyY2lyY2xlKHQpe2NvbnN0IGU9MS90LG49dGhpcy5fZGltLmdldE1pblNpemUoKS8yLHM9dGhpcy5fZGltLmdldENlbnRyZSgpLGk9TWF0aC5wb3cobix0KSxyPW4sbz1NYXRoLnBvdyhpLzIsZSksbD1NYXRoLnRydW5jKHRoaXMuX25QdHMvOCksYT1uZXcgQXJyYXkoOCpsKzEpLmZpbGwobnVsbCksYz1vL2w7Zm9yKGxldCBuPTA7bjw9bDtuKyspe2xldCBvPTAsaD1yO2lmKDAhPT1uKXtvPWMqbjtjb25zdCBzPU1hdGgucG93KG8sdCk7aD1NYXRoLnBvdyhpLXMsZSl9YVtuXT10aGlzLmNvb3JkVHJhbnMobyxoLHMpLGFbMipsLW5dPXRoaXMuY29vcmRUcmFucyhoLG8scyksYVsyKmwrbl09dGhpcy5jb29yZFRyYW5zKGgsLW8scyksYVs0Kmwtbl09dGhpcy5jb29yZFRyYW5zKG8sLWgscyksYVs0Kmwrbl09dGhpcy5jb29yZFRyYW5zKC1vLC1oLHMpLGFbNipsLW5dPXRoaXMuY29vcmRUcmFucygtaCwtbyxzKSxhWzYqbCtuXT10aGlzLmNvb3JkVHJhbnMoLWgsbyxzKSxhWzgqbC1uXT10aGlzLmNvb3JkVHJhbnMoLW8saCxzKX1hW2EubGVuZ3RoLTFdPW5ldyBnKGFbMF0pO2NvbnN0IGg9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlTGluZWFyUmluZyhhKSx1PXRoaXMuX2dlb21GYWN0LmNyZWF0ZVBvbHlnb24oaCk7cmV0dXJuIHRoaXMucm90YXRlKHUpfXNldE51bVBvaW50cyh0KXt0aGlzLl9uUHRzPXR9c2V0QmFzZSh0KXt0aGlzLl9kaW0uc2V0QmFzZSh0KX1zZXRSb3RhdGlvbih0KXt0aGlzLl9yb3RhdGlvbkFuZ2xlPXR9c2V0V2lkdGgodCl7dGhpcy5fZGltLnNldFdpZHRoKHQpfWNyZWF0ZUVsbGlwc2UoKXtjb25zdCB0PXRoaXMuX2RpbS5nZXRFbnZlbG9wZSgpLGU9dC5nZXRXaWR0aCgpLzIsbj10LmdldEhlaWdodCgpLzIscz10LmdldE1pblgoKStlLGk9dC5nZXRNaW5ZKCkrbixyPW5ldyBBcnJheSh0aGlzLl9uUHRzKzEpLmZpbGwobnVsbCk7bGV0IG89MDtmb3IobGV0IHQ9MDt0PHRoaXMuX25QdHM7dCsrKXtjb25zdCBsPXQqKDIqTWF0aC5QSS90aGlzLl9uUHRzKSxhPWUqTWF0aC5jb3MobCkrcyxjPW4qTWF0aC5zaW4obCkraTtyW28rK109dGhpcy5jb29yZChhLGMpfXJbb109bmV3IGcoclswXSk7Y29uc3QgbD10aGlzLl9nZW9tRmFjdC5jcmVhdGVMaW5lYXJSaW5nKHIpLGE9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9seWdvbihsKTtyZXR1cm4gdGhpcy5yb3RhdGUoYSl9Y29vcmRUcmFucyh0LGUsbil7cmV0dXJuIHRoaXMuY29vcmQodCtuLngsZStuLnkpfWNyZWF0ZVNxdWlyY2xlKCl7cmV0dXJuIHRoaXMuY3JlYXRlU3VwZXJjaXJjbGUoNCl9c2V0RW52ZWxvcGUodCl7dGhpcy5fZGltLnNldEVudmVsb3BlKHQpfXNldENlbnRyZSh0KXt0aGlzLl9kaW0uc2V0Q2VudHJlKHQpfWNyZWF0ZUFyYyh0LGUpe2NvbnN0IG49dGhpcy5fZGltLmdldEVudmVsb3BlKCkscz1uLmdldFdpZHRoKCkvMixpPW4uZ2V0SGVpZ2h0KCkvMixyPW4uZ2V0TWluWCgpK3Msbz1uLmdldE1pblkoKStpO2xldCBsPWU7KGw8PTB8fGw+MipNYXRoLlBJKSYmKGw9MipNYXRoLlBJKTtjb25zdCBhPWwvKHRoaXMuX25QdHMtMSksYz1uZXcgQXJyYXkodGhpcy5fblB0cykuZmlsbChudWxsKTtsZXQgaD0wO2ZvcihsZXQgZT0wO2U8dGhpcy5fblB0cztlKyspe2NvbnN0IG49dCtlKmEsbD1zKk1hdGguY29zKG4pK3IsdT1pKk1hdGguc2luKG4pK287Y1toKytdPXRoaXMuY29vcmQobCx1KX1jb25zdCB1PXRoaXMuX2dlb21GYWN0LmNyZWF0ZUxpbmVTdHJpbmcoYyk7cmV0dXJuIHRoaXMucm90YXRlKHUpfXJvdGF0ZSh0KXtpZigwIT09dGhpcy5fcm90YXRpb25BbmdsZSl7Y29uc3QgZT1sZS5yb3RhdGlvbkluc3RhbmNlKHRoaXMuX3JvdGF0aW9uQW5nbGUsdGhpcy5fZGltLmdldENlbnRyZSgpLngsdGhpcy5fZGltLmdldENlbnRyZSgpLnkpO3QuYXBwbHkoZSl9cmV0dXJuIHR9Y29vcmQodCxlKXtjb25zdCBuPW5ldyBnKHQsZSk7cmV0dXJuIHRoaXMuX3ByZWNNb2RlbC5tYWtlUHJlY2lzZShuKSxufWNyZWF0ZUFyY1BvbHlnb24odCxlKXtjb25zdCBuPXRoaXMuX2RpbS5nZXRFbnZlbG9wZSgpLHM9bi5nZXRXaWR0aCgpLzIsaT1uLmdldEhlaWdodCgpLzIscj1uLmdldE1pblgoKStzLG89bi5nZXRNaW5ZKCkraTtsZXQgbD1lOyhsPD0wfHxsPjIqTWF0aC5QSSkmJihsPTIqTWF0aC5QSSk7Y29uc3QgYT1sLyh0aGlzLl9uUHRzLTEpLGM9bmV3IEFycmF5KHRoaXMuX25QdHMrMikuZmlsbChudWxsKTtsZXQgaD0wO2NbaCsrXT10aGlzLmNvb3JkKHIsbyk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9uUHRzO2UrKyl7Y29uc3Qgbj10K2EqZSxsPXMqTWF0aC5jb3Mobikrcix1PWkqTWF0aC5zaW4obikrbztjW2grK109dGhpcy5jb29yZChsLHUpfWNbaCsrXT10aGlzLmNvb3JkKHIsbyk7Y29uc3QgdT10aGlzLl9nZW9tRmFjdC5jcmVhdGVMaW5lYXJSaW5nKGMpLGc9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9seWdvbih1KTtyZXR1cm4gdGhpcy5yb3RhdGUoZyl9Y3JlYXRlUmVjdGFuZ2xlKCl7bGV0IHQ9bnVsbCxlPTAsbj1NYXRoLnRydW5jKHRoaXMuX25QdHMvNCk7bjwxJiYobj0xKTtjb25zdCBzPXRoaXMuX2RpbS5nZXRFbnZlbG9wZSgpLmdldFdpZHRoKCkvbixpPXRoaXMuX2RpbS5nZXRFbnZlbG9wZSgpLmdldEhlaWdodCgpL24scj1uZXcgQXJyYXkoNCpuKzEpLmZpbGwobnVsbCksbz10aGlzLl9kaW0uZ2V0RW52ZWxvcGUoKTtmb3IodD0wO3Q8bjt0Kyspe2NvbnN0IG49by5nZXRNaW5YKCkrdCpzLGk9by5nZXRNaW5ZKCk7cltlKytdPXRoaXMuY29vcmQobixpKX1mb3IodD0wO3Q8bjt0Kyspe2NvbnN0IG49by5nZXRNYXhYKCkscz1vLmdldE1pblkoKSt0Kmk7cltlKytdPXRoaXMuY29vcmQobixzKX1mb3IodD0wO3Q8bjt0Kyspe2NvbnN0IG49by5nZXRNYXhYKCktdCpzLGk9by5nZXRNYXhZKCk7cltlKytdPXRoaXMuY29vcmQobixpKX1mb3IodD0wO3Q8bjt0Kyspe2NvbnN0IG49by5nZXRNaW5YKCkscz1vLmdldE1heFkoKS10Kmk7cltlKytdPXRoaXMuY29vcmQobixzKX1yW2UrK109bmV3IGcoclswXSk7Y29uc3QgbD10aGlzLl9nZW9tRmFjdC5jcmVhdGVMaW5lYXJSaW5nKHIpLGE9dGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9seWdvbihsKTtyZXR1cm4gdGhpcy5yb3RhdGUoYSl9Y3JlYXRlQ2lyY2xlKCl7cmV0dXJuIHRoaXMuY3JlYXRlRWxsaXBzZSgpfXNldEhlaWdodCh0KXt0aGlzLl9kaW0uc2V0SGVpZ2h0KHQpfXNldFNpemUodCl7dGhpcy5fZGltLnNldFNpemUodCl9Z2V0Q2xhc3MoKXtyZXR1cm4gU2V9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIHdle2NvbnN0cnVjdG9yKCl7d2UuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zZXRCYXNlKHQpe3RoaXMuYmFzZT10fXNldFdpZHRoKHQpe3RoaXMud2lkdGg9dH1nZXRCYXNlKCl7cmV0dXJuIHRoaXMuYmFzZX1nZXRXaWR0aCgpe3JldHVybiB0aGlzLndpZHRofXNldEVudmVsb3BlKHQpe3RoaXMud2lkdGg9dC5nZXRXaWR0aCgpLHRoaXMuaGVpZ2h0PXQuZ2V0SGVpZ2h0KCksdGhpcy5iYXNlPW5ldyBnKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKSx0aGlzLmNlbnRyZT1uZXcgZyh0LmNlbnRyZSgpKX1zZXRDZW50cmUodCl7dGhpcy5jZW50cmU9dH1nZXRNaW5TaXplKCl7cmV0dXJuIE1hdGgubWluKHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpfWdldEVudmVsb3BlKCl7cmV0dXJuIG51bGwhPT10aGlzLmJhc2U/bmV3IE4odGhpcy5iYXNlLngsdGhpcy5iYXNlLngrdGhpcy53aWR0aCx0aGlzLmJhc2UueSx0aGlzLmJhc2UueSt0aGlzLmhlaWdodCk6bnVsbCE9PXRoaXMuY2VudHJlP25ldyBOKHRoaXMuY2VudHJlLngtdGhpcy53aWR0aC8yLHRoaXMuY2VudHJlLngrdGhpcy53aWR0aC8yLHRoaXMuY2VudHJlLnktdGhpcy5oZWlnaHQvMix0aGlzLmNlbnRyZS55K3RoaXMuaGVpZ2h0LzIpOm5ldyBOKDAsdGhpcy53aWR0aCwwLHRoaXMuaGVpZ2h0KX1nZXRDZW50cmUoKXtyZXR1cm4gbnVsbD09PXRoaXMuY2VudHJlJiYodGhpcy5jZW50cmU9bmV3IGcodGhpcy5iYXNlLngrdGhpcy53aWR0aC8yLHRoaXMuYmFzZS55K3RoaXMuaGVpZ2h0LzIpKSx0aGlzLmNlbnRyZX1nZXRIZWlnaHQoKXtyZXR1cm4gdGhpcy5oZWlnaHR9c2V0SGVpZ2h0KHQpe3RoaXMuaGVpZ2h0PXR9c2V0U2l6ZSh0KXt0aGlzLmhlaWdodD10LHRoaXMud2lkdGg9dH1nZXRDbGFzcygpe3JldHVybiB3ZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19d2UuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5iYXNlPW51bGwsdGhpcy5jZW50cmU9bnVsbCx0aGlzLndpZHRoPW51bGwsdGhpcy5oZWlnaHQ9bnVsbH0sU2UuRGltZW5zaW9ucz13ZSxTZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9nZW9tRmFjdD1udWxsLHRoaXMuX3ByZWNNb2RlbD1udWxsLHRoaXMuX2RpbT1uZXcgd2UsdGhpcy5fblB0cz0xMDAsdGhpcy5fcm90YXRpb25BbmdsZT0wLDA9PT1hcmd1bWVudHMubGVuZ3RoKVNlLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsbmV3IEh0KTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tRmFjdD10LHRoaXMuX3ByZWNNb2RlbD10LmdldFByZWNpc2lvbk1vZGVsKCl9fTtjbGFzcyBMZSBleHRlbmRzIFNle2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxMZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXNldE51bUFybXModCl7dGhpcy5fbnVtQXJtcz10fXNldEFybUxlbmd0aFJhdGlvKHQpe3RoaXMuX2FybUxlbmd0aFJhdGlvPXR9Y3JlYXRlU2luZVN0YXIoKXtjb25zdCB0PXRoaXMuX2RpbS5nZXRFbnZlbG9wZSgpLGU9dC5nZXRXaWR0aCgpLzI7bGV0IG49dGhpcy5fYXJtTGVuZ3RoUmF0aW87bjwwJiYobj0wKSxuPjEmJihuPTEpO2NvbnN0IHM9biplLGk9KDEtbikqZSxyPXQuZ2V0TWluWCgpK2Usbz10LmdldE1pblkoKStlLGw9bmV3IEFycmF5KHRoaXMuX25QdHMrMSkuZmlsbChudWxsKTtsZXQgYT0wO2ZvcihsZXQgdD0wO3Q8dGhpcy5fblB0czt0Kyspe2NvbnN0IGU9dC90aGlzLl9uUHRzKnRoaXMuX251bUFybXMsbj1lLU1hdGguZmxvb3IoZSksYz0yKk1hdGguUEkqbixoPWkrcyooKE1hdGguY29zKGMpKzEpLzIpLHU9dCooMipNYXRoLlBJL3RoaXMuX25QdHMpLGc9aCpNYXRoLmNvcyh1KStyLGQ9aCpNYXRoLnNpbih1KStvO2xbYSsrXT10aGlzLmNvb3JkKGcsZCl9bFthXT1uZXcgZyhsWzBdKTtjb25zdCBjPXRoaXMuX2dlb21GYWN0LmNyZWF0ZUxpbmVhclJpbmcobCk7cmV0dXJuIHRoaXMuX2dlb21GYWN0LmNyZWF0ZVBvbHlnb24oYyl9Z2V0Q2xhc3MoKXtyZXR1cm4gTGV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUxlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX251bUFybXM9OCx0aGlzLl9hcm1MZW5ndGhSYXRpbz0uNSwwPT09YXJndW1lbnRzLmxlbmd0aClTZS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtTZS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfX07dmFyIFRlPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEFmZmluZVRyYW5zZm9ybWF0aW9uOmxlLEFmZmluZVRyYW5zZm9ybWF0aW9uQnVpbGRlcjpjZSxBZmZpbmVUcmFuc2Zvcm1hdGlvbkZhY3Rvcnk6aGUsQ29tcG9uZW50Q29vcmRpbmF0ZUV4dHJhY3Rlcjp1ZSxHZW9tZXRyeUNvbGxlY3Rpb25NYXBwZXI6Z2UsR2VvbWV0cnlDb21iaW5lcjpkZSxHZW9tZXRyeUVkaXRvcjpGdCxHZW9tZXRyeUV4dHJhY3RlcjpfZSxHZW9tZXRyeU1hcHBlcjpwZSxHZW9tZXRyeVRyYW5zZm9ybWVyOm1lLExpbmVTdHJpbmdFeHRyYWN0ZXI6eWUsTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyOnhlLE1hcE9wOmZlLFBvaW50RXh0cmFjdGVyOkllLFBvbHlnb25FeHRyYWN0ZXI6TmUsU2hvcnRDaXJjdWl0ZWRHZW9tZXRyeVZpc2l0b3I6Q2UsU2luZVN0YXJGYWN0b3J5OkxlfSksUmU9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQ29vcmRpbmF0ZTpnLENvb3JkaW5hdGVMaXN0OkksRW52ZWxvcGU6TixMaW5lU2VnbWVudDplZSxHZW9tZXRyeUZhY3Rvcnk6SHQsR2VvbWV0cnk6cSxQb2ludDpQdCxMaW5lU3RyaW5nOlR0LExpbmVhclJpbmc6RHQsUG9seWdvbjpidCxHZW9tZXRyeUNvbGxlY3Rpb246X3QsTXVsdGlQb2ludDpNdCxNdWx0aUxpbmVTdHJpbmc6ZnQsTXVsdGlQb2x5Z29uOkF0LERpbWVuc2lvbjp1dCxJbnRlcnNlY3Rpb25NYXRyaXg6c2UsUHJlY2lzaW9uTW9kZWw6a3QsTG9jYXRpb246bmUsVHJpYW5nbGU6cmUsdXRpbDpUZX0pO2NsYXNzIFBle2NvbnN0cnVjdG9yKCl7UGUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLl9wdH1nZXRDb29yZGluYXRlKHQpe3JldHVybiB0aGlzLl9wdFt0XX1zZXRNaW5pbXVtKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0TWluaW11bSh0Ll9wdFswXSx0Ll9wdFsxXSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodGhpcy5faXNOdWxsKXJldHVybiB0aGlzLmluaXRpYWxpemUodCxlKSxudWxsO2NvbnN0IG49dC5kaXN0YW5jZShlKTtuPHRoaXMuX2Rpc3RhbmNlJiZ0aGlzLmluaXRpYWxpemUodCxlLG4pfX1pbml0aWFsaXplKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5faXNOdWxsPSEwO2Vsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3B0WzBdLnNldENvb3JkaW5hdGUodCksdGhpcy5fcHRbMV0uc2V0Q29vcmRpbmF0ZShlKSx0aGlzLl9kaXN0YW5jZT10LmRpc3RhbmNlKGUpLHRoaXMuX2lzTnVsbD0hMX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9wdFswXS5zZXRDb29yZGluYXRlKHQpLHRoaXMuX3B0WzFdLnNldENvb3JkaW5hdGUoZSksdGhpcy5fZGlzdGFuY2U9bix0aGlzLl9pc051bGw9ITF9fXRvU3RyaW5nKCl7cmV0dXJuIEp0LnRvTGluZVN0cmluZyh0aGlzLl9wdFswXSx0aGlzLl9wdFsxXSl9Z2V0RGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5fZGlzdGFuY2V9c2V0TWF4aW11bSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldE1heGltdW0odC5fcHRbMF0sdC5fcHRbMV0pfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHRoaXMuX2lzTnVsbClyZXR1cm4gdGhpcy5pbml0aWFsaXplKHQsZSksbnVsbDtjb25zdCBuPXQuZGlzdGFuY2UoZSk7bj50aGlzLl9kaXN0YW5jZSYmdGhpcy5pbml0aWFsaXplKHQsZSxuKX19Z2V0Q2xhc3MoKXtyZXR1cm4gUGV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVBlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3B0PVtuZXcgZyxuZXcgZ10sdGhpcy5fZGlzdGFuY2U9aS5OYU4sdGhpcy5faXNOdWxsPSEwfTtjbGFzcyB2ZXtjb25zdHJ1Y3Rvcigpe3ZlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbXB1dGVEaXN0YW5jZSgpe2lmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgUGUmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgVHQmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1uZXcgZWUsaT10LmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCB0PTA7dDxpLmxlbmd0aC0xO3QrKyl7cy5zZXRDb29yZGluYXRlcyhpW3RdLGlbdCsxXSk7Y29uc3Qgcj1zLmNsb3Nlc3RQb2ludChlKTtuLnNldE1pbmltdW0ocixlKX19ZWxzZSBpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIFBlJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGJ0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3ZlLmNvbXB1dGVEaXN0YW5jZSh0LmdldEV4dGVyaW9yUmluZygpLGUsbik7Zm9yKGxldCBzPTA7czx0LmdldE51bUludGVyaW9yUmluZygpO3MrKyl2ZS5jb21wdXRlRGlzdGFuY2UodC5nZXRJbnRlcmlvclJpbmdOKHMpLGUsbil9ZWxzZSBpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIFBlJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYodCBpbnN0YW5jZW9mIFR0KXZlLmNvbXB1dGVEaXN0YW5jZSh0LGUsbik7ZWxzZSBpZih0IGluc3RhbmNlb2YgYnQpdmUuY29tcHV0ZURpc3RhbmNlKHQsZSxuKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBfdCl7Y29uc3Qgcz10O2ZvcihsZXQgdD0wO3Q8cy5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXtjb25zdCBpPXMuZ2V0R2VvbWV0cnlOKHQpO3ZlLmNvbXB1dGVEaXN0YW5jZShpLGUsbil9fWVsc2Ugbi5zZXRNaW5pbXVtKHQuZ2V0Q29vcmRpbmF0ZSgpLGUpfWVsc2UgaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBQZSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBlZSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPXQuY2xvc2VzdFBvaW50KGUpO24uc2V0TWluaW11bShzLGUpfX1nZXRDbGFzcygpe3JldHVybiB2ZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19dmUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBPZXtjb25zdHJ1Y3Rvcigpe09lLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGRpc3RhbmNlKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBuZXcgT2UodCxlKS5kaXN0YW5jZSgpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPW5ldyBPZSh0LGUpO3JldHVybiBzLnNldERlbnNpZnlGcmFjdGlvbihuKSxzLmRpc3RhbmNlKCl9fWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuX3B0RGlzdC5nZXRDb29yZGluYXRlcygpfXNldERlbnNpZnlGcmFjdGlvbih0KXtpZih0PjF8fHQ8PTApdGhyb3cgbmV3IG4oXCJGcmFjdGlvbiBpcyBub3QgaW4gcmFuZ2UgKDAuMCAtIDEuMF1cIik7dGhpcy5fZGVuc2lmeUZyYWM9dH1jb21wdXRlKHQsZSl7dGhpcy5jb21wdXRlT3JpZW50ZWREaXN0YW5jZSh0LGUsdGhpcy5fcHREaXN0KSx0aGlzLmNvbXB1dGVPcmllbnRlZERpc3RhbmNlKGUsdCx0aGlzLl9wdERpc3QpfWRpc3RhbmNlKCl7cmV0dXJuIHRoaXMuY29tcHV0ZSh0aGlzLl9nMCx0aGlzLl9nMSksdGhpcy5fcHREaXN0LmdldERpc3RhbmNlKCl9Y29tcHV0ZU9yaWVudGVkRGlzdGFuY2UodCxlLG4pe2NvbnN0IHM9bmV3IGJlKGUpO2lmKHQuYXBwbHkocyksbi5zZXRNYXhpbXVtKHMuZ2V0TWF4UG9pbnREaXN0YW5jZSgpKSx0aGlzLl9kZW5zaWZ5RnJhYz4wKXtjb25zdCBzPW5ldyBNZShlLHRoaXMuX2RlbnNpZnlGcmFjKTt0LmFwcGx5KHMpLG4uc2V0TWF4aW11bShzLmdldE1heFBvaW50RGlzdGFuY2UoKSl9fW9yaWVudGVkRGlzdGFuY2UoKXtyZXR1cm4gdGhpcy5jb21wdXRlT3JpZW50ZWREaXN0YW5jZSh0aGlzLl9nMCx0aGlzLl9nMSx0aGlzLl9wdERpc3QpLHRoaXMuX3B0RGlzdC5nZXREaXN0YW5jZSgpfWdldENsYXNzKCl7cmV0dXJuIE9lfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyBiZXtjb25zdHJ1Y3Rvcigpe2JlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmlsdGVyKHQpe3RoaXMuX21pblB0RGlzdC5pbml0aWFsaXplKCksdmUuY29tcHV0ZURpc3RhbmNlKHRoaXMuX2dlb20sdCx0aGlzLl9taW5QdERpc3QpLHRoaXMuX21heFB0RGlzdC5zZXRNYXhpbXVtKHRoaXMuX21pblB0RGlzdCl9Z2V0TWF4UG9pbnREaXN0YW5jZSgpe3JldHVybiB0aGlzLl9tYXhQdERpc3R9Z2V0Q2xhc3MoKXtyZXR1cm4gYmV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0JdfX1iZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9tYXhQdERpc3Q9bmV3IFBlLHRoaXMuX21pblB0RGlzdD1uZXcgUGUsdGhpcy5fZXVjbGlkZWFuRGlzdD1uZXcgdmUsdGhpcy5fZ2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb209dH07Y2xhc3MgTWV7Y29uc3RydWN0b3IoKXtNZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbHRlcih0LGUpe2lmKDA9PT1lKXJldHVybiBudWxsO2NvbnN0IG49dC5nZXRDb29yZGluYXRlKGUtMSkscz10LmdldENvb3JkaW5hdGUoZSksaT0ocy54LW4ueCkvdGhpcy5fbnVtU3ViU2VncyxyPShzLnktbi55KS90aGlzLl9udW1TdWJTZWdzO2ZvcihsZXQgdD0wO3Q8dGhpcy5fbnVtU3ViU2Vnczt0Kyspe2NvbnN0IGU9bi54K3QqaSxzPW4ueSt0KnIsbz1uZXcgZyhlLHMpO3RoaXMuX21pblB0RGlzdC5pbml0aWFsaXplKCksdmUuY29tcHV0ZURpc3RhbmNlKHRoaXMuX2dlb20sbyx0aGlzLl9taW5QdERpc3QpLHRoaXMuX21heFB0RGlzdC5zZXRNYXhpbXVtKHRoaXMuX21pblB0RGlzdCl9fWlzRG9uZSgpe3JldHVybiExfWlzR2VvbWV0cnlDaGFuZ2VkKCl7cmV0dXJuITF9Z2V0TWF4UG9pbnREaXN0YW5jZSgpe3JldHVybiB0aGlzLl9tYXhQdERpc3R9Z2V0Q2xhc3MoKXtyZXR1cm4gTWV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2R0XX19TWUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbWF4UHREaXN0PW5ldyBQZSx0aGlzLl9taW5QdERpc3Q9bmV3IFBlLHRoaXMuX2dlb209bnVsbCx0aGlzLl9udW1TdWJTZWdzPTA7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZ2VvbT10LHRoaXMuX251bVN1YlNlZ3M9TWF0aC50cnVuYyhNYXRoLnJvdW5kKDEvZSkpfSxPZS5NYXhQb2ludERpc3RhbmNlRmlsdGVyPWJlLE9lLk1heERlbnNpZmllZEJ5RnJhY3Rpb25EaXN0YW5jZUZpbHRlcj1NZSxPZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9nMD1udWxsLHRoaXMuX2cxPW51bGwsdGhpcy5fcHREaXN0PW5ldyBQZSx0aGlzLl9kZW5zaWZ5RnJhYz0wO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2cwPXQsdGhpcy5fZzE9ZX07dmFyIERlPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLERpc2NyZXRlSGF1c2RvcmZmRGlzdGFuY2U6T2UsRGlzdGFuY2VUb1BvaW50OnZlLFBvaW50UGFpckRpc3RhbmNlOlBlfSk7Y2xhc3MgQWV7Y29uc3RydWN0b3IoKXtBZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXZpc2l0SXRlbSh0KXt9Z2V0Q2xhc3MoKXtyZXR1cm4gQWV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUFlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgRmV7Y29uc3RydWN0b3IoKXtGZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWxvY2F0ZSh0KXt9Z2V0Q2xhc3MoKXtyZXR1cm4gRmV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUZlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgR2V7Y29uc3RydWN0b3IoKXtHZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldE1pbigpe3JldHVybiB0aGlzLl9taW59aW50ZXJzZWN0cyh0LGUpe3JldHVybiEodGhpcy5fbWluPmV8fHRoaXMuX21heDx0KX1nZXRNYXgoKXtyZXR1cm4gdGhpcy5fbWF4fXRvU3RyaW5nKCl7cmV0dXJuIEp0LnRvTGluZVN0cmluZyhuZXcgZyh0aGlzLl9taW4sMCksbmV3IGcodGhpcy5fbWF4LDApKX1nZXRDbGFzcygpe3JldHVybiBHZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3MgcWV7Y29uc3RydWN0b3IoKXtxZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNvbXBhcmUodCxlKXtjb25zdCBuPXQscz1lLGk9KG4uX21pbituLl9tYXgpLzIscj0ocy5fbWluK3MuX21heCkvMjtyZXR1cm4gaTxyPy0xOmk+cj8xOjB9Z2V0Q2xhc3MoKXtyZXR1cm4gcWV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2xdfX1xZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LEdlLk5vZGVDb21wYXJhdG9yPXFlLEdlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX21pbj1pLlBPU0lUSVZFX0lORklOSVRZLHRoaXMuX21heD1pLk5FR0FUSVZFX0lORklOSVRZfTtjbGFzcyBCZSBleHRlbmRzIEdle2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxCZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXF1ZXJ5KHQsZSxuKXtpZighdGhpcy5pbnRlcnNlY3RzKHQsZSkpcmV0dXJuIG51bGw7bi52aXNpdEl0ZW0odGhpcy5faXRlbSl9Z2V0Q2xhc3MoKXtyZXR1cm4gQmV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUJlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2l0ZW09bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9taW49dCx0aGlzLl9tYXg9ZSx0aGlzLl9pdGVtPW59O2NsYXNzIFZlIGV4dGVuZHMgR2V7Y29uc3RydWN0b3IoKXtzdXBlcigpLFZlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9YnVpbGRFeHRlbnQodCxlKXt0aGlzLl9taW49TWF0aC5taW4odC5fbWluLGUuX21pbiksdGhpcy5fbWF4PU1hdGgubWF4KHQuX21heCxlLl9tYXgpfXF1ZXJ5KHQsZSxuKXtpZighdGhpcy5pbnRlcnNlY3RzKHQsZSkpcmV0dXJuIG51bGw7bnVsbCE9PXRoaXMuX25vZGUxJiZ0aGlzLl9ub2RlMS5xdWVyeSh0LGUsbiksbnVsbCE9PXRoaXMuX25vZGUyJiZ0aGlzLl9ub2RlMi5xdWVyeSh0LGUsbil9Z2V0Q2xhc3MoKXtyZXR1cm4gVmV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVZlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX25vZGUxPW51bGwsdGhpcy5fbm9kZTI9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9ub2RlMT10LHRoaXMuX25vZGUyPWUsdGhpcy5idWlsZEV4dGVudCh0aGlzLl9ub2RlMSx0aGlzLl9ub2RlMil9O2NsYXNzIHple2NvbnN0cnVjdG9yKCl7emUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1idWlsZFRyZWUoKXtFZS5zb3J0KHRoaXMuX2xlYXZlcyxuZXcgR2UuTm9kZUNvbXBhcmF0b3IpO2xldCB0PXRoaXMuX2xlYXZlcyxlPW51bGwsbj1uZXcgeDtmb3IoOzspe2lmKHRoaXMuYnVpbGRMZXZlbCh0LG4pLDE9PT1uLnNpemUoKSlyZXR1cm4gbi5nZXQoMCk7ZT10LHQ9bixuPWV9fWluc2VydCh0LGUsbil7aWYobnVsbCE9PXRoaXMuX3Jvb3QpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcIkluZGV4IGNhbm5vdCBiZSBhZGRlZCB0byBvbmNlIGl0IGhhcyBiZWVuIHF1ZXJpZWRcIik7dGhpcy5fbGVhdmVzLmFkZChuZXcgQmUodCxlLG4pKX1xdWVyeSh0LGUsbil7dGhpcy5pbml0KCksdGhpcy5fcm9vdC5xdWVyeSh0LGUsbil9YnVpbGRSb290KCl7aWYobnVsbCE9PXRoaXMuX3Jvb3QpcmV0dXJuIG51bGw7dGhpcy5fcm9vdD10aGlzLmJ1aWxkVHJlZSgpfXByaW50Tm9kZSh0KXtPLm91dC5wcmludGxuKEp0LnRvTGluZVN0cmluZyhuZXcgZyh0Ll9taW4sdGhpcy5fbGV2ZWwpLG5ldyBnKHQuX21heCx0aGlzLl9sZXZlbCkpKX1pbml0KCl7aWYobnVsbCE9PXRoaXMuX3Jvb3QpcmV0dXJuIG51bGw7dGhpcy5idWlsZFJvb3QoKX1idWlsZExldmVsKHQsZSl7dGhpcy5fbGV2ZWwrKyxlLmNsZWFyKCk7Zm9yKGxldCBuPTA7bjx0LnNpemUoKTtuKz0yKXtjb25zdCBzPXQuZ2V0KG4pO2lmKG51bGw9PT0obisxPHQuc2l6ZSgpP3QuZ2V0KG4pOm51bGwpKWUuYWRkKHMpO2Vsc2V7Y29uc3Qgcz1uZXcgVmUodC5nZXQobiksdC5nZXQobisxKSk7ZS5hZGQocyl9fX1nZXRDbGFzcygpe3JldHVybiB6ZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19emUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbGVhdmVzPW5ldyB4LHRoaXMuX3Jvb3Q9bnVsbCx0aGlzLl9sZXZlbD0wfTtjbGFzcyBZZXtjb25zdHJ1Y3Rvcigpe1llLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmlzaXRJdGVtKHQpe3RoaXMuX2l0ZW1zLmFkZCh0KX1nZXRJdGVtcygpe3JldHVybiB0aGlzLl9pdGVtc31nZXRDbGFzcygpe3JldHVybiBZZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bQWVdfX1ZZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pdGVtcz1uZXcgeH07Y2xhc3MgVWV7Y29uc3RydWN0b3IoKXtVZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBsb2NhdGVQb2ludEluUmluZygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmXyhhcmd1bWVudHNbMV0sQSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IFVlKHQpLHM9bmV3IGcsaT1uZXcgZztmb3IobGV0IHQ9MTt0PGUuc2l6ZSgpO3QrKylpZihlLmdldENvb3JkaW5hdGUodCxzKSxlLmdldENvb3JkaW5hdGUodC0xLGkpLG4uY291bnRTZWdtZW50KHMsaSksbi5pc09uU2VnbWVudCgpKXJldHVybiBuLmdldExvY2F0aW9uKCk7cmV0dXJuIG4uZ2V0TG9jYXRpb24oKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IFVlKHQpO2ZvcihsZXQgdD0xO3Q8ZS5sZW5ndGg7dCsrKXtjb25zdCBzPWVbdF0saT1lW3QtMV07aWYobi5jb3VudFNlZ21lbnQocyxpKSxuLmlzT25TZWdtZW50KCkpcmV0dXJuIG4uZ2V0TG9jYXRpb24oKX1yZXR1cm4gbi5nZXRMb2NhdGlvbigpfX1jb3VudFNlZ21lbnQodCxlKXtpZih0Lng8dGhpcy5fcC54JiZlLng8dGhpcy5fcC54KXJldHVybiBudWxsO2lmKHRoaXMuX3AueD09PWUueCYmdGhpcy5fcC55PT09ZS55KXJldHVybiB0aGlzLl9pc1BvaW50T25TZWdtZW50PSEwLG51bGw7aWYodC55PT09dGhpcy5fcC55JiZlLnk9PT10aGlzLl9wLnkpe2xldCBuPXQueCxzPWUueDtyZXR1cm4gbj5zJiYobj1lLngscz10LngpLHRoaXMuX3AueD49biYmdGhpcy5fcC54PD1zJiYodGhpcy5faXNQb2ludE9uU2VnbWVudD0hMCksbnVsbH1pZih0Lnk+dGhpcy5fcC55JiZlLnk8PXRoaXMuX3AueXx8ZS55PnRoaXMuX3AueSYmdC55PD10aGlzLl9wLnkpe2xldCBuPXYuaW5kZXgodCxlLHRoaXMuX3ApO2lmKG49PT12LkNPTExJTkVBUilyZXR1cm4gdGhpcy5faXNQb2ludE9uU2VnbWVudD0hMCxudWxsO2UueTx0LnkmJihuPS1uKSxuPT09di5MRUZUJiZ0aGlzLl9jcm9zc2luZ0NvdW50Kyt9fWlzUG9pbnRJblBvbHlnb24oKXtyZXR1cm4gdGhpcy5nZXRMb2NhdGlvbigpIT09bmUuRVhURVJJT1J9Z2V0TG9jYXRpb24oKXtyZXR1cm4gdGhpcy5faXNQb2ludE9uU2VnbWVudD9uZS5CT1VOREFSWTp0aGlzLl9jcm9zc2luZ0NvdW50JTI9PTE/bmUuSU5URVJJT1I6bmUuRVhURVJJT1J9aXNPblNlZ21lbnQoKXtyZXR1cm4gdGhpcy5faXNQb2ludE9uU2VnbWVudH1nZXRDbGFzcygpe3JldHVybiBVZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19VWUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcD1udWxsLHRoaXMuX2Nyb3NzaW5nQ291bnQ9MCx0aGlzLl9pc1BvaW50T25TZWdtZW50PSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3A9dH07Y2xhc3Mga2V7Y29uc3RydWN0b3IoKXtrZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWxvY2F0ZSh0KXtjb25zdCBlPW5ldyBVZSh0KSxuPW5ldyBYZShlKTtyZXR1cm4gdGhpcy5faW5kZXgucXVlcnkodC55LHQueSxuKSxlLmdldExvY2F0aW9uKCl9Z2V0Q2xhc3MoKXtyZXR1cm4ga2V9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0ZlXX19Y2xhc3MgWGV7Y29uc3RydWN0b3IoKXtYZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXZpc2l0SXRlbSh0KXtjb25zdCBlPXQ7dGhpcy5fY291bnRlci5jb3VudFNlZ21lbnQoZS5nZXRDb29yZGluYXRlKDApLGUuZ2V0Q29vcmRpbmF0ZSgxKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gWGV9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0FlXX19WGUuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fY291bnRlcj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2NvdW50ZXI9dH07Y2xhc3MgSGV7Y29uc3RydWN0b3IoKXtIZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWluaXQodCl7Zm9yKGxldCBlPXhlLmdldExpbmVzKHQpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLmdldENvb3JkaW5hdGVzKCk7dGhpcy5hZGRMaW5lKHQpfX1hZGRMaW5lKHQpe2ZvcihsZXQgZT0xO2U8dC5sZW5ndGg7ZSsrKXtjb25zdCBuPW5ldyBlZSh0W2UtMV0sdFtlXSkscz1NYXRoLm1pbihuLnAwLnksbi5wMS55KSxpPU1hdGgubWF4KG4ucDAueSxuLnAxLnkpO3RoaXMuX2luZGV4Lmluc2VydChzLGksbil9fXF1ZXJ5KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IFllO3JldHVybiB0aGlzLl9pbmRleC5xdWVyeSh0LGUsbiksbi5nZXRJdGVtcygpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9pbmRleC5xdWVyeSh0LGUsbil9fWdldENsYXNzKCl7cmV0dXJuIEhlfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1IZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pbmRleD1uZXcgemU7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQpfSxrZS5TZWdtZW50VmlzaXRvcj1YZSxrZS5JbnRlcnZhbEluZGV4ZWRHZW9tZXRyeT1IZSxrZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pbmRleD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKCEoXyh0LE90KXx8dCBpbnN0YW5jZW9mIER0KSl0aHJvdyBuZXcgbihcIkFyZ3VtZW50IG11c3QgYmUgUG9seWdvbmFsIG9yIExpbmVhclJpbmdcIik7dGhpcy5faW5kZXg9bmV3IEhlKHQpfTtjbGFzcyBXZXtjb25zdHJ1Y3Rvcigpe1dlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGlzT25MaW5lKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZfKGFyZ3VtZW50c1sxXSxBKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgdGUscz1uZXcgZyxpPW5ldyBnLHI9ZS5zaXplKCk7Zm9yKGxldCBvPTE7bzxyO28rKylpZihlLmdldENvb3JkaW5hdGUoby0xLHMpLGUuZ2V0Q29vcmRpbmF0ZShvLGkpLG4uY29tcHV0ZUludGVyc2VjdGlvbih0LHMsaSksbi5oYXNJbnRlcnNlY3Rpb24oKSlyZXR1cm4hMDtyZXR1cm4hMX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IHRlO2ZvcihsZXQgcz0xO3M8ZS5sZW5ndGg7cysrKXtjb25zdCBpPWVbcy0xXSxyPWVbc107aWYobi5jb21wdXRlSW50ZXJzZWN0aW9uKHQsaSxyKSxuLmhhc0ludGVyc2VjdGlvbigpKXJldHVybiEwfXJldHVybiExfX1zdGF0aWMgbG9jYXRlSW5SaW5nKHQsZSl7cmV0dXJuIFVlLmxvY2F0ZVBvaW50SW5SaW5nKHQsZSl9c3RhdGljIGlzSW5SaW5nKHQsZSl7cmV0dXJuIFdlLmxvY2F0ZUluUmluZyh0LGUpIT09bmUuRVhURVJJT1J9Z2V0Q2xhc3MoKXtyZXR1cm4gV2V9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWZ1bmN0aW9uIGplKCl7fVdlLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30samUucHJvdG90eXBlLmhhc05leHQ9ZnVuY3Rpb24oKXt9LGplLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7fSxqZS5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7fTtjbGFzcyBLZXtjb25zdHJ1Y3Rvcigpe0tlLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGlzQXRvbWljKHQpe3JldHVybiEodCBpbnN0YW5jZW9mIF90KX1uZXh0KCl7aWYodGhpcy5fYXRTdGFydClyZXR1cm4gdGhpcy5fYXRTdGFydD0hMSxLZS5pc0F0b21pYyh0aGlzLl9wYXJlbnQpJiZ0aGlzLl9pbmRleCsrLHRoaXMuX3BhcmVudDtpZihudWxsIT09dGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yKXtpZih0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IuaGFzTmV4dCgpKXJldHVybiB0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IubmV4dCgpO3RoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvcj1udWxsfWlmKHRoaXMuX2luZGV4Pj10aGlzLl9tYXgpdGhyb3cgbmV3IHk7Y29uc3QgdD10aGlzLl9wYXJlbnQuZ2V0R2VvbWV0cnlOKHRoaXMuX2luZGV4KyspO3JldHVybiB0IGluc3RhbmNlb2YgX3Q/KHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvcj1uZXcgS2UodCksdGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yLm5leHQoKSk6dH1yZW1vdmUoKXt0aHJvdyBuZXcgWih0aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpKX1oYXNOZXh0KCl7aWYodGhpcy5fYXRTdGFydClyZXR1cm4hMDtpZihudWxsIT09dGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yKXtpZih0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IuaGFzTmV4dCgpKXJldHVybiEwO3RoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvcj1udWxsfXJldHVybiEodGhpcy5faW5kZXg+PXRoaXMuX21heCl9Z2V0Q2xhc3MoKXtyZXR1cm4gS2V9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2plXX19S2UuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcGFyZW50PW51bGwsdGhpcy5fYXRTdGFydD1udWxsLHRoaXMuX21heD1udWxsLHRoaXMuX2luZGV4PW51bGwsdGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcGFyZW50PXQsdGhpcy5fYXRTdGFydD0hMCx0aGlzLl9pbmRleD0wLHRoaXMuX21heD10LmdldE51bUdlb21ldHJpZXMoKX07Y2xhc3MgWmV7Y29uc3RydWN0b3IoKXtaZS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBsb2NhdGVQb2ludEluUG9seWdvbih0LGUpe2lmKGUuaXNFbXB0eSgpKXJldHVybiBuZS5FWFRFUklPUjtjb25zdCBuPWUuZ2V0RXh0ZXJpb3JSaW5nKCkscz1aZS5sb2NhdGVQb2ludEluUmluZyh0LG4pO2lmKHMhPT1uZS5JTlRFUklPUilyZXR1cm4gcztmb3IobGV0IG49MDtuPGUuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7bisrKXtjb25zdCBzPWUuZ2V0SW50ZXJpb3JSaW5nTihuKSxpPVplLmxvY2F0ZVBvaW50SW5SaW5nKHQscyk7aWYoaT09PW5lLkJPVU5EQVJZKXJldHVybiBuZS5CT1VOREFSWTtpZihpPT09bmUuSU5URVJJT1IpcmV0dXJuIG5lLkVYVEVSSU9SfXJldHVybiBuZS5JTlRFUklPUn1zdGF0aWMgbG9jYXRlUG9pbnRJblJpbmcodCxlKXtyZXR1cm4gZS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyh0KT9XZS5sb2NhdGVJblJpbmcodCxlLmdldENvb3JkaW5hdGVzKCkpOm5lLkVYVEVSSU9SfXN0YXRpYyBjb250YWluc1BvaW50SW5Qb2x5Z29uKHQsZSl7cmV0dXJuIG5lLkVYVEVSSU9SIT09WmUubG9jYXRlUG9pbnRJblBvbHlnb24odCxlKX1zdGF0aWMgbG9jYXRlSW5HZW9tZXRyeSh0LGUpe2lmKGUgaW5zdGFuY2VvZiBidClyZXR1cm4gWmUubG9jYXRlUG9pbnRJblBvbHlnb24odCxlKTtpZihlIGluc3RhbmNlb2YgX3Qpe2NvbnN0IG49bmV3IEtlKGUpO2Zvcig7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO2lmKHMhPT1lKXtjb25zdCBlPVplLmxvY2F0ZUluR2VvbWV0cnkodCxzKTtpZihlIT09bmUuRVhURVJJT1IpcmV0dXJuIGV9fX1yZXR1cm4gbmUuRVhURVJJT1J9c3RhdGljIGxvY2F0ZSh0LGUpe3JldHVybiBlLmlzRW1wdHkoKT9uZS5FWFRFUklPUjpaZS5sb2NhdGVJbkdlb21ldHJ5KHQsZSl9bG9jYXRlKHQpe3JldHVybiBaZS5sb2NhdGUodCx0aGlzLl9nZW9tKX1nZXRDbGFzcygpe3JldHVybiBaZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bRmVdfX1aZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9nZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbT10fTt2YXIgUWU9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsSW5kZXhlZFBvaW50SW5BcmVhTG9jYXRvcjprZSxQb2ludE9uR2VvbWV0cnlMb2NhdG9yOkZlLFNpbXBsZVBvaW50SW5BcmVhTG9jYXRvcjpaZX0pO2NsYXNzIEple2NvbnN0cnVjdG9yKCl7SmUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1tZWFzdXJlKHQsZSl7fWdldENsYXNzKCl7cmV0dXJuIEplfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1KZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzICRle2NvbnN0cnVjdG9yKCl7JGUuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1tZWFzdXJlKHQsZSl7cmV0dXJuIHQuaW50ZXJzZWN0aW9uKGUpLmdldEFyZWEoKS90LnVuaW9uKGUpLmdldEFyZWEoKX1nZXRDbGFzcygpe3JldHVybiAkZX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSmVdfX0kZS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIHRue2NvbnN0cnVjdG9yKCl7dG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZGlhZ29uYWxTaXplKHQpe2lmKHQuaXNOdWxsKCkpcmV0dXJuIDA7Y29uc3QgZT10LmdldFdpZHRoKCksbj10LmdldEhlaWdodCgpO3JldHVybiBNYXRoLnNxcnQoZSplK24qbil9bWVhc3VyZSh0LGUpe2NvbnN0IG49T2UuZGlzdGFuY2UodCxlLHRuLkRFTlNJRllfRlJBQ1RJT04pLHM9bmV3IE4odC5nZXRFbnZlbG9wZUludGVybmFsKCkpO3JldHVybiBzLmV4cGFuZFRvSW5jbHVkZShlLmdldEVudmVsb3BlSW50ZXJuYWwoKSksMS1uL3RuLmRpYWdvbmFsU2l6ZShzKX1nZXRDbGFzcygpe3JldHVybiB0bn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bSmVdfX10bi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LHRuLkRFTlNJRllfRlJBQ1RJT049LjI1O2NsYXNzIGVue2NvbnN0cnVjdG9yKCl7ZW4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY29tYmluZSh0LGUpe3JldHVybiBNYXRoLm1pbih0LGUpfWdldENsYXNzKCl7cmV0dXJuIGVufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1lbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O3ZhciBubj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxBcmVhU2ltaWxhcml0eU1lYXN1cmU6JGUsSGF1c2RvcmZmU2ltaWxhcml0eU1lYXN1cmU6dG4sU2ltaWxhcml0eU1lYXN1cmU6SmUsU2ltaWxhcml0eU1lYXN1cmVDb21iaW5lcjplbn0pO2NsYXNzIHNue2NvbnN0cnVjdG9yKCl7c24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgYXJlYTIodCxlLG4pe3JldHVybihlLngtdC54KSoobi55LXQueSktKG4ueC10LngpKihlLnktdC55KX1zdGF0aWMgY2VudHJvaWQzKHQsZSxuLHMpe3JldHVybiBzLng9dC54K2UueCtuLngscy55PXQueStlLnkrbi55LG51bGx9c3RhdGljIGdldENlbnRyb2lkKHQpe3JldHVybiBuZXcgc24odCkuZ2V0Q2VudHJvaWQoKX1zZXRBcmVhQmFzZVBvaW50KHQpe3RoaXMuX2FyZWFCYXNlUHQ9dH1hZGRQb2ludCh0KXt0aGlzLl9wdENvdW50Kz0xLHRoaXMuX3B0Q2VudFN1bS54Kz10LngsdGhpcy5fcHRDZW50U3VtLnkrPXQueX1hZGRMaW5lU2VnbWVudHModCl7bGV0IGU9MDtmb3IobGV0IG49MDtuPHQubGVuZ3RoLTE7bisrKXtjb25zdCBzPXRbbl0uZGlzdGFuY2UodFtuKzFdKTtpZigwPT09cyljb250aW51ZTtlKz1zO2NvbnN0IGk9KHRbbl0ueCt0W24rMV0ueCkvMjt0aGlzLl9saW5lQ2VudFN1bS54Kz1zKmk7Y29uc3Qgcj0odFtuXS55K3RbbisxXS55KS8yO3RoaXMuX2xpbmVDZW50U3VtLnkrPXMqcn10aGlzLl90b3RhbExlbmd0aCs9ZSwwPT09ZSYmdC5sZW5ndGg+MCYmdGhpcy5hZGRQb2ludCh0WzBdKX1hZGRIb2xlKHQpe2NvbnN0IGU9di5pc0NDVyh0KTtmb3IobGV0IG49MDtuPHQubGVuZ3RoLTE7bisrKXRoaXMuYWRkVHJpYW5nbGUodGhpcy5fYXJlYUJhc2VQdCx0W25dLHRbbisxXSxlKTt0aGlzLmFkZExpbmVTZWdtZW50cyh0KX1nZXRDZW50cm9pZCgpe2NvbnN0IHQ9bmV3IGc7aWYoTWF0aC5hYnModGhpcy5fYXJlYXN1bTIpPjApdC54PXRoaXMuX2NnMy54LzMvdGhpcy5fYXJlYXN1bTIsdC55PXRoaXMuX2NnMy55LzMvdGhpcy5fYXJlYXN1bTI7ZWxzZSBpZih0aGlzLl90b3RhbExlbmd0aD4wKXQueD10aGlzLl9saW5lQ2VudFN1bS54L3RoaXMuX3RvdGFsTGVuZ3RoLHQueT10aGlzLl9saW5lQ2VudFN1bS55L3RoaXMuX3RvdGFsTGVuZ3RoO2Vsc2V7aWYoISh0aGlzLl9wdENvdW50PjApKXJldHVybiBudWxsO3QueD10aGlzLl9wdENlbnRTdW0ueC90aGlzLl9wdENvdW50LHQueT10aGlzLl9wdENlbnRTdW0ueS90aGlzLl9wdENvdW50fXJldHVybiB0fWFkZFNoZWxsKHQpe3QubGVuZ3RoPjAmJnRoaXMuc2V0QXJlYUJhc2VQb2ludCh0WzBdKTtjb25zdCBlPSF2LmlzQ0NXKHQpO2ZvcihsZXQgbj0wO248dC5sZW5ndGgtMTtuKyspdGhpcy5hZGRUcmlhbmdsZSh0aGlzLl9hcmVhQmFzZVB0LHRbbl0sdFtuKzFdLGUpO3RoaXMuYWRkTGluZVNlZ21lbnRzKHQpfWFkZFRyaWFuZ2xlKHQsZSxuLHMpe2NvbnN0IGk9cz8xOi0xO3NuLmNlbnRyb2lkMyh0LGUsbix0aGlzLl90cmlhbmdsZUNlbnQzKTtjb25zdCByPXNuLmFyZWEyKHQsZSxuKTt0aGlzLl9jZzMueCs9aSpyKnRoaXMuX3RyaWFuZ2xlQ2VudDMueCx0aGlzLl9jZzMueSs9aSpyKnRoaXMuX3RyaWFuZ2xlQ2VudDMueSx0aGlzLl9hcmVhc3VtMis9aSpyfWFkZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgYnQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuYWRkU2hlbGwodC5nZXRFeHRlcmlvclJpbmcoKS5nZXRDb29yZGluYXRlcygpKTtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKXRoaXMuYWRkSG9sZSh0LmdldEludGVyaW9yUmluZ04oZSkuZ2V0Q29vcmRpbmF0ZXMoKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2lmKHQgaW5zdGFuY2VvZiBQdCl0aGlzLmFkZFBvaW50KHQuZ2V0Q29vcmRpbmF0ZSgpKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBUdCl0aGlzLmFkZExpbmVTZWdtZW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGJ0KXtjb25zdCBlPXQ7dGhpcy5hZGQoZSl9ZWxzZSBpZih0IGluc3RhbmNlb2YgX3Qpe2NvbnN0IGU9dDtmb3IobGV0IHQ9MDt0PGUuZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl0aGlzLmFkZChlLmdldEdlb21ldHJ5Tih0KSl9fX1nZXRDbGFzcygpe3JldHVybiBzbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZnVuY3Rpb24gcm4odCl7dGhpcy5tZXNzYWdlPXR8fFwiXCJ9ZnVuY3Rpb24gb24oKXt0aGlzLmFycmF5Xz1bXX1zbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9hcmVhQmFzZVB0PW51bGwsdGhpcy5fdHJpYW5nbGVDZW50Mz1uZXcgZyx0aGlzLl9hcmVhc3VtMj0wLHRoaXMuX2NnMz1uZXcgZyx0aGlzLl9saW5lQ2VudFN1bT1uZXcgZyx0aGlzLl90b3RhbExlbmd0aD0wLHRoaXMuX3B0Q291bnQ9MCx0aGlzLl9wdENlbnRTdW09bmV3IGc7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fYXJlYUJhc2VQdD1udWxsLHRoaXMuYWRkKHQpfSxybi5wcm90b3R5cGU9bmV3IEVycm9yLHJuLnByb3RvdHlwZS5uYW1lPVwiRW1wdHlTdGFja0V4Y2VwdGlvblwiLG9uLnByb3RvdHlwZT1uZXcgbSxvbi5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmFycmF5Xy5wdXNoKHQpLCEwfSxvbi5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe2lmKHQ8MHx8dD49dGhpcy5zaXplKCkpdGhyb3cgbmV3IHA7cmV0dXJuIHRoaXMuYXJyYXlfW3RdfSxvbi5wcm90b3R5cGUucHVzaD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5hcnJheV8ucHVzaCh0KSx0fSxvbi5wcm90b3R5cGUucG9wPWZ1bmN0aW9uKHQpe2lmKDA9PT10aGlzLmFycmF5Xy5sZW5ndGgpdGhyb3cgbmV3IHJuO3JldHVybiB0aGlzLmFycmF5Xy5wb3AoKX0sb24ucHJvdG90eXBlLnBlZWs9ZnVuY3Rpb24oKXtpZigwPT09dGhpcy5hcnJheV8ubGVuZ3RoKXRocm93IG5ldyBybjtyZXR1cm4gdGhpcy5hcnJheV9bdGhpcy5hcnJheV8ubGVuZ3RoLTFdfSxvbi5wcm90b3R5cGUuZW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuYXJyYXlfLmxlbmd0aH0sb24ucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbXB0eSgpfSxvbi5wcm90b3R5cGUuc2VhcmNoPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmFycmF5Xy5pbmRleE9mKHQpfSxvbi5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFycmF5Xy5sZW5ndGh9LG9uLnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGU9MCxuPXRoaXMuYXJyYXlfLmxlbmd0aDtlPG47ZSsrKXQucHVzaCh0aGlzLmFycmF5X1tlXSk7cmV0dXJuIHR9O2NsYXNzIGxue2NvbnN0cnVjdG9yKCl7bG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZmlsdGVyQ29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcgbG47Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspZS5maWx0ZXIodFtuXSk7cmV0dXJuIGUuZ2V0Q29vcmRpbmF0ZXMoKX1maWx0ZXIodCl7dGhpcy50cmVlU2V0LmNvbnRhaW5zKHQpfHwodGhpcy5saXN0LmFkZCh0KSx0aGlzLnRyZWVTZXQuYWRkKHQpKX1nZXRDb29yZGluYXRlcygpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMubGlzdC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHRoaXMubGlzdC50b0FycmF5KHQpfWdldENsYXNzKCl7cmV0dXJuIGxufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltCXX19bG4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy50cmVlU2V0PW5ldyBhdCx0aGlzLmxpc3Q9bmV3IHh9O2NsYXNzIGFue2NvbnN0cnVjdG9yKCl7YW4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZXh0cmFjdENvb3JkaW5hdGVzKHQpe2NvbnN0IGU9bmV3IGxuO3JldHVybiB0LmFwcGx5KGUpLGUuZ2V0Q29vcmRpbmF0ZXMoKX1wcmVTb3J0KHQpe2xldCBlPW51bGw7Zm9yKGxldCBuPTE7bjx0Lmxlbmd0aDtuKyspKHRbbl0ueTx0WzBdLnl8fHRbbl0ueT09PXRbMF0ueSYmdFtuXS54PHRbMF0ueCkmJihlPXRbMF0sdFswXT10W25dLHRbbl09ZSk7cmV0dXJuIGh0LnNvcnQodCwxLHQubGVuZ3RoLG5ldyBjbih0WzBdKSksdH1jb21wdXRlT2N0UmluZyh0KXtjb25zdCBlPXRoaXMuY29tcHV0ZU9jdFB0cyh0KSxuPW5ldyBJO3JldHVybiBuLmFkZChlLCExKSxuLnNpemUoKTwzP251bGw6KG4uY2xvc2VSaW5nKCksbi50b0Nvb3JkaW5hdGVBcnJheSgpKX1saW5lT3JQb2x5Z29uKHQpe2lmKDM9PT0odD10aGlzLmNsZWFuUmluZyh0KSkubGVuZ3RoKXJldHVybiB0aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKFt0WzBdLHRbMV1dKTtjb25zdCBlPXRoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcodCk7cmV0dXJuIHRoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZVBvbHlnb24oZSl9Y2xlYW5SaW5nKHQpe3UuZXF1YWxzKHRbMF0sdFt0Lmxlbmd0aC0xXSk7Y29uc3QgZT1uZXcgeDtsZXQgbj1udWxsO2ZvcihsZXQgcz0wO3M8PXQubGVuZ3RoLTI7cysrKXtjb25zdCBpPXRbc10scj10W3MrMV07aS5lcXVhbHMocil8fChudWxsIT09biYmdGhpcy5pc0JldHdlZW4obixpLHIpfHwoZS5hZGQoaSksbj1pKSl9ZS5hZGQodFt0Lmxlbmd0aC0xXSk7Y29uc3Qgcz1uZXcgQXJyYXkoZS5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIGUudG9BcnJheShzKX1pc0JldHdlZW4odCxlLG4pe2lmKDAhPT12LmluZGV4KHQsZSxuKSlyZXR1cm4hMTtpZih0LnghPT1uLngpe2lmKHQueDw9ZS54JiZlLng8PW4ueClyZXR1cm4hMDtpZihuLng8PWUueCYmZS54PD10LngpcmV0dXJuITB9aWYodC55IT09bi55KXtpZih0Lnk8PWUueSYmZS55PD1uLnkpcmV0dXJuITA7aWYobi55PD1lLnkmJmUueTw9dC55KXJldHVybiEwfXJldHVybiExfXJlZHVjZSh0KXtjb25zdCBlPXRoaXMuY29tcHV0ZU9jdFJpbmcodCk7aWYobnVsbD09PWUpcmV0dXJuIHQ7Y29uc3Qgbj1uZXcgYXQ7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspbi5hZGQoZVt0XSk7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspV2UuaXNJblJpbmcodFtzXSxlKXx8bi5hZGQodFtzXSk7Y29uc3Qgcz1YLnRvQ29vcmRpbmF0ZUFycmF5KG4pO3JldHVybiBzLmxlbmd0aDwzP3RoaXMucGFkQXJyYXkzKHMpOnN9Z2V0Q29udmV4SHVsbCgpe2lmKDA9PT10aGlzLl9pbnB1dFB0cy5sZW5ndGgpcmV0dXJuIHRoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpO2lmKDE9PT10aGlzLl9pbnB1dFB0cy5sZW5ndGgpcmV0dXJuIHRoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZVBvaW50KHRoaXMuX2lucHV0UHRzWzBdKTtpZigyPT09dGhpcy5faW5wdXRQdHMubGVuZ3RoKXJldHVybiB0aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuX2lucHV0UHRzKTtsZXQgdD10aGlzLl9pbnB1dFB0czt0aGlzLl9pbnB1dFB0cy5sZW5ndGg+NTAmJih0PXRoaXMucmVkdWNlKHRoaXMuX2lucHV0UHRzKSk7Y29uc3QgZT10aGlzLnByZVNvcnQodCksbj10aGlzLmdyYWhhbVNjYW4oZSkscz10aGlzLnRvQ29vcmRpbmF0ZUFycmF5KG4pO3JldHVybiB0aGlzLmxpbmVPclBvbHlnb24ocyl9cGFkQXJyYXkzKHQpe2NvbnN0IGU9bmV3IEFycmF5KDMpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspbjx0Lmxlbmd0aD9lW25dPXRbbl06ZVtuXT10WzBdO3JldHVybiBlfWNvbXB1dGVPY3RQdHModCl7Y29uc3QgZT1uZXcgQXJyYXkoOCkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPGUubGVuZ3RoO24rKyllW25dPXRbMF07Zm9yKGxldCBuPTE7bjx0Lmxlbmd0aDtuKyspdFtuXS54PGVbMF0ueCYmKGVbMF09dFtuXSksdFtuXS54LXRbbl0ueTxlWzFdLngtZVsxXS55JiYoZVsxXT10W25dKSx0W25dLnk+ZVsyXS55JiYoZVsyXT10W25dKSx0W25dLngrdFtuXS55PmVbM10ueCtlWzNdLnkmJihlWzNdPXRbbl0pLHRbbl0ueD5lWzRdLngmJihlWzRdPXRbbl0pLHRbbl0ueC10W25dLnk+ZVs1XS54LWVbNV0ueSYmKGVbNV09dFtuXSksdFtuXS55PGVbNl0ueSYmKGVbNl09dFtuXSksdFtuXS54K3Rbbl0ueTxlWzddLngrZVs3XS55JiYoZVs3XT10W25dKTtyZXR1cm4gZX10b0Nvb3JkaW5hdGVBcnJheSh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IG49MDtuPHQuc2l6ZSgpO24rKyl7Y29uc3Qgcz10LmdldChuKTtlW25dPXN9cmV0dXJuIGV9Z3JhaGFtU2Nhbih0KXtsZXQgZT1udWxsO2NvbnN0IG49bmV3IG9uO24ucHVzaCh0WzBdKSxuLnB1c2godFsxXSksbi5wdXNoKHRbMl0pO2ZvcihsZXQgcz0zO3M8dC5sZW5ndGg7cysrKXtmb3IoZT1uLnBvcCgpOyFuLmVtcHR5KCkmJnYuaW5kZXgobi5wZWVrKCksZSx0W3NdKT4wOyllPW4ucG9wKCk7bi5wdXNoKGUpLG4ucHVzaCh0W3NdKX1yZXR1cm4gbi5wdXNoKHRbMF0pLG59Z2V0Q2xhc3MoKXtyZXR1cm4gYW59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIGNue2NvbnN0cnVjdG9yKCl7Y24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgcG9sYXJDb21wYXJlKHQsZSxuKXtjb25zdCBzPWUueC10LngsaT1lLnktdC55LHI9bi54LXQueCxvPW4ueS10LnksbD12LmluZGV4KHQsZSxuKTtpZihsPT09di5DT1VOVEVSQ0xPQ0tXSVNFKXJldHVybiAxO2lmKGw9PT12LkNMT0NLV0lTRSlyZXR1cm4tMTtjb25zdCBhPXMqcytpKmksYz1yKnIrbypvO3JldHVybiBhPGM/LTE6YT5jPzE6MH1jb21wYXJlKHQsZSl7Y29uc3Qgbj10LHM9ZTtyZXR1cm4gY24ucG9sYXJDb21wYXJlKHRoaXMuX29yaWdpbixuLHMpfWdldENsYXNzKCl7cmV0dXJuIGNufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltsXX19Y24uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fb3JpZ2luPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fb3JpZ2luPXR9LGFuLlJhZGlhbENvbXBhcmF0b3I9Y24sYW4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fZ2VvbUZhY3Rvcnk9bnVsbCx0aGlzLl9pbnB1dFB0cz1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTthbi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLGFuLmV4dHJhY3RDb29yZGluYXRlcyh0KSx0LmdldEZhY3RvcnkoKSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faW5wdXRQdHM9bG4uZmlsdGVyQ29vcmRpbmF0ZXModCksdGhpcy5fZ2VvbUZhY3Rvcnk9ZX19O2NsYXNzIGhue2NvbnN0cnVjdG9yKCl7aG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgY2VudHJlKHQpe3JldHVybiBuZXcgZyhobi5hdmcodC5nZXRNaW5YKCksdC5nZXRNYXhYKCkpLGhuLmF2Zyh0LmdldE1pblkoKSx0LmdldE1heFkoKSkpfXN0YXRpYyBhdmcodCxlKXtyZXR1cm4odCtlKS8yfWFkZFBvbHlnb24odCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7bGV0IGU9bnVsbCxuPW51bGw7Y29uc3Qgcz10aGlzLmhvcml6b250YWxCaXNlY3Rvcih0KTtpZigwPT09cy5nZXRMZW5ndGgoKSluPTAsZT1zLmdldENvb3JkaW5hdGUoKTtlbHNle2NvbnN0IGk9cy5pbnRlcnNlY3Rpb24odCkscj10aGlzLndpZGVzdEdlb21ldHJ5KGkpO249ci5nZXRFbnZlbG9wZUludGVybmFsKCkuZ2V0V2lkdGgoKSxlPWhuLmNlbnRyZShyLmdldEVudmVsb3BlSW50ZXJuYWwoKSl9KG51bGw9PT10aGlzLl9pbnRlcmlvclBvaW50fHxuPnRoaXMuX21heFdpZHRoKSYmKHRoaXMuX2ludGVyaW9yUG9pbnQ9ZSx0aGlzLl9tYXhXaWR0aD1uKX1nZXRJbnRlcmlvclBvaW50KCl7cmV0dXJuIHRoaXMuX2ludGVyaW9yUG9pbnR9d2lkZXN0R2VvbWV0cnkoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIF90KXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gdDtsZXQgZT10LmdldEdlb21ldHJ5TigwKTtmb3IobGV0IG49MTtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl0LmdldEdlb21ldHJ5TihuKS5nZXRFbnZlbG9wZUludGVybmFsKCkuZ2V0V2lkdGgoKT5lLmdldEVudmVsb3BlSW50ZXJuYWwoKS5nZXRXaWR0aCgpJiYoZT10LmdldEdlb21ldHJ5TihuKSk7cmV0dXJuIGV9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdCBpbnN0YW5jZW9mIF90P3RoaXMud2lkZXN0R2VvbWV0cnkodCk6dH19aG9yaXpvbnRhbEJpc2VjdG9yKHQpe2NvbnN0IGU9dC5nZXRFbnZlbG9wZUludGVybmFsKCksbj11bi5nZXRCaXNlY3RvclkodCk7cmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhbbmV3IGcoZS5nZXRNaW5YKCksbiksbmV3IGcoZS5nZXRNYXhYKCksbildKX1hZGQodCl7aWYodCBpbnN0YW5jZW9mIGJ0KXRoaXMuYWRkUG9seWdvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBfdCl7Y29uc3QgZT10O2ZvcihsZXQgdD0wO3Q8ZS5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXRoaXMuYWRkKGUuZ2V0R2VvbWV0cnlOKHQpKX19Z2V0Q2xhc3MoKXtyZXR1cm4gaG59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIHVue2NvbnN0cnVjdG9yKCl7dW4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZ2V0QmlzZWN0b3JZKHQpe3JldHVybiBuZXcgdW4odCkuZ2V0QmlzZWN0b3JZKCl9dXBkYXRlSW50ZXJ2YWwodCl7dDw9dGhpcy5fY2VudHJlWT90PnRoaXMuX2xvWSYmKHRoaXMuX2xvWT10KTp0PnRoaXMuX2NlbnRyZVkmJnQ8dGhpcy5faGlZJiYodGhpcy5faGlZPXQpfWdldEJpc2VjdG9yWSgpe3RoaXMucHJvY2Vzcyh0aGlzLl9wb2x5LmdldEV4dGVyaW9yUmluZygpKTtmb3IobGV0IHQ9MDt0PHRoaXMuX3BvbHkuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7dCsrKXRoaXMucHJvY2Vzcyh0aGlzLl9wb2x5LmdldEludGVyaW9yUmluZ04odCkpO3JldHVybiBobi5hdmcodGhpcy5faGlZLHRoaXMuX2xvWSl9cHJvY2Vzcyh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCk7Zm9yKGxldCB0PTA7dDxlLnNpemUoKTt0Kyspe2NvbnN0IG49ZS5nZXRZKHQpO3RoaXMudXBkYXRlSW50ZXJ2YWwobil9fWdldENsYXNzKCl7cmV0dXJuIHVufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX11bi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9wb2x5PW51bGwsdGhpcy5fY2VudHJlWT1udWxsLHRoaXMuX2hpWT1pLk1BWF9WQUxVRSx0aGlzLl9sb1k9LWkuTUFYX1ZBTFVFO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3BvbHk9dCx0aGlzLl9oaVk9dC5nZXRFbnZlbG9wZUludGVybmFsKCkuZ2V0TWF4WSgpLHRoaXMuX2xvWT10LmdldEVudmVsb3BlSW50ZXJuYWwoKS5nZXRNaW5ZKCksdGhpcy5fY2VudHJlWT1obi5hdmcodGhpcy5fbG9ZLHRoaXMuX2hpWSl9LGhuLlNhZmVCaXNlY3RvckZpbmRlcj11bixobi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9mYWN0b3J5PW51bGwsdGhpcy5faW50ZXJpb3JQb2ludD1udWxsLHRoaXMuX21heFdpZHRoPTA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZmFjdG9yeT10LmdldEZhY3RvcnkoKSx0aGlzLmFkZCh0KX07Y2xhc3MgZ257Y29uc3RydWN0b3IoKXtnbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWFkZEVuZHBvaW50cygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodCBpbnN0YW5jZW9mIFR0KXRoaXMuYWRkRW5kcG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7ZWxzZSBpZih0IGluc3RhbmNlb2YgX3Qpe2NvbnN0IGU9dDtmb3IobGV0IHQ9MDt0PGUuZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl0aGlzLmFkZEVuZHBvaW50cyhlLmdldEdlb21ldHJ5Tih0KSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5hZGQodFswXSksdGhpcy5hZGQodFt0Lmxlbmd0aC0xXSl9fWdldEludGVyaW9yUG9pbnQoKXtyZXR1cm4gdGhpcy5faW50ZXJpb3JQb2ludH1hZGRJbnRlcmlvcigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodCBpbnN0YW5jZW9mIFR0KXRoaXMuYWRkSW50ZXJpb3IodC5nZXRDb29yZGluYXRlcygpKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBfdCl7Y29uc3QgZT10O2ZvcihsZXQgdD0wO3Q8ZS5nZXROdW1HZW9tZXRyaWVzKCk7dCsrKXRoaXMuYWRkSW50ZXJpb3IoZS5nZXRHZW9tZXRyeU4odCkpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0xO2U8dC5sZW5ndGgtMTtlKyspdGhpcy5hZGQodFtlXSl9fWFkZCh0KXtjb25zdCBlPXQuZGlzdGFuY2UodGhpcy5fY2VudHJvaWQpO2U8dGhpcy5fbWluRGlzdGFuY2UmJih0aGlzLl9pbnRlcmlvclBvaW50PW5ldyBnKHQpLHRoaXMuX21pbkRpc3RhbmNlPWUpfWdldENsYXNzKCl7cmV0dXJuIGdufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1nbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9jZW50cm9pZD1udWxsLHRoaXMuX21pbkRpc3RhbmNlPWkuTUFYX1ZBTFVFLHRoaXMuX2ludGVyaW9yUG9pbnQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0LmlzRW1wdHkoKT90aGlzLl9jZW50cm9pZD1uZXcgZzp0aGlzLl9jZW50cm9pZD1zbi5nZXRDZW50cm9pZCh0KSx0aGlzLmFkZEludGVyaW9yKHQpLG51bGw9PT10aGlzLl9pbnRlcmlvclBvaW50JiZ0aGlzLmFkZEVuZHBvaW50cyh0KX07Y2xhc3MgZG57Y29uc3RydWN0b3IoKXtkbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldEludGVyaW9yUG9pbnQoKXtyZXR1cm4gdGhpcy5faW50ZXJpb3JQb2ludH1hZGQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHQgaW5zdGFuY2VvZiBQdCl0aGlzLmFkZCh0LmdldENvb3JkaW5hdGUoKSk7ZWxzZSBpZih0IGluc3RhbmNlb2YgX3Qpe2NvbnN0IGU9dDtmb3IobGV0IHQ9MDt0PGUuZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl0aGlzLmFkZChlLmdldEdlb21ldHJ5Tih0KSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXQuZGlzdGFuY2UodGhpcy5fY2VudHJvaWQpO2U8dGhpcy5fbWluRGlzdGFuY2UmJih0aGlzLl9pbnRlcmlvclBvaW50PW5ldyBnKHQpLHRoaXMuX21pbkRpc3RhbmNlPWUpfX1nZXRDbGFzcygpe3JldHVybiBkbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZG4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fY2VudHJvaWQ9bnVsbCx0aGlzLl9taW5EaXN0YW5jZT1pLk1BWF9WQUxVRSx0aGlzLl9pbnRlcmlvclBvaW50PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fY2VudHJvaWQ9dC5nZXRDZW50cm9pZCgpLmdldENvb3JkaW5hdGUoKSx0aGlzLmFkZCh0KX07Y2xhc3MgX257Y29uc3RydWN0b3IoKXtfbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWxvY2F0ZUluUG9seWdvblJpbmcodCxlKXtyZXR1cm4gZS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyh0KT9XZS5sb2NhdGVJblJpbmcodCxlLmdldENvb3JkaW5hdGVzKCkpOm5lLkVYVEVSSU9SfWludGVyc2VjdHModCxlKXtyZXR1cm4gdGhpcy5sb2NhdGUodCxlKSE9PW5lLkVYVEVSSU9SfXVwZGF0ZUxvY2F0aW9uSW5mbyh0KXt0PT09bmUuSU5URVJJT1ImJih0aGlzLl9pc0luPSEwKSx0PT09bmUuQk9VTkRBUlkmJnRoaXMuX251bUJvdW5kYXJpZXMrK31jb21wdXRlTG9jYXRpb24odCxlKXtpZihlIGluc3RhbmNlb2YgUHQmJnRoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlT25Qb2ludCh0LGUpKSxlIGluc3RhbmNlb2YgVHQpdGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVPbkxpbmVTdHJpbmcodCxlKSk7ZWxzZSBpZihlIGluc3RhbmNlb2YgYnQpdGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVJblBvbHlnb24odCxlKSk7ZWxzZSBpZihlIGluc3RhbmNlb2YgZnQpe2NvbnN0IG49ZTtmb3IobGV0IGU9MDtlPG4uZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgcz1uLmdldEdlb21ldHJ5TihlKTt0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZU9uTGluZVN0cmluZyh0LHMpKX19ZWxzZSBpZihlIGluc3RhbmNlb2YgQXQpe2NvbnN0IG49ZTtmb3IobGV0IGU9MDtlPG4uZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgcz1uLmdldEdlb21ldHJ5TihlKTt0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZUluUG9seWdvbih0LHMpKX19ZWxzZSBpZihlIGluc3RhbmNlb2YgX3Qpe2NvbnN0IG49bmV3IEtlKGUpO2Zvcig7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO3MhPT1lJiZ0aGlzLmNvbXB1dGVMb2NhdGlvbih0LHMpfX19bG9jYXRlT25Qb2ludCh0LGUpe3JldHVybiBlLmdldENvb3JkaW5hdGUoKS5lcXVhbHMyRCh0KT9uZS5JTlRFUklPUjpuZS5FWFRFUklPUn1sb2NhdGVPbkxpbmVTdHJpbmcodCxlKXtpZighZS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyh0KSlyZXR1cm4gbmUuRVhURVJJT1I7Y29uc3Qgbj1lLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpO3JldHVybiBlLmlzQ2xvc2VkKCl8fCF0LmVxdWFscyhuLmdldENvb3JkaW5hdGUoMCkpJiYhdC5lcXVhbHMobi5nZXRDb29yZGluYXRlKG4uc2l6ZSgpLTEpKT9XZS5pc09uTGluZSh0LG4pP25lLklOVEVSSU9SOm5lLkVYVEVSSU9SOm5lLkJPVU5EQVJZfWxvY2F0ZUluUG9seWdvbih0LGUpe2lmKGUuaXNFbXB0eSgpKXJldHVybiBuZS5FWFRFUklPUjtjb25zdCBuPWUuZ2V0RXh0ZXJpb3JSaW5nKCkscz10aGlzLmxvY2F0ZUluUG9seWdvblJpbmcodCxuKTtpZihzPT09bmUuRVhURVJJT1IpcmV0dXJuIG5lLkVYVEVSSU9SO2lmKHM9PT1uZS5CT1VOREFSWSlyZXR1cm4gbmUuQk9VTkRBUlk7Zm9yKGxldCBuPTA7bjxlLmdldE51bUludGVyaW9yUmluZygpO24rKyl7Y29uc3Qgcz1lLmdldEludGVyaW9yUmluZ04obiksaT10aGlzLmxvY2F0ZUluUG9seWdvblJpbmcodCxzKTtpZihpPT09bmUuSU5URVJJT1IpcmV0dXJuIG5lLkVYVEVSSU9SO2lmKGk9PT1uZS5CT1VOREFSWSlyZXR1cm4gbmUuQk9VTkRBUll9cmV0dXJuIG5lLklOVEVSSU9SfWxvY2F0ZSh0LGUpe3JldHVybiBlLmlzRW1wdHkoKT9uZS5FWFRFUklPUjplIGluc3RhbmNlb2YgVHQ/dGhpcy5sb2NhdGVPbkxpbmVTdHJpbmcodCxlKTplIGluc3RhbmNlb2YgYnQ/dGhpcy5sb2NhdGVJblBvbHlnb24odCxlKToodGhpcy5faXNJbj0hMSx0aGlzLl9udW1Cb3VuZGFyaWVzPTAsdGhpcy5jb21wdXRlTG9jYXRpb24odCxlKSx0aGlzLl9ib3VuZGFyeVJ1bGUuaXNJbkJvdW5kYXJ5KHRoaXMuX251bUJvdW5kYXJpZXMpP25lLkJPVU5EQVJZOnRoaXMuX251bUJvdW5kYXJpZXM+MHx8dGhpcy5faXNJbj9uZS5JTlRFUklPUjpuZS5FWFRFUklPUil9Z2V0Q2xhc3MoKXtyZXR1cm4gX259Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fV9uLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2JvdW5kYXJ5UnVsZT1WLk9HQ19TRlNfQk9VTkRBUllfUlVMRSx0aGlzLl9pc0luPW51bGwsdGhpcy5fbnVtQm91bmRhcmllcz1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZihudWxsPT09dCl0aHJvdyBuZXcgbihcIlJ1bGUgbXVzdCBiZSBub24tbnVsbFwiKTt0aGlzLl9ib3VuZGFyeVJ1bGU9dH19O2NsYXNzIGZue2NvbnN0cnVjdG9yKCl7Zm4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgcG9pbnRXaXRNaW5BbmdsZVdpdGhYKHQsZSl7bGV0IG49aS5NQVhfVkFMVUUscz1udWxsO2ZvcihsZXQgaT0wO2k8dC5sZW5ndGg7aSsrKXtjb25zdCByPXRbaV07aWYocj09PWUpY29udGludWU7Y29uc3Qgbz1yLngtZS54O2xldCBsPXIueS1lLnk7bDwwJiYobD0tbCk7Y29uc3QgYT1sL01hdGguc3FydChvKm8rbCpsKTthPG4mJihuPWEscz1yKX1yZXR1cm4gc31zdGF0aWMgbG93ZXN0UG9pbnQodCl7bGV0IGU9dFswXTtmb3IobGV0IG49MTtuPHQubGVuZ3RoO24rKyl0W25dLnk8ZS55JiYoZT10W25dKTtyZXR1cm4gZX1zdGF0aWMgcG9pbnRXaXRoTWluQW5nbGVXaXRoU2VnbWVudCh0LGUsbil7bGV0IHM9aS5NQVhfVkFMVUUscj1udWxsO2ZvcihsZXQgaT0wO2k8dC5sZW5ndGg7aSsrKXtjb25zdCBvPXRbaV07aWYobz09PWUpY29udGludWU7aWYobz09PW4pY29udGludWU7Y29uc3QgbD1pZS5hbmdsZUJldHdlZW4oZSxvLG4pO2w8cyYmKHM9bCxyPW8pfXJldHVybiByfWdldFJhZGl1cygpe3JldHVybiB0aGlzLmNvbXB1dGUoKSx0aGlzLl9yYWRpdXN9Z2V0RGlhbWV0ZXIoKXtzd2l0Y2godGhpcy5jb21wdXRlKCksdGhpcy5fZXh0cmVtYWxQdHMubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKCk7Y2FzZSAxOnJldHVybiB0aGlzLl9pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5fY2VudHJlKX1jb25zdCB0PXRoaXMuX2V4dHJlbWFsUHRzWzBdLGU9dGhpcy5fZXh0cmVtYWxQdHNbMV07cmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKFt0LGVdKX1nZXRFeHRyZW1hbFBvaW50cygpe3JldHVybiB0aGlzLmNvbXB1dGUoKSx0aGlzLl9leHRyZW1hbFB0c31jb21wdXRlQ2lyY2xlUG9pbnRzKCl7aWYodGhpcy5faW5wdXQuaXNFbXB0eSgpKXJldHVybiB0aGlzLl9leHRyZW1hbFB0cz1uZXcgQXJyYXkoMCkuZmlsbChudWxsKSxudWxsO2lmKDE9PT10aGlzLl9pbnB1dC5nZXROdW1Qb2ludHMoKSl7Y29uc3QgdD10aGlzLl9pbnB1dC5nZXRDb29yZGluYXRlcygpO3JldHVybiB0aGlzLl9leHRyZW1hbFB0cz1bbmV3IGcodFswXSldLG51bGx9Y29uc3QgdD10aGlzLl9pbnB1dC5jb252ZXhIdWxsKCkuZ2V0Q29vcmRpbmF0ZXMoKTtsZXQgZT10O2lmKHRbMF0uZXF1YWxzMkQodFt0Lmxlbmd0aC0xXSkmJihlPW5ldyBBcnJheSh0Lmxlbmd0aC0xKS5maWxsKG51bGwpLFguY29weURlZXAodCwwLGUsMCx0Lmxlbmd0aC0xKSksZS5sZW5ndGg8PTIpcmV0dXJuIHRoaXMuX2V4dHJlbWFsUHRzPVguY29weURlZXAoZSksbnVsbDtsZXQgbj1mbi5sb3dlc3RQb2ludChlKSxzPWZuLnBvaW50V2l0TWluQW5nbGVXaXRoWChlLG4pO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtjb25zdCB0PWZuLnBvaW50V2l0aE1pbkFuZ2xlV2l0aFNlZ21lbnQoZSxuLHMpO2lmKGllLmlzT2J0dXNlKG4sdCxzKSlyZXR1cm4gdGhpcy5fZXh0cmVtYWxQdHM9W25ldyBnKG4pLG5ldyBnKHMpXSxudWxsO2lmKGllLmlzT2J0dXNlKHQsbixzKSluPXQ7ZWxzZXtpZighaWUuaXNPYnR1c2UodCxzLG4pKXJldHVybiB0aGlzLl9leHRyZW1hbFB0cz1bbmV3IGcobiksbmV3IGcocyksbmV3IGcodCldLG51bGw7cz10fX11LnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiTG9naWMgZmFpbHVyZSBpbiBNaW5pbXVtIEJvdW5kaW5nIENpcmNsZSBhbGdvcml0aG0hXCIpfWNvbXB1dGUoKXtpZihudWxsIT09dGhpcy5fZXh0cmVtYWxQdHMpcmV0dXJuIG51bGw7dGhpcy5jb21wdXRlQ2lyY2xlUG9pbnRzKCksdGhpcy5jb21wdXRlQ2VudHJlKCksbnVsbCE9PXRoaXMuX2NlbnRyZSYmKHRoaXMuX3JhZGl1cz10aGlzLl9jZW50cmUuZGlzdGFuY2UodGhpcy5fZXh0cmVtYWxQdHNbMF0pKX1nZXRGYXJ0aGVzdFBvaW50cygpe3N3aXRjaCh0aGlzLmNvbXB1dGUoKSx0aGlzLl9leHRyZW1hbFB0cy5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gdGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoKTtjYXNlIDE6cmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLl9jZW50cmUpfWNvbnN0IHQ9dGhpcy5fZXh0cmVtYWxQdHNbMF0sZT10aGlzLl9leHRyZW1hbFB0c1t0aGlzLl9leHRyZW1hbFB0cy5sZW5ndGgtMV07cmV0dXJuIHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKFt0LGVdKX1nZXRDaXJjbGUoKXtpZih0aGlzLmNvbXB1dGUoKSxudWxsPT09dGhpcy5fY2VudHJlKXJldHVybiB0aGlzLl9pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlUG9seWdvbigpO2NvbnN0IHQ9dGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMuX2NlbnRyZSk7cmV0dXJuIDA9PT10aGlzLl9yYWRpdXM/dDp0LmJ1ZmZlcih0aGlzLl9yYWRpdXMpfWdldENlbnRyZSgpe3JldHVybiB0aGlzLmNvbXB1dGUoKSx0aGlzLl9jZW50cmV9Y29tcHV0ZUNlbnRyZSgpe3N3aXRjaCh0aGlzLl9leHRyZW1hbFB0cy5sZW5ndGgpe2Nhc2UgMDp0aGlzLl9jZW50cmU9bnVsbDticmVhaztjYXNlIDE6dGhpcy5fY2VudHJlPXRoaXMuX2V4dHJlbWFsUHRzWzBdO2JyZWFrO2Nhc2UgMjp0aGlzLl9jZW50cmU9bmV3IGcoKHRoaXMuX2V4dHJlbWFsUHRzWzBdLngrdGhpcy5fZXh0cmVtYWxQdHNbMV0ueCkvMiwodGhpcy5fZXh0cmVtYWxQdHNbMF0ueSt0aGlzLl9leHRyZW1hbFB0c1sxXS55KS8yKTticmVhaztjYXNlIDM6dGhpcy5fY2VudHJlPXJlLmNpcmN1bWNlbnRyZSh0aGlzLl9leHRyZW1hbFB0c1swXSx0aGlzLl9leHRyZW1hbFB0c1sxXSx0aGlzLl9leHRyZW1hbFB0c1syXSl9fWdldENsYXNzKCl7cmV0dXJuIGZufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1mbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pbnB1dD1udWxsLHRoaXMuX2V4dHJlbWFsUHRzPW51bGwsdGhpcy5fY2VudHJlPW51bGwsdGhpcy5fcmFkaXVzPTA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXQ9dH07Y2xhc3MgcG57Y29uc3RydWN0b3IoKXtwbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBuZXh0SW5kZXgodCxlKXtyZXR1cm4rK2U+PXQubGVuZ3RoJiYoZT0wKSxlfXN0YXRpYyBjb21wdXRlQyh0LGUsbil7cmV0dXJuIHQqbi55LWUqbi54fXN0YXRpYyBnZXRNaW5pbXVtRGlhbWV0ZXIodCl7cmV0dXJuIG5ldyBwbih0KS5nZXREaWFtZXRlcigpfXN0YXRpYyBnZXRNaW5pbXVtUmVjdGFuZ2xlKHQpe3JldHVybiBuZXcgcG4odCkuZ2V0TWluaW11bVJlY3RhbmdsZSgpfXN0YXRpYyBjb21wdXRlU2VnbWVudEZvckxpbmUodCxlLG4pe2xldCBzPW51bGwsaT1udWxsO3JldHVybiBNYXRoLmFicyhlKT5NYXRoLmFicyh0KT8ocz1uZXcgZygwLG4vZSksaT1uZXcgZygxLG4vZS10L2UpKToocz1uZXcgZyhuL3QsMCksaT1uZXcgZyhuL3QtZS90LDEpKSxuZXcgZWUocyxpKX1nZXRXaWR0aENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksdGhpcy5fbWluV2lkdGhQdH1nZXRTdXBwb3J0aW5nU2VnbWVudCgpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSx0aGlzLl9pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoW3RoaXMuX21pbkJhc2VTZWcucDAsdGhpcy5fbWluQmFzZVNlZy5wMV0pfWdldERpYW1ldGVyKCl7aWYodGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksbnVsbD09PXRoaXMuX21pbldpZHRoUHQpcmV0dXJuIHRoaXMuX2lucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZygpO2NvbnN0IHQ9dGhpcy5fbWluQmFzZVNlZy5wcm9qZWN0KHRoaXMuX21pbldpZHRoUHQpO3JldHVybiB0aGlzLl9pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoW3QsdGhpcy5fbWluV2lkdGhQdF0pfWNvbXB1dGVXaWR0aENvbnZleCh0KXt0aGlzLl9jb252ZXhIdWxsUHRzPXQgaW5zdGFuY2VvZiBidD90LmdldEV4dGVyaW9yUmluZygpLmdldENvb3JkaW5hdGVzKCk6dC5nZXRDb29yZGluYXRlcygpLDA9PT10aGlzLl9jb252ZXhIdWxsUHRzLmxlbmd0aD8odGhpcy5fbWluV2lkdGg9MCx0aGlzLl9taW5XaWR0aFB0PW51bGwsdGhpcy5fbWluQmFzZVNlZz1udWxsKToxPT09dGhpcy5fY29udmV4SHVsbFB0cy5sZW5ndGg/KHRoaXMuX21pbldpZHRoPTAsdGhpcy5fbWluV2lkdGhQdD10aGlzLl9jb252ZXhIdWxsUHRzWzBdLHRoaXMuX21pbkJhc2VTZWcucDA9dGhpcy5fY29udmV4SHVsbFB0c1swXSx0aGlzLl9taW5CYXNlU2VnLnAxPXRoaXMuX2NvbnZleEh1bGxQdHNbMF0pOjI9PT10aGlzLl9jb252ZXhIdWxsUHRzLmxlbmd0aHx8Mz09PXRoaXMuX2NvbnZleEh1bGxQdHMubGVuZ3RoPyh0aGlzLl9taW5XaWR0aD0wLHRoaXMuX21pbldpZHRoUHQ9dGhpcy5fY29udmV4SHVsbFB0c1swXSx0aGlzLl9taW5CYXNlU2VnLnAwPXRoaXMuX2NvbnZleEh1bGxQdHNbMF0sdGhpcy5fbWluQmFzZVNlZy5wMT10aGlzLl9jb252ZXhIdWxsUHRzWzFdKTp0aGlzLmNvbXB1dGVDb252ZXhSaW5nTWluRGlhbWV0ZXIodGhpcy5fY29udmV4SHVsbFB0cyl9Y29tcHV0ZUNvbnZleFJpbmdNaW5EaWFtZXRlcih0KXt0aGlzLl9taW5XaWR0aD1pLk1BWF9WQUxVRTtsZXQgZT0xO2NvbnN0IG49bmV3IGVlO2ZvcihsZXQgcz0wO3M8dC5sZW5ndGgtMTtzKyspbi5wMD10W3NdLG4ucDE9dFtzKzFdLGU9dGhpcy5maW5kTWF4UGVycERpc3RhbmNlKHQsbixlKX1jb21wdXRlTWluaW11bURpYW1ldGVyKCl7aWYobnVsbCE9PXRoaXMuX21pbldpZHRoUHQpcmV0dXJuIG51bGw7aWYodGhpcy5faXNDb252ZXgpdGhpcy5jb21wdXRlV2lkdGhDb252ZXgodGhpcy5faW5wdXRHZW9tKTtlbHNle2NvbnN0IHQ9bmV3IGFuKHRoaXMuX2lucHV0R2VvbSkuZ2V0Q29udmV4SHVsbCgpO3RoaXMuY29tcHV0ZVdpZHRoQ29udmV4KHQpfX1nZXRMZW5ndGgoKXtyZXR1cm4gdGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksdGhpcy5fbWluV2lkdGh9ZmluZE1heFBlcnBEaXN0YW5jZSh0LGUsbil7bGV0IHM9ZS5kaXN0YW5jZVBlcnBlbmRpY3VsYXIodFtuXSksaT1zLHI9bixvPXI7Zm9yKDtpPj1zOylzPWkscj1vLG89cG4ubmV4dEluZGV4KHQsciksaT1lLmRpc3RhbmNlUGVycGVuZGljdWxhcih0W29dKTtyZXR1cm4gczx0aGlzLl9taW5XaWR0aCYmKHRoaXMuX21pblB0SW5kZXg9cix0aGlzLl9taW5XaWR0aD1zLHRoaXMuX21pbldpZHRoUHQ9dFt0aGlzLl9taW5QdEluZGV4XSx0aGlzLl9taW5CYXNlU2VnPW5ldyBlZShlKSkscn1nZXRNaW5pbXVtUmVjdGFuZ2xlKCl7aWYodGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksMD09PXRoaXMuX21pbldpZHRoKXJldHVybiB0aGlzLl9taW5CYXNlU2VnLnAwLmVxdWFsczJEKHRoaXMuX21pbkJhc2VTZWcucDEpP3RoaXMuX2lucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5fbWluQmFzZVNlZy5wMCk6dGhpcy5fbWluQmFzZVNlZy50b0dlb21ldHJ5KHRoaXMuX2lucHV0R2VvbS5nZXRGYWN0b3J5KCkpO2NvbnN0IHQ9dGhpcy5fbWluQmFzZVNlZy5wMS54LXRoaXMuX21pbkJhc2VTZWcucDAueCxlPXRoaXMuX21pbkJhc2VTZWcucDEueS10aGlzLl9taW5CYXNlU2VnLnAwLnk7bGV0IG49aS5NQVhfVkFMVUUscz0taS5NQVhfVkFMVUUscj1pLk1BWF9WQUxVRSxvPS1pLk1BWF9WQUxVRTtmb3IobGV0IGk9MDtpPHRoaXMuX2NvbnZleEh1bGxQdHMubGVuZ3RoO2krKyl7Y29uc3QgbD1wbi5jb21wdXRlQyh0LGUsdGhpcy5fY29udmV4SHVsbFB0c1tpXSk7bD5zJiYocz1sKSxsPG4mJihuPWwpO2NvbnN0IGE9cG4uY29tcHV0ZUMoLWUsdCx0aGlzLl9jb252ZXhIdWxsUHRzW2ldKTthPm8mJihvPWEpLGE8ciYmKHI9YSl9Y29uc3QgbD1wbi5jb21wdXRlU2VnbWVudEZvckxpbmUoLXQsLWUsbyksYT1wbi5jb21wdXRlU2VnbWVudEZvckxpbmUoLXQsLWUsciksYz1wbi5jb21wdXRlU2VnbWVudEZvckxpbmUoLWUsdCxzKSxoPXBuLmNvbXB1dGVTZWdtZW50Rm9yTGluZSgtZSx0LG4pLHU9Yy5saW5lSW50ZXJzZWN0aW9uKGwpLGc9aC5saW5lSW50ZXJzZWN0aW9uKGwpLGQ9aC5saW5lSW50ZXJzZWN0aW9uKGEpLF89Yy5saW5lSW50ZXJzZWN0aW9uKGEpLGY9dGhpcy5faW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKFt1LGcsZCxfLHVdKTtyZXR1cm4gdGhpcy5faW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVQb2x5Z29uKGYpfWdldENsYXNzKCl7cmV0dXJuIHBufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1wbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9pc0NvbnZleD1udWxsLHRoaXMuX2NvbnZleEh1bGxQdHM9bnVsbCx0aGlzLl9taW5CYXNlU2VnPW5ldyBlZSx0aGlzLl9taW5XaWR0aFB0PW51bGwsdGhpcy5fbWluUHRJbmRleD1udWxsLHRoaXMuX21pbldpZHRoPTAsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3BuLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCwhMSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faW5wdXRHZW9tPXQsdGhpcy5faXNDb252ZXg9ZX19O3ZhciBtbj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxkaXN0YW5jZTpEZSxsb2NhdGU6UWUsbWF0Y2g6bm4sQW5nbGU6aWUsQXJlYTp2dCxDZW50cm9pZDpzbixDb252ZXhIdWxsOmFuLERpc3RhbmNlOkQsSW50ZXJpb3JQb2ludEFyZWE6aG4sSW50ZXJpb3JQb2ludExpbmU6Z24sSW50ZXJpb3JQb2ludFBvaW50OmRuLExlbmd0aDp5dCxPcmllbnRhdGlvbjp2LFBvaW50TG9jYXRpb246V2UsUG9pbnRMb2NhdG9yOl9uLFJvYnVzdExpbmVJbnRlcnNlY3Rvcjp0ZSxNaW5pbXVtQm91bmRpbmdDaXJjbGU6Zm4sTWluaW11bURpYW1ldGVyOnBufSk7Y2xhc3MgeW57Y29uc3RydWN0b3IoKXt5bi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBkZW5zaWZ5UG9pbnRzKHQsZSxuKXtjb25zdCBzPW5ldyBlZSxpPW5ldyBJO2ZvcihsZXQgcj0wO3I8dC5sZW5ndGgtMTtyKyspe3MucDA9dFtyXSxzLnAxPXRbcisxXSxpLmFkZChzLnAwLCExKTtjb25zdCBvPXMuZ2V0TGVuZ3RoKCksbD1NYXRoLnRydW5jKG8vZSkrMTtpZihsPjEpe2NvbnN0IHQ9by9sO2ZvcihsZXQgZT0xO2U8bDtlKyspe2NvbnN0IHI9ZSp0L28sbD1zLnBvaW50QWxvbmcocik7bi5tYWtlUHJlY2lzZShsKSxpLmFkZChsLCExKX19fXJldHVybiBpLmFkZCh0W3QubGVuZ3RoLTFdLCExKSxpLnRvQ29vcmRpbmF0ZUFycmF5KCl9c3RhdGljIGRlbnNpZnkodCxlKXtjb25zdCBuPW5ldyB5bih0KTtyZXR1cm4gbi5zZXREaXN0YW5jZVRvbGVyYW5jZShlKSxuLmdldFJlc3VsdEdlb21ldHJ5KCl9Z2V0UmVzdWx0R2VvbWV0cnkoKXtyZXR1cm4gbmV3IHhuKHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlKS50cmFuc2Zvcm0odGhpcy5faW5wdXRHZW9tKX1zZXREaXN0YW5jZVRvbGVyYW5jZSh0KXtpZih0PD0wKXRocm93IG5ldyBuKFwiVG9sZXJhbmNlIG11c3QgYmUgcG9zaXRpdmVcIik7dGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9dH1nZXRDbGFzcygpe3JldHVybiB5bn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3MgeG4gZXh0ZW5kcyBtZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCkseG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX10cmFuc2Zvcm1NdWx0aVBvbHlnb24odCxlKXtjb25zdCBuPXN1cGVyLnRyYW5zZm9ybU11bHRpUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gdGhpcy5jcmVhdGVWYWxpZEFyZWEobil9dHJhbnNmb3JtUG9seWdvbih0LGUpe2NvbnN0IG49c3VwZXIudHJhbnNmb3JtUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gZSBpbnN0YW5jZW9mIEF0P246dGhpcy5jcmVhdGVWYWxpZEFyZWEobil9dHJhbnNmb3JtQ29vcmRpbmF0ZXModCxlKXtjb25zdCBuPXQudG9Db29yZGluYXRlQXJyYXkoKTtsZXQgcz15bi5kZW5zaWZ5UG9pbnRzKG4sdGhpcy5kaXN0YW5jZVRvbGVyYW5jZSxlLmdldFByZWNpc2lvbk1vZGVsKCkpO3JldHVybiBlIGluc3RhbmNlb2YgVHQmJjE9PT1zLmxlbmd0aCYmKHM9bmV3IEFycmF5KDApLmZpbGwobnVsbCkpLHRoaXMuX2ZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShzKX1jcmVhdGVWYWxpZEFyZWEodCl7cmV0dXJuIHQuYnVmZmVyKDApfWdldENsYXNzKCl7cmV0dXJuIHhufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX14bi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5kaXN0YW5jZVRvbGVyYW5jZT10fSx5bi5EZW5zaWZ5VHJhbnNmb3JtZXI9eG4seW4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dEdlb209dH07dmFyIEVuPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLERlbnNpZmllcjp5bn0pO2NsYXNzIElue2NvbnN0cnVjdG9yKCl7SW4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaXNOb3J0aGVybih0KXtyZXR1cm4gdD09PUluLk5FfHx0PT09SW4uTld9c3RhdGljIGlzT3Bwb3NpdGUodCxlKXtpZih0PT09ZSlyZXR1cm4hMTtyZXR1cm4gMj09PSh0LWUrNCklNH1zdGF0aWMgY29tbW9uSGFsZlBsYW5lKHQsZSl7aWYodD09PWUpcmV0dXJuIHQ7aWYoMj09PSh0LWUrNCklNClyZXR1cm4tMTtjb25zdCBuPXQ8ZT90OmU7cmV0dXJuIDA9PT1uJiYzPT09KHQ+ZT90OmUpPzM6bn1zdGF0aWMgaXNJbkhhbGZQbGFuZSh0LGUpe3JldHVybiBlPT09SW4uU0U/dD09PUluLlNFfHx0PT09SW4uU1c6dD09PWV8fHQ9PT1lKzF9c3RhdGljIHF1YWRyYW50KCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoMD09PXQmJjA9PT1lKXRocm93IG5ldyBuKFwiQ2Fubm90IGNvbXB1dGUgdGhlIHF1YWRyYW50IGZvciBwb2ludCAoIFwiK3QrXCIsIFwiK2UrXCIgKVwiKTtyZXR1cm4gdD49MD9lPj0wP0luLk5FOkluLlNFOmU+PTA/SW4uTlc6SW4uU1d9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKGUueD09PXQueCYmZS55PT09dC55KXRocm93IG5ldyBuKFwiQ2Fubm90IGNvbXB1dGUgdGhlIHF1YWRyYW50IGZvciB0d28gaWRlbnRpY2FsIHBvaW50cyBcIit0KTtyZXR1cm4gZS54Pj10Lng/ZS55Pj10Lnk/SW4uTkU6SW4uU0U6ZS55Pj10Lnk/SW4uTlc6SW4uU1d9fWdldENsYXNzKCl7cmV0dXJuIElufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Jbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LEluLk5FPTAsSW4uTlc9MSxJbi5TVz0yLEluLlNFPTM7Y2xhc3MgTm57Y29uc3RydWN0b3IoKXtObi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpbml0KHQsZSl7aWYobnVsbCE9PXQuX3N5bXx8bnVsbCE9PWUuX3N5bXx8bnVsbCE9PXQuX25leHR8fG51bGwhPT1lLl9uZXh0KXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJFZGdlcyBhcmUgYWxyZWFkeSBpbml0aWFsaXplZFwiKTtyZXR1cm4gdC5pbml0KGUpLHR9c3RhdGljIGNyZWF0ZSh0LGUpe2NvbnN0IG49bmV3IE5uKHQpLHM9bmV3IE5uKGUpO3JldHVybiBuLmluaXQocyksbn1maW5kKHQpe2xldCBlPXRoaXM7ZG97aWYobnVsbD09PWUpcmV0dXJuIG51bGw7aWYoZS5kZXN0KCkuZXF1YWxzMkQodCkpcmV0dXJuIGU7ZT1lLm9OZXh0KCl9d2hpbGUoZSE9PXRoaXMpO3JldHVybiBudWxsfWRlc3QoKXtyZXR1cm4gdGhpcy5fc3ltLl9vcmlnfW9OZXh0KCl7cmV0dXJuIHRoaXMuX3N5bS5fbmV4dH1pbnNlcnQodCl7aWYodGhpcy5vTmV4dCgpPT09dGhpcylyZXR1cm4gdGhpcy5pbnNlcnRBZnRlcih0KSxudWxsO2NvbnN0IGU9dGhpcy5jb21wYXJlVG8odCk7bGV0IG49dGhpcztkb3tjb25zdCBzPW4ub05leHQoKTtpZihzLmNvbXBhcmVUbyh0KSE9PWV8fHM9PT10aGlzKXJldHVybiBuLmluc2VydEFmdGVyKHQpLG51bGw7bj1zfXdoaWxlKG4hPT10aGlzKTt1LnNob3VsZE5ldmVyUmVhY2hIZXJlKCl9aW5zZXJ0QWZ0ZXIodCl7dS5lcXVhbHModGhpcy5fb3JpZyx0Lm9yaWcoKSk7Y29uc3QgZT10aGlzLm9OZXh0KCk7dGhpcy5fc3ltLnNldE5leHQodCksdC5zeW0oKS5zZXROZXh0KGUpfWRlZ3JlZSgpe2xldCB0PTAsZT10aGlzO2Rve3QrKyxlPWUub05leHQoKX13aGlsZShlIT09dGhpcyk7cmV0dXJuIHR9ZXF1YWxzKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5fb3JpZy5lcXVhbHMyRCh0KSYmdGhpcy5fc3ltLl9vcmlnLmVxdWFscyhlKX19ZGVsdGFZKCl7cmV0dXJuIHRoaXMuX3N5bS5fb3JpZy55LXRoaXMuX29yaWcueX1zeW0oKXtyZXR1cm4gdGhpcy5fc3ltfXByZXYoKXtyZXR1cm4gdGhpcy5fc3ltLm5leHQoKS5fc3ltfWNvbXBhcmVBbmd1bGFyRGlyZWN0aW9uKHQpe2NvbnN0IGU9dGhpcy5kZWx0YVgoKSxuPXRoaXMuZGVsdGFZKCkscz10LmRlbHRhWCgpLGk9dC5kZWx0YVkoKTtpZihlPT09cyYmbj09PWkpcmV0dXJuIDA7Y29uc3Qgcj1Jbi5xdWFkcmFudChlLG4pLG89SW4ucXVhZHJhbnQocyxpKTtyZXR1cm4gcj5vPzE6cjxvPy0xOnYuaW5kZXgodC5fb3JpZyx0LmRlc3QoKSx0aGlzLmRlc3QoKSl9cHJldk5vZGUoKXtsZXQgdD10aGlzO2Zvcig7Mj09PXQuZGVncmVlKCk7KWlmKHQ9dC5wcmV2KCksdD09PXRoaXMpcmV0dXJuIG51bGw7cmV0dXJuIHR9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5jb21wYXJlQW5ndWxhckRpcmVjdGlvbihlKX1uZXh0KCl7cmV0dXJuIHRoaXMuX25leHR9c2V0U3ltKHQpe3RoaXMuX3N5bT10fW9yaWcoKXtyZXR1cm4gdGhpcy5fb3JpZ310b1N0cmluZygpe3JldHVyblwiSEUoXCIrdGhpcy5fb3JpZy54K1wiIFwiK3RoaXMuX29yaWcueStcIiwgXCIrdGhpcy5fc3ltLl9vcmlnLngrXCIgXCIrdGhpcy5fc3ltLl9vcmlnLnkrXCIpXCJ9c2V0TmV4dCh0KXt0aGlzLl9uZXh0PXR9aW5pdCh0KXt0aGlzLnNldFN5bSh0KSx0LnNldFN5bSh0aGlzKSx0aGlzLnNldE5leHQodCksdC5zZXROZXh0KHRoaXMpfWRlbHRhWCgpe3JldHVybiB0aGlzLl9zeW0uX29yaWcueC10aGlzLl9vcmlnLnh9Z2V0Q2xhc3MoKXtyZXR1cm4gTm59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fU5uLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX29yaWc9bnVsbCx0aGlzLl9zeW09bnVsbCx0aGlzLl9uZXh0PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fb3JpZz10fTtjbGFzcyBDbiBleHRlbmRzIE5ue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxDbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBzZXRNYXJrQm90aCh0LGUpe3Quc2V0TWFyayhlKSx0LnN5bSgpLnNldE1hcmsoZSl9c3RhdGljIGlzTWFya2VkKHQpe3JldHVybiB0LmlzTWFya2VkKCl9c3RhdGljIHNldE1hcmsodCxlKXt0LnNldE1hcmsoZSl9c3RhdGljIG1hcmtCb3RoKHQpe3QubWFyaygpLHQuc3ltKCkubWFyaygpfXN0YXRpYyBtYXJrKHQpe3QubWFyaygpfW1hcmsoKXt0aGlzLl9pc01hcmtlZD0hMH1zZXRNYXJrKHQpe3RoaXMuX2lzTWFya2VkPXR9aXNNYXJrZWQoKXtyZXR1cm4gdGhpcy5faXNNYXJrZWR9Z2V0Q2xhc3MoKXtyZXR1cm4gQ259Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUNuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2lzTWFya2VkPSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdO05uLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9O2NsYXNzIFNue2NvbnN0cnVjdG9yKCl7U24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaXNWYWxpZEVkZ2UodCxlKXtyZXR1cm4gMCE9PWUuY29tcGFyZVRvKHQpfWluc2VydCh0LGUsbil7Y29uc3Qgcz10aGlzLmNyZWF0ZSh0LGUpO251bGwhPT1uP24uaW5zZXJ0KHMpOnRoaXMuX3ZlcnRleE1hcC5wdXQodCxzKTtjb25zdCBpPXRoaXMuX3ZlcnRleE1hcC5nZXQoZSk7cmV0dXJuIG51bGwhPT1pP2kuaW5zZXJ0KHMuc3ltKCkpOnRoaXMuX3ZlcnRleE1hcC5wdXQoZSxzLnN5bSgpKSxzfWNyZWF0ZSh0LGUpe2NvbnN0IG49dGhpcy5jcmVhdGVFZGdlKHQpLHM9dGhpcy5jcmVhdGVFZGdlKGUpO3JldHVybiBObi5pbml0KG4scyksbn1jcmVhdGVFZGdlKHQpe3JldHVybiBuZXcgTm4odCl9YWRkRWRnZSh0LGUpe2lmKCFTbi5pc1ZhbGlkRWRnZSh0LGUpKXJldHVybiBudWxsO2NvbnN0IG49dGhpcy5fdmVydGV4TWFwLmdldCh0KTtsZXQgcz1udWxsO2lmKG51bGwhPT1uJiYocz1uLmZpbmQoZSkpLG51bGwhPT1zKXJldHVybiBzO3JldHVybiB0aGlzLmluc2VydCh0LGUsbil9Z2V0VmVydGV4RWRnZXMoKXtyZXR1cm4gdGhpcy5fdmVydGV4TWFwLnZhbHVlcygpfWZpbmRFZGdlKHQsZSl7Y29uc3Qgbj10aGlzLl92ZXJ0ZXhNYXAuZ2V0KHQpO3JldHVybiBudWxsPT09bj9udWxsOm4uZmluZChlKX1nZXRDbGFzcygpe3JldHVybiBTbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19U24uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fdmVydGV4TWFwPW5ldyBVdH07Y2xhc3Mgd24gZXh0ZW5kcyBDbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksd24uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zZXRTdGFydCgpe3RoaXMuX2lzU3RhcnQ9ITB9aXNTdGFydCgpe3JldHVybiB0aGlzLl9pc1N0YXJ0fWdldENsYXNzKCl7cmV0dXJuIHdufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX13bi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pc1N0YXJ0PSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdO0NuLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9O2NsYXNzIExuIGV4dGVuZHMgU257Y29uc3RydWN0b3IoKXtzdXBlcigpLExuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y3JlYXRlRWRnZSh0KXtyZXR1cm4gbmV3IHduKHQpfWdldENsYXNzKCl7cmV0dXJuIExufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Mbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIFRue2NvbnN0cnVjdG9yKCl7VG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZGlzc29sdmUodCl7Y29uc3QgZT1uZXcgVG47cmV0dXJuIGUuYWRkKHQpLGUuZ2V0UmVzdWx0KCl9YWRkTGluZSh0KXt0aGlzLl9saW5lcy5hZGQodGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHQudG9Db29yZGluYXRlQXJyYXkoKSkpfXVwZGF0ZVJpbmdTdGFydEVkZ2UodCl7cmV0dXJuIHQuaXNTdGFydCgpfHwodD10LnN5bSgpKS5pc1N0YXJ0KCk/bnVsbD09PXRoaXMuX3JpbmdTdGFydEVkZ2U/KHRoaXMuX3JpbmdTdGFydEVkZ2U9dCxudWxsKTp2b2lkKHQub3JpZygpLmNvbXBhcmVUbyh0aGlzLl9yaW5nU3RhcnRFZGdlLm9yaWcoKSk8MCYmKHRoaXMuX3JpbmdTdGFydEVkZ2U9dCkpOm51bGx9Z2V0UmVzdWx0KCl7cmV0dXJuIG51bGw9PT10aGlzLl9yZXN1bHQmJnRoaXMuY29tcHV0ZVJlc3VsdCgpLHRoaXMuX3Jlc3VsdH1wcm9jZXNzKHQpe2xldCBlPXQucHJldk5vZGUoKTtudWxsPT09ZSYmKGU9dCksdGhpcy5zdGFja0VkZ2VzKGUpLHRoaXMuYnVpbGRMaW5lcygpfWJ1aWxkUmluZyh0KXtjb25zdCBlPW5ldyBJO2xldCBuPXQ7Zm9yKGUuYWRkKG4ub3JpZygpLmNvcHkoKSwhMSk7Mj09PW4uc3ltKCkuZGVncmVlKCk7KXtjb25zdCBzPW4ubmV4dCgpO2lmKHM9PT10KWJyZWFrO2UuYWRkKHMub3JpZygpLmNvcHkoKSwhMSksbj1zfWUuYWRkKG4uZGVzdCgpLmNvcHkoKSwhMSksdGhpcy5hZGRMaW5lKGUpfWJ1aWxkTGluZSh0KXtjb25zdCBlPW5ldyBJO2xldCBuPXQ7Zm9yKHRoaXMuX3JpbmdTdGFydEVkZ2U9bnVsbCxDbi5tYXJrQm90aChuKSxlLmFkZChuLm9yaWcoKS5jb3B5KCksITEpOzI9PT1uLnN5bSgpLmRlZ3JlZSgpOyl7dGhpcy51cGRhdGVSaW5nU3RhcnRFZGdlKG4pO2NvbnN0IHM9bi5uZXh0KCk7aWYocz09PXQpcmV0dXJuIHRoaXMuYnVpbGRSaW5nKHRoaXMuX3JpbmdTdGFydEVkZ2UpLG51bGw7ZS5hZGQocy5vcmlnKCkuY29weSgpLCExKSxuPXMsQ24ubWFya0JvdGgobil9ZS5hZGQobi5kZXN0KCkuY2xvbmUoKSwhMSksdGhpcy5zdGFja0VkZ2VzKG4uc3ltKCkpLHRoaXMuYWRkTGluZShlKX1zdGFja0VkZ2VzKHQpe2xldCBlPXQ7ZG97Q24uaXNNYXJrZWQoZSl8fHRoaXMuX25vZGVFZGdlU3RhY2suYWRkKGUpLGU9ZS5vTmV4dCgpfXdoaWxlKGUhPT10KX1jb21wdXRlUmVzdWx0KCl7Zm9yKGxldCB0PXRoaXMuX2dyYXBoLmdldFZlcnRleEVkZ2VzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7Q24uaXNNYXJrZWQoZSl8fHRoaXMucHJvY2VzcyhlKX10aGlzLl9yZXN1bHQ9dGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KHRoaXMuX2xpbmVzKX1idWlsZExpbmVzKCl7Zm9yKDshdGhpcy5fbm9kZUVkZ2VTdGFjay5lbXB0eSgpOyl7Y29uc3QgdD10aGlzLl9ub2RlRWRnZVN0YWNrLnBvcCgpO0NuLmlzTWFya2VkKHQpfHx0aGlzLmJ1aWxkTGluZSh0KX19YWRkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXthcmd1bWVudHNbMF0uYXBwbHkobmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVybltHXX1maWx0ZXIodCl7dCBpbnN0YW5jZW9mIFR0JiZ0aGlzLmFkZCh0KX19KX1lbHNlIGlmKF8oYXJndW1lbnRzWzBdLGYpKXtmb3IobGV0IHQ9YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3RoaXMuYWRkKGUpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO251bGw9PT10aGlzLl9mYWN0b3J5JiYodGhpcy5fZmFjdG9yeT10LmdldEZhY3RvcnkoKSk7Y29uc3QgZT10LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpO2xldCBuPSExO2ZvcihsZXQgdD0xO3Q8ZS5zaXplKCk7dCsrKXtjb25zdCBzPXRoaXMuX2dyYXBoLmFkZEVkZ2UoZS5nZXRDb29yZGluYXRlKHQtMSksZS5nZXRDb29yZGluYXRlKHQpKTtudWxsIT09cyYmKG58fChzLnNldFN0YXJ0KCksbj0hMCkpfX19Z2V0Q2xhc3MoKXtyZXR1cm4gVG59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVRuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3Jlc3VsdD1udWxsLHRoaXMuX2ZhY3Rvcnk9bnVsbCx0aGlzLl9ncmFwaD1udWxsLHRoaXMuX2xpbmVzPW5ldyB4LHRoaXMuX25vZGVFZGdlU3RhY2s9bmV3IG9uLHRoaXMuX3JpbmdTdGFydEVkZ2U9bnVsbCx0aGlzLl9ncmFwaD1uZXcgTG59O3ZhciBSbj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxMaW5lRGlzc29sdmVyOlRufSk7Y2xhc3MgUG57Y29uc3RydWN0b3IoKXtQbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBvcHBvc2l0ZSh0KXtyZXR1cm4gdD09PVBuLkxFRlQ/UG4uUklHSFQ6dD09PVBuLlJJR0hUP1BuLkxFRlQ6dH1nZXRDbGFzcygpe3JldHVybiBQbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19UG4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxQbi5PTj0wLFBuLkxFRlQ9MSxQbi5SSUdIVD0yO2NsYXNzIHZue2NvbnN0cnVjdG9yKCl7dm4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jb21wdXRlSW50ZXJzZWN0aW9ucyh0LGUpe3RoaXMubWNlLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4odGhpcy5jaGFpbkluZGV4LHQubWNlLHQuY2hhaW5JbmRleCxlKX1nZXRDbGFzcygpe3JldHVybiB2bn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19dm4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5tY2U9bnVsbCx0aGlzLmNoYWluSW5kZXg9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLm1jZT10LHRoaXMuY2hhaW5JbmRleD1lfTtjbGFzcyBPbntjb25zdHJ1Y3Rvcigpe09uLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNEZWxldGUoKXtyZXR1cm4gdGhpcy5fZXZlbnRUeXBlPT09T24uREVMRVRFfXNldERlbGV0ZUV2ZW50SW5kZXgodCl7dGhpcy5fZGVsZXRlRXZlbnRJbmRleD10fWdldE9iamVjdCgpe3JldHVybiB0aGlzLl9vYmp9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5feFZhbHVlPGUuX3hWYWx1ZT8tMTp0aGlzLl94VmFsdWU+ZS5feFZhbHVlPzE6dGhpcy5fZXZlbnRUeXBlPGUuX2V2ZW50VHlwZT8tMTp0aGlzLl9ldmVudFR5cGU+ZS5fZXZlbnRUeXBlPzE6MH1nZXRJbnNlcnRFdmVudCgpe3JldHVybiB0aGlzLl9pbnNlcnRFdmVudH1pc0luc2VydCgpe3JldHVybiB0aGlzLl9ldmVudFR5cGU9PT1Pbi5JTlNFUlR9aXNTYW1lTGFiZWwodCl7cmV0dXJuIG51bGwhPT10aGlzLl9sYWJlbCYmdGhpcy5fbGFiZWw9PT10Ll9sYWJlbH1nZXREZWxldGVFdmVudEluZGV4KCl7cmV0dXJuIHRoaXMuX2RlbGV0ZUV2ZW50SW5kZXh9Z2V0Q2xhc3MoKXtyZXR1cm4gT259Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3JdfX1Pbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9sYWJlbD1udWxsLHRoaXMuX3hWYWx1ZT1udWxsLHRoaXMuX2V2ZW50VHlwZT1udWxsLHRoaXMuX2luc2VydEV2ZW50PW51bGwsdGhpcy5fZGVsZXRlRXZlbnRJbmRleD1udWxsLHRoaXMuX29iaj1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9ldmVudFR5cGU9T24uREVMRVRFLHRoaXMuX3hWYWx1ZT10LHRoaXMuX2luc2VydEV2ZW50PWV9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fZXZlbnRUeXBlPU9uLklOU0VSVCx0aGlzLl9sYWJlbD10LHRoaXMuX3hWYWx1ZT1lLHRoaXMuX29iaj1ufX0sT24uSU5TRVJUPTEsT24uREVMRVRFPTI7Y2xhc3MgYm57Y29uc3RydWN0b3IoKXtibi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENsYXNzKCl7cmV0dXJuIGJufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1ibi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIE1ue2NvbnN0cnVjdG9yKCl7TW4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaXNBZGphY2VudFNlZ21lbnRzKHQsZSl7cmV0dXJuIDE9PT1NYXRoLmFicyh0LWUpfWlzVHJpdmlhbEludGVyc2VjdGlvbih0LGUsbixzKXtpZih0PT09biYmMT09PXRoaXMuX2xpLmdldEludGVyc2VjdGlvbk51bSgpKXtpZihNbi5pc0FkamFjZW50U2VnbWVudHMoZSxzKSlyZXR1cm4hMDtpZih0LmlzQ2xvc2VkKCkpe2NvbnN0IG49dC5nZXROdW1Qb2ludHMoKS0xO2lmKDA9PT1lJiZzPT09bnx8MD09PXMmJmU9PT1uKXJldHVybiEwfX1yZXR1cm4hMX1nZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCgpe3JldHVybiB0aGlzLl9wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludH1zZXRJc0RvbmVJZlByb3BlckludCh0KXt0aGlzLl9pc0RvbmVXaGVuUHJvcGVySW50PXR9aGFzUHJvcGVySW50ZXJpb3JJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzUHJvcGVySW50ZXJpb3J9aXNCb3VuZGFyeVBvaW50SW50ZXJuYWwodCxlKXtmb3IobGV0IG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgZT1uLm5leHQoKS5nZXRDb29yZGluYXRlKCk7aWYodC5pc0ludGVyc2VjdGlvbihlKSlyZXR1cm4hMH1yZXR1cm4hMX1oYXNQcm9wZXJJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzUHJvcGVyfWhhc0ludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9oYXNJbnRlcnNlY3Rpb259aXNEb25lKCl7cmV0dXJuIHRoaXMuX2lzRG9uZX1pc0JvdW5kYXJ5UG9pbnQodCxlKXtyZXR1cm4gbnVsbCE9PWUmJighIXRoaXMuaXNCb3VuZGFyeVBvaW50SW50ZXJuYWwodCxlWzBdKXx8ISF0aGlzLmlzQm91bmRhcnlQb2ludEludGVybmFsKHQsZVsxXSkpfXNldEJvdW5kYXJ5Tm9kZXModCxlKXt0aGlzLl9iZHlOb2Rlcz1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLl9iZHlOb2Rlc1swXT10LHRoaXMuX2JkeU5vZGVzWzFdPWV9YWRkSW50ZXJzZWN0aW9ucyh0LGUsbixzKXtpZih0PT09biYmZT09PXMpcmV0dXJuIG51bGw7dGhpcy5udW1UZXN0cysrO2NvbnN0IGk9dC5nZXRDb29yZGluYXRlcygpW2VdLHI9dC5nZXRDb29yZGluYXRlcygpW2UrMV0sbz1uLmdldENvb3JkaW5hdGVzKClbc10sbD1uLmdldENvb3JkaW5hdGVzKClbcysxXTt0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKGkscixvLGwpLHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpJiYodGhpcy5fcmVjb3JkSXNvbGF0ZWQmJih0LnNldElzb2xhdGVkKCExKSxuLnNldElzb2xhdGVkKCExKSksdGhpcy5fbnVtSW50ZXJzZWN0aW9ucysrLHRoaXMuaXNUcml2aWFsSW50ZXJzZWN0aW9uKHQsZSxuLHMpfHwodGhpcy5faGFzSW50ZXJzZWN0aW9uPSEwLCF0aGlzLl9pbmNsdWRlUHJvcGVyJiZ0aGlzLl9saS5pc1Byb3BlcigpfHwodC5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLGUsMCksbi5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLHMsMSkpLHRoaXMuX2xpLmlzUHJvcGVyKCkmJih0aGlzLl9wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludD10aGlzLl9saS5nZXRJbnRlcnNlY3Rpb24oMCkuY29weSgpLHRoaXMuX2hhc1Byb3Blcj0hMCx0aGlzLl9pc0RvbmVXaGVuUHJvcGVySW50JiYodGhpcy5faXNEb25lPSEwKSx0aGlzLmlzQm91bmRhcnlQb2ludCh0aGlzLl9saSx0aGlzLl9iZHlOb2Rlcyl8fCh0aGlzLl9oYXNQcm9wZXJJbnRlcmlvcj0hMCkpKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gTW59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fU1uLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2hhc0ludGVyc2VjdGlvbj0hMSx0aGlzLl9oYXNQcm9wZXI9ITEsdGhpcy5faGFzUHJvcGVySW50ZXJpb3I9ITEsdGhpcy5fcHJvcGVySW50ZXJzZWN0aW9uUG9pbnQ9bnVsbCx0aGlzLl9saT1udWxsLHRoaXMuX2luY2x1ZGVQcm9wZXI9bnVsbCx0aGlzLl9yZWNvcmRJc29sYXRlZD1udWxsLHRoaXMuX2lzU2VsZkludGVyc2VjdGlvbj1udWxsLHRoaXMuX251bUludGVyc2VjdGlvbnM9MCx0aGlzLm51bVRlc3RzPTAsdGhpcy5fYmR5Tm9kZXM9bnVsbCx0aGlzLl9pc0RvbmU9ITEsdGhpcy5faXNEb25lV2hlblByb3BlckludD0hMTtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9saT10LHRoaXMuX2luY2x1ZGVQcm9wZXI9ZSx0aGlzLl9yZWNvcmRJc29sYXRlZD1ufTtjbGFzcyBEbiBleHRlbmRzIGJue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxEbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXByZXBhcmVFdmVudHMoKXtFZS5zb3J0KHRoaXMuZXZlbnRzKTtmb3IobGV0IHQ9MDt0PHRoaXMuZXZlbnRzLnNpemUoKTt0Kyspe2NvbnN0IGU9dGhpcy5ldmVudHMuZ2V0KHQpO2UuaXNEZWxldGUoKSYmZS5nZXRJbnNlcnRFdmVudCgpLnNldERlbGV0ZUV2ZW50SW5kZXgodCl9fWNvbXB1dGVJbnRlcnNlY3Rpb25zKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMubk92ZXJsYXBzPTAsdGhpcy5wcmVwYXJlRXZlbnRzKCk7Zm9yKGxldCBlPTA7ZTx0aGlzLmV2ZW50cy5zaXplKCk7ZSsrKXtjb25zdCBuPXRoaXMuZXZlbnRzLmdldChlKTtpZihuLmlzSW5zZXJ0KCkmJnRoaXMucHJvY2Vzc092ZXJsYXBzKGUsbi5nZXREZWxldGVFdmVudEluZGV4KCksbix0KSx0LmlzRG9uZSgpKWJyZWFrfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgTW4mJl8oYXJndW1lbnRzWzBdLG0pJiZfKGFyZ3VtZW50c1sxXSxtKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5hZGRFZGdlcyh0LHQpLHRoaXMuYWRkRWRnZXMoZSxlKSx0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25zKG4pfWVsc2UgaWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJl8oYXJndW1lbnRzWzBdLG0pJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIE1uKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTthcmd1bWVudHNbMl0/dGhpcy5hZGRFZGdlcyh0LG51bGwpOnRoaXMuYWRkRWRnZXModCksdGhpcy5jb21wdXRlSW50ZXJzZWN0aW9ucyhlKX19YWRkRWRnZSh0LGUpe2NvbnN0IG49dC5nZXRNb25vdG9uZUNoYWluRWRnZSgpLHM9bi5nZXRTdGFydEluZGV4ZXMoKTtmb3IobGV0IHQ9MDt0PHMubGVuZ3RoLTE7dCsrKXtjb25zdCBzPW5ldyB2bihuLHQpLGk9bmV3IE9uKGUsbi5nZXRNaW5YKHQpLHMpO3RoaXMuZXZlbnRzLmFkZChpKSx0aGlzLmV2ZW50cy5hZGQobmV3IE9uKG4uZ2V0TWF4WCh0KSxpKSl9fXByb2Nlc3NPdmVybGFwcyh0LGUsbixzKXtjb25zdCBpPW4uZ2V0T2JqZWN0KCk7Zm9yKGxldCByPXQ7cjxlO3IrKyl7Y29uc3QgdD10aGlzLmV2ZW50cy5nZXQocik7aWYodC5pc0luc2VydCgpKXtjb25zdCBlPXQuZ2V0T2JqZWN0KCk7bi5pc1NhbWVMYWJlbCh0KXx8KGkuY29tcHV0ZUludGVyc2VjdGlvbnMoZSxzKSx0aGlzLm5PdmVybGFwcysrKX19fWFkZEVkZ2VzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2ZvcihsZXQgdD1hcmd1bWVudHNbMF0uaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7dGhpcy5hZGRFZGdlKGUsZSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO3RoaXMuYWRkRWRnZSh0LGUpfX19Z2V0Q2xhc3MoKXtyZXR1cm4gRG59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fURuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuZXZlbnRzPW5ldyB4LHRoaXMubk92ZXJsYXBzPW51bGx9O2NsYXNzIEFue2NvbnN0cnVjdG9yKCl7QW4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zZXRBbGxMb2NhdGlvbnModCl7Zm9yKGxldCBlPTA7ZTx0aGlzLmxvY2F0aW9uLmxlbmd0aDtlKyspdGhpcy5sb2NhdGlvbltlXT10fWlzTnVsbCgpe2ZvcihsZXQgdD0wO3Q8dGhpcy5sb2NhdGlvbi5sZW5ndGg7dCsrKWlmKHRoaXMubG9jYXRpb25bdF0hPT1uZS5OT05FKXJldHVybiExO3JldHVybiEwfXNldEFsbExvY2F0aW9uc0lmTnVsbCh0KXtmb3IobGV0IGU9MDtlPHRoaXMubG9jYXRpb24ubGVuZ3RoO2UrKyl0aGlzLmxvY2F0aW9uW2VdPT09bmUuTk9ORSYmKHRoaXMubG9jYXRpb25bZV09dCl9aXNMaW5lKCl7cmV0dXJuIDE9PT10aGlzLmxvY2F0aW9uLmxlbmd0aH1tZXJnZSh0KXtpZih0LmxvY2F0aW9uLmxlbmd0aD50aGlzLmxvY2F0aW9uLmxlbmd0aCl7Y29uc3QgdD1uZXcgQXJyYXkoMykuZmlsbChudWxsKTt0W1BuLk9OXT10aGlzLmxvY2F0aW9uW1BuLk9OXSx0W1BuLkxFRlRdPW5lLk5PTkUsdFtQbi5SSUdIVF09bmUuTk9ORSx0aGlzLmxvY2F0aW9uPXR9Zm9yKGxldCBlPTA7ZTx0aGlzLmxvY2F0aW9uLmxlbmd0aDtlKyspdGhpcy5sb2NhdGlvbltlXT09PW5lLk5PTkUmJmU8dC5sb2NhdGlvbi5sZW5ndGgmJih0aGlzLmxvY2F0aW9uW2VdPXQubG9jYXRpb25bZV0pfWdldExvY2F0aW9ucygpe3JldHVybiB0aGlzLmxvY2F0aW9ufWZsaXAoKXtpZih0aGlzLmxvY2F0aW9uLmxlbmd0aDw9MSlyZXR1cm4gbnVsbDtjb25zdCB0PXRoaXMubG9jYXRpb25bUG4uTEVGVF07dGhpcy5sb2NhdGlvbltQbi5MRUZUXT10aGlzLmxvY2F0aW9uW1BuLlJJR0hUXSx0aGlzLmxvY2F0aW9uW1BuLlJJR0hUXT10fXRvU3RyaW5nKCl7Y29uc3QgdD1uZXcgdztyZXR1cm4gdGhpcy5sb2NhdGlvbi5sZW5ndGg+MSYmdC5hcHBlbmQobmUudG9Mb2NhdGlvblN5bWJvbCh0aGlzLmxvY2F0aW9uW1BuLkxFRlRdKSksdC5hcHBlbmQobmUudG9Mb2NhdGlvblN5bWJvbCh0aGlzLmxvY2F0aW9uW1BuLk9OXSkpLHRoaXMubG9jYXRpb24ubGVuZ3RoPjEmJnQuYXBwZW5kKG5lLnRvTG9jYXRpb25TeW1ib2wodGhpcy5sb2NhdGlvbltQbi5SSUdIVF0pKSx0LnRvU3RyaW5nKCl9c2V0TG9jYXRpb25zKHQsZSxuKXt0aGlzLmxvY2F0aW9uW1BuLk9OXT10LHRoaXMubG9jYXRpb25bUG4uTEVGVF09ZSx0aGlzLmxvY2F0aW9uW1BuLlJJR0hUXT1ufWdldCh0KXtyZXR1cm4gdDx0aGlzLmxvY2F0aW9uLmxlbmd0aD90aGlzLmxvY2F0aW9uW3RdOm5lLk5PTkV9aXNBcmVhKCl7cmV0dXJuIHRoaXMubG9jYXRpb24ubGVuZ3RoPjF9aXNBbnlOdWxsKCl7Zm9yKGxldCB0PTA7dDx0aGlzLmxvY2F0aW9uLmxlbmd0aDt0KyspaWYodGhpcy5sb2NhdGlvblt0XT09PW5lLk5PTkUpcmV0dXJuITA7cmV0dXJuITF9c2V0TG9jYXRpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRMb2NhdGlvbihQbi5PTix0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmxvY2F0aW9uW3RdPWV9fWluaXQodCl7dGhpcy5sb2NhdGlvbj1uZXcgQXJyYXkodCkuZmlsbChudWxsKSx0aGlzLnNldEFsbExvY2F0aW9ucyhuZS5OT05FKX1pc0VxdWFsT25TaWRlKHQsZSl7cmV0dXJuIHRoaXMubG9jYXRpb25bZV09PT10LmxvY2F0aW9uW2VdfWFsbFBvc2l0aW9uc0VxdWFsKHQpe2ZvcihsZXQgZT0wO2U8dGhpcy5sb2NhdGlvbi5sZW5ndGg7ZSsrKWlmKHRoaXMubG9jYXRpb25bZV0hPT10KXJldHVybiExO3JldHVybiEwfWdldENsYXNzKCl7cmV0dXJuIEFufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Bbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLmxvY2F0aW9uPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0Lmxlbmd0aCl9ZWxzZSBpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCgxKSx0aGlzLmxvY2F0aW9uW1BuLk9OXT10fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBbil7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5pbml0KHQubG9jYXRpb24ubGVuZ3RoKSxudWxsIT09dClmb3IobGV0IGU9MDtlPHRoaXMubG9jYXRpb24ubGVuZ3RoO2UrKyl0aGlzLmxvY2F0aW9uW2VdPXQubG9jYXRpb25bZV19fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuaW5pdCgzKSx0aGlzLmxvY2F0aW9uW1BuLk9OXT10LHRoaXMubG9jYXRpb25bUG4uTEVGVF09ZSx0aGlzLmxvY2F0aW9uW1BuLlJJR0hUXT1ufX07Y2xhc3MgRm57Y29uc3RydWN0b3IoKXtGbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyB0b0xpbmVMYWJlbCh0KXtjb25zdCBlPW5ldyBGbihuZS5OT05FKTtmb3IobGV0IG49MDtuPDI7bisrKWUuc2V0TG9jYXRpb24obix0LmdldExvY2F0aW9uKG4pKTtyZXR1cm4gZX1nZXRHZW9tZXRyeUNvdW50KCl7bGV0IHQ9MDtyZXR1cm4gdGhpcy5lbHRbMF0uaXNOdWxsKCl8fHQrKyx0aGlzLmVsdFsxXS5pc051bGwoKXx8dCsrLHR9c2V0QWxsTG9jYXRpb25zKHQsZSl7dGhpcy5lbHRbdF0uc2V0QWxsTG9jYXRpb25zKGUpfWlzTnVsbCh0KXtyZXR1cm4gdGhpcy5lbHRbdF0uaXNOdWxsKCl9c2V0QWxsTG9jYXRpb25zSWZOdWxsKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0QWxsTG9jYXRpb25zSWZOdWxsKDAsdCksdGhpcy5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMSx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmVsdFt0XS5zZXRBbGxMb2NhdGlvbnNJZk51bGwoZSl9fWlzTGluZSh0KXtyZXR1cm4gdGhpcy5lbHRbdF0uaXNMaW5lKCl9bWVyZ2UodCl7Zm9yKGxldCBlPTA7ZTwyO2UrKyludWxsPT09dGhpcy5lbHRbZV0mJm51bGwhPT10LmVsdFtlXT90aGlzLmVsdFtlXT1uZXcgQW4odC5lbHRbZV0pOnRoaXMuZWx0W2VdLm1lcmdlKHQuZWx0W2VdKX1mbGlwKCl7dGhpcy5lbHRbMF0uZmxpcCgpLHRoaXMuZWx0WzFdLmZsaXAoKX1nZXRMb2NhdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5lbHRbdF0uZ2V0KFBuLk9OKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuZWx0W3RdLmdldChlKX19dG9TdHJpbmcoKXtjb25zdCB0PW5ldyB3O3JldHVybiBudWxsIT09dGhpcy5lbHRbMF0mJih0LmFwcGVuZChcIkE6XCIpLHQuYXBwZW5kKHRoaXMuZWx0WzBdLnRvU3RyaW5nKCkpKSxudWxsIT09dGhpcy5lbHRbMV0mJih0LmFwcGVuZChcIiBCOlwiKSx0LmFwcGVuZCh0aGlzLmVsdFsxXS50b1N0cmluZygpKSksdC50b1N0cmluZygpfWlzQXJlYSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmVsdFswXS5pc0FyZWEoKXx8dGhpcy5lbHRbMV0uaXNBcmVhKCk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmVsdFt0XS5pc0FyZWEoKX19aXNBbnlOdWxsKHQpe3JldHVybiB0aGlzLmVsdFt0XS5pc0FueU51bGwoKX1zZXRMb2NhdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmVsdFt0XS5zZXRMb2NhdGlvbihQbi5PTixlKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmVsdFt0XS5zZXRMb2NhdGlvbihlLG4pfX1pc0VxdWFsT25TaWRlKHQsZSl7cmV0dXJuIHRoaXMuZWx0WzBdLmlzRXF1YWxPblNpZGUodC5lbHRbMF0sZSkmJnRoaXMuZWx0WzFdLmlzRXF1YWxPblNpZGUodC5lbHRbMV0sZSl9YWxsUG9zaXRpb25zRXF1YWwodCxlKXtyZXR1cm4gdGhpcy5lbHRbdF0uYWxsUG9zaXRpb25zRXF1YWwoZSl9dG9MaW5lKHQpe3RoaXMuZWx0W3RdLmlzQXJlYSgpJiYodGhpcy5lbHRbdF09bmV3IEFuKHRoaXMuZWx0W3RdLmxvY2F0aW9uWzBdKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gRm59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUZuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuZWx0PW5ldyBBcnJheSgyKS5maWxsKG51bGwpLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZWx0WzBdPW5ldyBBbih0KSx0aGlzLmVsdFsxXT1uZXcgQW4odCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEZuKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmVsdFswXT1uZXcgQW4odC5lbHRbMF0pLHRoaXMuZWx0WzFdPW5ldyBBbih0LmVsdFsxXSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuZWx0WzBdPW5ldyBBbihuZS5OT05FKSx0aGlzLmVsdFsxXT1uZXcgQW4obmUuTk9ORSksdGhpcy5lbHRbdF0uc2V0TG9jYXRpb24oZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5lbHRbMF09bmV3IEFuKHQsZSxuKSx0aGlzLmVsdFsxXT1uZXcgQW4odCxlLG4pfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuZWx0WzBdPW5ldyBBbihuZS5OT05FLG5lLk5PTkUsbmUuTk9ORSksdGhpcy5lbHRbMV09bmV3IEFuKG5lLk5PTkUsbmUuTk9ORSxuZS5OT05FKSx0aGlzLmVsdFt0XS5zZXRMb2NhdGlvbnMoZSxuLHMpfX07Y2xhc3MgR257Y29uc3RydWN0b3IoKXtHbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldFNlZ21lbnRJbmRleCgpe3JldHVybiB0aGlzLnNlZ21lbnRJbmRleH1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuY29vcmR9cHJpbnQodCl7dC5wcmludCh0aGlzLmNvb3JkKSx0LnByaW50KFwiIHNlZyAjID0gXCIrdGhpcy5zZWdtZW50SW5kZXgpLHQucHJpbnRsbihcIiBkaXN0ID0gXCIrdGhpcy5kaXN0KX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLmNvbXBhcmUoZS5zZWdtZW50SW5kZXgsZS5kaXN0KX1pc0VuZFBvaW50KHQpe3JldHVybiAwPT09dGhpcy5zZWdtZW50SW5kZXgmJjA9PT10aGlzLmRpc3R8fHRoaXMuc2VnbWVudEluZGV4PT09dH10b1N0cmluZygpe3JldHVybiB0aGlzLmNvb3JkK1wiIHNlZyAjID0gXCIrdGhpcy5zZWdtZW50SW5kZXgrXCIgZGlzdCA9IFwiK3RoaXMuZGlzdH1nZXREaXN0YW5jZSgpe3JldHVybiB0aGlzLmRpc3R9Y29tcGFyZSh0LGUpe3JldHVybiB0aGlzLnNlZ21lbnRJbmRleDx0Py0xOnRoaXMuc2VnbWVudEluZGV4PnQ/MTp0aGlzLmRpc3Q8ZT8tMTp0aGlzLmRpc3Q+ZT8xOjB9Z2V0Q2xhc3MoKXtyZXR1cm4gR259Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3JdfX1Hbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLmNvb3JkPW51bGwsdGhpcy5zZWdtZW50SW5kZXg9bnVsbCx0aGlzLmRpc3Q9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmNvb3JkPW5ldyBnKHQpLHRoaXMuc2VnbWVudEluZGV4PWUsdGhpcy5kaXN0PW59O2NsYXNzIHFue2NvbnN0cnVjdG9yKCl7cW4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1wcmludCh0KXt0LnByaW50bG4oXCJJbnRlcnNlY3Rpb25zOlwiKTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkucHJpbnQodCl9fWl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX25vZGVNYXAudmFsdWVzKCkuaXRlcmF0b3IoKX1hZGRTcGxpdEVkZ2VzKHQpe3RoaXMuYWRkRW5kcG9pbnRzKCk7Y29uc3QgZT10aGlzLml0ZXJhdG9yKCk7bGV0IG49ZS5uZXh0KCk7Zm9yKDtlLmhhc05leHQoKTspe2NvbnN0IHM9ZS5uZXh0KCksaT10aGlzLmNyZWF0ZVNwbGl0RWRnZShuLHMpO3QuYWRkKGkpLG49c319YWRkRW5kcG9pbnRzKCl7Y29uc3QgdD10aGlzLmVkZ2UucHRzLmxlbmd0aC0xO3RoaXMuYWRkKHRoaXMuZWRnZS5wdHNbMF0sMCwwKSx0aGlzLmFkZCh0aGlzLmVkZ2UucHRzW3RdLHQsMCl9Y3JlYXRlU3BsaXRFZGdlKHQsZSl7bGV0IG49ZS5zZWdtZW50SW5kZXgtdC5zZWdtZW50SW5kZXgrMjtjb25zdCBzPXRoaXMuZWRnZS5wdHNbZS5zZWdtZW50SW5kZXhdLGk9ZS5kaXN0PjB8fCFlLmNvb3JkLmVxdWFsczJEKHMpO2l8fG4tLTtjb25zdCByPW5ldyBBcnJheShuKS5maWxsKG51bGwpO2xldCBvPTA7cltvKytdPW5ldyBnKHQuY29vcmQpO2ZvcihsZXQgbj10LnNlZ21lbnRJbmRleCsxO248PWUuc2VnbWVudEluZGV4O24rKylyW28rK109dGhpcy5lZGdlLnB0c1tuXTtyZXR1cm4gaSYmKHJbb109ZS5jb29yZCksbmV3IFVuKHIsbmV3IEZuKHRoaXMuZWRnZS5fbGFiZWwpKX1hZGQodCxlLG4pe2NvbnN0IHM9bmV3IEduKHQsZSxuKSxpPXRoaXMuX25vZGVNYXAuZ2V0KHMpO3JldHVybiBudWxsIT09aT9pOih0aGlzLl9ub2RlTWFwLnB1dChzLHMpLHMpfWlzSW50ZXJzZWN0aW9uKHQpe2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtpZihlLm5leHQoKS5jb29yZC5lcXVhbHModCkpcmV0dXJuITB9cmV0dXJuITF9Z2V0Q2xhc3MoKXtyZXR1cm4gcW59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXFuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX25vZGVNYXA9bmV3IHJ0LHRoaXMuZWRnZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZWRnZT10fTtjbGFzcyBCbntjb25zdHJ1Y3Rvcigpe0JuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHRvSW50QXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspZVtuXT10LmdldChuKS5pbnRWYWx1ZSgpO3JldHVybiBlfWdldENoYWluU3RhcnRJbmRpY2VzKHQpe2xldCBlPTA7Y29uc3Qgbj1uZXcgeDtuLmFkZChuZXcgTChlKSk7ZG97Y29uc3Qgcz10aGlzLmZpbmRDaGFpbkVuZCh0LGUpO24uYWRkKG5ldyBMKHMpKSxlPXN9d2hpbGUoZTx0Lmxlbmd0aC0xKTtyZXR1cm4gQm4udG9JbnRBcnJheShuKX1maW5kQ2hhaW5FbmQodCxlKXtjb25zdCBuPUluLnF1YWRyYW50KHRbZV0sdFtlKzFdKTtsZXQgcz1lKzE7Zm9yKDtzPHQubGVuZ3RoOyl7aWYoSW4ucXVhZHJhbnQodFtzLTFdLHRbc10pIT09bilicmVhaztzKyt9cmV0dXJuIHMtMX1nZXRDbGFzcygpe3JldHVybiBCbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Qm4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBWbntjb25zdHJ1Y3Rvcigpe1ZuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5wdHN9Z2V0TWF4WCh0KXtjb25zdCBlPXRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFt0XV0ueCxuPXRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFt0KzFdXS54O3JldHVybiBlPm4/ZTpufWdldE1pblgodCl7Y29uc3QgZT10aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbdF1dLngsbj10aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbdCsxXV0ueDtyZXR1cm4gZTxuP2U6bn1jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKCl7aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbih0aGlzLnN0YXJ0SW5kZXhbdF0sdGhpcy5zdGFydEluZGV4W3QrMV0sZSxlLnN0YXJ0SW5kZXhbbl0sZS5zdGFydEluZGV4W24rMV0scyl9ZWxzZSBpZig2PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF0scj1hcmd1bWVudHNbNV07aWYoZS10PT0xJiZpLXM9PTEpcmV0dXJuIHIuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLmUsdCxuLmUscyksbnVsbDtpZighdGhpcy5vdmVybGFwcyh0LGUsbixzLGkpKXJldHVybiBudWxsO2NvbnN0IG89TWF0aC50cnVuYygodCtlKS8yKSxsPU1hdGgudHJ1bmMoKHMraSkvMik7dDxvJiYoczxsJiZ0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4odCxvLG4scyxsLHIpLGw8aSYmdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKHQsbyxuLGwsaSxyKSksbzxlJiYoczxsJiZ0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4obyxlLG4scyxsLHIpLGw8aSYmdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKG8sZSxuLGwsaSxyKSl9fW92ZXJsYXBzKHQsZSxuLHMsaSl7cmV0dXJuIE4uaW50ZXJzZWN0cyh0aGlzLnB0c1t0XSx0aGlzLnB0c1tlXSxuLnB0c1tzXSxuLnB0c1tpXSl9Z2V0U3RhcnRJbmRleGVzKCl7cmV0dXJuIHRoaXMuc3RhcnRJbmRleH1jb21wdXRlSW50ZXJzZWN0cyh0LGUpe2ZvcihsZXQgbj0wO248dGhpcy5zdGFydEluZGV4Lmxlbmd0aC0xO24rKylmb3IobGV0IHM9MDtzPHQuc3RhcnRJbmRleC5sZW5ndGgtMTtzKyspdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKG4sdCxzLGUpfWdldENsYXNzKCl7cmV0dXJuIFZufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Wbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLmU9bnVsbCx0aGlzLnB0cz1udWxsLHRoaXMuc3RhcnRJbmRleD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZT10LHRoaXMucHRzPXQuZ2V0Q29vcmRpbmF0ZXMoKTtjb25zdCBlPW5ldyBCbjt0aGlzLnN0YXJ0SW5kZXg9ZS5nZXRDaGFpblN0YXJ0SW5kaWNlcyh0aGlzLnB0cyl9O2NsYXNzIHpue2NvbnN0cnVjdG9yKCl7em4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZGVwdGhBdExvY2F0aW9uKHQpe3JldHVybiB0PT09bmUuRVhURVJJT1I/MDp0PT09bmUuSU5URVJJT1I/MTp6bi5OVUxMX1ZBTFVFfWdldERlcHRoKHQsZSl7cmV0dXJuIHRoaXMuX2RlcHRoW3RdW2VdfXNldERlcHRoKHQsZSxuKXt0aGlzLl9kZXB0aFt0XVtlXT1ufWlzTnVsbCgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IobGV0IHQ9MDt0PDI7dCsrKWZvcihsZXQgZT0wO2U8MztlKyspaWYodGhpcy5fZGVwdGhbdF1bZV0hPT16bi5OVUxMX1ZBTFVFKXJldHVybiExO3JldHVybiEwfWlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fZGVwdGhbdF1bMV09PT16bi5OVUxMX1ZBTFVFfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5fZGVwdGhbdF1bZV09PT16bi5OVUxMX1ZBTFVFfX1ub3JtYWxpemUoKXtmb3IobGV0IHQ9MDt0PDI7dCsrKWlmKCF0aGlzLmlzTnVsbCh0KSl7bGV0IGU9dGhpcy5fZGVwdGhbdF1bMV07dGhpcy5fZGVwdGhbdF1bMl08ZSYmKGU9dGhpcy5fZGVwdGhbdF1bMl0pLGU8MCYmKGU9MCk7Zm9yKGxldCBuPTE7bjwzO24rKyl7bGV0IHM9MDt0aGlzLl9kZXB0aFt0XVtuXT5lJiYocz0xKSx0aGlzLl9kZXB0aFt0XVtuXT1zfX19Z2V0RGVsdGEodCl7cmV0dXJuIHRoaXMuX2RlcHRoW3RdW1BuLlJJR0hUXS10aGlzLl9kZXB0aFt0XVtQbi5MRUZUXX1nZXRMb2NhdGlvbih0LGUpe3JldHVybiB0aGlzLl9kZXB0aFt0XVtlXTw9MD9uZS5FWFRFUklPUjpuZS5JTlRFUklPUn10b1N0cmluZygpe3JldHVyblwiQTogXCIrdGhpcy5fZGVwdGhbMF1bMV0rXCIsXCIrdGhpcy5fZGVwdGhbMF1bMl0rXCIgQjogXCIrdGhpcy5fZGVwdGhbMV1bMV0rXCIsXCIrdGhpcy5fZGVwdGhbMV1bMl19YWRkKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8MjtlKyspZm9yKGxldCBuPTE7bjwzO24rKyl7Y29uc3Qgcz10LmdldExvY2F0aW9uKGUsbik7cyE9PW5lLkVYVEVSSU9SJiZzIT09bmUuSU5URVJJT1J8fCh0aGlzLmlzTnVsbChlLG4pP3RoaXMuX2RlcHRoW2VdW25dPXpuLmRlcHRoQXRMb2NhdGlvbihzKTp0aGlzLl9kZXB0aFtlXVtuXSs9em4uZGVwdGhBdExvY2F0aW9uKHMpKX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07YXJndW1lbnRzWzJdPT09bmUuSU5URVJJT1ImJnRoaXMuX2RlcHRoW3RdW2VdKyt9fWdldENsYXNzKCl7cmV0dXJuIHpufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX16bi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9kZXB0aD1BcnJheSgyKS5maWxsKCkubWFwKCgpPT5BcnJheSgzKSk7Zm9yKGxldCB0PTA7dDwyO3QrKylmb3IobGV0IGU9MDtlPDM7ZSsrKXRoaXMuX2RlcHRoW3RdW2VdPXpuLk5VTExfVkFMVUV9LHpuLk5VTExfVkFMVUU9LTE7Y2xhc3MgWW57Y29uc3RydWN0b3IoKXtZbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXNldFZpc2l0ZWQodCl7dGhpcy5faXNWaXNpdGVkPXR9c2V0SW5SZXN1bHQodCl7dGhpcy5faXNJblJlc3VsdD10fWlzQ292ZXJlZCgpe3JldHVybiB0aGlzLl9pc0NvdmVyZWR9aXNDb3ZlcmVkU2V0KCl7cmV0dXJuIHRoaXMuX2lzQ292ZXJlZFNldH1zZXRMYWJlbCh0KXt0aGlzLl9sYWJlbD10fWdldExhYmVsKCl7cmV0dXJuIHRoaXMuX2xhYmVsfXNldENvdmVyZWQodCl7dGhpcy5faXNDb3ZlcmVkPXQsdGhpcy5faXNDb3ZlcmVkU2V0PSEwfXVwZGF0ZUlNKHQpe3UuaXNUcnVlKHRoaXMuX2xhYmVsLmdldEdlb21ldHJ5Q291bnQoKT49MixcImZvdW5kIHBhcnRpYWwgbGFiZWxcIiksdGhpcy5jb21wdXRlSU0odCl9aXNJblJlc3VsdCgpe3JldHVybiB0aGlzLl9pc0luUmVzdWx0fWlzVmlzaXRlZCgpe3JldHVybiB0aGlzLl9pc1Zpc2l0ZWR9Z2V0Q2xhc3MoKXtyZXR1cm4gWW59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVluLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2xhYmVsPW51bGwsdGhpcy5faXNJblJlc3VsdD0hMSx0aGlzLl9pc0NvdmVyZWQ9ITEsdGhpcy5faXNDb3ZlcmVkU2V0PSExLHRoaXMuX2lzVmlzaXRlZD0hMSwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGFiZWw9dH19O2NsYXNzIFVuIGV4dGVuZHMgWW57Y29uc3RydWN0b3IoKXtzdXBlcigpLFVuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHVwZGF0ZUlNKCl7aWYoISgyPT09YXJndW1lbnRzLmxlbmd0aCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBzZSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBGbikpcmV0dXJuIHN1cGVyLnVwZGF0ZUlNLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07ZS5zZXRBdExlYXN0SWZWYWxpZCh0LmdldExvY2F0aW9uKDAsUG4uT04pLHQuZ2V0TG9jYXRpb24oMSxQbi5PTiksMSksdC5pc0FyZWEoKSYmKGUuc2V0QXRMZWFzdElmVmFsaWQodC5nZXRMb2NhdGlvbigwLFBuLkxFRlQpLHQuZ2V0TG9jYXRpb24oMSxQbi5MRUZUKSwyKSxlLnNldEF0TGVhc3RJZlZhbGlkKHQuZ2V0TG9jYXRpb24oMCxQbi5SSUdIVCksdC5nZXRMb2NhdGlvbigxLFBuLlJJR0hUKSwyKSl9fWdldERlcHRoKCl7cmV0dXJuIHRoaXMuX2RlcHRofWdldENvbGxhcHNlZEVkZ2UoKXtjb25zdCB0PW5ldyBBcnJheSgyKS5maWxsKG51bGwpO3JldHVybiB0WzBdPXRoaXMucHRzWzBdLHRbMV09dGhpcy5wdHNbMV0sbmV3IFVuKHQsRm4udG9MaW5lTGFiZWwodGhpcy5fbGFiZWwpKX1pc0lzb2xhdGVkKCl7cmV0dXJuIHRoaXMuX2lzSXNvbGF0ZWR9Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5wdHN9c2V0SXNvbGF0ZWQodCl7dGhpcy5faXNJc29sYXRlZD10fXNldE5hbWUodCl7dGhpcy5fbmFtZT10fWVxdWFscyh0KXtpZighKHQgaW5zdGFuY2VvZiBVbikpcmV0dXJuITE7Y29uc3QgZT10O2lmKHRoaXMucHRzLmxlbmd0aCE9PWUucHRzLmxlbmd0aClyZXR1cm4hMTtsZXQgbj0hMCxzPSEwLGk9dGhpcy5wdHMubGVuZ3RoO2ZvcihsZXQgdD0wO3Q8dGhpcy5wdHMubGVuZ3RoO3QrKylpZih0aGlzLnB0c1t0XS5lcXVhbHMyRChlLnB0c1t0XSl8fChuPSExKSx0aGlzLnB0c1t0XS5lcXVhbHMyRChlLnB0c1stLWldKXx8KHM9ITEpLCFuJiYhcylyZXR1cm4hMTtyZXR1cm4hMH1nZXRDb29yZGluYXRlKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMucHRzLmxlbmd0aD4wP3RoaXMucHRzWzBdOm51bGw7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnB0c1t0XX19cHJpbnQodCl7dC5wcmludChcImVkZ2UgXCIrdGhpcy5fbmFtZStcIjogXCIpLHQucHJpbnQoXCJMSU5FU1RSSU5HIChcIik7Zm9yKGxldCBlPTA7ZTx0aGlzLnB0cy5sZW5ndGg7ZSsrKWU+MCYmdC5wcmludChcIixcIiksdC5wcmludCh0aGlzLnB0c1tlXS54K1wiIFwiK3RoaXMucHRzW2VdLnkpO3QucHJpbnQoXCIpICBcIit0aGlzLl9sYWJlbCtcIiBcIit0aGlzLl9kZXB0aERlbHRhKX1jb21wdXRlSU0odCl7VW4udXBkYXRlSU0odGhpcy5fbGFiZWwsdCl9aXNDb2xsYXBzZWQoKXtyZXR1cm4hIXRoaXMuX2xhYmVsLmlzQXJlYSgpJiYoMz09PXRoaXMucHRzLmxlbmd0aCYmISF0aGlzLnB0c1swXS5lcXVhbHModGhpcy5wdHNbMl0pKX1pc0Nsb3NlZCgpe3JldHVybiB0aGlzLnB0c1swXS5lcXVhbHModGhpcy5wdHNbdGhpcy5wdHMubGVuZ3RoLTFdKX1nZXRNYXhpbXVtU2VnbWVudEluZGV4KCl7cmV0dXJuIHRoaXMucHRzLmxlbmd0aC0xfWdldERlcHRoRGVsdGEoKXtyZXR1cm4gdGhpcy5fZGVwdGhEZWx0YX1nZXROdW1Qb2ludHMoKXtyZXR1cm4gdGhpcy5wdHMubGVuZ3RofXByaW50UmV2ZXJzZSh0KXt0LnByaW50KFwiZWRnZSBcIit0aGlzLl9uYW1lK1wiOiBcIik7Zm9yKGxldCBlPXRoaXMucHRzLmxlbmd0aC0xO2U+PTA7ZS0tKXQucHJpbnQodGhpcy5wdHNbZV0rXCIgXCIpO3QucHJpbnRsbihcIlwiKX1nZXRNb25vdG9uZUNoYWluRWRnZSgpe3JldHVybiBudWxsPT09dGhpcy5fbWNlJiYodGhpcy5fbWNlPW5ldyBWbih0aGlzKSksdGhpcy5fbWNlfWdldEVudmVsb3BlKCl7aWYobnVsbD09PXRoaXMuX2Vudil7dGhpcy5fZW52PW5ldyBOO2ZvcihsZXQgdD0wO3Q8dGhpcy5wdHMubGVuZ3RoO3QrKyl0aGlzLl9lbnYuZXhwYW5kVG9JbmNsdWRlKHRoaXMucHRzW3RdKX1yZXR1cm4gdGhpcy5fZW52fWFkZEludGVyc2VjdGlvbih0LGUsbixzKXtjb25zdCBpPW5ldyBnKHQuZ2V0SW50ZXJzZWN0aW9uKHMpKTtsZXQgcj1lLG89dC5nZXRFZGdlRGlzdGFuY2UobixzKTtjb25zdCBsPXIrMTtpZihsPHRoaXMucHRzLmxlbmd0aCl7Y29uc3QgdD10aGlzLnB0c1tsXTtpLmVxdWFsczJEKHQpJiYocj1sLG89MCl9dGhpcy5laUxpc3QuYWRkKGkscixvKX10b1N0cmluZygpe2NvbnN0IHQ9bmV3IHd0O3QuYXBwZW5kKFwiZWRnZSBcIit0aGlzLl9uYW1lK1wiOiBcIiksdC5hcHBlbmQoXCJMSU5FU1RSSU5HIChcIik7Zm9yKGxldCBlPTA7ZTx0aGlzLnB0cy5sZW5ndGg7ZSsrKWU+MCYmdC5hcHBlbmQoXCIsXCIpLHQuYXBwZW5kKHRoaXMucHRzW2VdLngrXCIgXCIrdGhpcy5wdHNbZV0ueSk7cmV0dXJuIHQuYXBwZW5kKFwiKSAgXCIrdGhpcy5fbGFiZWwrXCIgXCIrdGhpcy5fZGVwdGhEZWx0YSksdC50b1N0cmluZygpfWlzUG9pbnR3aXNlRXF1YWwodCl7aWYodGhpcy5wdHMubGVuZ3RoIT09dC5wdHMubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgZT0wO2U8dGhpcy5wdHMubGVuZ3RoO2UrKylpZighdGhpcy5wdHNbZV0uZXF1YWxzMkQodC5wdHNbZV0pKXJldHVybiExO3JldHVybiEwfXNldERlcHRoRGVsdGEodCl7dGhpcy5fZGVwdGhEZWx0YT10fWdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCl7cmV0dXJuIHRoaXMuZWlMaXN0fWFkZEludGVyc2VjdGlvbnModCxlLG4pe2ZvcihsZXQgcz0wO3M8dC5nZXRJbnRlcnNlY3Rpb25OdW0oKTtzKyspdGhpcy5hZGRJbnRlcnNlY3Rpb24odCxlLG4scyl9Z2V0Q2xhc3MoKXtyZXR1cm4gVW59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVVuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMucHRzPW51bGwsdGhpcy5fZW52PW51bGwsdGhpcy5laUxpc3Q9bmV3IHFuKHRoaXMpLHRoaXMuX25hbWU9bnVsbCx0aGlzLl9tY2U9bnVsbCx0aGlzLl9pc0lzb2xhdGVkPSEwLHRoaXMuX2RlcHRoPW5ldyB6bix0aGlzLl9kZXB0aERlbHRhPTAsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO1VuLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxudWxsKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnB0cz10LHRoaXMuX2xhYmVsPWV9fTtjbGFzcyBrbiBleHRlbmRzIFlue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxrbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWlzSW5jaWRlbnRFZGdlSW5SZXN1bHQoKXtmb3IobGV0IHQ9dGhpcy5nZXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2lmKHQubmV4dCgpLmdldEVkZ2UoKS5pc0luUmVzdWx0KCkpcmV0dXJuITB9cmV0dXJuITF9aXNJc29sYXRlZCgpe3JldHVybiAxPT09dGhpcy5fbGFiZWwuZ2V0R2VvbWV0cnlDb3VudCgpfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fY29vcmR9cHJpbnQodCl7dC5wcmludGxuKFwibm9kZSBcIit0aGlzLl9jb29yZCtcIiBsYmw6IFwiK3RoaXMuX2xhYmVsKX1jb21wdXRlSU0odCl7fWNvbXB1dGVNZXJnZWRMb2NhdGlvbih0LGUpe2xldCBuPW5lLk5PTkU7aWYobj10aGlzLl9sYWJlbC5nZXRMb2NhdGlvbihlKSwhdC5pc051bGwoZSkpe2NvbnN0IHM9dC5nZXRMb2NhdGlvbihlKTtuIT09bmUuQk9VTkRBUlkmJihuPXMpfXJldHVybiBufXNldExhYmVsKCl7aWYoMiE9PWFyZ3VtZW50cy5sZW5ndGh8fCFOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSl8fCFOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpcmV0dXJuIHN1cGVyLnNldExhYmVsLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bnVsbD09PXRoaXMuX2xhYmVsP3RoaXMuX2xhYmVsPW5ldyBGbih0LGUpOnRoaXMuX2xhYmVsLnNldExvY2F0aW9uKHQsZSl9fWdldEVkZ2VzKCl7cmV0dXJuIHRoaXMuX2VkZ2VzfW1lcmdlTGFiZWwoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGtuKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLm1lcmdlTGFiZWwodC5fbGFiZWwpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBGbil7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTwyO2UrKyl7Y29uc3Qgbj10aGlzLmNvbXB1dGVNZXJnZWRMb2NhdGlvbih0LGUpO3RoaXMuX2xhYmVsLmdldExvY2F0aW9uKGUpPT09bmUuTk9ORSYmdGhpcy5fbGFiZWwuc2V0TG9jYXRpb24oZSxuKX19fWFkZCh0KXt0aGlzLl9lZGdlcy5pbnNlcnQodCksdC5zZXROb2RlKHRoaXMpfXNldExhYmVsQm91bmRhcnkodCl7aWYobnVsbD09PXRoaXMuX2xhYmVsKXJldHVybiBudWxsO2xldCBlPW5lLk5PTkU7bnVsbCE9PXRoaXMuX2xhYmVsJiYoZT10aGlzLl9sYWJlbC5nZXRMb2NhdGlvbih0KSk7bGV0IG49bnVsbDtzd2l0Y2goZSl7Y2FzZSBuZS5CT1VOREFSWTpuPW5lLklOVEVSSU9SO2JyZWFrO2Nhc2UgbmUuSU5URVJJT1I6ZGVmYXVsdDpuPW5lLkJPVU5EQVJZfXRoaXMuX2xhYmVsLnNldExvY2F0aW9uKHQsbil9Z2V0Q2xhc3MoKXtyZXR1cm4ga259Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWtuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2Nvb3JkPW51bGwsdGhpcy5fZWRnZXM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9jb29yZD10LHRoaXMuX2VkZ2VzPWUsdGhpcy5fbGFiZWw9bmV3IEZuKDAsbmUuTk9ORSl9O2NsYXNzIFhue2NvbnN0cnVjdG9yKCl7WG4uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maW5kKHQpe3JldHVybiB0aGlzLm5vZGVNYXAuZ2V0KHQpfWFkZE5vZGUoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPXRoaXMubm9kZU1hcC5nZXQodCk7cmV0dXJuIG51bGw9PT1lJiYoZT10aGlzLm5vZGVGYWN0LmNyZWF0ZU5vZGUodCksdGhpcy5ub2RlTWFwLnB1dCh0LGUpKSxlfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2Yga24pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5ub2RlTWFwLmdldCh0LmdldENvb3JkaW5hdGUoKSk7cmV0dXJuIG51bGw9PT1lPyh0aGlzLm5vZGVNYXAucHV0KHQuZ2V0Q29vcmRpbmF0ZSgpLHQpLHQpOihlLm1lcmdlTGFiZWwodCksZSl9fXByaW50KHQpe2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5wcmludCh0KX19aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5ub2RlTWFwLnZhbHVlcygpLml0ZXJhdG9yKCl9dmFsdWVzKCl7cmV0dXJuIHRoaXMubm9kZU1hcC52YWx1ZXMoKX1nZXRCb3VuZGFyeU5vZGVzKHQpe2NvbnN0IGU9bmV3IHg7Zm9yKGxldCBuPXRoaXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7cy5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpPT09bmUuQk9VTkRBUlkmJmUuYWRkKHMpfXJldHVybiBlfWFkZCh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZSgpO3RoaXMuYWRkTm9kZShlKS5hZGQodCl9Z2V0Q2xhc3MoKXtyZXR1cm4gWG59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVhuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMubm9kZU1hcD1uZXcgcnQsdGhpcy5ub2RlRmFjdD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMubm9kZUZhY3Q9dH07Y2xhc3MgSG57Y29uc3RydWN0b3IoKXtIbi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNvbXBhcmVEaXJlY3Rpb24odCl7cmV0dXJuIHRoaXMuX2R4PT09dC5fZHgmJnRoaXMuX2R5PT09dC5fZHk/MDp0aGlzLl9xdWFkcmFudD50Ll9xdWFkcmFudD8xOnRoaXMuX3F1YWRyYW50PHQuX3F1YWRyYW50Py0xOnYuaW5kZXgodC5fcDAsdC5fcDEsdGhpcy5fcDEpfWdldER5KCl7cmV0dXJuIHRoaXMuX2R5fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcDB9c2V0Tm9kZSh0KXt0aGlzLl9ub2RlPXR9cHJpbnQodCl7Y29uc3QgZT1NYXRoLmF0YW4yKHRoaXMuX2R5LHRoaXMuX2R4KSxuPXRoaXMuZ2V0Q2xhc3MoKS5nZXROYW1lKCkscz1uLmxhc3RJbmRleE9mKFwiLlwiKSxpPW4uc3Vic3RyaW5nKHMrMSk7dC5wcmludChcIiAgXCIraStcIjogXCIrdGhpcy5fcDArXCIgLSBcIit0aGlzLl9wMStcIiBcIit0aGlzLl9xdWFkcmFudCtcIjpcIitlK1wiICAgXCIrdGhpcy5fbGFiZWwpfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuY29tcGFyZURpcmVjdGlvbihlKX1nZXREaXJlY3RlZENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcDF9Z2V0RHgoKXtyZXR1cm4gdGhpcy5fZHh9Z2V0TGFiZWwoKXtyZXR1cm4gdGhpcy5fbGFiZWx9Z2V0RWRnZSgpe3JldHVybiB0aGlzLl9lZGdlfWdldFF1YWRyYW50KCl7cmV0dXJuIHRoaXMuX3F1YWRyYW50fWdldE5vZGUoKXtyZXR1cm4gdGhpcy5fbm9kZX10b1N0cmluZygpe2NvbnN0IHQ9TWF0aC5hdGFuMih0aGlzLl9keSx0aGlzLl9keCksZT10aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpLG49ZS5sYXN0SW5kZXhPZihcIi5cIik7cmV0dXJuXCIgIFwiK2Uuc3Vic3RyaW5nKG4rMSkrXCI6IFwiK3RoaXMuX3AwK1wiIC0gXCIrdGhpcy5fcDErXCIgXCIrdGhpcy5fcXVhZHJhbnQrXCI6XCIrdCtcIiAgIFwiK3RoaXMuX2xhYmVsfWNvbXB1dGVMYWJlbCh0KXt9aW5pdCh0LGUpe3RoaXMuX3AwPXQsdGhpcy5fcDE9ZSx0aGlzLl9keD1lLngtdC54LHRoaXMuX2R5PWUueS10LnksdGhpcy5fcXVhZHJhbnQ9SW4ucXVhZHJhbnQodGhpcy5fZHgsdGhpcy5fZHkpLHUuaXNUcnVlKCEoMD09PXRoaXMuX2R4JiYwPT09dGhpcy5fZHkpLFwiRWRnZUVuZCB3aXRoIGlkZW50aWNhbCBlbmRwb2ludHMgZm91bmRcIil9Z2V0Q2xhc3MoKXtyZXR1cm4gSG59Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3JdfX1Ibi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9lZGdlPW51bGwsdGhpcy5fbGFiZWw9bnVsbCx0aGlzLl9ub2RlPW51bGwsdGhpcy5fcDA9bnVsbCx0aGlzLl9wMT1udWxsLHRoaXMuX2R4PW51bGwsdGhpcy5fZHk9bnVsbCx0aGlzLl9xdWFkcmFudD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9lZGdlPXR9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07SG4uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsbixudWxsKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtIbi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpLHRoaXMuaW5pdChlLG4pLHRoaXMuX2xhYmVsPXN9fTtjbGFzcyBXbiBleHRlbmRzIGN7Y29uc3RydWN0b3IoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07c3VwZXIodCksYy5jYWxsKHRoaXMsdCl9ZWxzZXtpZigyIT09YXJndW1lbnRzLmxlbmd0aCl0aHJvdyBFcnJvcigpO3tjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtzdXBlcihXbi5tc2dXaXRoQ29vcmQodCxlKSksdGhpcy5uYW1lPVwiVG9wb2xvZ3lFeGNlcHRpb25cIix0aGlzLnB0PW5ldyBnKGUpfX19Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLnB0fWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfWdldENsYXNzKCl7cmV0dXJuIFdufXN0YXRpYyBtc2dXaXRoQ29vcmQodCxlKXtyZXR1cm4gbnVsbCE9PWU/dCtcIiBbIFwiK2UrXCIgXVwiOnR9fWNsYXNzIGpuIGV4dGVuZHMgSG57Y29uc3RydWN0b3IoKXtzdXBlcigpLGpuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGRlcHRoRmFjdG9yKHQsZSl7cmV0dXJuIHQ9PT1uZS5FWFRFUklPUiYmZT09PW5lLklOVEVSSU9SPzE6dD09PW5lLklOVEVSSU9SJiZlPT09bmUuRVhURVJJT1I/LTE6MH1nZXROZXh0TWluKCl7cmV0dXJuIHRoaXMuX25leHRNaW59Z2V0RGVwdGgodCl7cmV0dXJuIHRoaXMuX2RlcHRoW3RdfXNldFZpc2l0ZWQodCl7dGhpcy5faXNWaXNpdGVkPXR9Y29tcHV0ZURpcmVjdGVkTGFiZWwoKXt0aGlzLl9sYWJlbD1uZXcgRm4odGhpcy5fZWRnZS5nZXRMYWJlbCgpKSx0aGlzLl9pc0ZvcndhcmR8fHRoaXMuX2xhYmVsLmZsaXAoKX1nZXROZXh0KCl7cmV0dXJuIHRoaXMuX25leHR9c2V0RGVwdGgodCxlKXtpZigtOTk5IT09dGhpcy5fZGVwdGhbdF0mJnRoaXMuX2RlcHRoW3RdIT09ZSl0aHJvdyBuZXcgV24oXCJhc3NpZ25lZCBkZXB0aHMgZG8gbm90IG1hdGNoXCIsdGhpcy5nZXRDb29yZGluYXRlKCkpO3RoaXMuX2RlcHRoW3RdPWV9aXNJbnRlcmlvckFyZWFFZGdlKCl7bGV0IHQ9ITA7Zm9yKGxldCBlPTA7ZTwyO2UrKyl0aGlzLl9sYWJlbC5pc0FyZWEoZSkmJnRoaXMuX2xhYmVsLmdldExvY2F0aW9uKGUsUG4uTEVGVCk9PT1uZS5JTlRFUklPUiYmdGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24oZSxQbi5SSUdIVCk9PT1uZS5JTlRFUklPUnx8KHQ9ITEpO3JldHVybiB0fXNldE5leHRNaW4odCl7dGhpcy5fbmV4dE1pbj10fXByaW50KHQpe3N1cGVyLnByaW50LmNhbGwodGhpcyx0KSx0LnByaW50KFwiIFwiK3RoaXMuX2RlcHRoW1BuLkxFRlRdK1wiL1wiK3RoaXMuX2RlcHRoW1BuLlJJR0hUXSksdC5wcmludChcIiAoXCIrdGhpcy5nZXREZXB0aERlbHRhKCkrXCIpXCIpLHRoaXMuX2lzSW5SZXN1bHQmJnQucHJpbnQoXCIgaW5SZXN1bHRcIil9c2V0TWluRWRnZVJpbmcodCl7dGhpcy5fbWluRWRnZVJpbmc9dH1pc0xpbmVFZGdlKCl7Y29uc3QgdD10aGlzLl9sYWJlbC5pc0xpbmUoMCl8fHRoaXMuX2xhYmVsLmlzTGluZSgxKSxlPSF0aGlzLl9sYWJlbC5pc0FyZWEoMCl8fHRoaXMuX2xhYmVsLmFsbFBvc2l0aW9uc0VxdWFsKDAsbmUuRVhURVJJT1IpLG49IXRoaXMuX2xhYmVsLmlzQXJlYSgxKXx8dGhpcy5fbGFiZWwuYWxsUG9zaXRpb25zRXF1YWwoMSxuZS5FWFRFUklPUik7cmV0dXJuIHQmJmUmJm59c2V0RWRnZVJpbmcodCl7dGhpcy5fZWRnZVJpbmc9dH1nZXRNaW5FZGdlUmluZygpe3JldHVybiB0aGlzLl9taW5FZGdlUmluZ31nZXREZXB0aERlbHRhKCl7bGV0IHQ9dGhpcy5fZWRnZS5nZXREZXB0aERlbHRhKCk7cmV0dXJuIHRoaXMuX2lzRm9yd2FyZHx8KHQ9LXQpLHR9c2V0SW5SZXN1bHQodCl7dGhpcy5faXNJblJlc3VsdD10fWdldFN5bSgpe3JldHVybiB0aGlzLl9zeW19aXNGb3J3YXJkKCl7cmV0dXJuIHRoaXMuX2lzRm9yd2FyZH1nZXRFZGdlKCl7cmV0dXJuIHRoaXMuX2VkZ2V9cHJpbnRFZGdlKHQpe3RoaXMucHJpbnQodCksdC5wcmludChcIiBcIiksdGhpcy5faXNGb3J3YXJkP3RoaXMuX2VkZ2UucHJpbnQodCk6dGhpcy5fZWRnZS5wcmludFJldmVyc2UodCl9c2V0U3ltKHQpe3RoaXMuX3N5bT10fXNldFZpc2l0ZWRFZGdlKHQpe3RoaXMuc2V0VmlzaXRlZCh0KSx0aGlzLl9zeW0uc2V0VmlzaXRlZCh0KX1zZXRFZGdlRGVwdGhzKHQsZSl7bGV0IG49dGhpcy5nZXRFZGdlKCkuZ2V0RGVwdGhEZWx0YSgpO3RoaXMuX2lzRm9yd2FyZHx8KG49LW4pO2xldCBzPTE7dD09PVBuLkxFRlQmJihzPS0xKTtjb25zdCBpPVBuLm9wcG9zaXRlKHQpLHI9ZStuKnM7dGhpcy5zZXREZXB0aCh0LGUpLHRoaXMuc2V0RGVwdGgoaSxyKX1nZXRFZGdlUmluZygpe3JldHVybiB0aGlzLl9lZGdlUmluZ31pc0luUmVzdWx0KCl7cmV0dXJuIHRoaXMuX2lzSW5SZXN1bHR9c2V0TmV4dCh0KXt0aGlzLl9uZXh0PXR9aXNWaXNpdGVkKCl7cmV0dXJuIHRoaXMuX2lzVmlzaXRlZH1nZXRDbGFzcygpe3JldHVybiBqbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19am4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faXNGb3J3YXJkPW51bGwsdGhpcy5faXNJblJlc3VsdD0hMSx0aGlzLl9pc1Zpc2l0ZWQ9ITEsdGhpcy5fc3ltPW51bGwsdGhpcy5fbmV4dD1udWxsLHRoaXMuX25leHRNaW49bnVsbCx0aGlzLl9lZGdlUmluZz1udWxsLHRoaXMuX21pbkVkZ2VSaW5nPW51bGwsdGhpcy5fZGVwdGg9WzAsLTk5OSwtOTk5XTtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZihIbi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpLHRoaXMuX2lzRm9yd2FyZD1lLGUpdGhpcy5pbml0KHQuZ2V0Q29vcmRpbmF0ZSgwKSx0LmdldENvb3JkaW5hdGUoMSkpO2Vsc2V7Y29uc3QgZT10LmdldE51bVBvaW50cygpLTE7dGhpcy5pbml0KHQuZ2V0Q29vcmRpbmF0ZShlKSx0LmdldENvb3JkaW5hdGUoZS0xKSl9dGhpcy5jb21wdXRlRGlyZWN0ZWRMYWJlbCgpfTtjbGFzcyBLbntjb25zdHJ1Y3Rvcigpe0tuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y3JlYXRlTm9kZSh0KXtyZXR1cm4gbmV3IGtuKHQsbnVsbCl9Z2V0Q2xhc3MoKXtyZXR1cm4gS259Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUtuLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgWm57Y29uc3RydWN0b3IoKXtabi5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBsaW5rUmVzdWx0RGlyZWN0ZWRFZGdlcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkuZ2V0RWRnZXMoKS5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcygpfX1wcmludEVkZ2VzKHQpe3QucHJpbnRsbihcIkVkZ2VzOlwiKTtmb3IobGV0IGU9MDtlPHRoaXMuX2VkZ2VzLnNpemUoKTtlKyspe3QucHJpbnRsbihcImVkZ2UgXCIrZStcIjpcIik7Y29uc3Qgbj10aGlzLl9lZGdlcy5nZXQoZSk7bi5wcmludCh0KSxuLmVpTGlzdC5wcmludCh0KX19ZmluZCh0KXtyZXR1cm4gdGhpcy5fbm9kZXMuZmluZCh0KX1hZGROb2RlKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBrbil7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX25vZGVzLmFkZE5vZGUodCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fbm9kZXMuYWRkTm9kZSh0KX19Z2V0Tm9kZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX25vZGVzLml0ZXJhdG9yKCl9bGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKXtmb3IobGV0IHQ9dGhpcy5fbm9kZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLmdldEVkZ2VzKCkubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKX19ZGVidWdQcmludGxuKHQpe08ub3V0LnByaW50bG4odCl9aXNCb3VuZGFyeU5vZGUodCxlKXtjb25zdCBuPXRoaXMuX25vZGVzLmZpbmQoZSk7aWYobnVsbD09PW4pcmV0dXJuITE7Y29uc3Qgcz1uLmdldExhYmVsKCk7cmV0dXJuIG51bGwhPT1zJiZzLmdldExvY2F0aW9uKHQpPT09bmUuQk9VTkRBUll9bGlua0FsbERpcmVjdGVkRWRnZXMoKXtmb3IobGV0IHQ9dGhpcy5fbm9kZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLmdldEVkZ2VzKCkubGlua0FsbERpcmVjdGVkRWRnZXMoKX19bWF0Y2hJblNhbWVEaXJlY3Rpb24odCxlLG4scyl7cmV0dXJuISF0LmVxdWFscyhuKSYmKHYuaW5kZXgodCxlLHMpPT09di5DT0xMSU5FQVImJkluLnF1YWRyYW50KHQsZSk9PT1Jbi5xdWFkcmFudChuLHMpKX1nZXRFZGdlRW5kcygpe3JldHVybiB0aGlzLl9lZGdlRW5kTGlzdH1kZWJ1Z1ByaW50KHQpe08ub3V0LnByaW50KHQpfWdldEVkZ2VJdGVyYXRvcigpe3JldHVybiB0aGlzLl9lZGdlcy5pdGVyYXRvcigpfWZpbmRFZGdlSW5TYW1lRGlyZWN0aW9uKHQsZSl7Zm9yKGxldCBuPTA7bjx0aGlzLl9lZGdlcy5zaXplKCk7bisrKXtjb25zdCBzPXRoaXMuX2VkZ2VzLmdldChuKSxpPXMuZ2V0Q29vcmRpbmF0ZXMoKTtpZih0aGlzLm1hdGNoSW5TYW1lRGlyZWN0aW9uKHQsZSxpWzBdLGlbMV0pKXJldHVybiBzO2lmKHRoaXMubWF0Y2hJblNhbWVEaXJlY3Rpb24odCxlLGlbaS5sZW5ndGgtMV0saVtpLmxlbmd0aC0yXSkpcmV0dXJuIHN9cmV0dXJuIG51bGx9aW5zZXJ0RWRnZSh0KXt0aGlzLl9lZGdlcy5hZGQodCl9ZmluZEVkZ2VFbmQodCl7Zm9yKGxldCBlPXRoaXMuZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtpZihuLmdldEVkZ2UoKT09PXQpcmV0dXJuIG59cmV0dXJuIG51bGx9YWRkRWRnZXModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dGhpcy5fZWRnZXMuYWRkKHQpO2NvbnN0IG49bmV3IGpuKHQsITApLHM9bmV3IGpuKHQsITEpO24uc2V0U3ltKHMpLHMuc2V0U3ltKG4pLHRoaXMuYWRkKG4pLHRoaXMuYWRkKHMpfX1hZGQodCl7dGhpcy5fbm9kZXMuYWRkKHQpLHRoaXMuX2VkZ2VFbmRMaXN0LmFkZCh0KX1nZXROb2Rlcygpe3JldHVybiB0aGlzLl9ub2Rlcy52YWx1ZXMoKX1maW5kRWRnZSh0LGUpe2ZvcihsZXQgbj0wO248dGhpcy5fZWRnZXMuc2l6ZSgpO24rKyl7Y29uc3Qgcz10aGlzLl9lZGdlcy5nZXQobiksaT1zLmdldENvb3JkaW5hdGVzKCk7aWYodC5lcXVhbHMoaVswXSkmJmUuZXF1YWxzKGlbMV0pKXJldHVybiBzfXJldHVybiBudWxsfWdldENsYXNzKCl7cmV0dXJuIFpufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1abi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9lZGdlcz1uZXcgeCx0aGlzLl9ub2Rlcz1udWxsLHRoaXMuX2VkZ2VFbmRMaXN0PW5ldyB4LDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuX25vZGVzPW5ldyBYbihuZXcgS24pO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX25vZGVzPW5ldyBYbih0KX19O2NsYXNzIFFuIGV4dGVuZHMgWm57Y29uc3RydWN0b3IoKXtzdXBlcigpLFFuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGRldGVybWluZUJvdW5kYXJ5KHQsZSl7cmV0dXJuIHQuaXNJbkJvdW5kYXJ5KGUpP25lLkJPVU5EQVJZOm5lLklOVEVSSU9SfWluc2VydEJvdW5kYXJ5UG9pbnQodCxlKXtjb25zdCBuPXRoaXMuX25vZGVzLmFkZE5vZGUoZSkuZ2V0TGFiZWwoKTtsZXQgcz0xLGk9bmUuTk9ORTtpPW4uZ2V0TG9jYXRpb24odCxQbi5PTiksaT09PW5lLkJPVU5EQVJZJiZzKys7Y29uc3Qgcj1Rbi5kZXRlcm1pbmVCb3VuZGFyeSh0aGlzLl9ib3VuZGFyeU5vZGVSdWxlLHMpO24uc2V0TG9jYXRpb24odCxyKX1jb21wdXRlU2VsZk5vZGVzKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmNvbXB1dGVTZWxmTm9kZXModCxlLCExKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1uZXcgTW4odCwhMCwhMSk7cy5zZXRJc0RvbmVJZlByb3BlckludChuKTtjb25zdCBpPXRoaXMuY3JlYXRlRWRnZVNldEludGVyc2VjdG9yKCkscj10aGlzLl9wYXJlbnRHZW9tIGluc3RhbmNlb2YgRHR8fHRoaXMuX3BhcmVudEdlb20gaW5zdGFuY2VvZiBidHx8dGhpcy5fcGFyZW50R2VvbSBpbnN0YW5jZW9mIEF0LG89ZXx8IXI7cmV0dXJuIGkuY29tcHV0ZUludGVyc2VjdGlvbnModGhpcy5fZWRnZXMscyxvKSx0aGlzLmFkZFNlbGZJbnRlcnNlY3Rpb25Ob2Rlcyh0aGlzLl9hcmdJbmRleCksc319Y29tcHV0ZVNwbGl0RWRnZXModCl7Zm9yKGxldCBlPXRoaXMuX2VkZ2VzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5laUxpc3QuYWRkU3BsaXRFZGdlcyh0KX19Y29tcHV0ZUVkZ2VJbnRlcnNlY3Rpb25zKHQsZSxuKXtjb25zdCBzPW5ldyBNbihlLG4sITApO3JldHVybiBzLnNldEJvdW5kYXJ5Tm9kZXModGhpcy5nZXRCb3VuZGFyeU5vZGVzKCksdC5nZXRCb3VuZGFyeU5vZGVzKCkpLHRoaXMuY3JlYXRlRWRnZVNldEludGVyc2VjdG9yKCkuY29tcHV0ZUludGVyc2VjdGlvbnModGhpcy5fZWRnZXMsdC5fZWRnZXMscyksc31nZXRHZW9tZXRyeSgpe3JldHVybiB0aGlzLl9wYXJlbnRHZW9tfWdldEJvdW5kYXJ5Tm9kZVJ1bGUoKXtyZXR1cm4gdGhpcy5fYm91bmRhcnlOb2RlUnVsZX1oYXNUb29GZXdQb2ludHMoKXtyZXR1cm4gdGhpcy5faGFzVG9vRmV3UG9pbnRzfWFkZFBvaW50KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBQdCl7Y29uc3QgdD1hcmd1bWVudHNbMF0uZ2V0Q29vcmRpbmF0ZSgpO3RoaXMuaW5zZXJ0UG9pbnQodGhpcy5fYXJnSW5kZXgsdCxuZS5JTlRFUklPUil9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5zZXJ0UG9pbnQodGhpcy5fYXJnSW5kZXgsdCxuZS5JTlRFUklPUil9fWFkZFBvbHlnb24odCl7dGhpcy5hZGRQb2x5Z29uUmluZyh0LmdldEV4dGVyaW9yUmluZygpLG5lLkVYVEVSSU9SLG5lLklOVEVSSU9SKTtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKXtjb25zdCBuPXQuZ2V0SW50ZXJpb3JSaW5nTihlKTt0aGlzLmFkZFBvbHlnb25SaW5nKG4sbmUuSU5URVJJT1IsbmUuRVhURVJJT1IpfX1hZGRFZGdlKHQpe3RoaXMuaW5zZXJ0RWRnZSh0KTtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZXMoKTt0aGlzLmluc2VydFBvaW50KHRoaXMuX2FyZ0luZGV4LGVbMF0sbmUuQk9VTkRBUlkpLHRoaXMuaW5zZXJ0UG9pbnQodGhpcy5fYXJnSW5kZXgsZVtlLmxlbmd0aC0xXSxuZS5CT1VOREFSWSl9YWRkTGluZVN0cmluZyh0KXtjb25zdCBlPVgucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKTtpZihlLmxlbmd0aDwyKXJldHVybiB0aGlzLl9oYXNUb29GZXdQb2ludHM9ITAsdGhpcy5faW52YWxpZFBvaW50PWVbMF0sbnVsbDtjb25zdCBuPW5ldyBVbihlLG5ldyBGbih0aGlzLl9hcmdJbmRleCxuZS5JTlRFUklPUikpO3RoaXMuX2xpbmVFZGdlTWFwLnB1dCh0LG4pLHRoaXMuaW5zZXJ0RWRnZShuKSx1LmlzVHJ1ZShlLmxlbmd0aD49MixcImZvdW5kIExpbmVTdHJpbmcgd2l0aCBzaW5nbGUgcG9pbnRcIiksdGhpcy5pbnNlcnRCb3VuZGFyeVBvaW50KHRoaXMuX2FyZ0luZGV4LGVbMF0pLHRoaXMuaW5zZXJ0Qm91bmRhcnlQb2ludCh0aGlzLl9hcmdJbmRleCxlW2UubGVuZ3RoLTFdKX1nZXRJbnZhbGlkUG9pbnQoKXtyZXR1cm4gdGhpcy5faW52YWxpZFBvaW50fWdldEJvdW5kYXJ5UG9pbnRzKCl7Y29uc3QgdD10aGlzLmdldEJvdW5kYXJ5Tm9kZXMoKSxlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtsZXQgbj0wO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO2VbbisrXT10LmdldENvb3JkaW5hdGUoKS5jb3B5KCl9cmV0dXJuIGV9Z2V0Qm91bmRhcnlOb2Rlcygpe3JldHVybiBudWxsPT09dGhpcy5fYm91bmRhcnlOb2RlcyYmKHRoaXMuX2JvdW5kYXJ5Tm9kZXM9dGhpcy5fbm9kZXMuZ2V0Qm91bmRhcnlOb2Rlcyh0aGlzLl9hcmdJbmRleCkpLHRoaXMuX2JvdW5kYXJ5Tm9kZXN9YWRkU2VsZkludGVyc2VjdGlvbk5vZGUodCxlLG4pe2lmKHRoaXMuaXNCb3VuZGFyeU5vZGUodCxlKSlyZXR1cm4gbnVsbDtuPT09bmUuQk9VTkRBUlkmJnRoaXMuX3VzZUJvdW5kYXJ5RGV0ZXJtaW5hdGlvblJ1bGU/dGhpcy5pbnNlcnRCb3VuZGFyeVBvaW50KHQsZSk6dGhpcy5pbnNlcnRQb2ludCh0LGUsbil9YWRkUG9seWdvblJpbmcodCxlLG4pe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IHM9WC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2lmKHMubGVuZ3RoPDQpcmV0dXJuIHRoaXMuX2hhc1Rvb0Zld1BvaW50cz0hMCx0aGlzLl9pbnZhbGlkUG9pbnQ9c1swXSxudWxsO2xldCBpPWUscj1uO3YuaXNDQ1cocykmJihpPW4scj1lKTtjb25zdCBvPW5ldyBVbihzLG5ldyBGbih0aGlzLl9hcmdJbmRleCxuZS5CT1VOREFSWSxpLHIpKTt0aGlzLl9saW5lRWRnZU1hcC5wdXQodCxvKSx0aGlzLmluc2VydEVkZ2UobyksdGhpcy5pbnNlcnRQb2ludCh0aGlzLl9hcmdJbmRleCxzWzBdLG5lLkJPVU5EQVJZKX1pbnNlcnRQb2ludCh0LGUsbil7Y29uc3Qgcz10aGlzLl9ub2Rlcy5hZGROb2RlKGUpLGk9cy5nZXRMYWJlbCgpO251bGw9PT1pP3MuX2xhYmVsPW5ldyBGbih0LG4pOmkuc2V0TG9jYXRpb24odCxuKX1jcmVhdGVFZGdlU2V0SW50ZXJzZWN0b3IoKXtyZXR1cm4gbmV3IERufWFkZFNlbGZJbnRlcnNlY3Rpb25Ob2Rlcyh0KXtmb3IobGV0IGU9dGhpcy5fZWRnZXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkscz1uLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCk7Zm9yKGxldCBlPW4uZWlMaXN0Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO3RoaXMuYWRkU2VsZkludGVyc2VjdGlvbk5vZGUodCxuLmNvb3JkLHMpfX19YWRkKCl7aWYoISgxPT09YXJndW1lbnRzLmxlbmd0aCYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKSlyZXR1cm4gc3VwZXIuYWRkLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7aWYodCBpbnN0YW5jZW9mIEF0JiYodGhpcy5fdXNlQm91bmRhcnlEZXRlcm1pbmF0aW9uUnVsZT0hMSksdCBpbnN0YW5jZW9mIGJ0KXRoaXMuYWRkUG9seWdvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBUdCl0aGlzLmFkZExpbmVTdHJpbmcodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgUHQpdGhpcy5hZGRQb2ludCh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBNdCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgZnQpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIEF0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNle2lmKCEodCBpbnN0YW5jZW9mIF90KSl0aHJvdyBuZXcgWih0LmdldENsYXNzKCkuZ2V0TmFtZSgpKTt0aGlzLmFkZENvbGxlY3Rpb24odCl9fX1hZGRDb2xsZWN0aW9uKHQpe2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpO3RoaXMuYWRkKG4pfX1sb2NhdGUodCl7cmV0dXJuIF8odGhpcy5fcGFyZW50R2VvbSxPdCkmJnRoaXMuX3BhcmVudEdlb20uZ2V0TnVtR2VvbWV0cmllcygpPjUwPyhudWxsPT09dGhpcy5fYXJlYVB0TG9jYXRvciYmKHRoaXMuX2FyZWFQdExvY2F0b3I9bmV3IGtlKHRoaXMuX3BhcmVudEdlb20pKSx0aGlzLl9hcmVhUHRMb2NhdG9yLmxvY2F0ZSh0KSk6dGhpcy5fcHRMb2NhdG9yLmxvY2F0ZSh0LHRoaXMuX3BhcmVudEdlb20pfWZpbmRFZGdlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgVHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9saW5lRWRnZU1hcC5nZXQodCl9cmV0dXJuIHN1cGVyLmZpbmRFZGdlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDbGFzcygpe3JldHVybiBRbn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19UW4uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fcGFyZW50R2VvbT1udWxsLHRoaXMuX2xpbmVFZGdlTWFwPW5ldyBVdCx0aGlzLl9ib3VuZGFyeU5vZGVSdWxlPW51bGwsdGhpcy5fdXNlQm91bmRhcnlEZXRlcm1pbmF0aW9uUnVsZT0hMCx0aGlzLl9hcmdJbmRleD1udWxsLHRoaXMuX2JvdW5kYXJ5Tm9kZXM9bnVsbCx0aGlzLl9oYXNUb29GZXdQb2ludHM9ITEsdGhpcy5faW52YWxpZFBvaW50PW51bGwsdGhpcy5fYXJlYVB0TG9jYXRvcj1udWxsLHRoaXMuX3B0TG9jYXRvcj1uZXcgX24sMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO1FuLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLFYuT0dDX1NGU19CT1VOREFSWV9SVUxFKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9hcmdJbmRleD10LHRoaXMuX3BhcmVudEdlb209ZSx0aGlzLl9ib3VuZGFyeU5vZGVSdWxlPW4sbnVsbCE9PWUmJnRoaXMuYWRkKGUpfX07dmFyIEpuPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEdlb21ldHJ5R3JhcGg6UW59KTtjbGFzcyAkbntjb25zdHJ1Y3RvcigpeyRuLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmlzaXQodCl7fWdldENsYXNzKCl7cmV0dXJuICRufWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX0kbi5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIHRze2NvbnN0cnVjdG9yKCl7dHMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pc1JlcGVhdGVkKCl7cmV0dXJuIHRoaXMuX2NvdW50PjF9Z2V0UmlnaHQoKXtyZXR1cm4gdGhpcy5fcmlnaHR9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9wfXNldExlZnQodCl7dGhpcy5fbGVmdD10fWdldFgoKXtyZXR1cm4gdGhpcy5fcC54fWdldERhdGEoKXtyZXR1cm4gdGhpcy5fZGF0YX1nZXRDb3VudCgpe3JldHVybiB0aGlzLl9jb3VudH1nZXRMZWZ0KCl7cmV0dXJuIHRoaXMuX2xlZnR9Z2V0WSgpe3JldHVybiB0aGlzLl9wLnl9aW5jcmVtZW50KCl7dGhpcy5fY291bnQ9dGhpcy5fY291bnQrMX1zZXRSaWdodCh0KXt0aGlzLl9yaWdodD10fWdldENsYXNzKCl7cmV0dXJuIHRzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX10cy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9wPW51bGwsdGhpcy5fZGF0YT1udWxsLHRoaXMuX2xlZnQ9bnVsbCx0aGlzLl9yaWdodD1udWxsLHRoaXMuX2NvdW50PW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3A9bmV3IGcodCksdGhpcy5fbGVmdD1udWxsLHRoaXMuX3JpZ2h0PW51bGwsdGhpcy5fY291bnQ9MSx0aGlzLl9kYXRhPWV9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fcD1uZXcgZyh0LGUpLHRoaXMuX2xlZnQ9bnVsbCx0aGlzLl9yaWdodD1udWxsLHRoaXMuX2NvdW50PTEsdGhpcy5fZGF0YT1ufX07Y2xhc3MgZXN7Y29uc3RydWN0b3IoKXtlcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyB0b0Nvb3JkaW5hdGVzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBlcy50b0Nvb3JkaW5hdGVzKHQsITEpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBJO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpLGk9ZT90LmdldENvdW50KCk6MTtmb3IobGV0IGU9MDtlPGk7ZSsrKW4uYWRkKHQuZ2V0Q29vcmRpbmF0ZSgpLCEwKX1yZXR1cm4gbi50b0Nvb3JkaW5hdGVBcnJheSgpfX1pbnNlcnQoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaW5zZXJ0KHQsbnVsbCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKG51bGw9PT10aGlzLl9yb290KXJldHVybiB0aGlzLl9yb290PW5ldyB0cyh0LGUpLHRoaXMuX3Jvb3Q7aWYodGhpcy5fdG9sZXJhbmNlPjApe2NvbnN0IGU9dGhpcy5maW5kQmVzdE1hdGNoTm9kZSh0KTtpZihudWxsIT09ZSlyZXR1cm4gZS5pbmNyZW1lbnQoKSxlfXJldHVybiB0aGlzLmluc2VydEV4YWN0KHQsZSl9fXF1ZXJ5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IHg7cmV0dXJuIHRoaXMucXVlcnkodCxlKSxlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTiYmXyhhcmd1bWVudHNbMV0sbSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMucXVlcnlOb2RlKHRoaXMuX3Jvb3QsdCwhMCxuZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuWyRuXX12aXNpdCh0KXtlLmFkZCh0KX19KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTiYmXyhhcmd1bWVudHNbMV0sJG4pKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnF1ZXJ5Tm9kZSh0aGlzLl9yb290LHQsITAsZSl9fXF1ZXJ5Tm9kZSh0LGUsbixzKXtpZihudWxsPT09dClyZXR1cm4gbnVsbDtsZXQgaT1udWxsLHI9bnVsbCxvPW51bGw7bj8oaT1lLmdldE1pblgoKSxyPWUuZ2V0TWF4WCgpLG89dC5nZXRYKCkpOihpPWUuZ2V0TWluWSgpLHI9ZS5nZXRNYXhZKCksbz10LmdldFkoKSk7Y29uc3QgbD1vPD1yO2k8byYmdGhpcy5xdWVyeU5vZGUodC5nZXRMZWZ0KCksZSwhbixzKSxlLmNvbnRhaW5zKHQuZ2V0Q29vcmRpbmF0ZSgpKSYmcy52aXNpdCh0KSxsJiZ0aGlzLnF1ZXJ5Tm9kZSh0LmdldFJpZ2h0KCksZSwhbixzKX1maW5kQmVzdE1hdGNoTm9kZSh0KXtjb25zdCBlPW5ldyBucyh0LHRoaXMuX3RvbGVyYW5jZSk7cmV0dXJuIHRoaXMucXVlcnkoZS5xdWVyeUVudmVsb3BlKCksZSksZS5nZXROb2RlKCl9aXNFbXB0eSgpe3JldHVybiBudWxsPT09dGhpcy5fcm9vdH1pbnNlcnRFeGFjdCh0LGUpe2xldCBuPXRoaXMuX3Jvb3Qscz10aGlzLl9yb290LGk9ITAscj0hMDtmb3IoO251bGwhPT1uOyl7aWYobnVsbCE9PW4pe2lmKHQuZGlzdGFuY2Uobi5nZXRDb29yZGluYXRlKCkpPD10aGlzLl90b2xlcmFuY2UpcmV0dXJuIG4uaW5jcmVtZW50KCksbn1yPWk/dC54PG4uZ2V0WCgpOnQueTxuLmdldFkoKSxzPW4sbj1yP24uZ2V0TGVmdCgpOm4uZ2V0UmlnaHQoKSxpPSFpfXRoaXMuX251bWJlck9mTm9kZXM9dGhpcy5fbnVtYmVyT2ZOb2RlcysxO2NvbnN0IG89bmV3IHRzKHQsZSk7cmV0dXJuIHI/cy5zZXRMZWZ0KG8pOnMuc2V0UmlnaHQobyksb31nZXRDbGFzcygpe3JldHVybiBlc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3MgbnN7Y29uc3RydWN0b3IoKXtucy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXZpc2l0KHQpe2NvbnN0IGU9dGhpcy5fcC5kaXN0YW5jZSh0LmdldENvb3JkaW5hdGUoKSk7aWYoIShlPD10aGlzLl90b2xlcmFuY2UpKXJldHVybiBudWxsO2xldCBuPSExOyhudWxsPT09dGhpcy5fbWF0Y2hOb2RlfHxlPHRoaXMuX21hdGNoRGlzdHx8bnVsbCE9PXRoaXMuX21hdGNoTm9kZSYmZT09PXRoaXMuX21hdGNoRGlzdCYmdC5nZXRDb29yZGluYXRlKCkuY29tcGFyZVRvKHRoaXMuX21hdGNoTm9kZS5nZXRDb29yZGluYXRlKCkpPDEpJiYobj0hMCksbiYmKHRoaXMuX21hdGNoTm9kZT10LHRoaXMuX21hdGNoRGlzdD1lKX1xdWVyeUVudmVsb3BlKCl7Y29uc3QgdD1uZXcgTih0aGlzLl9wKTtyZXR1cm4gdC5leHBhbmRCeSh0aGlzLl90b2xlcmFuY2UpLHR9Z2V0Tm9kZSgpe3JldHVybiB0aGlzLl9tYXRjaE5vZGV9Z2V0Q2xhc3MoKXtyZXR1cm4gbnN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuWyRuXX19bnMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fdG9sZXJhbmNlPW51bGwsdGhpcy5fbWF0Y2hOb2RlPW51bGwsdGhpcy5fbWF0Y2hEaXN0PTAsdGhpcy5fcD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3A9dCx0aGlzLl90b2xlcmFuY2U9ZX0sZXMuQmVzdE1hdGNoVmlzaXRvcj1ucyxlcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9yb290PW51bGwsdGhpcy5fbnVtYmVyT2ZOb2Rlcz1udWxsLHRoaXMuX3RvbGVyYW5jZT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKWVzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsMCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fdG9sZXJhbmNlPXR9fTt2YXIgc3M9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsS2RUcmVlOmVzfSk7Y2xhc3MgaXN7Y29uc3RydWN0b3IoKXtpcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBnZXRTdWJub2RlSW5kZXgodCxlLG4pe2xldCBzPS0xO3JldHVybiB0LmdldE1pblgoKT49ZSYmKHQuZ2V0TWluWSgpPj1uJiYocz0zKSx0LmdldE1heFkoKTw9biYmKHM9MSkpLHQuZ2V0TWF4WCgpPD1lJiYodC5nZXRNaW5ZKCk+PW4mJihzPTIpLHQuZ2V0TWF4WSgpPD1uJiYocz0wKSksc31oYXNDaGlsZHJlbigpe2ZvcihsZXQgdD0wO3Q8NDt0KyspaWYobnVsbCE9PXRoaXMuX3N1Ym5vZGVbdF0pcmV0dXJuITA7cmV0dXJuITF9aXNQcnVuYWJsZSgpe3JldHVybiEodGhpcy5oYXNDaGlsZHJlbigpfHx0aGlzLmhhc0l0ZW1zKCkpfWFkZEFsbEl0ZW1zKHQpe3QuYWRkQWxsKHRoaXMuX2l0ZW1zKTtmb3IobGV0IGU9MDtlPDQ7ZSsrKW51bGwhPT10aGlzLl9zdWJub2RlW2VdJiZ0aGlzLl9zdWJub2RlW2VdLmFkZEFsbEl0ZW1zKHQpO3JldHVybiB0fWdldE5vZGVDb3VudCgpe2xldCB0PTA7Zm9yKGxldCBlPTA7ZTw0O2UrKyludWxsIT09dGhpcy5fc3Vibm9kZVtlXSYmKHQrPXRoaXMuX3N1Ym5vZGVbZV0uc2l6ZSgpKTtyZXR1cm4gdCsxfXNpemUoKXtsZXQgdD0wO2ZvcihsZXQgZT0wO2U8NDtlKyspbnVsbCE9PXRoaXMuX3N1Ym5vZGVbZV0mJih0Kz10aGlzLl9zdWJub2RlW2VdLnNpemUoKSk7cmV0dXJuIHQrdGhpcy5faXRlbXMuc2l6ZSgpfWFkZEFsbEl0ZW1zRnJvbU92ZXJsYXBwaW5nKHQsZSl7aWYoIXRoaXMuaXNTZWFyY2hNYXRjaCh0KSlyZXR1cm4gbnVsbDtlLmFkZEFsbCh0aGlzLl9pdGVtcyk7Zm9yKGxldCBuPTA7bjw0O24rKyludWxsIT09dGhpcy5fc3Vibm9kZVtuXSYmdGhpcy5fc3Vibm9kZVtuXS5hZGRBbGxJdGVtc0Zyb21PdmVybGFwcGluZyh0LGUpfXZpc2l0SXRlbXModCxlKXtmb3IobGV0IHQ9dGhpcy5faXRlbXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspZS52aXNpdEl0ZW0odC5uZXh0KCkpfWhhc0l0ZW1zKCl7cmV0dXJuIXRoaXMuX2l0ZW1zLmlzRW1wdHkoKX1yZW1vdmUodCxlKXtpZighdGhpcy5pc1NlYXJjaE1hdGNoKHQpKXJldHVybiExO2xldCBuPSExO2ZvcihsZXQgcz0wO3M8NDtzKyspaWYobnVsbCE9PXRoaXMuX3N1Ym5vZGVbc10mJihuPXRoaXMuX3N1Ym5vZGVbc10ucmVtb3ZlKHQsZSksbikpe3RoaXMuX3N1Ym5vZGVbc10uaXNQcnVuYWJsZSgpJiYodGhpcy5fc3Vibm9kZVtzXT1udWxsKTticmVha31yZXR1cm4gbnx8KG49dGhpcy5faXRlbXMucmVtb3ZlKGUpLG4pfXZpc2l0KHQsZSl7aWYoIXRoaXMuaXNTZWFyY2hNYXRjaCh0KSlyZXR1cm4gbnVsbDt0aGlzLnZpc2l0SXRlbXModCxlKTtmb3IobGV0IG49MDtuPDQ7bisrKW51bGwhPT10aGlzLl9zdWJub2RlW25dJiZ0aGlzLl9zdWJub2RlW25dLnZpc2l0KHQsZSl9Z2V0SXRlbXMoKXtyZXR1cm4gdGhpcy5faXRlbXN9ZGVwdGgoKXtsZXQgdD0wO2ZvcihsZXQgZT0wO2U8NDtlKyspaWYobnVsbCE9PXRoaXMuX3N1Ym5vZGVbZV0pe2NvbnN0IG49dGhpcy5fc3Vibm9kZVtlXS5kZXB0aCgpO24+dCYmKHQ9bil9cmV0dXJuIHQrMX1pc0VtcHR5KCl7bGV0IHQ9ITA7aWYodGhpcy5faXRlbXMuaXNFbXB0eSgpKXtmb3IobGV0IGU9MDtlPDQ7ZSsrKWlmKG51bGwhPT10aGlzLl9zdWJub2RlW2VdJiYhdGhpcy5fc3Vibm9kZVtlXS5pc0VtcHR5KCkpe3Q9ITE7YnJlYWt9fWVsc2UgdD0hMTtyZXR1cm4gdH1hZGQodCl7dGhpcy5faXRlbXMuYWRkKHQpfWdldENsYXNzKCl7cmV0dXJuIGlzfWdldCBpbnRlcmZhY2VzXygpe3JldHVyblthXX19ZnVuY3Rpb24gcnMoKXt9aXMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faXRlbXM9bmV3IHgsdGhpcy5fc3Vibm9kZT1uZXcgQXJyYXkoNCkuZmlsbChudWxsKX0scnMuZXhwb25lbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7bGV0IG4scyxpLHI7Y29uc3Qgbz17MzI6e2Q6MTI3LGM6MTI4LGI6MCxhOjB9LDY0OntkOjMyNzUyLGM6MCxiOjAsYTowfX0sbD17MzI6OCw2NDoxMX1bdF07cnx8KG49ZTwwfHwxL2U8MCxpc0Zpbml0ZShlKXx8KHI9b1t0XSxuJiYoci5kKz0xPDx0LzQtMSkscz1NYXRoLnBvdygyLGwpLTEsaT0wKSk7aWYoIXIpe2ZvcihzPXszMjoxMjcsNjQ6MTAyM31bdF0saT1NYXRoLmFicyhlKTtpPj0yOylzKyssaS89Mjtmb3IoO2k8MSYmcz4wOylzLS0saSo9MjtzPD0wJiYoaS89MiksMzI9PT10JiZzPjI1NCYmKHI9e2Q6bj8yNTU6MTI3LGM6MTI4LGI6MCxhOjB9LHM9TWF0aC5wb3coMixsKS0xLGk9MCl9cmV0dXJuIHN9KDY0LHQpLTEwMjN9LHJzLnBvd2VyT2YyPWZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLnBvdygyLHQpfTtjbGFzcyBvc3tjb25zdHJ1Y3Rvcigpe29zLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbXB1dGVRdWFkTGV2ZWwodCl7Y29uc3QgZT10LmdldFdpZHRoKCksbj10LmdldEhlaWdodCgpLHM9ZT5uP2U6bjtyZXR1cm4gcnMuZXhwb25lbnQocykrMX1nZXRMZXZlbCgpe3JldHVybiB0aGlzLl9sZXZlbH1jb21wdXRlS2V5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2Zvcih0aGlzLl9sZXZlbD1vcy5jb21wdXRlUXVhZExldmVsKHQpLHRoaXMuX2Vudj1uZXcgTix0aGlzLmNvbXB1dGVLZXkodGhpcy5fbGV2ZWwsdCk7IXRoaXMuX2Vudi5jb250YWlucyh0KTspdGhpcy5fbGV2ZWwrPTEsdGhpcy5jb21wdXRlS2V5KHRoaXMuX2xldmVsLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49cnMucG93ZXJPZjIodCk7dGhpcy5fcHQueD1NYXRoLmZsb29yKGUuZ2V0TWluWCgpL24pKm4sdGhpcy5fcHQueT1NYXRoLmZsb29yKGUuZ2V0TWluWSgpL24pKm4sdGhpcy5fZW52LmluaXQodGhpcy5fcHQueCx0aGlzLl9wdC54K24sdGhpcy5fcHQueSx0aGlzLl9wdC55K24pfX1nZXRFbnZlbG9wZSgpe3JldHVybiB0aGlzLl9lbnZ9Z2V0Q2VudHJlKCl7cmV0dXJuIG5ldyBnKCh0aGlzLl9lbnYuZ2V0TWluWCgpK3RoaXMuX2Vudi5nZXRNYXhYKCkpLzIsKHRoaXMuX2Vudi5nZXRNaW5ZKCkrdGhpcy5fZW52LmdldE1heFkoKSkvMil9Z2V0UG9pbnQoKXtyZXR1cm4gdGhpcy5fcHR9Z2V0Q2xhc3MoKXtyZXR1cm4gb3N9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fW9zLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3B0PW5ldyBnLHRoaXMuX2xldmVsPTAsdGhpcy5fZW52PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5jb21wdXRlS2V5KHQpfTtjbGFzcyBscyBleHRlbmRzIGlze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxscy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjcmVhdGVOb2RlKHQpe2NvbnN0IGU9bmV3IG9zKHQpO3JldHVybiBuZXcgbHMoZS5nZXRFbnZlbG9wZSgpLGUuZ2V0TGV2ZWwoKSl9c3RhdGljIGNyZWF0ZUV4cGFuZGVkKHQsZSl7Y29uc3Qgbj1uZXcgTihlKTtudWxsIT09dCYmbi5leHBhbmRUb0luY2x1ZGUodC5fZW52KTtjb25zdCBzPWxzLmNyZWF0ZU5vZGUobik7cmV0dXJuIG51bGwhPT10JiZzLmluc2VydE5vZGUodCksc31maW5kKHQpe2NvbnN0IGU9aXMuZ2V0U3Vibm9kZUluZGV4KHQsdGhpcy5fY2VudHJleCx0aGlzLl9jZW50cmV5KTtpZigtMT09PWUpcmV0dXJuIHRoaXM7aWYobnVsbCE9PXRoaXMuX3N1Ym5vZGVbZV0pe3JldHVybiB0aGlzLl9zdWJub2RlW2VdLmZpbmQodCl9cmV0dXJuIHRoaXN9aXNTZWFyY2hNYXRjaCh0KXtyZXR1cm4gbnVsbCE9PXQmJnRoaXMuX2Vudi5pbnRlcnNlY3RzKHQpfWdldFN1Ym5vZGUodCl7cmV0dXJuIG51bGw9PT10aGlzLl9zdWJub2RlW3RdJiYodGhpcy5fc3Vibm9kZVt0XT10aGlzLmNyZWF0ZVN1Ym5vZGUodCkpLHRoaXMuX3N1Ym5vZGVbdF19Z2V0RW52ZWxvcGUoKXtyZXR1cm4gdGhpcy5fZW52fWdldE5vZGUodCl7Y29uc3QgZT1pcy5nZXRTdWJub2RlSW5kZXgodCx0aGlzLl9jZW50cmV4LHRoaXMuX2NlbnRyZXkpO2lmKC0xIT09ZSl7cmV0dXJuIHRoaXMuZ2V0U3Vibm9kZShlKS5nZXROb2RlKHQpfXJldHVybiB0aGlzfWNyZWF0ZVN1Ym5vZGUodCl7bGV0IGU9MCxuPTAscz0wLGk9MDtzd2l0Y2godCl7Y2FzZSAwOmU9dGhpcy5fZW52LmdldE1pblgoKSxuPXRoaXMuX2NlbnRyZXgscz10aGlzLl9lbnYuZ2V0TWluWSgpLGk9dGhpcy5fY2VudHJleTticmVhaztjYXNlIDE6ZT10aGlzLl9jZW50cmV4LG49dGhpcy5fZW52LmdldE1heFgoKSxzPXRoaXMuX2Vudi5nZXRNaW5ZKCksaT10aGlzLl9jZW50cmV5O2JyZWFrO2Nhc2UgMjplPXRoaXMuX2Vudi5nZXRNaW5YKCksbj10aGlzLl9jZW50cmV4LHM9dGhpcy5fY2VudHJleSxpPXRoaXMuX2Vudi5nZXRNYXhZKCk7YnJlYWs7Y2FzZSAzOmU9dGhpcy5fY2VudHJleCxuPXRoaXMuX2Vudi5nZXRNYXhYKCkscz10aGlzLl9jZW50cmV5LGk9dGhpcy5fZW52LmdldE1heFkoKX1jb25zdCByPW5ldyBOKGUsbixzLGkpO3JldHVybiBuZXcgbHMocix0aGlzLl9sZXZlbC0xKX1pbnNlcnROb2RlKHQpe3UuaXNUcnVlKG51bGw9PT10aGlzLl9lbnZ8fHRoaXMuX2Vudi5jb250YWlucyh0Ll9lbnYpKTtjb25zdCBlPWlzLmdldFN1Ym5vZGVJbmRleCh0Ll9lbnYsdGhpcy5fY2VudHJleCx0aGlzLl9jZW50cmV5KTtpZih0Ll9sZXZlbD09PXRoaXMuX2xldmVsLTEpdGhpcy5fc3Vibm9kZVtlXT10O2Vsc2V7Y29uc3Qgbj10aGlzLmNyZWF0ZVN1Ym5vZGUoZSk7bi5pbnNlcnROb2RlKHQpLHRoaXMuX3N1Ym5vZGVbZV09bn19Z2V0Q2xhc3MoKXtyZXR1cm4gbHN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWxzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2Vudj1udWxsLHRoaXMuX2NlbnRyZXg9bnVsbCx0aGlzLl9jZW50cmV5PW51bGwsdGhpcy5fbGV2ZWw9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9lbnY9dCx0aGlzLl9sZXZlbD1lLHRoaXMuX2NlbnRyZXg9KHQuZ2V0TWluWCgpK3QuZ2V0TWF4WCgpKS8yLHRoaXMuX2NlbnRyZXk9KHQuZ2V0TWluWSgpK3QuZ2V0TWF4WSgpKS8yfTtjbGFzcyBhc3tjb25zdHJ1Y3Rvcigpe2FzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGlzWmVyb1dpZHRoKHQsZSl7Y29uc3Qgbj1lLXQ7aWYoMD09PW4pcmV0dXJuITA7Y29uc3Qgcz1uL01hdGgubWF4KE1hdGguYWJzKHQpLE1hdGguYWJzKGUpKTtyZXR1cm4gcnMuZXhwb25lbnQocyk8PWFzLk1JTl9CSU5BUllfRVhQT05FTlR9Z2V0Q2xhc3MoKXtyZXR1cm4gYXN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWFzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe30sYXMuTUlOX0JJTkFSWV9FWFBPTkVOVD0tNTA7Y2xhc3MgY3MgZXh0ZW5kcyBpc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksY3MuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pbnNlcnQodCxlKXtjb25zdCBuPWlzLmdldFN1Ym5vZGVJbmRleCh0LGNzLm9yaWdpbi54LGNzLm9yaWdpbi55KTtpZigtMT09PW4pcmV0dXJuIHRoaXMuYWRkKGUpLG51bGw7Y29uc3Qgcz10aGlzLl9zdWJub2RlW25dO2lmKG51bGw9PT1zfHwhcy5nZXRFbnZlbG9wZSgpLmNvbnRhaW5zKHQpKXtjb25zdCBlPWxzLmNyZWF0ZUV4cGFuZGVkKHMsdCk7dGhpcy5fc3Vibm9kZVtuXT1lfXRoaXMuaW5zZXJ0Q29udGFpbmVkKHRoaXMuX3N1Ym5vZGVbbl0sdCxlKX1pc1NlYXJjaE1hdGNoKHQpe3JldHVybiEwfWluc2VydENvbnRhaW5lZCh0LGUsbil7dS5pc1RydWUodC5nZXRFbnZlbG9wZSgpLmNvbnRhaW5zKGUpKTtjb25zdCBzPWFzLmlzWmVyb1dpZHRoKGUuZ2V0TWluWCgpLGUuZ2V0TWF4WCgpKSxpPWFzLmlzWmVyb1dpZHRoKGUuZ2V0TWluWSgpLGUuZ2V0TWF4WSgpKTtsZXQgcj1udWxsO3I9c3x8aT90LmZpbmQoZSk6dC5nZXROb2RlKGUpLHIuYWRkKG4pfWdldENsYXNzKCl7cmV0dXJuIGNzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9LGNzLm9yaWdpbj1uZXcgZygwLDApO2NsYXNzIGhze2NvbnN0cnVjdG9yKCl7aHMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pbnNlcnQodCxlKXt9cmVtb3ZlKHQsZSl7fXF1ZXJ5KCl7fWdldENsYXNzKCl7cmV0dXJuIGhzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1ocy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIHVze2NvbnN0cnVjdG9yKCl7dXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZW5zdXJlRXh0ZW50KHQsZSl7bGV0IG49dC5nZXRNaW5YKCkscz10LmdldE1heFgoKSxpPXQuZ2V0TWluWSgpLHI9dC5nZXRNYXhZKCk7cmV0dXJuIG4hPT1zJiZpIT09cj90OihuPT09cyYmKG4tPWUvMixzPW4rZS8yKSxpPT09ciYmKGktPWUvMixyPWkrZS8yKSxuZXcgTihuLHMsaSxyKSl9c2l6ZSgpe3JldHVybiBudWxsIT09dGhpcy5fcm9vdD90aGlzLl9yb290LnNpemUoKTowfWluc2VydCh0LGUpe3RoaXMuY29sbGVjdFN0YXRzKHQpO2NvbnN0IG49dXMuZW5zdXJlRXh0ZW50KHQsdGhpcy5fbWluRXh0ZW50KTt0aGlzLl9yb290Lmluc2VydChuLGUpfXF1ZXJ5KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IFllO3JldHVybiB0aGlzLnF1ZXJ5KHQsZSksZS5nZXRJdGVtcygpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9yb290LnZpc2l0KHQsZSl9fXF1ZXJ5QWxsKCl7Y29uc3QgdD1uZXcgeDtyZXR1cm4gdGhpcy5fcm9vdC5hZGRBbGxJdGVtcyh0KSx0fXJlbW92ZSh0LGUpe2NvbnN0IG49dXMuZW5zdXJlRXh0ZW50KHQsdGhpcy5fbWluRXh0ZW50KTtyZXR1cm4gdGhpcy5fcm9vdC5yZW1vdmUobixlKX1jb2xsZWN0U3RhdHModCl7Y29uc3QgZT10LmdldFdpZHRoKCk7ZTx0aGlzLl9taW5FeHRlbnQmJmU+MCYmKHRoaXMuX21pbkV4dGVudD1lKTtjb25zdCBuPXQuZ2V0SGVpZ2h0KCk7bjx0aGlzLl9taW5FeHRlbnQmJm4+MCYmKHRoaXMuX21pbkV4dGVudD1uKX1kZXB0aCgpe3JldHVybiBudWxsIT09dGhpcy5fcm9vdD90aGlzLl9yb290LmRlcHRoKCk6MH1pc0VtcHR5KCl7cmV0dXJuIG51bGw9PT10aGlzLl9yb290fHx0aGlzLl9yb290LmlzRW1wdHkoKX1nZXRDbGFzcygpe3JldHVybiB1c31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5baHMsYV19fXVzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3Jvb3Q9bnVsbCx0aGlzLl9taW5FeHRlbnQ9MSx0aGlzLl9yb290PW5ldyBjc30sdXMuc2VyaWFsVmVyc2lvblVJRD0tMHg2NzhiNjBjOTY3YTI1NDAwO3ZhciBncz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxRdWFkdHJlZTp1c30pO2NsYXNzIGRze2NvbnN0cnVjdG9yKCl7ZHMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRCb3VuZHMoKXt9Z2V0Q2xhc3MoKXtyZXR1cm4gZHN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWRzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgX3N7Y29uc3RydWN0b3IoKXtfcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldEl0ZW0oKXtyZXR1cm4gdGhpcy5faXRlbX1nZXRCb3VuZHMoKXtyZXR1cm4gdGhpcy5fYm91bmRzfWdldENsYXNzKCl7cmV0dXJuIF9zfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltkcyxhXX19X3MuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fYm91bmRzPW51bGwsdGhpcy5faXRlbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2JvdW5kcz10LHRoaXMuX2l0ZW09ZX07Y2xhc3MgZnN7Y29uc3RydWN0b3IoKXtmcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXBvbGwoKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCB0PXRoaXMuX2l0ZW1zLmdldCgxKTtyZXR1cm4gdGhpcy5faXRlbXMuc2V0KDEsdGhpcy5faXRlbXMuZ2V0KHRoaXMuX3NpemUpKSx0aGlzLl9zaXplLT0xLHRoaXMucmVvcmRlcigxKSx0fXNpemUoKXtyZXR1cm4gdGhpcy5fc2l6ZX1yZW9yZGVyKHQpe2xldCBlPW51bGw7Y29uc3Qgbj10aGlzLl9pdGVtcy5nZXQodCk7Zm9yKDsyKnQ8PXRoaXMuX3NpemUmJihlPTIqdCxlIT09dGhpcy5fc2l6ZSYmdGhpcy5faXRlbXMuZ2V0KGUrMSkuY29tcGFyZVRvKHRoaXMuX2l0ZW1zLmdldChlKSk8MCYmZSsrLHRoaXMuX2l0ZW1zLmdldChlKS5jb21wYXJlVG8obik8MCk7dD1lKXRoaXMuX2l0ZW1zLnNldCh0LHRoaXMuX2l0ZW1zLmdldChlKSk7dGhpcy5faXRlbXMuc2V0KHQsbil9Y2xlYXIoKXt0aGlzLl9zaXplPTAsdGhpcy5faXRlbXMuY2xlYXIoKX1wZWVrKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7cmV0dXJuIHRoaXMuX2l0ZW1zLmdldCgxKX1pc0VtcHR5KCl7cmV0dXJuIDA9PT10aGlzLl9zaXplfWFkZCh0KXt0aGlzLl9pdGVtcy5hZGQobnVsbCksdGhpcy5fc2l6ZSs9MTtsZXQgZT10aGlzLl9zaXplO2Zvcih0aGlzLl9pdGVtcy5zZXQoMCx0KTt0LmNvbXBhcmVUbyh0aGlzLl9pdGVtcy5nZXQoTWF0aC50cnVuYyhlLzIpKSk8MDtlLz0yKXRoaXMuX2l0ZW1zLnNldChlLHRoaXMuX2l0ZW1zLmdldChNYXRoLnRydW5jKGUvMikpKTt0aGlzLl9pdGVtcy5zZXQoZSx0KX1nZXRDbGFzcygpe3JldHVybiBmc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZnMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fc2l6ZT1udWxsLHRoaXMuX2l0ZW1zPW51bGwsdGhpcy5fc2l6ZT0wLHRoaXMuX2l0ZW1zPW5ldyB4LHRoaXMuX2l0ZW1zLmFkZChudWxsKX07Y2xhc3MgcHN7Y29uc3RydWN0b3IoKXtwcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldExldmVsKCl7cmV0dXJuIHRoaXMuX2xldmVsfXNpemUoKXtyZXR1cm4gdGhpcy5fY2hpbGRCb3VuZGFibGVzLnNpemUoKX1nZXRDaGlsZEJvdW5kYWJsZXMoKXtyZXR1cm4gdGhpcy5fY2hpbGRCb3VuZGFibGVzfWFkZENoaWxkQm91bmRhYmxlKHQpe3UuaXNUcnVlKG51bGw9PT10aGlzLl9ib3VuZHMpLHRoaXMuX2NoaWxkQm91bmRhYmxlcy5hZGQodCl9aXNFbXB0eSgpe3JldHVybiB0aGlzLl9jaGlsZEJvdW5kYWJsZXMuaXNFbXB0eSgpfWdldEJvdW5kcygpe3JldHVybiBudWxsPT09dGhpcy5fYm91bmRzJiYodGhpcy5fYm91bmRzPXRoaXMuY29tcHV0ZUJvdW5kcygpKSx0aGlzLl9ib3VuZHN9Z2V0Q2xhc3MoKXtyZXR1cm4gcHN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2RzLGFdfX1wcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9jaGlsZEJvdW5kYWJsZXM9bmV3IHgsdGhpcy5fYm91bmRzPW51bGwsdGhpcy5fbGV2ZWw9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGV2ZWw9dH19LHBzLnNlcmlhbFZlcnNpb25VSUQ9MHg1YTFlNTVlYzQxMzY5ODAwO2NsYXNzIG1ze2NvbnN0cnVjdG9yKCl7bXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgYXJlYSh0KXtyZXR1cm4gdC5nZXRCb3VuZHMoKS5nZXRBcmVhKCl9c3RhdGljIGlzQ29tcG9zaXRlKHQpe3JldHVybiB0IGluc3RhbmNlb2YgcHN9ZXhwYW5kVG9RdWV1ZSh0LGUpe2NvbnN0IHM9bXMuaXNDb21wb3NpdGUodGhpcy5fYm91bmRhYmxlMSksaT1tcy5pc0NvbXBvc2l0ZSh0aGlzLl9ib3VuZGFibGUyKTtpZihzJiZpKXJldHVybiBtcy5hcmVhKHRoaXMuX2JvdW5kYWJsZTEpPm1zLmFyZWEodGhpcy5fYm91bmRhYmxlMik/KHRoaXMuZXhwYW5kKHRoaXMuX2JvdW5kYWJsZTEsdGhpcy5fYm91bmRhYmxlMix0LGUpLG51bGwpOih0aGlzLmV4cGFuZCh0aGlzLl9ib3VuZGFibGUyLHRoaXMuX2JvdW5kYWJsZTEsdCxlKSxudWxsKTtpZihzKXJldHVybiB0aGlzLmV4cGFuZCh0aGlzLl9ib3VuZGFibGUxLHRoaXMuX2JvdW5kYWJsZTIsdCxlKSxudWxsO2lmKGkpcmV0dXJuIHRoaXMuZXhwYW5kKHRoaXMuX2JvdW5kYWJsZTIsdGhpcy5fYm91bmRhYmxlMSx0LGUpLG51bGw7dGhyb3cgbmV3IG4oXCJuZWl0aGVyIGJvdW5kYWJsZSBpcyBjb21wb3NpdGVcIil9aXNMZWF2ZXMoKXtyZXR1cm4hKG1zLmlzQ29tcG9zaXRlKHRoaXMuX2JvdW5kYWJsZTEpfHxtcy5pc0NvbXBvc2l0ZSh0aGlzLl9ib3VuZGFibGUyKSl9Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5fZGlzdGFuY2U8ZS5fZGlzdGFuY2U/LTE6dGhpcy5fZGlzdGFuY2U+ZS5fZGlzdGFuY2U/MTowfWV4cGFuZCh0LGUsbixzKXtmb3IobGV0IGk9dC5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7Y29uc3QgdD1pLm5leHQoKSxyPW5ldyBtcyh0LGUsdGhpcy5faXRlbURpc3RhbmNlKTtyLmdldERpc3RhbmNlKCk8cyYmbi5hZGQocil9fWdldEJvdW5kYWJsZSh0KXtyZXR1cm4gMD09PXQ/dGhpcy5fYm91bmRhYmxlMTp0aGlzLl9ib3VuZGFibGUyfWdldERpc3RhbmNlKCl7cmV0dXJuIHRoaXMuX2Rpc3RhbmNlfWRpc3RhbmNlKCl7cmV0dXJuIHRoaXMuaXNMZWF2ZXMoKT90aGlzLl9pdGVtRGlzdGFuY2UuZGlzdGFuY2UodGhpcy5fYm91bmRhYmxlMSx0aGlzLl9ib3VuZGFibGUyKTp0aGlzLl9ib3VuZGFibGUxLmdldEJvdW5kcygpLmRpc3RhbmNlKHRoaXMuX2JvdW5kYWJsZTIuZ2V0Qm91bmRzKCkpfWdldENsYXNzKCl7cmV0dXJuIG1zfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltyXX19bXMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fYm91bmRhYmxlMT1udWxsLHRoaXMuX2JvdW5kYWJsZTI9bnVsbCx0aGlzLl9kaXN0YW5jZT1udWxsLHRoaXMuX2l0ZW1EaXN0YW5jZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX2JvdW5kYWJsZTE9dCx0aGlzLl9ib3VuZGFibGUyPWUsdGhpcy5faXRlbURpc3RhbmNlPW4sdGhpcy5fZGlzdGFuY2U9dGhpcy5kaXN0YW5jZSgpfTtjbGFzcyB5c3tjb25zdHJ1Y3Rvcigpe3lzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbXBhcmVEb3VibGVzKHQsZSl7cmV0dXJuIHQ+ZT8xOnQ8ZT8tMTowfXF1ZXJ5SW50ZXJuYWwoKXtpZihfKGFyZ3VtZW50c1syXSxBZSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgT2JqZWN0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIHBzKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWUuZ2V0Q2hpbGRCb3VuZGFibGVzKCk7Zm9yKGxldCBlPTA7ZTxzLnNpemUoKTtlKyspe2NvbnN0IGk9cy5nZXQoZSk7dGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKGkuZ2V0Qm91bmRzKCksdCkmJihpIGluc3RhbmNlb2YgcHM/dGhpcy5xdWVyeUludGVybmFsKHQsaSxuKTppIGluc3RhbmNlb2YgX3M/bi52aXNpdEl0ZW0oaS5nZXRJdGVtKCkpOnUuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKSl9fWVsc2UgaWYoXyhhcmd1bWVudHNbMl0sbSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgT2JqZWN0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIHBzKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWUuZ2V0Q2hpbGRCb3VuZGFibGVzKCk7Zm9yKGxldCBlPTA7ZTxzLnNpemUoKTtlKyspe2NvbnN0IGk9cy5nZXQoZSk7dGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKGkuZ2V0Qm91bmRzKCksdCkmJihpIGluc3RhbmNlb2YgcHM/dGhpcy5xdWVyeUludGVybmFsKHQsaSxuKTppIGluc3RhbmNlb2YgX3M/bi5hZGQoaS5nZXRJdGVtKCkpOnUuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKSl9fX1nZXROb2RlQ2FwYWNpdHkoKXtyZXR1cm4gdGhpcy5fbm9kZUNhcGFjaXR5fWxhc3ROb2RlKHQpe3JldHVybiB0LmdldCh0LnNpemUoKS0xKX1zaXplKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuaXNFbXB0eSgpPzA6KHRoaXMuYnVpbGQoKSx0aGlzLnNpemUodGhpcy5fcm9vdCkpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtsZXQgdD0wO2ZvcihsZXQgZT1hcmd1bWVudHNbMF0uZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7biBpbnN0YW5jZW9mIHBzP3QrPXRoaXMuc2l6ZShuKTpuIGluc3RhbmNlb2YgX3MmJih0Kz0xKX1yZXR1cm4gdH19cmVtb3ZlSXRlbSh0LGUpe2xldCBuPW51bGw7Zm9yKGxldCBzPXQuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7dCBpbnN0YW5jZW9mIF9zJiZ0LmdldEl0ZW0oKT09PWUmJihuPXQpfXJldHVybiBudWxsIT09biYmKHQuZ2V0Q2hpbGRCb3VuZGFibGVzKCkucmVtb3ZlKG4pLCEwKX1pdGVtc1RyZWUoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7dGhpcy5idWlsZCgpO2NvbnN0IHQ9dGhpcy5pdGVtc1RyZWUodGhpcy5fcm9vdCk7cmV0dXJuIG51bGw9PT10P25ldyB4OnR9aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IHg7Zm9yKGxldCBuPXQuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7aWYodCBpbnN0YW5jZW9mIHBzKXtjb25zdCBuPXRoaXMuaXRlbXNUcmVlKHQpO251bGwhPT1uJiZlLmFkZChuKX1lbHNlIHQgaW5zdGFuY2VvZiBfcz9lLmFkZCh0LmdldEl0ZW0oKSk6dS5zaG91bGROZXZlclJlYWNoSGVyZSgpfXJldHVybiBlLnNpemUoKTw9MD9udWxsOmV9fWluc2VydCh0LGUpe3UuaXNUcnVlKCF0aGlzLl9idWlsdCxcIkNhbm5vdCBpbnNlcnQgaXRlbXMgaW50byBhbiBTVFIgcGFja2VkIFItdHJlZSBhZnRlciBpdCBoYXMgYmVlbiBidWlsdC5cIiksdGhpcy5faXRlbUJvdW5kYWJsZXMuYWRkKG5ldyBfcyh0LGUpKX1ib3VuZGFibGVzQXRMZXZlbCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyB4O3JldHVybiB0aGlzLmJvdW5kYWJsZXNBdExldmVsKHQsdGhpcy5fcm9vdCxlKSxlfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZih1LmlzVHJ1ZSh0Pi0yKSxlLmdldExldmVsKCk9PT10KXJldHVybiBuLmFkZChlKSxudWxsO2ZvcihsZXQgcz1lLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCBlPXMubmV4dCgpO2UgaW5zdGFuY2VvZiBwcz90aGlzLmJvdW5kYWJsZXNBdExldmVsKHQsZSxuKToodS5pc1RydWUoZSBpbnN0YW5jZW9mIF9zKSwtMT09PXQmJm4uYWRkKGUpKX1yZXR1cm4gbnVsbH19cXVlcnkoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5idWlsZCgpO2NvbnN0IGU9bmV3IHg7cmV0dXJuIHRoaXMuaXNFbXB0eSgpfHx0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHModGhpcy5fcm9vdC5nZXRCb3VuZHMoKSx0KSYmdGhpcy5xdWVyeUludGVybmFsKHQsdGhpcy5fcm9vdCxlKSxlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0aGlzLmJ1aWxkKCksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKHRoaXMuX3Jvb3QuZ2V0Qm91bmRzKCksdCkmJnRoaXMucXVlcnlJbnRlcm5hbCh0LHRoaXMuX3Jvb3QsZSl9fWJ1aWxkKCl7aWYodGhpcy5fYnVpbHQpcmV0dXJuIG51bGw7dGhpcy5fcm9vdD10aGlzLl9pdGVtQm91bmRhYmxlcy5pc0VtcHR5KCk/dGhpcy5jcmVhdGVOb2RlKDApOnRoaXMuY3JlYXRlSGlnaGVyTGV2ZWxzKHRoaXMuX2l0ZW1Cb3VuZGFibGVzLC0xKSx0aGlzLl9pdGVtQm91bmRhYmxlcz1udWxsLHRoaXMuX2J1aWx0PSEwfWdldFJvb3QoKXtyZXR1cm4gdGhpcy5idWlsZCgpLHRoaXMuX3Jvb3R9cmVtb3ZlKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmJ1aWxkKCksISF0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHModGhpcy5fcm9vdC5nZXRCb3VuZHMoKSx0KSYmdGhpcy5yZW1vdmUodCx0aGlzLl9yb290LGUpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtsZXQgcz10aGlzLnJlbW92ZUl0ZW0oZSxuKTtpZihzKXJldHVybiEwO2xldCBpPW51bGw7Zm9yKGxldCByPWUuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe2NvbnN0IGU9ci5uZXh0KCk7aWYodGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKGUuZ2V0Qm91bmRzKCksdCkmJihlIGluc3RhbmNlb2YgcHMmJihzPXRoaXMucmVtb3ZlKHQsZSxuKSxzKSkpe2k9ZTticmVha319cmV0dXJuIG51bGwhPT1pJiZpLmdldENoaWxkQm91bmRhYmxlcygpLmlzRW1wdHkoKSYmZS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5yZW1vdmUoaSksc319Y3JlYXRlSGlnaGVyTGV2ZWxzKHQsZSl7dS5pc1RydWUoIXQuaXNFbXB0eSgpKTtjb25zdCBuPXRoaXMuY3JlYXRlUGFyZW50Qm91bmRhYmxlcyh0LGUrMSk7cmV0dXJuIDE9PT1uLnNpemUoKT9uLmdldCgwKTp0aGlzLmNyZWF0ZUhpZ2hlckxldmVscyhuLGUrMSl9ZGVwdGgoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5pc0VtcHR5KCk/MDoodGhpcy5idWlsZCgpLHRoaXMuZGVwdGgodGhpcy5fcm9vdCkpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtsZXQgdD0wO2ZvcihsZXQgZT1hcmd1bWVudHNbMF0uZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7aWYobiBpbnN0YW5jZW9mIHBzKXtjb25zdCBlPXRoaXMuZGVwdGgobik7ZT50JiYodD1lKX19cmV0dXJuIHQrMX19Y3JlYXRlUGFyZW50Qm91bmRhYmxlcyh0LGUpe3UuaXNUcnVlKCF0LmlzRW1wdHkoKSk7Y29uc3Qgbj1uZXcgeDtuLmFkZCh0aGlzLmNyZWF0ZU5vZGUoZSkpO2NvbnN0IHM9bmV3IHgodCk7RWUuc29ydChzLHRoaXMuZ2V0Q29tcGFyYXRvcigpKTtmb3IobGV0IHQ9cy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3Qgcz10Lm5leHQoKTt0aGlzLmxhc3ROb2RlKG4pLmdldENoaWxkQm91bmRhYmxlcygpLnNpemUoKT09PXRoaXMuZ2V0Tm9kZUNhcGFjaXR5KCkmJm4uYWRkKHRoaXMuY3JlYXRlTm9kZShlKSksdGhpcy5sYXN0Tm9kZShuKS5hZGRDaGlsZEJvdW5kYWJsZShzKX1yZXR1cm4gbn1pc0VtcHR5KCl7cmV0dXJuIHRoaXMuX2J1aWx0P3RoaXMuX3Jvb3QuaXNFbXB0eSgpOnRoaXMuX2l0ZW1Cb3VuZGFibGVzLmlzRW1wdHkoKX1nZXRDbGFzcygpe3JldHVybiB5c31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bYV19fXlzLkludGVyc2VjdHNPcD1mdW5jdGlvbigpe30seXMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fcm9vdD1udWxsLHRoaXMuX2J1aWx0PSExLHRoaXMuX2l0ZW1Cb3VuZGFibGVzPW5ldyB4LHRoaXMuX25vZGVDYXBhY2l0eT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXlzLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMseXMuREVGQVVMVF9OT0RFX0NBUEFDSVRZKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt1LmlzVHJ1ZSh0PjEsXCJOb2RlIGNhcGFjaXR5IG11c3QgYmUgZ3JlYXRlciB0aGFuIDFcIiksdGhpcy5fbm9kZUNhcGFjaXR5PXR9fSx5cy5zZXJpYWxWZXJzaW9uVUlEPS0weDM1ZWY2NGM4MmQ0YzU0MDAseXMuREVGQVVMVF9OT0RFX0NBUEFDSVRZPTEwO2NsYXNzIHhze2NvbnN0cnVjdG9yKCl7eHMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1kaXN0YW5jZSh0LGUpe31nZXRDbGFzcygpe3JldHVybiB4c31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19eHMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBFcyBleHRlbmRzIHlze2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxFcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjZW50cmVYKHQpe3JldHVybiBFcy5hdmcodC5nZXRNaW5YKCksdC5nZXRNYXhYKCkpfXN0YXRpYyBhdmcodCxlKXtyZXR1cm4odCtlKS8yfXN0YXRpYyBnZXRJdGVtcyh0KXtjb25zdCBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtsZXQgbj0wO2Zvcig7IXQuaXNFbXB0eSgpOyl7Y29uc3Qgcz10LnBvbGwoKTtlW25dPXMuZ2V0Qm91bmRhYmxlKDApLmdldEl0ZW0oKSxuKyt9cmV0dXJuIGV9c3RhdGljIGNlbnRyZVkodCl7cmV0dXJuIEVzLmF2Zyh0LmdldE1pblkoKSx0LmdldE1heFkoKSl9Y3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlcyh0LGUpe3UuaXNUcnVlKHQubGVuZ3RoPjApO2NvbnN0IG49bmV3IHg7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspbi5hZGRBbGwodGhpcy5jcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2UodFtzXSxlKSk7cmV0dXJuIG59Y3JlYXRlTm9kZSh0KXtyZXR1cm4gbmV3IElzKHQpfXNpemUoKXtyZXR1cm4gMD09PWFyZ3VtZW50cy5sZW5ndGg/c3VwZXIuc2l6ZS5jYWxsKHRoaXMpOnN1cGVyLnNpemUuYXBwbHkodGhpcyxhcmd1bWVudHMpfWluc2VydCgpe2lmKCEoMj09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgT2JqZWN0JiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE4pKXJldHVybiBzdXBlci5pbnNlcnQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3tjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZih0LmlzTnVsbCgpKXJldHVybiBudWxsO3N1cGVyLmluc2VydC5jYWxsKHRoaXMsdCxlKX19Z2V0SW50ZXJzZWN0c09wKCl7cmV0dXJuIEVzLmludGVyc2VjdHNPcH12ZXJ0aWNhbFNsaWNlcyh0LGUpe2NvbnN0IG49TWF0aC50cnVuYyhNYXRoLmNlaWwodC5zaXplKCkvZSkpLHM9bmV3IEFycmF5KGUpLmZpbGwobnVsbCksaT10Lml0ZXJhdG9yKCk7Zm9yKGxldCB0PTA7dDxlO3QrKyl7c1t0XT1uZXcgeDtsZXQgZT0wO2Zvcig7aS5oYXNOZXh0KCkmJmU8bjspe2NvbnN0IG49aS5uZXh0KCk7c1t0XS5hZGQobiksZSsrfX1yZXR1cm4gc31xdWVyeSgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gc3VwZXIucXVlcnkuY2FsbCh0aGlzLHQpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtzdXBlci5xdWVyeS5jYWxsKHRoaXMsdCxlKX19Z2V0Q29tcGFyYXRvcigpe3JldHVybiBFcy55Q29tcGFyYXRvcn1jcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2UodCxlKXtyZXR1cm4gc3VwZXIuY3JlYXRlUGFyZW50Qm91bmRhYmxlcy5jYWxsKHRoaXMsdCxlKX1yZW1vdmUoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBPYmplY3QmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgTil7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHN1cGVyLnJlbW92ZS5jYWxsKHRoaXMsdCxlKX1yZXR1cm4gc3VwZXIucmVtb3ZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1kZXB0aCgpe3JldHVybiAwPT09YXJndW1lbnRzLmxlbmd0aD9zdXBlci5kZXB0aC5jYWxsKHRoaXMpOnN1cGVyLmRlcHRoLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jcmVhdGVQYXJlbnRCb3VuZGFibGVzKHQsZSl7dS5pc1RydWUoIXQuaXNFbXB0eSgpKTtjb25zdCBuPU1hdGgudHJ1bmMoTWF0aC5jZWlsKHQuc2l6ZSgpL3RoaXMuZ2V0Tm9kZUNhcGFjaXR5KCkpKSxzPW5ldyB4KHQpO0VlLnNvcnQocyxFcy54Q29tcGFyYXRvcik7Y29uc3QgaT10aGlzLnZlcnRpY2FsU2xpY2VzKHMsTWF0aC50cnVuYyhNYXRoLmNlaWwoTWF0aC5zcXJ0KG4pKSkpO3JldHVybiB0aGlzLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZXMoaSxlKX1uZWFyZXN0TmVpZ2hib3VyKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKF8oYXJndW1lbnRzWzBdLHhzKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgbXModGhpcy5nZXRSb290KCksdGhpcy5nZXRSb290KCksdCk7cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihlKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG1zKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKHQsaS5QT1NJVElWRV9JTkZJTklUWSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRXMmJl8oYXJndW1lbnRzWzFdLHhzKSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgbXModGhpcy5nZXRSb290KCksdC5nZXRSb290KCksZSk7cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihuKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG1zJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT1hcmd1bWVudHNbMV0sbj1udWxsO2NvbnN0IHM9bmV3IGZzO2ZvcihzLmFkZCh0KTshcy5pc0VtcHR5KCkmJmU+MDspe2NvbnN0IHQ9cy5wb2xsKCksaT10LmdldERpc3RhbmNlKCk7aWYoaT49ZSlicmVhazt0LmlzTGVhdmVzKCk/KGU9aSxuPXQpOnQuZXhwYW5kVG9RdWV1ZShzLGUpfXJldHVybltuLmdldEJvdW5kYWJsZSgwKS5nZXRJdGVtKCksbi5nZXRCb3VuZGFibGUoMSkuZ2V0SXRlbSgpXX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG1zJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLm5lYXJlc3ROZWlnaGJvdXIodCxpLlBPU0lUSVZFX0lORklOSVRZLGUpfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihfKGFyZ3VtZW50c1syXSx4cykmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgTiYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBPYmplY3Qpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9bmV3IF9zKHQsZSksaT1uZXcgbXModGhpcy5nZXRSb290KCkscyxuKTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKGkpWzBdfWlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzJdKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtcyYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07bGV0IHM9ZTtjb25zdCBpPW5ldyBmcztpLmFkZCh0KTtjb25zdCByPW5ldyBmcztmb3IoOyFpLmlzRW1wdHkoKSYmcz49MDspe2NvbnN0IHQ9aS5wb2xsKCksZT10LmdldERpc3RhbmNlKCk7aWYoZT49cylicmVhaztpZih0LmlzTGVhdmVzKCkpaWYoci5zaXplKCk8bilyLmFkZCh0KTtlbHNle3IucGVlaygpLmdldERpc3RhbmNlKCk+ZSYmKHIucG9sbCgpLHIuYWRkKHQpKSxzPXIucGVlaygpLmdldERpc3RhbmNlKCl9ZWxzZSB0LmV4cGFuZFRvUXVldWUoaSxzKX1yZXR1cm4gRXMuZ2V0SXRlbXMocil9fWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9bmV3IF9zKHQsZSkscj1uZXcgbXModGhpcy5nZXRSb290KCksaSxuKTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKHIscyl9fWdldENsYXNzKCl7cmV0dXJuIEVzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltocyxhXX19Y2xhc3MgSXMgZXh0ZW5kcyBwc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksSXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jb21wdXRlQm91bmRzKCl7bGV0IHQ9bnVsbDtmb3IobGV0IGU9dGhpcy5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtudWxsPT09dD90PW5ldyBOKG4uZ2V0Qm91bmRzKCkpOnQuZXhwYW5kVG9JbmNsdWRlKG4uZ2V0Qm91bmRzKCkpfXJldHVybiB0fWdldENsYXNzKCl7cmV0dXJuIElzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Jcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtjb25zdCB0PWFyZ3VtZW50c1swXTtwcy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfSxFcy5TVFJ0cmVlTm9kZT1JcyxFcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClFcy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLEVzLkRFRkFVTFRfTk9ERV9DQVBBQ0lUWSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07eXMuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0KX19LEVzLnNlcmlhbFZlcnNpb25VSUQ9MHgzOTkyMGY3ZDVmMjYxZTAsRXMueENvbXBhcmF0b3I9bmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVybltsXX1jb21wYXJlKHQsZSl7cmV0dXJuIHlzLmNvbXBhcmVEb3VibGVzKEVzLmNlbnRyZVgodC5nZXRCb3VuZHMoKSksRXMuY2VudHJlWChlLmdldEJvdW5kcygpKSl9fSxFcy55Q29tcGFyYXRvcj1uZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW2xdfWNvbXBhcmUodCxlKXtyZXR1cm4geXMuY29tcGFyZURvdWJsZXMoRXMuY2VudHJlWSh0LmdldEJvdW5kcygpKSxFcy5jZW50cmVZKGUuZ2V0Qm91bmRzKCkpKX19LEVzLmludGVyc2VjdHNPcD1uZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0ludGVyc2VjdHNPcF19aW50ZXJzZWN0cyh0LGUpe3JldHVybiB0LmludGVyc2VjdHMoZSl9fSxFcy5ERUZBVUxUX05PREVfQ0FQQUNJVFk9MTA7dmFyIE5zPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLFNUUnRyZWU6RXN9KSxDcz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxrZHRyZWU6c3MscXVhZHRyZWU6Z3Msc3RydHJlZTpOc30pO2NvbnN0IFNzPVtcIlBvaW50XCIsXCJNdWx0aVBvaW50XCIsXCJMaW5lU3RyaW5nXCIsXCJNdWx0aUxpbmVTdHJpbmdcIixcIlBvbHlnb25cIixcIk11bHRpUG9seWdvblwiXTtjbGFzcyB3c3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmdlb21ldHJ5RmFjdG9yeT10fHxuZXcgSHR9cmVhZCh0KXtsZXQgZTtlPVwic3RyaW5nXCI9PXR5cGVvZiB0P0pTT04ucGFyc2UodCk6dDtjb25zdCBuPWUudHlwZTtpZighTHNbbl0pdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBHZW9KU09OIHR5cGU6IFwiK2UudHlwZSk7cmV0dXJuLTEhPT1Tcy5pbmRleE9mKG4pP0xzW25dLmNhbGwodGhpcyxlLmNvb3JkaW5hdGVzKTpcIkdlb21ldHJ5Q29sbGVjdGlvblwiPT09bj9Mc1tuXS5jYWxsKHRoaXMsZS5nZW9tZXRyaWVzKTpMc1tuXS5jYWxsKHRoaXMsZSl9d3JpdGUodCl7Y29uc3QgZT10LmdldEdlb21ldHJ5VHlwZSgpO2lmKCFUc1tlXSl0aHJvdyBuZXcgRXJyb3IoXCJHZW9tZXRyeSBpcyBub3Qgc3VwcG9ydGVkXCIpO3JldHVybiBUc1tlXS5jYWxsKHRoaXMsdCl9fWNvbnN0IExzPXtGZWF0dXJlOmZ1bmN0aW9uKHQpe2NvbnN0IGU9e307Zm9yKGNvbnN0IG4gaW4gdCllW25dPXRbbl07aWYodC5nZW9tZXRyeSl7Y29uc3Qgbj10Lmdlb21ldHJ5LnR5cGU7aWYoIUxzW25dKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gR2VvSlNPTiB0eXBlOiBcIit0LnR5cGUpO2UuZ2VvbWV0cnk9dGhpcy5yZWFkKHQuZ2VvbWV0cnkpfXJldHVybiB0LmJib3gmJihlLmJib3g9THMuYmJveC5jYWxsKHRoaXMsdC5iYm94KSksZX0sRmVhdHVyZUNvbGxlY3Rpb246ZnVuY3Rpb24odCl7Y29uc3QgZT17fTtpZih0LmZlYXR1cmVzKXtlLmZlYXR1cmVzPVtdO2ZvcihsZXQgbj0wO248dC5mZWF0dXJlcy5sZW5ndGg7KytuKWUuZmVhdHVyZXMucHVzaCh0aGlzLnJlYWQodC5mZWF0dXJlc1tuXSkpfXJldHVybiB0LmJib3gmJihlLmJib3g9dGhpcy5wYXJzZS5iYm94LmNhbGwodGhpcyx0LmJib3gpKSxlfSxjb29yZGluYXRlczpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7KytuKXtjb25zdCBzPXRbbl07ZS5wdXNoKG5ldyBnKHNbMF0sc1sxXSkpfXJldHVybiBlfSxiYm94OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKFtuZXcgZyh0WzBdLHRbMV0pLG5ldyBnKHRbMl0sdFsxXSksbmV3IGcodFsyXSx0WzNdKSxuZXcgZyh0WzBdLHRbM10pLG5ldyBnKHRbMF0sdFsxXSldKX0sUG9pbnQ6ZnVuY3Rpb24odCl7Y29uc3QgZT1uZXcgZyh0WzBdLHRbMV0pO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludChlKX0sTXVsdGlQb2ludDpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7KytuKWUucHVzaChMcy5Qb2ludC5jYWxsKHRoaXMsdFtuXSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KGUpfSxMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2NvbnN0IGU9THMuY29vcmRpbmF0ZXMuY2FsbCh0aGlzLHQpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKGUpfSxNdWx0aUxpbmVTdHJpbmc6ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQubGVuZ3RoOysrbillLnB1c2goTHMuTGluZVN0cmluZy5jYWxsKHRoaXMsdFtuXSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoZSl9LFBvbHlnb246ZnVuY3Rpb24odCl7Y29uc3QgZT1Mcy5jb29yZGluYXRlcy5jYWxsKHRoaXMsdFswXSksbj10aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKGUpLHM9W107Zm9yKGxldCBlPTE7ZTx0Lmxlbmd0aDsrK2Upe2NvbnN0IG49dFtlXSxpPUxzLmNvb3JkaW5hdGVzLmNhbGwodGhpcyxuKSxyPXRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoaSk7cy5wdXNoKHIpfXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2x5Z29uKG4scyl9LE11bHRpUG9seWdvbjpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7KytuKXtjb25zdCBzPXRbbl07ZS5wdXNoKExzLlBvbHlnb24uY2FsbCh0aGlzLHMpKX1yZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKGUpfSxHZW9tZXRyeUNvbGxlY3Rpb246ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQubGVuZ3RoOysrbil7Y29uc3Qgcz10W25dO2UucHVzaCh0aGlzLnJlYWQocykpfXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oZSl9fSxUcz17Y29vcmRpbmF0ZTpmdW5jdGlvbih0KXtyZXR1cm5bdC54LHQueV19LFBvaW50OmZ1bmN0aW9uKHQpe3JldHVybnt0eXBlOlwiUG9pbnRcIixjb29yZGluYXRlczpUcy5jb29yZGluYXRlLmNhbGwodGhpcyx0LmdldENvb3JkaW5hdGUoKSl9fSxNdWx0aVBvaW50OmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Ll9nZW9tZXRyaWVzLmxlbmd0aDsrK24pe2NvbnN0IHM9dC5fZ2VvbWV0cmllc1tuXSxpPVRzLlBvaW50LmNhbGwodGhpcyxzKTtlLnB1c2goaS5jb29yZGluYXRlcyl9cmV0dXJue3R5cGU6XCJNdWx0aVBvaW50XCIsY29vcmRpbmF0ZXM6ZX19LExpbmVTdHJpbmc6ZnVuY3Rpb24odCl7Y29uc3QgZT1bXSxuPXQuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoOysrdCl7Y29uc3Qgcz1uW3RdO2UucHVzaChUcy5jb29yZGluYXRlLmNhbGwodGhpcyxzKSl9cmV0dXJue3R5cGU6XCJMaW5lU3RyaW5nXCIsY29vcmRpbmF0ZXM6ZX19LE11bHRpTGluZVN0cmluZzpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5fZ2VvbWV0cmllcy5sZW5ndGg7KytuKXtjb25zdCBzPXQuX2dlb21ldHJpZXNbbl0saT1Ucy5MaW5lU3RyaW5nLmNhbGwodGhpcyxzKTtlLnB1c2goaS5jb29yZGluYXRlcyl9cmV0dXJue3R5cGU6XCJNdWx0aUxpbmVTdHJpbmdcIixjb29yZGluYXRlczplfX0sUG9seWdvbjpmdW5jdGlvbih0KXtjb25zdCBlPVtdLG49VHMuTGluZVN0cmluZy5jYWxsKHRoaXMsdC5fc2hlbGwpO2UucHVzaChuLmNvb3JkaW5hdGVzKTtmb3IobGV0IG49MDtuPHQuX2hvbGVzLmxlbmd0aDsrK24pe2NvbnN0IHM9dC5faG9sZXNbbl0saT1Ucy5MaW5lU3RyaW5nLmNhbGwodGhpcyxzKTtlLnB1c2goaS5jb29yZGluYXRlcyl9cmV0dXJue3R5cGU6XCJQb2x5Z29uXCIsY29vcmRpbmF0ZXM6ZX19LE11bHRpUG9seWdvbjpmdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5fZ2VvbWV0cmllcy5sZW5ndGg7KytuKXtjb25zdCBzPXQuX2dlb21ldHJpZXNbbl0saT1Ucy5Qb2x5Z29uLmNhbGwodGhpcyxzKTtlLnB1c2goaS5jb29yZGluYXRlcyl9cmV0dXJue3R5cGU6XCJNdWx0aVBvbHlnb25cIixjb29yZGluYXRlczplfX0sR2VvbWV0cnlDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Ll9nZW9tZXRyaWVzLmxlbmd0aDsrK24pe2NvbnN0IHM9dC5fZ2VvbWV0cmllc1tuXSxpPXMuZ2V0R2VvbWV0cnlUeXBlKCk7ZS5wdXNoKFRzW2ldLmNhbGwodGhpcyxzKSl9cmV0dXJue3R5cGU6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixnZW9tZXRyaWVzOmV9fX07ZnVuY3Rpb24gUnModCl7cmV0dXJuW3QueCx0LnldfXZhciBQcz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxHZW9KU09OUmVhZGVyOmNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMucGFyc2VyPW5ldyB3cyh0fHxuZXcgSHQpfXJlYWQodCl7cmV0dXJuIHRoaXMucGFyc2VyLnJlYWQodCl9fSxHZW9KU09OV3JpdGVyOmNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5wYXJzZXI9bmV3IHdzKHRoaXMuZ2VvbWV0cnlGYWN0b3J5KX13cml0ZSh0KXtyZXR1cm4gdGhpcy5wYXJzZXIud3JpdGUodCl9fSxPTDNQYXJzZXI6Y2xhc3N7Y29uc3RydWN0b3IodCxlKXt0aGlzLmdlb21ldHJ5RmFjdG9yeT10fHxuZXcgSHQsdGhpcy5vbD1lfHxcInVuZGVmaW5lZFwiIT10eXBlb2Ygb2wmJm9sfWluamVjdCh0LGUsbixzLGkscixvLGwpe3RoaXMub2w9e2dlb206e1BvaW50OnQsTGluZVN0cmluZzplLExpbmVhclJpbmc6bixQb2x5Z29uOnMsTXVsdGlQb2ludDppLE11bHRpTGluZVN0cmluZzpyLE11bHRpUG9seWdvbjpvLEdlb21ldHJ5Q29sbGVjdGlvbjpsfX19cmVhZCh0KXtjb25zdCBlPXRoaXMub2w7cmV0dXJuIHQgaW5zdGFuY2VvZiBlLmdlb20uUG9pbnQ/dGhpcy5jb252ZXJ0RnJvbVBvaW50KHQpOnQgaW5zdGFuY2VvZiBlLmdlb20uTGluZVN0cmluZz90aGlzLmNvbnZlcnRGcm9tTGluZVN0cmluZyh0KTp0IGluc3RhbmNlb2YgZS5nZW9tLkxpbmVhclJpbmc/dGhpcy5jb252ZXJ0RnJvbUxpbmVhclJpbmcodCk6dCBpbnN0YW5jZW9mIGUuZ2VvbS5Qb2x5Z29uP3RoaXMuY29udmVydEZyb21Qb2x5Z29uKHQpOnQgaW5zdGFuY2VvZiBlLmdlb20uTXVsdGlQb2ludD90aGlzLmNvbnZlcnRGcm9tTXVsdGlQb2ludCh0KTp0IGluc3RhbmNlb2YgZS5nZW9tLk11bHRpTGluZVN0cmluZz90aGlzLmNvbnZlcnRGcm9tTXVsdGlMaW5lU3RyaW5nKHQpOnQgaW5zdGFuY2VvZiBlLmdlb20uTXVsdGlQb2x5Z29uP3RoaXMuY29udmVydEZyb21NdWx0aVBvbHlnb24odCk6dCBpbnN0YW5jZW9mIGUuZ2VvbS5HZW9tZXRyeUNvbGxlY3Rpb24/dGhpcy5jb252ZXJ0RnJvbUNvbGxlY3Rpb24odCk6dm9pZCAwfWNvbnZlcnRGcm9tUG9pbnQodCl7Y29uc3QgZT10LmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KG5ldyBnKGVbMF0sZVsxXSkpfWNvbnZlcnRGcm9tTGluZVN0cmluZyh0KXtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0LmdldENvb3JkaW5hdGVzKCkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGcodFswXSx0WzFdKX0pKSl9Y29udmVydEZyb21MaW5lYXJSaW5nKHQpe3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHQuZ2V0Q29vcmRpbmF0ZXMoKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZyh0WzBdLHRbMV0pfSkpKX1jb252ZXJ0RnJvbVBvbHlnb24odCl7Y29uc3QgZT10LmdldExpbmVhclJpbmdzKCk7bGV0IG49bnVsbDtjb25zdCBzPVtdO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtjb25zdCBpPXRoaXMuY29udmVydEZyb21MaW5lYXJSaW5nKGVbdF0pOzA9PT10P249aTpzLnB1c2goaSl9cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvbHlnb24obixzKX1jb252ZXJ0RnJvbU11bHRpUG9pbnQodCl7Y29uc3QgZT10LmdldFBvaW50cygpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29udmVydEZyb21Qb2ludCh0KX0pLHRoaXMpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KGUpfWNvbnZlcnRGcm9tTXVsdGlMaW5lU3RyaW5nKHQpe2NvbnN0IGU9dC5nZXRMaW5lU3RyaW5ncygpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29udmVydEZyb21MaW5lU3RyaW5nKHQpfSksdGhpcyk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZyhlKX1jb252ZXJ0RnJvbU11bHRpUG9seWdvbih0KXtjb25zdCBlPXQuZ2V0UG9seWdvbnMoKS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbnZlcnRGcm9tUG9seWdvbih0KX0pLHRoaXMpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvbHlnb24oZSl9Y29udmVydEZyb21Db2xsZWN0aW9uKHQpe2NvbnN0IGU9dC5nZXRHZW9tZXRyaWVzKCkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5yZWFkKHQpfSksdGhpcyk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihlKX13cml0ZSh0KXtyZXR1cm5cIlBvaW50XCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvUG9pbnQodC5nZXRDb29yZGluYXRlKCkpOlwiTGluZVN0cmluZ1wiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb0xpbmVTdHJpbmcodCk6XCJMaW5lYXJSaW5nXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvTGluZWFyUmluZyh0KTpcIlBvbHlnb25cIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9Qb2x5Z29uKHQpOlwiTXVsdGlQb2ludFwiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb011bHRpUG9pbnQodCk6XCJNdWx0aUxpbmVTdHJpbmdcIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9NdWx0aUxpbmVTdHJpbmcodCk6XCJNdWx0aVBvbHlnb25cIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9NdWx0aVBvbHlnb24odCk6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9Db2xsZWN0aW9uKHQpOnZvaWQgMH1jb252ZXJ0VG9Qb2ludCh0KXtyZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5Qb2ludChbdC54LHQueV0pfWNvbnZlcnRUb0xpbmVTdHJpbmcodCl7Y29uc3QgZT10Ll9wb2ludHMuX2Nvb3JkaW5hdGVzLm1hcChScyk7cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uTGluZVN0cmluZyhlKX1jb252ZXJ0VG9MaW5lYXJSaW5nKHQpe2NvbnN0IGU9dC5fcG9pbnRzLl9jb29yZGluYXRlcy5tYXAoUnMpO3JldHVybiBuZXcgdGhpcy5vbC5nZW9tLkxpbmVhclJpbmcoZSl9Y29udmVydFRvUG9seWdvbih0KXtjb25zdCBlPVt0Ll9zaGVsbC5fcG9pbnRzLl9jb29yZGluYXRlcy5tYXAoUnMpXTtmb3IobGV0IG49MDtuPHQuX2hvbGVzLmxlbmd0aDtuKyspZS5wdXNoKHQuX2hvbGVzW25dLl9wb2ludHMuX2Nvb3JkaW5hdGVzLm1hcChScykpO3JldHVybiBuZXcgdGhpcy5vbC5nZW9tLlBvbHlnb24oZSl9Y29udmVydFRvTXVsdGlQb2ludCh0KXtyZXR1cm4gbmV3IHRoaXMub2wuZ2VvbS5NdWx0aVBvaW50KHQuZ2V0Q29vcmRpbmF0ZXMoKS5tYXAoUnMpKX1jb252ZXJ0VG9NdWx0aUxpbmVTdHJpbmcodCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuX2dlb21ldHJpZXMubGVuZ3RoO24rKyllLnB1c2godGhpcy5jb252ZXJ0VG9MaW5lU3RyaW5nKHQuX2dlb21ldHJpZXNbbl0pLmdldENvb3JkaW5hdGVzKCkpO3JldHVybiBuZXcgdGhpcy5vbC5nZW9tLk11bHRpTGluZVN0cmluZyhlKX1jb252ZXJ0VG9NdWx0aVBvbHlnb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQuX2dlb21ldHJpZXMubGVuZ3RoO24rKyllLnB1c2godGhpcy5jb252ZXJ0VG9Qb2x5Z29uKHQuX2dlb21ldHJpZXNbbl0pLmdldENvb3JkaW5hdGVzKCkpO3JldHVybiBuZXcgdGhpcy5vbC5nZW9tLk11bHRpUG9seWdvbihlKX1jb252ZXJ0VG9Db2xsZWN0aW9uKHQpe2NvbnN0IGU9W107Zm9yKGxldCBuPTA7bjx0Ll9nZW9tZXRyaWVzLmxlbmd0aDtuKyspe2NvbnN0IHM9dC5fZ2VvbWV0cmllc1tuXTtlLnB1c2godGhpcy53cml0ZShzKSl9cmV0dXJuIG5ldyB0aGlzLm9sLmdlb20uR2VvbWV0cnlDb2xsZWN0aW9uKGUpfX0sV0tUUmVhZGVyOmNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMucGFyc2VyPW5ldyBLdCh0fHxuZXcgSHQpfXJlYWQodCl7cmV0dXJuIHRoaXMucGFyc2VyLnJlYWQodCl9fSxXS1RXcml0ZXI6SnR9KTtjbGFzcyB2c3tjb25zdHJ1Y3Rvcigpe3ZzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHJlbGF0aXZlU2lnbih0LGUpe3JldHVybiB0PGU/LTE6dD5lPzE6MH1zdGF0aWMgY29tcGFyZSh0LGUsbil7aWYoZS5lcXVhbHMyRChuKSlyZXR1cm4gMDtjb25zdCBzPXZzLnJlbGF0aXZlU2lnbihlLngsbi54KSxpPXZzLnJlbGF0aXZlU2lnbihlLnksbi55KTtzd2l0Y2godCl7Y2FzZSAwOnJldHVybiB2cy5jb21wYXJlVmFsdWUocyxpKTtjYXNlIDE6cmV0dXJuIHZzLmNvbXBhcmVWYWx1ZShpLHMpO2Nhc2UgMjpyZXR1cm4gdnMuY29tcGFyZVZhbHVlKGksLXMpO2Nhc2UgMzpyZXR1cm4gdnMuY29tcGFyZVZhbHVlKC1zLGkpO2Nhc2UgNDpyZXR1cm4gdnMuY29tcGFyZVZhbHVlKC1zLC1pKTtjYXNlIDU6cmV0dXJuIHZzLmNvbXBhcmVWYWx1ZSgtaSwtcyk7Y2FzZSA2OnJldHVybiB2cy5jb21wYXJlVmFsdWUoLWkscyk7Y2FzZSA3OnJldHVybiB2cy5jb21wYXJlVmFsdWUocywtaSl9cmV0dXJuIHUuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJpbnZhbGlkIG9jdGFudCB2YWx1ZVwiKSwwfXN0YXRpYyBjb21wYXJlVmFsdWUodCxlKXtyZXR1cm4gdDwwPy0xOnQ+MD8xOmU8MD8tMTplPjA/MTowfWdldENsYXNzKCl7cmV0dXJuIHZzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX12cy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIE9ze2NvbnN0cnVjdG9yKCl7T3MuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuY29vcmR9cHJpbnQodCl7dC5wcmludCh0aGlzLmNvb3JkKSx0LnByaW50KFwiIHNlZyAjID0gXCIrdGhpcy5zZWdtZW50SW5kZXgpfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuc2VnbWVudEluZGV4PGUuc2VnbWVudEluZGV4Py0xOnRoaXMuc2VnbWVudEluZGV4PmUuc2VnbWVudEluZGV4PzE6dGhpcy5jb29yZC5lcXVhbHMyRChlLmNvb3JkKT8wOnZzLmNvbXBhcmUodGhpcy5fc2VnbWVudE9jdGFudCx0aGlzLmNvb3JkLGUuY29vcmQpfWlzRW5kUG9pbnQodCl7cmV0dXJuIDA9PT10aGlzLnNlZ21lbnRJbmRleCYmIXRoaXMuX2lzSW50ZXJpb3J8fHRoaXMuc2VnbWVudEluZGV4PT09dH1pc0ludGVyaW9yKCl7cmV0dXJuIHRoaXMuX2lzSW50ZXJpb3J9Z2V0Q2xhc3MoKXtyZXR1cm4gT3N9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3JdfX1Pcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9zZWdTdHJpbmc9bnVsbCx0aGlzLmNvb3JkPW51bGwsdGhpcy5zZWdtZW50SW5kZXg9bnVsbCx0aGlzLl9zZWdtZW50T2N0YW50PW51bGwsdGhpcy5faXNJbnRlcmlvcj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuX3NlZ1N0cmluZz10LHRoaXMuY29vcmQ9bmV3IGcoZSksdGhpcy5zZWdtZW50SW5kZXg9bix0aGlzLl9zZWdtZW50T2N0YW50PXMsdGhpcy5faXNJbnRlcmlvcj0hZS5lcXVhbHMyRCh0LmdldENvb3JkaW5hdGUobikpfTtjbGFzcyBic3tjb25zdHJ1Y3Rvcigpe2JzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0U3BsaXRDb29yZGluYXRlcygpe2NvbnN0IHQ9bmV3IEk7dGhpcy5hZGRFbmRwb2ludHMoKTtjb25zdCBlPXRoaXMuaXRlcmF0b3IoKTtsZXQgbj1lLm5leHQoKTtmb3IoO2UuaGFzTmV4dCgpOyl7Y29uc3Qgcz1lLm5leHQoKTt0aGlzLmFkZEVkZ2VDb29yZGluYXRlcyhuLHMsdCksbj1zfXJldHVybiB0LnRvQ29vcmRpbmF0ZUFycmF5KCl9YWRkQ29sbGFwc2VkTm9kZXMoKXtjb25zdCB0PW5ldyB4O3RoaXMuZmluZENvbGxhcHNlc0Zyb21JbnNlcnRlZE5vZGVzKHQpLHRoaXMuZmluZENvbGxhcHNlc0Zyb21FeGlzdGluZ1ZlcnRpY2VzKHQpO2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLmludFZhbHVlKCk7dGhpcy5hZGQodGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKHQpLHQpfX1wcmludCh0KXt0LnByaW50bG4oXCJJbnRlcnNlY3Rpb25zOlwiKTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkucHJpbnQodCl9fWZpbmRDb2xsYXBzZXNGcm9tRXhpc3RpbmdWZXJ0aWNlcyh0KXtmb3IobGV0IGU9MDtlPHRoaXMuX2VkZ2Uuc2l6ZSgpLTI7ZSsrKXtjb25zdCBuPXRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShlKSxzPSh0aGlzLl9lZGdlLmdldENvb3JkaW5hdGUoZSsxKSx0aGlzLl9lZGdlLmdldENvb3JkaW5hdGUoZSsyKSk7bi5lcXVhbHMyRChzKSYmdC5hZGQobmV3IEwoZSsxKSl9fWFkZEVkZ2VDb29yZGluYXRlcyh0LGUsbil7ZS5zZWdtZW50SW5kZXgsdC5zZWdtZW50SW5kZXg7Y29uc3Qgcz10aGlzLl9lZGdlLmdldENvb3JkaW5hdGUoZS5zZWdtZW50SW5kZXgpLGk9ZS5pc0ludGVyaW9yKCl8fCFlLmNvb3JkLmVxdWFsczJEKHMpO24uYWRkKG5ldyBnKHQuY29vcmQpLCExKTtmb3IobGV0IHM9dC5zZWdtZW50SW5kZXgrMTtzPD1lLnNlZ21lbnRJbmRleDtzKyspbi5hZGQodGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKHMpKTtpJiZuLmFkZChuZXcgZyhlLmNvb3JkKSl9aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fbm9kZU1hcC52YWx1ZXMoKS5pdGVyYXRvcigpfWFkZFNwbGl0RWRnZXModCl7dGhpcy5hZGRFbmRwb2ludHMoKSx0aGlzLmFkZENvbGxhcHNlZE5vZGVzKCk7Y29uc3QgZT10aGlzLml0ZXJhdG9yKCk7bGV0IG49ZS5uZXh0KCk7Zm9yKDtlLmhhc05leHQoKTspe2NvbnN0IHM9ZS5uZXh0KCksaT10aGlzLmNyZWF0ZVNwbGl0RWRnZShuLHMpO3QuYWRkKGkpLG49c319ZmluZENvbGxhcHNlSW5kZXgodCxlLG4pe2lmKCF0LmNvb3JkLmVxdWFsczJEKGUuY29vcmQpKXJldHVybiExO2xldCBzPWUuc2VnbWVudEluZGV4LXQuc2VnbWVudEluZGV4O3JldHVybiBlLmlzSW50ZXJpb3IoKXx8cy0tLDE9PT1zJiYoblswXT10LnNlZ21lbnRJbmRleCsxLCEwKX1maW5kQ29sbGFwc2VzRnJvbUluc2VydGVkTm9kZXModCl7Y29uc3QgZT1uZXcgQXJyYXkoMSkuZmlsbChudWxsKSxuPXRoaXMuaXRlcmF0b3IoKTtsZXQgcz1uLm5leHQoKTtmb3IoO24uaGFzTmV4dCgpOyl7Y29uc3QgaT1uLm5leHQoKTt0aGlzLmZpbmRDb2xsYXBzZUluZGV4KHMsaSxlKSYmdC5hZGQobmV3IEwoZVswXSkpLHM9aX19Z2V0RWRnZSgpe3JldHVybiB0aGlzLl9lZGdlfWFkZEVuZHBvaW50cygpe2NvbnN0IHQ9dGhpcy5fZWRnZS5zaXplKCktMTt0aGlzLmFkZCh0aGlzLl9lZGdlLmdldENvb3JkaW5hdGUoMCksMCksdGhpcy5hZGQodGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKHQpLHQpfWNyZWF0ZVNwbGl0RWRnZSh0LGUpe2xldCBuPWUuc2VnbWVudEluZGV4LXQuc2VnbWVudEluZGV4KzI7Y29uc3Qgcz10aGlzLl9lZGdlLmdldENvb3JkaW5hdGUoZS5zZWdtZW50SW5kZXgpLGk9ZS5pc0ludGVyaW9yKCl8fCFlLmNvb3JkLmVxdWFsczJEKHMpO2l8fG4tLTtjb25zdCByPW5ldyBBcnJheShuKS5maWxsKG51bGwpO2xldCBvPTA7cltvKytdPW5ldyBnKHQuY29vcmQpO2ZvcihsZXQgbj10LnNlZ21lbnRJbmRleCsxO248PWUuc2VnbWVudEluZGV4O24rKylyW28rK109dGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKG4pO3JldHVybiBpJiYocltvXT1uZXcgZyhlLmNvb3JkKSksbmV3IEZzKHIsdGhpcy5fZWRnZS5nZXREYXRhKCkpfWFkZCh0LGUpe2NvbnN0IG49bmV3IE9zKHRoaXMuX2VkZ2UsdCxlLHRoaXMuX2VkZ2UuZ2V0U2VnbWVudE9jdGFudChlKSkscz10aGlzLl9ub2RlTWFwLmdldChuKTtyZXR1cm4gbnVsbCE9PXM/KHUuaXNUcnVlKHMuY29vcmQuZXF1YWxzMkQodCksXCJGb3VuZCBlcXVhbCBub2RlcyB3aXRoIGRpZmZlcmVudCBjb29yZGluYXRlc1wiKSxzKToodGhpcy5fbm9kZU1hcC5wdXQobixuKSxuKX1jaGVja1NwbGl0RWRnZXNDb3JyZWN0bmVzcyh0KXtjb25zdCBlPXRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZXMoKSxuPXQuZ2V0KDApLmdldENvb3JkaW5hdGUoMCk7aWYoIW4uZXF1YWxzMkQoZVswXSkpdGhyb3cgbmV3IGMoXCJiYWQgc3BsaXQgZWRnZSBzdGFydCBwb2ludCBhdCBcIituKTtjb25zdCBzPXQuZ2V0KHQuc2l6ZSgpLTEpLmdldENvb3JkaW5hdGVzKCksaT1zW3MubGVuZ3RoLTFdO2lmKCFpLmVxdWFsczJEKGVbZS5sZW5ndGgtMV0pKXRocm93IG5ldyBjKFwiYmFkIHNwbGl0IGVkZ2UgZW5kIHBvaW50IGF0IFwiK2kpfWdldENsYXNzKCl7cmV0dXJuIGJzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1icy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9ub2RlTWFwPW5ldyBydCx0aGlzLl9lZGdlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZWRnZT10fTtjbGFzcyBNc3tjb25zdHJ1Y3Rvcigpe01zLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIG9jdGFudCgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKDA9PT10JiYwPT09ZSl0aHJvdyBuZXcgbihcIkNhbm5vdCBjb21wdXRlIHRoZSBvY3RhbnQgZm9yIHBvaW50ICggXCIrdCtcIiwgXCIrZStcIiApXCIpO2NvbnN0IHM9TWF0aC5hYnModCksaT1NYXRoLmFicyhlKTtyZXR1cm4gdD49MD9lPj0wP3M+PWk/MDoxOnM+PWk/Nzo2OmU+PTA/cz49aT8zOjI6cz49aT80OjV9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLHM9ZS54LXQueCxpPWUueS10Lnk7aWYoMD09PXMmJjA9PT1pKXRocm93IG5ldyBuKFwiQ2Fubm90IGNvbXB1dGUgdGhlIG9jdGFudCBmb3IgdHdvIGlkZW50aWNhbCBwb2ludHMgXCIrdCk7cmV0dXJuIE1zLm9jdGFudChzLGkpfX1nZXRDbGFzcygpe3JldHVybiBNc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19TXMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBEc3tjb25zdHJ1Y3Rvcigpe0RzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q29vcmRpbmF0ZXMoKXt9c2l6ZSgpe31nZXRDb29yZGluYXRlKHQpe31pc0Nsb3NlZCgpe31zZXREYXRhKHQpe31nZXREYXRhKCl7fWdldENsYXNzKCl7cmV0dXJuIERzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Ecy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIEFze2NvbnN0cnVjdG9yKCl7QXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1hZGRJbnRlcnNlY3Rpb24odCxlKXt9Z2V0Q2xhc3MoKXtyZXR1cm4gQXN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0RzXX19QXMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBGc3tjb25zdHJ1Y3Rvcigpe0ZzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGdldE5vZGVkU3Vic3RyaW5ncygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyB4O3JldHVybiBGcy5nZXROb2RlZFN1YnN0cmluZ3ModCxlKSxlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7bi5uZXh0KCkuZ2V0Tm9kZUxpc3QoKS5hZGRTcGxpdEVkZ2VzKGUpfX19Z2V0Q29vcmRpbmF0ZXMoKXtyZXR1cm4gdGhpcy5fcHRzfXNpemUoKXtyZXR1cm4gdGhpcy5fcHRzLmxlbmd0aH1nZXRDb29yZGluYXRlKHQpe3JldHVybiB0aGlzLl9wdHNbdF19aXNDbG9zZWQoKXtyZXR1cm4gdGhpcy5fcHRzWzBdLmVxdWFscyh0aGlzLl9wdHNbdGhpcy5fcHRzLmxlbmd0aC0xXSl9Z2V0U2VnbWVudE9jdGFudCh0KXtyZXR1cm4gdD09PXRoaXMuX3B0cy5sZW5ndGgtMT8tMTp0aGlzLnNhZmVPY3RhbnQodGhpcy5nZXRDb29yZGluYXRlKHQpLHRoaXMuZ2V0Q29vcmRpbmF0ZSh0KzEpKX1zZXREYXRhKHQpe3RoaXMuX2RhdGE9dH1zYWZlT2N0YW50KHQsZSl7cmV0dXJuIHQuZXF1YWxzMkQoZSk/MDpNcy5vY3RhbnQodCxlKX1nZXREYXRhKCl7cmV0dXJuIHRoaXMuX2RhdGF9YWRkSW50ZXJzZWN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuYWRkSW50ZXJzZWN0aW9uTm9kZSh0LGUpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzNdLHM9bmV3IGcodC5nZXRJbnRlcnNlY3Rpb24obikpO3RoaXMuYWRkSW50ZXJzZWN0aW9uKHMsZSl9fXRvU3RyaW5nKCl7cmV0dXJuIEp0LnRvTGluZVN0cmluZyhuZXcgenQodGhpcy5fcHRzKSl9Z2V0Tm9kZUxpc3QoKXtyZXR1cm4gdGhpcy5fbm9kZUxpc3R9YWRkSW50ZXJzZWN0aW9uTm9kZSh0LGUpe2xldCBuPWU7Y29uc3Qgcz1uKzE7aWYoczx0aGlzLl9wdHMubGVuZ3RoKXtjb25zdCBlPXRoaXMuX3B0c1tzXTt0LmVxdWFsczJEKGUpJiYobj1zKX1yZXR1cm4gdGhpcy5fbm9kZUxpc3QuYWRkKHQsbil9YWRkSW50ZXJzZWN0aW9ucyh0LGUsbil7Zm9yKGxldCBzPTA7czx0LmdldEludGVyc2VjdGlvbk51bSgpO3MrKyl0aGlzLmFkZEludGVyc2VjdGlvbih0LGUsbixzKX1nZXRDbGFzcygpe3JldHVybiBGc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bQXNdfX1Gcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9ub2RlTGlzdD1uZXcgYnModGhpcyksdGhpcy5fcHRzPW51bGwsdGhpcy5fZGF0YT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3B0cz10LHRoaXMuX2RhdGE9ZX07Y2xhc3MgR3N7Y29uc3RydWN0b3IoKXtHcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfW92ZXJsYXAoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dC5nZXRMaW5lU2VnbWVudChlLHRoaXMuX292ZXJsYXBTZWcxKSxuLmdldExpbmVTZWdtZW50KHMsdGhpcy5fb3ZlcmxhcFNlZzIpLHRoaXMub3ZlcmxhcCh0aGlzLl9vdmVybGFwU2VnMSx0aGlzLl9vdmVybGFwU2VnMil9fWdldENsYXNzKCl7cmV0dXJuIEdzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Hcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9vdmVybGFwU2VnMT1uZXcgZWUsdGhpcy5fb3ZlcmxhcFNlZzI9bmV3IGVlfTtjbGFzcyBxc3tjb25zdHJ1Y3Rvcigpe3FzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0TGluZVNlZ21lbnQodCxlKXtlLnAwPXRoaXMuX3B0c1t0XSxlLnAxPXRoaXMuX3B0c1t0KzFdfWNvbXB1dGVTZWxlY3QodCxlLG4scyl7Y29uc3QgaT10aGlzLl9wdHNbZV0scj10aGlzLl9wdHNbbl07aWYobi1lPT0xKXJldHVybiBzLnNlbGVjdCh0aGlzLGUpLG51bGw7aWYoIXQuaW50ZXJzZWN0cyhpLHIpKXJldHVybiBudWxsO2NvbnN0IG89TWF0aC50cnVuYygoZStuKS8yKTtlPG8mJnRoaXMuY29tcHV0ZVNlbGVjdCh0LGUsbyxzKSxvPG4mJnRoaXMuY29tcHV0ZVNlbGVjdCh0LG8sbixzKX1nZXRDb29yZGluYXRlcygpe2NvbnN0IHQ9bmV3IEFycmF5KHRoaXMuX2VuZC10aGlzLl9zdGFydCsxKS5maWxsKG51bGwpO2xldCBlPTA7Zm9yKGxldCBuPXRoaXMuX3N0YXJ0O248PXRoaXMuX2VuZDtuKyspdFtlKytdPXRoaXMuX3B0c1tuXTtyZXR1cm4gdH1jb21wdXRlT3ZlcmxhcHMoKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5jb21wdXRlT3ZlcmxhcHModGhpcy5fc3RhcnQsdGhpcy5fZW5kLHQsdC5fc3RhcnQsdC5fZW5kLGUpfWVsc2UgaWYoNj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLHI9YXJndW1lbnRzWzVdO2lmKGUtdD09MSYmaS1zPT0xKXJldHVybiByLm92ZXJsYXAodGhpcyx0LG4scyksbnVsbDtpZighdGhpcy5vdmVybGFwcyh0LGUsbixzLGkpKXJldHVybiBudWxsO2NvbnN0IG89TWF0aC50cnVuYygodCtlKS8yKSxsPU1hdGgudHJ1bmMoKHMraSkvMik7dDxvJiYoczxsJiZ0aGlzLmNvbXB1dGVPdmVybGFwcyh0LG8sbixzLGwsciksbDxpJiZ0aGlzLmNvbXB1dGVPdmVybGFwcyh0LG8sbixsLGkscikpLG88ZSYmKHM8bCYmdGhpcy5jb21wdXRlT3ZlcmxhcHMobyxlLG4scyxsLHIpLGw8aSYmdGhpcy5jb21wdXRlT3ZlcmxhcHMobyxlLG4sbCxpLHIpKX19c2V0SWQodCl7dGhpcy5faWQ9dH1zZWxlY3QodCxlKXt0aGlzLmNvbXB1dGVTZWxlY3QodCx0aGlzLl9zdGFydCx0aGlzLl9lbmQsZSl9Z2V0RW52ZWxvcGUoKXtpZihudWxsPT09dGhpcy5fZW52KXtjb25zdCB0PXRoaXMuX3B0c1t0aGlzLl9zdGFydF0sZT10aGlzLl9wdHNbdGhpcy5fZW5kXTt0aGlzLl9lbnY9bmV3IE4odCxlKX1yZXR1cm4gdGhpcy5fZW52fW92ZXJsYXBzKHQsZSxuLHMsaSl7cmV0dXJuIE4uaW50ZXJzZWN0cyh0aGlzLl9wdHNbdF0sdGhpcy5fcHRzW2VdLG4uX3B0c1tzXSxuLl9wdHNbaV0pfWdldEVuZEluZGV4KCl7cmV0dXJuIHRoaXMuX2VuZH1nZXRTdGFydEluZGV4KCl7cmV0dXJuIHRoaXMuX3N0YXJ0fWdldENvbnRleHQoKXtyZXR1cm4gdGhpcy5fY29udGV4dH1nZXRJZCgpe3JldHVybiB0aGlzLl9pZH1nZXRDbGFzcygpe3JldHVybiBxc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19cXMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcHRzPW51bGwsdGhpcy5fc3RhcnQ9bnVsbCx0aGlzLl9lbmQ9bnVsbCx0aGlzLl9lbnY9bnVsbCx0aGlzLl9jb250ZXh0PW51bGwsdGhpcy5faWQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0aGlzLl9wdHM9dCx0aGlzLl9zdGFydD1lLHRoaXMuX2VuZD1uLHRoaXMuX2NvbnRleHQ9c307Y2xhc3MgQnN7Y29uc3RydWN0b3IoKXtCcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBnZXRDaGFpblN0YXJ0SW5kaWNlcyh0KXtsZXQgZT0wO2NvbnN0IG49bmV3IHg7bi5hZGQobmV3IEwoZSkpO2Rve2NvbnN0IHM9QnMuZmluZENoYWluRW5kKHQsZSk7bi5hZGQobmV3IEwocykpLGU9c313aGlsZShlPHQubGVuZ3RoLTEpO3JldHVybiBCcy50b0ludEFycmF5KG4pfXN0YXRpYyBmaW5kQ2hhaW5FbmQodCxlKXtsZXQgbj1lO2Zvcig7bjx0Lmxlbmd0aC0xJiZ0W25dLmVxdWFsczJEKHRbbisxXSk7KW4rKztpZihuPj10Lmxlbmd0aC0xKXJldHVybiB0Lmxlbmd0aC0xO2NvbnN0IHM9SW4ucXVhZHJhbnQodFtuXSx0W24rMV0pO2xldCBpPWUrMTtmb3IoO2k8dC5sZW5ndGg7KXtpZighdFtpLTFdLmVxdWFsczJEKHRbaV0pKXtpZihJbi5xdWFkcmFudCh0W2ktMV0sdFtpXSkhPT1zKWJyZWFrfWkrK31yZXR1cm4gaS0xfXN0YXRpYyBnZXRDaGFpbnMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIEJzLmdldENoYWlucyh0LG51bGwpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyB4LHM9QnMuZ2V0Q2hhaW5TdGFydEluZGljZXModCk7Zm9yKGxldCBpPTA7aTxzLmxlbmd0aC0xO2krKyl7Y29uc3Qgcj1uZXcgcXModCxzW2ldLHNbaSsxXSxlKTtuLmFkZChyKX1yZXR1cm4gbn19c3RhdGljIHRvSW50QXJyYXkodCl7Y29uc3QgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspZVtuXT10LmdldChuKS5pbnRWYWx1ZSgpO3JldHVybiBlfWdldENsYXNzKCl7cmV0dXJuIEJzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Ccy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIFZze2NvbnN0cnVjdG9yKCl7VnMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jb21wdXRlTm9kZXModCl7fWdldE5vZGVkU3Vic3RyaW5ncygpe31nZXRDbGFzcygpe3JldHVybiBWc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19VnMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyB6c3tjb25zdHJ1Y3Rvcigpe3pzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c2V0U2VnbWVudEludGVyc2VjdG9yKHQpe3RoaXMuX3NlZ0ludD10fWdldENsYXNzKCl7cmV0dXJuIHpzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltWc119fXpzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX3NlZ0ludD1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNldFNlZ21lbnRJbnRlcnNlY3Rvcih0KX19O2NsYXNzIFlzIGV4dGVuZHMgenN7Y29uc3RydWN0b3IoKXtzdXBlcigpLFlzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0TW9ub3RvbmVDaGFpbnMoKXtyZXR1cm4gdGhpcy5fbW9ub0NoYWluc31nZXROb2RlZFN1YnN0cmluZ3MoKXtyZXR1cm4gRnMuZ2V0Tm9kZWRTdWJzdHJpbmdzKHRoaXMuX25vZGVkU2VnU3RyaW5ncyl9Z2V0SW5kZXgoKXtyZXR1cm4gdGhpcy5faW5kZXh9YWRkKHQpe2ZvcihsZXQgZT1Ccy5nZXRDaGFpbnModC5nZXRDb29yZGluYXRlcygpLHQpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3Quc2V0SWQodGhpcy5faWRDb3VudGVyKyspLHRoaXMuX2luZGV4Lmluc2VydCh0LmdldEVudmVsb3BlKCksdCksdGhpcy5fbW9ub0NoYWlucy5hZGQodCl9fWNvbXB1dGVOb2Rlcyh0KXt0aGlzLl9ub2RlZFNlZ1N0cmluZ3M9dDtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLmFkZChlLm5leHQoKSk7dGhpcy5pbnRlcnNlY3RDaGFpbnMoKX1pbnRlcnNlY3RDaGFpbnMoKXtjb25zdCB0PW5ldyBVcyh0aGlzLl9zZWdJbnQpO2ZvcihsZXQgZT10aGlzLl9tb25vQ2hhaW5zLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO2ZvcihsZXQgZT10aGlzLl9pbmRleC5xdWVyeShuLmdldEVudmVsb3BlKCkpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBzPWUubmV4dCgpO2lmKHMuZ2V0SWQoKT5uLmdldElkKCkmJihuLmNvbXB1dGVPdmVybGFwcyhzLHQpLHRoaXMuX25PdmVybGFwcysrKSx0aGlzLl9zZWdJbnQuaXNEb25lKCkpcmV0dXJuIG51bGx9fX1nZXRDbGFzcygpe3JldHVybiBZc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3MgVXMgZXh0ZW5kcyBHc3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksVXMuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1vdmVybGFwKCl7aWYoNCE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHN1cGVyLm92ZXJsYXAuYXBwbHkodGhpcyxhcmd1bWVudHMpO3tjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPXQuZ2V0Q29udGV4dCgpLHI9bi5nZXRDb250ZXh0KCk7dGhpcy5fc2kucHJvY2Vzc0ludGVyc2VjdGlvbnMoaSxlLHIscyl9fWdldENsYXNzKCl7cmV0dXJuIFVzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Vcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9zaT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NpPXR9LFlzLlNlZ21lbnRPdmVybGFwQWN0aW9uPVVzLFlzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX21vbm9DaGFpbnM9bmV3IHgsdGhpcy5faW5kZXg9bmV3IEVzLHRoaXMuX2lkQ291bnRlcj0wLHRoaXMuX25vZGVkU2VnU3RyaW5ncz1udWxsLHRoaXMuX25PdmVybGFwcz0wLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt6cy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfX07Y2xhc3Mga3N7Y29uc3RydWN0b3IoKXtrcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXJlc2NhbGUoKXtpZihfKGFyZ3VtZW50c1swXSxmKSl7Zm9yKGxldCB0PWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLnJlc2NhbGUoZS5nZXRDb29yZGluYXRlcygpKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT1udWxsLG49bnVsbDsyPT09dC5sZW5ndGgmJihlPW5ldyBnKHRbMF0pLG49bmV3IGcodFsxXSkpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV0ueD10W2VdLngvdGhpcy5fc2NhbGVGYWN0b3IrdGhpcy5fb2Zmc2V0WCx0W2VdLnk9dFtlXS55L3RoaXMuX3NjYWxlRmFjdG9yK3RoaXMuX29mZnNldFk7Mj09PXQubGVuZ3RoJiZ0WzBdLmVxdWFsczJEKHRbMV0pJiZPLm91dC5wcmludGxuKHQpfX1zY2FsZSgpe2lmKF8oYXJndW1lbnRzWzBdLGYpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyB4KHQuc2l6ZSgpKTtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtlLmFkZChuZXcgRnModGhpcy5zY2FsZSh0LmdldENvb3JkaW5hdGVzKCkpLHQuZ2V0RGF0YSgpKSl9cmV0dXJuIGV9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspZVtuXT1uZXcgZyhNYXRoLnJvdW5kKCh0W25dLngtdGhpcy5fb2Zmc2V0WCkqdGhpcy5fc2NhbGVGYWN0b3IpLE1hdGgucm91bmQoKHRbbl0ueS10aGlzLl9vZmZzZXRZKSp0aGlzLl9zY2FsZUZhY3RvciksdFtuXS56KTtyZXR1cm4gWC5yZW1vdmVSZXBlYXRlZFBvaW50cyhlKX19aXNJbnRlZ2VyUHJlY2lzaW9uKCl7cmV0dXJuIDE9PT10aGlzLl9zY2FsZUZhY3Rvcn1nZXROb2RlZFN1YnN0cmluZ3MoKXtjb25zdCB0PXRoaXMuX25vZGVyLmdldE5vZGVkU3Vic3RyaW5ncygpO3JldHVybiB0aGlzLl9pc1NjYWxlZCYmdGhpcy5yZXNjYWxlKHQpLHR9Y29tcHV0ZU5vZGVzKHQpe2xldCBlPXQ7dGhpcy5faXNTY2FsZWQmJihlPXRoaXMuc2NhbGUodCkpLHRoaXMuX25vZGVyLmNvbXB1dGVOb2RlcyhlKX1nZXRDbGFzcygpe3JldHVybiBrc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bVnNdfX1rcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9ub2Rlcj1udWxsLHRoaXMuX3NjYWxlRmFjdG9yPW51bGwsdGhpcy5fb2Zmc2V0WD1udWxsLHRoaXMuX29mZnNldFk9bnVsbCx0aGlzLl9pc1NjYWxlZD0hMSwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07a3MuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsMCwwKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9ub2Rlcj10LHRoaXMuX3NjYWxlRmFjdG9yPWUsdGhpcy5faXNTY2FsZWQ9IXRoaXMuaXNJbnRlZ2VyUHJlY2lzaW9uKCl9fTt2YXIgWHM9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsTUNJbmRleE5vZGVyOllzLFNjYWxlZE5vZGVyOmtzLFNlZ21lbnRTdHJpbmc6RHN9KTtjbGFzcyBIc3tjb25zdHJ1Y3Rvcigpe0hzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGlzU2ltcGxlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgSHModCkuaXNTaW1wbGUoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIG5ldyBIcyh0LGUpLmlzU2ltcGxlKCl9fWlzU2ltcGxlTXVsdGlQb2ludCh0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4hMDtjb25zdCBlPW5ldyBhdDtmb3IobGV0IG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7Y29uc3Qgcz10LmdldEdlb21ldHJ5TihuKS5nZXRDb29yZGluYXRlKCk7aWYoZS5jb250YWlucyhzKSlyZXR1cm4gdGhpcy5fbm9uU2ltcGxlTG9jYXRpb249cywhMTtlLmFkZChzKX1yZXR1cm4hMH1pc1NpbXBsZVBvbHlnb25hbCh0KXtmb3IobGV0IGU9eGUuZ2V0TGluZXModCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7aWYoIXRoaXMuaXNTaW1wbGVMaW5lYXJHZW9tZXRyeSh0KSlyZXR1cm4hMX1yZXR1cm4hMH1oYXNDbG9zZWRFbmRwb2ludEludGVyc2VjdGlvbih0KXtjb25zdCBlPW5ldyBydDtmb3IobGV0IG49dC5nZXRFZGdlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCkscz0odC5nZXRNYXhpbXVtU2VnbWVudEluZGV4KCksdC5pc0Nsb3NlZCgpKSxpPXQuZ2V0Q29vcmRpbmF0ZSgwKTt0aGlzLmFkZEVuZHBvaW50KGUsaSxzKTtjb25zdCByPXQuZ2V0Q29vcmRpbmF0ZSh0LmdldE51bVBvaW50cygpLTEpO3RoaXMuYWRkRW5kcG9pbnQoZSxyLHMpfWZvcihsZXQgdD1lLnZhbHVlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO2lmKGUuaXNDbG9zZWQmJjIhPT1lLmRlZ3JlZSlyZXR1cm4gdGhpcy5fbm9uU2ltcGxlTG9jYXRpb249ZS5nZXRDb29yZGluYXRlKCksITB9cmV0dXJuITF9Z2V0Tm9uU2ltcGxlTG9jYXRpb24oKXtyZXR1cm4gdGhpcy5fbm9uU2ltcGxlTG9jYXRpb259aXNTaW1wbGVMaW5lYXJHZW9tZXRyeSh0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4hMDtjb25zdCBlPW5ldyBRbigwLHQpLG49bmV3IHRlLHM9ZS5jb21wdXRlU2VsZk5vZGVzKG4sITApO3JldHVybiFzLmhhc0ludGVyc2VjdGlvbigpfHwocy5oYXNQcm9wZXJJbnRlcnNlY3Rpb24oKT8odGhpcy5fbm9uU2ltcGxlTG9jYXRpb249cy5nZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCgpLCExKTohdGhpcy5oYXNOb25FbmRwb2ludEludGVyc2VjdGlvbihlKSYmKCF0aGlzLl9pc0Nsb3NlZEVuZHBvaW50c0luSW50ZXJpb3J8fCF0aGlzLmhhc0Nsb3NlZEVuZHBvaW50SW50ZXJzZWN0aW9uKGUpKSl9aGFzTm9uRW5kcG9pbnRJbnRlcnNlY3Rpb24odCl7Zm9yKGxldCBlPXQuZ2V0RWRnZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLG49dC5nZXRNYXhpbXVtU2VnbWVudEluZGV4KCk7Zm9yKGxldCBlPXQuZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTtpZighdC5pc0VuZFBvaW50KG4pKXJldHVybiB0aGlzLl9ub25TaW1wbGVMb2NhdGlvbj10LmdldENvb3JkaW5hdGUoKSwhMH19cmV0dXJuITF9YWRkRW5kcG9pbnQodCxlLG4pe2xldCBzPXQuZ2V0KGUpO251bGw9PT1zJiYocz1uZXcgV3MoZSksdC5wdXQoZSxzKSkscy5hZGRFbmRwb2ludChuKX1jb21wdXRlU2ltcGxlKHQpe3JldHVybiB0aGlzLl9ub25TaW1wbGVMb2NhdGlvbj1udWxsLCEhdC5pc0VtcHR5KCl8fCh0IGluc3RhbmNlb2YgVHR8fHQgaW5zdGFuY2VvZiBmdD90aGlzLmlzU2ltcGxlTGluZWFyR2VvbWV0cnkodCk6dCBpbnN0YW5jZW9mIE10P3RoaXMuaXNTaW1wbGVNdWx0aVBvaW50KHQpOl8odCxPdCk/dGhpcy5pc1NpbXBsZVBvbHlnb25hbCh0KTohKHQgaW5zdGFuY2VvZiBfdCl8fHRoaXMuaXNTaW1wbGVHZW9tZXRyeUNvbGxlY3Rpb24odCkpfWlzU2ltcGxlKCl7cmV0dXJuIHRoaXMuX25vblNpbXBsZUxvY2F0aW9uPW51bGwsdGhpcy5jb21wdXRlU2ltcGxlKHRoaXMuX2lucHV0R2VvbSl9aXNTaW1wbGVHZW9tZXRyeUNvbGxlY3Rpb24odCl7Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7aWYoIXRoaXMuY29tcHV0ZVNpbXBsZShuKSlyZXR1cm4hMX1yZXR1cm4hMH1nZXRDbGFzcygpe3JldHVybiBIc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3MgV3N7Y29uc3RydWN0b3IoKXtXcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWFkZEVuZHBvaW50KHQpe3RoaXMuZGVncmVlKyssdGhpcy5pc0Nsb3NlZHw9dH1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMucHR9Z2V0Q2xhc3MoKXtyZXR1cm4gV3N9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVdzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMucHQ9bnVsbCx0aGlzLmlzQ2xvc2VkPW51bGwsdGhpcy5kZWdyZWU9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnB0PXQsdGhpcy5pc0Nsb3NlZD0hMSx0aGlzLmRlZ3JlZT0wfSxIcy5FbmRwb2ludEluZm89V3MsSHMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5faXNDbG9zZWRFbmRwb2ludHNJbkludGVyaW9yPSEwLHRoaXMuX25vblNpbXBsZUxvY2F0aW9uPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2lucHV0R2VvbT10fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2lucHV0R2VvbT10LHRoaXMuX2lzQ2xvc2VkRW5kcG9pbnRzSW5JbnRlcmlvcj0hZS5pc0luQm91bmRhcnkoMil9fTtjbGFzcyBqc3tjb25zdHJ1Y3Rvcigpe2pzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGJ1ZmZlckRpc3RhbmNlRXJyb3IodCl7Y29uc3QgZT1NYXRoLlBJLzIvdDtyZXR1cm4gMS1NYXRoLmNvcyhlLzIpfWdldEVuZENhcFN0eWxlKCl7cmV0dXJuIHRoaXMuX2VuZENhcFN0eWxlfWlzU2luZ2xlU2lkZWQoKXtyZXR1cm4gdGhpcy5faXNTaW5nbGVTaWRlZH1zZXRRdWFkcmFudFNlZ21lbnRzKHQpe3RoaXMuX3F1YWRyYW50U2VnbWVudHM9dCwwPT09dGhpcy5fcXVhZHJhbnRTZWdtZW50cyYmKHRoaXMuX2pvaW5TdHlsZT1qcy5KT0lOX0JFVkVMKSx0aGlzLl9xdWFkcmFudFNlZ21lbnRzPDAmJih0aGlzLl9qb2luU3R5bGU9anMuSk9JTl9NSVRSRSx0aGlzLl9taXRyZUxpbWl0PU1hdGguYWJzKHRoaXMuX3F1YWRyYW50U2VnbWVudHMpKSx0PD0wJiYodGhpcy5fcXVhZHJhbnRTZWdtZW50cz0xKSx0aGlzLl9qb2luU3R5bGUhPT1qcy5KT0lOX1JPVU5EJiYodGhpcy5fcXVhZHJhbnRTZWdtZW50cz1qcy5ERUZBVUxUX1FVQURSQU5UX1NFR01FTlRTKX1nZXRKb2luU3R5bGUoKXtyZXR1cm4gdGhpcy5fam9pblN0eWxlfXNldEpvaW5TdHlsZSh0KXt0aGlzLl9qb2luU3R5bGU9dH1zZXRTaW1wbGlmeUZhY3Rvcih0KXt0aGlzLl9zaW1wbGlmeUZhY3Rvcj10PDA/MDp0fWdldFNpbXBsaWZ5RmFjdG9yKCl7cmV0dXJuIHRoaXMuX3NpbXBsaWZ5RmFjdG9yfWdldFF1YWRyYW50U2VnbWVudHMoKXtyZXR1cm4gdGhpcy5fcXVhZHJhbnRTZWdtZW50c31zZXRFbmRDYXBTdHlsZSh0KXt0aGlzLl9lbmRDYXBTdHlsZT10fWdldE1pdHJlTGltaXQoKXtyZXR1cm4gdGhpcy5fbWl0cmVMaW1pdH1zZXRNaXRyZUxpbWl0KHQpe3RoaXMuX21pdHJlTGltaXQ9dH1zZXRTaW5nbGVTaWRlZCh0KXt0aGlzLl9pc1NpbmdsZVNpZGVkPXR9Z2V0Q2xhc3MoKXtyZXR1cm4ganN9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWpzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX3F1YWRyYW50U2VnbWVudHM9anMuREVGQVVMVF9RVUFEUkFOVF9TRUdNRU5UUyx0aGlzLl9lbmRDYXBTdHlsZT1qcy5DQVBfUk9VTkQsdGhpcy5fam9pblN0eWxlPWpzLkpPSU5fUk9VTkQsdGhpcy5fbWl0cmVMaW1pdD1qcy5ERUZBVUxUX01JVFJFX0xJTUlULHRoaXMuX2lzU2luZ2xlU2lkZWQ9ITEsdGhpcy5fc2ltcGxpZnlGYWN0b3I9anMuREVGQVVMVF9TSU1QTElGWV9GQUNUT1IsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0UXVhZHJhbnRTZWdtZW50cyh0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnNldFF1YWRyYW50U2VnbWVudHModCksdGhpcy5zZXRFbmRDYXBTdHlsZShlKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTt0aGlzLnNldFF1YWRyYW50U2VnbWVudHModCksdGhpcy5zZXRFbmRDYXBTdHlsZShlKSx0aGlzLnNldEpvaW5TdHlsZShuKSx0aGlzLnNldE1pdHJlTGltaXQocyl9fSxqcy5DQVBfUk9VTkQ9MSxqcy5DQVBfRkxBVD0yLGpzLkNBUF9TUVVBUkU9Myxqcy5KT0lOX1JPVU5EPTEsanMuSk9JTl9NSVRSRT0yLGpzLkpPSU5fQkVWRUw9Myxqcy5ERUZBVUxUX1FVQURSQU5UX1NFR01FTlRTPTgsanMuREVGQVVMVF9NSVRSRV9MSU1JVD01LGpzLkRFRkFVTFRfU0lNUExJRllfRkFDVE9SPS4wMTtjbGFzcyBLc3tjb25zdHJ1Y3Rvcigpe0tzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9taW5Db29yZH1nZXRSaWdodG1vc3RTaWRlKHQsZSl7bGV0IG49dGhpcy5nZXRSaWdodG1vc3RTaWRlT2ZTZWdtZW50KHQsZSk7cmV0dXJuIG48MCYmKG49dGhpcy5nZXRSaWdodG1vc3RTaWRlT2ZTZWdtZW50KHQsZS0xKSksbjwwJiYodGhpcy5fbWluQ29vcmQ9bnVsbCx0aGlzLmNoZWNrRm9yUmlnaHRtb3N0Q29vcmRpbmF0ZSh0KSksbn1maW5kUmlnaHRtb3N0RWRnZUF0VmVydGV4KCl7Y29uc3QgdD10aGlzLl9taW5EZS5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKTt1LmlzVHJ1ZSh0aGlzLl9taW5JbmRleD4wJiZ0aGlzLl9taW5JbmRleDx0Lmxlbmd0aCxcInJpZ2h0bW9zdCBwb2ludCBleHBlY3RlZCB0byBiZSBpbnRlcmlvciB2ZXJ0ZXggb2YgZWRnZVwiKTtjb25zdCBlPXRbdGhpcy5fbWluSW5kZXgtMV0sbj10W3RoaXMuX21pbkluZGV4KzFdLHM9di5pbmRleCh0aGlzLl9taW5Db29yZCxuLGUpO2xldCBpPSExOyhlLnk8dGhpcy5fbWluQ29vcmQueSYmbi55PHRoaXMuX21pbkNvb3JkLnkmJnM9PT12LkNPVU5URVJDTE9DS1dJU0V8fGUueT50aGlzLl9taW5Db29yZC55JiZuLnk+dGhpcy5fbWluQ29vcmQueSYmcz09PXYuQ0xPQ0tXSVNFKSYmKGk9ITApLGkmJih0aGlzLl9taW5JbmRleD10aGlzLl9taW5JbmRleC0xKX1nZXRSaWdodG1vc3RTaWRlT2ZTZWdtZW50KHQsZSl7Y29uc3Qgbj10LmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpO2lmKGU8MHx8ZSsxPj1uLmxlbmd0aClyZXR1cm4tMTtpZihuW2VdLnk9PT1uW2UrMV0ueSlyZXR1cm4tMTtsZXQgcz1Qbi5MRUZUO3JldHVybiBuW2VdLnk8bltlKzFdLnkmJihzPVBuLlJJR0hUKSxzfWdldEVkZ2UoKXtyZXR1cm4gdGhpcy5fb3JpZW50ZWREZX1jaGVja0ZvclJpZ2h0bW9zdENvb3JkaW5hdGUodCl7Y29uc3QgZT10LmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGgtMTtuKyspKG51bGw9PT10aGlzLl9taW5Db29yZHx8ZVtuXS54PnRoaXMuX21pbkNvb3JkLngpJiYodGhpcy5fbWluRGU9dCx0aGlzLl9taW5JbmRleD1uLHRoaXMuX21pbkNvb3JkPWVbbl0pfWZpbmRSaWdodG1vc3RFZGdlQXROb2RlKCl7Y29uc3QgdD10aGlzLl9taW5EZS5nZXROb2RlKCkuZ2V0RWRnZXMoKTt0aGlzLl9taW5EZT10LmdldFJpZ2h0bW9zdEVkZ2UoKSx0aGlzLl9taW5EZS5pc0ZvcndhcmQoKXx8KHRoaXMuX21pbkRlPXRoaXMuX21pbkRlLmdldFN5bSgpLHRoaXMuX21pbkluZGV4PXRoaXMuX21pbkRlLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpLmxlbmd0aC0xKX1maW5kRWRnZSh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0LmlzRm9yd2FyZCgpJiZ0aGlzLmNoZWNrRm9yUmlnaHRtb3N0Q29vcmRpbmF0ZSh0KX11LmlzVHJ1ZSgwIT09dGhpcy5fbWluSW5kZXh8fHRoaXMuX21pbkNvb3JkLmVxdWFscyh0aGlzLl9taW5EZS5nZXRDb29yZGluYXRlKCkpLFwiaW5jb25zaXN0ZW5jeSBpbiByaWdodG1vc3QgcHJvY2Vzc2luZ1wiKSwwPT09dGhpcy5fbWluSW5kZXg/dGhpcy5maW5kUmlnaHRtb3N0RWRnZUF0Tm9kZSgpOnRoaXMuZmluZFJpZ2h0bW9zdEVkZ2VBdFZlcnRleCgpLHRoaXMuX29yaWVudGVkRGU9dGhpcy5fbWluRGUsdGhpcy5nZXRSaWdodG1vc3RTaWRlKHRoaXMuX21pbkRlLHRoaXMuX21pbkluZGV4KT09PVBuLkxFRlQmJih0aGlzLl9vcmllbnRlZERlPXRoaXMuX21pbkRlLmdldFN5bSgpKX1nZXRDbGFzcygpe3JldHVybiBLc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZnVuY3Rpb24gWnMoKXt0aGlzLmFycmF5Xz1bXX1Lcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9taW5JbmRleD0tMSx0aGlzLl9taW5Db29yZD1udWxsLHRoaXMuX21pbkRlPW51bGwsdGhpcy5fb3JpZW50ZWREZT1udWxsfSxacy5wcm90b3R5cGUuYWRkTGFzdD1mdW5jdGlvbih0KXt0aGlzLmFycmF5Xy5wdXNoKHQpfSxacy5wcm90b3R5cGUucmVtb3ZlRmlyc3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hcnJheV8uc2hpZnQoKX0sWnMucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuYXJyYXlfLmxlbmd0aH07Y2xhc3MgUXN7Y29uc3RydWN0b3IoKXtRcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNsZWFyVmlzaXRlZEVkZ2VzKCl7Zm9yKGxldCB0PXRoaXMuX2RpckVkZ2VMaXN0Lml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5zZXRWaXNpdGVkKCExKX19Z2V0UmlnaHRtb3N0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9yaWdodE1vc3RDb29yZH1jb21wdXRlTm9kZURlcHRoKHQpe2xldCBlPW51bGw7Zm9yKGxldCBuPXQuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtpZih0LmlzVmlzaXRlZCgpfHx0LmdldFN5bSgpLmlzVmlzaXRlZCgpKXtlPXQ7YnJlYWt9fWlmKG51bGw9PT1lKXRocm93IG5ldyBXbihcInVuYWJsZSB0byBmaW5kIGVkZ2UgdG8gY29tcHV0ZSBkZXB0aHMgYXQgXCIrdC5nZXRDb29yZGluYXRlKCkpO3QuZ2V0RWRnZXMoKS5jb21wdXRlRGVwdGhzKGUpO2ZvcihsZXQgZT10LmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dC5zZXRWaXNpdGVkKCEwKSx0aGlzLmNvcHlTeW1EZXB0aHModCl9fWNvbXB1dGVEZXB0aCh0KXt0aGlzLmNsZWFyVmlzaXRlZEVkZ2VzKCk7Y29uc3QgZT10aGlzLl9maW5kZXIuZ2V0RWRnZSgpO2UuZ2V0Tm9kZSgpLGUuZ2V0TGFiZWwoKTtlLnNldEVkZ2VEZXB0aHMoUG4uUklHSFQsdCksdGhpcy5jb3B5U3ltRGVwdGhzKGUpLHRoaXMuY29tcHV0ZURlcHRocyhlKX1jcmVhdGUodCl7dGhpcy5hZGRSZWFjaGFibGUodCksdGhpcy5fZmluZGVyLmZpbmRFZGdlKHRoaXMuX2RpckVkZ2VMaXN0KSx0aGlzLl9yaWdodE1vc3RDb29yZD10aGlzLl9maW5kZXIuZ2V0Q29vcmRpbmF0ZSgpfWZpbmRSZXN1bHRFZGdlcygpe2ZvcihsZXQgdD10aGlzLl9kaXJFZGdlTGlzdC5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtlLmdldERlcHRoKFBuLlJJR0hUKT49MSYmZS5nZXREZXB0aChQbi5MRUZUKTw9MCYmIWUuaXNJbnRlcmlvckFyZWFFZGdlKCkmJmUuc2V0SW5SZXN1bHQoITApfX1jb21wdXRlRGVwdGhzKHQpe2NvbnN0IGU9bmV3IEosbj1uZXcgWnMscz10LmdldE5vZGUoKTtmb3Iobi5hZGRMYXN0KHMpLGUuYWRkKHMpLHQuc2V0VmlzaXRlZCghMCk7IW4uaXNFbXB0eSgpOyl7Y29uc3QgdD1uLnJlbW92ZUZpcnN0KCk7ZS5hZGQodCksdGhpcy5jb21wdXRlTm9kZURlcHRoKHQpO2ZvcihsZXQgcz10LmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCkuZ2V0U3ltKCk7aWYodC5pc1Zpc2l0ZWQoKSljb250aW51ZTtjb25zdCBpPXQuZ2V0Tm9kZSgpO2UuY29udGFpbnMoaSl8fChuLmFkZExhc3QoaSksZS5hZGQoaSkpfX19Y29tcGFyZVRvKHQpe2NvbnN0IGU9dDtyZXR1cm4gdGhpcy5fcmlnaHRNb3N0Q29vcmQueDxlLl9yaWdodE1vc3RDb29yZC54Py0xOnRoaXMuX3JpZ2h0TW9zdENvb3JkLng+ZS5fcmlnaHRNb3N0Q29vcmQueD8xOjB9Z2V0RW52ZWxvcGUoKXtpZihudWxsPT09dGhpcy5fZW52KXtjb25zdCB0PW5ldyBOO2ZvcihsZXQgZT10aGlzLl9kaXJFZGdlTGlzdC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKS5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IGU9MDtlPG4ubGVuZ3RoLTE7ZSsrKXQuZXhwYW5kVG9JbmNsdWRlKG5bZV0pfXRoaXMuX2Vudj10fXJldHVybiB0aGlzLl9lbnZ9YWRkUmVhY2hhYmxlKHQpe2NvbnN0IGU9bmV3IG9uO2ZvcihlLmFkZCh0KTshZS5lbXB0eSgpOyl7Y29uc3QgdD1lLnBvcCgpO3RoaXMuYWRkKHQsZSl9fWNvcHlTeW1EZXB0aHModCl7Y29uc3QgZT10LmdldFN5bSgpO2Uuc2V0RGVwdGgoUG4uTEVGVCx0LmdldERlcHRoKFBuLlJJR0hUKSksZS5zZXREZXB0aChQbi5SSUdIVCx0LmdldERlcHRoKFBuLkxFRlQpKX1hZGQodCxlKXt0LnNldFZpc2l0ZWQoITApLHRoaXMuX25vZGVzLmFkZCh0KTtmb3IobGV0IG49dC5nZXRFZGdlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO3RoaXMuX2RpckVkZ2VMaXN0LmFkZCh0KTtjb25zdCBzPXQuZ2V0U3ltKCkuZ2V0Tm9kZSgpO3MuaXNWaXNpdGVkKCl8fGUucHVzaChzKX19Z2V0Tm9kZXMoKXtyZXR1cm4gdGhpcy5fbm9kZXN9Z2V0RGlyZWN0ZWRFZGdlcygpe3JldHVybiB0aGlzLl9kaXJFZGdlTGlzdH1nZXRDbGFzcygpe3JldHVybiBRc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bcl19fVFzLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2ZpbmRlcj1udWxsLHRoaXMuX2RpckVkZ2VMaXN0PW5ldyB4LHRoaXMuX25vZGVzPW5ldyB4LHRoaXMuX3JpZ2h0TW9zdENvb3JkPW51bGwsdGhpcy5fZW52PW51bGwsdGhpcy5fZmluZGVyPW5ldyBLc307Y2xhc3MgSnN7Y29uc3RydWN0b3IoKXtKcy5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNvbXB1dGVSaW5nKCl7aWYobnVsbCE9PXRoaXMuX3JpbmcpcmV0dXJuIG51bGw7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5fcHRzLnNpemUoKSkuZmlsbChudWxsKTtmb3IobGV0IGU9MDtlPHRoaXMuX3B0cy5zaXplKCk7ZSsrKXRbZV09dGhpcy5fcHRzLmdldChlKTt0aGlzLl9yaW5nPXRoaXMuX2dlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHQpLHRoaXMuX2lzSG9sZT12LmlzQ0NXKHRoaXMuX3JpbmcuZ2V0Q29vcmRpbmF0ZXMoKSl9aXNJc29sYXRlZCgpe3JldHVybiAxPT09dGhpcy5fbGFiZWwuZ2V0R2VvbWV0cnlDb3VudCgpfWNvbXB1dGVQb2ludHModCl7dGhpcy5fc3RhcnREZT10O2xldCBlPXQsbj0hMDtkb3tpZihudWxsPT09ZSl0aHJvdyBuZXcgV24oXCJGb3VuZCBudWxsIERpcmVjdGVkRWRnZVwiKTtpZihlLmdldEVkZ2VSaW5nKCk9PT10aGlzKXRocm93IG5ldyBXbihcIkRpcmVjdGVkIEVkZ2UgdmlzaXRlZCB0d2ljZSBkdXJpbmcgcmluZy1idWlsZGluZyBhdCBcIitlLmdldENvb3JkaW5hdGUoKSk7dGhpcy5fZWRnZXMuYWRkKGUpO2NvbnN0IHQ9ZS5nZXRMYWJlbCgpO3UuaXNUcnVlKHQuaXNBcmVhKCkpLHRoaXMubWVyZ2VMYWJlbCh0KSx0aGlzLmFkZFBvaW50cyhlLmdldEVkZ2UoKSxlLmlzRm9yd2FyZCgpLG4pLG49ITEsdGhpcy5zZXRFZGdlUmluZyhlLHRoaXMpLGU9dGhpcy5nZXROZXh0KGUpfXdoaWxlKGUhPT10aGlzLl9zdGFydERlKX1nZXRMaW5lYXJSaW5nKCl7cmV0dXJuIHRoaXMuX3Jpbmd9Z2V0Q29vcmRpbmF0ZSh0KXtyZXR1cm4gdGhpcy5fcHRzLmdldCh0KX1jb21wdXRlTWF4Tm9kZURlZ3JlZSgpe3RoaXMuX21heE5vZGVEZWdyZWU9MDtsZXQgdD10aGlzLl9zdGFydERlO2Rve2NvbnN0IGU9dC5nZXROb2RlKCkuZ2V0RWRnZXMoKS5nZXRPdXRnb2luZ0RlZ3JlZSh0aGlzKTtlPnRoaXMuX21heE5vZGVEZWdyZWUmJih0aGlzLl9tYXhOb2RlRGVncmVlPWUpLHQ9dGhpcy5nZXROZXh0KHQpfXdoaWxlKHQhPT10aGlzLl9zdGFydERlKTt0aGlzLl9tYXhOb2RlRGVncmVlKj0yfWFkZFBvaW50cyh0LGUsbil7Y29uc3Qgcz10LmdldENvb3JkaW5hdGVzKCk7aWYoZSl7bGV0IHQ9MTtuJiYodD0wKTtmb3IobGV0IGU9dDtlPHMubGVuZ3RoO2UrKyl0aGlzLl9wdHMuYWRkKHNbZV0pfWVsc2V7bGV0IHQ9cy5sZW5ndGgtMjtuJiYodD1zLmxlbmd0aC0xKTtmb3IobGV0IGU9dDtlPj0wO2UtLSl0aGlzLl9wdHMuYWRkKHNbZV0pfX1pc0hvbGUoKXtyZXR1cm4gdGhpcy5faXNIb2xlfXNldEluUmVzdWx0KCl7bGV0IHQ9dGhpcy5fc3RhcnREZTtkb3t0LmdldEVkZ2UoKS5zZXRJblJlc3VsdCghMCksdD10LmdldE5leHQoKX13aGlsZSh0IT09dGhpcy5fc3RhcnREZSl9Y29udGFpbnNQb2ludCh0KXtjb25zdCBlPXRoaXMuZ2V0TGluZWFyUmluZygpO2lmKCFlLmdldEVudmVsb3BlSW50ZXJuYWwoKS5jb250YWlucyh0KSlyZXR1cm4hMTtpZighV2UuaXNJblJpbmcodCxlLmdldENvb3JkaW5hdGVzKCkpKXJldHVybiExO2ZvcihsZXQgZT10aGlzLl9ob2xlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7aWYoZS5uZXh0KCkuY29udGFpbnNQb2ludCh0KSlyZXR1cm4hMX1yZXR1cm4hMH1hZGRIb2xlKHQpe3RoaXMuX2hvbGVzLmFkZCh0KX1pc1NoZWxsKCl7cmV0dXJuIG51bGw9PT10aGlzLl9zaGVsbH1nZXRMYWJlbCgpe3JldHVybiB0aGlzLl9sYWJlbH1nZXRFZGdlcygpe3JldHVybiB0aGlzLl9lZGdlc31nZXRNYXhOb2RlRGVncmVlKCl7cmV0dXJuIHRoaXMuX21heE5vZGVEZWdyZWU8MCYmdGhpcy5jb21wdXRlTWF4Tm9kZURlZ3JlZSgpLHRoaXMuX21heE5vZGVEZWdyZWV9Z2V0U2hlbGwoKXtyZXR1cm4gdGhpcy5fc2hlbGx9bWVyZ2VMYWJlbCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLm1lcmdlTGFiZWwodCwwKSx0aGlzLm1lcmdlTGFiZWwodCwxKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXQuZ2V0TG9jYXRpb24oZSxQbi5SSUdIVCk7aWYobj09PW5lLk5PTkUpcmV0dXJuIG51bGw7aWYodGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24oZSk9PT1uZS5OT05FKXJldHVybiB0aGlzLl9sYWJlbC5zZXRMb2NhdGlvbihlLG4pLG51bGx9fXNldFNoZWxsKHQpe3RoaXMuX3NoZWxsPXQsbnVsbCE9PXQmJnQuYWRkSG9sZSh0aGlzKX10b1BvbHlnb24odCl7Y29uc3QgZT1uZXcgQXJyYXkodGhpcy5faG9sZXMuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgdD0wO3Q8dGhpcy5faG9sZXMuc2l6ZSgpO3QrKyllW3RdPXRoaXMuX2hvbGVzLmdldCh0KS5nZXRMaW5lYXJSaW5nKCk7cmV0dXJuIHQuY3JlYXRlUG9seWdvbih0aGlzLmdldExpbmVhclJpbmcoKSxlKX1nZXRDbGFzcygpe3JldHVybiBKc31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19SnMuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fc3RhcnREZT1udWxsLHRoaXMuX21heE5vZGVEZWdyZWU9LTEsdGhpcy5fZWRnZXM9bmV3IHgsdGhpcy5fcHRzPW5ldyB4LHRoaXMuX2xhYmVsPW5ldyBGbihuZS5OT05FKSx0aGlzLl9yaW5nPW51bGwsdGhpcy5faXNIb2xlPW51bGwsdGhpcy5fc2hlbGw9bnVsbCx0aGlzLl9ob2xlcz1uZXcgeCx0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZ2VvbWV0cnlGYWN0b3J5PWUsdGhpcy5jb21wdXRlUG9pbnRzKHQpLHRoaXMuY29tcHV0ZVJpbmcoKX19O2NsYXNzICRzIGV4dGVuZHMgSnN7Y29uc3RydWN0b3IoKXtzdXBlcigpLCRzLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c2V0RWRnZVJpbmcodCxlKXt0LnNldE1pbkVkZ2VSaW5nKGUpfWdldE5leHQodCl7cmV0dXJuIHQuZ2V0TmV4dE1pbigpfWdldENsYXNzKCl7cmV0dXJuICRzfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX0kcy5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtKcy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSl9O2NsYXNzIHRpIGV4dGVuZHMgSnN7Y29uc3RydWN0b3IoKXtzdXBlcigpLHRpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9YnVpbGRNaW5pbWFsUmluZ3MoKXtjb25zdCB0PW5ldyB4O2xldCBlPXRoaXMuX3N0YXJ0RGU7ZG97aWYobnVsbD09PWUuZ2V0TWluRWRnZVJpbmcoKSl7Y29uc3Qgbj1uZXcgJHMoZSx0aGlzLl9nZW9tZXRyeUZhY3RvcnkpO3QuYWRkKG4pfWU9ZS5nZXROZXh0KCl9d2hpbGUoZSE9PXRoaXMuX3N0YXJ0RGUpO3JldHVybiB0fXNldEVkZ2VSaW5nKHQsZSl7dC5zZXRFZGdlUmluZyhlKX1saW5rRGlyZWN0ZWRFZGdlc0Zvck1pbmltYWxFZGdlUmluZ3MoKXtsZXQgdD10aGlzLl9zdGFydERlO2Rve3QuZ2V0Tm9kZSgpLmdldEVkZ2VzKCkubGlua01pbmltYWxEaXJlY3RlZEVkZ2VzKHRoaXMpLHQ9dC5nZXROZXh0KCl9d2hpbGUodCE9PXRoaXMuX3N0YXJ0RGUpfWdldE5leHQodCl7cmV0dXJuIHQuZ2V0TmV4dCgpfWdldENsYXNzKCl7cmV0dXJuIHRpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX10aS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtKcy5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSl9O2NsYXNzIGVpe2NvbnN0cnVjdG9yKCl7ZWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zb3J0U2hlbGxzQW5kSG9sZXModCxlLG4pe2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO3QuaXNIb2xlKCk/bi5hZGQodCk6ZS5hZGQodCl9fWNvbXB1dGVQb2x5Z29ucyh0KXtjb25zdCBlPW5ldyB4O2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpLnRvUG9seWdvbih0aGlzLl9nZW9tZXRyeUZhY3RvcnkpO2UuYWRkKHQpfXJldHVybiBlfXBsYWNlRnJlZUhvbGVzKHQsZSl7Zm9yKGxldCBuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IGU9bi5uZXh0KCk7aWYobnVsbD09PWUuZ2V0U2hlbGwoKSl7Y29uc3Qgbj10aGlzLmZpbmRFZGdlUmluZ0NvbnRhaW5pbmcoZSx0KTtpZihudWxsPT09bil0aHJvdyBuZXcgV24oXCJ1bmFibGUgdG8gYXNzaWduIGhvbGUgdG8gYSBzaGVsbFwiLGUuZ2V0Q29vcmRpbmF0ZSgwKSk7ZS5zZXRTaGVsbChuKX19fWJ1aWxkTWluaW1hbEVkZ2VSaW5ncyh0LGUsbil7Y29uc3Qgcz1uZXcgeDtmb3IobGV0IGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7Y29uc3QgdD1pLm5leHQoKTtpZih0LmdldE1heE5vZGVEZWdyZWUoKT4yKXt0LmxpbmtEaXJlY3RlZEVkZ2VzRm9yTWluaW1hbEVkZ2VSaW5ncygpO2NvbnN0IHM9dC5idWlsZE1pbmltYWxSaW5ncygpLGk9dGhpcy5maW5kU2hlbGwocyk7bnVsbCE9PWk/KHRoaXMucGxhY2VQb2x5Z29uSG9sZXMoaSxzKSxlLmFkZChpKSk6bi5hZGRBbGwocyl9ZWxzZSBzLmFkZCh0KX1yZXR1cm4gc31jb250YWluc1BvaW50KHQpe2ZvcihsZXQgZT10aGlzLl9zaGVsbExpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2lmKGUubmV4dCgpLmNvbnRhaW5zUG9pbnQodCkpcmV0dXJuITB9cmV0dXJuITF9YnVpbGRNYXhpbWFsRWRnZVJpbmdzKHQpe2NvbnN0IGU9bmV3IHg7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7aWYodC5pc0luUmVzdWx0KCkmJnQuZ2V0TGFiZWwoKS5pc0FyZWEoKSYmbnVsbD09PXQuZ2V0RWRnZVJpbmcoKSl7Y29uc3Qgbj1uZXcgdGkodCx0aGlzLl9nZW9tZXRyeUZhY3RvcnkpO2UuYWRkKG4pLG4uc2V0SW5SZXN1bHQoKX19cmV0dXJuIGV9cGxhY2VQb2x5Z29uSG9sZXModCxlKXtmb3IobGV0IG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgZT1uLm5leHQoKTtlLmlzSG9sZSgpJiZlLnNldFNoZWxsKHQpfX1nZXRQb2x5Z29ucygpe3JldHVybiB0aGlzLmNvbXB1dGVQb2x5Z29ucyh0aGlzLl9zaGVsbExpc3QpfWZpbmRFZGdlUmluZ0NvbnRhaW5pbmcodCxlKXtjb25zdCBuPXQuZ2V0TGluZWFyUmluZygpLHM9bi5nZXRFbnZlbG9wZUludGVybmFsKCksaT1uLmdldENvb3JkaW5hdGVOKDApO2xldCByPW51bGwsbz1udWxsO2ZvcihsZXQgdD1lLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49ZS5nZXRMaW5lYXJSaW5nKCksbD1uLmdldEVudmVsb3BlSW50ZXJuYWwoKTtudWxsIT09ciYmKG89ci5nZXRMaW5lYXJSaW5nKCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKTtsZXQgYT0hMTtsLmNvbnRhaW5zKHMpJiZXZS5pc0luUmluZyhpLG4uZ2V0Q29vcmRpbmF0ZXMoKSkmJihhPSEwKSxhJiYobnVsbD09PXJ8fG8uY29udGFpbnMobCkpJiYocj1lKX1yZXR1cm4gcn1maW5kU2hlbGwodCl7bGV0IGU9MCxuPW51bGw7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7dC5pc0hvbGUoKXx8KG49dCxlKyspfXJldHVybiB1LmlzVHJ1ZShlPD0xLFwiZm91bmQgdHdvIHNoZWxscyBpbiBNaW5pbWFsRWRnZVJpbmcgbGlzdFwiKSxufWFkZCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmFkZCh0LmdldEVkZ2VFbmRzKCksdC5nZXROb2RlcygpKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtabi5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcyhlKTtjb25zdCBuPXRoaXMuYnVpbGRNYXhpbWFsRWRnZVJpbmdzKHQpLHM9bmV3IHgsaT10aGlzLmJ1aWxkTWluaW1hbEVkZ2VSaW5ncyhuLHRoaXMuX3NoZWxsTGlzdCxzKTt0aGlzLnNvcnRTaGVsbHNBbmRIb2xlcyhpLHRoaXMuX3NoZWxsTGlzdCxzKSx0aGlzLnBsYWNlRnJlZUhvbGVzKHRoaXMuX3NoZWxsTGlzdCxzKX19Z2V0Q2xhc3MoKXtyZXR1cm4gZWl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWVpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2dlb21ldHJ5RmFjdG9yeT1udWxsLHRoaXMuX3NoZWxsTGlzdD1uZXcgeDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9dH07Y2xhc3Mgbml7Y29uc3RydWN0b3IoKXtuaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBzaW1wbGlmeSh0LGUpe3JldHVybiBuZXcgbmkodCkuc2ltcGxpZnkoZSl9aXNEZWxldGFibGUodCxlLG4scyl7Y29uc3QgaT10aGlzLl9pbnB1dExpbmVbdF0scj10aGlzLl9pbnB1dExpbmVbZV0sbz10aGlzLl9pbnB1dExpbmVbbl07cmV0dXJuISF0aGlzLmlzQ29uY2F2ZShpLHIsbykmJighIXRoaXMuaXNTaGFsbG93KGkscixvLHMpJiZ0aGlzLmlzU2hhbGxvd1NhbXBsZWQoaSxyLHQsbixzKSl9ZGVsZXRlU2hhbGxvd0NvbmNhdml0aWVzKCl7bGV0IHQ9MTt0aGlzLl9pbnB1dExpbmUubGVuZ3RoO2xldCBlPXRoaXMuZmluZE5leHROb25EZWxldGVkSW5kZXgodCksbj10aGlzLmZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KGUpLHM9ITE7Zm9yKDtuPHRoaXMuX2lucHV0TGluZS5sZW5ndGg7KXtsZXQgaT0hMTt0aGlzLmlzRGVsZXRhYmxlKHQsZSxuLHRoaXMuX2Rpc3RhbmNlVG9sKSYmKHRoaXMuX2lzRGVsZXRlZFtlXT1uaS5ERUxFVEUsaT0hMCxzPSEwKSx0PWk/bjplLGU9dGhpcy5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleCh0KSxuPXRoaXMuZmluZE5leHROb25EZWxldGVkSW5kZXgoZSl9cmV0dXJuIHN9aXNTaGFsbG93Q29uY2F2aXR5KHQsZSxuLHMpe3JldHVybiB2LmluZGV4KHQsZSxuKT09PXRoaXMuX2FuZ2xlT3JpZW50YXRpb24mJkQucG9pbnRUb1NlZ21lbnQoZSx0LG4pPHN9aXNTaGFsbG93U2FtcGxlZCh0LGUsbixzLGkpe2xldCByPU1hdGgudHJ1bmMoKHMtbikvbmkuTlVNX1BUU19UT19DSEVDSyk7cjw9MCYmKHI9MSk7Zm9yKGxldCBvPW47bzxzO28rPXIpaWYoIXRoaXMuaXNTaGFsbG93KHQsZSx0aGlzLl9pbnB1dExpbmVbb10saSkpcmV0dXJuITE7cmV0dXJuITB9aXNDb25jYXZlKHQsZSxuKXtyZXR1cm4gdi5pbmRleCh0LGUsbik9PT10aGlzLl9hbmdsZU9yaWVudGF0aW9ufXNpbXBsaWZ5KHQpe3RoaXMuX2Rpc3RhbmNlVG9sPU1hdGguYWJzKHQpLHQ8MCYmKHRoaXMuX2FuZ2xlT3JpZW50YXRpb249di5DTE9DS1dJU0UpLHRoaXMuX2lzRGVsZXRlZD1uZXcgQXJyYXkodGhpcy5faW5wdXRMaW5lLmxlbmd0aCkuZmlsbChudWxsKTtsZXQgZT0hMTtkb3tlPXRoaXMuZGVsZXRlU2hhbGxvd0NvbmNhdml0aWVzKCl9d2hpbGUoZSk7cmV0dXJuIHRoaXMuY29sbGFwc2VMaW5lKCl9ZmluZE5leHROb25EZWxldGVkSW5kZXgodCl7bGV0IGU9dCsxO2Zvcig7ZTx0aGlzLl9pbnB1dExpbmUubGVuZ3RoJiZ0aGlzLl9pc0RlbGV0ZWRbZV09PT1uaS5ERUxFVEU7KWUrKztyZXR1cm4gZX1pc1NoYWxsb3codCxlLG4scyl7cmV0dXJuIEQucG9pbnRUb1NlZ21lbnQoZSx0LG4pPHN9Y29sbGFwc2VMaW5lKCl7Y29uc3QgdD1uZXcgSTtmb3IobGV0IGU9MDtlPHRoaXMuX2lucHV0TGluZS5sZW5ndGg7ZSsrKXRoaXMuX2lzRGVsZXRlZFtlXSE9PW5pLkRFTEVURSYmdC5hZGQodGhpcy5faW5wdXRMaW5lW2VdKTtyZXR1cm4gdC50b0Nvb3JkaW5hdGVBcnJheSgpfWdldENsYXNzKCl7cmV0dXJuIG5pfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1uaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pbnB1dExpbmU9bnVsbCx0aGlzLl9kaXN0YW5jZVRvbD1udWxsLHRoaXMuX2lzRGVsZXRlZD1udWxsLHRoaXMuX2FuZ2xlT3JpZW50YXRpb249di5DT1VOVEVSQ0xPQ0tXSVNFO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2lucHV0TGluZT10fSxuaS5JTklUPTAsbmkuREVMRVRFPTEsbmkuS0VFUD0xLG5pLk5VTV9QVFNfVE9fQ0hFQ0s9MTA7Y2xhc3Mgc2l7Y29uc3RydWN0b3IoKXtzaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuX3B0TGlzdC50b0FycmF5KHNpLkNPT1JESU5BVEVfQVJSQVlfVFlQRSl9c2V0UHJlY2lzaW9uTW9kZWwodCl7dGhpcy5fcHJlY2lzaW9uTW9kZWw9dH1hZGRQdCh0KXtjb25zdCBlPW5ldyBnKHQpO2lmKHRoaXMuX3ByZWNpc2lvbk1vZGVsLm1ha2VQcmVjaXNlKGUpLHRoaXMuaXNSZWR1bmRhbnQoZSkpcmV0dXJuIG51bGw7dGhpcy5fcHRMaXN0LmFkZChlKX1yZXZlcnNlKCl7fWFkZFB0cyh0LGUpe2lmKGUpZm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspdGhpcy5hZGRQdCh0W2VdKTtlbHNlIGZvcihsZXQgZT10Lmxlbmd0aC0xO2U+PTA7ZS0tKXRoaXMuYWRkUHQodFtlXSl9aXNSZWR1bmRhbnQodCl7aWYodGhpcy5fcHRMaXN0LnNpemUoKTwxKXJldHVybiExO2NvbnN0IGU9dGhpcy5fcHRMaXN0LmdldCh0aGlzLl9wdExpc3Quc2l6ZSgpLTEpO3JldHVybiB0LmRpc3RhbmNlKGUpPHRoaXMuX21pbmltaW1WZXJ0ZXhEaXN0YW5jZX10b1N0cmluZygpe3JldHVybihuZXcgSHQpLmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5nZXRDb29yZGluYXRlcygpKS50b1N0cmluZygpfWNsb3NlUmluZygpe2lmKHRoaXMuX3B0TGlzdC5zaXplKCk8MSlyZXR1cm4gbnVsbDtjb25zdCB0PW5ldyBnKHRoaXMuX3B0TGlzdC5nZXQoMCkpLGU9dGhpcy5fcHRMaXN0LmdldCh0aGlzLl9wdExpc3Quc2l6ZSgpLTEpO2xldCBuPW51bGw7aWYodGhpcy5fcHRMaXN0LnNpemUoKT49MiYmdGhpcy5fcHRMaXN0LmdldCh0aGlzLl9wdExpc3Quc2l6ZSgpLTIpLHQuZXF1YWxzKGUpKXJldHVybiBudWxsO3RoaXMuX3B0TGlzdC5hZGQodCl9c2V0TWluaW11bVZlcnRleERpc3RhbmNlKHQpe3RoaXMuX21pbmltaW1WZXJ0ZXhEaXN0YW5jZT10fWdldENsYXNzKCl7cmV0dXJuIHNpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1zaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9wdExpc3Q9bnVsbCx0aGlzLl9wcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuX21pbmltaW1WZXJ0ZXhEaXN0YW5jZT0wLHRoaXMuX3B0TGlzdD1uZXcgeH0sc2kuQ09PUkRJTkFURV9BUlJBWV9UWVBFPW5ldyBBcnJheSgwKS5maWxsKG51bGwpO2NsYXNzIGlpe2NvbnN0cnVjdG9yKCl7aWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1hZGROZXh0U2VnbWVudCh0LGUpe2lmKHRoaXMuX3MwPXRoaXMuX3MxLHRoaXMuX3MxPXRoaXMuX3MyLHRoaXMuX3MyPXQsdGhpcy5fc2VnMC5zZXRDb29yZGluYXRlcyh0aGlzLl9zMCx0aGlzLl9zMSksdGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudCh0aGlzLl9zZWcwLHRoaXMuX3NpZGUsdGhpcy5fZGlzdGFuY2UsdGhpcy5fb2Zmc2V0MCksdGhpcy5fc2VnMS5zZXRDb29yZGluYXRlcyh0aGlzLl9zMSx0aGlzLl9zMiksdGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudCh0aGlzLl9zZWcxLHRoaXMuX3NpZGUsdGhpcy5fZGlzdGFuY2UsdGhpcy5fb2Zmc2V0MSksdGhpcy5fczEuZXF1YWxzKHRoaXMuX3MyKSlyZXR1cm4gbnVsbDtjb25zdCBuPXYuaW5kZXgodGhpcy5fczAsdGhpcy5fczEsdGhpcy5fczIpLHM9bj09PXYuQ0xPQ0tXSVNFJiZ0aGlzLl9zaWRlPT09UG4uTEVGVHx8bj09PXYuQ09VTlRFUkNMT0NLV0lTRSYmdGhpcy5fc2lkZT09PVBuLlJJR0hUOzA9PT1uP3RoaXMuYWRkQ29sbGluZWFyKGUpOnM/dGhpcy5hZGRPdXRzaWRlVHVybihuLGUpOnRoaXMuYWRkSW5zaWRlVHVybihuLGUpfWFkZExpbmVFbmRDYXAodCxlKXtjb25zdCBuPW5ldyBlZSh0LGUpLHM9bmV3IGVlO3RoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQobixQbi5MRUZULHRoaXMuX2Rpc3RhbmNlLHMpO2NvbnN0IGk9bmV3IGVlO3RoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQobixQbi5SSUdIVCx0aGlzLl9kaXN0YW5jZSxpKTtjb25zdCByPWUueC10Lngsbz1lLnktdC55LGw9TWF0aC5hdGFuMihvLHIpO3N3aXRjaCh0aGlzLl9idWZQYXJhbXMuZ2V0RW5kQ2FwU3R5bGUoKSl7Y2FzZSBqcy5DQVBfUk9VTkQ6dGhpcy5fc2VnTGlzdC5hZGRQdChzLnAxKSx0aGlzLmFkZERpcmVjdGVkRmlsbGV0KGUsbCtNYXRoLlBJLzIsbC1NYXRoLlBJLzIsdi5DTE9DS1dJU0UsdGhpcy5fZGlzdGFuY2UpLHRoaXMuX3NlZ0xpc3QuYWRkUHQoaS5wMSk7YnJlYWs7Y2FzZSBqcy5DQVBfRkxBVDp0aGlzLl9zZWdMaXN0LmFkZFB0KHMucDEpLHRoaXMuX3NlZ0xpc3QuYWRkUHQoaS5wMSk7YnJlYWs7Y2FzZSBqcy5DQVBfU1FVQVJFOmNvbnN0IHQ9bmV3IGc7dC54PU1hdGguYWJzKHRoaXMuX2Rpc3RhbmNlKSpNYXRoLmNvcyhsKSx0Lnk9TWF0aC5hYnModGhpcy5fZGlzdGFuY2UpKk1hdGguc2luKGwpO2NvbnN0IG49bmV3IGcocy5wMS54K3QueCxzLnAxLnkrdC55KSxyPW5ldyBnKGkucDEueCt0LngsaS5wMS55K3QueSk7dGhpcy5fc2VnTGlzdC5hZGRQdChuKSx0aGlzLl9zZWdMaXN0LmFkZFB0KHIpfX1nZXRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLl9zZWdMaXN0LmdldENvb3JkaW5hdGVzKCl9YWRkTWl0cmVKb2luKHQsZSxuLHMpe2xldCBpPSEwLHI9bnVsbDt0cnl7cj1iLmludGVyc2VjdGlvbihlLnAwLGUucDEsbi5wMCxuLnAxKSwoczw9MD8xOnIuZGlzdGFuY2UodCkvTWF0aC5hYnMocykpPnRoaXMuX2J1ZlBhcmFtcy5nZXRNaXRyZUxpbWl0KCkmJihpPSExKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBTKSl0aHJvdyB0O3I9bmV3IGcoMCwwKSxpPSExfWk/dGhpcy5fc2VnTGlzdC5hZGRQdChyKTp0aGlzLmFkZExpbWl0ZWRNaXRyZUpvaW4oZSxuLHMsdGhpcy5fYnVmUGFyYW1zLmdldE1pdHJlTGltaXQoKSl9YWRkT3V0c2lkZVR1cm4odCxlKXtpZih0aGlzLl9vZmZzZXQwLnAxLmRpc3RhbmNlKHRoaXMuX29mZnNldDEucDApPHRoaXMuX2Rpc3RhbmNlKmlpLk9GRlNFVF9TRUdNRU5UX1NFUEFSQVRJT05fRkFDVE9SKXJldHVybiB0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDAucDEpLG51bGw7dGhpcy5fYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpPT09anMuSk9JTl9NSVRSRT90aGlzLmFkZE1pdHJlSm9pbih0aGlzLl9zMSx0aGlzLl9vZmZzZXQwLHRoaXMuX29mZnNldDEsdGhpcy5fZGlzdGFuY2UpOnRoaXMuX2J1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKT09PWpzLkpPSU5fQkVWRUw/dGhpcy5hZGRCZXZlbEpvaW4odGhpcy5fb2Zmc2V0MCx0aGlzLl9vZmZzZXQxKTooZSYmdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQwLnAxKSx0aGlzLmFkZENvcm5lckZpbGxldCh0aGlzLl9zMSx0aGlzLl9vZmZzZXQwLnAxLHRoaXMuX29mZnNldDEucDAsdCx0aGlzLl9kaXN0YW5jZSksdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQxLnAwKSl9Y3JlYXRlU3F1YXJlKHQpe3RoaXMuX3NlZ0xpc3QuYWRkUHQobmV3IGcodC54K3RoaXMuX2Rpc3RhbmNlLHQueSt0aGlzLl9kaXN0YW5jZSkpLHRoaXMuX3NlZ0xpc3QuYWRkUHQobmV3IGcodC54K3RoaXMuX2Rpc3RhbmNlLHQueS10aGlzLl9kaXN0YW5jZSkpLHRoaXMuX3NlZ0xpc3QuYWRkUHQobmV3IGcodC54LXRoaXMuX2Rpc3RhbmNlLHQueS10aGlzLl9kaXN0YW5jZSkpLHRoaXMuX3NlZ0xpc3QuYWRkUHQobmV3IGcodC54LXRoaXMuX2Rpc3RhbmNlLHQueSt0aGlzLl9kaXN0YW5jZSkpLHRoaXMuX3NlZ0xpc3QuY2xvc2VSaW5nKCl9YWRkU2VnbWVudHModCxlKXt0aGlzLl9zZWdMaXN0LmFkZFB0cyh0LGUpfWFkZEZpcnN0U2VnbWVudCgpe3RoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MS5wMCl9YWRkQ29ybmVyRmlsbGV0KHQsZSxuLHMsaSl7Y29uc3Qgcj1lLngtdC54LG89ZS55LXQueTtsZXQgbD1NYXRoLmF0YW4yKG8scik7Y29uc3QgYT1uLngtdC54LGM9bi55LXQueSxoPU1hdGguYXRhbjIoYyxhKTtzPT09di5DTE9DS1dJU0U/bDw9aCYmKGwrPTIqTWF0aC5QSSk6bD49aCYmKGwtPTIqTWF0aC5QSSksdGhpcy5fc2VnTGlzdC5hZGRQdChlKSx0aGlzLmFkZERpcmVjdGVkRmlsbGV0KHQsbCxoLHMsaSksdGhpcy5fc2VnTGlzdC5hZGRQdChuKX1hZGRMYXN0U2VnbWVudCgpe3RoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MS5wMSl9aW5pdFNpZGVTZWdtZW50cyh0LGUsbil7dGhpcy5fczE9dCx0aGlzLl9zMj1lLHRoaXMuX3NpZGU9bix0aGlzLl9zZWcxLnNldENvb3JkaW5hdGVzKHQsZSksdGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudCh0aGlzLl9zZWcxLG4sdGhpcy5fZGlzdGFuY2UsdGhpcy5fb2Zmc2V0MSl9YWRkTGltaXRlZE1pdHJlSm9pbih0LGUsbixzKXtjb25zdCBpPXRoaXMuX3NlZzAucDEscj1pZS5hbmdsZShpLHRoaXMuX3NlZzAucDApLG89KGllLmFuZ2xlKGksdGhpcy5fc2VnMS5wMSksaWUuYW5nbGVCZXR3ZWVuT3JpZW50ZWQodGhpcy5fc2VnMC5wMCxpLHRoaXMuX3NlZzEucDEpLzIpLGw9aWUubm9ybWFsaXplKHIrbyksYT1pZS5ub3JtYWxpemUobCtNYXRoLlBJKSxjPXMqbixoPW4tYypNYXRoLmFicyhNYXRoLnNpbihvKSksdT1pLngrYypNYXRoLmNvcyhhKSxkPWkueStjKk1hdGguc2luKGEpLF89bmV3IGcodSxkKSxmPW5ldyBlZShpLF8pLHA9Zi5wb2ludEFsb25nT2Zmc2V0KDEsaCksbT1mLnBvaW50QWxvbmdPZmZzZXQoMSwtaCk7dGhpcy5fc2lkZT09PVBuLkxFRlQ/KHRoaXMuX3NlZ0xpc3QuYWRkUHQocCksdGhpcy5fc2VnTGlzdC5hZGRQdChtKSk6KHRoaXMuX3NlZ0xpc3QuYWRkUHQobSksdGhpcy5fc2VnTGlzdC5hZGRQdChwKSl9YWRkRGlyZWN0ZWRGaWxsZXQodCxlLG4scyxpKXtjb25zdCByPXM9PT12LkNMT0NLV0lTRT8tMToxLG89TWF0aC5hYnMoZS1uKSxsPU1hdGgudHJ1bmMoby90aGlzLl9maWxsZXRBbmdsZVF1YW50dW0rLjUpO2lmKGw8MSlyZXR1cm4gbnVsbDtsZXQgYT1udWxsLGM9bnVsbDthPTAsYz1vL2w7bGV0IGg9MDtjb25zdCB1PW5ldyBnO2Zvcig7aDxvOyl7Y29uc3Qgbj1lK3IqaDt1Lng9dC54K2kqTWF0aC5jb3MobiksdS55PXQueStpKk1hdGguc2luKG4pLHRoaXMuX3NlZ0xpc3QuYWRkUHQodSksaCs9Y319Y29tcHV0ZU9mZnNldFNlZ21lbnQodCxlLG4scyl7Y29uc3QgaT1lPT09UG4uTEVGVD8xOi0xLHI9dC5wMS54LXQucDAueCxvPXQucDEueS10LnAwLnksbD1NYXRoLnNxcnQocipyK28qbyksYT1pKm4qci9sLGM9aSpuKm8vbDtzLnAwLng9dC5wMC54LWMscy5wMC55PXQucDAueSthLHMucDEueD10LnAxLngtYyxzLnAxLnk9dC5wMS55K2F9YWRkSW5zaWRlVHVybih0LGUpe2lmKHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odGhpcy5fb2Zmc2V0MC5wMCx0aGlzLl9vZmZzZXQwLnAxLHRoaXMuX29mZnNldDEucDAsdGhpcy5fb2Zmc2V0MS5wMSksdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkpdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9saS5nZXRJbnRlcnNlY3Rpb24oMCkpO2Vsc2UgaWYodGhpcy5faGFzTmFycm93Q29uY2F2ZUFuZ2xlPSEwLHRoaXMuX29mZnNldDAucDEuZGlzdGFuY2UodGhpcy5fb2Zmc2V0MS5wMCk8dGhpcy5fZGlzdGFuY2UqaWkuSU5TSURFX1RVUk5fVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SKXRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MC5wMSk7ZWxzZXtpZih0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDAucDEpLHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3I+MCl7Y29uc3QgdD1uZXcgZygodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcip0aGlzLl9vZmZzZXQwLnAxLngrdGhpcy5fczEueCkvKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IrMSksKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IqdGhpcy5fb2Zmc2V0MC5wMS55K3RoaXMuX3MxLnkpLyh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKzEpKTt0aGlzLl9zZWdMaXN0LmFkZFB0KHQpO2NvbnN0IGU9bmV3IGcoKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IqdGhpcy5fb2Zmc2V0MS5wMC54K3RoaXMuX3MxLngpLyh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKzEpLCh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKnRoaXMuX29mZnNldDEucDAueSt0aGlzLl9zMS55KS8odGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvcisxKSk7dGhpcy5fc2VnTGlzdC5hZGRQdChlKX1lbHNlIHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fczEpO3RoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MS5wMCl9fWNyZWF0ZUNpcmNsZSh0KXtjb25zdCBlPW5ldyBnKHQueCt0aGlzLl9kaXN0YW5jZSx0LnkpO3RoaXMuX3NlZ0xpc3QuYWRkUHQoZSksdGhpcy5hZGREaXJlY3RlZEZpbGxldCh0LDAsMipNYXRoLlBJLC0xLHRoaXMuX2Rpc3RhbmNlKSx0aGlzLl9zZWdMaXN0LmNsb3NlUmluZygpfWFkZEJldmVsSm9pbih0LGUpe3RoaXMuX3NlZ0xpc3QuYWRkUHQodC5wMSksdGhpcy5fc2VnTGlzdC5hZGRQdChlLnAwKX1pbml0KHQpe3RoaXMuX2Rpc3RhbmNlPXQsdGhpcy5fbWF4Q3VydmVTZWdtZW50RXJyb3I9dCooMS1NYXRoLmNvcyh0aGlzLl9maWxsZXRBbmdsZVF1YW50dW0vMikpLHRoaXMuX3NlZ0xpc3Q9bmV3IHNpLHRoaXMuX3NlZ0xpc3Quc2V0UHJlY2lzaW9uTW9kZWwodGhpcy5fcHJlY2lzaW9uTW9kZWwpLHRoaXMuX3NlZ0xpc3Quc2V0TWluaW11bVZlcnRleERpc3RhbmNlKHQqaWkuQ1VSVkVfVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SKX1hZGRDb2xsaW5lYXIodCl7dGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0aGlzLl9zMCx0aGlzLl9zMSx0aGlzLl9zMSx0aGlzLl9zMiksdGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCk+PTImJih0aGlzLl9idWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCk9PT1qcy5KT0lOX0JFVkVMfHx0aGlzLl9idWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCk9PT1qcy5KT0lOX01JVFJFPyh0JiZ0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDAucDEpLHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MS5wMCkpOnRoaXMuYWRkQ29ybmVyRmlsbGV0KHRoaXMuX3MxLHRoaXMuX29mZnNldDAucDEsdGhpcy5fb2Zmc2V0MS5wMCx2LkNMT0NLV0lTRSx0aGlzLl9kaXN0YW5jZSkpfWNsb3NlUmluZygpe3RoaXMuX3NlZ0xpc3QuY2xvc2VSaW5nKCl9aGFzTmFycm93Q29uY2F2ZUFuZ2xlKCl7cmV0dXJuIHRoaXMuX2hhc05hcnJvd0NvbmNhdmVBbmdsZX1nZXRDbGFzcygpe3JldHVybiBpaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19aWkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbWF4Q3VydmVTZWdtZW50RXJyb3I9MCx0aGlzLl9maWxsZXRBbmdsZVF1YW50dW09bnVsbCx0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yPTEsdGhpcy5fc2VnTGlzdD1udWxsLHRoaXMuX2Rpc3RhbmNlPTAsdGhpcy5fcHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLl9idWZQYXJhbXM9bnVsbCx0aGlzLl9saT1udWxsLHRoaXMuX3MwPW51bGwsdGhpcy5fczE9bnVsbCx0aGlzLl9zMj1udWxsLHRoaXMuX3NlZzA9bmV3IGVlLHRoaXMuX3NlZzE9bmV3IGVlLHRoaXMuX29mZnNldDA9bmV3IGVlLHRoaXMuX29mZnNldDE9bmV3IGVlLHRoaXMuX3NpZGU9MCx0aGlzLl9oYXNOYXJyb3dDb25jYXZlQW5nbGU9ITE7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fcHJlY2lzaW9uTW9kZWw9dCx0aGlzLl9idWZQYXJhbXM9ZSx0aGlzLl9saT1uZXcgdGUsdGhpcy5fZmlsbGV0QW5nbGVRdWFudHVtPU1hdGguUEkvMi9lLmdldFF1YWRyYW50U2VnbWVudHMoKSxlLmdldFF1YWRyYW50U2VnbWVudHMoKT49OCYmZS5nZXRKb2luU3R5bGUoKT09PWpzLkpPSU5fUk9VTkQmJih0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yPWlpLk1BWF9DTE9TSU5HX1NFR19MRU5fRkFDVE9SKSx0aGlzLmluaXQobil9LGlpLk9GRlNFVF9TRUdNRU5UX1NFUEFSQVRJT05fRkFDVE9SPS4wMDEsaWkuSU5TSURFX1RVUk5fVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SPS4wMDEsaWkuQ1VSVkVfVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SPTFlLTYsaWkuTUFYX0NMT1NJTkdfU0VHX0xFTl9GQUNUT1I9ODA7Y2xhc3Mgcml7Y29uc3RydWN0b3IoKXtyaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb3B5Q29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspZVtuXT1uZXcgZyh0W25dKTtyZXR1cm4gZX1nZXRPZmZzZXRDdXJ2ZSh0LGUpe2lmKHRoaXMuX2Rpc3RhbmNlPWUsMD09PWUpcmV0dXJuIG51bGw7Y29uc3Qgbj1lPDAscz1NYXRoLmFicyhlKSxpPXRoaXMuZ2V0U2VnR2VuKHMpO3QubGVuZ3RoPD0xP3RoaXMuY29tcHV0ZVBvaW50Q3VydmUodFswXSxpKTp0aGlzLmNvbXB1dGVPZmZzZXRDdXJ2ZSh0LG4saSk7Y29uc3Qgcj1pLmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIG4mJlgucmV2ZXJzZShyKSxyfWNvbXB1dGVTaW5nbGVTaWRlZEJ1ZmZlckN1cnZlKHQsZSxuKXtjb25zdCBzPXRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5fZGlzdGFuY2UpO2lmKGUpe24uYWRkU2VnbWVudHModCwhMCk7Y29uc3QgZT1uaS5zaW1wbGlmeSh0LC1zKSxpPWUubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKGVbaV0sZVtpLTFdLFBuLkxFRlQpLG4uYWRkRmlyc3RTZWdtZW50KCk7Zm9yKGxldCB0PWktMjt0Pj0wO3QtLSluLmFkZE5leHRTZWdtZW50KGVbdF0sITApfWVsc2V7bi5hZGRTZWdtZW50cyh0LCExKTtjb25zdCBlPW5pLnNpbXBsaWZ5KHQscyksaT1lLmxlbmd0aC0xO24uaW5pdFNpZGVTZWdtZW50cyhlWzBdLGVbMV0sUG4uTEVGVCksbi5hZGRGaXJzdFNlZ21lbnQoKTtmb3IobGV0IHQ9Mjt0PD1pO3QrKyluLmFkZE5leHRTZWdtZW50KGVbdF0sITApfW4uYWRkTGFzdFNlZ21lbnQoKSxuLmNsb3NlUmluZygpfWNvbXB1dGVSaW5nQnVmZmVyQ3VydmUodCxlLG4pe2xldCBzPXRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5fZGlzdGFuY2UpO2U9PT1Qbi5SSUdIVCYmKHM9LXMpO2NvbnN0IGk9bmkuc2ltcGxpZnkodCxzKSxyPWkubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKGlbci0xXSxpWzBdLGUpO2ZvcihsZXQgdD0xO3Q8PXI7dCsrKXtjb25zdCBlPTEhPT10O24uYWRkTmV4dFNlZ21lbnQoaVt0XSxlKX1uLmNsb3NlUmluZygpfWNvbXB1dGVMaW5lQnVmZmVyQ3VydmUodCxlKXtjb25zdCBuPXRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5fZGlzdGFuY2UpLHM9bmkuc2ltcGxpZnkodCxuKSxpPXMubGVuZ3RoLTE7ZS5pbml0U2lkZVNlZ21lbnRzKHNbMF0sc1sxXSxQbi5MRUZUKTtmb3IobGV0IHQ9Mjt0PD1pO3QrKyllLmFkZE5leHRTZWdtZW50KHNbdF0sITApO2UuYWRkTGFzdFNlZ21lbnQoKSxlLmFkZExpbmVFbmRDYXAoc1tpLTFdLHNbaV0pO2NvbnN0IHI9bmkuc2ltcGxpZnkodCwtbiksbz1yLmxlbmd0aC0xO2UuaW5pdFNpZGVTZWdtZW50cyhyW29dLHJbby0xXSxQbi5MRUZUKTtmb3IobGV0IHQ9by0yO3Q+PTA7dC0tKWUuYWRkTmV4dFNlZ21lbnQoclt0XSwhMCk7ZS5hZGRMYXN0U2VnbWVudCgpLGUuYWRkTGluZUVuZENhcChyWzFdLHJbMF0pLGUuY2xvc2VSaW5nKCl9Y29tcHV0ZVBvaW50Q3VydmUodCxlKXtzd2l0Y2godGhpcy5fYnVmUGFyYW1zLmdldEVuZENhcFN0eWxlKCkpe2Nhc2UganMuQ0FQX1JPVU5EOmUuY3JlYXRlQ2lyY2xlKHQpO2JyZWFrO2Nhc2UganMuQ0FQX1NRVUFSRTplLmNyZWF0ZVNxdWFyZSh0KX19Z2V0TGluZUN1cnZlKHQsZSl7aWYodGhpcy5fZGlzdGFuY2U9ZSxlPDAmJiF0aGlzLl9idWZQYXJhbXMuaXNTaW5nbGVTaWRlZCgpKXJldHVybiBudWxsO2lmKDA9PT1lKXJldHVybiBudWxsO2NvbnN0IG49TWF0aC5hYnMoZSkscz10aGlzLmdldFNlZ0dlbihuKTtpZih0Lmxlbmd0aDw9MSl0aGlzLmNvbXB1dGVQb2ludEN1cnZlKHRbMF0scyk7ZWxzZSBpZih0aGlzLl9idWZQYXJhbXMuaXNTaW5nbGVTaWRlZCgpKXtjb25zdCBuPWU8MDt0aGlzLmNvbXB1dGVTaW5nbGVTaWRlZEJ1ZmZlckN1cnZlKHQsbixzKX1lbHNlIHRoaXMuY29tcHV0ZUxpbmVCdWZmZXJDdXJ2ZSh0LHMpO3JldHVybiBzLmdldENvb3JkaW5hdGVzKCl9Z2V0QnVmZmVyUGFyYW1ldGVycygpe3JldHVybiB0aGlzLl9idWZQYXJhbXN9c2ltcGxpZnlUb2xlcmFuY2UodCl7cmV0dXJuIHQqdGhpcy5fYnVmUGFyYW1zLmdldFNpbXBsaWZ5RmFjdG9yKCl9Z2V0UmluZ0N1cnZlKHQsZSxuKXtpZih0aGlzLl9kaXN0YW5jZT1uLHQubGVuZ3RoPD0yKXJldHVybiB0aGlzLmdldExpbmVDdXJ2ZSh0LG4pO2lmKDA9PT1uKXJldHVybiByaS5jb3B5Q29vcmRpbmF0ZXModCk7Y29uc3Qgcz10aGlzLmdldFNlZ0dlbihuKTtyZXR1cm4gdGhpcy5jb21wdXRlUmluZ0J1ZmZlckN1cnZlKHQsZSxzKSxzLmdldENvb3JkaW5hdGVzKCl9Y29tcHV0ZU9mZnNldEN1cnZlKHQsZSxuKXtjb25zdCBzPXRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5fZGlzdGFuY2UpO2lmKGUpe2NvbnN0IGU9bmkuc2ltcGxpZnkodCwtcyksaT1lLmxlbmd0aC0xO24uaW5pdFNpZGVTZWdtZW50cyhlW2ldLGVbaS0xXSxQbi5MRUZUKSxuLmFkZEZpcnN0U2VnbWVudCgpO2ZvcihsZXQgdD1pLTI7dD49MDt0LS0pbi5hZGROZXh0U2VnbWVudChlW3RdLCEwKX1lbHNle2NvbnN0IGU9bmkuc2ltcGxpZnkodCxzKSxpPWUubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKGVbMF0sZVsxXSxQbi5MRUZUKSxuLmFkZEZpcnN0U2VnbWVudCgpO2ZvcihsZXQgdD0yO3Q8PWk7dCsrKW4uYWRkTmV4dFNlZ21lbnQoZVt0XSwhMCl9bi5hZGRMYXN0U2VnbWVudCgpfWdldFNlZ0dlbih0KXtyZXR1cm4gbmV3IGlpKHRoaXMuX3ByZWNpc2lvbk1vZGVsLHRoaXMuX2J1ZlBhcmFtcyx0KX1nZXRDbGFzcygpe3JldHVybiByaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19cmkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZGlzdGFuY2U9MCx0aGlzLl9wcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuX2J1ZlBhcmFtcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3ByZWNpc2lvbk1vZGVsPXQsdGhpcy5fYnVmUGFyYW1zPWV9O2NsYXNzIG9pe2NvbnN0cnVjdG9yKCl7b2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maW5kU3RhYmJlZFNlZ21lbnRzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9bmV3IHg7Zm9yKGxldCBuPXRoaXMuX3N1YmdyYXBocy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKSxpPXMuZ2V0RW52ZWxvcGUoKTt0Lnk8aS5nZXRNaW5ZKCl8fHQueT5pLmdldE1heFkoKXx8dGhpcy5maW5kU3RhYmJlZFNlZ21lbnRzKHQscy5nZXREaXJlY3RlZEVkZ2VzKCksZSl9cmV0dXJuIGV9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpaWYoXyhhcmd1bWVudHNbMl0sbSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBqbil7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1lLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgaT0wO2k8cy5sZW5ndGgtMTtpKyspe2lmKHRoaXMuX3NlZy5wMD1zW2ldLHRoaXMuX3NlZy5wMT1zW2krMV0sdGhpcy5fc2VnLnAwLnk+dGhpcy5fc2VnLnAxLnkmJnRoaXMuX3NlZy5yZXZlcnNlKCksTWF0aC5tYXgodGhpcy5fc2VnLnAwLngsdGhpcy5fc2VnLnAxLngpPHQueCljb250aW51ZTtpZih0aGlzLl9zZWcuaXNIb3Jpem9udGFsKCkpY29udGludWU7aWYodC55PHRoaXMuX3NlZy5wMC55fHx0Lnk+dGhpcy5fc2VnLnAxLnkpY29udGludWU7aWYodi5pbmRleCh0aGlzLl9zZWcucDAsdGhpcy5fc2VnLnAxLHQpPT09di5SSUdIVCljb250aW51ZTtsZXQgcj1lLmdldERlcHRoKFBuLkxFRlQpO3RoaXMuX3NlZy5wMC5lcXVhbHMoc1tpXSl8fChyPWUuZ2V0RGVwdGgoUG4uUklHSFQpKTtjb25zdCBvPW5ldyBsaSh0aGlzLl9zZWcscik7bi5hZGQobyl9fWVsc2UgaWYoXyhhcmd1bWVudHNbMl0sbSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmXyhhcmd1bWVudHNbMV0sbSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2ZvcihsZXQgcz1lLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCBlPXMubmV4dCgpO2UuaXNGb3J3YXJkKCkmJnRoaXMuZmluZFN0YWJiZWRTZWdtZW50cyh0LGUsbil9fX1nZXREZXB0aCh0KXtjb25zdCBlPXRoaXMuZmluZFN0YWJiZWRTZWdtZW50cyh0KTtyZXR1cm4gMD09PWUuc2l6ZSgpPzA6RWUubWluKGUpLl9sZWZ0RGVwdGh9Z2V0Q2xhc3MoKXtyZXR1cm4gb2l9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIGxpe2NvbnN0cnVjdG9yKCl7bGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jb21wYXJlVG8odCl7Y29uc3QgZT10O2lmKHRoaXMuX3Vwd2FyZFNlZy5taW5YKCk+PWUuX3Vwd2FyZFNlZy5tYXhYKCkpcmV0dXJuIDE7aWYodGhpcy5fdXB3YXJkU2VnLm1heFgoKTw9ZS5fdXB3YXJkU2VnLm1pblgoKSlyZXR1cm4tMTtsZXQgbj10aGlzLl91cHdhcmRTZWcub3JpZW50YXRpb25JbmRleChlLl91cHdhcmRTZWcpO3JldHVybiAwIT09bj9uOihuPS0xKmUuX3Vwd2FyZFNlZy5vcmllbnRhdGlvbkluZGV4KHRoaXMuX3Vwd2FyZFNlZyksMCE9PW4/bjp0aGlzLl91cHdhcmRTZWcuY29tcGFyZVRvKGUuX3Vwd2FyZFNlZykpfWNvbXBhcmVYKHQsZSl7Y29uc3Qgbj10LnAwLmNvbXBhcmVUbyhlLnAwKTtyZXR1cm4gMCE9PW4/bjp0LnAxLmNvbXBhcmVUbyhlLnAxKX10b1N0cmluZygpe3JldHVybiB0aGlzLl91cHdhcmRTZWcudG9TdHJpbmcoKX1nZXRDbGFzcygpe3JldHVybiBsaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bcl19fWxpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3Vwd2FyZFNlZz1udWxsLHRoaXMuX2xlZnREZXB0aD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3Vwd2FyZFNlZz1uZXcgZWUodCksdGhpcy5fbGVmdERlcHRoPWV9LG9pLkRlcHRoU2VnbWVudD1saSxvaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9zdWJncmFwaHM9bnVsbCx0aGlzLl9zZWc9bmV3IGVlO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3N1YmdyYXBocz10fTtjbGFzcyBhaXtjb25zdHJ1Y3Rvcigpe2FpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9YWRkUG9pbnQodCl7aWYodGhpcy5fZGlzdGFuY2U8PTApcmV0dXJuIG51bGw7Y29uc3QgZT10LmdldENvb3JkaW5hdGVzKCksbj10aGlzLl9jdXJ2ZUJ1aWxkZXIuZ2V0TGluZUN1cnZlKGUsdGhpcy5fZGlzdGFuY2UpO3RoaXMuYWRkQ3VydmUobixuZS5FWFRFUklPUixuZS5JTlRFUklPUil9YWRkUG9seWdvbih0KXtsZXQgZT10aGlzLl9kaXN0YW5jZSxuPVBuLkxFRlQ7dGhpcy5fZGlzdGFuY2U8MCYmKGU9LXRoaXMuX2Rpc3RhbmNlLG49UG4uUklHSFQpO2NvbnN0IHM9dC5nZXRFeHRlcmlvclJpbmcoKSxpPVgucmVtb3ZlUmVwZWF0ZWRQb2ludHMocy5nZXRDb29yZGluYXRlcygpKTtpZih0aGlzLl9kaXN0YW5jZTwwJiZ0aGlzLmlzRXJvZGVkQ29tcGxldGVseShzLHRoaXMuX2Rpc3RhbmNlKSlyZXR1cm4gbnVsbDtpZih0aGlzLl9kaXN0YW5jZTw9MCYmaS5sZW5ndGg8MylyZXR1cm4gbnVsbDt0aGlzLmFkZFBvbHlnb25SaW5nKGksZSxuLG5lLkVYVEVSSU9SLG5lLklOVEVSSU9SKTtmb3IobGV0IHM9MDtzPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7cysrKXtjb25zdCBpPXQuZ2V0SW50ZXJpb3JSaW5nTihzKSxyPVgucmVtb3ZlUmVwZWF0ZWRQb2ludHMoaS5nZXRDb29yZGluYXRlcygpKTt0aGlzLl9kaXN0YW5jZT4wJiZ0aGlzLmlzRXJvZGVkQ29tcGxldGVseShpLC10aGlzLl9kaXN0YW5jZSl8fHRoaXMuYWRkUG9seWdvblJpbmcocixlLFBuLm9wcG9zaXRlKG4pLG5lLklOVEVSSU9SLG5lLkVYVEVSSU9SKX19aXNUcmlhbmdsZUVyb2RlZENvbXBsZXRlbHkodCxlKXtjb25zdCBuPW5ldyByZSh0WzBdLHRbMV0sdFsyXSkscz1uLmluQ2VudHJlKCk7cmV0dXJuIEQucG9pbnRUb1NlZ21lbnQocyxuLnAwLG4ucDEpPE1hdGguYWJzKGUpfWFkZExpbmVTdHJpbmcodCl7aWYodGhpcy5fZGlzdGFuY2U8PTAmJiF0aGlzLl9jdXJ2ZUJ1aWxkZXIuZ2V0QnVmZmVyUGFyYW1ldGVycygpLmlzU2luZ2xlU2lkZWQoKSlyZXR1cm4gbnVsbDtjb25zdCBlPVgucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKSxuPXRoaXMuX2N1cnZlQnVpbGRlci5nZXRMaW5lQ3VydmUoZSx0aGlzLl9kaXN0YW5jZSk7dGhpcy5hZGRDdXJ2ZShuLG5lLkVYVEVSSU9SLG5lLklOVEVSSU9SKX1hZGRDdXJ2ZSh0LGUsbil7aWYobnVsbD09PXR8fHQubGVuZ3RoPDIpcmV0dXJuIG51bGw7Y29uc3Qgcz1uZXcgRnModCxuZXcgRm4oMCxuZS5CT1VOREFSWSxlLG4pKTt0aGlzLl9jdXJ2ZUxpc3QuYWRkKHMpfWdldEN1cnZlcygpe3JldHVybiB0aGlzLmFkZCh0aGlzLl9pbnB1dEdlb20pLHRoaXMuX2N1cnZlTGlzdH1hZGRQb2x5Z29uUmluZyh0LGUsbixzLGkpe2lmKDA9PT1lJiZ0Lmxlbmd0aDxEdC5NSU5JTVVNX1ZBTElEX1NJWkUpcmV0dXJuIG51bGw7bGV0IHI9cyxvPWk7dC5sZW5ndGg+PUR0Lk1JTklNVU1fVkFMSURfU0laRSYmdi5pc0NDVyh0KSYmKHI9aSxvPXMsbj1Qbi5vcHBvc2l0ZShuKSk7Y29uc3QgbD10aGlzLl9jdXJ2ZUJ1aWxkZXIuZ2V0UmluZ0N1cnZlKHQsbixlKTt0aGlzLmFkZEN1cnZlKGwscixvKX1hZGQodCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7aWYodCBpbnN0YW5jZW9mIGJ0KXRoaXMuYWRkUG9seWdvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBUdCl0aGlzLmFkZExpbmVTdHJpbmcodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgUHQpdGhpcy5hZGRQb2ludCh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBNdCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgZnQpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIEF0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNle2lmKCEodCBpbnN0YW5jZW9mIF90KSl0aHJvdyBuZXcgWih0LmdldENsYXNzKCkuZ2V0TmFtZSgpKTt0aGlzLmFkZENvbGxlY3Rpb24odCl9fWlzRXJvZGVkQ29tcGxldGVseSh0LGUpe2NvbnN0IG49dC5nZXRDb29yZGluYXRlcygpO2lmKG4ubGVuZ3RoPDQpcmV0dXJuIGU8MDtpZig0PT09bi5sZW5ndGgpcmV0dXJuIHRoaXMuaXNUcmlhbmdsZUVyb2RlZENvbXBsZXRlbHkobixlKTtjb25zdCBzPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLGk9TWF0aC5taW4ocy5nZXRIZWlnaHQoKSxzLmdldFdpZHRoKCkpO3JldHVybiBlPDAmJjIqTWF0aC5hYnMoZSk+aX1hZGRDb2xsZWN0aW9uKHQpe2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpO3RoaXMuYWRkKG4pfX1nZXRDbGFzcygpe3JldHVybiBhaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19YWkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5fZGlzdGFuY2U9bnVsbCx0aGlzLl9jdXJ2ZUJ1aWxkZXI9bnVsbCx0aGlzLl9jdXJ2ZUxpc3Q9bmV3IHg7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5faW5wdXRHZW9tPXQsdGhpcy5fZGlzdGFuY2U9ZSx0aGlzLl9jdXJ2ZUJ1aWxkZXI9bn07Y2xhc3MgY2l7Y29uc3RydWN0b3IoKXtjaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldE5leHRDVyh0KXt0aGlzLmdldEVkZ2VzKCk7Y29uc3QgZT10aGlzLl9lZGdlTGlzdC5pbmRleE9mKHQpO2xldCBuPWUtMTtyZXR1cm4gMD09PWUmJihuPXRoaXMuX2VkZ2VMaXN0LnNpemUoKS0xKSx0aGlzLl9lZGdlTGlzdC5nZXQobil9cHJvcGFnYXRlU2lkZUxhYmVscyh0KXtsZXQgZT1uZS5OT05FO2ZvcihsZXQgbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpLmdldExhYmVsKCk7cy5pc0FyZWEodCkmJnMuZ2V0TG9jYXRpb24odCxQbi5MRUZUKSE9PW5lLk5PTkUmJihlPXMuZ2V0TG9jYXRpb24odCxQbi5MRUZUKSl9aWYoZT09PW5lLk5PTkUpcmV0dXJuIG51bGw7bGV0IG49ZTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgcz1lLm5leHQoKSxpPXMuZ2V0TGFiZWwoKTtpZihpLmdldExvY2F0aW9uKHQsUG4uT04pPT09bmUuTk9ORSYmaS5zZXRMb2NhdGlvbih0LFBuLk9OLG4pLGkuaXNBcmVhKHQpKXtjb25zdCBlPWkuZ2V0TG9jYXRpb24odCxQbi5MRUZUKSxyPWkuZ2V0TG9jYXRpb24odCxQbi5SSUdIVCk7aWYociE9PW5lLk5PTkUpe2lmKHIhPT1uKXRocm93IG5ldyBXbihcInNpZGUgbG9jYXRpb24gY29uZmxpY3RcIixzLmdldENvb3JkaW5hdGUoKSk7ZT09PW5lLk5PTkUmJnUuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJmb3VuZCBzaW5nbGUgbnVsbCBzaWRlIChhdCBcIitzLmdldENvb3JkaW5hdGUoKStcIilcIiksbj1lfWVsc2UgdS5pc1RydWUoaS5nZXRMb2NhdGlvbih0LFBuLkxFRlQpPT09bmUuTk9ORSxcImZvdW5kIHNpbmdsZSBudWxsIHNpZGVcIiksaS5zZXRMb2NhdGlvbih0LFBuLlJJR0hULG4pLGkuc2V0TG9jYXRpb24odCxQbi5MRUZULG4pfX19Z2V0Q29vcmRpbmF0ZSgpe2NvbnN0IHQ9dGhpcy5pdGVyYXRvcigpO3JldHVybiB0Lmhhc05leHQoKT90Lm5leHQoKS5nZXRDb29yZGluYXRlKCk6bnVsbH1wcmludCh0KXtPLm91dC5wcmludGxuKFwiRWRnZUVuZFN0YXI6ICAgXCIrdGhpcy5nZXRDb29yZGluYXRlKCkpO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5wcmludCh0KX19aXNBcmVhTGFiZWxzQ29uc2lzdGVudCh0KXtyZXR1cm4gdGhpcy5jb21wdXRlRWRnZUVuZExhYmVscyh0LmdldEJvdW5kYXJ5Tm9kZVJ1bGUoKSksdGhpcy5jaGVja0FyZWFMYWJlbHNDb25zaXN0ZW50KDApfWNoZWNrQXJlYUxhYmVsc0NvbnNpc3RlbnQodCl7Y29uc3QgZT10aGlzLmdldEVkZ2VzKCk7aWYoZS5zaXplKCk8PTApcmV0dXJuITA7Y29uc3Qgbj1lLnNpemUoKS0xLHM9ZS5nZXQobikuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0LFBuLkxFRlQpO3UuaXNUcnVlKHMhPT1uZS5OT05FLFwiRm91bmQgdW5sYWJlbGxlZCBhcmVhIGVkZ2VcIik7bGV0IGk9cztmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKS5nZXRMYWJlbCgpO3UuaXNUcnVlKG4uaXNBcmVhKHQpLFwiRm91bmQgbm9uLWFyZWEgZWRnZVwiKTtjb25zdCBzPW4uZ2V0TG9jYXRpb24odCxQbi5MRUZUKSxyPW4uZ2V0TG9jYXRpb24odCxQbi5SSUdIVCk7aWYocz09PXIpcmV0dXJuITE7aWYociE9PWkpcmV0dXJuITE7aT1zfXJldHVybiEwfWZpbmRJbmRleCh0KXt0aGlzLml0ZXJhdG9yKCk7Zm9yKGxldCBlPTA7ZTx0aGlzLl9lZGdlTGlzdC5zaXplKCk7ZSsrKXtpZih0aGlzLl9lZGdlTGlzdC5nZXQoZSk9PT10KXJldHVybiBlfXJldHVybi0xfWl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuZ2V0RWRnZXMoKS5pdGVyYXRvcigpfWdldEVkZ2VzKCl7cmV0dXJuIG51bGw9PT10aGlzLl9lZGdlTGlzdCYmKHRoaXMuX2VkZ2VMaXN0PW5ldyB4KHRoaXMuX2VkZ2VNYXAudmFsdWVzKCkpKSx0aGlzLl9lZGdlTGlzdH1nZXRMb2NhdGlvbih0LGUsbil7cmV0dXJuIHRoaXMuX3B0SW5BcmVhTG9jYXRpb25bdF09PT1uZS5OT05FJiYodGhpcy5fcHRJbkFyZWFMb2NhdGlvblt0XT1aZS5sb2NhdGUoZSxuW3RdLmdldEdlb21ldHJ5KCkpKSx0aGlzLl9wdEluQXJlYUxvY2F0aW9uW3RdfXRvU3RyaW5nKCl7Y29uc3QgdD1uZXcgdzt0LmFwcGVuZChcIkVkZ2VFbmRTdGFyOiAgIFwiK3RoaXMuZ2V0Q29vcmRpbmF0ZSgpKSx0LmFwcGVuZChcIlxcblwiKTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0LmFwcGVuZChuKSx0LmFwcGVuZChcIlxcblwiKX1yZXR1cm4gdC50b1N0cmluZygpfWNvbXB1dGVFZGdlRW5kTGFiZWxzKHQpe2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5jb21wdXRlTGFiZWwodCl9fWNvbXB1dGVMYWJlbGxpbmcodCl7dGhpcy5jb21wdXRlRWRnZUVuZExhYmVscyh0WzBdLmdldEJvdW5kYXJ5Tm9kZVJ1bGUoKSksdGhpcy5wcm9wYWdhdGVTaWRlTGFiZWxzKDApLHRoaXMucHJvcGFnYXRlU2lkZUxhYmVscygxKTtjb25zdCBlPVshMSwhMV07Zm9yKGxldCB0PXRoaXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IG49dC5uZXh0KCkuZ2V0TGFiZWwoKTtmb3IobGV0IHQ9MDt0PDI7dCsrKW4uaXNMaW5lKHQpJiZuLmdldExvY2F0aW9uKHQpPT09bmUuQk9VTkRBUlkmJihlW3RdPSEwKX1mb3IobGV0IG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKSxpPXMuZ2V0TGFiZWwoKTtmb3IobGV0IG49MDtuPDI7bisrKWlmKGkuaXNBbnlOdWxsKG4pKXtsZXQgcj1uZS5OT05FO2lmKGVbbl0pcj1uZS5FWFRFUklPUjtlbHNle2NvbnN0IGU9cy5nZXRDb29yZGluYXRlKCk7cj10aGlzLmdldExvY2F0aW9uKG4sZSx0KX1pLnNldEFsbExvY2F0aW9uc0lmTnVsbChuLHIpfX19Z2V0RGVncmVlKCl7cmV0dXJuIHRoaXMuX2VkZ2VNYXAuc2l6ZSgpfWluc2VydEVkZ2VFbmQodCxlKXt0aGlzLl9lZGdlTWFwLnB1dCh0LGUpLHRoaXMuX2VkZ2VMaXN0PW51bGx9Z2V0Q2xhc3MoKXtyZXR1cm4gY2l9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2VkZ2VNYXA9bmV3IHJ0LHRoaXMuX2VkZ2VMaXN0PW51bGwsdGhpcy5fcHRJbkFyZWFMb2NhdGlvbj1bbmUuTk9ORSxuZS5OT05FXX07Y2xhc3MgaGkgZXh0ZW5kcyBjaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksaGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcygpe3RoaXMuZ2V0UmVzdWx0QXJlYUVkZ2VzKCk7bGV0IHQ9bnVsbCxlPW51bGwsbj10aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkc7Zm9yKGxldCBzPTA7czx0aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3Quc2l6ZSgpO3MrKyl7Y29uc3QgaT10aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3QuZ2V0KHMpLHI9aS5nZXRTeW0oKTtpZihpLmdldExhYmVsKCkuaXNBcmVhKCkpc3dpdGNoKG51bGw9PT10JiZpLmlzSW5SZXN1bHQoKSYmKHQ9aSksbil7Y2FzZSB0aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkc6aWYoIXIuaXNJblJlc3VsdCgpKWNvbnRpbnVlO2U9cixuPXRoaXMuX0xJTktJTkdfVE9fT1VUR09JTkc7YnJlYWs7Y2FzZSB0aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HOmlmKCFpLmlzSW5SZXN1bHQoKSljb250aW51ZTtlLnNldE5leHQoaSksbj10aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkd9fWlmKG49PT10aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HKXtpZihudWxsPT09dCl0aHJvdyBuZXcgV24oXCJubyBvdXRnb2luZyBkaXJFZGdlIGZvdW5kXCIsdGhpcy5nZXRDb29yZGluYXRlKCkpO3UuaXNUcnVlKHQuaXNJblJlc3VsdCgpLFwidW5hYmxlIHRvIGxpbmsgbGFzdCBpbmNvbWluZyBkaXJFZGdlXCIpLGUuc2V0TmV4dCh0KX19aW5zZXJ0KHQpe2NvbnN0IGU9dDt0aGlzLmluc2VydEVkZ2VFbmQoZSxlKX1nZXRSaWdodG1vc3RFZGdlKCl7Y29uc3QgdD10aGlzLmdldEVkZ2VzKCksZT10LnNpemUoKTtpZihlPDEpcmV0dXJuIG51bGw7Y29uc3Qgbj10LmdldCgwKTtpZigxPT09ZSlyZXR1cm4gbjtjb25zdCBzPXQuZ2V0KGUtMSksaT1uLmdldFF1YWRyYW50KCkscj1zLmdldFF1YWRyYW50KCk7cmV0dXJuIEluLmlzTm9ydGhlcm4oaSkmJkluLmlzTm9ydGhlcm4ocik/bjpJbi5pc05vcnRoZXJuKGkpfHxJbi5pc05vcnRoZXJuKHIpPzAhPT1uLmdldER5KCk/bjowIT09cy5nZXREeSgpP3M6KHUuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJmb3VuZCB0d28gaG9yaXpvbnRhbCBlZGdlcyBpbmNpZGVudCBvbiBub2RlXCIpLG51bGwpOnN9cHJpbnQodCl7Ty5vdXQucHJpbnRsbihcIkRpcmVjdGVkRWRnZVN0YXI6IFwiK3RoaXMuZ2V0Q29vcmRpbmF0ZSgpKTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0LnByaW50KFwib3V0IFwiKSxuLnByaW50KHQpLHQucHJpbnRsbigpLHQucHJpbnQoXCJpbiBcIiksbi5nZXRTeW0oKS5wcmludCh0KSx0LnByaW50bG4oKX19Z2V0UmVzdWx0QXJlYUVkZ2VzKCl7aWYobnVsbCE9PXRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdClyZXR1cm4gdGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0O3RoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdD1uZXcgeDtmb3IobGV0IHQ9dGhpcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTsoZS5pc0luUmVzdWx0KCl8fGUuZ2V0U3ltKCkuaXNJblJlc3VsdCgpKSYmdGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0LmFkZChlKX1yZXR1cm4gdGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0fXVwZGF0ZUxhYmVsbGluZyh0KXtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKS5nZXRMYWJlbCgpO24uc2V0QWxsTG9jYXRpb25zSWZOdWxsKDAsdC5nZXRMb2NhdGlvbigwKSksbi5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMSx0LmdldExvY2F0aW9uKDEpKX19bGlua0FsbERpcmVjdGVkRWRnZXMoKXt0aGlzLmdldEVkZ2VzKCk7bGV0IHQ9bnVsbCxlPW51bGw7Zm9yKGxldCBuPXRoaXMuX2VkZ2VMaXN0LnNpemUoKS0xO24+PTA7bi0tKXtjb25zdCBzPXRoaXMuX2VkZ2VMaXN0LmdldChuKSxpPXMuZ2V0U3ltKCk7bnVsbD09PWUmJihlPWkpLG51bGwhPT10JiZpLnNldE5leHQodCksdD1zfWUuc2V0TmV4dCh0KX1jb21wdXRlRGVwdGhzKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5maW5kSW5kZXgodCksbj10LmdldERlcHRoKFBuLkxFRlQpLHM9dC5nZXREZXB0aChQbi5SSUdIVCksaT10aGlzLmNvbXB1dGVEZXB0aHMoZSsxLHRoaXMuX2VkZ2VMaXN0LnNpemUoKSxuKTtpZih0aGlzLmNvbXB1dGVEZXB0aHMoMCxlLGkpIT09cyl0aHJvdyBuZXcgV24oXCJkZXB0aCBtaXNtYXRjaCBhdCBcIit0LmdldENvb3JkaW5hdGUoKSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bGV0IG49YXJndW1lbnRzWzJdO2ZvcihsZXQgcz10O3M8ZTtzKyspe2NvbnN0IHQ9dGhpcy5fZWRnZUxpc3QuZ2V0KHMpO3Quc2V0RWRnZURlcHRocyhQbi5SSUdIVCxuKSxuPXQuZ2V0RGVwdGgoUG4uTEVGVCl9cmV0dXJuIG59fW1lcmdlU3ltTGFiZWxzKCl7Zm9yKGxldCB0PXRoaXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7ZS5nZXRMYWJlbCgpLm1lcmdlKGUuZ2V0U3ltKCkuZ2V0TGFiZWwoKSl9fWxpbmtNaW5pbWFsRGlyZWN0ZWRFZGdlcyh0KXtsZXQgZT1udWxsLG49bnVsbCxzPXRoaXMuX1NDQU5OSU5HX0ZPUl9JTkNPTUlORztmb3IobGV0IGk9dGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0LnNpemUoKS0xO2k+PTA7aS0tKXtjb25zdCByPXRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdC5nZXQoaSksbz1yLmdldFN5bSgpO3N3aXRjaChudWxsPT09ZSYmci5nZXRFZGdlUmluZygpPT09dCYmKGU9cikscyl7Y2FzZSB0aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkc6aWYoby5nZXRFZGdlUmluZygpIT09dCljb250aW51ZTtuPW8scz10aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HO2JyZWFrO2Nhc2UgdGhpcy5fTElOS0lOR19UT19PVVRHT0lORzppZihyLmdldEVkZ2VSaW5nKCkhPT10KWNvbnRpbnVlO24uc2V0TmV4dE1pbihyKSxzPXRoaXMuX1NDQU5OSU5HX0ZPUl9JTkNPTUlOR319cz09PXRoaXMuX0xJTktJTkdfVE9fT1VUR09JTkcmJih1LmlzVHJ1ZShudWxsIT09ZSxcImZvdW5kIG51bGwgZm9yIGZpcnN0IG91dGdvaW5nIGRpckVkZ2VcIiksdS5pc1RydWUoZS5nZXRFZGdlUmluZygpPT09dCxcInVuYWJsZSB0byBsaW5rIGxhc3QgaW5jb21pbmcgZGlyRWRnZVwiKSxuLnNldE5leHRNaW4oZSkpfWdldE91dGdvaW5nRGVncmVlKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe2xldCB0PTA7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLmlzSW5SZXN1bHQoKSYmdCsrfXJldHVybiB0fWlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT0wO2ZvcihsZXQgbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtuLm5leHQoKS5nZXRFZGdlUmluZygpPT09dCYmZSsrfXJldHVybiBlfX1nZXRMYWJlbCgpe3JldHVybiB0aGlzLl9sYWJlbH1maW5kQ292ZXJlZExpbmVFZGdlcygpe2xldCB0PW5lLk5PTkU7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkscz1uLmdldFN5bSgpO2lmKCFuLmlzTGluZUVkZ2UoKSl7aWYobi5pc0luUmVzdWx0KCkpe3Q9bmUuSU5URVJJT1I7YnJlYWt9aWYocy5pc0luUmVzdWx0KCkpe3Q9bmUuRVhURVJJT1I7YnJlYWt9fX1pZih0PT09bmUuTk9ORSlyZXR1cm4gbnVsbDtsZXQgZT10O2ZvcihsZXQgdD10aGlzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBuPXQubmV4dCgpLHM9bi5nZXRTeW0oKTtuLmlzTGluZUVkZ2UoKT9uLmdldEVkZ2UoKS5zZXRDb3ZlcmVkKGU9PT1uZS5JTlRFUklPUik6KG4uaXNJblJlc3VsdCgpJiYoZT1uZS5FWFRFUklPUikscy5pc0luUmVzdWx0KCkmJihlPW5lLklOVEVSSU9SKSl9fWNvbXB1dGVMYWJlbGxpbmcodCl7c3VwZXIuY29tcHV0ZUxhYmVsbGluZy5jYWxsKHRoaXMsdCksdGhpcy5fbGFiZWw9bmV3IEZuKG5lLk5PTkUpO2ZvcihsZXQgdD10aGlzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLmdldEVkZ2UoKS5nZXRMYWJlbCgpO2ZvcihsZXQgdD0wO3Q8Mjt0Kyspe2NvbnN0IG49ZS5nZXRMb2NhdGlvbih0KTtuIT09bmUuSU5URVJJT1ImJm4hPT1uZS5CT1VOREFSWXx8dGhpcy5fbGFiZWwuc2V0TG9jYXRpb24odCxuZS5JTlRFUklPUil9fX1nZXRDbGFzcygpe3JldHVybiBoaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19aGkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0PW51bGwsdGhpcy5fbGFiZWw9bnVsbCx0aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkc9MSx0aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HPTJ9O2NsYXNzIHVpIGV4dGVuZHMgS257Y29uc3RydWN0b3IoKXtzdXBlcigpLHVpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y3JlYXRlTm9kZSh0KXtyZXR1cm4gbmV3IGtuKHQsbmV3IGhpKX1nZXRDbGFzcygpe3JldHVybiB1aX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19dWkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBnaXtjb25zdHJ1Y3Rvcigpe2dpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIG9yaWVudGF0aW9uKHQpe3JldHVybiAxPT09WC5pbmNyZWFzaW5nRGlyZWN0aW9uKHQpfXN0YXRpYyBjb21wYXJlT3JpZW50ZWQodCxlLG4scyl7Y29uc3QgaT1lPzE6LTEscj1zPzE6LTEsbz1lP3QubGVuZ3RoOi0xLGw9cz9uLmxlbmd0aDotMTtsZXQgYT1lPzA6dC5sZW5ndGgtMSxjPXM/MDpuLmxlbmd0aC0xO2Zvcig7Oyl7Y29uc3QgZT10W2FdLmNvbXBhcmVUbyhuW2NdKTtpZigwIT09ZSlyZXR1cm4gZTthKz1pLGMrPXI7Y29uc3Qgcz1hPT09byxoPWM9PT1sO2lmKHMmJiFoKXJldHVybi0xO2lmKCFzJiZoKXJldHVybiAxO2lmKHMmJmgpcmV0dXJuIDB9fWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIGdpLmNvbXBhcmVPcmllbnRlZCh0aGlzLl9wdHMsdGhpcy5fb3JpZW50YXRpb24sZS5fcHRzLGUuX29yaWVudGF0aW9uKX1nZXRDbGFzcygpe3JldHVybiBnaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bcl19fWdpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3B0cz1udWxsLHRoaXMuX29yaWVudGF0aW9uPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcHRzPXQsdGhpcy5fb3JpZW50YXRpb249Z2kub3JpZW50YXRpb24odCl9O2NsYXNzIGRpe2NvbnN0cnVjdG9yKCl7ZGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1wcmludCh0KXt0LnByaW50KFwiTVVMVElMSU5FU1RSSU5HICggXCIpO2ZvcihsZXQgZT0wO2U8dGhpcy5fZWRnZXMuc2l6ZSgpO2UrKyl7Y29uc3Qgbj10aGlzLl9lZGdlcy5nZXQoZSk7ZT4wJiZ0LnByaW50KFwiLFwiKSx0LnByaW50KFwiKFwiKTtjb25zdCBzPW4uZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IGU9MDtlPHMubGVuZ3RoO2UrKyllPjAmJnQucHJpbnQoXCIsXCIpLHQucHJpbnQoc1tlXS54K1wiIFwiK3NbZV0ueSk7dC5wcmludGxuKFwiKVwiKX10LnByaW50KFwiKSAgXCIpfWFkZEFsbCh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLmFkZChlLm5leHQoKSl9ZmluZEVkZ2VJbmRleCh0KXtmb3IobGV0IGU9MDtlPHRoaXMuX2VkZ2VzLnNpemUoKTtlKyspaWYodGhpcy5fZWRnZXMuZ2V0KGUpLmVxdWFscyh0KSlyZXR1cm4gZTtyZXR1cm4tMX1pdGVyYXRvcigpe3JldHVybiB0aGlzLl9lZGdlcy5pdGVyYXRvcigpfWdldEVkZ2VzKCl7cmV0dXJuIHRoaXMuX2VkZ2VzfWdldCh0KXtyZXR1cm4gdGhpcy5fZWRnZXMuZ2V0KHQpfWZpbmRFcXVhbEVkZ2UodCl7Y29uc3QgZT1uZXcgZ2kodC5nZXRDb29yZGluYXRlcygpKTtyZXR1cm4gdGhpcy5fb2NhTWFwLmdldChlKX1hZGQodCl7dGhpcy5fZWRnZXMuYWRkKHQpO2NvbnN0IGU9bmV3IGdpKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7dGhpcy5fb2NhTWFwLnB1dChlLHQpfWdldENsYXNzKCl7cmV0dXJuIGRpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1kaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9lZGdlcz1uZXcgeCx0aGlzLl9vY2FNYXA9bmV3IHJ0fTtjbGFzcyBfaXtjb25zdHJ1Y3Rvcigpe19pLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cHJvY2Vzc0ludGVyc2VjdGlvbnModCxlLG4scyl7fWlzRG9uZSgpe31nZXRDbGFzcygpe3JldHVybiBfaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19X2kuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBmaXtjb25zdHJ1Y3Rvcigpe2ZpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGlzQWRqYWNlbnRTZWdtZW50cyh0LGUpe3JldHVybiAxPT09TWF0aC5hYnModC1lKX1pc1RyaXZpYWxJbnRlcnNlY3Rpb24odCxlLG4scyl7aWYodD09PW4mJjE9PT10aGlzLl9saS5nZXRJbnRlcnNlY3Rpb25OdW0oKSl7aWYoZmkuaXNBZGphY2VudFNlZ21lbnRzKGUscykpcmV0dXJuITA7aWYodC5pc0Nsb3NlZCgpKXtjb25zdCBuPXQuc2l6ZSgpLTE7aWYoMD09PWUmJnM9PT1ufHwwPT09cyYmZT09PW4pcmV0dXJuITB9fXJldHVybiExfWdldFByb3BlckludGVyc2VjdGlvblBvaW50KCl7cmV0dXJuIHRoaXMuX3Byb3BlckludGVyc2VjdGlvblBvaW50fWhhc1Byb3BlckludGVyaW9ySW50ZXJzZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc1Byb3BlckludGVyaW9yfWdldExpbmVJbnRlcnNlY3Rvcigpe3JldHVybiB0aGlzLl9saX1oYXNQcm9wZXJJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzUHJvcGVyfXByb2Nlc3NJbnRlcnNlY3Rpb25zKHQsZSxuLHMpe2lmKHQ9PT1uJiZlPT09cylyZXR1cm4gbnVsbDt0aGlzLm51bVRlc3RzKys7Y29uc3QgaT10LmdldENvb3JkaW5hdGVzKClbZV0scj10LmdldENvb3JkaW5hdGVzKClbZSsxXSxvPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzXSxsPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzKzFdO3RoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24oaSxyLG8sbCksdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkmJih0aGlzLm51bUludGVyc2VjdGlvbnMrKyx0aGlzLl9saS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCkmJih0aGlzLm51bUludGVyaW9ySW50ZXJzZWN0aW9ucysrLHRoaXMuX2hhc0ludGVyaW9yPSEwKSx0aGlzLmlzVHJpdmlhbEludGVyc2VjdGlvbih0LGUsbixzKXx8KHRoaXMuX2hhc0ludGVyc2VjdGlvbj0hMCx0LmFkZEludGVyc2VjdGlvbnModGhpcy5fbGksZSwwKSxuLmFkZEludGVyc2VjdGlvbnModGhpcy5fbGkscywxKSx0aGlzLl9saS5pc1Byb3BlcigpJiYodGhpcy5udW1Qcm9wZXJJbnRlcnNlY3Rpb25zKyssdGhpcy5faGFzUHJvcGVyPSEwLHRoaXMuX2hhc1Byb3BlckludGVyaW9yPSEwKSkpfWhhc0ludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9oYXNJbnRlcnNlY3Rpb259aXNEb25lKCl7cmV0dXJuITF9aGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzSW50ZXJpb3J9Z2V0Q2xhc3MoKXtyZXR1cm4gZml9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW19pXX19ZmkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faGFzSW50ZXJzZWN0aW9uPSExLHRoaXMuX2hhc1Byb3Blcj0hMSx0aGlzLl9oYXNQcm9wZXJJbnRlcmlvcj0hMSx0aGlzLl9oYXNJbnRlcmlvcj0hMSx0aGlzLl9wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludD1udWxsLHRoaXMuX2xpPW51bGwsdGhpcy5faXNTZWxmSW50ZXJzZWN0aW9uPW51bGwsdGhpcy5udW1JbnRlcnNlY3Rpb25zPTAsdGhpcy5udW1JbnRlcmlvckludGVyc2VjdGlvbnM9MCx0aGlzLm51bVByb3BlckludGVyc2VjdGlvbnM9MCx0aGlzLm51bVRlc3RzPTA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGk9dH07Y2xhc3MgcGl7Y29uc3RydWN0b3IoKXtwaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBkZXB0aERlbHRhKHQpe2NvbnN0IGU9dC5nZXRMb2NhdGlvbigwLFBuLkxFRlQpLG49dC5nZXRMb2NhdGlvbigwLFBuLlJJR0hUKTtyZXR1cm4gZT09PW5lLklOVEVSSU9SJiZuPT09bmUuRVhURVJJT1I/MTplPT09bmUuRVhURVJJT1ImJm49PT1uZS5JTlRFUklPUj8tMTowfXN0YXRpYyBjb252ZXJ0U2VnU3RyaW5ncyh0KXtjb25zdCBlPW5ldyBIdCxuPW5ldyB4O2Zvcig7dC5oYXNOZXh0KCk7KXtjb25zdCBzPXQubmV4dCgpLGk9ZS5jcmVhdGVMaW5lU3RyaW5nKHMuZ2V0Q29vcmRpbmF0ZXMoKSk7bi5hZGQoaSl9cmV0dXJuIGUuYnVpbGRHZW9tZXRyeShuKX1zZXRXb3JraW5nUHJlY2lzaW9uTW9kZWwodCl7dGhpcy5fd29ya2luZ1ByZWNpc2lvbk1vZGVsPXR9aW5zZXJ0VW5pcXVlRWRnZSh0KXtjb25zdCBlPXRoaXMuX2VkZ2VMaXN0LmZpbmRFcXVhbEVkZ2UodCk7aWYobnVsbCE9PWUpe2NvbnN0IG49ZS5nZXRMYWJlbCgpO2xldCBzPXQuZ2V0TGFiZWwoKTtlLmlzUG9pbnR3aXNlRXF1YWwodCl8fChzPW5ldyBGbih0LmdldExhYmVsKCkpLHMuZmxpcCgpKSxuLm1lcmdlKHMpO2NvbnN0IGk9cGkuZGVwdGhEZWx0YShzKSxyPWUuZ2V0RGVwdGhEZWx0YSgpK2k7ZS5zZXREZXB0aERlbHRhKHIpfWVsc2UgdGhpcy5fZWRnZUxpc3QuYWRkKHQpLHQuc2V0RGVwdGhEZWx0YShwaS5kZXB0aERlbHRhKHQuZ2V0TGFiZWwoKSkpfWJ1aWxkU3ViZ3JhcGhzKHQsZSl7Y29uc3Qgbj1uZXcgeDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKSxpPXQuZ2V0UmlnaHRtb3N0Q29vcmRpbmF0ZSgpLHI9bmV3IG9pKG4pLmdldERlcHRoKGkpO3QuY29tcHV0ZURlcHRoKHIpLHQuZmluZFJlc3VsdEVkZ2VzKCksbi5hZGQodCksZS5hZGQodC5nZXREaXJlY3RlZEVkZ2VzKCksdC5nZXROb2RlcygpKX19Y3JlYXRlU3ViZ3JhcGhzKHQpe2NvbnN0IGU9bmV3IHg7Zm9yKGxldCBuPXQuZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtpZighdC5pc1Zpc2l0ZWQoKSl7Y29uc3Qgbj1uZXcgUXM7bi5jcmVhdGUodCksZS5hZGQobil9fXJldHVybiBFZS5zb3J0KGUsRWUucmV2ZXJzZU9yZGVyKCkpLGV9Y3JlYXRlRW1wdHlSZXN1bHRHZW9tZXRyeSgpe3JldHVybiB0aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2x5Z29uKCl9Z2V0Tm9kZXIodCl7aWYobnVsbCE9PXRoaXMuX3dvcmtpbmdOb2RlcilyZXR1cm4gdGhpcy5fd29ya2luZ05vZGVyO2NvbnN0IGU9bmV3IFlzLG49bmV3IHRlO3JldHVybiBuLnNldFByZWNpc2lvbk1vZGVsKHQpLGUuc2V0U2VnbWVudEludGVyc2VjdG9yKG5ldyBmaShuKSksZX1idWZmZXIodCxlKXtsZXQgbj10aGlzLl93b3JraW5nUHJlY2lzaW9uTW9kZWw7bnVsbD09PW4mJihuPXQuZ2V0UHJlY2lzaW9uTW9kZWwoKSksdGhpcy5fZ2VvbUZhY3Q9dC5nZXRGYWN0b3J5KCk7Y29uc3Qgcz1uZXcgcmkobix0aGlzLl9idWZQYXJhbXMpLGk9bmV3IGFpKHQsZSxzKS5nZXRDdXJ2ZXMoKTtpZihpLnNpemUoKTw9MClyZXR1cm4gdGhpcy5jcmVhdGVFbXB0eVJlc3VsdEdlb21ldHJ5KCk7dGhpcy5jb21wdXRlTm9kZWRFZGdlcyhpLG4pLHRoaXMuX2dyYXBoPW5ldyBabihuZXcgdWkpLHRoaXMuX2dyYXBoLmFkZEVkZ2VzKHRoaXMuX2VkZ2VMaXN0LmdldEVkZ2VzKCkpO2NvbnN0IHI9dGhpcy5jcmVhdGVTdWJncmFwaHModGhpcy5fZ3JhcGgpLG89bmV3IGVpKHRoaXMuX2dlb21GYWN0KTt0aGlzLmJ1aWxkU3ViZ3JhcGhzKHIsbyk7Y29uc3QgbD1vLmdldFBvbHlnb25zKCk7cmV0dXJuIGwuc2l6ZSgpPD0wP3RoaXMuY3JlYXRlRW1wdHlSZXN1bHRHZW9tZXRyeSgpOnRoaXMuX2dlb21GYWN0LmJ1aWxkR2VvbWV0cnkobCl9Y29tcHV0ZU5vZGVkRWRnZXModCxlKXtjb25zdCBuPXRoaXMuZ2V0Tm9kZXIoZSk7bi5jb21wdXRlTm9kZXModCk7Zm9yKGxldCB0PW4uZ2V0Tm9kZWRTdWJzdHJpbmdzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj1lLmdldENvb3JkaW5hdGVzKCk7aWYoMj09PW4ubGVuZ3RoJiZuWzBdLmVxdWFsczJEKG5bMV0pKWNvbnRpbnVlO2NvbnN0IHM9ZS5nZXREYXRhKCksaT1uZXcgVW4oZS5nZXRDb29yZGluYXRlcygpLG5ldyBGbihzKSk7dGhpcy5pbnNlcnRVbmlxdWVFZGdlKGkpfX1zZXROb2Rlcih0KXt0aGlzLl93b3JraW5nTm9kZXI9dH1nZXRDbGFzcygpe3JldHVybiBwaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19cGkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fYnVmUGFyYW1zPW51bGwsdGhpcy5fd29ya2luZ1ByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5fd29ya2luZ05vZGVyPW51bGwsdGhpcy5fZ2VvbUZhY3Q9bnVsbCx0aGlzLl9ncmFwaD1udWxsLHRoaXMuX2VkZ2VMaXN0PW5ldyBkaTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9idWZQYXJhbXM9dH07Y2xhc3MgbWl7Y29uc3RydWN0b3IoKXttaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKGxldCB0PXRoaXMuX3NlZ1N0cmluZ3MuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCkuZ2V0Q29vcmRpbmF0ZXMoKTt0aGlzLmNoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zKGVbMF0sdGhpcy5fc2VnU3RyaW5ncyksdGhpcy5jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucyhlW2UubGVuZ3RoLTFdLHRoaXMuX3NlZ1N0cmluZ3MpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT1hcmd1bWVudHNbMV0uaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IGU9MTtlPG4ubGVuZ3RoLTE7ZSsrKWlmKG5bZV0uZXF1YWxzKHQpKXRocm93IG5ldyBjKFwiZm91bmQgZW5kcHQvaW50ZXJpb3IgcHQgaW50ZXJzZWN0aW9uIGF0IGluZGV4IFwiK2UrXCIgOnB0IFwiK3QpfX19Y2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClmb3IobGV0IHQ9dGhpcy5fc2VnU3RyaW5ncy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtmb3IobGV0IHQ9dGhpcy5fc2VnU3RyaW5ncy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3Qgbj10Lm5leHQoKTt0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKGUsbil9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dC5nZXRDb29yZGluYXRlcygpLHM9ZS5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgaT0wO2k8bi5sZW5ndGgtMTtpKyspZm9yKGxldCBuPTA7bjxzLmxlbmd0aC0xO24rKyl0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKHQsaSxlLG4pfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO2lmKHQ9PT1uJiZlPT09cylyZXR1cm4gbnVsbDtjb25zdCBpPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlXSxyPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlKzFdLG89bi5nZXRDb29yZGluYXRlcygpW3NdLGw9bi5nZXRDb29yZGluYXRlcygpW3MrMV07aWYodGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihpLHIsbyxsKSx0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSYmKHRoaXMuX2xpLmlzUHJvcGVyKCl8fHRoaXMuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24odGhpcy5fbGksaSxyKXx8dGhpcy5oYXNJbnRlcmlvckludGVyc2VjdGlvbih0aGlzLl9saSxvLGwpKSl0aHJvdyBuZXcgYyhcImZvdW5kIG5vbi1ub2RlZCBpbnRlcnNlY3Rpb24gYXQgXCIraStcIi1cIityK1wiIGFuZCBcIitvK1wiLVwiK2wpfX1jaGVja1ZhbGlkKCl7dGhpcy5jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucygpLHRoaXMuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMoKSx0aGlzLmNoZWNrQ29sbGFwc2VzKCl9Y2hlY2tDb2xsYXBzZXMoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClmb3IobGV0IHQ9dGhpcy5fc2VnU3RyaW5ncy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLmNoZWNrQ29sbGFwc2VzKGUpfWVsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLmdldENvb3JkaW5hdGVzKCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aC0yO2UrKyl0aGlzLmNoZWNrQ29sbGFwc2UodFtlXSx0W2UrMV0sdFtlKzJdKX19aGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24odCxlLG4pe2ZvcihsZXQgcz0wO3M8dC5nZXRJbnRlcnNlY3Rpb25OdW0oKTtzKyspe2NvbnN0IGk9dC5nZXRJbnRlcnNlY3Rpb24ocyk7aWYoIWkuZXF1YWxzKGUpJiYhaS5lcXVhbHMobikpcmV0dXJuITB9cmV0dXJuITF9Y2hlY2tDb2xsYXBzZSh0LGUsbil7aWYodC5lcXVhbHMobikpdGhyb3cgbmV3IGMoXCJmb3VuZCBub24tbm9kZWQgY29sbGFwc2UgYXQgXCIrbWkuZmFjdC5jcmVhdGVMaW5lU3RyaW5nKFt0LGUsbl0pKX1nZXRDbGFzcygpe3JldHVybiBtaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19bWkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbGk9bmV3IHRlLHRoaXMuX3NlZ1N0cmluZ3M9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zZWdTdHJpbmdzPXR9LG1pLmZhY3Q9bmV3IEh0O2NsYXNzIHlpe2NvbnN0cnVjdG9yKCl7eWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pbnRlcnNlY3RzU2NhbGVkKHQsZSl7Y29uc3Qgbj1NYXRoLm1pbih0LngsZS54KSxzPU1hdGgubWF4KHQueCxlLngpLGk9TWF0aC5taW4odC55LGUueSkscj1NYXRoLm1heCh0LnksZS55KSxvPXRoaXMuX21heHg8bnx8dGhpcy5fbWlueD5zfHx0aGlzLl9tYXh5PGl8fHRoaXMuX21pbnk+cjtpZihvKXJldHVybiExO2NvbnN0IGw9dGhpcy5pbnRlcnNlY3RzVG9sZXJhbmNlU3F1YXJlKHQsZSk7cmV0dXJuIHUuaXNUcnVlKCEobyYmbCksXCJGb3VuZCBiYWQgZW52ZWxvcGUgdGVzdFwiKSxsfWluaXRDb3JuZXJzKHQpe3RoaXMuX21pbng9dC54LS41LHRoaXMuX21heHg9dC54Ky41LHRoaXMuX21pbnk9dC55LS41LHRoaXMuX21heHk9dC55Ky41LHRoaXMuX2Nvcm5lclswXT1uZXcgZyh0aGlzLl9tYXh4LHRoaXMuX21heHkpLHRoaXMuX2Nvcm5lclsxXT1uZXcgZyh0aGlzLl9taW54LHRoaXMuX21heHkpLHRoaXMuX2Nvcm5lclsyXT1uZXcgZyh0aGlzLl9taW54LHRoaXMuX21pbnkpLHRoaXMuX2Nvcm5lclszXT1uZXcgZyh0aGlzLl9tYXh4LHRoaXMuX21pbnkpfWludGVyc2VjdHModCxlKXtyZXR1cm4gMT09PXRoaXMuX3NjYWxlRmFjdG9yP3RoaXMuaW50ZXJzZWN0c1NjYWxlZCh0LGUpOih0aGlzLmNvcHlTY2FsZWQodCx0aGlzLl9wMFNjYWxlZCksdGhpcy5jb3B5U2NhbGVkKGUsdGhpcy5fcDFTY2FsZWQpLHRoaXMuaW50ZXJzZWN0c1NjYWxlZCh0aGlzLl9wMFNjYWxlZCx0aGlzLl9wMVNjYWxlZCkpfXNjYWxlKHQpe3JldHVybiBNYXRoLnJvdW5kKHQqdGhpcy5fc2NhbGVGYWN0b3IpfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fb3JpZ2luYWxQdH1jb3B5U2NhbGVkKHQsZSl7ZS54PXRoaXMuc2NhbGUodC54KSxlLnk9dGhpcy5zY2FsZSh0LnkpfWdldFNhZmVFbnZlbG9wZSgpe2lmKG51bGw9PT10aGlzLl9zYWZlRW52KXtjb25zdCB0PXlpLlNBRkVfRU5WX0VYUEFOU0lPTl9GQUNUT1IvdGhpcy5fc2NhbGVGYWN0b3I7dGhpcy5fc2FmZUVudj1uZXcgTih0aGlzLl9vcmlnaW5hbFB0LngtdCx0aGlzLl9vcmlnaW5hbFB0LngrdCx0aGlzLl9vcmlnaW5hbFB0LnktdCx0aGlzLl9vcmlnaW5hbFB0LnkrdCl9cmV0dXJuIHRoaXMuX3NhZmVFbnZ9aW50ZXJzZWN0c1BpeGVsQ2xvc3VyZSh0LGUpe3JldHVybiB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbMF0sdGhpcy5fY29ybmVyWzFdKSwhIXRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpfHwodGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fY29ybmVyWzFdLHRoaXMuX2Nvcm5lclsyXSksISF0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKXx8KHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2Nvcm5lclsyXSx0aGlzLl9jb3JuZXJbM10pLCEhdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCl8fCh0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbM10sdGhpcy5fY29ybmVyWzBdKSwhIXRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpKSkpfWludGVyc2VjdHNUb2xlcmFuY2VTcXVhcmUodCxlKXtsZXQgbj0hMSxzPSExO3JldHVybiB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbMF0sdGhpcy5fY29ybmVyWzFdKSwhIXRoaXMuX2xpLmlzUHJvcGVyKCl8fCh0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLl9jb3JuZXJbMV0sdGhpcy5fY29ybmVyWzJdKSwhIXRoaXMuX2xpLmlzUHJvcGVyKCl8fCh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSYmKG49ITApLHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2Nvcm5lclsyXSx0aGlzLl9jb3JuZXJbM10pLCEhdGhpcy5fbGkuaXNQcm9wZXIoKXx8KHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpJiYocz0hMCksdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5fY29ybmVyWzNdLHRoaXMuX2Nvcm5lclswXSksISF0aGlzLl9saS5pc1Byb3BlcigpfHwoISghbnx8IXMpfHwoISF0LmVxdWFscyh0aGlzLl9wdCl8fCEhZS5lcXVhbHModGhpcy5fcHQpKSkpKSl9YWRkU25hcHBlZE5vZGUodCxlKXtjb25zdCBuPXQuZ2V0Q29vcmRpbmF0ZShlKSxzPXQuZ2V0Q29vcmRpbmF0ZShlKzEpO3JldHVybiEhdGhpcy5pbnRlcnNlY3RzKG4scykmJih0LmFkZEludGVyc2VjdGlvbih0aGlzLmdldENvb3JkaW5hdGUoKSxlKSwhMCl9Z2V0Q2xhc3MoKXtyZXR1cm4geWl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXlpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpPW51bGwsdGhpcy5fcHQ9bnVsbCx0aGlzLl9vcmlnaW5hbFB0PW51bGwsdGhpcy5fcHRTY2FsZWQ9bnVsbCx0aGlzLl9wMFNjYWxlZD1udWxsLHRoaXMuX3AxU2NhbGVkPW51bGwsdGhpcy5fc2NhbGVGYWN0b3I9bnVsbCx0aGlzLl9taW54PW51bGwsdGhpcy5fbWF4eD1udWxsLHRoaXMuX21pbnk9bnVsbCx0aGlzLl9tYXh5PW51bGwsdGhpcy5fY29ybmVyPW5ldyBBcnJheSg0KS5maWxsKG51bGwpLHRoaXMuX3NhZmVFbnY9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXTtpZih0aGlzLl9vcmlnaW5hbFB0PXQsdGhpcy5fcHQ9dCx0aGlzLl9zY2FsZUZhY3Rvcj1lLHRoaXMuX2xpPXMsZTw9MCl0aHJvdyBuZXcgbihcIlNjYWxlIGZhY3RvciBtdXN0IGJlIG5vbi16ZXJvXCIpOzEhPT1lJiYodGhpcy5fcHQ9bmV3IGcodGhpcy5zY2FsZSh0LngpLHRoaXMuc2NhbGUodC55KSksdGhpcy5fcDBTY2FsZWQ9bmV3IGcsdGhpcy5fcDFTY2FsZWQ9bmV3IGcpLHRoaXMuaW5pdENvcm5lcnModGhpcy5fcHQpfSx5aS5TQUZFX0VOVl9FWFBBTlNJT05fRkFDVE9SPS43NTtjbGFzcyB4aXtjb25zdHJ1Y3Rvcigpe3hpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c2VsZWN0KCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3QuZ2V0TGluZVNlZ21lbnQoZSx0aGlzLnNlbGVjdGVkU2VnbWVudCksdGhpcy5zZWxlY3QodGhpcy5zZWxlY3RlZFNlZ21lbnQpfX1nZXRDbGFzcygpe3JldHVybiB4aX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19eGkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5zZWxlY3RlZFNlZ21lbnQ9bmV3IGVlfTtjbGFzcyBFaXtjb25zdHJ1Y3Rvcigpe0VpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c25hcCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zbmFwKHQsbnVsbCwtMSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9dC5nZXRTYWZlRW52ZWxvcGUoKSxpPW5ldyBJaSh0LGUsbik7cmV0dXJuIHRoaXMuX2luZGV4LnF1ZXJ5KHMsbmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVybltBZV19dmlzaXRJdGVtKHQpe3Quc2VsZWN0KHMsaSl9fSksaS5pc05vZGVBZGRlZCgpfX1nZXRDbGFzcygpe3JldHVybiBFaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3MgSWkgZXh0ZW5kcyB4aXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksSWkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pc05vZGVBZGRlZCgpe3JldHVybiB0aGlzLl9pc05vZGVBZGRlZH1zZWxlY3QoKXtpZighKDI9PT1hcmd1bWVudHMubGVuZ3RoJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgcXMpKXJldHVybiBzdXBlci5zZWxlY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpO3tjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXQuZ2V0Q29udGV4dCgpO2lmKG51bGwhPT10aGlzLl9wYXJlbnRFZGdlJiZuPT09dGhpcy5fcGFyZW50RWRnZSYmZT09PXRoaXMuX2hvdFBpeGVsVmVydGV4SW5kZXgpcmV0dXJuIG51bGw7dGhpcy5faXNOb2RlQWRkZWQ9dGhpcy5faG90UGl4ZWwuYWRkU25hcHBlZE5vZGUobixlKX19Z2V0Q2xhc3MoKXtyZXR1cm4gSWl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUlpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2hvdFBpeGVsPW51bGwsdGhpcy5fcGFyZW50RWRnZT1udWxsLHRoaXMuX2hvdFBpeGVsVmVydGV4SW5kZXg9bnVsbCx0aGlzLl9pc05vZGVBZGRlZD0hMTtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9ob3RQaXhlbD10LHRoaXMuX3BhcmVudEVkZ2U9ZSx0aGlzLl9ob3RQaXhlbFZlcnRleEluZGV4PW59LEVpLkhvdFBpeGVsU25hcEFjdGlvbj1JaSxFaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pbmRleD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2luZGV4PXR9O2NsYXNzIE5pe2NvbnN0cnVjdG9yKCl7TmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1wcm9jZXNzSW50ZXJzZWN0aW9ucyh0LGUsbixzKXtpZih0PT09biYmZT09PXMpcmV0dXJuIG51bGw7Y29uc3QgaT10LmdldENvb3JkaW5hdGVzKClbZV0scj10LmdldENvb3JkaW5hdGVzKClbZSsxXSxvPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzXSxsPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzKzFdO2lmKHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24oaSxyLG8sbCksdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkmJnRoaXMuX2xpLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKSl7Zm9yKGxldCB0PTA7dDx0aGlzLl9saS5nZXRJbnRlcnNlY3Rpb25OdW0oKTt0KyspdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb25zLmFkZCh0aGlzLl9saS5nZXRJbnRlcnNlY3Rpb24odCkpO3QuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLl9saSxlLDApLG4uYWRkSW50ZXJzZWN0aW9ucyh0aGlzLl9saSxzLDEpfX1pc0RvbmUoKXtyZXR1cm4hMX1nZXRJbnRlcmlvckludGVyc2VjdGlvbnMoKXtyZXR1cm4gdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb25zfWdldENsYXNzKCl7cmV0dXJuIE5pfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltfaV19fU5pLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpPW51bGwsdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb25zPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGk9dCx0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbnM9bmV3IHh9O2NsYXNzIENpe2NvbnN0cnVjdG9yKCl7Q2kuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jaGVja0NvcnJlY3RuZXNzKHQpe2NvbnN0IGU9RnMuZ2V0Tm9kZWRTdWJzdHJpbmdzKHQpLG49bmV3IG1pKGUpO3RyeXtuLmNoZWNrVmFsaWQoKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBDKSl0aHJvdyB0O3QucHJpbnRTdGFja1RyYWNlKCl9fWdldE5vZGVkU3Vic3RyaW5ncygpe3JldHVybiBGcy5nZXROb2RlZFN1YnN0cmluZ3ModGhpcy5fbm9kZWRTZWdTdHJpbmdzKX1zbmFwUm91bmQodCxlKXtjb25zdCBuPXRoaXMuZmluZEludGVyaW9ySW50ZXJzZWN0aW9ucyh0LGUpO3RoaXMuY29tcHV0ZUludGVyc2VjdGlvblNuYXBzKG4pLHRoaXMuY29tcHV0ZVZlcnRleFNuYXBzKHQpfWZpbmRJbnRlcmlvckludGVyc2VjdGlvbnModCxlKXtjb25zdCBuPW5ldyBOaShlKTtyZXR1cm4gdGhpcy5fbm9kZXIuc2V0U2VnbWVudEludGVyc2VjdG9yKG4pLHRoaXMuX25vZGVyLmNvbXB1dGVOb2Rlcyh0KSxuLmdldEludGVyaW9ySW50ZXJzZWN0aW9ucygpfWNvbXB1dGVWZXJ0ZXhTbmFwcygpe2lmKF8oYXJndW1lbnRzWzBdLGYpKXtmb3IobGV0IHQ9YXJndW1lbnRzWzBdLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO3RoaXMuY29tcHV0ZVZlcnRleFNuYXBzKGUpfX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRnMpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9dC5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXtjb25zdCBzPW5ldyB5aShlW25dLHRoaXMuX3NjYWxlRmFjdG9yLHRoaXMuX2xpKTt0aGlzLl9wb2ludFNuYXBwZXIuc25hcChzLHQsbikmJnQuYWRkSW50ZXJzZWN0aW9uKGVbbl0sbil9fX1jb21wdXRlTm9kZXModCl7dGhpcy5fbm9kZWRTZWdTdHJpbmdzPXQsdGhpcy5fbm9kZXI9bmV3IFlzLHRoaXMuX3BvaW50U25hcHBlcj1uZXcgRWkodGhpcy5fbm9kZXIuZ2V0SW5kZXgoKSksdGhpcy5zbmFwUm91bmQodCx0aGlzLl9saSl9Y29tcHV0ZUludGVyc2VjdGlvblNuYXBzKHQpe2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpLG49bmV3IHlpKHQsdGhpcy5fc2NhbGVGYWN0b3IsdGhpcy5fbGkpO3RoaXMuX3BvaW50U25hcHBlci5zbmFwKG4pfX1nZXRDbGFzcygpe3JldHVybiBDaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bVnNdfX1DaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9wbT1udWxsLHRoaXMuX2xpPW51bGwsdGhpcy5fc2NhbGVGYWN0b3I9bnVsbCx0aGlzLl9ub2Rlcj1udWxsLHRoaXMuX3BvaW50U25hcHBlcj1udWxsLHRoaXMuX25vZGVkU2VnU3RyaW5ncz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3BtPXQsdGhpcy5fbGk9bmV3IHRlLHRoaXMuX2xpLnNldFByZWNpc2lvbk1vZGVsKHQpLHRoaXMuX3NjYWxlRmFjdG9yPXQuZ2V0U2NhbGUoKX07Y2xhc3MgU2l7Y29uc3RydWN0b3IoKXtTaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBidWZmZXJPcCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IFNpKHQpLmdldFJlc3VsdEdlb21ldHJ5KGUpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1syXSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1uZXcgU2kodCk7cmV0dXJuIHMuc2V0UXVhZHJhbnRTZWdtZW50cyhuKSxzLmdldFJlc3VsdEdlb21ldHJ5KGUpfWlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YganMmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIG5ldyBTaSh0LG4pLmdldFJlc3VsdEdlb21ldHJ5KGUpfX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXSxpPW5ldyBTaSh0KTtyZXR1cm4gaS5zZXRRdWFkcmFudFNlZ21lbnRzKG4pLGkuc2V0RW5kQ2FwU3R5bGUocyksaS5nZXRSZXN1bHRHZW9tZXRyeShlKX19c3RhdGljIHByZWNpc2lvblNjYWxlRmFjdG9yKHQsZSxuKXtjb25zdCBzPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLGk9TS5tYXgoTWF0aC5hYnMocy5nZXRNYXhYKCkpLE1hdGguYWJzKHMuZ2V0TWF4WSgpKSxNYXRoLmFicyhzLmdldE1pblgoKSksTWF0aC5hYnMocy5nZXRNaW5ZKCkpKSsyKihlPjA/ZTowKSxyPW4tTWF0aC50cnVuYyhNYXRoLmxvZyhpKS9NYXRoLmxvZygxMCkrMSk7cmV0dXJuIE1hdGgucG93KDEwLHIpfWJ1ZmZlckZpeGVkUHJlY2lzaW9uKHQpe2NvbnN0IGU9bmV3IGtzKG5ldyBDaShuZXcga3QoMSkpLHQuZ2V0U2NhbGUoKSksbj1uZXcgcGkodGhpcy5fYnVmUGFyYW1zKTtuLnNldFdvcmtpbmdQcmVjaXNpb25Nb2RlbCh0KSxuLnNldE5vZGVyKGUpLHRoaXMuX3Jlc3VsdEdlb21ldHJ5PW4uYnVmZmVyKHRoaXMuX2FyZ0dlb20sdGhpcy5fZGlzdGFuY2UpfWJ1ZmZlclJlZHVjZWRQcmVjaXNpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKGxldCB0PVNpLk1BWF9QUkVDSVNJT05fRElHSVRTO3Q+PTA7dC0tKXt0cnl7dGhpcy5idWZmZXJSZWR1Y2VkUHJlY2lzaW9uKHQpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIFduKSl0aHJvdyB0O3RoaXMuX3NhdmVFeGNlcHRpb249dH1pZihudWxsIT09dGhpcy5fcmVzdWx0R2VvbWV0cnkpcmV0dXJuIG51bGx9dGhyb3cgdGhpcy5fc2F2ZUV4Y2VwdGlvbn1pZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1TaS5wcmVjaXNpb25TY2FsZUZhY3Rvcih0aGlzLl9hcmdHZW9tLHRoaXMuX2Rpc3RhbmNlLHQpLG49bmV3IGt0KGUpO3RoaXMuYnVmZmVyRml4ZWRQcmVjaXNpb24obil9fWNvbXB1dGVHZW9tZXRyeSgpe2lmKHRoaXMuYnVmZmVyT3JpZ2luYWxQcmVjaXNpb24oKSxudWxsIT09dGhpcy5fcmVzdWx0R2VvbWV0cnkpcmV0dXJuIG51bGw7Y29uc3QgdD10aGlzLl9hcmdHZW9tLmdldEZhY3RvcnkoKS5nZXRQcmVjaXNpb25Nb2RlbCgpO3QuZ2V0VHlwZSgpPT09a3QuRklYRUQ/dGhpcy5idWZmZXJGaXhlZFByZWNpc2lvbih0KTp0aGlzLmJ1ZmZlclJlZHVjZWRQcmVjaXNpb24oKX1zZXRRdWFkcmFudFNlZ21lbnRzKHQpe3RoaXMuX2J1ZlBhcmFtcy5zZXRRdWFkcmFudFNlZ21lbnRzKHQpfWJ1ZmZlck9yaWdpbmFsUHJlY2lzaW9uKCl7dHJ5e2NvbnN0IHQ9bmV3IHBpKHRoaXMuX2J1ZlBhcmFtcyk7dGhpcy5fcmVzdWx0R2VvbWV0cnk9dC5idWZmZXIodGhpcy5fYXJnR2VvbSx0aGlzLl9kaXN0YW5jZSl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgYykpdGhyb3cgdDt0aGlzLl9zYXZlRXhjZXB0aW9uPXR9fWdldFJlc3VsdEdlb21ldHJ5KHQpe3JldHVybiB0aGlzLl9kaXN0YW5jZT10LHRoaXMuY29tcHV0ZUdlb21ldHJ5KCksdGhpcy5fcmVzdWx0R2VvbWV0cnl9c2V0RW5kQ2FwU3R5bGUodCl7dGhpcy5fYnVmUGFyYW1zLnNldEVuZENhcFN0eWxlKHQpfWdldENsYXNzKCl7cmV0dXJuIFNpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1TaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9hcmdHZW9tPW51bGwsdGhpcy5fZGlzdGFuY2U9bnVsbCx0aGlzLl9idWZQYXJhbXM9bmV3IGpzLHRoaXMuX3Jlc3VsdEdlb21ldHJ5PW51bGwsdGhpcy5fc2F2ZUV4Y2VwdGlvbj1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9hcmdHZW9tPXR9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fYXJnR2VvbT10LHRoaXMuX2J1ZlBhcmFtcz1lfX0sU2kuQ0FQX1JPVU5EPWpzLkNBUF9ST1VORCxTaS5DQVBfQlVUVD1qcy5DQVBfRkxBVCxTaS5DQVBfRkxBVD1qcy5DQVBfRkxBVCxTaS5DQVBfU1FVQVJFPWpzLkNBUF9TUVVBUkUsU2kuTUFYX1BSRUNJU0lPTl9ESUdJVFM9MTI7dmFyIHdpPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLEJ1ZmZlck9wOlNpLEJ1ZmZlclBhcmFtZXRlcnM6anN9KTtjbGFzcyBMaXtjb25zdHJ1Y3Rvcigpe0xpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNJbnNpZGVBcmVhKCl7cmV0dXJuIHRoaXMuX3NlZ0luZGV4PT09TGkuSU5TSURFX0FSRUF9Z2V0Q29vcmRpbmF0ZSgpe3JldHVybiB0aGlzLl9wdH1nZXRHZW9tZXRyeUNvbXBvbmVudCgpe3JldHVybiB0aGlzLl9jb21wb25lbnR9Z2V0U2VnbWVudEluZGV4KCl7cmV0dXJuIHRoaXMuX3NlZ0luZGV4fWdldENsYXNzKCl7cmV0dXJuIExpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1MaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9jb21wb25lbnQ9bnVsbCx0aGlzLl9zZWdJbmRleD1udWxsLHRoaXMuX3B0PW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO0xpLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxMaS5JTlNJREVfQVJFQSxlKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLl9jb21wb25lbnQ9dCx0aGlzLl9zZWdJbmRleD1lLHRoaXMuX3B0PW59fSxMaS5JTlNJREVfQVJFQT0tMTtjbGFzcyBUaXtjb25zdHJ1Y3Rvcigpe1RpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGdldExvY2F0aW9ucyh0KXtjb25zdCBlPW5ldyB4O3JldHVybiB0LmFwcGx5KG5ldyBUaShlKSksZX1maWx0ZXIodCl7KHQgaW5zdGFuY2VvZiBQdHx8dCBpbnN0YW5jZW9mIFR0fHx0IGluc3RhbmNlb2YgYnQpJiZ0aGlzLl9sb2NhdGlvbnMuYWRkKG5ldyBMaSh0LDAsdC5nZXRDb29yZGluYXRlKCkpKX1nZXRDbGFzcygpe3JldHVybiBUaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bZ3RdfX1UaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9sb2NhdGlvbnM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9sb2NhdGlvbnM9dH07Y2xhc3MgUml7Y29uc3RydWN0b3IoKXtSaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBkaXN0YW5jZSh0LGUpe3JldHVybiBuZXcgUmkodCxlKS5kaXN0YW5jZSgpfXN0YXRpYyBpc1dpdGhpbkRpc3RhbmNlKHQsZSxuKXtyZXR1cm4hKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmRpc3RhbmNlKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT5uKSYmbmV3IFJpKHQsZSxuKS5kaXN0YW5jZSgpPD1ufXN0YXRpYyBuZWFyZXN0UG9pbnRzKHQsZSl7cmV0dXJuIG5ldyBSaSh0LGUpLm5lYXJlc3RQb2ludHMoKX1jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PW5ldyBBcnJheSgyKS5maWxsKG51bGwpO2lmKHRoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UoMCx0KSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGw7dGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgxLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dGhpcy5fZ2VvbVt0XTtpZihuLmdldERpbWVuc2lvbigpPDIpcmV0dXJuIG51bGw7Y29uc3Qgcz0xLXQsaT1OZS5nZXRQb2x5Z29ucyhuKTtpZihpLnNpemUoKT4wKXtjb25zdCBuPVRpLmdldExvY2F0aW9ucyh0aGlzLl9nZW9tW3NdKTtpZih0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKG4saSxlKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bc109ZVswXSx0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uW3RdPWVbMV0sbnVsbH19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFycmF5JiZfKGFyZ3VtZW50c1swXSxtKSYmXyhhcmd1bWVudHNbMV0sbSkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2ZvcihsZXQgcz0wO3M8dC5zaXplKCk7cysrKXtjb25zdCBpPXQuZ2V0KHMpO2ZvcihsZXQgdD0wO3Q8ZS5zaXplKCk7dCsrKWlmKHRoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UoaSxlLmdldCh0KSxuKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fWVsc2UgaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBBcnJheSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBMaSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBidCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz10LmdldENvb3JkaW5hdGUoKTtpZihuZS5FWFRFUklPUiE9PXRoaXMuX3B0TG9jYXRvci5sb2NhdGUocyxlKSlyZXR1cm4gdGhpcy5fbWluRGlzdGFuY2U9MCxuWzBdPXQsblsxXT1uZXcgTGkoZSxzKSxudWxsfX1jb21wdXRlTWluRGlzdGFuY2VMaW5lc1BvaW50cyh0LGUsbil7Zm9yKGxldCBzPTA7czx0LnNpemUoKTtzKyspe2NvbnN0IGk9dC5nZXQocyk7Zm9yKGxldCB0PTA7dDxlLnNpemUoKTt0Kyspe2NvbnN0IHM9ZS5nZXQodCk7aWYodGhpcy5jb21wdXRlTWluRGlzdGFuY2UoaSxzLG4pLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19fWNvbXB1dGVGYWNldERpc3RhbmNlKCl7Y29uc3QgdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKSxlPXhlLmdldExpbmVzKHRoaXMuX2dlb21bMF0pLG49eGUuZ2V0TGluZXModGhpcy5fZ2VvbVsxXSkscz1JZS5nZXRQb2ludHModGhpcy5fZ2VvbVswXSksaT1JZS5nZXRQb2ludHModGhpcy5fZ2VvbVsxXSk7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlTGluZXMoZSxuLHQpLHRoaXMudXBkYXRlTWluRGlzdGFuY2UodCwhMSksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlP251bGw6KHRbMF09bnVsbCx0WzFdPW51bGwsdGhpcy5jb21wdXRlTWluRGlzdGFuY2VMaW5lc1BvaW50cyhlLGksdCksdGhpcy51cGRhdGVNaW5EaXN0YW5jZSh0LCExKSx0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2U/bnVsbDoodFswXT1udWxsLHRbMV09bnVsbCx0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzUG9pbnRzKG4scyx0KSx0aGlzLnVwZGF0ZU1pbkRpc3RhbmNlKHQsITApLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZT9udWxsOih0WzBdPW51bGwsdFsxXT1udWxsLHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlUG9pbnRzKHMsaSx0KSx2b2lkIHRoaXMudXBkYXRlTWluRGlzdGFuY2UodCwhMSkpKSl9bmVhcmVzdExvY2F0aW9ucygpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZSgpLHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb259dXBkYXRlTWluRGlzdGFuY2UodCxlKXtpZihudWxsPT09dFswXSlyZXR1cm4gbnVsbDtlPyh0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uWzBdPXRbMV0sdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblsxXT10WzBdKToodGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblswXT10WzBdLHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bMV09dFsxXSl9bmVhcmVzdFBvaW50cygpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZSgpLFt0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uWzBdLmdldENvb3JkaW5hdGUoKSx0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uWzFdLmdldENvb3JkaW5hdGUoKV19Y29tcHV0ZU1pbkRpc3RhbmNlKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKG51bGwhPT10aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uKXJldHVybiBudWxsO2lmKHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb249bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgpLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbDt0aGlzLmNvbXB1dGVGYWNldERpc3RhbmNlKCl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFycmF5JiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFR0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIFB0KXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZih0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5kaXN0YW5jZShlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk+dGhpcy5fbWluRGlzdGFuY2UpcmV0dXJuIG51bGw7Y29uc3Qgcz10LmdldENvb3JkaW5hdGVzKCksaT1lLmdldENvb3JkaW5hdGUoKTtmb3IobGV0IHI9MDtyPHMubGVuZ3RoLTE7cisrKXtjb25zdCBvPUQucG9pbnRUb1NlZ21lbnQoaSxzW3JdLHNbcisxXSk7aWYobzx0aGlzLl9taW5EaXN0YW5jZSl7dGhpcy5fbWluRGlzdGFuY2U9bztjb25zdCBsPW5ldyBlZShzW3JdLHNbcisxXSkuY2xvc2VzdFBvaW50KGkpO25bMF09bmV3IExpKHQscixsKSxuWzFdPW5ldyBMaShlLDAsaSl9aWYodGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX1lbHNlIGlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQXJyYXkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgVHQmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgVHQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmRpc3RhbmNlKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT50aGlzLl9taW5EaXN0YW5jZSlyZXR1cm4gbnVsbDtjb25zdCBzPXQuZ2V0Q29vcmRpbmF0ZXMoKSxpPWUuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IHI9MDtyPHMubGVuZ3RoLTE7cisrKWZvcihsZXQgbz0wO288aS5sZW5ndGgtMTtvKyspe2NvbnN0IGw9RC5zZWdtZW50VG9TZWdtZW50KHNbcl0sc1tyKzFdLGlbb10saVtvKzFdKTtpZihsPHRoaXMuX21pbkRpc3RhbmNlKXt0aGlzLl9taW5EaXN0YW5jZT1sO2NvbnN0IGE9bmV3IGVlKHNbcl0sc1tyKzFdKSxjPW5ldyBlZShpW29dLGlbbysxXSksaD1hLmNsb3Nlc3RQb2ludHMoYyk7blswXT1uZXcgTGkodCxyLGhbMF0pLG5bMV09bmV3IExpKGUsbyxoWzFdKX1pZih0aGlzLl9taW5EaXN0YW5jZTw9dGhpcy5fdGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fX1jb21wdXRlTWluRGlzdGFuY2VQb2ludHModCxlLG4pe2ZvcihsZXQgcz0wO3M8dC5zaXplKCk7cysrKXtjb25zdCBpPXQuZ2V0KHMpO2ZvcihsZXQgdD0wO3Q8ZS5zaXplKCk7dCsrKXtjb25zdCBzPWUuZ2V0KHQpLHI9aS5nZXRDb29yZGluYXRlKCkuZGlzdGFuY2Uocy5nZXRDb29yZGluYXRlKCkpO2lmKHI8dGhpcy5fbWluRGlzdGFuY2UmJih0aGlzLl9taW5EaXN0YW5jZT1yLG5bMF09bmV3IExpKGksMCxpLmdldENvb3JkaW5hdGUoKSksblsxXT1uZXcgTGkocywwLHMuZ2V0Q29vcmRpbmF0ZSgpKSksdGhpcy5fbWluRGlzdGFuY2U8PXRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX19ZGlzdGFuY2UoKXtpZihudWxsPT09dGhpcy5fZ2VvbVswXXx8bnVsbD09PXRoaXMuX2dlb21bMV0pdGhyb3cgbmV3IG4oXCJudWxsIGdlb21ldHJpZXMgYXJlIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJuIHRoaXMuX2dlb21bMF0uaXNFbXB0eSgpfHx0aGlzLl9nZW9tWzFdLmlzRW1wdHkoKT8wOih0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZSgpLHRoaXMuX21pbkRpc3RhbmNlKX1jb21wdXRlTWluRGlzdGFuY2VMaW5lcyh0LGUsbil7Zm9yKGxldCBzPTA7czx0LnNpemUoKTtzKyspe2NvbnN0IGk9dC5nZXQocyk7Zm9yKGxldCB0PTA7dDxlLnNpemUoKTt0Kyspe2NvbnN0IHM9ZS5nZXQodCk7aWYodGhpcy5jb21wdXRlTWluRGlzdGFuY2UoaSxzLG4pLHRoaXMuX21pbkRpc3RhbmNlPD10aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19fWdldENsYXNzKCl7cmV0dXJuIFJpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1SaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9nZW9tPW51bGwsdGhpcy5fdGVybWluYXRlRGlzdGFuY2U9MCx0aGlzLl9wdExvY2F0b3I9bmV3IF9uLHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb249bnVsbCx0aGlzLl9taW5EaXN0YW5jZT1pLk1BWF9WQUxVRSwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07UmkuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsMCl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fZ2VvbT1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLl9nZW9tWzBdPXQsdGhpcy5fZ2VvbVsxXT1lLHRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlPW59fTt2YXIgUGk9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsRGlzdGFuY2VPcDpSaX0pO2NsYXNzIHZpe2NvbnN0cnVjdG9yKCl7dmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDb29yZGluYXRlcygpe2lmKG51bGw9PT10aGlzLl9jb29yZGluYXRlcyl7bGV0IHQ9MCxlPTA7Y29uc3Qgbj1uZXcgSTtmb3IobGV0IHM9dGhpcy5fZGlyZWN0ZWRFZGdlcy5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgaT1zLm5leHQoKTtpLmdldEVkZ2VEaXJlY3Rpb24oKT90Kys6ZSsrLG4uYWRkKGkuZ2V0RWRnZSgpLmdldExpbmUoKS5nZXRDb29yZGluYXRlcygpLCExLGkuZ2V0RWRnZURpcmVjdGlvbigpKX10aGlzLl9jb29yZGluYXRlcz1uLnRvQ29vcmRpbmF0ZUFycmF5KCksZT50JiZYLnJldmVyc2UodGhpcy5fY29vcmRpbmF0ZXMpfXJldHVybiB0aGlzLl9jb29yZGluYXRlc310b0xpbmVTdHJpbmcoKXtyZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSl9YWRkKHQpe3RoaXMuX2RpcmVjdGVkRWRnZXMuYWRkKHQpfWdldENsYXNzKCl7cmV0dXJuIHZpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX12aS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9mYWN0b3J5PW51bGwsdGhpcy5fZGlyZWN0ZWRFZGdlcz1uZXcgeCx0aGlzLl9jb29yZGluYXRlcz1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2ZhY3Rvcnk9dH07Y2xhc3MgT2l7Y29uc3RydWN0b3IoKXtPaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBnZXRDb21wb25lbnRXaXRoVmlzaXRlZFN0YXRlKHQsZSl7Zm9yKDt0Lmhhc05leHQoKTspe2NvbnN0IG49dC5uZXh0KCk7aWYobi5pc1Zpc2l0ZWQoKT09PWUpcmV0dXJuIG59cmV0dXJuIG51bGx9c3RhdGljIHNldFZpc2l0ZWQodCxlKXtmb3IoO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuc2V0VmlzaXRlZChlKX19c3RhdGljIHNldE1hcmtlZCh0LGUpe2Zvcig7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5zZXRNYXJrZWQoZSl9fXNldFZpc2l0ZWQodCl7dGhpcy5faXNWaXNpdGVkPXR9aXNNYXJrZWQoKXtyZXR1cm4gdGhpcy5faXNNYXJrZWR9c2V0RGF0YSh0KXt0aGlzLl9kYXRhPXR9Z2V0RGF0YSgpe3JldHVybiB0aGlzLl9kYXRhfXNldE1hcmtlZCh0KXt0aGlzLl9pc01hcmtlZD10fWdldENvbnRleHQoKXtyZXR1cm4gdGhpcy5fZGF0YX1pc1Zpc2l0ZWQoKXtyZXR1cm4gdGhpcy5faXNWaXNpdGVkfXNldENvbnRleHQodCl7dGhpcy5fZGF0YT10fWdldENsYXNzKCl7cmV0dXJuIE9pfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1PaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pc01hcmtlZD0hMSx0aGlzLl9pc1Zpc2l0ZWQ9ITEsdGhpcy5fZGF0YT1udWxsfTtjbGFzcyBiaSBleHRlbmRzIE9pe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxiaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyB0b0VkZ2VzKHQpe2NvbnN0IGU9bmV3IHg7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspZS5hZGQobi5uZXh0KCkuX3BhcmVudEVkZ2UpO3JldHVybiBlfWlzUmVtb3ZlZCgpe3JldHVybiBudWxsPT09dGhpcy5fcGFyZW50RWRnZX1jb21wYXJlRGlyZWN0aW9uKHQpe3JldHVybiB0aGlzLl9xdWFkcmFudD50Ll9xdWFkcmFudD8xOnRoaXMuX3F1YWRyYW50PHQuX3F1YWRyYW50Py0xOnYuaW5kZXgodC5fcDAsdC5fcDEsdGhpcy5fcDEpfWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fZnJvbS5nZXRDb29yZGluYXRlKCl9cHJpbnQodCl7Y29uc3QgZT10aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpLG49ZS5sYXN0SW5kZXhPZihcIi5cIikscz1lLnN1YnN0cmluZyhuKzEpO3QucHJpbnQoXCIgIFwiK3MrXCI6IFwiK3RoaXMuX3AwK1wiIC0gXCIrdGhpcy5fcDErXCIgXCIrdGhpcy5fcXVhZHJhbnQrXCI6XCIrdGhpcy5fYW5nbGUpfWdldERpcmVjdGlvblB0KCl7cmV0dXJuIHRoaXMuX3AxfWdldEFuZ2xlKCl7cmV0dXJuIHRoaXMuX2FuZ2xlfWNvbXBhcmVUbyh0KXtjb25zdCBlPXQ7cmV0dXJuIHRoaXMuY29tcGFyZURpcmVjdGlvbihlKX1nZXRGcm9tTm9kZSgpe3JldHVybiB0aGlzLl9mcm9tfWdldFN5bSgpe3JldHVybiB0aGlzLl9zeW19c2V0RWRnZSh0KXt0aGlzLl9wYXJlbnRFZGdlPXR9cmVtb3ZlKCl7dGhpcy5fc3ltPW51bGwsdGhpcy5fcGFyZW50RWRnZT1udWxsfWdldEVkZ2UoKXtyZXR1cm4gdGhpcy5fcGFyZW50RWRnZX1nZXRRdWFkcmFudCgpe3JldHVybiB0aGlzLl9xdWFkcmFudH1zZXRTeW0odCl7dGhpcy5fc3ltPXR9Z2V0VG9Ob2RlKCl7cmV0dXJuIHRoaXMuX3RvfWdldEVkZ2VEaXJlY3Rpb24oKXtyZXR1cm4gdGhpcy5fZWRnZURpcmVjdGlvbn1nZXRDbGFzcygpe3JldHVybiBiaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bcl19fWJpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX3BhcmVudEVkZ2U9bnVsbCx0aGlzLl9mcm9tPW51bGwsdGhpcy5fdG89bnVsbCx0aGlzLl9wMD1udWxsLHRoaXMuX3AxPW51bGwsdGhpcy5fc3ltPW51bGwsdGhpcy5fZWRnZURpcmVjdGlvbj1udWxsLHRoaXMuX3F1YWRyYW50PW51bGwsdGhpcy5fYW5nbGU9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107dGhpcy5fZnJvbT10LHRoaXMuX3RvPWUsdGhpcy5fZWRnZURpcmVjdGlvbj1zLHRoaXMuX3AwPXQuZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuX3AxPW47Y29uc3QgaT10aGlzLl9wMS54LXRoaXMuX3AwLngscj10aGlzLl9wMS55LXRoaXMuX3AwLnk7dGhpcy5fcXVhZHJhbnQ9SW4ucXVhZHJhbnQoaSxyKSx0aGlzLl9hbmdsZT1NYXRoLmF0YW4yKHIsaSl9fTtjbGFzcyBNaSBleHRlbmRzIGJpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxNaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldE5leHQoKXtyZXR1cm4gMiE9PXRoaXMuZ2V0VG9Ob2RlKCkuZ2V0RGVncmVlKCk/bnVsbDp0aGlzLmdldFRvTm9kZSgpLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5nZXQoMCk9PT10aGlzLmdldFN5bSgpP3RoaXMuZ2V0VG9Ob2RlKCkuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLmdldCgxKToodS5pc1RydWUodGhpcy5nZXRUb05vZGUoKS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuZ2V0KDEpPT09dGhpcy5nZXRTeW0oKSksdGhpcy5nZXRUb05vZGUoKS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuZ2V0KDApKX1nZXRDbGFzcygpe3JldHVybiBNaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19TWkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107YmkuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsbixzKX07Y2xhc3MgRGkgZXh0ZW5kcyBPaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksRGkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pc1JlbW92ZWQoKXtyZXR1cm4gbnVsbD09PXRoaXMuX2RpckVkZ2V9c2V0RGlyZWN0ZWRFZGdlcyh0LGUpe3RoaXMuX2RpckVkZ2U9W3QsZV0sdC5zZXRFZGdlKHRoaXMpLGUuc2V0RWRnZSh0aGlzKSx0LnNldFN5bShlKSxlLnNldFN5bSh0KSx0LmdldEZyb21Ob2RlKCkuYWRkT3V0RWRnZSh0KSxlLmdldEZyb21Ob2RlKCkuYWRkT3V0RWRnZShlKX1nZXREaXJFZGdlKCl7aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fZGlyRWRnZVt0XX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEZpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fZGlyRWRnZVswXS5nZXRGcm9tTm9kZSgpPT09dD90aGlzLl9kaXJFZGdlWzBdOnRoaXMuX2RpckVkZ2VbMV0uZ2V0RnJvbU5vZGUoKT09PXQ/dGhpcy5fZGlyRWRnZVsxXTpudWxsfX1yZW1vdmUoKXt0aGlzLl9kaXJFZGdlPW51bGx9Z2V0T3Bwb3NpdGVOb2RlKHQpe3JldHVybiB0aGlzLl9kaXJFZGdlWzBdLmdldEZyb21Ob2RlKCk9PT10P3RoaXMuX2RpckVkZ2VbMF0uZ2V0VG9Ob2RlKCk6dGhpcy5fZGlyRWRnZVsxXS5nZXRGcm9tTm9kZSgpPT09dD90aGlzLl9kaXJFZGdlWzFdLmdldFRvTm9kZSgpOm51bGx9Z2V0Q2xhc3MoKXtyZXR1cm4gRGl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fURpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2RpckVkZ2U9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5zZXREaXJlY3RlZEVkZ2VzKHQsZSl9fTtjbGFzcyBBaXtjb25zdHJ1Y3Rvcigpe0FpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0TmV4dEVkZ2UodCl7Y29uc3QgZT10aGlzLmdldEluZGV4KHQpO3JldHVybiB0aGlzLl9vdXRFZGdlcy5nZXQodGhpcy5nZXRJbmRleChlKzEpKX1nZXRDb29yZGluYXRlKCl7Y29uc3QgdD10aGlzLml0ZXJhdG9yKCk7cmV0dXJuIHQuaGFzTmV4dCgpP3QubmV4dCgpLmdldENvb3JkaW5hdGUoKTpudWxsfWl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuc29ydEVkZ2VzKCksdGhpcy5fb3V0RWRnZXMuaXRlcmF0b3IoKX1zb3J0RWRnZXMoKXt0aGlzLl9zb3J0ZWR8fChFZS5zb3J0KHRoaXMuX291dEVkZ2VzKSx0aGlzLl9zb3J0ZWQ9ITApfXJlbW92ZSh0KXt0aGlzLl9vdXRFZGdlcy5yZW1vdmUodCl9Z2V0RWRnZXMoKXtyZXR1cm4gdGhpcy5zb3J0RWRnZXMoKSx0aGlzLl9vdXRFZGdlc31nZXROZXh0Q1dFZGdlKHQpe2NvbnN0IGU9dGhpcy5nZXRJbmRleCh0KTtyZXR1cm4gdGhpcy5fb3V0RWRnZXMuZ2V0KHRoaXMuZ2V0SW5kZXgoZS0xKSl9Z2V0SW5kZXgoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIERpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnNvcnRFZGdlcygpO2ZvcihsZXQgZT0wO2U8dGhpcy5fb3V0RWRnZXMuc2l6ZSgpO2UrKyl7aWYodGhpcy5fb3V0RWRnZXMuZ2V0KGUpLmdldEVkZ2UoKT09PXQpcmV0dXJuIGV9cmV0dXJuLTF9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBiaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5zb3J0RWRnZXMoKTtmb3IobGV0IGU9MDtlPHRoaXMuX291dEVkZ2VzLnNpemUoKTtlKyspe2lmKHRoaXMuX291dEVkZ2VzLmdldChlKT09PXQpcmV0dXJuIGV9cmV0dXJuLTF9aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXtsZXQgdD1hcmd1bWVudHNbMF0ldGhpcy5fb3V0RWRnZXMuc2l6ZSgpO3JldHVybiB0PDAmJih0Kz10aGlzLl9vdXRFZGdlcy5zaXplKCkpLHR9fWFkZCh0KXt0aGlzLl9vdXRFZGdlcy5hZGQodCksdGhpcy5fc29ydGVkPSExfWdldERlZ3JlZSgpe3JldHVybiB0aGlzLl9vdXRFZGdlcy5zaXplKCl9Z2V0Q2xhc3MoKXtyZXR1cm4gQWl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUFpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX291dEVkZ2VzPW5ldyB4LHRoaXMuX3NvcnRlZD0hMX07Y2xhc3MgRmkgZXh0ZW5kcyBPaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksRmkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZ2V0RWRnZXNCZXR3ZWVuKHQsZSl7Y29uc3Qgbj1uZXcgSihiaS50b0VkZ2VzKHQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpKSkscz1iaS50b0VkZ2VzKGUuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpKTtyZXR1cm4gbi5yZXRhaW5BbGwocyksbn1pc1JlbW92ZWQoKXtyZXR1cm4gbnVsbD09PXRoaXMuX3B0fWFkZE91dEVkZ2UodCl7dGhpcy5fZGVTdGFyLmFkZCh0KX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3B0fWdldE91dEVkZ2VzKCl7cmV0dXJuIHRoaXMuX2RlU3Rhcn1yZW1vdmUoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLl9wdD1udWxsO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2RlU3Rhci5yZW1vdmUodCl9fWdldEluZGV4KHQpe3JldHVybiB0aGlzLl9kZVN0YXIuZ2V0SW5kZXgodCl9Z2V0RGVncmVlKCl7cmV0dXJuIHRoaXMuX2RlU3Rhci5nZXREZWdyZWUoKX1nZXRDbGFzcygpe3JldHVybiBGaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19RmkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fcHQ9bnVsbCx0aGlzLl9kZVN0YXI9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07RmkuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LG5ldyBBaSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcHQ9dCx0aGlzLl9kZVN0YXI9ZX19O2NsYXNzIEdpIGV4dGVuZHMgRGl7Y29uc3RydWN0b3IoKXtzdXBlcigpLEdpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0TGluZSgpe3JldHVybiB0aGlzLl9saW5lfWdldENsYXNzKCl7cmV0dXJuIEdpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1HaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9saW5lPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZT10fTtjbGFzcyBxaXtjb25zdHJ1Y3Rvcigpe3FpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmluZCh0KXtyZXR1cm4gdGhpcy5fbm9kZU1hcC5nZXQodCl9aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fbm9kZU1hcC52YWx1ZXMoKS5pdGVyYXRvcigpfXJlbW92ZSh0KXtyZXR1cm4gdGhpcy5fbm9kZU1hcC5yZW1vdmUodCl9dmFsdWVzKCl7cmV0dXJuIHRoaXMuX25vZGVNYXAudmFsdWVzKCl9YWRkKHQpe3JldHVybiB0aGlzLl9ub2RlTWFwLnB1dCh0LmdldENvb3JkaW5hdGUoKSx0KSx0fWdldENsYXNzKCl7cmV0dXJuIHFpfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1xaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9ub2RlTWFwPW5ldyBydH07Y2xhc3MgQml7Y29uc3RydWN0b3IoKXtCaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbmROb2Rlc09mRGVncmVlKHQpe2NvbnN0IGU9bmV3IHg7Zm9yKGxldCBuPXRoaXMubm9kZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO3MuZ2V0RGVncmVlKCk9PT10JiZlLmFkZChzKX1yZXR1cm4gZX1kaXJFZGdlSXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fZGlyRWRnZXMuaXRlcmF0b3IoKX1lZGdlSXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fZWRnZXMuaXRlcmF0b3IoKX1yZW1vdmUoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIERpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnJlbW92ZSh0LmdldERpckVkZ2UoMCkpLHRoaXMucmVtb3ZlKHQuZ2V0RGlyRWRnZSgxKSksdGhpcy5fZWRnZXMucmVtb3ZlKHQpLHQucmVtb3ZlKCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGJpKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXQuZ2V0U3ltKCk7bnVsbCE9PWUmJmUuc2V0U3ltKG51bGwpLHQuZ2V0RnJvbU5vZGUoKS5yZW1vdmUodCksdC5yZW1vdmUoKSx0aGlzLl9kaXJFZGdlcy5yZW1vdmUodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEZpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCksbj10LmdldFN5bSgpO251bGwhPT1uJiZ0aGlzLnJlbW92ZShuKSx0aGlzLl9kaXJFZGdlcy5yZW1vdmUodCk7Y29uc3Qgcz10LmdldEVkZ2UoKTtudWxsIT09cyYmdGhpcy5fZWRnZXMucmVtb3ZlKHMpfXRoaXMuX25vZGVNYXAucmVtb3ZlKHQuZ2V0Q29vcmRpbmF0ZSgpKSx0LnJlbW92ZSgpfX1maW5kTm9kZSh0KXtyZXR1cm4gdGhpcy5fbm9kZU1hcC5maW5kKHQpfWdldEVkZ2VzKCl7cmV0dXJuIHRoaXMuX2VkZ2VzfW5vZGVJdGVyYXRvcigpe3JldHVybiB0aGlzLl9ub2RlTWFwLml0ZXJhdG9yKCl9Y29udGFpbnMoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIERpKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5fZWRnZXMuY29udGFpbnModCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBiaSl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2RpckVkZ2VzLmNvbnRhaW5zKHQpfX1hZGQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEZpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9ub2RlTWFwLmFkZCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRGkpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2VkZ2VzLmFkZCh0KSx0aGlzLmFkZCh0LmdldERpckVkZ2UoMCkpLHRoaXMuYWRkKHQuZ2V0RGlyRWRnZSgxKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGJpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9kaXJFZGdlcy5hZGQodCl9fWdldE5vZGVzKCl7cmV0dXJuIHRoaXMuX25vZGVNYXAudmFsdWVzKCl9Z2V0Q2xhc3MoKXtyZXR1cm4gQml9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUJpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2VkZ2VzPW5ldyBKLHRoaXMuX2RpckVkZ2VzPW5ldyBKLHRoaXMuX25vZGVNYXA9bmV3IHFpfTtjbGFzcyBWaSBleHRlbmRzIEJpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxWaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWFkZEVkZ2UodCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3QgZT1YLnJlbW92ZVJlcGVhdGVkUG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7aWYoZS5sZW5ndGg8PTEpcmV0dXJuIG51bGw7Y29uc3Qgbj1lWzBdLHM9ZVtlLmxlbmd0aC0xXSxpPXRoaXMuZ2V0Tm9kZShuKSxyPXRoaXMuZ2V0Tm9kZShzKSxvPW5ldyBNaShpLHIsZVsxXSwhMCksbD1uZXcgTWkocixpLGVbZS5sZW5ndGgtMl0sITEpLGE9bmV3IEdpKHQpO2Euc2V0RGlyZWN0ZWRFZGdlcyhvLGwpLHRoaXMuYWRkKGEpfWdldE5vZGUodCl7bGV0IGU9dGhpcy5maW5kTm9kZSh0KTtyZXR1cm4gbnVsbD09PWUmJihlPW5ldyBGaSh0KSx0aGlzLmFkZChlKSksZX1nZXRDbGFzcygpe3JldHVybiBWaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19VmkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyB6aXtjb25zdHJ1Y3Rvcigpe3ppLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9YnVpbGRFZGdlU3RyaW5nc0ZvclVucHJvY2Vzc2VkTm9kZXMoKXtmb3IobGV0IHQ9dGhpcy5fZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtlLmlzTWFya2VkKCl8fCh1LmlzVHJ1ZSgyPT09ZS5nZXREZWdyZWUoKSksdGhpcy5idWlsZEVkZ2VTdHJpbmdzU3RhcnRpbmdBdChlKSxlLnNldE1hcmtlZCghMCkpfX1idWlsZEVkZ2VTdHJpbmdzRm9yTm9uRGVncmVlMk5vZGVzKCl7Zm9yKGxldCB0PXRoaXMuX2dyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7MiE9PWUuZ2V0RGVncmVlKCkmJih0aGlzLmJ1aWxkRWRnZVN0cmluZ3NTdGFydGluZ0F0KGUpLGUuc2V0TWFya2VkKCEwKSl9fWJ1aWxkRWRnZVN0cmluZ3NGb3JPYnZpb3VzU3RhcnROb2Rlcygpe3RoaXMuYnVpbGRFZGdlU3RyaW5nc0Zvck5vbkRlZ3JlZTJOb2RlcygpfWdldE1lcmdlZExpbmVTdHJpbmdzKCl7cmV0dXJuIHRoaXMubWVyZ2UoKSx0aGlzLl9tZXJnZWRMaW5lU3RyaW5nc31idWlsZEVkZ2VTdHJpbmdzU3RhcnRpbmdBdCh0KXtmb3IobGV0IGU9dC5nZXRPdXRFZGdlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3QuZ2V0RWRnZSgpLmlzTWFya2VkKCl8fHRoaXMuX2VkZ2VTdHJpbmdzLmFkZCh0aGlzLmJ1aWxkRWRnZVN0cmluZ1N0YXJ0aW5nV2l0aCh0KSl9fW1lcmdlKCl7aWYobnVsbCE9PXRoaXMuX21lcmdlZExpbmVTdHJpbmdzKXJldHVybiBudWxsO09pLnNldE1hcmtlZCh0aGlzLl9ncmFwaC5ub2RlSXRlcmF0b3IoKSwhMSksT2kuc2V0TWFya2VkKHRoaXMuX2dyYXBoLmVkZ2VJdGVyYXRvcigpLCExKSx0aGlzLl9lZGdlU3RyaW5ncz1uZXcgeCx0aGlzLmJ1aWxkRWRnZVN0cmluZ3NGb3JPYnZpb3VzU3RhcnROb2RlcygpLHRoaXMuYnVpbGRFZGdlU3RyaW5nc0Zvcklzb2xhdGVkTG9vcHMoKSx0aGlzLl9tZXJnZWRMaW5lU3RyaW5ncz1uZXcgeDtmb3IobGV0IHQ9dGhpcy5fZWRnZVN0cmluZ3MuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7dGhpcy5fbWVyZ2VkTGluZVN0cmluZ3MuYWRkKGUudG9MaW5lU3RyaW5nKCkpfX1hZGRMaW5lU3RyaW5nKHQpe251bGw9PT10aGlzLl9mYWN0b3J5JiYodGhpcy5fZmFjdG9yeT10LmdldEZhY3RvcnkoKSksdGhpcy5fZ3JhcGguYWRkRWRnZSh0KX1idWlsZEVkZ2VTdHJpbmdTdGFydGluZ1dpdGgodCl7Y29uc3QgZT1uZXcgdmkodGhpcy5fZmFjdG9yeSk7bGV0IG49dDtkb3tlLmFkZChuKSxuLmdldEVkZ2UoKS5zZXRNYXJrZWQoITApLG49bi5nZXROZXh0KCl9d2hpbGUobnVsbCE9PW4mJm4hPT10KTtyZXR1cm4gZX1hZGQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpO24gaW5zdGFuY2VvZiBUdCYmdGhpcy5hZGRMaW5lU3RyaW5nKG4pfX1lbHNlIGlmKF8oYXJndW1lbnRzWzBdLGYpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9tZXJnZWRMaW5lU3RyaW5ncz1udWxsO2ZvcihsZXQgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3RoaXMuYWRkKHQpfX19YnVpbGRFZGdlU3RyaW5nc0Zvcklzb2xhdGVkTG9vcHMoKXt0aGlzLmJ1aWxkRWRnZVN0cmluZ3NGb3JVbnByb2Nlc3NlZE5vZGVzKCl9Z2V0Q2xhc3MoKXtyZXR1cm4geml9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXppLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2dyYXBoPW5ldyBWaSx0aGlzLl9tZXJnZWRMaW5lU3RyaW5ncz1udWxsLHRoaXMuX2ZhY3Rvcnk9bnVsbCx0aGlzLl9lZGdlU3RyaW5ncz1udWxsfTtjbGFzcyBZaXtjb25zdHJ1Y3Rvcigpe1lpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZGlyRWRnZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX2RpckVkZ2VzLml0ZXJhdG9yKCl9ZWRnZUl0ZXJhdG9yKCl7cmV0dXJuIHRoaXMuX2VkZ2VzLml0ZXJhdG9yKCl9Z2V0UGFyZW50KCl7cmV0dXJuIHRoaXMuX3BhcmVudEdyYXBofW5vZGVJdGVyYXRvcigpe3JldHVybiB0aGlzLl9ub2RlTWFwLml0ZXJhdG9yKCl9Y29udGFpbnModCl7cmV0dXJuIHRoaXMuX2VkZ2VzLmNvbnRhaW5zKHQpfWFkZCh0KXtpZih0aGlzLl9lZGdlcy5jb250YWlucyh0KSlyZXR1cm4gbnVsbDt0aGlzLl9lZGdlcy5hZGQodCksdGhpcy5fZGlyRWRnZXMuYWRkKHQuZ2V0RGlyRWRnZSgwKSksdGhpcy5fZGlyRWRnZXMuYWRkKHQuZ2V0RGlyRWRnZSgxKSksdGhpcy5fbm9kZU1hcC5hZGQodC5nZXREaXJFZGdlKDApLmdldEZyb21Ob2RlKCkpLHRoaXMuX25vZGVNYXAuYWRkKHQuZ2V0RGlyRWRnZSgxKS5nZXRGcm9tTm9kZSgpKX1nZXRDbGFzcygpe3JldHVybiBZaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19WWkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcGFyZW50R3JhcGg9bnVsbCx0aGlzLl9lZGdlcz1uZXcgSix0aGlzLl9kaXJFZGdlcz1uZXcgeCx0aGlzLl9ub2RlTWFwPW5ldyBxaTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wYXJlbnRHcmFwaD10fTtjbGFzcyBVaXtjb25zdHJ1Y3Rvcigpe1VpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9YWRkUmVhY2hhYmxlKHQsZSl7Y29uc3Qgbj1uZXcgb247Zm9yKG4uYWRkKHQpOyFuLmVtcHR5KCk7KXtjb25zdCB0PW4ucG9wKCk7dGhpcy5hZGRFZGdlcyh0LG4sZSl9fWZpbmRTdWJncmFwaCh0KXtjb25zdCBlPW5ldyBZaSh0aGlzLl9ncmFwaCk7cmV0dXJuIHRoaXMuYWRkUmVhY2hhYmxlKHQsZSksZX1nZXRDb25uZWN0ZWRTdWJncmFwaHMoKXtjb25zdCB0PW5ldyB4O09pLnNldFZpc2l0ZWQodGhpcy5fZ3JhcGgubm9kZUl0ZXJhdG9yKCksITEpO2ZvcihsZXQgZT10aGlzLl9ncmFwaC5lZGdlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkuZ2V0RGlyRWRnZSgwKS5nZXRGcm9tTm9kZSgpO24uaXNWaXNpdGVkKCl8fHQuYWRkKHRoaXMuZmluZFN1YmdyYXBoKG4pKX1yZXR1cm4gdH1hZGRFZGdlcyh0LGUsbil7dC5zZXRWaXNpdGVkKCEwKTtmb3IobGV0IHM9dC5nZXRPdXRFZGdlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO24uYWRkKHQuZ2V0RWRnZSgpKTtjb25zdCBpPXQuZ2V0VG9Ob2RlKCk7aS5pc1Zpc2l0ZWQoKXx8ZS5wdXNoKGkpfX1nZXRDbGFzcygpe3JldHVybiBVaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19VWkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZ3JhcGg9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9ncmFwaD10fTtjbGFzcyBraXtjb25zdHJ1Y3Rvcigpe2tpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGZpbmRVbnZpc2l0ZWRCZXN0T3JpZW50ZWRERSh0KXtsZXQgZT1udWxsLG49bnVsbDtmb3IobGV0IHM9dC5nZXRPdXRFZGdlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO3QuZ2V0RWRnZSgpLmlzVmlzaXRlZCgpfHwobj10LHQuZ2V0RWRnZURpcmVjdGlvbigpJiYoZT10KSl9cmV0dXJuIG51bGwhPT1lP2U6bn1zdGF0aWMgZmluZExvd2VzdERlZ3JlZU5vZGUodCl7bGV0IGU9TC5NQVhfVkFMVUUsbj1udWxsO2ZvcihsZXQgcz10Lm5vZGVJdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTsobnVsbD09PW58fHQuZ2V0RGVncmVlKCk8ZSkmJihlPXQuZ2V0RGVncmVlKCksbj10KX1yZXR1cm4gbn1zdGF0aWMgaXNTZXF1ZW5jZWQodCl7aWYoISh0IGluc3RhbmNlb2YgZnQpKXJldHVybiEwO2NvbnN0IGU9dCxuPW5ldyBhdDtsZXQgcz1udWxsO2NvbnN0IGk9bmV3IHg7Zm9yKGxldCB0PTA7dDxlLmdldE51bUdlb21ldHJpZXMoKTt0Kyspe2NvbnN0IHI9ZS5nZXRHZW9tZXRyeU4odCksbz1yLmdldENvb3JkaW5hdGVOKDApLGw9ci5nZXRDb29yZGluYXRlTihyLmdldE51bVBvaW50cygpLTEpO2lmKG4uY29udGFpbnMobykpcmV0dXJuITE7aWYobi5jb250YWlucyhsKSlyZXR1cm4hMTtudWxsIT09cyYmKG8uZXF1YWxzKHMpfHwobi5hZGRBbGwoaSksaS5jbGVhcigpKSksaS5hZGQobyksaS5hZGQobCkscz1sfXJldHVybiEwfXN0YXRpYyByZXZlcnNlKHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlcygpLG49bmV3IEFycmF5KGUubGVuZ3RoKS5maWxsKG51bGwpLHM9ZS5sZW5ndGg7Zm9yKGxldCB0PTA7dDxzO3QrKyluW3MtMS10XT1uZXcgZyhlW3RdKTtyZXR1cm4gdC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhuKX1zdGF0aWMgc2VxdWVuY2UodCl7Y29uc3QgZT1uZXcga2k7cmV0dXJuIGUuYWRkKHQpLGUuZ2V0U2VxdWVuY2VkTGluZVN0cmluZ3MoKX1hZGRMaW5lKHQpe251bGw9PT10aGlzLl9mYWN0b3J5JiYodGhpcy5fZmFjdG9yeT10LmdldEZhY3RvcnkoKSksdGhpcy5fZ3JhcGguYWRkRWRnZSh0KSx0aGlzLl9saW5lQ291bnQrK31oYXNTZXF1ZW5jZSh0KXtsZXQgZT0wO2ZvcihsZXQgbj10Lm5vZGVJdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7bi5uZXh0KCkuZ2V0RGVncmVlKCklMj09MSYmZSsrfXJldHVybiBlPD0yfWNvbXB1dGVTZXF1ZW5jZSgpe2lmKHRoaXMuX2lzUnVuKXJldHVybiBudWxsO3RoaXMuX2lzUnVuPSEwO2NvbnN0IHQ9dGhpcy5maW5kU2VxdWVuY2VzKCk7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7dGhpcy5fc2VxdWVuY2VkR2VvbWV0cnk9dGhpcy5idWlsZFNlcXVlbmNlZEdlb21ldHJ5KHQpLHRoaXMuX2lzU2VxdWVuY2VhYmxlPSEwO2NvbnN0IGU9dGhpcy5fc2VxdWVuY2VkR2VvbWV0cnkuZ2V0TnVtR2VvbWV0cmllcygpO3UuaXNUcnVlKHRoaXMuX2xpbmVDb3VudD09PWUsXCJMaW5lcyB3ZXJlIG1pc3NpbmcgZnJvbSByZXN1bHRcIiksdS5pc1RydWUodGhpcy5fc2VxdWVuY2VkR2VvbWV0cnkgaW5zdGFuY2VvZiBUdHx8dGhpcy5fc2VxdWVuY2VkR2VvbWV0cnkgaW5zdGFuY2VvZiBmdCxcIlJlc3VsdCBpcyBub3QgbGluZWFsXCIpfWZpbmRTZXF1ZW5jZXMoKXtjb25zdCB0PW5ldyB4O2ZvcihsZXQgZT1uZXcgVWkodGhpcy5fZ3JhcGgpLmdldENvbm5lY3RlZFN1YmdyYXBocygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO2lmKCF0aGlzLmhhc1NlcXVlbmNlKG4pKXJldHVybiBudWxsO3tjb25zdCBlPXRoaXMuZmluZFNlcXVlbmNlKG4pO3QuYWRkKGUpfX1yZXR1cm4gdH1hZGRSZXZlcnNlU3VicGF0aCh0LGUsbil7Y29uc3Qgcz10LmdldFRvTm9kZSgpO2xldCBpPW51bGw7Zm9yKDs7KXtlLmFkZCh0LmdldFN5bSgpKSx0LmdldEVkZ2UoKS5zZXRWaXNpdGVkKCEwKSxpPXQuZ2V0RnJvbU5vZGUoKTtjb25zdCBuPWtpLmZpbmRVbnZpc2l0ZWRCZXN0T3JpZW50ZWRERShpKTtpZihudWxsPT09bilicmVhazt0PW4uZ2V0U3ltKCl9biYmdS5pc1RydWUoaT09PXMsXCJwYXRoIG5vdCBjb250aWd1b3VzXCIpfWZpbmRTZXF1ZW5jZSh0KXtPaS5zZXRWaXNpdGVkKHQuZWRnZUl0ZXJhdG9yKCksITEpO2NvbnN0IGU9a2kuZmluZExvd2VzdERlZ3JlZU5vZGUodCkuZ2V0T3V0RWRnZXMoKS5pdGVyYXRvcigpLm5leHQoKS5nZXRTeW0oKSxuPW5ldyBacyxzPW4ubGlzdEl0ZXJhdG9yKCk7Zm9yKHRoaXMuYWRkUmV2ZXJzZVN1YnBhdGgoZSxzLCExKTtzLmhhc1ByZXZpb3VzKCk7KXtjb25zdCB0PXMucHJldmlvdXMoKSxlPWtpLmZpbmRVbnZpc2l0ZWRCZXN0T3JpZW50ZWRERSh0LmdldEZyb21Ob2RlKCkpO251bGwhPT1lJiZ0aGlzLmFkZFJldmVyc2VTdWJwYXRoKGUuZ2V0U3ltKCkscywhMCl9cmV0dXJuIHRoaXMub3JpZW50KG4pfXJldmVyc2UodCl7Y29uc3QgZT1uZXcgWnM7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7ZS5hZGRGaXJzdCh0LmdldFN5bSgpKX1yZXR1cm4gZX1vcmllbnQodCl7Y29uc3QgZT10LmdldCgwKSxuPXQuZ2V0KHQuc2l6ZSgpLTEpLHM9ZS5nZXRGcm9tTm9kZSgpLGk9bi5nZXRUb05vZGUoKTtsZXQgcj0hMTtpZigxPT09cy5nZXREZWdyZWUoKXx8MT09PWkuZ2V0RGVncmVlKCkpe2xldCB0PSExOzE9PT1uLmdldFRvTm9kZSgpLmdldERlZ3JlZSgpJiYhMT09PW4uZ2V0RWRnZURpcmVjdGlvbigpJiYodD0hMCxyPSEwKSwxPT09ZS5nZXRGcm9tTm9kZSgpLmdldERlZ3JlZSgpJiYhMD09PWUuZ2V0RWRnZURpcmVjdGlvbigpJiYodD0hMCxyPSExKSx0fHwxPT09ZS5nZXRGcm9tTm9kZSgpLmdldERlZ3JlZSgpJiYocj0hMCl9cmV0dXJuIHI/dGhpcy5yZXZlcnNlKHQpOnR9YnVpbGRTZXF1ZW5jZWRHZW9tZXRyeSh0KXtjb25zdCBlPW5ldyB4O2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtmb3IobGV0IHQ9bi5uZXh0KCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IG49dC5uZXh0KCkscz1uLmdldEVkZ2UoKS5nZXRMaW5lKCk7bGV0IGk9cztuLmdldEVkZ2VEaXJlY3Rpb24oKXx8cy5pc0Nsb3NlZCgpfHwoaT1raS5yZXZlcnNlKHMpKSxlLmFkZChpKX19cmV0dXJuIDA9PT1lLnNpemUoKT90aGlzLl9mYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZyhuZXcgQXJyYXkoMCkuZmlsbChudWxsKSk6dGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KGUpfWdldFNlcXVlbmNlZExpbmVTdHJpbmdzKCl7cmV0dXJuIHRoaXMuY29tcHV0ZVNlcXVlbmNlKCksdGhpcy5fc2VxdWVuY2VkR2VvbWV0cnl9aXNTZXF1ZW5jZWFibGUoKXtyZXR1cm4gdGhpcy5jb21wdXRlU2VxdWVuY2UoKSx0aGlzLl9pc1NlcXVlbmNlYWJsZX1hZGQoKXtpZihfKGFyZ3VtZW50c1swXSxmKSl7Zm9yKGxldCB0PWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLmFkZChlKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2FyZ3VtZW50c1swXS5hcHBseShuZXcgY2xhc3N7Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0ddfWZpbHRlcih0KXt0IGluc3RhbmNlb2YgVHQmJnRoaXMuYWRkTGluZSh0KX19KX19Z2V0Q2xhc3MoKXtyZXR1cm4ga2l9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWtpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2dyYXBoPW5ldyBWaSx0aGlzLl9mYWN0b3J5PW5ldyBIdCx0aGlzLl9saW5lQ291bnQ9MCx0aGlzLl9pc1J1bj0hMSx0aGlzLl9zZXF1ZW5jZWRHZW9tZXRyeT1udWxsLHRoaXMuX2lzU2VxdWVuY2VhYmxlPSExfTt2YXIgWGk9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsTGluZU1lcmdlcjp6aSxMaW5lU2VxdWVuY2VyOmtpfSk7Y2xhc3MgSGl7Y29uc3RydWN0b3IoKXtIaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpc0Nsb3NlZCh0KXtyZXR1cm4hKHQubGVuZ3RoPD0xKSYmdFswXS5lcXVhbHMyRCh0W3QubGVuZ3RoLTFdKX1zbmFwVmVydGljZXModCxlKXtjb25zdCBuPXRoaXMuX2lzQ2xvc2VkP3Quc2l6ZSgpLTE6dC5zaXplKCk7Zm9yKGxldCBzPTA7czxuO3MrKyl7Y29uc3Qgbj10LmdldChzKSxpPXRoaXMuZmluZFNuYXBGb3JWZXJ0ZXgobixlKTtudWxsIT09aSYmKHQuc2V0KHMsbmV3IGcoaSkpLDA9PT1zJiZ0aGlzLl9pc0Nsb3NlZCYmdC5zZXQodC5zaXplKCktMSxuZXcgZyhpKSkpfX1maW5kU25hcEZvclZlcnRleCh0LGUpe2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXtpZih0LmVxdWFsczJEKGVbbl0pKXJldHVybiBudWxsO2lmKHQuZGlzdGFuY2UoZVtuXSk8dGhpcy5fc25hcFRvbGVyYW5jZSlyZXR1cm4gZVtuXX1yZXR1cm4gbnVsbH1zbmFwVG8odCl7Y29uc3QgZT1uZXcgSSh0aGlzLl9zcmNQdHMpO3JldHVybiB0aGlzLnNuYXBWZXJ0aWNlcyhlLHQpLHRoaXMuc25hcFNlZ21lbnRzKGUsdCksZS50b0Nvb3JkaW5hdGVBcnJheSgpfXNuYXBTZWdtZW50cyh0LGUpe2lmKDA9PT1lLmxlbmd0aClyZXR1cm4gbnVsbDtsZXQgbj1lLmxlbmd0aDtlWzBdLmVxdWFsczJEKGVbZS5sZW5ndGgtMV0pJiYobj1lLmxlbmd0aC0xKTtmb3IobGV0IHM9MDtzPG47cysrKXtjb25zdCBuPWVbc10saT10aGlzLmZpbmRTZWdtZW50SW5kZXhUb1NuYXAobix0KTtpPj0wJiZ0LmFkZChpKzEsbmV3IGcobiksITEpfX1maW5kU2VnbWVudEluZGV4VG9TbmFwKHQsZSl7bGV0IG49aS5NQVhfVkFMVUUscz0tMTtmb3IobGV0IGk9MDtpPGUuc2l6ZSgpLTE7aSsrKXtpZih0aGlzLl9zZWcucDA9ZS5nZXQoaSksdGhpcy5fc2VnLnAxPWUuZ2V0KGkrMSksdGhpcy5fc2VnLnAwLmVxdWFsczJEKHQpfHx0aGlzLl9zZWcucDEuZXF1YWxzMkQodCkpe2lmKHRoaXMuX2FsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzKWNvbnRpbnVlO3JldHVybi0xfWNvbnN0IHI9dGhpcy5fc2VnLmRpc3RhbmNlKHQpO3I8dGhpcy5fc25hcFRvbGVyYW5jZSYmcjxuJiYobj1yLHM9aSl9cmV0dXJuIHN9c2V0QWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXModCl7dGhpcy5fYWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXM9dH1nZXRDbGFzcygpe3JldHVybiBIaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19SGkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fc25hcFRvbGVyYW5jZT0wLHRoaXMuX3NyY1B0cz1udWxsLHRoaXMuX3NlZz1uZXcgZWUsdGhpcy5fYWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXM9ITEsdGhpcy5faXNDbG9zZWQ9ITEsYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBUdCYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07SGkuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LmdldENvb3JkaW5hdGVzKCksZSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9zcmNQdHM9dCx0aGlzLl9pc0Nsb3NlZD1IaS5pc0Nsb3NlZCh0KSx0aGlzLl9zbmFwVG9sZXJhbmNlPWV9fTtjbGFzcyBXaXtjb25zdHJ1Y3Rvcigpe1dpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHNuYXAodCxlLG4pe2NvbnN0IHM9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksaT1uZXcgV2kodCk7c1swXT1pLnNuYXBUbyhlLG4pO2NvbnN0IHI9bmV3IFdpKGUpO3JldHVybiBzWzFdPXIuc25hcFRvKHNbMF0sbiksc31zdGF0aWMgY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2xldCBlPVdpLmNvbXB1dGVTaXplQmFzZWRTbmFwVG9sZXJhbmNlKHQpO2NvbnN0IG49dC5nZXRQcmVjaXNpb25Nb2RlbCgpO2lmKG4uZ2V0VHlwZSgpPT09a3QuRklYRUQpe2NvbnN0IHQ9MS9uLmdldFNjYWxlKCkqMi8xLjQxNTt0PmUmJihlPXQpfXJldHVybiBlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gTWF0aC5taW4oV2kuY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlKHQpLFdpLmNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZShlKSl9fXN0YXRpYyBjb21wdXRlU2l6ZUJhc2VkU25hcFRvbGVyYW5jZSh0KXtjb25zdCBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO3JldHVybiBNYXRoLm1pbihlLmdldEhlaWdodCgpLGUuZ2V0V2lkdGgoKSkqV2kuU05BUF9QUkVDSVNJT05fRkFDVE9SfXN0YXRpYyBzbmFwVG9TZWxmKHQsZSxuKXtyZXR1cm4gbmV3IFdpKHQpLnNuYXBUb1NlbGYoZSxuKX1zbmFwVG8odCxlKXtjb25zdCBuPXRoaXMuZXh0cmFjdFRhcmdldENvb3JkaW5hdGVzKHQpO3JldHVybiBuZXcgamkoZSxuKS50cmFuc2Zvcm0odGhpcy5fc3JjR2VvbSl9c25hcFRvU2VsZih0LGUpe2NvbnN0IG49dGhpcy5leHRyYWN0VGFyZ2V0Q29vcmRpbmF0ZXModGhpcy5fc3JjR2VvbSkscz1uZXcgamkodCxuLCEwKS50cmFuc2Zvcm0odGhpcy5fc3JjR2VvbSk7bGV0IGk9cztyZXR1cm4gZSYmXyhpLE90KSYmKGk9cy5idWZmZXIoMCkpLGl9Y29tcHV0ZVNuYXBUb2xlcmFuY2UodCl7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbmltdW1TZWdtZW50TGVuZ3RoKHQpLzEwfWV4dHJhY3RUYXJnZXRDb29yZGluYXRlcyh0KXtjb25zdCBlPW5ldyBhdCxuPXQuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoO3QrKyllLmFkZChuW3RdKTtyZXR1cm4gZS50b0FycmF5KG5ldyBBcnJheSgwKS5maWxsKG51bGwpKX1jb21wdXRlTWluaW11bVNlZ21lbnRMZW5ndGgodCl7bGV0IGU9aS5NQVhfVkFMVUU7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aC0xO24rKyl7Y29uc3Qgcz10W25dLmRpc3RhbmNlKHRbbisxXSk7czxlJiYoZT1zKX1yZXR1cm4gZX1nZXRDbGFzcygpe3JldHVybiBXaX1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19V2kuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fc3JjR2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NyY0dlb209dH0sV2kuU05BUF9QUkVDSVNJT05fRkFDVE9SPTFlLTk7Y2xhc3MgamkgZXh0ZW5kcyBtZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksamkuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zbmFwTGluZSh0LGUpe2NvbnN0IG49bmV3IEhpKHQsdGhpcy5fc25hcFRvbGVyYW5jZSk7cmV0dXJuIG4uc2V0QWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXModGhpcy5faXNTZWxmU25hcCksbi5zbmFwVG8oZSl9dHJhbnNmb3JtQ29vcmRpbmF0ZXModCxlKXtjb25zdCBuPXQudG9Db29yZGluYXRlQXJyYXkoKSxzPXRoaXMuc25hcExpbmUobix0aGlzLl9zbmFwUHRzKTtyZXR1cm4gdGhpcy5fZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHMpfWdldENsYXNzKCl7cmV0dXJuIGppfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1qaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9zbmFwVG9sZXJhbmNlPW51bGwsdGhpcy5fc25hcFB0cz1udWxsLHRoaXMuX2lzU2VsZlNuYXA9ITEsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3NuYXBUb2xlcmFuY2U9dCx0aGlzLl9zbmFwUHRzPWV9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fc25hcFRvbGVyYW5jZT10LHRoaXMuX3NuYXBQdHM9ZSx0aGlzLl9pc1NlbGZTbmFwPW59fTt2YXIgS2k9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsR2VvbWV0cnlTbmFwcGVyOldpLExpbmVTdHJpbmdTbmFwcGVyOkhpfSk7Y2xhc3MgWml7Y29uc3RydWN0b3IoKXtaaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMuX3B0c31zaXplKCl7cmV0dXJuIHRoaXMuX3B0cy5sZW5ndGh9Z2V0Q29vcmRpbmF0ZSh0KXtyZXR1cm4gdGhpcy5fcHRzW3RdfWlzQ2xvc2VkKCl7cmV0dXJuIHRoaXMuX3B0c1swXS5lcXVhbHModGhpcy5fcHRzW3RoaXMuX3B0cy5sZW5ndGgtMV0pfWdldFNlZ21lbnRPY3RhbnQodCl7cmV0dXJuIHQ9PT10aGlzLl9wdHMubGVuZ3RoLTE/LTE6TXMub2N0YW50KHRoaXMuZ2V0Q29vcmRpbmF0ZSh0KSx0aGlzLmdldENvb3JkaW5hdGUodCsxKSl9c2V0RGF0YSh0KXt0aGlzLl9kYXRhPXR9Z2V0RGF0YSgpe3JldHVybiB0aGlzLl9kYXRhfXRvU3RyaW5nKCl7cmV0dXJuIEp0LnRvTGluZVN0cmluZyhuZXcgenQodGhpcy5fcHRzKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gWml9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0RzXX19WmkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcHRzPW51bGwsdGhpcy5fZGF0YT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3B0cz10LHRoaXMuX2RhdGE9ZX07Y2xhc3MgUWl7Y29uc3RydWN0b3IoKXtRaS5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjcmVhdGVBbGxJbnRlcnNlY3Rpb25zRmluZGVyKHQpe2NvbnN0IGU9bmV3IFFpKHQpO3JldHVybiBlLnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKCEwKSxlfXN0YXRpYyBjcmVhdGVBbnlJbnRlcnNlY3Rpb25GaW5kZXIodCl7cmV0dXJuIG5ldyBRaSh0KX1zdGF0aWMgY3JlYXRlSW50ZXJzZWN0aW9uQ291bnRlcih0KXtjb25zdCBlPW5ldyBRaSh0KTtyZXR1cm4gZS5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyghMCksZS5zZXRLZWVwSW50ZXJzZWN0aW9ucyghMSksZX1nZXRJbnRlcmlvckludGVyc2VjdGlvbigpe3JldHVybiB0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbn1zZXRDaGVja0VuZFNlZ21lbnRzT25seSh0KXt0aGlzLl9pc0NoZWNrRW5kU2VnbWVudHNPbmx5PXR9Z2V0SW50ZXJzZWN0aW9uU2VnbWVudHMoKXtyZXR1cm4gdGhpcy5faW50U2VnbWVudHN9Y291bnQoKXtyZXR1cm4gdGhpcy5faW50ZXJzZWN0aW9uQ291bnR9Z2V0SW50ZXJzZWN0aW9ucygpe3JldHVybiB0aGlzLl9pbnRlcnNlY3Rpb25zfXNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKHQpe3RoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zPXR9c2V0S2VlcEludGVyc2VjdGlvbnModCl7dGhpcy5fa2VlcEludGVyc2VjdGlvbnM9dH1wcm9jZXNzSW50ZXJzZWN0aW9ucyh0LGUsbixzKXtpZighdGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnMmJnRoaXMuaGFzSW50ZXJzZWN0aW9uKCkpcmV0dXJuIG51bGw7aWYodD09PW4mJmU9PT1zKXJldHVybiBudWxsO2lmKHRoaXMuX2lzQ2hlY2tFbmRTZWdtZW50c09ubHkpe2lmKCEodGhpcy5pc0VuZFNlZ21lbnQodCxlKXx8dGhpcy5pc0VuZFNlZ21lbnQobixzKSkpcmV0dXJuIG51bGx9Y29uc3QgaT10LmdldENvb3JkaW5hdGVzKClbZV0scj10LmdldENvb3JkaW5hdGVzKClbZSsxXSxvPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzXSxsPW4uZ2V0Q29vcmRpbmF0ZXMoKVtzKzFdO3RoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24oaSxyLG8sbCksdGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkmJnRoaXMuX2xpLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKSYmKHRoaXMuX2ludFNlZ21lbnRzPW5ldyBBcnJheSg0KS5maWxsKG51bGwpLHRoaXMuX2ludFNlZ21lbnRzWzBdPWksdGhpcy5faW50U2VnbWVudHNbMV09cix0aGlzLl9pbnRTZWdtZW50c1syXT1vLHRoaXMuX2ludFNlZ21lbnRzWzNdPWwsdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb249dGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uKDApLHRoaXMuX2tlZXBJbnRlcnNlY3Rpb25zJiZ0aGlzLl9pbnRlcnNlY3Rpb25zLmFkZCh0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbiksdGhpcy5faW50ZXJzZWN0aW9uQ291bnQrKyl9aXNFbmRTZWdtZW50KHQsZSl7cmV0dXJuIDA9PT1lfHxlPj10LnNpemUoKS0yfWhhc0ludGVyc2VjdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb259aXNEb25lKCl7cmV0dXJuIXRoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zJiZudWxsIT09dGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb259Z2V0Q2xhc3MoKXtyZXR1cm4gUWl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW19pXX19UWkuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnM9ITEsdGhpcy5faXNDaGVja0VuZFNlZ21lbnRzT25seT0hMSx0aGlzLl9saT1udWxsLHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9uPW51bGwsdGhpcy5faW50U2VnbWVudHM9bnVsbCx0aGlzLl9pbnRlcnNlY3Rpb25zPW5ldyB4LHRoaXMuX2ludGVyc2VjdGlvbkNvdW50PTAsdGhpcy5fa2VlcEludGVyc2VjdGlvbnM9ITA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGk9dCx0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbj1udWxsfTtjbGFzcyBKaXtjb25zdHJ1Y3Rvcigpe0ppLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbXB1dGVJbnRlcnNlY3Rpb25zKHQpe2NvbnN0IGU9bmV3IEppKHQpO3JldHVybiBlLnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKCEwKSxlLmlzVmFsaWQoKSxlLmdldEludGVyc2VjdGlvbnMoKX1leGVjdXRlKCl7aWYobnVsbCE9PXRoaXMuX3NlZ0ludClyZXR1cm4gbnVsbDt0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKCl9Z2V0SW50ZXJzZWN0aW9ucygpe3JldHVybiB0aGlzLl9zZWdJbnQuZ2V0SW50ZXJzZWN0aW9ucygpfWlzVmFsaWQoKXtyZXR1cm4gdGhpcy5leGVjdXRlKCksdGhpcy5faXNWYWxpZH1zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyh0KXt0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucz10fWNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKCl7dGhpcy5faXNWYWxpZD0hMCx0aGlzLl9zZWdJbnQ9bmV3IFFpKHRoaXMuX2xpKSx0aGlzLl9zZWdJbnQuc2V0RmluZEFsbEludGVyc2VjdGlvbnModGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnMpO2NvbnN0IHQ9bmV3IFlzO2lmKHQuc2V0U2VnbWVudEludGVyc2VjdG9yKHRoaXMuX3NlZ0ludCksdC5jb21wdXRlTm9kZXModGhpcy5fc2VnU3RyaW5ncyksdGhpcy5fc2VnSW50Lmhhc0ludGVyc2VjdGlvbigpKXJldHVybiB0aGlzLl9pc1ZhbGlkPSExLG51bGx9Y2hlY2tWYWxpZCgpe2lmKHRoaXMuZXhlY3V0ZSgpLCF0aGlzLl9pc1ZhbGlkKXRocm93IG5ldyBXbih0aGlzLmdldEVycm9yTWVzc2FnZSgpLHRoaXMuX3NlZ0ludC5nZXRJbnRlcmlvckludGVyc2VjdGlvbigpKX1nZXRFcnJvck1lc3NhZ2UoKXtpZih0aGlzLl9pc1ZhbGlkKXJldHVyblwibm8gaW50ZXJzZWN0aW9ucyBmb3VuZFwiO2NvbnN0IHQ9dGhpcy5fc2VnSW50LmdldEludGVyc2VjdGlvblNlZ21lbnRzKCk7cmV0dXJuXCJmb3VuZCBub24tbm9kZWQgaW50ZXJzZWN0aW9uIGJldHdlZW4gXCIrSnQudG9MaW5lU3RyaW5nKHRbMF0sdFsxXSkrXCIgYW5kIFwiK0p0LnRvTGluZVN0cmluZyh0WzJdLHRbM10pfWdldENsYXNzKCl7cmV0dXJuIEppfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1KaS5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9saT1uZXcgdGUsdGhpcy5fc2VnU3RyaW5ncz1udWxsLHRoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zPSExLHRoaXMuX3NlZ0ludD1udWxsLHRoaXMuX2lzVmFsaWQ9ITA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2VnU3RyaW5ncz10fTtjbGFzcyAkaXtjb25zdHJ1Y3RvcigpeyRpLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHRvU2VnbWVudFN0cmluZ3ModCl7Y29uc3QgZT1uZXcgeDtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtlLmFkZChuZXcgWmkodC5nZXRDb29yZGluYXRlcygpLHQpKX1yZXR1cm4gZX1zdGF0aWMgY2hlY2tWYWxpZCh0KXtuZXcgJGkodCkuY2hlY2tWYWxpZCgpfWNoZWNrVmFsaWQoKXt0aGlzLl9udi5jaGVja1ZhbGlkKCl9Z2V0Q2xhc3MoKXtyZXR1cm4gJGl9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fSRpLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX252PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbnY9bmV3IEppKCRpLnRvU2VnbWVudFN0cmluZ3ModCkpfTtjbGFzcyB0cntjb25zdHJ1Y3Rvcigpe3RyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y29sbGVjdExpbmVzKHQpe2ZvcihsZXQgZT10aGlzLl9vcC5nZXRHcmFwaCgpLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dGhpcy5jb2xsZWN0TGluZUVkZ2Uobix0LHRoaXMuX2xpbmVFZGdlc0xpc3QpLHRoaXMuY29sbGVjdEJvdW5kYXJ5VG91Y2hFZGdlKG4sdCx0aGlzLl9saW5lRWRnZXNMaXN0KX19bGFiZWxJc29sYXRlZExpbmUodCxlKXtjb25zdCBuPXRoaXMuX3B0TG9jYXRvci5sb2NhdGUodC5nZXRDb29yZGluYXRlKCksdGhpcy5fb3AuZ2V0QXJnR2VvbWV0cnkoZSkpO3QuZ2V0TGFiZWwoKS5zZXRMb2NhdGlvbihlLG4pfWJ1aWxkKHQpe3JldHVybiB0aGlzLmZpbmRDb3ZlcmVkTGluZUVkZ2VzKCksdGhpcy5jb2xsZWN0TGluZXModCksdGhpcy5idWlsZExpbmVzKHQpLHRoaXMuX3Jlc3VsdExpbmVMaXN0fWNvbGxlY3RMaW5lRWRnZSh0LGUsbil7Y29uc3Qgcz10LmdldExhYmVsKCksaT10LmdldEVkZ2UoKTt0LmlzTGluZUVkZ2UoKSYmKHQuaXNWaXNpdGVkKCl8fCFjci5pc1Jlc3VsdE9mT3AocyxlKXx8aS5pc0NvdmVyZWQoKXx8KG4uYWRkKGkpLHQuc2V0VmlzaXRlZEVkZ2UoITApKSl9ZmluZENvdmVyZWRMaW5lRWRnZXMoKXtmb3IobGV0IHQ9dGhpcy5fb3AuZ2V0R3JhcGgoKS5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt0Lm5leHQoKS5nZXRFZGdlcygpLmZpbmRDb3ZlcmVkTGluZUVkZ2VzKCl9Zm9yKGxldCB0PXRoaXMuX29wLmdldEdyYXBoKCkuZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxuPWUuZ2V0RWRnZSgpO2lmKGUuaXNMaW5lRWRnZSgpJiYhbi5pc0NvdmVyZWRTZXQoKSl7Y29uc3QgdD10aGlzLl9vcC5pc0NvdmVyZWRCeUEoZS5nZXRDb29yZGluYXRlKCkpO24uc2V0Q292ZXJlZCh0KX19fWxhYmVsSXNvbGF0ZWRMaW5lcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKSxuPXQuZ2V0TGFiZWwoKTt0LmlzSXNvbGF0ZWQoKSYmKG4uaXNOdWxsKDApP3RoaXMubGFiZWxJc29sYXRlZExpbmUodCwwKTp0aGlzLmxhYmVsSXNvbGF0ZWRMaW5lKHQsMSkpfX1idWlsZExpbmVzKHQpe2ZvcihsZXQgdD10aGlzLl9saW5lRWRnZXNMaXN0Lml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49KGUuZ2V0TGFiZWwoKSx0aGlzLl9nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhlLmdldENvb3JkaW5hdGVzKCkpKTt0aGlzLl9yZXN1bHRMaW5lTGlzdC5hZGQobiksZS5zZXRJblJlc3VsdCghMCl9fWNvbGxlY3RCb3VuZGFyeVRvdWNoRWRnZSh0LGUsbil7Y29uc3Qgcz10LmdldExhYmVsKCk7cmV0dXJuIHQuaXNMaW5lRWRnZSgpfHx0LmlzVmlzaXRlZCgpfHx0LmlzSW50ZXJpb3JBcmVhRWRnZSgpfHx0LmdldEVkZ2UoKS5pc0luUmVzdWx0KCk/bnVsbDoodS5pc1RydWUoISh0LmlzSW5SZXN1bHQoKXx8dC5nZXRTeW0oKS5pc0luUmVzdWx0KCkpfHwhdC5nZXRFZGdlKCkuaXNJblJlc3VsdCgpKSx2b2lkKGNyLmlzUmVzdWx0T2ZPcChzLGUpJiZlPT09Y3IuSU5URVJTRUNUSU9OJiYobi5hZGQodC5nZXRFZGdlKCkpLHQuc2V0VmlzaXRlZEVkZ2UoITApKSkpfWdldENsYXNzKCl7cmV0dXJuIHRyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX10ci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9vcD1udWxsLHRoaXMuX2dlb21ldHJ5RmFjdG9yeT1udWxsLHRoaXMuX3B0TG9jYXRvcj1udWxsLHRoaXMuX2xpbmVFZGdlc0xpc3Q9bmV3IHgsdGhpcy5fcmVzdWx0TGluZUxpc3Q9bmV3IHg7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fb3A9dCx0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9ZSx0aGlzLl9wdExvY2F0b3I9bn07Y2xhc3MgZXJ7Y29uc3RydWN0b3IoKXtlci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbHRlckNvdmVyZWROb2RlVG9Qb2ludCh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZSgpO2lmKCF0aGlzLl9vcC5pc0NvdmVyZWRCeUxBKGUpKXtjb25zdCB0PXRoaXMuX2dlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludChlKTt0aGlzLl9yZXN1bHRQb2ludExpc3QuYWRkKHQpfX1leHRyYWN0Tm9uQ292ZXJlZFJlc3VsdE5vZGVzKHQpe2ZvcihsZXQgZT10aGlzLl9vcC5nZXRHcmFwaCgpLmdldE5vZGVzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7aWYoIW4uaXNJblJlc3VsdCgpJiYoIW4uaXNJbmNpZGVudEVkZ2VJblJlc3VsdCgpJiYoMD09PW4uZ2V0RWRnZXMoKS5nZXREZWdyZWUoKXx8dD09PWNyLklOVEVSU0VDVElPTikpKXtjb25zdCBlPW4uZ2V0TGFiZWwoKTtjci5pc1Jlc3VsdE9mT3AoZSx0KSYmdGhpcy5maWx0ZXJDb3ZlcmVkTm9kZVRvUG9pbnQobil9fX1idWlsZCh0KXtyZXR1cm4gdGhpcy5leHRyYWN0Tm9uQ292ZXJlZFJlc3VsdE5vZGVzKHQpLHRoaXMuX3Jlc3VsdFBvaW50TGlzdH1nZXRDbGFzcygpe3JldHVybiBlcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19ZXIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fb3A9bnVsbCx0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9bnVsbCx0aGlzLl9yZXN1bHRQb2ludExpc3Q9bmV3IHg7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fb3A9dCx0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9ZX07Y2xhc3MgbnJ7Y29uc3RydWN0b3IoKXt0aGlzLl9pc0ZpcnN0PSEwLHRoaXMuX2NvbW1vbk1hbnRpc3NhQml0c0NvdW50PTUzLHRoaXMuX2NvbW1vbkJpdHM9bmV3IHMsdGhpcy5fY29tbW9uU2lnbkV4cD1udWxsfWdldENvbW1vbigpe3JldHVybiBpLmxvbmdCaXRzVG9Eb3VibGUodGhpcy5fY29tbW9uQml0cyl9YWRkKHQpe2NvbnN0IGU9aS5kb3VibGVUb0xvbmdCaXRzKHQpO3JldHVybiB0aGlzLl9pc0ZpcnN0Pyh0aGlzLl9jb21tb25CaXRzPWUsdGhpcy5fY29tbW9uU2lnbkV4cD1uci5zaWduRXhwQml0cyh0aGlzLl9jb21tb25CaXRzKSx0aGlzLl9pc0ZpcnN0PSExLG51bGwpOm5yLnNpZ25FeHBCaXRzKGUpIT09dGhpcy5fY29tbW9uU2lnbkV4cD8odGhpcy5fY29tbW9uQml0cy5oaWdoPTAsdGhpcy5fY29tbW9uQml0cy5sb3c9MCxudWxsKToodGhpcy5fY29tbW9uTWFudGlzc2FCaXRzQ291bnQ9bnIubnVtQ29tbW9uTW9zdFNpZ01hbnRpc3NhQml0cyh0aGlzLl9jb21tb25CaXRzLGUpLHZvaWQodGhpcy5fY29tbW9uQml0cz1uci56ZXJvTG93ZXJCaXRzKHRoaXMuX2NvbW1vbkJpdHMsNjQtKDEyK3RoaXMuX2NvbW1vbk1hbnRpc3NhQml0c0NvdW50KSkpKX10b1N0cmluZygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWkubG9uZ0JpdHNUb0RvdWJsZSh0KSxuPVwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiK3MudG9CaW5hcnlTdHJpbmcodCkscj1uLnN1YnN0cmluZyhuLmxlbmd0aC02NCk7cmV0dXJuIHIuc3Vic3RyaW5nKDAsMSkrXCIgIFwiK3Iuc3Vic3RyaW5nKDEsMTIpK1wiKGV4cCkgXCIrci5zdWJzdHJpbmcoMTIpK1wiIFsgXCIrZStcIiBdXCJ9fWdldENsYXNzKCl7cmV0dXJuIG5yfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfXN0YXRpYyBnZXRCaXQodCxlKXtjb25zdCBuPTE8PGUlMzI7cmV0dXJuIGU8MzI/MCE9KHQubG93Jm4pPzE6MDowIT0odC5oaWdoJm4pPzE6MH1zdGF0aWMgc2lnbkV4cEJpdHModCl7cmV0dXJuIHQuaGlnaD4+PjIwfXN0YXRpYyB6ZXJvTG93ZXJCaXRzKHQsZSl7bGV0IG49XCJsb3dcIjtpZihlPjMyJiYodC5sb3c9MCxlJT0zMixuPVwiaGlnaFwiKSxlPjApe2NvbnN0IHM9ZTwzMj9+KCgxPDxlKS0xKTowO3Rbbl0mPXN9cmV0dXJuIHR9c3RhdGljIG51bUNvbW1vbk1vc3RTaWdNYW50aXNzYUJpdHModCxlKXtsZXQgbj0wO2ZvcihsZXQgcz01MjtzPj0wO3MtLSl7aWYobnIuZ2V0Qml0KHQscykhPT1uci5nZXRCaXQoZSxzKSlyZXR1cm4gbjtuKyt9cmV0dXJuIDUyfX1jbGFzcyBzcntjb25zdHJ1Y3Rvcigpe3NyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9YWRkQ29tbW9uQml0cyh0KXtjb25zdCBlPW5ldyBycih0aGlzLl9jb21tb25Db29yZCk7dC5hcHBseShlKSx0Lmdlb21ldHJ5Q2hhbmdlZCgpfXJlbW92ZUNvbW1vbkJpdHModCl7aWYoMD09PXRoaXMuX2NvbW1vbkNvb3JkLngmJjA9PT10aGlzLl9jb21tb25Db29yZC55KXJldHVybiB0O2NvbnN0IGU9bmV3IGcodGhpcy5fY29tbW9uQ29vcmQpO2UueD0tZS54LGUueT0tZS55O2NvbnN0IG49bmV3IHJyKGUpO3JldHVybiB0LmFwcGx5KG4pLHQuZ2VvbWV0cnlDaGFuZ2VkKCksdH1nZXRDb21tb25Db29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX2NvbW1vbkNvb3JkfWFkZCh0KXt0LmFwcGx5KHRoaXMuX2NjRmlsdGVyKSx0aGlzLl9jb21tb25Db29yZD10aGlzLl9jY0ZpbHRlci5nZXRDb21tb25Db29yZGluYXRlKCl9Z2V0Q2xhc3MoKXtyZXR1cm4gc3J9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIGlye2NvbnN0cnVjdG9yKCl7aXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maWx0ZXIodCl7dGhpcy5fY29tbW9uQml0c1guYWRkKHQueCksdGhpcy5fY29tbW9uQml0c1kuYWRkKHQueSl9Z2V0Q29tbW9uQ29vcmRpbmF0ZSgpe3JldHVybiBuZXcgZyh0aGlzLl9jb21tb25CaXRzWC5nZXRDb21tb24oKSx0aGlzLl9jb21tb25CaXRzWS5nZXRDb21tb24oKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gaXJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0JdfX1pci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9jb21tb25CaXRzWD1uZXcgbnIsdGhpcy5fY29tbW9uQml0c1k9bmV3IG5yfTtjbGFzcyBycntjb25zdHJ1Y3Rvcigpe3JyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmlsdGVyKHQsZSl7Y29uc3Qgbj10LmdldE9yZGluYXRlKGUsMCkrdGhpcy50cmFucy54LHM9dC5nZXRPcmRpbmF0ZShlLDEpK3RoaXMudHJhbnMueTt0LnNldE9yZGluYXRlKGUsMCxuKSx0LnNldE9yZGluYXRlKGUsMSxzKX1pc0RvbmUoKXtyZXR1cm4hMX1pc0dlb21ldHJ5Q2hhbmdlZCgpe3JldHVybiEwfWdldENsYXNzKCl7cmV0dXJuIHJyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltkdF19fXJyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMudHJhbnM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnRyYW5zPXR9LHNyLkNvbW1vbkNvb3JkaW5hdGVGaWx0ZXI9aXIsc3IuVHJhbnNsYXRlcj1ycixzci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9jb21tb25Db29yZD1udWxsLHRoaXMuX2NjRmlsdGVyPW5ldyBpcn07Y2xhc3Mgb3J7Y29uc3RydWN0b3IoKXtvci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBvdmVybGF5T3AodCxlLG4pe3JldHVybiBuZXcgb3IodCxlKS5nZXRSZXN1bHRHZW9tZXRyeShuKX1zdGF0aWMgdW5pb24odCxlKXtyZXR1cm4gb3Iub3ZlcmxheU9wKHQsZSxjci5VTklPTil9c3RhdGljIGludGVyc2VjdGlvbih0LGUpe3JldHVybiBvci5vdmVybGF5T3AodCxlLGNyLklOVEVSU0VDVElPTil9c3RhdGljIHN5bURpZmZlcmVuY2UodCxlKXtyZXR1cm4gb3Iub3ZlcmxheU9wKHQsZSxjci5TWU1ESUZGRVJFTkNFKX1zdGF0aWMgZGlmZmVyZW5jZSh0LGUpe3JldHVybiBvci5vdmVybGF5T3AodCxlLGNyLkRJRkZFUkVOQ0UpfXNlbGZTbmFwKHQpe3JldHVybiBuZXcgV2kodCkuc25hcFRvKHQsdGhpcy5fc25hcFRvbGVyYW5jZSl9cmVtb3ZlQ29tbW9uQml0cyh0KXt0aGlzLl9jYnI9bmV3IHNyLHRoaXMuX2Nici5hZGQodFswXSksdGhpcy5fY2JyLmFkZCh0WzFdKTtjb25zdCBlPW5ldyBBcnJheSgyKS5maWxsKG51bGwpO3JldHVybiBlWzBdPXRoaXMuX2Nici5yZW1vdmVDb21tb25CaXRzKHRbMF0uY29weSgpKSxlWzFdPXRoaXMuX2Nici5yZW1vdmVDb21tb25CaXRzKHRbMV0uY29weSgpKSxlfXByZXBhcmVSZXN1bHQodCl7cmV0dXJuIHRoaXMuX2Nici5hZGRDb21tb25CaXRzKHQpLHR9Z2V0UmVzdWx0R2VvbWV0cnkodCl7Y29uc3QgZT10aGlzLnNuYXAodGhpcy5fZ2VvbSksbj1jci5vdmVybGF5T3AoZVswXSxlWzFdLHQpO3JldHVybiB0aGlzLnByZXBhcmVSZXN1bHQobil9Y2hlY2tWYWxpZCh0KXt0LmlzVmFsaWQoKXx8Ty5vdXQucHJpbnRsbihcIlNuYXBwZWQgZ2VvbWV0cnkgaXMgaW52YWxpZFwiKX1jb21wdXRlU25hcFRvbGVyYW5jZSgpe3RoaXMuX3NuYXBUb2xlcmFuY2U9V2kuY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlKHRoaXMuX2dlb21bMF0sdGhpcy5fZ2VvbVsxXSl9c25hcCh0KXtjb25zdCBlPXRoaXMucmVtb3ZlQ29tbW9uQml0cyh0KTtyZXR1cm4gV2kuc25hcChlWzBdLGVbMV0sdGhpcy5fc25hcFRvbGVyYW5jZSl9Z2V0Q2xhc3MoKXtyZXR1cm4gb3J9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fW9yLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2dlb209bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5fc25hcFRvbGVyYW5jZT1udWxsLHRoaXMuX2Nicj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2dlb21bMF09dCx0aGlzLl9nZW9tWzFdPWUsdGhpcy5jb21wdXRlU25hcFRvbGVyYW5jZSgpfTtjbGFzcyBscntjb25zdHJ1Y3Rvcigpe2xyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIG92ZXJsYXlPcCh0LGUsbil7cmV0dXJuIG5ldyBscih0LGUpLmdldFJlc3VsdEdlb21ldHJ5KG4pfXN0YXRpYyB1bmlvbih0LGUpe3JldHVybiBsci5vdmVybGF5T3AodCxlLGNyLlVOSU9OKX1zdGF0aWMgaW50ZXJzZWN0aW9uKHQsZSl7cmV0dXJuIGxyLm92ZXJsYXlPcCh0LGUsY3IuSU5URVJTRUNUSU9OKX1zdGF0aWMgc3ltRGlmZmVyZW5jZSh0LGUpe3JldHVybiBsci5vdmVybGF5T3AodCxlLGNyLlNZTURJRkZFUkVOQ0UpfXN0YXRpYyBkaWZmZXJlbmNlKHQsZSl7cmV0dXJuIGxyLm92ZXJsYXlPcCh0LGUsY3IuRElGRkVSRU5DRSl9Z2V0UmVzdWx0R2VvbWV0cnkodCl7bGV0IGU9bnVsbCxuPSExLHM9bnVsbDt0cnl7ZT1jci5vdmVybGF5T3AodGhpcy5fZ2VvbVswXSx0aGlzLl9nZW9tWzFdLHQpLCEwJiYobj0hMCl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgYykpdGhyb3cgdDtzPXR9aWYoIW4pdHJ5e2U9b3Iub3ZlcmxheU9wKHRoaXMuX2dlb21bMF0sdGhpcy5fZ2VvbVsxXSx0KX1jYXRjaCh0KXt0aHJvdyB0IGluc3RhbmNlb2YgYz9zOnR9cmV0dXJuIGV9Z2V0Q2xhc3MoKXtyZXR1cm4gbHJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWxyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2dlb209bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZ2VvbVswXT10LHRoaXMuX2dlb21bMV09ZX07Y2xhc3MgYXJ7Y29uc3RydWN0b3IoKXthci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldEFyZ0dlb21ldHJ5KHQpe3JldHVybiB0aGlzLl9hcmdbdF0uZ2V0R2VvbWV0cnkoKX1zZXRDb21wdXRhdGlvblByZWNpc2lvbih0KXt0aGlzLl9yZXN1bHRQcmVjaXNpb25Nb2RlbD10LHRoaXMuX2xpLnNldFByZWNpc2lvbk1vZGVsKHRoaXMuX3Jlc3VsdFByZWNpc2lvbk1vZGVsKX1nZXRDbGFzcygpe3JldHVybiBhcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19YXIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fbGk9bmV3IHRlLHRoaXMuX3Jlc3VsdFByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5fYXJnPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24odC5nZXRQcmVjaXNpb25Nb2RlbCgpKSx0aGlzLl9hcmc9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksdGhpcy5fYXJnWzBdPW5ldyBRbigwLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2FyLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlLFYuT0dDX1NGU19CT1VOREFSWV9SVUxFKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0LmdldFByZWNpc2lvbk1vZGVsKCkuY29tcGFyZVRvKGUuZ2V0UHJlY2lzaW9uTW9kZWwoKSk+PTA/dGhpcy5zZXRDb21wdXRhdGlvblByZWNpc2lvbih0LmdldFByZWNpc2lvbk1vZGVsKCkpOnRoaXMuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24oZS5nZXRQcmVjaXNpb25Nb2RlbCgpKSx0aGlzLl9hcmc9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5fYXJnWzBdPW5ldyBRbigwLHQsbiksdGhpcy5fYXJnWzFdPW5ldyBRbigxLGUsbil9fTtjbGFzcyBjciBleHRlbmRzIGFye2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxjci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBvdmVybGF5T3AodCxlLG4pe3JldHVybiBuZXcgY3IodCxlKS5nZXRSZXN1bHRHZW9tZXRyeShuKX1zdGF0aWMgdW5pb24odCxlKXtpZih0LmlzRW1wdHkoKXx8ZS5pc0VtcHR5KCkpe2lmKHQuaXNFbXB0eSgpJiZlLmlzRW1wdHkoKSlyZXR1cm4gY3IuY3JlYXRlRW1wdHlSZXN1bHQoY3IuVU5JT04sdCxlLHQuZ2V0RmFjdG9yeSgpKTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gZS5jb3B5KCk7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIHQuY29weSgpfWlmKHQuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKXx8ZS5pc0dlb21ldHJ5Q29sbGVjdGlvbigpKXRocm93IG5ldyBuKFwiVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBHZW9tZXRyeUNvbGxlY3Rpb24gYXJndW1lbnRzXCIpO3JldHVybiBsci5vdmVybGF5T3AodCxlLGNyLlVOSU9OKX1zdGF0aWMgaW50ZXJzZWN0aW9uKHQsZSl7aWYodC5pc0VtcHR5KCl8fGUuaXNFbXB0eSgpKXJldHVybiBjci5jcmVhdGVFbXB0eVJlc3VsdChjci5JTlRFUlNFQ1RJT04sdCxlLHQuZ2V0RmFjdG9yeSgpKTtpZih0LmlzR2VvbWV0cnlDb2xsZWN0aW9uKCkpe2NvbnN0IG49ZTtyZXR1cm4gZ2UubWFwKHQsbmV3IGNsYXNze2dldCBpbnRlcmZhY2VzXygpe3JldHVybltmZV19bWFwKHQpe3JldHVybiBjci5pbnRlcnNlY3Rpb24odCxuKX19KX1yZXR1cm4gbHIub3ZlcmxheU9wKHQsZSxjci5JTlRFUlNFQ1RJT04pfXN0YXRpYyBzeW1EaWZmZXJlbmNlKHQsZSl7aWYodC5pc0VtcHR5KCl8fGUuaXNFbXB0eSgpKXtpZih0LmlzRW1wdHkoKSYmZS5pc0VtcHR5KCkpcmV0dXJuIGNyLmNyZWF0ZUVtcHR5UmVzdWx0KGNyLlNZTURJRkZFUkVOQ0UsdCxlLHQuZ2V0RmFjdG9yeSgpKTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gZS5jb3B5KCk7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIHQuY29weSgpfWlmKHQuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKXx8ZS5pc0dlb21ldHJ5Q29sbGVjdGlvbigpKXRocm93IG5ldyBuKFwiVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBHZW9tZXRyeUNvbGxlY3Rpb24gYXJndW1lbnRzXCIpO3JldHVybiBsci5vdmVybGF5T3AodCxlLGNyLlNZTURJRkZFUkVOQ0UpfXN0YXRpYyByZXN1bHREaW1lbnNpb24odCxlLG4pe2NvbnN0IHM9ZS5nZXREaW1lbnNpb24oKSxpPW4uZ2V0RGltZW5zaW9uKCk7bGV0IHI9LTE7c3dpdGNoKHQpe2Nhc2UgY3IuSU5URVJTRUNUSU9OOnI9TWF0aC5taW4ocyxpKTticmVhaztjYXNlIGNyLlVOSU9OOnI9TWF0aC5tYXgocyxpKTticmVhaztjYXNlIGNyLkRJRkZFUkVOQ0U6cj1zO2JyZWFrO2Nhc2UgY3IuU1lNRElGRkVSRU5DRTpyPU1hdGgubWF4KHMsaSl9cmV0dXJuIHJ9c3RhdGljIGNyZWF0ZUVtcHR5UmVzdWx0KHQsZSxuLHMpe2xldCBpPW51bGw7c3dpdGNoKGNyLnJlc3VsdERpbWVuc2lvbih0LGUsbikpe2Nhc2UtMTppPXMuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk7YnJlYWs7Y2FzZSAwOmk9cy5jcmVhdGVQb2ludCgpO2JyZWFrO2Nhc2UgMTppPXMuY3JlYXRlTGluZVN0cmluZygpO2JyZWFrO2Nhc2UgMjppPXMuY3JlYXRlUG9seWdvbigpfXJldHVybiBpfXN0YXRpYyBkaWZmZXJlbmNlKHQsZSl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIGNyLmNyZWF0ZUVtcHR5UmVzdWx0KGNyLkRJRkZFUkVOQ0UsdCxlLHQuZ2V0RmFjdG9yeSgpKTtpZihlLmlzRW1wdHkoKSlyZXR1cm4gdC5jb3B5KCk7aWYodC5pc0dlb21ldHJ5Q29sbGVjdGlvbigpfHxlLmlzR2VvbWV0cnlDb2xsZWN0aW9uKCkpdGhyb3cgbmV3IG4oXCJUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IEdlb21ldHJ5Q29sbGVjdGlvbiBhcmd1bWVudHNcIik7cmV0dXJuIGxyLm92ZXJsYXlPcCh0LGUsY3IuRElGRkVSRU5DRSl9c3RhdGljIGlzUmVzdWx0T2ZPcCgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXQuZ2V0TG9jYXRpb24oMCkscz10LmdldExvY2F0aW9uKDEpO3JldHVybiBjci5pc1Jlc3VsdE9mT3AobixzLGUpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtsZXQgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Y29uc3Qgbj1hcmd1bWVudHNbMl07c3dpdGNoKHQ9PT1uZS5CT1VOREFSWSYmKHQ9bmUuSU5URVJJT1IpLGU9PT1uZS5CT1VOREFSWSYmKGU9bmUuSU5URVJJT1IpLG4pe2Nhc2UgY3IuSU5URVJTRUNUSU9OOnJldHVybiB0PT09bmUuSU5URVJJT1ImJmU9PT1uZS5JTlRFUklPUjtjYXNlIGNyLlVOSU9OOnJldHVybiB0PT09bmUuSU5URVJJT1J8fGU9PT1uZS5JTlRFUklPUjtjYXNlIGNyLkRJRkZFUkVOQ0U6cmV0dXJuIHQ9PT1uZS5JTlRFUklPUiYmZSE9PW5lLklOVEVSSU9SO2Nhc2UgY3IuU1lNRElGRkVSRU5DRTpyZXR1cm4gdD09PW5lLklOVEVSSU9SJiZlIT09bmUuSU5URVJJT1J8fHQhPT1uZS5JTlRFUklPUiYmZT09PW5lLklOVEVSSU9SfXJldHVybiExfX1pbnNlcnRVbmlxdWVFZGdlKHQpe2NvbnN0IGU9dGhpcy5fZWRnZUxpc3QuZmluZEVxdWFsRWRnZSh0KTtpZihudWxsIT09ZSl7Y29uc3Qgbj1lLmdldExhYmVsKCk7bGV0IHM9dC5nZXRMYWJlbCgpO2UuaXNQb2ludHdpc2VFcXVhbCh0KXx8KHM9bmV3IEZuKHQuZ2V0TGFiZWwoKSkscy5mbGlwKCkpO2NvbnN0IGk9ZS5nZXREZXB0aCgpO2kuaXNOdWxsKCkmJmkuYWRkKG4pLGkuYWRkKHMpLG4ubWVyZ2Uocyl9ZWxzZSB0aGlzLl9lZGdlTGlzdC5hZGQodCl9Z2V0R3JhcGgoKXtyZXR1cm4gdGhpcy5fZ3JhcGh9Y2FuY2VsRHVwbGljYXRlUmVzdWx0RWRnZXMoKXtmb3IobGV0IHQ9dGhpcy5fZ3JhcGguZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxuPWUuZ2V0U3ltKCk7ZS5pc0luUmVzdWx0KCkmJm4uaXNJblJlc3VsdCgpJiYoZS5zZXRJblJlc3VsdCghMSksbi5zZXRJblJlc3VsdCghMSkpfX1pc0NvdmVyZWRCeUxBKHQpe3JldHVybiEhdGhpcy5pc0NvdmVyZWQodCx0aGlzLl9yZXN1bHRMaW5lTGlzdCl8fCEhdGhpcy5pc0NvdmVyZWQodCx0aGlzLl9yZXN1bHRQb2x5TGlzdCl9Y29tcHV0ZUdlb21ldHJ5KHQsZSxuLHMpe2NvbnN0IGk9bmV3IHg7cmV0dXJuIGkuYWRkQWxsKHQpLGkuYWRkQWxsKGUpLGkuYWRkQWxsKG4pLGkuaXNFbXB0eSgpP2NyLmNyZWF0ZUVtcHR5UmVzdWx0KHMsdGhpcy5fYXJnWzBdLmdldEdlb21ldHJ5KCksdGhpcy5fYXJnWzFdLmdldEdlb21ldHJ5KCksdGhpcy5fZ2VvbUZhY3QpOnRoaXMuX2dlb21GYWN0LmJ1aWxkR2VvbWV0cnkoaSl9bWVyZ2VTeW1MYWJlbHMoKXtmb3IobGV0IHQ9dGhpcy5fZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuZ2V0RWRnZXMoKS5tZXJnZVN5bUxhYmVscygpfX1pc0NvdmVyZWQodCxlKXtmb3IobGV0IG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgZT1uLm5leHQoKTtpZih0aGlzLl9wdExvY2F0b3IubG9jYXRlKHQsZSkhPT1uZS5FWFRFUklPUilyZXR1cm4hMH1yZXR1cm4hMX1yZXBsYWNlQ29sbGFwc2VkRWRnZXMoKXtjb25zdCB0PW5ldyB4O2ZvcihsZXQgZT10aGlzLl9lZGdlTGlzdC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTtuLmlzQ29sbGFwc2VkKCkmJihlLnJlbW92ZSgpLHQuYWRkKG4uZ2V0Q29sbGFwc2VkRWRnZSgpKSl9dGhpcy5fZWRnZUxpc3QuYWRkQWxsKHQpfXVwZGF0ZU5vZGVMYWJlbGxpbmcoKXtmb3IobGV0IHQ9dGhpcy5fZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxuPWUuZ2V0RWRnZXMoKS5nZXRMYWJlbCgpO2UuZ2V0TGFiZWwoKS5tZXJnZShuKX19Z2V0UmVzdWx0R2VvbWV0cnkodCl7cmV0dXJuIHRoaXMuY29tcHV0ZU92ZXJsYXkodCksdGhpcy5fcmVzdWx0R2VvbX1pbnNlcnRVbmlxdWVFZGdlcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0aGlzLmluc2VydFVuaXF1ZUVkZ2UodCl9fWNvbXB1dGVPdmVybGF5KHQpe3RoaXMuY29weVBvaW50cygwKSx0aGlzLmNvcHlQb2ludHMoMSksdGhpcy5fYXJnWzBdLmNvbXB1dGVTZWxmTm9kZXModGhpcy5fbGksITEpLHRoaXMuX2FyZ1sxXS5jb21wdXRlU2VsZk5vZGVzKHRoaXMuX2xpLCExKSx0aGlzLl9hcmdbMF0uY29tcHV0ZUVkZ2VJbnRlcnNlY3Rpb25zKHRoaXMuX2FyZ1sxXSx0aGlzLl9saSwhMCk7Y29uc3QgZT1uZXcgeDt0aGlzLl9hcmdbMF0uY29tcHV0ZVNwbGl0RWRnZXMoZSksdGhpcy5fYXJnWzFdLmNvbXB1dGVTcGxpdEVkZ2VzKGUpLHRoaXMuaW5zZXJ0VW5pcXVlRWRnZXMoZSksdGhpcy5jb21wdXRlTGFiZWxzRnJvbURlcHRocygpLHRoaXMucmVwbGFjZUNvbGxhcHNlZEVkZ2VzKCksJGkuY2hlY2tWYWxpZCh0aGlzLl9lZGdlTGlzdC5nZXRFZGdlcygpKSx0aGlzLl9ncmFwaC5hZGRFZGdlcyh0aGlzLl9lZGdlTGlzdC5nZXRFZGdlcygpKSx0aGlzLmNvbXB1dGVMYWJlbGxpbmcoKSx0aGlzLmxhYmVsSW5jb21wbGV0ZU5vZGVzKCksdGhpcy5maW5kUmVzdWx0QXJlYUVkZ2VzKHQpLHRoaXMuY2FuY2VsRHVwbGljYXRlUmVzdWx0RWRnZXMoKTtjb25zdCBuPW5ldyBlaSh0aGlzLl9nZW9tRmFjdCk7bi5hZGQodGhpcy5fZ3JhcGgpLHRoaXMuX3Jlc3VsdFBvbHlMaXN0PW4uZ2V0UG9seWdvbnMoKTtjb25zdCBzPW5ldyB0cih0aGlzLHRoaXMuX2dlb21GYWN0LHRoaXMuX3B0TG9jYXRvcik7dGhpcy5fcmVzdWx0TGluZUxpc3Q9cy5idWlsZCh0KTtjb25zdCBpPW5ldyBlcih0aGlzLHRoaXMuX2dlb21GYWN0LHRoaXMuX3B0TG9jYXRvcik7dGhpcy5fcmVzdWx0UG9pbnRMaXN0PWkuYnVpbGQodCksdGhpcy5fcmVzdWx0R2VvbT10aGlzLmNvbXB1dGVHZW9tZXRyeSh0aGlzLl9yZXN1bHRQb2ludExpc3QsdGhpcy5fcmVzdWx0TGluZUxpc3QsdGhpcy5fcmVzdWx0UG9seUxpc3QsdCl9bGFiZWxJbmNvbXBsZXRlTm9kZSh0LGUpe2NvbnN0IG49dGhpcy5fcHRMb2NhdG9yLmxvY2F0ZSh0LmdldENvb3JkaW5hdGUoKSx0aGlzLl9hcmdbZV0uZ2V0R2VvbWV0cnkoKSk7dC5nZXRMYWJlbCgpLnNldExvY2F0aW9uKGUsbil9Y29weVBvaW50cyh0KXtmb3IobGV0IGU9dGhpcy5fYXJnW3RdLmdldE5vZGVJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0aGlzLl9ncmFwaC5hZGROb2RlKG4uZ2V0Q29vcmRpbmF0ZSgpKS5zZXRMYWJlbCh0LG4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KSl9fWZpbmRSZXN1bHRBcmVhRWRnZXModCl7Zm9yKGxldCBlPXRoaXMuX2dyYXBoLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkscz1uLmdldExhYmVsKCk7cy5pc0FyZWEoKSYmIW4uaXNJbnRlcmlvckFyZWFFZGdlKCkmJmNyLmlzUmVzdWx0T2ZPcChzLmdldExvY2F0aW9uKDAsUG4uUklHSFQpLHMuZ2V0TG9jYXRpb24oMSxQbi5SSUdIVCksdCkmJm4uc2V0SW5SZXN1bHQoITApfX1jb21wdXRlTGFiZWxzRnJvbURlcHRocygpe2ZvcihsZXQgdD10aGlzLl9lZGdlTGlzdC5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKSxuPWUuZ2V0TGFiZWwoKSxzPWUuZ2V0RGVwdGgoKTtpZighcy5pc051bGwoKSl7cy5ub3JtYWxpemUoKTtmb3IobGV0IHQ9MDt0PDI7dCsrKW4uaXNOdWxsKHQpfHwhbi5pc0FyZWEoKXx8cy5pc051bGwodCl8fCgwPT09cy5nZXREZWx0YSh0KT9uLnRvTGluZSh0KToodS5pc1RydWUoIXMuaXNOdWxsKHQsUG4uTEVGVCksXCJkZXB0aCBvZiBMRUZUIHNpZGUgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkXCIpLG4uc2V0TG9jYXRpb24odCxQbi5MRUZULHMuZ2V0TG9jYXRpb24odCxQbi5MRUZUKSksdS5pc1RydWUoIXMuaXNOdWxsKHQsUG4uUklHSFQpLFwiZGVwdGggb2YgUklHSFQgc2lkZSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWRcIiksbi5zZXRMb2NhdGlvbih0LFBuLlJJR0hULHMuZ2V0TG9jYXRpb24odCxQbi5SSUdIVCkpKSl9fX1jb21wdXRlTGFiZWxsaW5nKCl7Zm9yKGxldCB0PXRoaXMuX2dyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLmdldEVkZ2VzKCkuY29tcHV0ZUxhYmVsbGluZyh0aGlzLl9hcmcpfXRoaXMubWVyZ2VTeW1MYWJlbHMoKSx0aGlzLnVwZGF0ZU5vZGVMYWJlbGxpbmcoKX1sYWJlbEluY29tcGxldGVOb2Rlcygpe2ZvcihsZXQgdD10aGlzLl9ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLG49ZS5nZXRMYWJlbCgpO2UuaXNJc29sYXRlZCgpJiYobi5pc051bGwoMCk/dGhpcy5sYWJlbEluY29tcGxldGVOb2RlKGUsMCk6dGhpcy5sYWJlbEluY29tcGxldGVOb2RlKGUsMSkpLGUuZ2V0RWRnZXMoKS51cGRhdGVMYWJlbGxpbmcobil9fWlzQ292ZXJlZEJ5QSh0KXtyZXR1cm4hIXRoaXMuaXNDb3ZlcmVkKHQsdGhpcy5fcmVzdWx0UG9seUxpc3QpfWdldENsYXNzKCl7cmV0dXJuIGNyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9wdExvY2F0b3I9bmV3IF9uLHRoaXMuX2dlb21GYWN0PW51bGwsdGhpcy5fcmVzdWx0R2VvbT1udWxsLHRoaXMuX2dyYXBoPW51bGwsdGhpcy5fZWRnZUxpc3Q9bmV3IGRpLHRoaXMuX3Jlc3VsdFBvbHlMaXN0PW5ldyB4LHRoaXMuX3Jlc3VsdExpbmVMaXN0PW5ldyB4LHRoaXMuX3Jlc3VsdFBvaW50TGlzdD1uZXcgeDtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTthci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSksdGhpcy5fZ3JhcGg9bmV3IFpuKG5ldyB1aSksdGhpcy5fZ2VvbUZhY3Q9dC5nZXRGYWN0b3J5KCl9LGNyLklOVEVSU0VDVElPTj0xLGNyLlVOSU9OPTIsY3IuRElGRkVSRU5DRT0zLGNyLlNZTURJRkZFUkVOQ0U9NDt2YXIgaHI9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsc25hcDpLaSxPdmVybGF5T3A6Y3J9KTtjbGFzcyB1ciBleHRlbmRzIGJpe2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx1ci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldE5leHQoKXtyZXR1cm4gdGhpcy5fbmV4dH1pc0luUmluZygpe3JldHVybiBudWxsIT09dGhpcy5fZWRnZVJpbmd9c2V0UmluZyh0KXt0aGlzLl9lZGdlUmluZz10fXNldExhYmVsKHQpe3RoaXMuX2xhYmVsPXR9Z2V0TGFiZWwoKXtyZXR1cm4gdGhpcy5fbGFiZWx9c2V0TmV4dCh0KXt0aGlzLl9uZXh0PXR9Z2V0UmluZygpe3JldHVybiB0aGlzLl9lZGdlUmluZ31nZXRDbGFzcygpe3JldHVybiB1cn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19dXIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZWRnZVJpbmc9bnVsbCx0aGlzLl9uZXh0PW51bGwsdGhpcy5fbGFiZWw9LTE7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107YmkuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsbixzKX07Y2xhc3MgZ3IgZXh0ZW5kcyBEaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksZ3IuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRMaW5lKCl7cmV0dXJuIHRoaXMuX2xpbmV9Z2V0Q2xhc3MoKXtyZXR1cm4gZ3J9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWdyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpbmU9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lPXR9O2NsYXNzIGRye2NvbnN0cnVjdG9yKCl7ZHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZmluZERpZmZlcmVudFBvaW50KHQsZSl7Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspaWYoIXRbbl0uZXF1YWxzKGUpKXJldHVybiB0W25dO3JldHVybiBudWxsfXZpc2l0SW50ZXJpb3JSaW5nKHQsZSl7Y29uc3Qgbj10LmdldENvb3JkaW5hdGVzKCkscz1uWzBdLGk9ZHIuZmluZERpZmZlcmVudFBvaW50KG4scykscj1lLmZpbmRFZGdlSW5TYW1lRGlyZWN0aW9uKHMsaSksbz1lLmZpbmRFZGdlRW5kKHIpO2xldCBsPW51bGw7by5nZXRMYWJlbCgpLmdldExvY2F0aW9uKDAsUG4uUklHSFQpPT09bmUuSU5URVJJT1I/bD1vOm8uZ2V0U3ltKCkuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbigwLFBuLlJJR0hUKT09PW5lLklOVEVSSU9SJiYobD1vLmdldFN5bSgpKSx1LmlzVHJ1ZShudWxsIT09bCxcInVuYWJsZSB0byBmaW5kIGRpckVkZ2Ugd2l0aCBJbnRlcmlvciBvbiBSSFNcIiksdGhpcy52aXNpdExpbmtlZERpcmVjdGVkRWRnZXMobCl9dmlzaXRTaGVsbEludGVyaW9ycyh0LGUpe2lmKHQgaW5zdGFuY2VvZiBidCl7Y29uc3Qgbj10O3RoaXMudmlzaXRJbnRlcmlvclJpbmcobi5nZXRFeHRlcmlvclJpbmcoKSxlKX1pZih0IGluc3RhbmNlb2YgQXQpe2NvbnN0IG49dDtmb3IobGV0IHQ9MDt0PG4uZ2V0TnVtR2VvbWV0cmllcygpO3QrKyl7Y29uc3Qgcz1uLmdldEdlb21ldHJ5Tih0KTt0aGlzLnZpc2l0SW50ZXJpb3JSaW5nKHMuZ2V0RXh0ZXJpb3JSaW5nKCksZSl9fX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX2Rpc2Nvbm5lY3RlZFJpbmdjb29yZH1zZXRJbnRlcmlvckVkZ2VzSW5SZXN1bHQodCl7Zm9yKGxldCBlPXQuZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0LmdldExhYmVsKCkuZ2V0TG9jYXRpb24oMCxQbi5SSUdIVCk9PT1uZS5JTlRFUklPUiYmdC5zZXRJblJlc3VsdCghMCl9fXZpc2l0TGlua2VkRGlyZWN0ZWRFZGdlcyh0KXtjb25zdCBlPXQ7bGV0IG49dDtkb3t1LmlzVHJ1ZShudWxsIT09bixcImZvdW5kIG51bGwgRGlyZWN0ZWQgRWRnZVwiKSxuLnNldFZpc2l0ZWQoITApLG49bi5nZXROZXh0KCl9d2hpbGUobiE9PWUpfWJ1aWxkRWRnZVJpbmdzKHQpe2NvbnN0IGU9bmV3IHg7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7aWYodC5pc0luUmVzdWx0KCkmJm51bGw9PT10LmdldEVkZ2VSaW5nKCkpe2NvbnN0IG49bmV3IHRpKHQsdGhpcy5fZ2VvbWV0cnlGYWN0b3J5KTtuLmxpbmtEaXJlY3RlZEVkZ2VzRm9yTWluaW1hbEVkZ2VSaW5ncygpO2NvbnN0IHM9bi5idWlsZE1pbmltYWxSaW5ncygpO2UuYWRkQWxsKHMpfX1yZXR1cm4gZX1oYXNVbnZpc2l0ZWRTaGVsbEVkZ2UodCl7Zm9yKGxldCBlPTA7ZTx0LnNpemUoKTtlKyspe2NvbnN0IG49dC5nZXQoZSk7aWYobi5pc0hvbGUoKSljb250aW51ZTtjb25zdCBzPW4uZ2V0RWRnZXMoKTtsZXQgaT1zLmdldCgwKTtpZihpLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oMCxQbi5SSUdIVCk9PT1uZS5JTlRFUklPUilmb3IobGV0IHQ9MDt0PHMuc2l6ZSgpO3QrKylpZihpPXMuZ2V0KHQpLCFpLmlzVmlzaXRlZCgpKXJldHVybiB0aGlzLl9kaXNjb25uZWN0ZWRSaW5nY29vcmQ9aS5nZXRDb29yZGluYXRlKCksITB9cmV0dXJuITF9aXNJbnRlcmlvcnNDb25uZWN0ZWQoKXtjb25zdCB0PW5ldyB4O3RoaXMuX2dlb21HcmFwaC5jb21wdXRlU3BsaXRFZGdlcyh0KTtjb25zdCBlPW5ldyBabihuZXcgdWkpO2UuYWRkRWRnZXModCksdGhpcy5zZXRJbnRlcmlvckVkZ2VzSW5SZXN1bHQoZSksZS5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcygpO2NvbnN0IG49dGhpcy5idWlsZEVkZ2VSaW5ncyhlLmdldEVkZ2VFbmRzKCkpO3JldHVybiB0aGlzLnZpc2l0U2hlbGxJbnRlcmlvcnModGhpcy5fZ2VvbUdyYXBoLmdldEdlb21ldHJ5KCksZSksIXRoaXMuaGFzVW52aXNpdGVkU2hlbGxFZGdlKG4pfWdldENsYXNzKCl7cmV0dXJuIGRyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1kci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9nZW9tZXRyeUZhY3Rvcnk9bmV3IEh0LHRoaXMuX2dlb21HcmFwaD1udWxsLHRoaXMuX2Rpc2Nvbm5lY3RlZFJpbmdjb29yZD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb21HcmFwaD10fTtjbGFzcyBfcntjb25zdHJ1Y3Rvcigpe19yLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y3JlYXRlRWRnZUVuZEZvck5leHQodCxlLG4scyl7Y29uc3QgaT1uLnNlZ21lbnRJbmRleCsxO2lmKGk+PXQuZ2V0TnVtUG9pbnRzKCkmJm51bGw9PT1zKXJldHVybiBudWxsO2xldCByPXQuZ2V0Q29vcmRpbmF0ZShpKTtudWxsIT09cyYmcy5zZWdtZW50SW5kZXg9PT1uLnNlZ21lbnRJbmRleCYmKHI9cy5jb29yZCk7Y29uc3Qgbz1uZXcgSG4odCxuLmNvb3JkLHIsbmV3IEZuKHQuZ2V0TGFiZWwoKSkpO2UuYWRkKG8pfWNyZWF0ZUVkZ2VFbmRGb3JQcmV2KHQsZSxuLHMpe2xldCBpPW4uc2VnbWVudEluZGV4O2lmKDA9PT1uLmRpc3Qpe2lmKDA9PT1pKXJldHVybiBudWxsO2ktLX1sZXQgcj10LmdldENvb3JkaW5hdGUoaSk7bnVsbCE9PXMmJnMuc2VnbWVudEluZGV4Pj1pJiYocj1zLmNvb3JkKTtjb25zdCBvPW5ldyBGbih0LmdldExhYmVsKCkpO28uZmxpcCgpO2NvbnN0IGw9bmV3IEhuKHQsbi5jb29yZCxyLG8pO2UuYWRkKGwpfWNvbXB1dGVFZGdlRW5kcygpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPW5ldyB4O2ZvcihsZXQgbj10O24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTt0aGlzLmNvbXB1dGVFZGdlRW5kcyh0LGUpfXJldHVybiBlfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXQuZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKTtuLmFkZEVuZHBvaW50cygpO2NvbnN0IHM9bi5pdGVyYXRvcigpO2xldCBpPW51bGwscj1udWxsO2lmKCFzLmhhc05leHQoKSlyZXR1cm4gbnVsbDtsZXQgbz1zLm5leHQoKTtkb3tpPXIscj1vLG89bnVsbCxzLmhhc05leHQoKSYmKG89cy5uZXh0KCkpLG51bGwhPT1yJiYodGhpcy5jcmVhdGVFZGdlRW5kRm9yUHJldih0LGUscixpKSx0aGlzLmNyZWF0ZUVkZ2VFbmRGb3JOZXh0KHQsZSxyLG8pKX13aGlsZShudWxsIT09cil9fWdldENsYXNzKCl7cmV0dXJuIF9yfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1fci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIGZyIGV4dGVuZHMgSG57Y29uc3RydWN0b3IoKXtzdXBlcigpLGZyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aW5zZXJ0KHQpe3RoaXMuX2VkZ2VFbmRzLmFkZCh0KX1wcmludCh0KXt0LnByaW50bG4oXCJFZGdlRW5kQnVuZGxlLS1cXHgzZSBMYWJlbDogXCIrdGhpcy5fbGFiZWwpO2ZvcihsZXQgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtlLm5leHQoKS5wcmludCh0KSx0LnByaW50bG4oKX19aXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fZWRnZUVuZHMuaXRlcmF0b3IoKX1nZXRFZGdlRW5kcygpe3JldHVybiB0aGlzLl9lZGdlRW5kc31jb21wdXRlTGFiZWxPbih0LGUpe2xldCBuPTAscz0hMTtmb3IobGV0IGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgaT1lLm5leHQoKS5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpO2k9PT1uZS5CT1VOREFSWSYmbisrLGk9PT1uZS5JTlRFUklPUiYmKHM9ITApfWxldCBpPW5lLk5PTkU7cyYmKGk9bmUuSU5URVJJT1IpLG4+MCYmKGk9UW4uZGV0ZXJtaW5lQm91bmRhcnkoZSxuKSksdGhpcy5fbGFiZWwuc2V0TG9jYXRpb24odCxpKX1jb21wdXRlTGFiZWxTaWRlKHQsZSl7Zm9yKGxldCBuPXRoaXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7aWYocy5nZXRMYWJlbCgpLmlzQXJlYSgpKXtjb25zdCBuPXMuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0LGUpO2lmKG49PT1uZS5JTlRFUklPUilyZXR1cm4gdGhpcy5fbGFiZWwuc2V0TG9jYXRpb24odCxlLG5lLklOVEVSSU9SKSxudWxsO249PT1uZS5FWFRFUklPUiYmdGhpcy5fbGFiZWwuc2V0TG9jYXRpb24odCxlLG5lLkVYVEVSSU9SKX19fWdldExhYmVsKCl7cmV0dXJuIHRoaXMuX2xhYmVsfWNvbXB1dGVMYWJlbFNpZGVzKHQpe3RoaXMuY29tcHV0ZUxhYmVsU2lkZSh0LFBuLkxFRlQpLHRoaXMuY29tcHV0ZUxhYmVsU2lkZSh0LFBuLlJJR0hUKX11cGRhdGVJTSh0KXtVbi51cGRhdGVJTSh0aGlzLl9sYWJlbCx0KX1jb21wdXRlTGFiZWwodCl7bGV0IGU9ITE7Zm9yKGxldCB0PXRoaXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3QubmV4dCgpLmdldExhYmVsKCkuaXNBcmVhKCkmJihlPSEwKX10aGlzLl9sYWJlbD1lP25ldyBGbihuZS5OT05FLG5lLk5PTkUsbmUuTk9ORSk6bmV3IEZuKG5lLk5PTkUpO2ZvcihsZXQgbj0wO248MjtuKyspdGhpcy5jb21wdXRlTGFiZWxPbihuLHQpLGUmJnRoaXMuY29tcHV0ZUxhYmVsU2lkZXMobil9Z2V0Q2xhc3MoKXtyZXR1cm4gZnJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWZyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX2VkZ2VFbmRzPW5ldyB4LDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtmci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLG51bGwsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMV07SG4uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LmdldEVkZ2UoKSx0LmdldENvb3JkaW5hdGUoKSx0LmdldERpcmVjdGVkQ29vcmRpbmF0ZSgpLG5ldyBGbih0LmdldExhYmVsKCkpKSx0aGlzLmluc2VydCh0KX19O2NsYXNzIHByIGV4dGVuZHMgY2l7Y29uc3RydWN0b3IoKXtzdXBlcigpLHByLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dXBkYXRlSU0odCl7Zm9yKGxldCBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2UubmV4dCgpLnVwZGF0ZUlNKHQpfX1pbnNlcnQodCl7bGV0IGU9dGhpcy5fZWRnZU1hcC5nZXQodCk7bnVsbD09PWU/KGU9bmV3IGZyKHQpLHRoaXMuaW5zZXJ0RWRnZUVuZCh0LGUpKTplLmluc2VydCh0KX1nZXRDbGFzcygpe3JldHVybiBwcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19cHIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBtciBleHRlbmRzIGtue2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxtci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXVwZGF0ZUlNRnJvbUVkZ2VzKHQpe3RoaXMuX2VkZ2VzLnVwZGF0ZUlNKHQpfWNvbXB1dGVJTSh0KXt0LnNldEF0TGVhc3RJZlZhbGlkKHRoaXMuX2xhYmVsLmdldExvY2F0aW9uKDApLHRoaXMuX2xhYmVsLmdldExvY2F0aW9uKDEpLDApfWdldENsYXNzKCl7cmV0dXJuIG1yfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1tci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtrbi5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSl9O2NsYXNzIHlyIGV4dGVuZHMgS257Y29uc3RydWN0b3IoKXtzdXBlcigpLHlyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y3JlYXRlTm9kZSh0KXtyZXR1cm4gbmV3IG1yKHQsbmV3IHByKX1nZXRDbGFzcygpe3JldHVybiB5cn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19eXIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyB4cntjb25zdHJ1Y3Rvcigpe3hyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aW5zZXJ0RWRnZUVuZHModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dGhpcy5fbm9kZXMuYWRkKHQpfX1nZXROb2RlSXRlcmF0b3IoKXtyZXR1cm4gdGhpcy5fbm9kZXMuaXRlcmF0b3IoKX1jb3B5Tm9kZXNBbmRMYWJlbHModCxlKXtmb3IobGV0IG49dC5nZXROb2RlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7dGhpcy5fbm9kZXMuYWRkTm9kZSh0LmdldENvb3JkaW5hdGUoKSkuc2V0TGFiZWwoZSx0LmdldExhYmVsKCkuZ2V0TG9jYXRpb24oZSkpfX1idWlsZCh0KXt0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25Ob2Rlcyh0LDApLHRoaXMuY29weU5vZGVzQW5kTGFiZWxzKHQsMCk7Y29uc3QgZT0obmV3IF9yKS5jb21wdXRlRWRnZUVuZHModC5nZXRFZGdlSXRlcmF0b3IoKSk7dGhpcy5pbnNlcnRFZGdlRW5kcyhlKX1jb21wdXRlSW50ZXJzZWN0aW9uTm9kZXModCxlKXtmb3IobGV0IG49dC5nZXRFZGdlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCkscz10LmdldExhYmVsKCkuZ2V0TG9jYXRpb24oZSk7Zm9yKGxldCBuPXQuZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKSxpPXRoaXMuX25vZGVzLmFkZE5vZGUodC5jb29yZCk7cz09PW5lLkJPVU5EQVJZP2kuc2V0TGFiZWxCb3VuZGFyeShlKTppLmdldExhYmVsKCkuaXNOdWxsKGUpJiZpLnNldExhYmVsKGUsbmUuSU5URVJJT1IpfX19Z2V0Q2xhc3MoKXtyZXR1cm4geHJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXhyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX25vZGVzPW5ldyBYbihuZXcgeXIpfTtjbGFzcyBFcntjb25zdHJ1Y3Rvcigpe0VyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNOb2RlRWRnZUFyZWFMYWJlbHNDb25zaXN0ZW50KCl7Zm9yKGxldCB0PXRoaXMuX25vZGVHcmFwaC5nZXROb2RlSXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCk7aWYoIWUuZ2V0RWRnZXMoKS5pc0FyZWFMYWJlbHNDb25zaXN0ZW50KHRoaXMuX2dlb21HcmFwaCkpcmV0dXJuIHRoaXMuX2ludmFsaWRQb2ludD1lLmdldENvb3JkaW5hdGUoKS5jb3B5KCksITF9cmV0dXJuITB9Z2V0SW52YWxpZFBvaW50KCl7cmV0dXJuIHRoaXMuX2ludmFsaWRQb2ludH1oYXNEdXBsaWNhdGVSaW5ncygpe2ZvcihsZXQgdD10aGlzLl9ub2RlR3JhcGguZ2V0Tm9kZUl0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtmb3IobGV0IGU9dC5uZXh0KCkuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTtpZih0LmdldEVkZ2VFbmRzKCkuc2l6ZSgpPjEpcmV0dXJuIHRoaXMuX2ludmFsaWRQb2ludD10LmdldEVkZ2UoKS5nZXRDb29yZGluYXRlKDApLCEwfX1yZXR1cm4hMX1pc05vZGVDb25zaXN0ZW50QXJlYSgpe2NvbnN0IHQ9dGhpcy5fZ2VvbUdyYXBoLmNvbXB1dGVTZWxmTm9kZXModGhpcy5fbGksITAsITApO3JldHVybiB0Lmhhc1Byb3BlckludGVyc2VjdGlvbigpPyh0aGlzLl9pbnZhbGlkUG9pbnQ9dC5nZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCgpLCExKToodGhpcy5fbm9kZUdyYXBoLmJ1aWxkKHRoaXMuX2dlb21HcmFwaCksdGhpcy5pc05vZGVFZGdlQXJlYUxhYmVsc0NvbnNpc3RlbnQoKSl9Z2V0Q2xhc3MoKXtyZXR1cm4gRXJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUVyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpPW5ldyB0ZSx0aGlzLl9nZW9tR3JhcGg9bnVsbCx0aGlzLl9ub2RlR3JhcGg9bmV3IHhyLHRoaXMuX2ludmFsaWRQb2ludD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dlb21HcmFwaD10fTtjbGFzcyBJcntjb25zdHJ1Y3Rvcigpe0lyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9YnVpbGRJbmRleCgpe3RoaXMuX2luZGV4PW5ldyBFcztmb3IobGV0IHQ9MDt0PHRoaXMuX3JpbmdzLnNpemUoKTt0Kyspe2NvbnN0IGU9dGhpcy5fcmluZ3MuZ2V0KHQpLG49ZS5nZXRFbnZlbG9wZUludGVybmFsKCk7dGhpcy5faW5kZXguaW5zZXJ0KG4sZSl9fWdldE5lc3RlZFBvaW50KCl7cmV0dXJuIHRoaXMuX25lc3RlZFB0fWlzTm9uTmVzdGVkKCl7dGhpcy5idWlsZEluZGV4KCk7Zm9yKGxldCB0PTA7dDx0aGlzLl9yaW5ncy5zaXplKCk7dCsrKXtjb25zdCBlPXRoaXMuX3JpbmdzLmdldCh0KSxuPWUuZ2V0Q29vcmRpbmF0ZXMoKSxzPXRoaXMuX2luZGV4LnF1ZXJ5KGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKTtmb3IobGV0IHQ9MDt0PHMuc2l6ZSgpO3QrKyl7Y29uc3QgaT1zLmdldCh0KSxyPWkuZ2V0Q29vcmRpbmF0ZXMoKTtpZihlPT09aSljb250aW51ZTtpZighZS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhpLmdldEVudmVsb3BlSW50ZXJuYWwoKSkpY29udGludWU7Y29uc3Qgbz1Dci5maW5kUHROb3ROb2RlKG4saSx0aGlzLl9ncmFwaCk7aWYobnVsbCE9PW8mJldlLmlzSW5SaW5nKG8scikpcmV0dXJuIHRoaXMuX25lc3RlZFB0PW8sITF9fXJldHVybiEwfWFkZCh0KXt0aGlzLl9yaW5ncy5hZGQodCksdGhpcy5fdG90YWxFbnYuZXhwYW5kVG9JbmNsdWRlKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKX1nZXRDbGFzcygpe3JldHVybiBJcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19SXIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZ3JhcGg9bnVsbCx0aGlzLl9yaW5ncz1uZXcgeCx0aGlzLl90b3RhbEVudj1uZXcgTix0aGlzLl9pbmRleD1udWxsLHRoaXMuX25lc3RlZFB0PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ3JhcGg9dH07Y2xhc3MgTnJ7Y29uc3RydWN0b3IoKXtOci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldEVycm9yVHlwZSgpe3JldHVybiB0aGlzLl9lcnJvclR5cGV9Z2V0TWVzc2FnZSgpe3JldHVybiBOci5lcnJNc2dbdGhpcy5fZXJyb3JUeXBlXX1nZXRDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX3B0fXRvU3RyaW5nKCl7bGV0IHQ9XCJcIjtyZXR1cm4gbnVsbCE9PXRoaXMuX3B0JiYodD1cIiBhdCBvciBuZWFyIHBvaW50IFwiK3RoaXMuX3B0KSx0aGlzLmdldE1lc3NhZ2UoKSt0fWdldENsYXNzKCl7cmV0dXJuIE5yfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Oci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9lcnJvclR5cGU9bnVsbCx0aGlzLl9wdD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtOci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsbnVsbCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZXJyb3JUeXBlPXQsbnVsbCE9PWUmJih0aGlzLl9wdD1lLmNvcHkoKSl9fSxOci5FUlJPUj0wLE5yLlJFUEVBVEVEX1BPSU5UPTEsTnIuSE9MRV9PVVRTSURFX1NIRUxMPTIsTnIuTkVTVEVEX0hPTEVTPTMsTnIuRElTQ09OTkVDVEVEX0lOVEVSSU9SPTQsTnIuU0VMRl9JTlRFUlNFQ1RJT049NSxOci5SSU5HX1NFTEZfSU5URVJTRUNUSU9OPTYsTnIuTkVTVEVEX1NIRUxMUz03LE5yLkRVUExJQ0FURV9SSU5HUz04LE5yLlRPT19GRVdfUE9JTlRTPTksTnIuSU5WQUxJRF9DT09SRElOQVRFPTEwLE5yLlJJTkdfTk9UX0NMT1NFRD0xMSxOci5lcnJNc2c9W1wiVG9wb2xvZ3kgVmFsaWRhdGlvbiBFcnJvclwiLFwiUmVwZWF0ZWQgUG9pbnRcIixcIkhvbGUgbGllcyBvdXRzaWRlIHNoZWxsXCIsXCJIb2xlcyBhcmUgbmVzdGVkXCIsXCJJbnRlcmlvciBpcyBkaXNjb25uZWN0ZWRcIixcIlNlbGYtaW50ZXJzZWN0aW9uXCIsXCJSaW5nIFNlbGYtaW50ZXJzZWN0aW9uXCIsXCJOZXN0ZWQgc2hlbGxzXCIsXCJEdXBsaWNhdGUgUmluZ3NcIixcIlRvbyBmZXcgZGlzdGluY3QgcG9pbnRzIGluIGdlb21ldHJ5IGNvbXBvbmVudFwiLFwiSW52YWxpZCBDb29yZGluYXRlXCIsXCJSaW5nIGlzIG5vdCBjbG9zZWRcIl07Y2xhc3MgQ3J7Y29uc3RydWN0b3IoKXtDci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBmaW5kUHROb3ROb2RlKHQsZSxuKXtjb25zdCBzPW4uZmluZEVkZ2UoZSkuZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl7Y29uc3Qgbj10W2VdO2lmKCFzLmlzSW50ZXJzZWN0aW9uKG4pKXJldHVybiBufXJldHVybiBudWxsfXN0YXRpYyBpc1ZhbGlkKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IENyKHQpLmlzVmFsaWQoKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiFpLmlzTmFOKHQueCkmJighaS5pc0luZmluaXRlKHQueCkmJighaS5pc05hTih0LnkpJiYhaS5pc0luZmluaXRlKHQueSkpKX19Y2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXMoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtjb25zdCB0PWFyZ3VtZW50c1swXTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKylpZighQ3IuaXNWYWxpZCh0W2VdKSlyZXR1cm4gdGhpcy5fdmFsaWRFcnI9bmV3IE5yKE5yLklOVkFMSURfQ09PUkRJTkFURSx0W2VdKSxudWxsfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBidCl7Y29uc3QgdD1hcmd1bWVudHNbMF07aWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyh0LmdldEV4dGVyaW9yUmluZygpLmdldENvb3JkaW5hdGVzKCkpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKWlmKHRoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXModC5nZXRJbnRlcmlvclJpbmdOKGUpLmdldENvb3JkaW5hdGVzKCkpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbH19Y2hlY2tIb2xlc05vdE5lc3RlZCh0LGUpe2NvbnN0IG49bmV3IElyKGUpO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspe2NvbnN0IHM9dC5nZXRJbnRlcmlvclJpbmdOKGUpO24uYWRkKHMpfW4uaXNOb25OZXN0ZWQoKXx8KHRoaXMuX3ZhbGlkRXJyPW5ldyBOcihOci5ORVNURURfSE9MRVMsbi5nZXROZXN0ZWRQb2ludCgpKSl9Y2hlY2tDb25zaXN0ZW50QXJlYSh0KXtjb25zdCBlPW5ldyBFcih0KTtpZighZS5pc05vZGVDb25zaXN0ZW50QXJlYSgpKXJldHVybiB0aGlzLl92YWxpZEVycj1uZXcgTnIoTnIuU0VMRl9JTlRFUlNFQ1RJT04sZS5nZXRJbnZhbGlkUG9pbnQoKSksbnVsbDtlLmhhc0R1cGxpY2F0ZVJpbmdzKCkmJih0aGlzLl92YWxpZEVycj1uZXcgTnIoTnIuRFVQTElDQVRFX1JJTkdTLGUuZ2V0SW52YWxpZFBvaW50KCkpKX1pc1ZhbGlkKCl7cmV0dXJuIHRoaXMuY2hlY2tWYWxpZCh0aGlzLl9wYXJlbnRHZW9tZXRyeSksbnVsbD09PXRoaXMuX3ZhbGlkRXJyfWNoZWNrU2hlbGxJbnNpZGVIb2xlKHQsZSxuKXtjb25zdCBzPXQuZ2V0Q29vcmRpbmF0ZXMoKSxpPWUuZ2V0Q29vcmRpbmF0ZXMoKSxyPUNyLmZpbmRQdE5vdE5vZGUocyxlLG4pO2lmKG51bGwhPT1yKXtpZighV2UuaXNJblJpbmcocixpKSlyZXR1cm4gcn1jb25zdCBvPUNyLmZpbmRQdE5vdE5vZGUoaSx0LG4pO2lmKG51bGwhPT1vKXtyZXR1cm4gV2UuaXNJblJpbmcobyxzKT9vOm51bGx9cmV0dXJuIHUuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJwb2ludHMgaW4gc2hlbGwgYW5kIGhvbGUgYXBwZWFyIHRvIGJlIGVxdWFsXCIpLG51bGx9Y2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5ncyh0KXtmb3IobGV0IGU9dC5nZXRFZGdlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7aWYodGhpcy5jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmcodC5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9fWNoZWNrQ29ubmVjdGVkSW50ZXJpb3JzKHQpe2NvbnN0IGU9bmV3IGRyKHQpO2UuaXNJbnRlcmlvcnNDb25uZWN0ZWQoKXx8KHRoaXMuX3ZhbGlkRXJyPW5ldyBOcihOci5ESVNDT05ORUNURURfSU5URVJJT1IsZS5nZXRDb29yZGluYXRlKCkpKX1jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmcodCl7Y29uc3QgZT1uZXcgYXQ7bGV0IG49ITA7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7aWYobiluPSExO2Vsc2V7aWYoZS5jb250YWlucyh0LmNvb3JkKSlyZXR1cm4gdGhpcy5fdmFsaWRFcnI9bmV3IE5yKE5yLlJJTkdfU0VMRl9JTlRFUlNFQ1RJT04sdC5jb29yZCksbnVsbDtlLmFkZCh0LmNvb3JkKX19fWNoZWNrSG9sZXNJblNoZWxsKHQsZSl7Y29uc3Qgbj10LmdldEV4dGVyaW9yUmluZygpLHM9bmV3IGtlKG4pO2ZvcihsZXQgaT0wO2k8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtpKyspe2NvbnN0IHI9dC5nZXRJbnRlcmlvclJpbmdOKGkpLG89Q3IuZmluZFB0Tm90Tm9kZShyLmdldENvb3JkaW5hdGVzKCksbixlKTtpZihudWxsPT09bylyZXR1cm4gbnVsbDtpZihuZS5FWFRFUklPUj09PXMubG9jYXRlKG8pKXJldHVybiB0aGlzLl92YWxpZEVycj1uZXcgTnIoTnIuSE9MRV9PVVRTSURFX1NIRUxMLG8pLG51bGx9fWNoZWNrVG9vRmV3UG9pbnRzKHQpe2lmKHQuaGFzVG9vRmV3UG9pbnRzKCkpcmV0dXJuIHRoaXMuX3ZhbGlkRXJyPW5ldyBOcihOci5UT09fRkVXX1BPSU5UUyx0LmdldEludmFsaWRQb2ludCgpKSxudWxsfWdldFZhbGlkYXRpb25FcnJvcigpe3JldHVybiB0aGlzLmNoZWNrVmFsaWQodGhpcy5fcGFyZW50R2VvbWV0cnkpLHRoaXMuX3ZhbGlkRXJyfWNoZWNrVmFsaWQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFB0KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZXMoKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE10KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZXMoKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIER0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZXMoKSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDbG9zZWRSaW5nKHQpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtjb25zdCBlPW5ldyBRbigwLHQpO2lmKHRoaXMuY2hlY2tUb29GZXdQb2ludHMoZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2NvbnN0IG49bmV3IHRlO2UuY29tcHV0ZVNlbGZOb2RlcyhuLCEwLCEwKSx0aGlzLmNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZ3MoZSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFR0KXtjb25zdCB0PWFyZ3VtZW50c1swXTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZXMoKSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2NvbnN0IGU9bmV3IFFuKDAsdCk7dGhpcy5jaGVja1Rvb0Zld1BvaW50cyhlKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgYnQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXModCksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDbG9zZWRSaW5ncyh0KSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7Y29uc3QgZT1uZXcgUW4oMCx0KTtpZih0aGlzLmNoZWNrVG9vRmV3UG9pbnRzKGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ29uc2lzdGVudEFyZWEoZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2lmKCF0aGlzLl9pc1NlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkJiYodGhpcy5jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmdzKGUpLG51bGwhPT10aGlzLl92YWxpZEVycikpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0hvbGVzSW5TaGVsbCh0LGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrSG9sZXNOb3ROZXN0ZWQodCxlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGw7dGhpcy5jaGVja0Nvbm5lY3RlZEludGVyaW9ycyhlKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXQpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2ZvcihsZXQgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXtjb25zdCBuPXQuZ2V0R2VvbWV0cnlOKGUpO2lmKHRoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXMobiksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDbG9zZWRSaW5ncyhuKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9Y29uc3QgZT1uZXcgUW4oMCx0KTtpZih0aGlzLmNoZWNrVG9vRmV3UG9pbnRzKGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ29uc2lzdGVudEFyZWEoZSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsO2lmKCF0aGlzLl9pc1NlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkJiYodGhpcy5jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmdzKGUpLG51bGwhPT10aGlzLl92YWxpZEVycikpcmV0dXJuIG51bGw7Zm9yKGxldCBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe2NvbnN0IHM9dC5nZXRHZW9tZXRyeU4obik7aWYodGhpcy5jaGVja0hvbGVzSW5TaGVsbChzLGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbH1mb3IobGV0IG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7Y29uc3Qgcz10LmdldEdlb21ldHJ5TihuKTtpZih0aGlzLmNoZWNrSG9sZXNOb3ROZXN0ZWQocyxlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9aWYodGhpcy5jaGVja1NoZWxsc05vdE5lc3RlZCh0LGUpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDt0aGlzLmNoZWNrQ29ubmVjdGVkSW50ZXJpb3JzKGUpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07Zm9yKGxldCBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe2NvbnN0IG49dC5nZXRHZW9tZXRyeU4oZSk7aWYodGhpcy5jaGVja1ZhbGlkKG4pLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbH19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO2lmKHRoaXMuX3ZhbGlkRXJyPW51bGwsdC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7aWYodCBpbnN0YW5jZW9mIFB0KXRoaXMuY2hlY2tWYWxpZCh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBNdCl0aGlzLmNoZWNrVmFsaWQodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgRHQpdGhpcy5jaGVja1ZhbGlkKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIFR0KXRoaXMuY2hlY2tWYWxpZCh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBidCl0aGlzLmNoZWNrVmFsaWQodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgQXQpdGhpcy5jaGVja1ZhbGlkKHQpO2Vsc2V7aWYoISh0IGluc3RhbmNlb2YgX3QpKXRocm93IG5ldyBaKHQuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpO3RoaXMuY2hlY2tWYWxpZCh0KX19fXNldFNlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkKHQpe3RoaXMuX2lzU2VsZlRvdWNoaW5nUmluZ0Zvcm1pbmdIb2xlVmFsaWQ9dH1jaGVja1NoZWxsTm90TmVzdGVkKHQsZSxuKXtjb25zdCBzPXQuZ2V0Q29vcmRpbmF0ZXMoKSxpPWUuZ2V0RXh0ZXJpb3JSaW5nKCkscj1pLmdldENvb3JkaW5hdGVzKCksbz1Dci5maW5kUHROb3ROb2RlKHMsaSxuKTtpZihudWxsPT09bylyZXR1cm4gbnVsbDtpZighV2UuaXNJblJpbmcobyxyKSlyZXR1cm4gbnVsbDtpZihlLmdldE51bUludGVyaW9yUmluZygpPD0wKXJldHVybiB0aGlzLl92YWxpZEVycj1uZXcgTnIoTnIuTkVTVEVEX1NIRUxMUyxvKSxudWxsO2xldCBsPW51bGw7Zm9yKGxldCBzPTA7czxlLmdldE51bUludGVyaW9yUmluZygpO3MrKyl7Y29uc3QgaT1lLmdldEludGVyaW9yUmluZ04ocyk7aWYobD10aGlzLmNoZWNrU2hlbGxJbnNpZGVIb2xlKHQsaSxuKSxudWxsPT09bClyZXR1cm4gbnVsbH10aGlzLl92YWxpZEVycj1uZXcgTnIoTnIuTkVTVEVEX1NIRUxMUyxsKX1jaGVja0Nsb3NlZFJpbmdzKHQpe2lmKHRoaXMuY2hlY2tDbG9zZWRSaW5nKHQuZ2V0RXh0ZXJpb3JSaW5nKCkpLG51bGwhPT10aGlzLl92YWxpZEVycilyZXR1cm4gbnVsbDtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKWlmKHRoaXMuY2hlY2tDbG9zZWRSaW5nKHQuZ2V0SW50ZXJpb3JSaW5nTihlKSksbnVsbCE9PXRoaXMuX3ZhbGlkRXJyKXJldHVybiBudWxsfWNoZWNrQ2xvc2VkUmluZyh0KXtpZighdC5pc0Nsb3NlZCgpKXtsZXQgZT1udWxsO3QuZ2V0TnVtUG9pbnRzKCk+PTEmJihlPXQuZ2V0Q29vcmRpbmF0ZU4oMCkpLHRoaXMuX3ZhbGlkRXJyPW5ldyBOcihOci5SSU5HX05PVF9DTE9TRUQsZSl9fWNoZWNrU2hlbGxzTm90TmVzdGVkKHQsZSl7Zm9yKGxldCBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe2NvbnN0IHM9dC5nZXRHZW9tZXRyeU4obikuZ2V0RXh0ZXJpb3JSaW5nKCk7Zm9yKGxldCBpPTA7aTx0LmdldE51bUdlb21ldHJpZXMoKTtpKyspe2lmKG49PT1pKWNvbnRpbnVlO2NvbnN0IHI9dC5nZXRHZW9tZXRyeU4oaSk7aWYodGhpcy5jaGVja1NoZWxsTm90TmVzdGVkKHMscixlKSxudWxsIT09dGhpcy5fdmFsaWRFcnIpcmV0dXJuIG51bGx9fX1nZXRDbGFzcygpe3JldHVybiBDcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Q3IuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcGFyZW50R2VvbWV0cnk9bnVsbCx0aGlzLl9pc1NlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkPSExLHRoaXMuX3ZhbGlkRXJyPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcGFyZW50R2VvbWV0cnk9dH07Y2xhc3MgU3J7Y29uc3RydWN0b3IoKXtTci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBmaW5kRGlyRWRnZXNJblJpbmcodCl7bGV0IGU9dDtjb25zdCBuPW5ldyB4O2Rve24uYWRkKGUpLGU9ZS5nZXROZXh0KCksdS5pc1RydWUobnVsbCE9PWUsXCJmb3VuZCBudWxsIERFIGluIHJpbmdcIiksdS5pc1RydWUoZT09PXR8fCFlLmlzSW5SaW5nKCksXCJmb3VuZCBERSBhbHJlYWR5IGluIHJpbmdcIil9d2hpbGUoZSE9PXQpO3JldHVybiBufXN0YXRpYyBhZGRFZGdlKHQsZSxuKXtpZihlKWZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKW4uYWRkKHRbZV0sITEpO2Vsc2UgZm9yKGxldCBlPXQubGVuZ3RoLTE7ZT49MDtlLS0pbi5hZGQodFtlXSwhMSl9c3RhdGljIGZpbmRFZGdlUmluZ0NvbnRhaW5pbmcodCxlKXtjb25zdCBuPXQuZ2V0UmluZygpLHM9bi5nZXRFbnZlbG9wZUludGVybmFsKCk7bGV0IGk9bi5nZXRDb29yZGluYXRlTigwKSxyPW51bGwsbz1udWxsO2ZvcihsZXQgdD1lLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpLGw9ZS5nZXRSaW5nKCksYT1sLmdldEVudmVsb3BlSW50ZXJuYWwoKTtpZihhLmVxdWFscyhzKSljb250aW51ZTtpZighYS5jb250YWlucyhzKSljb250aW51ZTtpPVgucHROb3RJbkxpc3Qobi5nZXRDb29yZGluYXRlcygpLGwuZ2V0Q29vcmRpbmF0ZXMoKSk7bGV0IGM9ITE7V2UuaXNJblJpbmcoaSxsLmdldENvb3JkaW5hdGVzKCkpJiYoYz0hMCksYyYmKG51bGw9PT1yfHxvLmNvbnRhaW5zKGEpKSYmKHI9ZSxvPXIuZ2V0UmluZygpLmdldEVudmVsb3BlSW50ZXJuYWwoKSl9cmV0dXJuIHJ9aXNJbmNsdWRlZCgpe3JldHVybiB0aGlzLl9pc0luY2x1ZGVkfWdldENvb3JkaW5hdGVzKCl7aWYobnVsbD09PXRoaXMuX3JpbmdQdHMpe2NvbnN0IHQ9bmV3IEk7Zm9yKGxldCBlPXRoaXMuX2RlTGlzdC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKSxzPW4uZ2V0RWRnZSgpO1NyLmFkZEVkZ2Uocy5nZXRMaW5lKCkuZ2V0Q29vcmRpbmF0ZXMoKSxuLmdldEVkZ2VEaXJlY3Rpb24oKSx0KX10aGlzLl9yaW5nUHRzPXQudG9Db29yZGluYXRlQXJyYXkoKX1yZXR1cm4gdGhpcy5fcmluZ1B0c31pc0luY2x1ZGVkU2V0KCl7cmV0dXJuIHRoaXMuX2lzSW5jbHVkZWRTZXR9aXNWYWxpZCgpe3JldHVybiB0aGlzLmdldENvb3JkaW5hdGVzKCksISh0aGlzLl9yaW5nUHRzLmxlbmd0aDw9MykmJih0aGlzLmdldFJpbmcoKSxDci5pc1ZhbGlkKHRoaXMuX3JpbmcpKX1idWlsZCh0KXtsZXQgZT10O2Rve3RoaXMuYWRkKGUpLGUuc2V0UmluZyh0aGlzKSxlPWUuZ2V0TmV4dCgpLHUuaXNUcnVlKG51bGwhPT1lLFwiZm91bmQgbnVsbCBERSBpbiByaW5nXCIpLHUuaXNUcnVlKGU9PT10fHwhZS5pc0luUmluZygpLFwiZm91bmQgREUgYWxyZWFkeSBpbiByaW5nXCIpfXdoaWxlKGUhPT10KX1pc091dGVySG9sZSgpe3JldHVybiEhdGhpcy5faXNIb2xlJiYhdGhpcy5oYXNTaGVsbCgpfWdldFBvbHlnb24oKXtsZXQgdD1udWxsO2lmKG51bGwhPT10aGlzLl9ob2xlcyl7dD1uZXcgQXJyYXkodGhpcy5faG9sZXMuc2l6ZSgpKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dGhpcy5faG9sZXMuc2l6ZSgpO2UrKyl0W2VdPXRoaXMuX2hvbGVzLmdldChlKX1yZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2x5Z29uKHRoaXMuX3JpbmcsdCl9aXNIb2xlKCl7cmV0dXJuIHRoaXMuX2lzSG9sZX1pc1Byb2Nlc3NlZCgpe3JldHVybiB0aGlzLl9pc1Byb2Nlc3NlZH1hZGRIb2xlKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBEdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07bnVsbD09PXRoaXMuX2hvbGVzJiYodGhpcy5faG9sZXM9bmV3IHgpLHRoaXMuX2hvbGVzLmFkZCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgU3Ipe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3Quc2V0U2hlbGwodGhpcyk7Y29uc3QgZT10LmdldFJpbmcoKTtudWxsPT09dGhpcy5faG9sZXMmJih0aGlzLl9ob2xlcz1uZXcgeCksdGhpcy5faG9sZXMuYWRkKGUpfX1zZXRJbmNsdWRlZCh0KXt0aGlzLl9pc0luY2x1ZGVkPXQsdGhpcy5faXNJbmNsdWRlZFNldD0hMH1nZXRPdXRlckhvbGUoKXtpZih0aGlzLmlzSG9sZSgpKXJldHVybiBudWxsO2ZvcihsZXQgdD0wO3Q8dGhpcy5fZGVMaXN0LnNpemUoKTt0Kyspe2NvbnN0IGU9dGhpcy5fZGVMaXN0LmdldCh0KS5nZXRTeW0oKS5nZXRSaW5nKCk7aWYoZS5pc091dGVySG9sZSgpKXJldHVybiBlfXJldHVybiBudWxsfWNvbXB1dGVIb2xlKCl7Y29uc3QgdD10aGlzLmdldFJpbmcoKTt0aGlzLl9pc0hvbGU9di5pc0NDVyh0LmdldENvb3JkaW5hdGVzKCkpfWhhc1NoZWxsKCl7cmV0dXJuIG51bGwhPT10aGlzLl9zaGVsbH1pc091dGVyU2hlbGwoKXtyZXR1cm4gbnVsbCE9PXRoaXMuZ2V0T3V0ZXJIb2xlKCl9Z2V0TGluZVN0cmluZygpe3JldHVybiB0aGlzLmdldENvb3JkaW5hdGVzKCksdGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuX3JpbmdQdHMpfXRvU3RyaW5nKCl7cmV0dXJuIEp0LnRvTGluZVN0cmluZyhuZXcgenQodGhpcy5nZXRDb29yZGluYXRlcygpKSl9Z2V0U2hlbGwoKXtyZXR1cm4gdGhpcy5pc0hvbGUoKT90aGlzLl9zaGVsbDp0aGlzfWFkZCh0KXt0aGlzLl9kZUxpc3QuYWRkKHQpfWdldFJpbmcoKXtpZihudWxsIT09dGhpcy5fcmluZylyZXR1cm4gdGhpcy5fcmluZzt0aGlzLmdldENvb3JkaW5hdGVzKCksdGhpcy5fcmluZ1B0cy5sZW5ndGg8MyYmTy5vdXQucHJpbnRsbih0aGlzLl9yaW5nUHRzKTt0cnl7dGhpcy5fcmluZz10aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcodGhpcy5fcmluZ1B0cyl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgQykpdGhyb3cgdDtPLm91dC5wcmludGxuKHRoaXMuX3JpbmdQdHMpfXJldHVybiB0aGlzLl9yaW5nfXVwZGF0ZUluY2x1ZGVkKCl7aWYodGhpcy5pc0hvbGUoKSlyZXR1cm4gbnVsbDtmb3IobGV0IHQ9MDt0PHRoaXMuX2RlTGlzdC5zaXplKCk7dCsrKXtjb25zdCBlPXRoaXMuX2RlTGlzdC5nZXQodCkuZ2V0U3ltKCkuZ2V0UmluZygpLmdldFNoZWxsKCk7aWYobnVsbCE9PWUmJmUuaXNJbmNsdWRlZFNldCgpKXJldHVybiB0aGlzLnNldEluY2x1ZGVkKCFlLmlzSW5jbHVkZWQoKSksbnVsbH19c2V0U2hlbGwodCl7dGhpcy5fc2hlbGw9dH1zZXRQcm9jZXNzZWQodCl7dGhpcy5faXNQcm9jZXNzZWQ9dH1nZXRDbGFzcygpe3JldHVybiBTcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3Mgd3J7Y29uc3RydWN0b3IoKXt3ci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNvbXBhcmUodCxlKXtjb25zdCBuPWU7cmV0dXJuIHQuZ2V0UmluZygpLmdldEVudmVsb3BlKCkuY29tcGFyZVRvKG4uZ2V0UmluZygpLmdldEVudmVsb3BlKCkpfWdldENsYXNzKCl7cmV0dXJuIHdyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltsXX19d3IuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fSxTci5FbnZlbG9wZUNvbXBhcmF0b3I9d3IsU3IuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZmFjdG9yeT1udWxsLHRoaXMuX2RlTGlzdD1uZXcgeCx0aGlzLl9sb3dlc3RFZGdlPW51bGwsdGhpcy5fcmluZz1udWxsLHRoaXMuX3JpbmdQdHM9bnVsbCx0aGlzLl9ob2xlcz1udWxsLHRoaXMuX3NoZWxsPW51bGwsdGhpcy5faXNIb2xlPW51bGwsdGhpcy5faXNQcm9jZXNzZWQ9ITEsdGhpcy5faXNJbmNsdWRlZFNldD0hMSx0aGlzLl9pc0luY2x1ZGVkPSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2ZhY3Rvcnk9dH07Y2xhc3MgTHIgZXh0ZW5kcyBCaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksTHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZmluZExhYmVsZWRFZGdlUmluZ3ModCl7Y29uc3QgZT1uZXcgeDtsZXQgbj0xO2ZvcihsZXQgcz10Lml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCB0PXMubmV4dCgpO2lmKHQuaXNNYXJrZWQoKSljb250aW51ZTtpZih0LmdldExhYmVsKCk+PTApY29udGludWU7ZS5hZGQodCk7Y29uc3QgaT1Tci5maW5kRGlyRWRnZXNJblJpbmcodCk7THIubGFiZWwoaSxuKSxuKyt9cmV0dXJuIGV9c3RhdGljIGdldERlZ3JlZU5vbkRlbGV0ZWQodCl7bGV0IGU9MDtmb3IobGV0IG49dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe24ubmV4dCgpLmlzTWFya2VkKCl8fGUrK31yZXR1cm4gZX1zdGF0aWMgZGVsZXRlQWxsRWRnZXModCl7Zm9yKGxldCBlPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCB0PWUubmV4dCgpO3Quc2V0TWFya2VkKCEwKTtjb25zdCBuPXQuZ2V0U3ltKCk7bnVsbCE9PW4mJm4uc2V0TWFya2VkKCEwKX19c3RhdGljIGxhYmVsKHQsZSl7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe24ubmV4dCgpLnNldExhYmVsKGUpfX1zdGF0aWMgY29tcHV0ZU5leHRDV0VkZ2VzKHQpe2xldCBlPW51bGwsbj1udWxsO2ZvcihsZXQgcz10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTtpZighdC5pc01hcmtlZCgpKXtpZihudWxsPT09ZSYmKGU9dCksbnVsbCE9PW4pe24uZ2V0U3ltKCkuc2V0TmV4dCh0KX1uPXR9fWlmKG51bGwhPT1uKXtuLmdldFN5bSgpLnNldE5leHQoZSl9fXN0YXRpYyBjb21wdXRlTmV4dENDV0VkZ2VzKHQsZSl7bGV0IG49bnVsbCxzPW51bGw7Y29uc3QgaT10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKTtmb3IobGV0IHQ9aS5zaXplKCktMTt0Pj0wO3QtLSl7Y29uc3Qgcj1pLmdldCh0KSxvPXIuZ2V0U3ltKCk7bGV0IGw9bnVsbDtyLmdldExhYmVsKCk9PT1lJiYobD1yKTtsZXQgYT1udWxsO28uZ2V0TGFiZWwoKT09PWUmJihhPW8pLG51bGw9PT1sJiZudWxsPT09YXx8KG51bGwhPT1hJiYocz1hKSxudWxsIT09bCYmKG51bGwhPT1zJiYocy5zZXROZXh0KGwpLHM9bnVsbCksbnVsbD09PW4mJihuPWwpKSl9bnVsbCE9PXMmJih1LmlzVHJ1ZShudWxsIT09bikscy5zZXROZXh0KG4pKX1zdGF0aWMgZ2V0RGVncmVlKHQsZSl7bGV0IG49MDtmb3IobGV0IHM9dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe3MubmV4dCgpLmdldExhYmVsKCk9PT1lJiZuKyt9cmV0dXJuIG59c3RhdGljIGZpbmRJbnRlcnNlY3Rpb25Ob2Rlcyh0LGUpe2xldCBuPXQscz1udWxsO2Rve2NvbnN0IGk9bi5nZXRGcm9tTm9kZSgpO0xyLmdldERlZ3JlZShpLGUpPjEmJihudWxsPT09cyYmKHM9bmV3IHgpLHMuYWRkKGkpKSxuPW4uZ2V0TmV4dCgpLHUuaXNUcnVlKG51bGwhPT1uLFwiZm91bmQgbnVsbCBERSBpbiByaW5nXCIpLHUuaXNUcnVlKG49PT10fHwhbi5pc0luUmluZygpLFwiZm91bmQgREUgYWxyZWFkeSBpbiByaW5nXCIpfXdoaWxlKG4hPT10KTtyZXR1cm4gc31maW5kRWRnZVJpbmcodCl7Y29uc3QgZT1uZXcgU3IodGhpcy5fZmFjdG9yeSk7cmV0dXJuIGUuYnVpbGQodCksZX1jb21wdXRlRGVwdGhQYXJpdHkoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClmb3IoOzspcmV0dXJuIG51bGx9Y29tcHV0ZU5leHRDV0VkZ2VzKCl7Zm9yKGxldCB0PXRoaXMubm9kZUl0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO0xyLmNvbXB1dGVOZXh0Q1dFZGdlcyhlKX19YWRkRWRnZSh0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBlPVgucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKTtpZihlLmxlbmd0aDwyKXJldHVybiBudWxsO2NvbnN0IG49ZVswXSxzPWVbZS5sZW5ndGgtMV0saT10aGlzLmdldE5vZGUobikscj10aGlzLmdldE5vZGUocyksbz1uZXcgdXIoaSxyLGVbMV0sITApLGw9bmV3IHVyKHIsaSxlW2UubGVuZ3RoLTJdLCExKSxhPW5ldyBncih0KTthLnNldERpcmVjdGVkRWRnZXMobyxsKSx0aGlzLmFkZChhKX1kZWxldGVDdXRFZGdlcygpe3RoaXMuY29tcHV0ZU5leHRDV0VkZ2VzKCksTHIuZmluZExhYmVsZWRFZGdlUmluZ3ModGhpcy5fZGlyRWRnZXMpO2NvbnN0IHQ9bmV3IHg7Zm9yKGxldCBlPXRoaXMuX2RpckVkZ2VzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO2lmKG4uaXNNYXJrZWQoKSljb250aW51ZTtjb25zdCBzPW4uZ2V0U3ltKCk7aWYobi5nZXRMYWJlbCgpPT09cy5nZXRMYWJlbCgpKXtuLnNldE1hcmtlZCghMCkscy5zZXRNYXJrZWQoITApO2NvbnN0IGU9bi5nZXRFZGdlKCk7dC5hZGQoZS5nZXRMaW5lKCkpfX1yZXR1cm4gdH1nZXRFZGdlUmluZ3MoKXt0aGlzLmNvbXB1dGVOZXh0Q1dFZGdlcygpLExyLmxhYmVsKHRoaXMuX2RpckVkZ2VzLC0xKTtjb25zdCB0PUxyLmZpbmRMYWJlbGVkRWRnZVJpbmdzKHRoaXMuX2RpckVkZ2VzKTt0aGlzLmNvbnZlcnRNYXhpbWFsVG9NaW5pbWFsRWRnZVJpbmdzKHQpO2NvbnN0IGU9bmV3IHg7Zm9yKGxldCB0PXRoaXMuX2RpckVkZ2VzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBuPXQubmV4dCgpO2lmKG4uaXNNYXJrZWQoKSljb250aW51ZTtpZihuLmlzSW5SaW5nKCkpY29udGludWU7Y29uc3Qgcz10aGlzLmZpbmRFZGdlUmluZyhuKTtlLmFkZChzKX1yZXR1cm4gZX1nZXROb2RlKHQpe2xldCBlPXRoaXMuZmluZE5vZGUodCk7cmV0dXJuIG51bGw9PT1lJiYoZT1uZXcgRmkodCksdGhpcy5hZGQoZSkpLGV9Y29udmVydE1heGltYWxUb01pbmltYWxFZGdlUmluZ3ModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCksbj10LmdldExhYmVsKCkscz1Mci5maW5kSW50ZXJzZWN0aW9uTm9kZXModCxuKTtpZihudWxsIT09cylmb3IobGV0IHQ9cy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTtMci5jb21wdXRlTmV4dENDV0VkZ2VzKGUsbil9fX1kZWxldGVEYW5nbGVzKCl7Y29uc3QgdD10aGlzLmZpbmROb2Rlc09mRGVncmVlKDEpLGU9bmV3IEosbj1uZXcgb247Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspbi5wdXNoKGUubmV4dCgpKTtmb3IoOyFuLmlzRW1wdHkoKTspe2NvbnN0IHQ9bi5wb3AoKTtMci5kZWxldGVBbGxFZGdlcyh0KTtmb3IobGV0IHM9dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7dC5zZXRNYXJrZWQoITApO2NvbnN0IGk9dC5nZXRTeW0oKTtudWxsIT09aSYmaS5zZXRNYXJrZWQoITApO2NvbnN0IHI9dC5nZXRFZGdlKCk7ZS5hZGQoci5nZXRMaW5lKCkpO2NvbnN0IG89dC5nZXRUb05vZGUoKTsxPT09THIuZ2V0RGVncmVlTm9uRGVsZXRlZChvKSYmbi5wdXNoKG8pfX1yZXR1cm4gZX1nZXRDbGFzcygpe3JldHVybiBMcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19THIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fZmFjdG9yeT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2ZhY3Rvcnk9dH07Y2xhc3MgVHJ7Y29uc3RydWN0b3IoKXtUci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBmaW5kT3V0ZXJTaGVsbHModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCksbj10LmdldE91dGVySG9sZSgpO251bGw9PT1ufHxuLmlzUHJvY2Vzc2VkKCl8fCh0LnNldEluY2x1ZGVkKCEwKSxuLnNldFByb2Nlc3NlZCghMCkpfX1zdGF0aWMgZXh0cmFjdFBvbHlnb25zKHQsZSl7Y29uc3Qgbj1uZXcgeDtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTsoZXx8dC5pc0luY2x1ZGVkKCkpJiZuLmFkZCh0LmdldFBvbHlnb24oKSl9cmV0dXJuIG59c3RhdGljIGFzc2lnbkhvbGVzVG9TaGVsbHModCxlKXtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtUci5hc3NpZ25Ib2xlVG9TaGVsbCh0LGUpfX1zdGF0aWMgYXNzaWduSG9sZVRvU2hlbGwodCxlKXtjb25zdCBuPVNyLmZpbmRFZGdlUmluZ0NvbnRhaW5pbmcodCxlKTtudWxsIT09biYmbi5hZGRIb2xlKHQpfXN0YXRpYyBmaW5kRGlzam9pbnRTaGVsbHModCl7VHIuZmluZE91dGVyU2hlbGxzKHQpO2xldCBlPW51bGw7ZG97ZT0hMTtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTt0LmlzSW5jbHVkZWRTZXQoKXx8KHQudXBkYXRlSW5jbHVkZWQoKSx0LmlzSW5jbHVkZWRTZXQoKXx8KGU9ITApKX19d2hpbGUoZSl9Z2V0R2VvbWV0cnkoKXtyZXR1cm4gbnVsbD09PXRoaXMuX2dlb21GYWN0b3J5JiYodGhpcy5fZ2VvbUZhY3Rvcnk9bmV3IEh0KSx0aGlzLnBvbHlnb25pemUoKSx0aGlzLl9leHRyYWN0T25seVBvbHlnb25hbD90aGlzLl9nZW9tRmFjdG9yeS5idWlsZEdlb21ldHJ5KHRoaXMuX3BvbHlMaXN0KTp0aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oSHQudG9HZW9tZXRyeUFycmF5KHRoaXMuX3BvbHlMaXN0KSl9Z2V0SW52YWxpZFJpbmdMaW5lcygpe3JldHVybiB0aGlzLnBvbHlnb25pemUoKSx0aGlzLl9pbnZhbGlkUmluZ0xpbmVzfWZpbmRWYWxpZFJpbmdzKHQsZSxuKXtmb3IobGV0IHM9dC5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7Y29uc3QgdD1zLm5leHQoKTt0LmlzVmFsaWQoKT9lLmFkZCh0KTpuLmFkZCh0LmdldExpbmVTdHJpbmcoKSl9fXBvbHlnb25pemUoKXtpZihudWxsIT09dGhpcy5fcG9seUxpc3QpcmV0dXJuIG51bGw7aWYodGhpcy5fcG9seUxpc3Q9bmV3IHgsbnVsbD09PXRoaXMuX2dyYXBoKXJldHVybiBudWxsO3RoaXMuX2RhbmdsZXM9dGhpcy5fZ3JhcGguZGVsZXRlRGFuZ2xlcygpLHRoaXMuX2N1dEVkZ2VzPXRoaXMuX2dyYXBoLmRlbGV0ZUN1dEVkZ2VzKCk7Y29uc3QgdD10aGlzLl9ncmFwaC5nZXRFZGdlUmluZ3MoKTtsZXQgZT1uZXcgeDt0aGlzLl9pbnZhbGlkUmluZ0xpbmVzPW5ldyB4LHRoaXMuX2lzQ2hlY2tpbmdSaW5nc1ZhbGlkP3RoaXMuZmluZFZhbGlkUmluZ3ModCxlLHRoaXMuX2ludmFsaWRSaW5nTGluZXMpOmU9dCx0aGlzLmZpbmRTaGVsbHNBbmRIb2xlcyhlKSxUci5hc3NpZ25Ib2xlc1RvU2hlbGxzKHRoaXMuX2hvbGVMaXN0LHRoaXMuX3NoZWxsTGlzdCksRWUuc29ydCh0aGlzLl9zaGVsbExpc3QsbmV3IFNyLkVudmVsb3BlQ29tcGFyYXRvcik7bGV0IG49ITA7dGhpcy5fZXh0cmFjdE9ubHlQb2x5Z29uYWwmJihUci5maW5kRGlzam9pbnRTaGVsbHModGhpcy5fc2hlbGxMaXN0KSxuPSExKSx0aGlzLl9wb2x5TGlzdD1Uci5leHRyYWN0UG9seWdvbnModGhpcy5fc2hlbGxMaXN0LG4pfWdldERhbmdsZXMoKXtyZXR1cm4gdGhpcy5wb2x5Z29uaXplKCksdGhpcy5fZGFuZ2xlc31nZXRDdXRFZGdlcygpe3JldHVybiB0aGlzLnBvbHlnb25pemUoKSx0aGlzLl9jdXRFZGdlc31nZXRQb2x5Z29ucygpe3JldHVybiB0aGlzLnBvbHlnb25pemUoKSx0aGlzLl9wb2x5TGlzdH1hZGQoKXtpZihfKGFyZ3VtZW50c1swXSxmKSl7Zm9yKGxldCB0PWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLmFkZChlKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFR0KXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nZW9tRmFjdG9yeT10LmdldEZhY3RvcnkoKSxudWxsPT09dGhpcy5fZ3JhcGgmJih0aGlzLl9ncmFwaD1uZXcgTHIodGhpcy5fZ2VvbUZhY3RvcnkpKSx0aGlzLl9ncmFwaC5hZGRFZGdlKHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXthcmd1bWVudHNbMF0uYXBwbHkodGhpcy5fbGluZVN0cmluZ0FkZGVyKX19c2V0Q2hlY2tSaW5nc1ZhbGlkKHQpe3RoaXMuX2lzQ2hlY2tpbmdSaW5nc1ZhbGlkPXR9ZmluZFNoZWxsc0FuZEhvbGVzKHQpe3RoaXMuX2hvbGVMaXN0PW5ldyB4LHRoaXMuX3NoZWxsTGlzdD1uZXcgeDtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0LmNvbXB1dGVIb2xlKCksdC5pc0hvbGUoKT90aGlzLl9ob2xlTGlzdC5hZGQodCk6dGhpcy5fc2hlbGxMaXN0LmFkZCh0KX19Z2V0Q2xhc3MoKXtyZXR1cm4gVHJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIFJye2NvbnN0cnVjdG9yKCl7UnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maWx0ZXIodCl7dCBpbnN0YW5jZW9mIFR0JiZ0aGlzLnAuYWRkKHQpfWdldENsYXNzKCl7cmV0dXJuIFJyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltHXX19UnIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5wPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5wPXR9LFRyLkxpbmVTdHJpbmdBZGRlcj1ScixUci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9saW5lU3RyaW5nQWRkZXI9bmV3IFJyKHRoaXMpLHRoaXMuX2dyYXBoPW51bGwsdGhpcy5fZGFuZ2xlcz1uZXcgeCx0aGlzLl9jdXRFZGdlcz1uZXcgeCx0aGlzLl9pbnZhbGlkUmluZ0xpbmVzPW5ldyB4LHRoaXMuX2hvbGVMaXN0PW51bGwsdGhpcy5fc2hlbGxMaXN0PW51bGwsdGhpcy5fcG9seUxpc3Q9bnVsbCx0aGlzLl9pc0NoZWNraW5nUmluZ3NWYWxpZD0hMCx0aGlzLl9leHRyYWN0T25seVBvbHlnb25hbD1udWxsLHRoaXMuX2dlb21GYWN0b3J5PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpVHIuY29uc3RydWN0b3JfLmNhbGwodGhpcywhMSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZXh0cmFjdE9ubHlQb2x5Z29uYWw9dH19O3ZhciBQcj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxQb2x5Z29uaXplcjpUcn0pO2NsYXNzIHZye2NvbnN0cnVjdG9yKCl7dnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1pbnNlcnRFZGdlRW5kcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0aGlzLl9ub2Rlcy5hZGQodCl9fWNvbXB1dGVQcm9wZXJJbnRlcnNlY3Rpb25JTSh0LGUpe2NvbnN0IG49dGhpcy5fYXJnWzBdLmdldEdlb21ldHJ5KCkuZ2V0RGltZW5zaW9uKCkscz10aGlzLl9hcmdbMV0uZ2V0R2VvbWV0cnkoKS5nZXREaW1lbnNpb24oKSxpPXQuaGFzUHJvcGVySW50ZXJzZWN0aW9uKCkscj10Lmhhc1Byb3BlckludGVyaW9ySW50ZXJzZWN0aW9uKCk7Mj09PW4mJjI9PT1zP2kmJmUuc2V0QXRMZWFzdChcIjIxMjEwMTIxMlwiKToyPT09biYmMT09PXM/KGkmJmUuc2V0QXRMZWFzdChcIkZGRjBGRkZGMlwiKSxyJiZlLnNldEF0TGVhc3QoXCIxRkZGRkYxRkZcIikpOjE9PT1uJiYyPT09cz8oaSYmZS5zZXRBdExlYXN0KFwiRjBGRkZGRkYyXCIpLHImJmUuc2V0QXRMZWFzdChcIjFGMUZGRkZGRlwiKSk6MT09PW4mJjE9PT1zJiZyJiZlLnNldEF0TGVhc3QoXCIwRkZGRkZGRkZcIil9bGFiZWxJc29sYXRlZEVkZ2VzKHQsZSl7Zm9yKGxldCBuPXRoaXMuX2FyZ1t0XS5nZXRFZGdlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7dC5pc0lzb2xhdGVkKCkmJih0aGlzLmxhYmVsSXNvbGF0ZWRFZGdlKHQsZSx0aGlzLl9hcmdbZV0uZ2V0R2VvbWV0cnkoKSksdGhpcy5faXNvbGF0ZWRFZGdlcy5hZGQodCkpfX1sYWJlbElzb2xhdGVkRWRnZSh0LGUsbil7aWYobi5nZXREaW1lbnNpb24oKT4wKXtjb25zdCBzPXRoaXMuX3B0TG9jYXRvci5sb2NhdGUodC5nZXRDb29yZGluYXRlKCksbik7dC5nZXRMYWJlbCgpLnNldEFsbExvY2F0aW9ucyhlLHMpfWVsc2UgdC5nZXRMYWJlbCgpLnNldEFsbExvY2F0aW9ucyhlLG5lLkVYVEVSSU9SKX1jb21wdXRlSU0oKXtjb25zdCB0PW5ldyBzZTtpZih0LnNldChuZS5FWFRFUklPUixuZS5FWFRFUklPUiwyKSwhdGhpcy5fYXJnWzBdLmdldEdlb21ldHJ5KCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHModGhpcy5fYXJnWzFdLmdldEdlb21ldHJ5KCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSlyZXR1cm4gdGhpcy5jb21wdXRlRGlzam9pbnRJTSh0KSx0O3RoaXMuX2FyZ1swXS5jb21wdXRlU2VsZk5vZGVzKHRoaXMuX2xpLCExKSx0aGlzLl9hcmdbMV0uY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLl9saSwhMSk7Y29uc3QgZT10aGlzLl9hcmdbMF0uY29tcHV0ZUVkZ2VJbnRlcnNlY3Rpb25zKHRoaXMuX2FyZ1sxXSx0aGlzLl9saSwhMSk7dGhpcy5jb21wdXRlSW50ZXJzZWN0aW9uTm9kZXMoMCksdGhpcy5jb21wdXRlSW50ZXJzZWN0aW9uTm9kZXMoMSksdGhpcy5jb3B5Tm9kZXNBbmRMYWJlbHMoMCksdGhpcy5jb3B5Tm9kZXNBbmRMYWJlbHMoMSksdGhpcy5sYWJlbElzb2xhdGVkTm9kZXMoKSx0aGlzLmNvbXB1dGVQcm9wZXJJbnRlcnNlY3Rpb25JTShlLHQpO2NvbnN0IG49bmV3IF9yLHM9bi5jb21wdXRlRWRnZUVuZHModGhpcy5fYXJnWzBdLmdldEVkZ2VJdGVyYXRvcigpKTt0aGlzLmluc2VydEVkZ2VFbmRzKHMpO2NvbnN0IGk9bi5jb21wdXRlRWRnZUVuZHModGhpcy5fYXJnWzFdLmdldEVkZ2VJdGVyYXRvcigpKTtyZXR1cm4gdGhpcy5pbnNlcnRFZGdlRW5kcyhpKSx0aGlzLmxhYmVsTm9kZUVkZ2VzKCksdGhpcy5sYWJlbElzb2xhdGVkRWRnZXMoMCwxKSx0aGlzLmxhYmVsSXNvbGF0ZWRFZGdlcygxLDApLHRoaXMudXBkYXRlSU0odCksdH1sYWJlbE5vZGVFZGdlcygpe2ZvcihsZXQgdD10aGlzLl9ub2Rlcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dC5uZXh0KCkuZ2V0RWRnZXMoKS5jb21wdXRlTGFiZWxsaW5nKHRoaXMuX2FyZyl9fWNvcHlOb2Rlc0FuZExhYmVscyh0KXtmb3IobGV0IGU9dGhpcy5fYXJnW3RdLmdldE5vZGVJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKTt0aGlzLl9ub2Rlcy5hZGROb2RlKG4uZ2V0Q29vcmRpbmF0ZSgpKS5zZXRMYWJlbCh0LG4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KSl9fWxhYmVsSW50ZXJzZWN0aW9uTm9kZXModCl7Zm9yKGxldCBlPXRoaXMuX2FyZ1t0XS5nZXRFZGdlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCkscz1uLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCk7Zm9yKGxldCBlPW4uZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKSxpPXRoaXMuX25vZGVzLmZpbmQobi5jb29yZCk7aS5nZXRMYWJlbCgpLmlzTnVsbCh0KSYmKHM9PT1uZS5CT1VOREFSWT9pLnNldExhYmVsQm91bmRhcnkodCk6aS5zZXRMYWJlbCh0LG5lLklOVEVSSU9SKSl9fX1sYWJlbElzb2xhdGVkTm9kZSh0LGUpe2NvbnN0IG49dGhpcy5fcHRMb2NhdG9yLmxvY2F0ZSh0LmdldENvb3JkaW5hdGUoKSx0aGlzLl9hcmdbZV0uZ2V0R2VvbWV0cnkoKSk7dC5nZXRMYWJlbCgpLnNldEFsbExvY2F0aW9ucyhlLG4pfWNvbXB1dGVJbnRlcnNlY3Rpb25Ob2Rlcyh0KXtmb3IobGV0IGU9dGhpcy5fYXJnW3RdLmdldEVkZ2VJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3Qgbj1lLm5leHQoKSxzPW4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KTtmb3IobGV0IGU9bi5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpLGk9dGhpcy5fbm9kZXMuYWRkTm9kZShuLmNvb3JkKTtzPT09bmUuQk9VTkRBUlk/aS5zZXRMYWJlbEJvdW5kYXJ5KHQpOmkuZ2V0TGFiZWwoKS5pc051bGwodCkmJmkuc2V0TGFiZWwodCxuZS5JTlRFUklPUil9fX1sYWJlbElzb2xhdGVkTm9kZXMoKXtmb3IobGV0IHQ9dGhpcy5fbm9kZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe2NvbnN0IGU9dC5uZXh0KCksbj1lLmdldExhYmVsKCk7dS5pc1RydWUobi5nZXRHZW9tZXRyeUNvdW50KCk+MCxcIm5vZGUgd2l0aCBlbXB0eSBsYWJlbCBmb3VuZFwiKSxlLmlzSXNvbGF0ZWQoKSYmKG4uaXNOdWxsKDApP3RoaXMubGFiZWxJc29sYXRlZE5vZGUoZSwwKTp0aGlzLmxhYmVsSXNvbGF0ZWROb2RlKGUsMSkpfX11cGRhdGVJTSh0KXtmb3IobGV0IGU9dGhpcy5faXNvbGF0ZWRFZGdlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7ZS5uZXh0KCkudXBkYXRlSU0odCl9Zm9yKGxldCBlPXRoaXMuX25vZGVzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO24udXBkYXRlSU0odCksbi51cGRhdGVJTUZyb21FZGdlcyh0KX19Y29tcHV0ZURpc2pvaW50SU0odCl7Y29uc3QgZT10aGlzLl9hcmdbMF0uZ2V0R2VvbWV0cnkoKTtlLmlzRW1wdHkoKXx8KHQuc2V0KG5lLklOVEVSSU9SLG5lLkVYVEVSSU9SLGUuZ2V0RGltZW5zaW9uKCkpLHQuc2V0KG5lLkJPVU5EQVJZLG5lLkVYVEVSSU9SLGUuZ2V0Qm91bmRhcnlEaW1lbnNpb24oKSkpO2NvbnN0IG49dGhpcy5fYXJnWzFdLmdldEdlb21ldHJ5KCk7bi5pc0VtcHR5KCl8fCh0LnNldChuZS5FWFRFUklPUixuZS5JTlRFUklPUixuLmdldERpbWVuc2lvbigpKSx0LnNldChuZS5FWFRFUklPUixuZS5CT1VOREFSWSxuLmdldEJvdW5kYXJ5RGltZW5zaW9uKCkpKX1nZXRDbGFzcygpe3JldHVybiB2cn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19dnIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbGk9bmV3IHRlLHRoaXMuX3B0TG9jYXRvcj1uZXcgX24sdGhpcy5fYXJnPW51bGwsdGhpcy5fbm9kZXM9bmV3IFhuKG5ldyB5ciksdGhpcy5faW09bnVsbCx0aGlzLl9pc29sYXRlZEVkZ2VzPW5ldyB4LHRoaXMuX2ludmFsaWRQb2ludD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2FyZz10fTtjbGFzcyBPcntjb25zdHJ1Y3Rvcigpe09yLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvbnRhaW5zKHQsZSl7cmV0dXJuIG5ldyBPcih0KS5jb250YWlucyhlKX1pc0NvbnRhaW5lZEluQm91bmRhcnkodCl7aWYodCBpbnN0YW5jZW9mIGJ0KXJldHVybiExO2lmKHQgaW5zdGFuY2VvZiBQdClyZXR1cm4gdGhpcy5pc1BvaW50Q29udGFpbmVkSW5Cb3VuZGFyeSh0KTtpZih0IGluc3RhbmNlb2YgVHQpcmV0dXJuIHRoaXMuaXNMaW5lU3RyaW5nQ29udGFpbmVkSW5Cb3VuZGFyeSh0KTtmb3IobGV0IGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7Y29uc3Qgbj10LmdldEdlb21ldHJ5TihlKTtpZighdGhpcy5pc0NvbnRhaW5lZEluQm91bmRhcnkobikpcmV0dXJuITF9cmV0dXJuITB9aXNMaW5lU2VnbWVudENvbnRhaW5lZEluQm91bmRhcnkodCxlKXtpZih0LmVxdWFscyhlKSlyZXR1cm4gdGhpcy5pc1BvaW50Q29udGFpbmVkSW5Cb3VuZGFyeSh0KTtpZih0Lng9PT1lLngpe2lmKHQueD09PXRoaXMuX3JlY3RFbnYuZ2V0TWluWCgpfHx0Lng9PT10aGlzLl9yZWN0RW52LmdldE1heFgoKSlyZXR1cm4hMH1lbHNlIGlmKHQueT09PWUueSYmKHQueT09PXRoaXMuX3JlY3RFbnYuZ2V0TWluWSgpfHx0Lnk9PT10aGlzLl9yZWN0RW52LmdldE1heFkoKSkpcmV0dXJuITA7cmV0dXJuITF9aXNMaW5lU3RyaW5nQ29udGFpbmVkSW5Cb3VuZGFyeSh0KXtjb25zdCBlPXQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksbj1uZXcgZyxzPW5ldyBnO2ZvcihsZXQgdD0wO3Q8ZS5zaXplKCktMTt0KyspaWYoZS5nZXRDb29yZGluYXRlKHQsbiksZS5nZXRDb29yZGluYXRlKHQrMSxzKSwhdGhpcy5pc0xpbmVTZWdtZW50Q29udGFpbmVkSW5Cb3VuZGFyeShuLHMpKXJldHVybiExO3JldHVybiEwfWlzUG9pbnRDb250YWluZWRJbkJvdW5kYXJ5KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBQdCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaXNQb2ludENvbnRhaW5lZEluQm91bmRhcnkodC5nZXRDb29yZGluYXRlKCkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHQueD09PXRoaXMuX3JlY3RFbnYuZ2V0TWluWCgpfHx0Lng9PT10aGlzLl9yZWN0RW52LmdldE1heFgoKXx8dC55PT09dGhpcy5fcmVjdEVudi5nZXRNaW5ZKCl8fHQueT09PXRoaXMuX3JlY3RFbnYuZ2V0TWF4WSgpfX1jb250YWlucyh0KXtyZXR1cm4hIXRoaXMuX3JlY3RFbnYuY29udGFpbnModC5nZXRFbnZlbG9wZUludGVybmFsKCkpJiYhdGhpcy5pc0NvbnRhaW5lZEluQm91bmRhcnkodCl9Z2V0Q2xhc3MoKXtyZXR1cm4gT3J9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fU9yLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3JlY3RFbnY9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9yZWN0RW52PXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpfTtjbGFzcyBicntjb25zdHJ1Y3Rvcigpe2JyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aW50ZXJzZWN0cyh0LGUpe2NvbnN0IG49bmV3IE4odCxlKTtpZighdGhpcy5fcmVjdEVudi5pbnRlcnNlY3RzKG4pKXJldHVybiExO2lmKHRoaXMuX3JlY3RFbnYuaW50ZXJzZWN0cyh0KSlyZXR1cm4hMDtpZih0aGlzLl9yZWN0RW52LmludGVyc2VjdHMoZSkpcmV0dXJuITA7aWYodC5jb21wYXJlVG8oZSk+MCl7Y29uc3Qgbj10O3Q9ZSxlPW59bGV0IHM9ITE7cmV0dXJuIGUueT50LnkmJihzPSEwKSxzP3RoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2RpYWdEb3duMCx0aGlzLl9kaWFnRG93bjEpOnRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuX2RpYWdVcDAsdGhpcy5fZGlhZ1VwMSksISF0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKX1nZXRDbGFzcygpe3JldHVybiBicn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19YnIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbGk9bmV3IHRlLHRoaXMuX3JlY3RFbnY9bnVsbCx0aGlzLl9kaWFnVXAwPW51bGwsdGhpcy5fZGlhZ1VwMT1udWxsLHRoaXMuX2RpYWdEb3duMD1udWxsLHRoaXMuX2RpYWdEb3duMT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3JlY3RFbnY9dCx0aGlzLl9kaWFnVXAwPW5ldyBnKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKSx0aGlzLl9kaWFnVXAxPW5ldyBnKHQuZ2V0TWF4WCgpLHQuZ2V0TWF4WSgpKSx0aGlzLl9kaWFnRG93bjA9bmV3IGcodC5nZXRNaW5YKCksdC5nZXRNYXhZKCkpLHRoaXMuX2RpYWdEb3duMT1uZXcgZyh0LmdldE1heFgoKSx0LmdldE1pblkoKSl9O2NsYXNzIE1ye2NvbnN0cnVjdG9yKCl7TXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaW50ZXJzZWN0cyh0LGUpe3JldHVybiBuZXcgTXIodCkuaW50ZXJzZWN0cyhlKX1pbnRlcnNlY3RzKHQpe2lmKCF0aGlzLl9yZWN0RW52LmludGVyc2VjdHModC5nZXRFbnZlbG9wZUludGVybmFsKCkpKXJldHVybiExO2NvbnN0IGU9bmV3IERyKHRoaXMuX3JlY3RFbnYpO2lmKGUuYXBwbHlUbyh0KSxlLmludGVyc2VjdHMoKSlyZXR1cm4hMDtjb25zdCBuPW5ldyBBcih0aGlzLl9yZWN0YW5nbGUpO2lmKG4uYXBwbHlUbyh0KSxuLmNvbnRhaW5zUG9pbnQoKSlyZXR1cm4hMDtjb25zdCBzPW5ldyBGcih0aGlzLl9yZWN0YW5nbGUpO3JldHVybiBzLmFwcGx5VG8odCksISFzLmludGVyc2VjdHMoKX1nZXRDbGFzcygpe3JldHVybiBNcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19TXIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcmVjdGFuZ2xlPW51bGwsdGhpcy5fcmVjdEVudj1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3JlY3RhbmdsZT10LHRoaXMuX3JlY3RFbnY9dC5nZXRFbnZlbG9wZUludGVybmFsKCl9O2NsYXNzIERyIGV4dGVuZHMgQ2V7Y29uc3RydWN0b3IoKXtzdXBlcigpLERyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNEb25lKCl7cmV0dXJuITA9PT10aGlzLl9pbnRlcnNlY3RzfXZpc2l0KHQpe2NvbnN0IGU9dC5nZXRFbnZlbG9wZUludGVybmFsKCk7cmV0dXJuIHRoaXMuX3JlY3RFbnYuaW50ZXJzZWN0cyhlKT90aGlzLl9yZWN0RW52LmNvbnRhaW5zKGUpfHxlLmdldE1pblgoKT49dGhpcy5fcmVjdEVudi5nZXRNaW5YKCkmJmUuZ2V0TWF4WCgpPD10aGlzLl9yZWN0RW52LmdldE1heFgoKXx8ZS5nZXRNaW5ZKCk+PXRoaXMuX3JlY3RFbnYuZ2V0TWluWSgpJiZlLmdldE1heFkoKTw9dGhpcy5fcmVjdEVudi5nZXRNYXhZKCk/KHRoaXMuX2ludGVyc2VjdHM9ITAsbnVsbCk6dm9pZCAwOm51bGx9aW50ZXJzZWN0cygpe3JldHVybiB0aGlzLl9pbnRlcnNlY3RzfWdldENsYXNzKCl7cmV0dXJuIERyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Eci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9yZWN0RW52PW51bGwsdGhpcy5faW50ZXJzZWN0cz0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9yZWN0RW52PXR9O2NsYXNzIEFyIGV4dGVuZHMgQ2V7Y29uc3RydWN0b3IoKXtzdXBlcigpLEFyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9aXNEb25lKCl7cmV0dXJuITA9PT10aGlzLl9jb250YWluc1BvaW50fXZpc2l0KHQpe2lmKCEodCBpbnN0YW5jZW9mIGJ0KSlyZXR1cm4gbnVsbDtjb25zdCBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2lmKCF0aGlzLl9yZWN0RW52LmludGVyc2VjdHMoZSkpcmV0dXJuIG51bGw7Y29uc3Qgbj1uZXcgZztmb3IobGV0IHM9MDtzPDQ7cysrKWlmKHRoaXMuX3JlY3RTZXEuZ2V0Q29vcmRpbmF0ZShzLG4pLGUuY29udGFpbnMobikmJlplLmNvbnRhaW5zUG9pbnRJblBvbHlnb24obix0KSlyZXR1cm4gdGhpcy5fY29udGFpbnNQb2ludD0hMCxudWxsfWNvbnRhaW5zUG9pbnQoKXtyZXR1cm4gdGhpcy5fY29udGFpbnNQb2ludH1nZXRDbGFzcygpe3JldHVybiBBcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19QXIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcmVjdFNlcT1udWxsLHRoaXMuX3JlY3RFbnY9bnVsbCx0aGlzLl9jb250YWluc1BvaW50PSExO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3JlY3RTZXE9dC5nZXRFeHRlcmlvclJpbmcoKS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0aGlzLl9yZWN0RW52PXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpfTtjbGFzcyBGciBleHRlbmRzIENle2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxGci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWludGVyc2VjdHMoKXtyZXR1cm4gdGhpcy5faGFzSW50ZXJzZWN0aW9ufWlzRG9uZSgpe3JldHVybiEwPT09dGhpcy5faGFzSW50ZXJzZWN0aW9ufXZpc2l0KHQpe2NvbnN0IGU9dC5nZXRFbnZlbG9wZUludGVybmFsKCk7aWYoIXRoaXMuX3JlY3RFbnYuaW50ZXJzZWN0cyhlKSlyZXR1cm4gbnVsbDtjb25zdCBuPXhlLmdldExpbmVzKHQpO3RoaXMuY2hlY2tJbnRlcnNlY3Rpb25XaXRoTGluZVN0cmluZ3Mobil9Y2hlY2tJbnRlcnNlY3Rpb25XaXRoTGluZVN0cmluZ3ModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7aWYodGhpcy5jaGVja0ludGVyc2VjdGlvbldpdGhTZWdtZW50cyh0KSx0aGlzLl9oYXNJbnRlcnNlY3Rpb24pcmV0dXJuIG51bGx9fWNoZWNrSW50ZXJzZWN0aW9uV2l0aFNlZ21lbnRzKHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKTtmb3IobGV0IHQ9MTt0PGUuc2l6ZSgpO3QrKylpZihlLmdldENvb3JkaW5hdGUodC0xLHRoaXMuX3AwKSxlLmdldENvb3JkaW5hdGUodCx0aGlzLl9wMSksdGhpcy5fcmVjdEludGVyc2VjdG9yLmludGVyc2VjdHModGhpcy5fcDAsdGhpcy5fcDEpKXJldHVybiB0aGlzLl9oYXNJbnRlcnNlY3Rpb249ITAsbnVsbH1nZXRDbGFzcygpe3JldHVybiBGcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19RnIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcmVjdEVudj1udWxsLHRoaXMuX3JlY3RJbnRlcnNlY3Rvcj1udWxsLHRoaXMuX2hhc0ludGVyc2VjdGlvbj0hMSx0aGlzLl9wMD1uZXcgZyx0aGlzLl9wMT1uZXcgZztjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9yZWN0RW52PXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLHRoaXMuX3JlY3RJbnRlcnNlY3Rvcj1uZXcgYnIodGhpcy5fcmVjdEVudil9O2NsYXNzIEdyIGV4dGVuZHMgYXJ7Y29uc3RydWN0b3IoKXtzdXBlcigpLEdyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNvdmVycyh0LGUpe3JldHVybiEoMj09PWUuZ2V0RGltZW5zaW9uKCkmJnQuZ2V0RGltZW5zaW9uKCk8MikmJighKDE9PT1lLmdldERpbWVuc2lvbigpJiZ0LmdldERpbWVuc2lvbigpPDEmJmUuZ2V0TGVuZ3RoKCk+MCkmJighIXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmNvdmVycyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJighIXQuaXNSZWN0YW5nbGUoKXx8bmV3IEdyKHQsZSkuZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCkuaXNDb3ZlcnMoKSkpKX1zdGF0aWMgaW50ZXJzZWN0cyh0LGUpe2lmKCF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSlyZXR1cm4hMTtpZih0LmlzUmVjdGFuZ2xlKCkpcmV0dXJuIE1yLmludGVyc2VjdHModCxlKTtpZihlLmlzUmVjdGFuZ2xlKCkpcmV0dXJuIE1yLmludGVyc2VjdHMoZSx0KTtpZih0LmlzR2VvbWV0cnlDb2xsZWN0aW9uKCl8fGUuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKSl7Zm9yKGxldCBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspZm9yKGxldCBzPTA7czxlLmdldE51bUdlb21ldHJpZXMoKTtzKyspaWYodC5nZXRHZW9tZXRyeU4obikuaW50ZXJzZWN0cyhlLmdldEdlb21ldHJ5TihzKSkpcmV0dXJuITA7cmV0dXJuITF9cmV0dXJuIG5ldyBHcih0LGUpLmdldEludGVyc2VjdGlvbk1hdHJpeCgpLmlzSW50ZXJzZWN0cygpfXN0YXRpYyB0b3VjaGVzKHQsZSl7cmV0dXJuISF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmbmV3IEdyKHQsZSkuZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCkuaXNUb3VjaGVzKHQuZ2V0RGltZW5zaW9uKCksZS5nZXREaW1lbnNpb24oKSl9c3RhdGljIGVxdWFsc1RvcG8odCxlKXtyZXR1cm4hIXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmVxdWFscyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJkdyLnJlbGF0ZSh0LGUpLmlzRXF1YWxzKHQuZ2V0RGltZW5zaW9uKCksZS5nZXREaW1lbnNpb24oKSl9c3RhdGljIHJlbGF0ZSgpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IEdyKHQsZSkuZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiBuZXcgR3IodCxlLG4pLmdldEludGVyc2VjdGlvbk1hdHJpeCgpfX1zdGF0aWMgb3ZlcmxhcHModCxlKXtyZXR1cm4hIXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpJiZuZXcgR3IodCxlKS5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKS5pc092ZXJsYXBzKHQuZ2V0RGltZW5zaW9uKCksZS5nZXREaW1lbnNpb24oKSl9c3RhdGljIGNyb3NzZXModCxlKXtyZXR1cm4hIXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpJiZuZXcgR3IodCxlKS5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKS5pc0Nyb3NzZXModC5nZXREaW1lbnNpb24oKSxlLmdldERpbWVuc2lvbigpKX1zdGF0aWMgY29udGFpbnModCxlKXtyZXR1cm4hKDI9PT1lLmdldERpbWVuc2lvbigpJiZ0LmdldERpbWVuc2lvbigpPDIpJiYoISgxPT09ZS5nZXREaW1lbnNpb24oKSYmdC5nZXREaW1lbnNpb24oKTwxJiZlLmdldExlbmd0aCgpPjApJiYoISF0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5jb250YWlucyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJih0LmlzUmVjdGFuZ2xlKCk/T3IuY29udGFpbnModCxlKTpuZXcgR3IodCxlKS5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKS5pc0NvbnRhaW5zKCkpKSl9Z2V0SW50ZXJzZWN0aW9uTWF0cml4KCl7cmV0dXJuIHRoaXMuX3JlbGF0ZS5jb21wdXRlSU0oKX1nZXRDbGFzcygpe3JldHVybiBHcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19R3IuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fcmVsYXRlPW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2FyLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCxlKSx0aGlzLl9yZWxhdGU9bmV3IHZyKHRoaXMuX2FyZyl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07YXIuY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUsbiksdGhpcy5fcmVsYXRlPW5ldyB2cih0aGlzLl9hcmcpfX07dmFyIHFyPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLFJlbGF0ZU9wOkdyfSk7Y2xhc3MgQnJ7Y29uc3RydWN0b3IoKXtCci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyB1bmlvbih0LGUpe3JldHVybiBuZXcgQnIodCxlKS51bmlvbigpfXVuaW9uKCl7Y29uc3QgdD1uZXcgX24sZT1uZXcgYXQ7Zm9yKGxldCBuPTA7bjx0aGlzLl9wb2ludEdlb20uZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7Y29uc3Qgcz10aGlzLl9wb2ludEdlb20uZ2V0R2VvbWV0cnlOKG4pLmdldENvb3JkaW5hdGUoKTt0LmxvY2F0ZShzLHRoaXMuX290aGVyR2VvbSk9PT1uZS5FWFRFUklPUiYmZS5hZGQocyl9aWYoMD09PWUuc2l6ZSgpKXJldHVybiB0aGlzLl9vdGhlckdlb207bGV0IG49bnVsbDtjb25zdCBzPVgudG9Db29yZGluYXRlQXJyYXkoZSk7cmV0dXJuIG49MT09PXMubGVuZ3RoP3RoaXMuX2dlb21GYWN0LmNyZWF0ZVBvaW50KHNbMF0pOnRoaXMuX2dlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnRGcm9tQ29vcmRzKHMpLGRlLmNvbWJpbmUobix0aGlzLl9vdGhlckdlb20pfWdldENsYXNzKCl7cmV0dXJuIEJyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Cci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9wb2ludEdlb209bnVsbCx0aGlzLl9vdGhlckdlb209bnVsbCx0aGlzLl9nZW9tRmFjdD1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3BvaW50R2VvbT10LHRoaXMuX290aGVyR2VvbT1lLHRoaXMuX2dlb21GYWN0PWUuZ2V0RmFjdG9yeSgpfTtjbGFzcyBWcntjb25zdHJ1Y3Rvcigpe1ZyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHJlc3RyaWN0VG9Qb2x5Z29ucyh0KXtpZihfKHQsT3QpKXJldHVybiB0O2NvbnN0IGU9TmUuZ2V0UG9seWdvbnModCk7cmV0dXJuIDE9PT1lLnNpemUoKT9lLmdldCgwKTp0LmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aVBvbHlnb24oSHQudG9Qb2x5Z29uQXJyYXkoZSkpfXN0YXRpYyBnZXRHZW9tZXRyeSh0LGUpe3JldHVybiBlPj10LnNpemUoKT9udWxsOnQuZ2V0KGUpfXN0YXRpYyB1bmlvbih0KXtyZXR1cm4gbmV3IFZyKHQpLnVuaW9uKCl9cmVkdWNlVG9HZW9tZXRyaWVzKHQpe2NvbnN0IGU9bmV3IHg7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7bGV0IHM9bnVsbDtfKHQsbSk/cz10aGlzLnVuaW9uVHJlZSh0KTp0IGluc3RhbmNlb2YgcSYmKHM9dCksZS5hZGQocyl9cmV0dXJuIGV9ZXh0cmFjdEJ5RW52ZWxvcGUodCxlLG4pe2NvbnN0IHM9bmV3IHg7Zm9yKGxldCBpPTA7aTxlLmdldE51bUdlb21ldHJpZXMoKTtpKyspe2NvbnN0IHI9ZS5nZXRHZW9tZXRyeU4oaSk7ci5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyh0KT9zLmFkZChyKTpuLmFkZChyKX1yZXR1cm4gdGhpcy5fZ2VvbUZhY3RvcnkuYnVpbGRHZW9tZXRyeShzKX11bmlvbk9wdGltaXplZCh0LGUpe2NvbnN0IG49dC5nZXRFbnZlbG9wZUludGVybmFsKCkscz1lLmdldEVudmVsb3BlSW50ZXJuYWwoKTtpZighbi5pbnRlcnNlY3RzKHMpKXtyZXR1cm4gZGUuY29tYmluZSh0LGUpfWlmKHQuZ2V0TnVtR2VvbWV0cmllcygpPD0xJiZlLmdldE51bUdlb21ldHJpZXMoKTw9MSlyZXR1cm4gdGhpcy51bmlvbkFjdHVhbCh0LGUpO2NvbnN0IGk9bi5pbnRlcnNlY3Rpb24ocyk7cmV0dXJuIHRoaXMudW5pb25Vc2luZ0VudmVsb3BlSW50ZXJzZWN0aW9uKHQsZSxpKX11bmlvbigpe2lmKG51bGw9PT10aGlzLl9pbnB1dFBvbHlzKXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJ1bmlvbigpIG1ldGhvZCBjYW5ub3QgYmUgY2FsbGVkIHR3aWNlXCIpO2lmKHRoaXMuX2lucHV0UG9seXMuaXNFbXB0eSgpKXJldHVybiBudWxsO3RoaXMuX2dlb21GYWN0b3J5PXRoaXMuX2lucHV0UG9seXMuaXRlcmF0b3IoKS5uZXh0KCkuZ2V0RmFjdG9yeSgpO2NvbnN0IHQ9bmV3IEVzKFZyLlNUUlRSRUVfTk9ERV9DQVBBQ0lUWSk7Zm9yKGxldCBlPXRoaXMuX2lucHV0UG9seXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IG49ZS5uZXh0KCk7dC5pbnNlcnQobi5nZXRFbnZlbG9wZUludGVybmFsKCksbil9dGhpcy5faW5wdXRQb2x5cz1udWxsO2NvbnN0IGU9dC5pdGVtc1RyZWUoKTtyZXR1cm4gdGhpcy51bmlvblRyZWUoZSl9YmluYXJ5VW5pb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuYmluYXJ5VW5pb24odCwwLHQuc2l6ZSgpKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYobi1lPD0xKXtjb25zdCBuPVZyLmdldEdlb21ldHJ5KHQsZSk7cmV0dXJuIHRoaXMudW5pb25TYWZlKG4sbnVsbCl9aWYobi1lPT0yKXJldHVybiB0aGlzLnVuaW9uU2FmZShWci5nZXRHZW9tZXRyeSh0LGUpLFZyLmdldEdlb21ldHJ5KHQsZSsxKSk7e2NvbnN0IHM9TWF0aC50cnVuYygobitlKS8yKSxpPXRoaXMuYmluYXJ5VW5pb24odCxlLHMpLHI9dGhpcy5iaW5hcnlVbmlvbih0LHMsbik7cmV0dXJuIHRoaXMudW5pb25TYWZlKGkscil9fX1yZXBlYXRlZFVuaW9uKHQpe2xldCBlPW51bGw7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7ZT1udWxsPT09ZT90LmNvcHkoKTplLnVuaW9uKHQpfXJldHVybiBlfXVuaW9uU2FmZSh0LGUpe3JldHVybiBudWxsPT09dCYmbnVsbD09PWU/bnVsbDpudWxsPT09dD9lLmNvcHkoKTpudWxsPT09ZT90LmNvcHkoKTp0aGlzLnVuaW9uT3B0aW1pemVkKHQsZSl9dW5pb25BY3R1YWwodCxlKXtyZXR1cm4gVnIucmVzdHJpY3RUb1BvbHlnb25zKHQudW5pb24oZSkpfXVuaW9uVHJlZSh0KXtjb25zdCBlPXRoaXMucmVkdWNlVG9HZW9tZXRyaWVzKHQpO3JldHVybiB0aGlzLmJpbmFyeVVuaW9uKGUpfXVuaW9uVXNpbmdFbnZlbG9wZUludGVyc2VjdGlvbih0LGUsbil7Y29uc3Qgcz1uZXcgeCxpPXRoaXMuZXh0cmFjdEJ5RW52ZWxvcGUobix0LHMpLHI9dGhpcy5leHRyYWN0QnlFbnZlbG9wZShuLGUscyksbz10aGlzLnVuaW9uQWN0dWFsKGkscik7cmV0dXJuIHMuYWRkKG8pLGRlLmNvbWJpbmUocyl9YnVmZmVyVW5pb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHQuZ2V0KDApLmdldEZhY3RvcnkoKS5idWlsZEdlb21ldHJ5KHQpLmJ1ZmZlcigwKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihbdCxlXSkuYnVmZmVyKDApfX1nZXRDbGFzcygpe3JldHVybiBWcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19VnIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRQb2x5cz1udWxsLHRoaXMuX2dlb21GYWN0b3J5PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXRQb2x5cz10LG51bGw9PT10aGlzLl9pbnB1dFBvbHlzJiYodGhpcy5faW5wdXRQb2x5cz1uZXcgeCl9LFZyLlNUUlRSRUVfTk9ERV9DQVBBQ0lUWT00O2NsYXNzIHpye2NvbnN0cnVjdG9yKCl7enIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgdW5pb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXyhhcmd1bWVudHNbMF0sZikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgenIodCkudW5pb24oKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgenIodCkudW5pb24oKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIG5ldyB6cih0LGUpLnVuaW9uKCl9fXVuaW9uTm9PcHQodCl7Y29uc3QgZT10aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2ludCgpO3JldHVybiBsci5vdmVybGF5T3AodCxlLGNyLlVOSU9OKX11bmlvbldpdGhOdWxsKHQsZSl7cmV0dXJuIG51bGw9PT10JiZudWxsPT09ZT9udWxsOm51bGw9PT1lP3Q6bnVsbD09PXQ/ZTp0LnVuaW9uKGUpfWV4dHJhY3QoKXtpZihfKGFyZ3VtZW50c1swXSxmKSl7Zm9yKGxldCB0PWFyZ3VtZW50c1swXS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7Y29uc3QgZT10Lm5leHQoKTt0aGlzLmV4dHJhY3QoZSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxKXtjb25zdCB0PWFyZ3VtZW50c1swXTtudWxsPT09dGhpcy5fZ2VvbUZhY3QmJih0aGlzLl9nZW9tRmFjdD10LmdldEZhY3RvcnkoKSksX2UuZXh0cmFjdCh0LHEuVFlQRU5BTUVfUE9MWUdPTix0aGlzLl9wb2x5Z29ucyksX2UuZXh0cmFjdCh0LHEuVFlQRU5BTUVfTElORVNUUklORyx0aGlzLl9saW5lcyksX2UuZXh0cmFjdCh0LHEuVFlQRU5BTUVfUE9JTlQsdGhpcy5fcG9pbnRzKX19dW5pb24oKXtpZihudWxsPT09dGhpcy5fZ2VvbUZhY3QpcmV0dXJuIG51bGw7bGV0IHQ9bnVsbDtpZih0aGlzLl9wb2ludHMuc2l6ZSgpPjApe2NvbnN0IGU9dGhpcy5fZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeSh0aGlzLl9wb2ludHMpO3Q9dGhpcy51bmlvbk5vT3B0KGUpfWxldCBlPW51bGw7aWYodGhpcy5fbGluZXMuc2l6ZSgpPjApe2NvbnN0IHQ9dGhpcy5fZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeSh0aGlzLl9saW5lcyk7ZT10aGlzLnVuaW9uTm9PcHQodCl9bGV0IG49bnVsbDt0aGlzLl9wb2x5Z29ucy5zaXplKCk+MCYmKG49VnIudW5pb24odGhpcy5fcG9seWdvbnMpKTtjb25zdCBzPXRoaXMudW5pb25XaXRoTnVsbChlLG4pO2xldCBpPW51bGw7cmV0dXJuIGk9bnVsbD09PXQ/czpudWxsPT09cz90OkJyLnVuaW9uKHQscyksbnVsbD09PWk/dGhpcy5fZ2VvbUZhY3QuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk6aX1nZXRDbGFzcygpe3JldHVybiB6cn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19enIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7aWYodGhpcy5fcG9seWdvbnM9bmV3IHgsdGhpcy5fbGluZXM9bmV3IHgsdGhpcy5fcG9pbnRzPW5ldyB4LHRoaXMuX2dlb21GYWN0PW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKF8oYXJndW1lbnRzWzBdLGYpKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLmV4dHJhY3QodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuZXh0cmFjdCh0KX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fZ2VvbUZhY3Q9ZSx0aGlzLmV4dHJhY3QodCl9fTt2YXIgWXI9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsVW5hcnlVbmlvbk9wOnpyfSksVXI9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsSXNWYWxpZE9wOkNyLENvbnNpc3RlbnRBcmVhVGVzdGVyOkVyfSksa3I9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQm91bmRhcnlPcDpwdCxJc1NpbXBsZU9wOkhzLGJ1ZmZlcjp3aSxkaXN0YW5jZTpQaSxsaW5lbWVyZ2U6WGksb3ZlcmxheTpocixwb2x5Z29uaXplOlByLHJlbGF0ZTpxcix1bmlvbjpZcix2YWxpZDpVcn0pO2NsYXNzIFhyIGV4dGVuZHMgRnQuQ29vcmRpbmF0ZU9wZXJhdGlvbntjb25zdHJ1Y3Rvcigpe3N1cGVyKCksWHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1lZGl0KCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgcSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoMD09PXQubGVuZ3RoKXJldHVybiBudWxsO2NvbnN0IG49bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXtjb25zdCBzPW5ldyBnKHRbZV0pO3RoaXMuX3RhcmdldFBNLm1ha2VQcmVjaXNlKHMpLG5bZV09c31jb25zdCBzPW5ldyBJKG4sITEpLnRvQ29vcmRpbmF0ZUFycmF5KCk7bGV0IGk9MDtlIGluc3RhbmNlb2YgVHQmJihpPTIpLGUgaW5zdGFuY2VvZiBEdCYmKGk9NCk7bGV0IHI9bjtyZXR1cm4gdGhpcy5fcmVtb3ZlQ29sbGFwc2VkJiYocj1udWxsKSxzLmxlbmd0aDxpP3I6c31yZXR1cm4gc3VwZXIuZWRpdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0Q2xhc3MoKXtyZXR1cm4gWHJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVhyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3RhcmdldFBNPW51bGwsdGhpcy5fcmVtb3ZlQ29sbGFwc2VkPSEwO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3RhcmdldFBNPXQsdGhpcy5fcmVtb3ZlQ29sbGFwc2VkPWV9O2NsYXNzIEhye2NvbnN0cnVjdG9yKCl7SHIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgcmVkdWNlKHQsZSl7cmV0dXJuIG5ldyBIcihlKS5yZWR1Y2UodCl9c3RhdGljIHJlZHVjZVBvaW50d2lzZSh0LGUpe2NvbnN0IG49bmV3IEhyKGUpO3JldHVybiBuLnNldFBvaW50d2lzZSghMCksbi5yZWR1Y2UodCl9Zml4UG9seWdvbmFsVG9wb2xvZ3kodCl7bGV0IGU9dDt0aGlzLl9jaGFuZ2VQcmVjaXNpb25Nb2RlbHx8KGU9dGhpcy5jaGFuZ2VQTSh0LHRoaXMuX3RhcmdldFBNKSk7Y29uc3Qgbj1TaS5idWZmZXJPcChlLDApO2xldCBzPW47cmV0dXJuIHRoaXMuX2NoYW5nZVByZWNpc2lvbk1vZGVsfHwocz10LmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeShuKSksc31yZWR1Y2VQb2ludHdpc2UodCl7bGV0IGU9bnVsbDtpZih0aGlzLl9jaGFuZ2VQcmVjaXNpb25Nb2RlbCl7Y29uc3Qgbj10aGlzLmNyZWF0ZUZhY3RvcnkodC5nZXRGYWN0b3J5KCksdGhpcy5fdGFyZ2V0UE0pO2U9bmV3IEZ0KG4pfWVsc2UgZT1uZXcgRnQ7bGV0IG49dGhpcy5fcmVtb3ZlQ29sbGFwc2VkO3JldHVybiB0LmdldERpbWVuc2lvbigpPj0yJiYobj0hMCksZS5lZGl0KHQsbmV3IFhyKHRoaXMuX3RhcmdldFBNLG4pKX1jaGFuZ2VQTSh0LGUpe3JldHVybiB0aGlzLmNyZWF0ZUVkaXRvcih0LmdldEZhY3RvcnkoKSxlKS5lZGl0KHQsbmV3IEZ0Lk5vT3BHZW9tZXRyeU9wZXJhdGlvbil9c2V0UmVtb3ZlQ29sbGFwc2VkQ29tcG9uZW50cyh0KXt0aGlzLl9yZW1vdmVDb2xsYXBzZWQ9dH1jcmVhdGVGYWN0b3J5KHQsZSl7cmV0dXJuIG5ldyBIdChlLHQuZ2V0U1JJRCgpLHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpKX1zZXRDaGFuZ2VQcmVjaXNpb25Nb2RlbCh0KXt0aGlzLl9jaGFuZ2VQcmVjaXNpb25Nb2RlbD10fXJlZHVjZSh0KXtjb25zdCBlPXRoaXMucmVkdWNlUG9pbnR3aXNlKHQpO3JldHVybiB0aGlzLl9pc1BvaW50d2lzZT9lOl8oZSxPdCk/Q3IuaXNWYWxpZChlKT9lOnRoaXMuZml4UG9seWdvbmFsVG9wb2xvZ3koZSk6ZX1zZXRQb2ludHdpc2UodCl7dGhpcy5faXNQb2ludHdpc2U9dH1jcmVhdGVFZGl0b3IodCxlKXtpZih0LmdldFByZWNpc2lvbk1vZGVsKCk9PT1lKXJldHVybiBuZXcgRnQ7Y29uc3Qgbj10aGlzLmNyZWF0ZUZhY3RvcnkodCxlKTtyZXR1cm4gbmV3IEZ0KG4pfWdldENsYXNzKCl7cmV0dXJuIEhyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Ici5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl90YXJnZXRQTT1udWxsLHRoaXMuX3JlbW92ZUNvbGxhcHNlZD0hMCx0aGlzLl9jaGFuZ2VQcmVjaXNpb25Nb2RlbD0hMSx0aGlzLl9pc1BvaW50d2lzZT0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl90YXJnZXRQTT10fTt2YXIgV3I9T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsR2VvbWV0cnlQcmVjaXNpb25SZWR1Y2VyOkhyfSk7Y2xhc3MganJ7Y29uc3RydWN0b3IoKXtqci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBzaW1wbGlmeSh0LGUpe2NvbnN0IG49bmV3IGpyKHQpO3JldHVybiBuLnNldERpc3RhbmNlVG9sZXJhbmNlKGUpLG4uc2ltcGxpZnkoKX1zaW1wbGlmeVNlY3Rpb24odCxlKXtpZih0KzE9PT1lKXJldHVybiBudWxsO3RoaXMuX3NlZy5wMD10aGlzLl9wdHNbdF0sdGhpcy5fc2VnLnAxPXRoaXMuX3B0c1tlXTtsZXQgbj0tMSxzPXQ7Zm9yKGxldCBpPXQrMTtpPGU7aSsrKXtjb25zdCB0PXRoaXMuX3NlZy5kaXN0YW5jZSh0aGlzLl9wdHNbaV0pO3Q+biYmKG49dCxzPWkpfWlmKG48PXRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlKWZvcihsZXQgbj10KzE7bjxlO24rKyl0aGlzLl91c2VQdFtuXT0hMTtlbHNlIHRoaXMuc2ltcGxpZnlTZWN0aW9uKHQscyksdGhpcy5zaW1wbGlmeVNlY3Rpb24ocyxlKX1zZXREaXN0YW5jZVRvbGVyYW5jZSh0KXt0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT10fXNpbXBsaWZ5KCl7dGhpcy5fdXNlUHQ9bmV3IEFycmF5KHRoaXMuX3B0cy5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKGxldCB0PTA7dDx0aGlzLl9wdHMubGVuZ3RoO3QrKyl0aGlzLl91c2VQdFt0XT0hMDt0aGlzLnNpbXBsaWZ5U2VjdGlvbigwLHRoaXMuX3B0cy5sZW5ndGgtMSk7Y29uc3QgdD1uZXcgSTtmb3IobGV0IGU9MDtlPHRoaXMuX3B0cy5sZW5ndGg7ZSsrKXRoaXMuX3VzZVB0W2VdJiZ0LmFkZChuZXcgZyh0aGlzLl9wdHNbZV0pKTtyZXR1cm4gdC50b0Nvb3JkaW5hdGVBcnJheSgpfWdldENsYXNzKCl7cmV0dXJuIGpyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1qci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9wdHM9bnVsbCx0aGlzLl91c2VQdD1udWxsLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPW51bGwsdGhpcy5fc2VnPW5ldyBlZTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9wdHM9dH07Y2xhc3MgS3J7Y29uc3RydWN0b3IoKXtLci5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBzaW1wbGlmeSh0LGUpe2NvbnN0IG49bmV3IEtyKHQpO3JldHVybiBuLnNldERpc3RhbmNlVG9sZXJhbmNlKGUpLG4uZ2V0UmVzdWx0R2VvbWV0cnkoKX1zZXRFbnN1cmVWYWxpZCh0KXt0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9dH1nZXRSZXN1bHRHZW9tZXRyeSgpe3JldHVybiB0aGlzLl9pbnB1dEdlb20uaXNFbXB0eSgpP3RoaXMuX2lucHV0R2VvbS5jb3B5KCk6bmV3IFpyKHRoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neSx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZSkudHJhbnNmb3JtKHRoaXMuX2lucHV0R2VvbSl9c2V0RGlzdGFuY2VUb2xlcmFuY2UodCl7aWYodDwwKXRocm93IG5ldyBuKFwiVG9sZXJhbmNlIG11c3QgYmUgbm9uLW5lZ2F0aXZlXCIpO3RoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPXR9Z2V0Q2xhc3MoKXtyZXR1cm4gS3J9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIFpyIGV4dGVuZHMgbWV7Y29uc3RydWN0b3IoKXtzdXBlcigpLFpyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dHJhbnNmb3JtUG9seWdvbih0LGUpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2NvbnN0IG49c3VwZXIudHJhbnNmb3JtUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gZSBpbnN0YW5jZW9mIEF0P246dGhpcy5jcmVhdGVWYWxpZEFyZWEobil9Y3JlYXRlVmFsaWRBcmVhKHQpe3JldHVybiB0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k/dC5idWZmZXIoMCk6dH10cmFuc2Zvcm1Db29yZGluYXRlcyh0LGUpe2NvbnN0IG49dC50b0Nvb3JkaW5hdGVBcnJheSgpO2xldCBzPW51bGw7cmV0dXJuIHM9MD09PW4ubGVuZ3RoP25ldyBBcnJheSgwKS5maWxsKG51bGwpOmpyLnNpbXBsaWZ5KG4sdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2UpLHRoaXMuX2ZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShzKX10cmFuc2Zvcm1NdWx0aVBvbHlnb24odCxlKXtjb25zdCBuPXN1cGVyLnRyYW5zZm9ybU11bHRpUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gdGhpcy5jcmVhdGVWYWxpZEFyZWEobil9dHJhbnNmb3JtTGluZWFyUmluZyh0LGUpe2NvbnN0IG49ZSBpbnN0YW5jZW9mIGJ0LHM9c3VwZXIudHJhbnNmb3JtTGluZWFyUmluZy5jYWxsKHRoaXMsdCxlKTtyZXR1cm4hbnx8cyBpbnN0YW5jZW9mIER0P3M6bnVsbH1nZXRDbGFzcygpe3JldHVybiBacn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19WnIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5PSEwLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5PXQsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9ZX0sS3IuRFBUcmFuc2Zvcm1lcj1acixLci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pbnB1dEdlb209bnVsbCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT1udWxsLHRoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT0hMDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dEdlb209dH07Y2xhc3MgUXIgZXh0ZW5kcyBlZXtjb25zdHJ1Y3Rvcigpe3N1cGVyKCksUXIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRJbmRleCgpe3JldHVybiB0aGlzLl9pbmRleH1nZXRQYXJlbnQoKXtyZXR1cm4gdGhpcy5fcGFyZW50fWdldENsYXNzKCl7cmV0dXJuIFFyfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Rci5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9wYXJlbnQ9bnVsbCx0aGlzLl9pbmRleD1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtRci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSxudWxsLC0xKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxzPWFyZ3VtZW50c1szXTtlZS5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsZSksdGhpcy5fcGFyZW50PW4sdGhpcy5faW5kZXg9c319O2NsYXNzIEpye2NvbnN0cnVjdG9yKCl7SnIuY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgZXh0cmFjdENvb3JkaW5hdGVzKHQpe2NvbnN0IGU9bmV3IEFycmF5KHQuc2l6ZSgpKzEpLmZpbGwobnVsbCk7bGV0IG49bnVsbDtmb3IobGV0IHM9MDtzPHQuc2l6ZSgpO3MrKyluPXQuZ2V0KHMpLGVbc109bi5wMDtyZXR1cm4gZVtlLmxlbmd0aC0xXT1uLnAxLGV9YWRkVG9SZXN1bHQodCl7dGhpcy5fcmVzdWx0U2Vncy5hZGQodCl9YXNMaW5lU3RyaW5nKCl7cmV0dXJuIHRoaXMuX3BhcmVudExpbmUuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoSnIuZXh0cmFjdENvb3JkaW5hdGVzKHRoaXMuX3Jlc3VsdFNlZ3MpKX1nZXRSZXN1bHRTaXplKCl7Y29uc3QgdD10aGlzLl9yZXN1bHRTZWdzLnNpemUoKTtyZXR1cm4gMD09PXQ/MDp0KzF9Z2V0UGFyZW50KCl7cmV0dXJuIHRoaXMuX3BhcmVudExpbmV9Z2V0U2VnbWVudCh0KXtyZXR1cm4gdGhpcy5fc2Vnc1t0XX1nZXRQYXJlbnRDb29yZGluYXRlcygpe3JldHVybiB0aGlzLl9wYXJlbnRMaW5lLmdldENvb3JkaW5hdGVzKCl9Z2V0TWluaW11bVNpemUoKXtyZXR1cm4gdGhpcy5fbWluaW11bVNpemV9YXNMaW5lYXJSaW5nKCl7cmV0dXJuIHRoaXMuX3BhcmVudExpbmUuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcoSnIuZXh0cmFjdENvb3JkaW5hdGVzKHRoaXMuX3Jlc3VsdFNlZ3MpKX1nZXRTZWdtZW50cygpe3JldHVybiB0aGlzLl9zZWdzfWluaXQoKXtjb25zdCB0PXRoaXMuX3BhcmVudExpbmUuZ2V0Q29vcmRpbmF0ZXMoKTt0aGlzLl9zZWdzPW5ldyBBcnJheSh0Lmxlbmd0aC0xKS5maWxsKG51bGwpO2ZvcihsZXQgZT0wO2U8dC5sZW5ndGgtMTtlKyspe2NvbnN0IG49bmV3IFFyKHRbZV0sdFtlKzFdLHRoaXMuX3BhcmVudExpbmUsZSk7dGhpcy5fc2Vnc1tlXT1ufX1nZXRSZXN1bHRDb29yZGluYXRlcygpe3JldHVybiBKci5leHRyYWN0Q29vcmRpbmF0ZXModGhpcy5fcmVzdWx0U2Vncyl9Z2V0Q2xhc3MoKXtyZXR1cm4gSnJ9Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUpyLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX3BhcmVudExpbmU9bnVsbCx0aGlzLl9zZWdzPW51bGwsdGhpcy5fcmVzdWx0U2Vncz1uZXcgeCx0aGlzLl9taW5pbXVtU2l6ZT1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtKci5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQsMil9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcGFyZW50TGluZT10LHRoaXMuX21pbmltdW1TaXplPWUsdGhpcy5pbml0KCl9fTtjbGFzcyAkcntjb25zdHJ1Y3RvcigpeyRyLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmVtb3ZlKHQpe3RoaXMuX2luZGV4LnJlbW92ZShuZXcgTih0LnAwLHQucDEpLHQpfWFkZCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgSnIpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLmdldFNlZ21lbnRzKCk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspe2NvbnN0IG49dFtlXTt0aGlzLmFkZChuKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGVlKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbmRleC5pbnNlcnQobmV3IE4odC5wMCx0LnAxKSx0KX19cXVlcnkodCl7Y29uc3QgZT1uZXcgTih0LnAwLHQucDEpLG49bmV3IHRvKHQpO3JldHVybiB0aGlzLl9pbmRleC5xdWVyeShlLG4pLG4uZ2V0SXRlbXMoKX1nZXRDbGFzcygpe3JldHVybiAkcn1nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19JHIuY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faW5kZXg9bmV3IHVzfTtjbGFzcyB0b3tjb25zdHJ1Y3Rvcigpe3RvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmlzaXRJdGVtKHQpe2NvbnN0IGU9dDtOLmludGVyc2VjdHMoZS5wMCxlLnAxLHRoaXMuX3F1ZXJ5U2VnLnAwLHRoaXMuX3F1ZXJ5U2VnLnAxKSYmdGhpcy5faXRlbXMuYWRkKHQpfWdldEl0ZW1zKCl7cmV0dXJuIHRoaXMuX2l0ZW1zfWdldENsYXNzKCl7cmV0dXJuIHRvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltBZV19fXRvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3F1ZXJ5U2VnPW51bGwsdGhpcy5faXRlbXM9bmV3IHg7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fcXVlcnlTZWc9dH07Y2xhc3MgZW97Y29uc3RydWN0b3IoKXtlby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBpc0luTGluZVNlY3Rpb24odCxlLG4pe2lmKG4uZ2V0UGFyZW50KCkhPT10LmdldFBhcmVudCgpKXJldHVybiExO2NvbnN0IHM9bi5nZXRJbmRleCgpO3JldHVybiBzPj1lWzBdJiZzPGVbMV19ZmxhdHRlbih0LGUpe2NvbnN0IG49dGhpcy5fbGluZVB0c1t0XSxzPXRoaXMuX2xpbmVQdHNbZV0saT1uZXcgZWUobixzKTtyZXR1cm4gdGhpcy5yZW1vdmUodGhpcy5fbGluZSx0LGUpLHRoaXMuX291dHB1dEluZGV4LmFkZChpKSxpfWhhc0JhZEludGVyc2VjdGlvbih0LGUsbil7cmV0dXJuISF0aGlzLmhhc0JhZE91dHB1dEludGVyc2VjdGlvbihuKXx8ISF0aGlzLmhhc0JhZElucHV0SW50ZXJzZWN0aW9uKHQsZSxuKX1zZXREaXN0YW5jZVRvbGVyYW5jZSh0KXt0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT10fXNpbXBsaWZ5U2VjdGlvbih0LGUsbil7bis9MTtjb25zdCBzPW5ldyBBcnJheSgyKS5maWxsKG51bGwpO2lmKHQrMT09PWUpe2NvbnN0IGU9dGhpcy5fbGluZS5nZXRTZWdtZW50KHQpO3JldHVybiB0aGlzLl9saW5lLmFkZFRvUmVzdWx0KGUpLG51bGx9bGV0IGk9ITA7aWYodGhpcy5fbGluZS5nZXRSZXN1bHRTaXplKCk8dGhpcy5fbGluZS5nZXRNaW5pbXVtU2l6ZSgpKXtuKzE8dGhpcy5fbGluZS5nZXRNaW5pbXVtU2l6ZSgpJiYoaT0hMSl9Y29uc3Qgcj1uZXcgQXJyYXkoMSkuZmlsbChudWxsKSxvPXRoaXMuZmluZEZ1cnRoZXN0UG9pbnQodGhpcy5fbGluZVB0cyx0LGUscik7clswXT50aGlzLl9kaXN0YW5jZVRvbGVyYW5jZSYmKGk9ITEpO2NvbnN0IGw9bmV3IGVlO2lmKGwucDA9dGhpcy5fbGluZVB0c1t0XSxsLnAxPXRoaXMuX2xpbmVQdHNbZV0sc1swXT10LHNbMV09ZSx0aGlzLmhhc0JhZEludGVyc2VjdGlvbih0aGlzLl9saW5lLHMsbCkmJihpPSExKSxpKXtjb25zdCBuPXRoaXMuZmxhdHRlbih0LGUpO3JldHVybiB0aGlzLl9saW5lLmFkZFRvUmVzdWx0KG4pLG51bGx9dGhpcy5zaW1wbGlmeVNlY3Rpb24odCxvLG4pLHRoaXMuc2ltcGxpZnlTZWN0aW9uKG8sZSxuKX1oYXNCYWRPdXRwdXRJbnRlcnNlY3Rpb24odCl7Zm9yKGxldCBlPXRoaXMuX291dHB1dEluZGV4LnF1ZXJ5KHQpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXtjb25zdCBuPWUubmV4dCgpO2lmKHRoaXMuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24obix0KSlyZXR1cm4hMH1yZXR1cm4hMX1maW5kRnVydGhlc3RQb2ludCh0LGUsbixzKXtjb25zdCBpPW5ldyBlZTtpLnAwPXRbZV0saS5wMT10W25dO2xldCByPS0xLG89ZTtmb3IobGV0IHM9ZSsxO3M8bjtzKyspe2NvbnN0IGU9dFtzXSxuPWkuZGlzdGFuY2UoZSk7bj5yJiYocj1uLG89cyl9cmV0dXJuIHNbMF09cixvfXNpbXBsaWZ5KHQpe3RoaXMuX2xpbmU9dCx0aGlzLl9saW5lUHRzPXQuZ2V0UGFyZW50Q29vcmRpbmF0ZXMoKSx0aGlzLnNpbXBsaWZ5U2VjdGlvbigwLHRoaXMuX2xpbmVQdHMubGVuZ3RoLTEsMCl9cmVtb3ZlKHQsZSxuKXtmb3IobGV0IHM9ZTtzPG47cysrKXtjb25zdCBlPXQuZ2V0U2VnbWVudChzKTt0aGlzLl9pbnB1dEluZGV4LnJlbW92ZShlKX19aGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0LnAwLHQucDEsZS5wMCxlLnAxKSx0aGlzLl9saS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCl9aGFzQmFkSW5wdXRJbnRlcnNlY3Rpb24odCxlLG4pe2ZvcihsZXQgcz10aGlzLl9pbnB1dEluZGV4LnF1ZXJ5KG4pLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCBpPXMubmV4dCgpO2lmKHRoaXMuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24oaSxuKSl7aWYoZW8uaXNJbkxpbmVTZWN0aW9uKHQsZSxpKSljb250aW51ZTtyZXR1cm4hMH19cmV0dXJuITF9Z2V0Q2xhc3MoKXtyZXR1cm4gZW99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWVvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpPW5ldyB0ZSx0aGlzLl9pbnB1dEluZGV4PW5ldyAkcix0aGlzLl9vdXRwdXRJbmRleD1uZXcgJHIsdGhpcy5fbGluZT1udWxsLHRoaXMuX2xpbmVQdHM9bnVsbCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT0wO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2lucHV0SW5kZXg9dCx0aGlzLl9vdXRwdXRJbmRleD1lfTtjbGFzcyBub3tjb25zdHJ1Y3Rvcigpe25vLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c2V0RGlzdGFuY2VUb2xlcmFuY2UodCl7dGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9dH1zaW1wbGlmeSh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLl9pbnB1dEluZGV4LmFkZChlLm5leHQoKSk7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9bmV3IGVvKHRoaXMuX2lucHV0SW5kZXgsdGhpcy5fb3V0cHV0SW5kZXgpO3Quc2V0RGlzdGFuY2VUb2xlcmFuY2UodGhpcy5fZGlzdGFuY2VUb2xlcmFuY2UpLHQuc2ltcGxpZnkoZS5uZXh0KCkpfX1nZXRDbGFzcygpe3JldHVybiBub31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19bm8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRJbmRleD1uZXcgJHIsdGhpcy5fb3V0cHV0SW5kZXg9bmV3ICRyLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPTB9O2NsYXNzIHNve2NvbnN0cnVjdG9yKCl7c28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgc2ltcGxpZnkodCxlKXtjb25zdCBuPW5ldyBzbyh0KTtyZXR1cm4gbi5zZXREaXN0YW5jZVRvbGVyYW5jZShlKSxuLmdldFJlc3VsdEdlb21ldHJ5KCl9Z2V0UmVzdWx0R2VvbWV0cnkoKXtpZih0aGlzLl9pbnB1dEdlb20uaXNFbXB0eSgpKXJldHVybiB0aGlzLl9pbnB1dEdlb20uY29weSgpO3JldHVybiB0aGlzLl9saW5lc3RyaW5nTWFwPW5ldyBVdCx0aGlzLl9pbnB1dEdlb20uYXBwbHkobmV3IHJvKHRoaXMpKSx0aGlzLl9saW5lU2ltcGxpZmllci5zaW1wbGlmeSh0aGlzLl9saW5lc3RyaW5nTWFwLnZhbHVlcygpKSxuZXcgaW8odGhpcy5fbGluZXN0cmluZ01hcCkudHJhbnNmb3JtKHRoaXMuX2lucHV0R2VvbSl9c2V0RGlzdGFuY2VUb2xlcmFuY2UodCl7aWYodDwwKXRocm93IG5ldyBuKFwiVG9sZXJhbmNlIG11c3QgYmUgbm9uLW5lZ2F0aXZlXCIpO3RoaXMuX2xpbmVTaW1wbGlmaWVyLnNldERpc3RhbmNlVG9sZXJhbmNlKHQpfWdldENsYXNzKCl7cmV0dXJuIHNvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyBpbyBleHRlbmRzIG1le2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxpby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXRyYW5zZm9ybUNvb3JkaW5hdGVzKHQsZSl7aWYoMD09PXQuc2l6ZSgpKXJldHVybiBudWxsO2lmKGUgaW5zdGFuY2VvZiBUdCl7Y29uc3QgdD10aGlzLl9saW5lc3RyaW5nTWFwLmdldChlKTtyZXR1cm4gdGhpcy5jcmVhdGVDb29yZGluYXRlU2VxdWVuY2UodC5nZXRSZXN1bHRDb29yZGluYXRlcygpKX1yZXR1cm4gc3VwZXIudHJhbnNmb3JtQ29vcmRpbmF0ZXMuY2FsbCh0aGlzLHQsZSl9Z2V0Q2xhc3MoKXtyZXR1cm4gaW99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWlvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpbmVzdHJpbmdNYXA9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lc3RyaW5nTWFwPXR9O2NsYXNzIHJve2NvbnN0cnVjdG9yKCl7cm8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1maWx0ZXIodCl7aWYodCBpbnN0YW5jZW9mIFR0KXtjb25zdCBlPXQ7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIG51bGw7Y29uc3Qgbj1lLmlzQ2xvc2VkKCk/NDoyLHM9bmV3IEpyKGUsbik7dGhpcy50cHMuX2xpbmVzdHJpbmdNYXAucHV0KGUscyl9fWdldENsYXNzKCl7cmV0dXJuIHJvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltHXX19cm8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy50cHM9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnRwcz10fSxzby5MaW5lU3RyaW5nVHJhbnNmb3JtZXI9aW8sc28uTGluZVN0cmluZ01hcEJ1aWxkZXJGaWx0ZXI9cm8sc28uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5fbGluZVNpbXBsaWZpZXI9bmV3IG5vLHRoaXMuX2xpbmVzdHJpbmdNYXA9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9pbnB1dEdlb209dH07Y2xhc3Mgb297Y29uc3RydWN0b3IoKXtvby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBzaW1wbGlmeSh0LGUpe3JldHVybiBuZXcgb28odCxlKS5zaW1wbGlmeSgpfXNpbXBsaWZ5VmVydGV4KHQpe2xldCBlPXQsbj1lLmdldEFyZWEoKSxzPW51bGw7Zm9yKDtudWxsIT09ZTspe2NvbnN0IHQ9ZS5nZXRBcmVhKCk7dDxuJiYobj10LHM9ZSksZT1lLl9uZXh0fXJldHVybiBudWxsIT09cyYmbjx0aGlzLl90b2xlcmFuY2UmJnMucmVtb3ZlKCksdC5pc0xpdmUoKT9uOi0xfXNpbXBsaWZ5KCl7Y29uc3QgdD1sby5idWlsZExpbmUodGhpcy5fcHRzKTtsZXQgZT10aGlzLl90b2xlcmFuY2U7ZG97ZT10aGlzLnNpbXBsaWZ5VmVydGV4KHQpfXdoaWxlKGU8dGhpcy5fdG9sZXJhbmNlKTtjb25zdCBuPXQuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gbi5sZW5ndGg8Mj9bblswXSxuZXcgZyhuWzBdKV06bn1nZXRDbGFzcygpe3JldHVybiBvb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Y2xhc3MgbG97Y29uc3RydWN0b3IoKXtsby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBidWlsZExpbmUodCl7bGV0IGU9bnVsbCxuPW51bGw7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspe2NvbnN0IGk9bmV3IGxvKHRbc10pO251bGw9PT1lJiYoZT1pKSxpLnNldFByZXYobiksbnVsbCE9PW4mJihuLnNldE5leHQoaSksbi51cGRhdGVBcmVhKCkpLG49aX1yZXR1cm4gZX1nZXRDb29yZGluYXRlcygpe2NvbnN0IHQ9bmV3IEk7bGV0IGU9dGhpcztkb3t0LmFkZChlLl9wdCwhMSksZT1lLl9uZXh0fXdoaWxlKG51bGwhPT1lKTtyZXR1cm4gdC50b0Nvb3JkaW5hdGVBcnJheSgpfWdldEFyZWEoKXtyZXR1cm4gdGhpcy5fYXJlYX11cGRhdGVBcmVhKCl7aWYobnVsbD09PXRoaXMuX3ByZXZ8fG51bGw9PT10aGlzLl9uZXh0KXJldHVybiB0aGlzLl9hcmVhPWxvLk1BWF9BUkVBLG51bGw7dGhpcy5fYXJlYT1NYXRoLmFicyhyZS5hcmVhKHRoaXMuX3ByZXYuX3B0LHRoaXMuX3B0LHRoaXMuX25leHQuX3B0KSl9cmVtb3ZlKCl7Y29uc3QgdD10aGlzLl9wcmV2LGU9dGhpcy5fbmV4dDtsZXQgbj1udWxsO3JldHVybiBudWxsIT09dGhpcy5fcHJldiYmKHRoaXMuX3ByZXYuc2V0TmV4dChlKSx0aGlzLl9wcmV2LnVwZGF0ZUFyZWEoKSxuPXRoaXMuX3ByZXYpLG51bGwhPT10aGlzLl9uZXh0JiYodGhpcy5fbmV4dC5zZXRQcmV2KHQpLHRoaXMuX25leHQudXBkYXRlQXJlYSgpLG51bGw9PT1uJiYobj10aGlzLl9uZXh0KSksdGhpcy5faXNMaXZlPSExLG59aXNMaXZlKCl7cmV0dXJuIHRoaXMuX2lzTGl2ZX1zZXRQcmV2KHQpe3RoaXMuX3ByZXY9dH1zZXROZXh0KHQpe3RoaXMuX25leHQ9dH1nZXRDbGFzcygpe3JldHVybiBsb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19bG8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcHQ9bnVsbCx0aGlzLl9wcmV2PW51bGwsdGhpcy5fbmV4dD1udWxsLHRoaXMuX2FyZWE9bG8uTUFYX0FSRUEsdGhpcy5faXNMaXZlPSEwO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3B0PXR9LGxvLk1BWF9BUkVBPWkuTUFYX1ZBTFVFLG9vLlZXVmVydGV4PWxvLG9vLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3B0cz1udWxsLHRoaXMuX3RvbGVyYW5jZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX3B0cz10LHRoaXMuX3RvbGVyYW5jZT1lKmV9O2NsYXNzIGFve2NvbnN0cnVjdG9yKCl7YW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgc2ltcGxpZnkodCxlKXtjb25zdCBuPW5ldyBhbyh0KTtyZXR1cm4gbi5zZXREaXN0YW5jZVRvbGVyYW5jZShlKSxuLmdldFJlc3VsdEdlb21ldHJ5KCl9c2V0RW5zdXJlVmFsaWQodCl7dGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5PXR9Z2V0UmVzdWx0R2VvbWV0cnkoKXtyZXR1cm4gdGhpcy5faW5wdXRHZW9tLmlzRW1wdHkoKT90aGlzLl9pbnB1dEdlb20uY29weSgpOm5ldyBjbyh0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3ksdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2UpLnRyYW5zZm9ybSh0aGlzLl9pbnB1dEdlb20pfXNldERpc3RhbmNlVG9sZXJhbmNlKHQpe2lmKHQ8MCl0aHJvdyBuZXcgbihcIlRvbGVyYW5jZSBtdXN0IGJlIG5vbi1uZWdhdGl2ZVwiKTt0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT10fWdldENsYXNzKCl7cmV0dXJuIGFvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyBjbyBleHRlbmRzIG1le2NvbnN0cnVjdG9yKCl7c3VwZXIoKSxjby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXRyYW5zZm9ybVBvbHlnb24odCxlKXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtjb25zdCBuPXN1cGVyLnRyYW5zZm9ybVBvbHlnb24uY2FsbCh0aGlzLHQsZSk7cmV0dXJuIGUgaW5zdGFuY2VvZiBBdD9uOnRoaXMuY3JlYXRlVmFsaWRBcmVhKG4pfWNyZWF0ZVZhbGlkQXJlYSh0KXtyZXR1cm4gdGhpcy5faXNFbnN1cmVWYWxpZFRvcG9sb2d5P3QuYnVmZmVyKDApOnR9dHJhbnNmb3JtQ29vcmRpbmF0ZXModCxlKXtjb25zdCBuPXQudG9Db29yZGluYXRlQXJyYXkoKTtsZXQgcz1udWxsO3JldHVybiBzPTA9PT1uLmxlbmd0aD9uZXcgQXJyYXkoMCkuZmlsbChudWxsKTpvby5zaW1wbGlmeShuLHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlKSx0aGlzLl9mYWN0b3J5LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUocyl9dHJhbnNmb3JtTXVsdGlQb2x5Z29uKHQsZSl7Y29uc3Qgbj1zdXBlci50cmFuc2Zvcm1NdWx0aVBvbHlnb24uY2FsbCh0aGlzLHQsZSk7cmV0dXJuIHRoaXMuY3JlYXRlVmFsaWRBcmVhKG4pfXRyYW5zZm9ybUxpbmVhclJpbmcodCxlKXtjb25zdCBuPWUgaW5zdGFuY2VvZiBidCxzPXN1cGVyLnRyYW5zZm9ybUxpbmVhclJpbmcuY2FsbCh0aGlzLHQsZSk7cmV0dXJuIW58fHMgaW5zdGFuY2VvZiBEdD9zOm51bGx9Z2V0Q2xhc3MoKXtyZXR1cm4gY299Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT0hMCx0aGlzLl9kaXN0YW5jZVRvbGVyYW5jZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2lzRW5zdXJlVmFsaWRUb3BvbG9neT10LHRoaXMuX2Rpc3RhbmNlVG9sZXJhbmNlPWV9LGFvLlZXVHJhbnNmb3JtZXI9Y28sYW8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRHZW9tPW51bGwsdGhpcy5fZGlzdGFuY2VUb2xlcmFuY2U9bnVsbCx0aGlzLl9pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9ITA7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5faW5wdXRHZW9tPXR9O3ZhciBobz1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxEb3VnbGFzUGV1Y2tlclNpbXBsaWZpZXI6S3IsVG9wb2xvZ3lQcmVzZXJ2aW5nU2ltcGxpZmllcjpzbyxWV1NpbXBsaWZpZXI6YW99KTtjbGFzcyB1b3tjb25zdHJ1Y3Rvcigpe3VvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHBvaW50QWxvbmdSZXZlcnNlKHQsZSl7Y29uc3Qgbj1uZXcgZztyZXR1cm4gbi54PXQucDEueC1lKih0LnAxLngtdC5wMC54KSxuLnk9dC5wMS55LWUqKHQucDEueS10LnAwLnkpLG59c3BsaXRBdCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXRoaXMuX21pbmltdW1MZW4vdGhpcy5fc2VnTGVuO2lmKHQuZGlzdGFuY2UodGhpcy5fc2VnLnAwKTx0aGlzLl9taW5pbXVtTGVuKXJldHVybiB0aGlzLl9zcGxpdFB0PXRoaXMuX3NlZy5wb2ludEFsb25nKGUpLG51bGw7aWYodC5kaXN0YW5jZSh0aGlzLl9zZWcucDEpPHRoaXMuX21pbmltdW1MZW4pcmV0dXJuIHRoaXMuX3NwbGl0UHQ9dW8ucG9pbnRBbG9uZ1JldmVyc2UodGhpcy5fc2VnLGUpLG51bGw7dGhpcy5fc3BsaXRQdD10fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dGhpcy5nZXRDb25zdHJhaW5lZExlbmd0aCh0KS90aGlzLl9zZWdMZW47ZS5lcXVhbHMyRCh0aGlzLl9zZWcucDApP3RoaXMuX3NwbGl0UHQ9dGhpcy5fc2VnLnBvaW50QWxvbmcobik6dGhpcy5fc3BsaXRQdD11by5wb2ludEFsb25nUmV2ZXJzZSh0aGlzLl9zZWcsbil9fXNldE1pbmltdW1MZW5ndGgodCl7dGhpcy5fbWluaW11bUxlbj10fWdldENvbnN0cmFpbmVkTGVuZ3RoKHQpe3JldHVybiB0PHRoaXMuX21pbmltdW1MZW4/dGhpcy5fbWluaW11bUxlbjp0fWdldFNwbGl0UG9pbnQoKXtyZXR1cm4gdGhpcy5fc3BsaXRQdH1nZXRDbGFzcygpe3JldHVybiB1b31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19dW8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fc2VnPW51bGwsdGhpcy5fc2VnTGVuPW51bGwsdGhpcy5fc3BsaXRQdD1udWxsLHRoaXMuX21pbmltdW1MZW49MDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zZWc9dCx0aGlzLl9zZWdMZW49dC5nZXRMZW5ndGgoKX07Y2xhc3MgZ297Y29uc3RydWN0b3IoKXtnby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbmRTcGxpdFBvaW50KHQsZSl7fWdldENsYXNzKCl7cmV0dXJuIGdvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1nby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIF9ve2NvbnN0cnVjdG9yKCl7X28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgcHJvamVjdGVkU3BsaXRQb2ludCh0LGUpe3JldHVybiB0LmdldExpbmVTZWdtZW50KCkucHJvamVjdChlKX1maW5kU3BsaXRQb2ludCh0LGUpe2NvbnN0IG49dC5nZXRMaW5lU2VnbWVudCgpLHM9bi5nZXRMZW5ndGgoKS8yLGk9bmV3IHVvKG4pLHI9X28ucHJvamVjdGVkU3BsaXRQb2ludCh0LGUpO2xldCBvPTIqci5kaXN0YW5jZShlKSouODtyZXR1cm4gbz5zJiYobz1zKSxpLnNldE1pbmltdW1MZW5ndGgobyksaS5zcGxpdEF0KHIpLGkuZ2V0U3BsaXRQb2ludCgpfWdldENsYXNzKCl7cmV0dXJuIF9vfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltnb119fV9vLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgZm97Y29uc3RydWN0b3IoKXtmby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyB0cmlBcmVhKHQsZSxuKXtyZXR1cm4oZS54LXQueCkqKG4ueS10LnkpLShlLnktdC55KSoobi54LXQueCl9c3RhdGljIGlzSW5DaXJjbGVERE5vcm1hbGl6ZWQodCxlLG4scyl7Y29uc3QgaT1SLnZhbHVlT2YodC54KS5zZWxmU3VidHJhY3Qocy54KSxyPVIudmFsdWVPZih0LnkpLnNlbGZTdWJ0cmFjdChzLnkpLG89Ui52YWx1ZU9mKGUueCkuc2VsZlN1YnRyYWN0KHMueCksbD1SLnZhbHVlT2YoZS55KS5zZWxmU3VidHJhY3Qocy55KSxhPVIudmFsdWVPZihuLngpLnNlbGZTdWJ0cmFjdChzLngpLGM9Ui52YWx1ZU9mKG4ueSkuc2VsZlN1YnRyYWN0KHMueSksaD1pLm11bHRpcGx5KGwpLnNlbGZTdWJ0cmFjdChvLm11bHRpcGx5KHIpKSx1PW8ubXVsdGlwbHkoYykuc2VsZlN1YnRyYWN0KGEubXVsdGlwbHkobCkpLGc9YS5tdWx0aXBseShyKS5zZWxmU3VidHJhY3QoaS5tdWx0aXBseShjKSksZD1pLm11bHRpcGx5KGkpLnNlbGZBZGQoci5tdWx0aXBseShyKSksXz1vLm11bHRpcGx5KG8pLnNlbGZBZGQobC5tdWx0aXBseShsKSksZj1hLm11bHRpcGx5KGEpLnNlbGZBZGQoYy5tdWx0aXBseShjKSk7cmV0dXJuIGQuc2VsZk11bHRpcGx5KHUpLnNlbGZBZGQoXy5zZWxmTXVsdGlwbHkoZykpLnNlbGZBZGQoZi5zZWxmTXVsdGlwbHkoaCkpLmRvdWJsZVZhbHVlKCk+MH1zdGF0aWMgY2hlY2tSb2J1c3RJbkNpcmNsZSh0LGUsbixzKXtjb25zdCBpPWZvLmlzSW5DaXJjbGVOb25Sb2J1c3QodCxlLG4scykscj1mby5pc0luQ2lyY2xlRERTbG93KHQsZSxuLHMpLG89Zm8uaXNJbkNpcmNsZUNDKHQsZSxuLHMpLGw9cmUuY2lyY3VtY2VudHJlKHQsZSxuKTtPLm91dC5wcmludGxuKFwicCByYWRpdXMgZGlmZiBhID0gXCIrTWF0aC5hYnMocy5kaXN0YW5jZShsKS10LmRpc3RhbmNlKGwpKS90LmRpc3RhbmNlKGwpKSxpPT09ciYmaT09PW98fChPLm91dC5wcmludGxuKFwiaW5DaXJjbGUgcm9idXN0bmVzcyBmYWlsdXJlIChkb3VibGUgcmVzdWx0ID0gXCIraStcIiwgREQgcmVzdWx0ID0gXCIrcitcIiwgQ0MgcmVzdWx0ID0gXCIrbytcIilcIiksTy5vdXQucHJpbnRsbihKdC50b0xpbmVTdHJpbmcobmV3IHp0KFt0LGUsbixzXSkpKSxPLm91dC5wcmludGxuKFwiQ2lyY3VtY2VudHJlID0gXCIrSnQudG9Qb2ludChsKStcIiByYWRpdXMgPSBcIit0LmRpc3RhbmNlKGwpKSxPLm91dC5wcmludGxuKFwicCByYWRpdXMgZGlmZiBhID0gXCIrTWF0aC5hYnMocy5kaXN0YW5jZShsKS90LmRpc3RhbmNlKGwpLTEpKSxPLm91dC5wcmludGxuKFwicCByYWRpdXMgZGlmZiBiID0gXCIrTWF0aC5hYnMocy5kaXN0YW5jZShsKS9lLmRpc3RhbmNlKGwpLTEpKSxPLm91dC5wcmludGxuKFwicCByYWRpdXMgZGlmZiBjID0gXCIrTWF0aC5hYnMocy5kaXN0YW5jZShsKS9uLmRpc3RhbmNlKGwpLTEpKSxPLm91dC5wcmludGxuKCkpfXN0YXRpYyBpc0luQ2lyY2xlRERGYXN0KHQsZSxuLHMpe2NvbnN0IGk9Ui5zcXIodC54KS5zZWxmQWRkKFIuc3FyKHQueSkpLnNlbGZNdWx0aXBseShmby50cmlBcmVhRERGYXN0KGUsbixzKSkscj1SLnNxcihlLngpLnNlbGZBZGQoUi5zcXIoZS55KSkuc2VsZk11bHRpcGx5KGZvLnRyaUFyZWFEREZhc3QodCxuLHMpKSxvPVIuc3FyKG4ueCkuc2VsZkFkZChSLnNxcihuLnkpKS5zZWxmTXVsdGlwbHkoZm8udHJpQXJlYURERmFzdCh0LGUscykpLGw9Ui5zcXIocy54KS5zZWxmQWRkKFIuc3FyKHMueSkpLnNlbGZNdWx0aXBseShmby50cmlBcmVhRERGYXN0KHQsZSxuKSk7cmV0dXJuIGkuc2VsZlN1YnRyYWN0KHIpLnNlbGZBZGQobykuc2VsZlN1YnRyYWN0KGwpLmRvdWJsZVZhbHVlKCk+MH1zdGF0aWMgaXNJbkNpcmNsZUNDKHQsZSxuLHMpe2NvbnN0IGk9cmUuY2lyY3VtY2VudHJlKHQsZSxuKSxyPXQuZGlzdGFuY2UoaSk7cmV0dXJuIHMuZGlzdGFuY2UoaSktcjw9MH1zdGF0aWMgaXNJbkNpcmNsZU5vcm1hbGl6ZWQodCxlLG4scyl7Y29uc3QgaT10Lngtcy54LHI9dC55LXMueSxvPWUueC1zLngsbD1lLnktcy55LGE9bi54LXMueCxjPW4ueS1zLnk7cmV0dXJuKGkqaStyKnIpKihvKmMtYSpsKSsobypvK2wqbCkqKGEqci1pKmMpKyhhKmErYypjKSooaSpsLW8qcik+MH1zdGF0aWMgaXNJbkNpcmNsZUREU2xvdyh0LGUsbixzKXtjb25zdCBpPVIudmFsdWVPZihzLngpLHI9Ui52YWx1ZU9mKHMueSksbz1SLnZhbHVlT2YodC54KSxsPVIudmFsdWVPZih0LnkpLGE9Ui52YWx1ZU9mKGUueCksYz1SLnZhbHVlT2YoZS55KSxoPVIudmFsdWVPZihuLngpLHU9Ui52YWx1ZU9mKG4ueSksZz1vLm11bHRpcGx5KG8pLmFkZChsLm11bHRpcGx5KGwpKS5tdWx0aXBseShmby50cmlBcmVhRERTbG93KGEsYyxoLHUsaSxyKSksZD1hLm11bHRpcGx5KGEpLmFkZChjLm11bHRpcGx5KGMpKS5tdWx0aXBseShmby50cmlBcmVhRERTbG93KG8sbCxoLHUsaSxyKSksXz1oLm11bHRpcGx5KGgpLmFkZCh1Lm11bHRpcGx5KHUpKS5tdWx0aXBseShmby50cmlBcmVhRERTbG93KG8sbCxhLGMsaSxyKSksZj1pLm11bHRpcGx5KGkpLmFkZChyLm11bHRpcGx5KHIpKS5tdWx0aXBseShmby50cmlBcmVhRERTbG93KG8sbCxhLGMsaCx1KSk7cmV0dXJuIGcuc3VidHJhY3QoZCkuYWRkKF8pLnN1YnRyYWN0KGYpLmRvdWJsZVZhbHVlKCk+MH1zdGF0aWMgaXNJbkNpcmNsZU5vblJvYnVzdCh0LGUsbixzKXtyZXR1cm4odC54KnQueCt0LnkqdC55KSpmby50cmlBcmVhKGUsbixzKS0oZS54KmUueCtlLnkqZS55KSpmby50cmlBcmVhKHQsbixzKSsobi54Km4ueCtuLnkqbi55KSpmby50cmlBcmVhKHQsZSxzKS0ocy54KnMueCtzLnkqcy55KSpmby50cmlBcmVhKHQsZSxuKT4wfXN0YXRpYyBpc0luQ2lyY2xlUm9idXN0KHQsZSxuLHMpe3JldHVybiBmby5pc0luQ2lyY2xlTm9ybWFsaXplZCh0LGUsbixzKX1zdGF0aWMgdHJpQXJlYUREU2xvdyh0LGUsbixzLGkscil7cmV0dXJuIG4uc3VidHJhY3QodCkubXVsdGlwbHkoci5zdWJ0cmFjdChlKSkuc3VidHJhY3Qocy5zdWJ0cmFjdChlKS5tdWx0aXBseShpLnN1YnRyYWN0KHQpKSl9c3RhdGljIHRyaUFyZWFEREZhc3QodCxlLG4pe2NvbnN0IHM9Ui52YWx1ZU9mKGUueCkuc2VsZlN1YnRyYWN0KHQueCkuc2VsZk11bHRpcGx5KFIudmFsdWVPZihuLnkpLnNlbGZTdWJ0cmFjdCh0LnkpKSxpPVIudmFsdWVPZihlLnkpLnNlbGZTdWJ0cmFjdCh0LnkpLnNlbGZNdWx0aXBseShSLnZhbHVlT2Yobi54KS5zZWxmU3VidHJhY3QodC54KSk7cmV0dXJuIHMuc2VsZlN1YnRyYWN0KGkpfWdldENsYXNzKCl7cmV0dXJuIGZvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1mby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt9O2NsYXNzIHBve2NvbnN0cnVjdG9yKCl7cG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaW50ZXJwb2xhdGVaKCl7aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9ZS5kaXN0YW5jZShuKSxpPXQuZGlzdGFuY2UoZSkscj1uLnotZS56O3JldHVybiBlLnorciooaS9zKX1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1lLngscj1lLnksbz1uLngtaSxsPXMueC1pLGE9bi55LXIsYz1zLnktcixoPW8qYy1sKmEsdT10LngtaSxnPXQueS1yLGQ9KGMqdS1sKmcpL2gsXz0oLWEqdStvKmcpL2g7cmV0dXJuIGUueitkKihuLnotZS56KStfKihzLnotZS56KX19Y2lyY2xlQ2VudGVyKHQsZSl7Y29uc3Qgbj1uZXcgcG8odGhpcy5nZXRYKCksdGhpcy5nZXRZKCkpLHM9dGhpcy5iaXNlY3RvcihuLHQpLGk9dGhpcy5iaXNlY3Rvcih0LGUpLHI9bmV3IGIocyxpKTtsZXQgbz1udWxsO3RyeXtvPW5ldyBwbyhyLmdldFgoKSxyLmdldFkoKSl9Y2F0Y2gocyl7aWYoIShzIGluc3RhbmNlb2YgUykpdGhyb3cgcztPLmVyci5wcmludGxuKFwiYTogXCIrbitcIiAgYjogXCIrdCtcIiAgYzogXCIrZSksTy5lcnIucHJpbnRsbihzKX1yZXR1cm4gb31kb3QodCl7cmV0dXJuIHRoaXMuX3AueCp0LmdldFgoKSt0aGlzLl9wLnkqdC5nZXRZKCl9bWFnbigpe3JldHVybiBNYXRoLnNxcnQodGhpcy5fcC54KnRoaXMuX3AueCt0aGlzLl9wLnkqdGhpcy5fcC55KX1nZXRaKCl7cmV0dXJuIHRoaXMuX3Auen1iaXNlY3Rvcih0LGUpe2NvbnN0IG49ZS5nZXRYKCktdC5nZXRYKCkscz1lLmdldFkoKS10LmdldFkoKSxpPW5ldyBiKHQuZ2V0WCgpK24vMix0LmdldFkoKStzLzIsMSkscj1uZXcgYih0LmdldFgoKS1zK24vMix0LmdldFkoKStuK3MvMiwxKTtyZXR1cm4gbmV3IGIoaSxyKX1lcXVhbHMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX3AueD09PXQuZ2V0WCgpJiZ0aGlzLl9wLnk9PT10LmdldFkoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuX3AuZGlzdGFuY2UodC5nZXRDb29yZGluYXRlKCkpPGV9fWdldENvb3JkaW5hdGUoKXtyZXR1cm4gdGhpcy5fcH1pc0luQ2lyY2xlKHQsZSxuKXtyZXR1cm4gZm8uaXNJbkNpcmNsZVJvYnVzdCh0Ll9wLGUuX3Asbi5fcCx0aGlzLl9wKX1pbnRlcnBvbGF0ZVpWYWx1ZSh0LGUsbil7Y29uc3Qgcz10LmdldFgoKSxpPXQuZ2V0WSgpLHI9ZS5nZXRYKCktcyxvPW4uZ2V0WCgpLXMsbD1lLmdldFkoKS1pLGE9bi5nZXRZKCktaSxjPXIqYS1vKmwsaD10aGlzLmdldFgoKS1zLHU9dGhpcy5nZXRZKCktaSxnPShhKmgtbyp1KS9jLGQ9KC1sKmgrcip1KS9jO3JldHVybiB0LmdldFooKStnKihlLmdldFooKS10LmdldFooKSkrZCoobi5nZXRaKCktdC5nZXRaKCkpfW1pZFBvaW50KHQpe2NvbnN0IGU9KHRoaXMuX3AueCt0LmdldFgoKSkvMixuPSh0aGlzLl9wLnkrdC5nZXRZKCkpLzIscz0odGhpcy5fcC56K3QuZ2V0WigpKS8yO3JldHVybiBuZXcgcG8oZSxuLHMpfXJpZ2h0T2YodCl7cmV0dXJuIHRoaXMuaXNDQ1codC5kZXN0KCksdC5vcmlnKCkpfWlzQ0NXKHQsZSl7cmV0dXJuKHQuX3AueC10aGlzLl9wLngpKihlLl9wLnktdGhpcy5fcC55KS0odC5fcC55LXRoaXMuX3AueSkqKGUuX3AueC10aGlzLl9wLngpPjB9Z2V0WCgpe3JldHVybiB0aGlzLl9wLnh9Y3Jvc3NQcm9kdWN0KHQpe3JldHVybiB0aGlzLl9wLngqdC5nZXRZKCktdGhpcy5fcC55KnQuZ2V0WCgpfXNldFoodCl7dGhpcy5fcC56PXR9dGltZXModCl7cmV0dXJuIG5ldyBwbyh0KnRoaXMuX3AueCx0KnRoaXMuX3AueSl9Y3Jvc3MoKXtyZXR1cm4gbmV3IHBvKHRoaXMuX3AueSwtdGhpcy5fcC54KX1sZWZ0T2YodCl7cmV0dXJuIHRoaXMuaXNDQ1codC5vcmlnKCksdC5kZXN0KCkpfXRvU3RyaW5nKCl7cmV0dXJuXCJQT0lOVCAoXCIrdGhpcy5fcC54K1wiIFwiK3RoaXMuX3AueStcIilcIn1zdWIodCl7cmV0dXJuIG5ldyBwbyh0aGlzLl9wLngtdC5nZXRYKCksdGhpcy5fcC55LXQuZ2V0WSgpKX1nZXRZKCl7cmV0dXJuIHRoaXMuX3AueX1jbGFzc2lmeSh0LGUpe2NvbnN0IG49ZS5zdWIodCkscz10aGlzLnN1Yih0KSxpPW4uY3Jvc3NQcm9kdWN0KHMpO3JldHVybiBpPjA/cG8uTEVGVDppPDA/cG8uUklHSFQ6bi5nZXRYKCkqcy5nZXRYKCk8MHx8bi5nZXRZKCkqcy5nZXRZKCk8MD9wby5CRUhJTkQ6bi5tYWduKCk8cy5tYWduKCk/cG8uQkVZT05EOnQuZXF1YWxzKHRoaXMpP3BvLk9SSUdJTjplLmVxdWFscyh0aGlzKT9wby5ERVNUSU5BVElPTjpwby5CRVRXRUVOfXN1bSh0KXtyZXR1cm4gbmV3IHBvKHRoaXMuX3AueCt0LmdldFgoKSx0aGlzLl9wLnkrdC5nZXRZKCkpfWRpc3RhbmNlKHQsZSl7cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhlLmdldFgoKS10LmdldFgoKSwyKStNYXRoLnBvdyhlLmdldFkoKS10LmdldFkoKSwyKSl9Y2lyY3VtUmFkaXVzUmF0aW8odCxlKXtjb25zdCBuPXRoaXMuY2lyY2xlQ2VudGVyKHQsZSkscz10aGlzLmRpc3RhbmNlKG4sdCk7bGV0IGk9dGhpcy5kaXN0YW5jZSh0aGlzLHQpLHI9dGhpcy5kaXN0YW5jZSh0LGUpO3JldHVybiByPGkmJihpPXIpLHI9dGhpcy5kaXN0YW5jZShlLHRoaXMpLHI8aSYmKGk9cikscy9pfWdldENsYXNzKCl7cmV0dXJuIHBvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1wby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9wPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3A9bmV3IGcodCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fcD1uZXcgZyh0LGUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuX3A9bmV3IGcodCxlLG4pfX0scG8uTEVGVD0wLHBvLlJJR0hUPTEscG8uQkVZT05EPTIscG8uQkVISU5EPTMscG8uQkVUV0VFTj00LHBvLk9SSUdJTj01LHBvLkRFU1RJTkFUSU9OPTY7Y2xhc3MgbW8gZXh0ZW5kcyBwb3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksbW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRDb25zdHJhaW50KCl7cmV0dXJuIHRoaXMuX2NvbnN0cmFpbnR9c2V0T25Db25zdHJhaW50KHQpe3RoaXMuX2lzT25Db25zdHJhaW50PXR9bWVyZ2UodCl7dC5faXNPbkNvbnN0cmFpbnQmJih0aGlzLl9pc09uQ29uc3RyYWludD0hMCx0aGlzLl9jb25zdHJhaW50PXQuX2NvbnN0cmFpbnQpfWlzT25Db25zdHJhaW50KCl7cmV0dXJuIHRoaXMuX2lzT25Db25zdHJhaW50fXNldENvbnN0cmFpbnQodCl7dGhpcy5faXNPbkNvbnN0cmFpbnQ9ITAsdGhpcy5fY29uc3RyYWludD10fWdldENsYXNzKCl7cmV0dXJuIG1vfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1tby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pc09uQ29uc3RyYWludD1udWxsLHRoaXMuX2NvbnN0cmFpbnQ9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTtwby5jb25zdHJ1Y3Rvcl8uY2FsbCh0aGlzLHQpfTtjbGFzcyB5b3tjb25zdHJ1Y3Rvcigpe3lvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIG1ha2VFZGdlKHQsZSl7Y29uc3Qgbj1uZXcgeW8scz1uZXcgeW8saT1uZXcgeW8scj1uZXcgeW87bi5fcm90PXMscy5fcm90PWksaS5fcm90PXIsci5fcm90PW4sbi5zZXROZXh0KG4pLHMuc2V0TmV4dChyKSxpLnNldE5leHQoaSksci5zZXROZXh0KHMpO2NvbnN0IG89bjtyZXR1cm4gby5zZXRPcmlnKHQpLG8uc2V0RGVzdChlKSxvfXN0YXRpYyBzd2FwKHQpe2NvbnN0IGU9dC5vUHJldigpLG49dC5zeW0oKS5vUHJldigpO3lvLnNwbGljZSh0LGUpLHlvLnNwbGljZSh0LnN5bSgpLG4pLHlvLnNwbGljZSh0LGUubE5leHQoKSkseW8uc3BsaWNlKHQuc3ltKCksbi5sTmV4dCgpKSx0LnNldE9yaWcoZS5kZXN0KCkpLHQuc2V0RGVzdChuLmRlc3QoKSl9c3RhdGljIHNwbGljZSh0LGUpe2NvbnN0IG49dC5vTmV4dCgpLnJvdCgpLHM9ZS5vTmV4dCgpLnJvdCgpLGk9ZS5vTmV4dCgpLHI9dC5vTmV4dCgpLG89cy5vTmV4dCgpLGw9bi5vTmV4dCgpO3Quc2V0TmV4dChpKSxlLnNldE5leHQociksbi5zZXROZXh0KG8pLHMuc2V0TmV4dChsKX1zdGF0aWMgY29ubmVjdCh0LGUpe2NvbnN0IG49eW8ubWFrZUVkZ2UodC5kZXN0KCksZS5vcmlnKCkpO3JldHVybiB5by5zcGxpY2Uobix0LmxOZXh0KCkpLHlvLnNwbGljZShuLnN5bSgpLGUpLG59ZXF1YWxzTm9uT3JpZW50ZWQodCl7cmV0dXJuISF0aGlzLmVxdWFsc09yaWVudGVkKHQpfHwhIXRoaXMuZXF1YWxzT3JpZW50ZWQodC5zeW0oKSl9dG9MaW5lU2VnbWVudCgpe3JldHVybiBuZXcgZWUodGhpcy5fdmVydGV4LmdldENvb3JkaW5hdGUoKSx0aGlzLmRlc3QoKS5nZXRDb29yZGluYXRlKCkpfWRlc3QoKXtyZXR1cm4gdGhpcy5zeW0oKS5vcmlnKCl9b05leHQoKXtyZXR1cm4gdGhpcy5fbmV4dH1lcXVhbHNPcmllbnRlZCh0KXtyZXR1cm4hKCF0aGlzLm9yaWcoKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQodC5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpKXx8IXRoaXMuZGVzdCgpLmdldENvb3JkaW5hdGUoKS5lcXVhbHMyRCh0LmRlc3QoKS5nZXRDb29yZGluYXRlKCkpKX1kTmV4dCgpe3JldHVybiB0aGlzLnN5bSgpLm9OZXh0KCkuc3ltKCl9bFByZXYoKXtyZXR1cm4gdGhpcy5fbmV4dC5zeW0oKX1yUHJldigpe3JldHVybiB0aGlzLnN5bSgpLm9OZXh0KCl9cm90KCl7cmV0dXJuIHRoaXMuX3JvdH1vUHJldigpe3JldHVybiB0aGlzLl9yb3QuX25leHQuX3JvdH1zeW0oKXtyZXR1cm4gdGhpcy5fcm90Ll9yb3R9c2V0T3JpZyh0KXt0aGlzLl92ZXJ0ZXg9dH1sTmV4dCgpe3JldHVybiB0aGlzLmludlJvdCgpLm9OZXh0KCkucm90KCl9Z2V0TGVuZ3RoKCl7cmV0dXJuIHRoaXMub3JpZygpLmdldENvb3JkaW5hdGUoKS5kaXN0YW5jZSh0aGlzLmRlc3QoKS5nZXRDb29yZGluYXRlKCkpfWludlJvdCgpe3JldHVybiB0aGlzLl9yb3Quc3ltKCl9c2V0RGVzdCh0KXt0aGlzLnN5bSgpLnNldE9yaWcodCl9c2V0RGF0YSh0KXt0aGlzLl9kYXRhPXR9Z2V0RGF0YSgpe3JldHVybiB0aGlzLl9kYXRhfWRlbGV0ZSgpe3RoaXMuX3JvdD1udWxsfW9yaWcoKXtyZXR1cm4gdGhpcy5fdmVydGV4fXJOZXh0KCl7cmV0dXJuIHRoaXMuX3JvdC5fbmV4dC5pbnZSb3QoKX10b1N0cmluZygpe2NvbnN0IHQ9dGhpcy5fdmVydGV4LmdldENvb3JkaW5hdGUoKSxlPXRoaXMuZGVzdCgpLmdldENvb3JkaW5hdGUoKTtyZXR1cm4gSnQudG9MaW5lU3RyaW5nKHQsZSl9aXNMaXZlKCl7cmV0dXJuIG51bGwhPT10aGlzLl9yb3R9Z2V0UHJpbWFyeSgpe3JldHVybiB0aGlzLm9yaWcoKS5nZXRDb29yZGluYXRlKCkuY29tcGFyZVRvKHRoaXMuZGVzdCgpLmdldENvb3JkaW5hdGUoKSk8PTA/dGhpczp0aGlzLnN5bSgpfWRQcmV2KCl7cmV0dXJuIHRoaXMuaW52Um90KCkub05leHQoKS5pbnZSb3QoKX1zZXROZXh0KHQpe3RoaXMuX25leHQ9dH1nZXRDbGFzcygpe3JldHVybiB5b31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19eW8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fcm90PW51bGwsdGhpcy5fdmVydGV4PW51bGwsdGhpcy5fbmV4dD1udWxsLHRoaXMuX2RhdGE9bnVsbH07Y2xhc3MgeG97Y29uc3RydWN0b3IoKXt4by5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWluc2VydFNpdGUodCl7bGV0IGU9dGhpcy5fc3ViZGl2LmxvY2F0ZSh0KTtpZih0aGlzLl9zdWJkaXYuaXNWZXJ0ZXhPZkVkZ2UoZSx0KSlyZXR1cm4gZTt0aGlzLl9zdWJkaXYuaXNPbkVkZ2UoZSx0LmdldENvb3JkaW5hdGUoKSkmJihlPWUub1ByZXYoKSx0aGlzLl9zdWJkaXYuZGVsZXRlKGUub05leHQoKSkpO2xldCBuPXRoaXMuX3N1YmRpdi5tYWtlRWRnZShlLm9yaWcoKSx0KTt5by5zcGxpY2UobixlKTtjb25zdCBzPW47ZG97bj10aGlzLl9zdWJkaXYuY29ubmVjdChlLG4uc3ltKCkpLGU9bi5vUHJldigpfXdoaWxlKGUubE5leHQoKSE9PXMpO2Zvcig7Oyl7Y29uc3QgaT1lLm9QcmV2KCk7aWYoaS5kZXN0KCkucmlnaHRPZihlKSYmdC5pc0luQ2lyY2xlKGUub3JpZygpLGkuZGVzdCgpLGUuZGVzdCgpKSl5by5zd2FwKGUpLGU9ZS5vUHJldigpO2Vsc2V7aWYoZS5vTmV4dCgpPT09cylyZXR1cm4gbjtlPWUub05leHQoKS5sUHJldigpfX19aW5zZXJ0U2l0ZXModCl7Zm9yKGxldCBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe2NvbnN0IHQ9ZS5uZXh0KCk7dGhpcy5pbnNlcnRTaXRlKHQpfX1nZXRDbGFzcygpe3JldHVybiB4b31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19eG8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fc3ViZGl2PW51bGwsdGhpcy5faXNVc2luZ1RvbGVyYW5jZT0hMTtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zdWJkaXY9dCx0aGlzLl9pc1VzaW5nVG9sZXJhbmNlPXQuZ2V0VG9sZXJhbmNlKCk+MH07Y2xhc3MgRW97Y29uc3RydWN0b3IoKXtFby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWxvY2F0ZSh0KXt9Z2V0Q2xhc3MoKXtyZXR1cm4gRW99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUVvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgSW97Y29uc3RydWN0b3IoKXtJby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWluaXQoKXt0aGlzLl9sYXN0RWRnZT10aGlzLmZpbmRFZGdlKCl9bG9jYXRlKHQpe3RoaXMuX2xhc3RFZGdlLmlzTGl2ZSgpfHx0aGlzLmluaXQoKTtjb25zdCBlPXRoaXMuX3N1YmRpdi5sb2NhdGVGcm9tRWRnZSh0LHRoaXMuX2xhc3RFZGdlKTtyZXR1cm4gdGhpcy5fbGFzdEVkZ2U9ZSxlfWZpbmRFZGdlKCl7cmV0dXJuIHRoaXMuX3N1YmRpdi5nZXRFZGdlcygpLml0ZXJhdG9yKCkubmV4dCgpfWdldENsYXNzKCl7cmV0dXJuIElvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltFb119fUlvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3N1YmRpdj1udWxsLHRoaXMuX2xhc3RFZGdlPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc3ViZGl2PXQsdGhpcy5pbml0KCl9O2NsYXNzIE5vIGV4dGVuZHMgY3tjb25zdHJ1Y3Rvcigpe3N1cGVyKCksTm8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgbXNnV2l0aFNwYXRpYWwodCxlKXtyZXR1cm4gbnVsbCE9PWU/dCtcIiBbIFwiK2UrXCIgXVwiOnR9Z2V0U2VnbWVudCgpe3JldHVybiB0aGlzLl9zZWd9Z2V0Q2xhc3MoKXtyZXR1cm4gTm99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fU5vLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuX3NlZz1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtjb25zdCB0PWFyZ3VtZW50c1swXTtjLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsdCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGVlKXtjb25zdCB0PWFyZ3VtZW50c1swXTtjLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsXCJMb2NhdGUgZmFpbGVkIHRvIGNvbnZlcmdlIChhdCBlZGdlOiBcIit0K1wiKS4gIFBvc3NpYmxlIGNhdXNlcyBpbmNsdWRlIGludmFsaWQgU3ViZGl2aXNpb24gdG9wb2xvZ3kgb3IgdmVyeSBjbG9zZSBzaXRlc1wiKSx0aGlzLl9zZWc9bmV3IGVlKHQpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtjLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsTm8ubXNnV2l0aFNwYXRpYWwodCxlKSksdGhpcy5fc2VnPW5ldyBlZShlKX19O2NsYXNzIENve2NvbnN0cnVjdG9yKCl7Q28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12aXNpdCh0KXt9Z2V0Q2xhc3MoKXtyZXR1cm4gQ299Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fUNvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe307Y2xhc3MgU297Y29uc3RydWN0b3IoKXtTby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBnZXRUcmlhbmdsZUVkZ2VzKHQsZSl7aWYoZVswXT10LGVbMV09ZVswXS5sTmV4dCgpLGVbMl09ZVsxXS5sTmV4dCgpLGVbMl0ubE5leHQoKSE9PWVbMF0pdGhyb3cgbmV3IG4oXCJFZGdlcyBkbyBub3QgZm9ybSBhIHRyaWFuZ2xlXCIpfWdldFRyaWFuZ2xlVmVydGljZXModCl7Y29uc3QgZT1uZXcgVG87cmV0dXJuIHRoaXMudmlzaXRUcmlhbmdsZXMoZSx0KSxlLmdldFRyaWFuZ2xlVmVydGljZXMoKX1pc0ZyYW1lVmVydGV4KHQpe3JldHVybiEhdC5lcXVhbHModGhpcy5fZnJhbWVWZXJ0ZXhbMF0pfHwoISF0LmVxdWFscyh0aGlzLl9mcmFtZVZlcnRleFsxXSl8fCEhdC5lcXVhbHModGhpcy5fZnJhbWVWZXJ0ZXhbMl0pKX1pc1ZlcnRleE9mRWRnZSh0LGUpe3JldHVybiEoIWUuZXF1YWxzKHQub3JpZygpLHRoaXMuX3RvbGVyYW5jZSkmJiFlLmVxdWFscyh0LmRlc3QoKSx0aGlzLl90b2xlcmFuY2UpKX1jb25uZWN0KHQsZSl7Y29uc3Qgbj15by5jb25uZWN0KHQsZSk7cmV0dXJuIHRoaXMuX3F1YWRFZGdlcy5hZGQobiksbn1nZXRWb3Jvbm9pQ2VsbFBvbHlnb24odCxlKXtjb25zdCBuPW5ldyB4LHM9dDtkb3tjb25zdCBlPXQucm90KCkub3JpZygpLmdldENvb3JkaW5hdGUoKTtuLmFkZChlKSx0PXQub1ByZXYoKX13aGlsZSh0IT09cyk7Y29uc3QgaT1uZXcgSTtpLmFkZEFsbChuLCExKSxpLmNsb3NlUmluZygpLGkuc2l6ZSgpPDQmJihPLm91dC5wcmludGxuKGkpLGkuYWRkKGkuZ2V0KGkuc2l6ZSgpLTEpLCEwKSk7Y29uc3Qgcj1pLnRvQ29vcmRpbmF0ZUFycmF5KCksbz1lLmNyZWF0ZVBvbHlnb24oZS5jcmVhdGVMaW5lYXJSaW5nKHIpKSxsPXMub3JpZygpO3JldHVybiBvLnNldFVzZXJEYXRhKGwuZ2V0Q29vcmRpbmF0ZSgpKSxvfXNldExvY2F0b3IodCl7dGhpcy5fbG9jYXRvcj10fWluaXRTdWJkaXYoKXtjb25zdCB0PXRoaXMubWFrZUVkZ2UodGhpcy5fZnJhbWVWZXJ0ZXhbMF0sdGhpcy5fZnJhbWVWZXJ0ZXhbMV0pLGU9dGhpcy5tYWtlRWRnZSh0aGlzLl9mcmFtZVZlcnRleFsxXSx0aGlzLl9mcmFtZVZlcnRleFsyXSk7eW8uc3BsaWNlKHQuc3ltKCksZSk7Y29uc3Qgbj10aGlzLm1ha2VFZGdlKHRoaXMuX2ZyYW1lVmVydGV4WzJdLHRoaXMuX2ZyYW1lVmVydGV4WzBdKTtyZXR1cm4geW8uc3BsaWNlKGUuc3ltKCksbikseW8uc3BsaWNlKG4uc3ltKCksdCksdH1pc0ZyYW1lQm9yZGVyRWRnZSh0KXtjb25zdCBlPW5ldyBBcnJheSgzKS5maWxsKG51bGwpO1NvLmdldFRyaWFuZ2xlRWRnZXModCxlKTtjb25zdCBuPW5ldyBBcnJheSgzKS5maWxsKG51bGwpO1NvLmdldFRyaWFuZ2xlRWRnZXModC5zeW0oKSxuKTtjb25zdCBzPXQubE5leHQoKS5kZXN0KCk7aWYodGhpcy5pc0ZyYW1lVmVydGV4KHMpKXJldHVybiEwO2NvbnN0IGk9dC5zeW0oKS5sTmV4dCgpLmRlc3QoKTtyZXR1cm4hIXRoaXMuaXNGcmFtZVZlcnRleChpKX1tYWtlRWRnZSh0LGUpe2NvbnN0IG49eW8ubWFrZUVkZ2UodCxlKTtyZXR1cm4gdGhpcy5fcXVhZEVkZ2VzLmFkZChuKSxufXZpc2l0VHJpYW5nbGVzKHQsZSl7dGhpcy5fdmlzaXRlZEtleSsrO2NvbnN0IG49bmV3IG9uO24ucHVzaCh0aGlzLl9zdGFydGluZ0VkZ2UpO2NvbnN0IHM9bmV3IEo7Zm9yKDshbi5lbXB0eSgpOyl7Y29uc3QgaT1uLnBvcCgpO2lmKCFzLmNvbnRhaW5zKGkpKXtjb25zdCByPXRoaXMuZmV0Y2hUcmlhbmdsZVRvVmlzaXQoaSxuLGUscyk7bnVsbCE9PXImJnQudmlzaXQocil9fX1pc0ZyYW1lRWRnZSh0KXtyZXR1cm4hKCF0aGlzLmlzRnJhbWVWZXJ0ZXgodC5vcmlnKCkpJiYhdGhpcy5pc0ZyYW1lVmVydGV4KHQuZGVzdCgpKSl9aXNPbkVkZ2UodCxlKXtyZXR1cm4gdGhpcy5fc2VnLnNldENvb3JkaW5hdGVzKHQub3JpZygpLmdldENvb3JkaW5hdGUoKSx0LmRlc3QoKS5nZXRDb29yZGluYXRlKCkpLHRoaXMuX3NlZy5kaXN0YW5jZShlKTx0aGlzLl9lZGdlQ29pbmNpZGVuY2VUb2xlcmFuY2V9Z2V0RW52ZWxvcGUoKXtyZXR1cm4gbmV3IE4odGhpcy5fZnJhbWVFbnYpfWNyZWF0ZUZyYW1lKHQpe2NvbnN0IGU9dC5nZXRXaWR0aCgpLG49dC5nZXRIZWlnaHQoKTtsZXQgcz0wO3M9ZT5uPzEwKmU6MTAqbix0aGlzLl9mcmFtZVZlcnRleFswXT1uZXcgcG8oKHQuZ2V0TWF4WCgpK3QuZ2V0TWluWCgpKS8yLHQuZ2V0TWF4WSgpK3MpLHRoaXMuX2ZyYW1lVmVydGV4WzFdPW5ldyBwbyh0LmdldE1pblgoKS1zLHQuZ2V0TWluWSgpLXMpLHRoaXMuX2ZyYW1lVmVydGV4WzJdPW5ldyBwbyh0LmdldE1heFgoKStzLHQuZ2V0TWluWSgpLXMpLHRoaXMuX2ZyYW1lRW52PW5ldyBOKHRoaXMuX2ZyYW1lVmVydGV4WzBdLmdldENvb3JkaW5hdGUoKSx0aGlzLl9mcmFtZVZlcnRleFsxXS5nZXRDb29yZGluYXRlKCkpLHRoaXMuX2ZyYW1lRW52LmV4cGFuZFRvSW5jbHVkZSh0aGlzLl9mcmFtZVZlcnRleFsyXS5nZXRDb29yZGluYXRlKCkpfWdldFRyaWFuZ2xlQ29vcmRpbmF0ZXModCl7Y29uc3QgZT1uZXcgUm87cmV0dXJuIHRoaXMudmlzaXRUcmlhbmdsZXMoZSx0KSxlLmdldFRyaWFuZ2xlcygpfWdldFZlcnRpY2VzKHQpe2NvbnN0IGU9bmV3IEo7Zm9yKGxldCBuPXRoaXMuX3F1YWRFZGdlcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3Qgcz1uLm5leHQoKSxpPXMub3JpZygpOyF0JiZ0aGlzLmlzRnJhbWVWZXJ0ZXgoaSl8fGUuYWRkKGkpO2NvbnN0IHI9cy5kZXN0KCk7IXQmJnRoaXMuaXNGcmFtZVZlcnRleChyKXx8ZS5hZGQocil9cmV0dXJuIGV9ZmV0Y2hUcmlhbmdsZVRvVmlzaXQodCxlLG4scyl7bGV0IGk9dCxyPTAsbz0hMTtkb3t0aGlzLl90cmlFZGdlc1tyXT1pLHRoaXMuaXNGcmFtZUVkZ2UoaSkmJihvPSEwKTtjb25zdCB0PWkuc3ltKCk7cy5jb250YWlucyh0KXx8ZS5wdXNoKHQpLHMuYWRkKGkpLHIrKyxpPWkubE5leHQoKX13aGlsZShpIT09dCk7cmV0dXJuIG8mJiFuP251bGw6dGhpcy5fdHJpRWRnZXN9Z2V0RWRnZXMoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5fcXVhZEVkZ2VzO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXRoaXMuZ2V0UHJpbWFyeUVkZ2VzKCExKSxuPW5ldyBBcnJheShlLnNpemUoKSkuZmlsbChudWxsKTtsZXQgcz0wO2ZvcihsZXQgaT1lLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXtjb25zdCBlPWkubmV4dCgpO25bcysrXT10LmNyZWF0ZUxpbmVTdHJpbmcoW2Uub3JpZygpLmdldENvb3JkaW5hdGUoKSxlLmRlc3QoKS5nZXRDb29yZGluYXRlKCldKX1yZXR1cm4gdC5jcmVhdGVNdWx0aUxpbmVTdHJpbmcobil9fWdldFZlcnRleFVuaXF1ZUVkZ2VzKHQpe2NvbnN0IGU9bmV3IHgsbj1uZXcgSjtmb3IobGV0IHM9dGhpcy5fcXVhZEVkZ2VzLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXtjb25zdCBpPXMubmV4dCgpLHI9aS5vcmlnKCk7bi5jb250YWlucyhyKXx8KG4uYWRkKHIpLCF0JiZ0aGlzLmlzRnJhbWVWZXJ0ZXgocil8fGUuYWRkKGkpKTtjb25zdCBvPWkuc3ltKCksbD1vLm9yaWcoKTtuLmNvbnRhaW5zKGwpfHwobi5hZGQobCksIXQmJnRoaXMuaXNGcmFtZVZlcnRleChsKXx8ZS5hZGQobykpfXJldHVybiBlfWdldFRyaWFuZ2xlRWRnZXModCl7Y29uc3QgZT1uZXcgTG87cmV0dXJuIHRoaXMudmlzaXRUcmlhbmdsZXMoZSx0KSxlLmdldFRyaWFuZ2xlRWRnZXMoKX1nZXRQcmltYXJ5RWRnZXModCl7dGhpcy5fdmlzaXRlZEtleSsrO2NvbnN0IGU9bmV3IHgsbj1uZXcgb247bi5wdXNoKHRoaXMuX3N0YXJ0aW5nRWRnZSk7Y29uc3Qgcz1uZXcgSjtmb3IoOyFuLmVtcHR5KCk7KXtjb25zdCBpPW4ucG9wKCk7aWYoIXMuY29udGFpbnMoaSkpe2NvbnN0IHI9aS5nZXRQcmltYXJ5KCk7IXQmJnRoaXMuaXNGcmFtZUVkZ2Uocil8fGUuYWRkKHIpLG4ucHVzaChpLm9OZXh0KCkpLG4ucHVzaChpLnN5bSgpLm9OZXh0KCkpLHMuYWRkKGkpLHMuYWRkKGkuc3ltKCkpfX1yZXR1cm4gZX1kZWxldGUodCl7eW8uc3BsaWNlKHQsdC5vUHJldigpKSx5by5zcGxpY2UodC5zeW0oKSx0LnN5bSgpLm9QcmV2KCkpO2NvbnN0IGU9dC5zeW0oKSxuPXQucm90KCkscz10LnJvdCgpLnN5bSgpO3RoaXMuX3F1YWRFZGdlcy5yZW1vdmUodCksdGhpcy5fcXVhZEVkZ2VzLnJlbW92ZShlKSx0aGlzLl9xdWFkRWRnZXMucmVtb3ZlKG4pLHRoaXMuX3F1YWRFZGdlcy5yZW1vdmUocyksdC5kZWxldGUoKSxlLmRlbGV0ZSgpLG4uZGVsZXRlKCkscy5kZWxldGUoKX1sb2NhdGVGcm9tRWRnZSh0LGUpe2xldCBuPTA7Y29uc3Qgcz10aGlzLl9xdWFkRWRnZXMuc2l6ZSgpO2xldCBpPWU7Zm9yKDs7KXtpZihuKyssbj5zKXRocm93IG5ldyBObyhpLnRvTGluZVNlZ21lbnQoKSk7aWYodC5lcXVhbHMoaS5vcmlnKCkpfHx0LmVxdWFscyhpLmRlc3QoKSkpYnJlYWs7aWYodC5yaWdodE9mKGkpKWk9aS5zeW0oKTtlbHNlIGlmKHQucmlnaHRPZihpLm9OZXh0KCkpKXtpZih0LnJpZ2h0T2YoaS5kUHJldigpKSlicmVhaztpPWkuZFByZXYoKX1lbHNlIGk9aS5vTmV4dCgpfXJldHVybiBpfWdldFRvbGVyYW5jZSgpe3JldHVybiB0aGlzLl90b2xlcmFuY2V9Z2V0Vm9yb25vaUNlbGxQb2x5Z29ucyh0KXt0aGlzLnZpc2l0VHJpYW5nbGVzKG5ldyB3bywhMCk7Y29uc3QgZT1uZXcgeDtmb3IobGV0IG49dGhpcy5nZXRWZXJ0ZXhVbmlxdWVFZGdlcyghMSkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7ZS5hZGQodGhpcy5nZXRWb3Jvbm9pQ2VsbFBvbHlnb24ocyx0KSl9cmV0dXJuIGV9Z2V0Vm9yb25vaURpYWdyYW0odCl7Y29uc3QgZT10aGlzLmdldFZvcm9ub2lDZWxsUG9seWdvbnModCk7cmV0dXJuIHQuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKEh0LnRvR2VvbWV0cnlBcnJheShlKSl9Z2V0VHJpYW5nbGVzKHQpe2NvbnN0IGU9dGhpcy5nZXRUcmlhbmdsZUNvb3JkaW5hdGVzKCExKSxuPW5ldyBBcnJheShlLnNpemUoKSkuZmlsbChudWxsKTtsZXQgcz0wO2ZvcihsZXQgaT1lLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXtjb25zdCBlPWkubmV4dCgpO25bcysrXT10LmNyZWF0ZVBvbHlnb24odC5jcmVhdGVMaW5lYXJSaW5nKGUpKX1yZXR1cm4gdC5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obil9aW5zZXJ0U2l0ZSh0KXtsZXQgZT10aGlzLmxvY2F0ZSh0KTtpZih0LmVxdWFscyhlLm9yaWcoKSx0aGlzLl90b2xlcmFuY2UpfHx0LmVxdWFscyhlLmRlc3QoKSx0aGlzLl90b2xlcmFuY2UpKXJldHVybiBlO2xldCBuPXRoaXMubWFrZUVkZ2UoZS5vcmlnKCksdCk7eW8uc3BsaWNlKG4sZSk7Y29uc3Qgcz1uO2Rve249dGhpcy5jb25uZWN0KGUsbi5zeW0oKSksZT1uLm9QcmV2KCl9d2hpbGUoZS5sTmV4dCgpIT09cyk7cmV0dXJuIHN9bG9jYXRlKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcG8pe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9sb2NhdG9yLmxvY2F0ZSh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLl9sb2NhdG9yLmxvY2F0ZShuZXcgcG8odCkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXRoaXMuX2xvY2F0b3IubG9jYXRlKG5ldyBwbyh0KSk7aWYobnVsbD09PW4pcmV0dXJuIG51bGw7bGV0IHM9bjtuLmRlc3QoKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQodCkmJihzPW4uc3ltKCkpO2xldCBpPXM7ZG97aWYoaS5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKGUpKXJldHVybiBpO2k9aS5vTmV4dCgpfXdoaWxlKGkhPT1zKTtyZXR1cm4gbnVsbH19Z2V0Q2xhc3MoKXtyZXR1cm4gU299Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWNsYXNzIHdve2NvbnN0cnVjdG9yKCl7d28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12aXNpdCh0KXtjb25zdCBlPXRbMF0ub3JpZygpLmdldENvb3JkaW5hdGUoKSxuPXRbMV0ub3JpZygpLmdldENvb3JkaW5hdGUoKSxzPXRbMl0ub3JpZygpLmdldENvb3JkaW5hdGUoKSxpPXJlLmNpcmN1bWNlbnRyZShlLG4scykscj1uZXcgcG8oaSk7Zm9yKGxldCBlPTA7ZTwzO2UrKyl0W2VdLnJvdCgpLnNldE9yaWcocil9Z2V0Q2xhc3MoKXtyZXR1cm4gd299Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0NvXX19d28uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBMb3tjb25zdHJ1Y3Rvcigpe0xvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Z2V0VHJpYW5nbGVFZGdlcygpe3JldHVybiB0aGlzLl90cmlMaXN0fXZpc2l0KHQpe3RoaXMuX3RyaUxpc3QuYWRkKHQpfWdldENsYXNzKCl7cmV0dXJuIExvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltDb119fUxvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3RyaUxpc3Q9bmV3IHh9O2NsYXNzIFRve2NvbnN0cnVjdG9yKCl7VG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12aXNpdCh0KXt0aGlzLl90cmlMaXN0LmFkZChbdFswXS5vcmlnKCksdFsxXS5vcmlnKCksdFsyXS5vcmlnKCldKX1nZXRUcmlhbmdsZVZlcnRpY2VzKCl7cmV0dXJuIHRoaXMuX3RyaUxpc3R9Z2V0Q2xhc3MoKXtyZXR1cm4gVG99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW0NvXX19VG8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fdHJpTGlzdD1uZXcgeH07Y2xhc3MgUm97Y29uc3RydWN0b3IoKXtSby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNoZWNrVHJpYW5nbGVTaXplKHQpe2xldCBlPVwiXCI7dC5sZW5ndGg+PTI/ZT1KdC50b0xpbmVTdHJpbmcodFswXSx0WzFdKTp0Lmxlbmd0aD49MSYmKGU9SnQudG9Qb2ludCh0WzBdKSl9dmlzaXQodCl7dGhpcy5fY29vcmRMaXN0LmNsZWFyKCk7Zm9yKGxldCBlPTA7ZTwzO2UrKyl7Y29uc3Qgbj10W2VdLm9yaWcoKTt0aGlzLl9jb29yZExpc3QuYWRkKG4uZ2V0Q29vcmRpbmF0ZSgpKX1pZih0aGlzLl9jb29yZExpc3Quc2l6ZSgpPjApe3RoaXMuX2Nvb3JkTGlzdC5jbG9zZVJpbmcoKTtjb25zdCB0PXRoaXMuX2Nvb3JkTGlzdC50b0Nvb3JkaW5hdGVBcnJheSgpO2lmKDQhPT10Lmxlbmd0aClyZXR1cm4gbnVsbDt0aGlzLl90cmlDb29yZHMuYWRkKHQpfX1nZXRUcmlhbmdsZXMoKXtyZXR1cm4gdGhpcy5fdHJpQ29vcmRzfWdldENsYXNzKCl7cmV0dXJuIFJvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltDb119fVJvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2Nvb3JkTGlzdD1uZXcgSSx0aGlzLl90cmlDb29yZHM9bmV3IHh9LFNvLlRyaWFuZ2xlQ2lyY3VtY2VudHJlVmlzaXRvcj13byxTby5UcmlhbmdsZUVkZ2VzTGlzdFZpc2l0b3I9TG8sU28uVHJpYW5nbGVWZXJ0ZXhMaXN0VmlzaXRvcj1UbyxTby5UcmlhbmdsZUNvb3JkaW5hdGVzVmlzaXRvcj1SbyxTby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl92aXNpdGVkS2V5PTAsdGhpcy5fcXVhZEVkZ2VzPW5ldyB4LHRoaXMuX3N0YXJ0aW5nRWRnZT1udWxsLHRoaXMuX3RvbGVyYW5jZT1udWxsLHRoaXMuX2VkZ2VDb2luY2lkZW5jZVRvbGVyYW5jZT1udWxsLHRoaXMuX2ZyYW1lVmVydGV4PW5ldyBBcnJheSgzKS5maWxsKG51bGwpLHRoaXMuX2ZyYW1lRW52PW51bGwsdGhpcy5fbG9jYXRvcj1udWxsLHRoaXMuX3NlZz1uZXcgZWUsdGhpcy5fdHJpRWRnZXM9bmV3IEFycmF5KDMpLmZpbGwobnVsbCk7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fdG9sZXJhbmNlPWUsdGhpcy5fZWRnZUNvaW5jaWRlbmNlVG9sZXJhbmNlPWUvU28uRURHRV9DT0lOQ0lERU5DRV9UT0xfRkFDVE9SLHRoaXMuY3JlYXRlRnJhbWUodCksdGhpcy5fc3RhcnRpbmdFZGdlPXRoaXMuaW5pdFN1YmRpdigpLHRoaXMuX2xvY2F0b3I9bmV3IElvKHRoaXMpfSxTby5FREdFX0NPSU5DSURFTkNFX1RPTF9GQUNUT1I9MWUzO2NsYXNzIFBve2NvbnN0cnVjdG9yKCl7UG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1nZXRMaW5lU2VnbWVudCgpe3JldHVybiB0aGlzLl9sc31nZXRFbmRaKCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMSkuen1nZXRTdGFydFooKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgwKS56fWludGVyc2VjdGlvbih0KXtyZXR1cm4gdGhpcy5fbHMuaW50ZXJzZWN0aW9uKHQuZ2V0TGluZVNlZ21lbnQoKSl9Z2V0U3RhcnQoKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgwKX1nZXRFbmQoKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgxKX1nZXRFbmRZKCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMSkueX1nZXRTdGFydFgoKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgwKS54fWVxdWFsc1RvcG8odCl7cmV0dXJuIHRoaXMuX2xzLmVxdWFsc1RvcG8odC5nZXRMaW5lU2VnbWVudCgpKX1nZXRTdGFydFkoKXtyZXR1cm4gdGhpcy5fbHMuZ2V0Q29vcmRpbmF0ZSgwKS55fXNldERhdGEodCl7dGhpcy5fZGF0YT10fWdldERhdGEoKXtyZXR1cm4gdGhpcy5fZGF0YX1nZXRFbmRYKCl7cmV0dXJuIHRoaXMuX2xzLmdldENvb3JkaW5hdGUoMSkueH10b1N0cmluZygpe3JldHVybiB0aGlzLl9scy50b1N0cmluZygpfWdldENsYXNzKCl7cmV0dXJuIFBvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Qby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9scz1udWxsLHRoaXMuX2RhdGE9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fbHM9bmV3IGVlKHQsZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fbHM9bmV3IGVlKHQsZSksdGhpcy5fZGF0YT1ufWVsc2UgaWYoNj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdLGk9YXJndW1lbnRzWzRdLHI9YXJndW1lbnRzWzVdO1BvLmNvbnN0cnVjdG9yXy5jYWxsKHRoaXMsbmV3IGcodCxlLG4pLG5ldyBnKHMsaSxyKSl9ZWxzZSBpZig3PT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM10saT1hcmd1bWVudHNbNF0scj1hcmd1bWVudHNbNV0sbz1hcmd1bWVudHNbNl07UG8uY29uc3RydWN0b3JfLmNhbGwodGhpcyxuZXcgZyh0LGUsbiksbmV3IGcocyxpLHIpLG8pfX07Y2xhc3Mgdm97Y29uc3RydWN0b3IoKXt2by5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjb21wdXRlVmVydGV4RW52ZWxvcGUodCl7Y29uc3QgZT1uZXcgTjtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtlLmV4cGFuZFRvSW5jbHVkZSh0LmdldENvb3JkaW5hdGUoKSl9cmV0dXJuIGV9Z2V0SW5pdGlhbFZlcnRpY2VzKCl7cmV0dXJuIHRoaXMuX2luaXRpYWxWZXJ0aWNlc31nZXRLRFQoKXtyZXR1cm4gdGhpcy5fa2R0fWVuZm9yY2VDb25zdHJhaW50cygpe3RoaXMuYWRkQ29uc3RyYWludFZlcnRpY2VzKCk7bGV0IHQ9MCxlPTA7ZG97ZT10aGlzLmVuZm9yY2VHYWJyaWVsKHRoaXMuX3NlZ21lbnRzKSx0Kyt9d2hpbGUoZT4wJiZ0PHZvLk1BWF9TUExJVF9JVEVSKX1pbnNlcnRTaXRlcyh0KXtmb3IobGV0IGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7Y29uc3QgdD1lLm5leHQoKTt0aGlzLmluc2VydFNpdGUodCl9fWdldFZlcnRleEZhY3RvcnkoKXtyZXR1cm4gdGhpcy5fdmVydGV4RmFjdG9yeX1nZXRQb2ludEFycmF5KCl7Y29uc3QgdD1uZXcgQXJyYXkodGhpcy5faW5pdGlhbFZlcnRpY2VzLnNpemUoKSt0aGlzLl9zZWdWZXJ0aWNlcy5zaXplKCkpLmZpbGwobnVsbCk7bGV0IGU9MDtmb3IobGV0IG49dGhpcy5faW5pdGlhbFZlcnRpY2VzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCBzPW4ubmV4dCgpO3RbZSsrXT1zLmdldENvb3JkaW5hdGUoKX1mb3IobGV0IG49dGhpcy5fc2VnVmVydGljZXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHM9bi5uZXh0KCk7dFtlKytdPXMuZ2V0Q29vcmRpbmF0ZSgpfXJldHVybiB0fXNldENvbnN0cmFpbnRzKHQsZSl7dGhpcy5fc2VnbWVudHM9dCx0aGlzLl9zZWdWZXJ0aWNlcz1lfWNvbXB1dGVDb252ZXhIdWxsKCl7Y29uc3QgdD1uZXcgSHQsZT10aGlzLmdldFBvaW50QXJyYXkoKSxuPW5ldyBhbihlLHQpO3RoaXMuX2NvbnZleEh1bGw9bi5nZXRDb252ZXhIdWxsKCl9YWRkQ29uc3RyYWludFZlcnRpY2VzKCl7dGhpcy5jb21wdXRlQ29udmV4SHVsbCgpLHRoaXMuaW5zZXJ0U2l0ZXModGhpcy5fc2VnVmVydGljZXMpfWZpbmROb25HYWJyaWVsUG9pbnQodCl7Y29uc3QgZT10LmdldFN0YXJ0KCksbj10LmdldEVuZCgpLHM9bmV3IGcoKGUueCtuLngpLzIsKGUueStuLnkpLzIpLHI9ZS5kaXN0YW5jZShzKSxvPW5ldyBOKHMpO28uZXhwYW5kQnkocik7Y29uc3QgbD10aGlzLl9rZHQucXVlcnkobyk7bGV0IGE9bnVsbCxjPWkuTUFYX1ZBTFVFO2ZvcihsZXQgdD1sLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBpPXQubmV4dCgpLmdldENvb3JkaW5hdGUoKTtpZihpLmVxdWFsczJEKGUpfHxpLmVxdWFsczJEKG4pKWNvbnRpbnVlO2NvbnN0IG89cy5kaXN0YW5jZShpKTtpZihvPHIpe2NvbnN0IHQ9bzsobnVsbD09PWF8fHQ8YykmJihhPWksYz10KX19cmV0dXJuIGF9Z2V0Q29uc3RyYWludFNlZ21lbnRzKCl7cmV0dXJuIHRoaXMuX3NlZ21lbnRzfXNldFNwbGl0UG9pbnRGaW5kZXIodCl7dGhpcy5fc3BsaXRGaW5kZXI9dH1nZXRDb252ZXhIdWxsKCl7cmV0dXJuIHRoaXMuX2NvbnZleEh1bGx9Z2V0VG9sZXJhbmNlKCl7cmV0dXJuIHRoaXMuX3RvbGVyYW5jZX1lbmZvcmNlR2FicmllbCh0KXtjb25zdCBlPW5ldyB4O2xldCBuPTA7Y29uc3Qgcz1uZXcgeDtmb3IobGV0IGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7Y29uc3QgdD1pLm5leHQoKSxyPXRoaXMuZmluZE5vbkdhYnJpZWxQb2ludCh0KTtpZihudWxsPT09ciljb250aW51ZTt0aGlzLl9zcGxpdFB0PXRoaXMuX3NwbGl0RmluZGVyLmZpbmRTcGxpdFBvaW50KHQscik7Y29uc3Qgbz10aGlzLmNyZWF0ZVZlcnRleCh0aGlzLl9zcGxpdFB0LHQpO3RoaXMuaW5zZXJ0U2l0ZShvKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQodGhpcy5fc3BsaXRQdCk7Y29uc3QgbD1uZXcgUG8odC5nZXRTdGFydFgoKSx0LmdldFN0YXJ0WSgpLHQuZ2V0U3RhcnRaKCksby5nZXRYKCksby5nZXRZKCksby5nZXRaKCksdC5nZXREYXRhKCkpLGE9bmV3IFBvKG8uZ2V0WCgpLG8uZ2V0WSgpLG8uZ2V0WigpLHQuZ2V0RW5kWCgpLHQuZ2V0RW5kWSgpLHQuZ2V0RW5kWigpLHQuZ2V0RGF0YSgpKTtlLmFkZChsKSxlLmFkZChhKSxzLmFkZCh0KSxuKz0xfXJldHVybiB0LnJlbW92ZUFsbChzKSx0LmFkZEFsbChlKSxufWNyZWF0ZVZlcnRleCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtsZXQgZT1udWxsO3JldHVybiBlPW51bGwhPT10aGlzLl92ZXJ0ZXhGYWN0b3J5P3RoaXMuX3ZlcnRleEZhY3RvcnkuY3JlYXRlVmVydGV4KHQsbnVsbCk6bmV3IG1vKHQpLGV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2xldCBuPW51bGw7cmV0dXJuIG49bnVsbCE9PXRoaXMuX3ZlcnRleEZhY3Rvcnk/dGhpcy5fdmVydGV4RmFjdG9yeS5jcmVhdGVWZXJ0ZXgodCxlKTpuZXcgbW8odCksbi5zZXRPbkNvbnN0cmFpbnQoITApLG59fWdldFN1YmRpdmlzaW9uKCl7cmV0dXJuIHRoaXMuX3N1YmRpdn1jb21wdXRlQm91bmRpbmdCb3goKXtjb25zdCB0PXZvLmNvbXB1dGVWZXJ0ZXhFbnZlbG9wZSh0aGlzLl9pbml0aWFsVmVydGljZXMpLGU9dm8uY29tcHV0ZVZlcnRleEVudmVsb3BlKHRoaXMuX3NlZ1ZlcnRpY2VzKSxuPW5ldyBOKHQpO24uZXhwYW5kVG9JbmNsdWRlKGUpO2NvbnN0IHM9LjIqbi5nZXRXaWR0aCgpLGk9LjIqbi5nZXRIZWlnaHQoKSxyPU1hdGgubWF4KHMsaSk7dGhpcy5fY29tcHV0ZUFyZWFFbnY9bmV3IE4obiksdGhpcy5fY29tcHV0ZUFyZWFFbnYuZXhwYW5kQnkocil9c2V0VmVydGV4RmFjdG9yeSh0KXt0aGlzLl92ZXJ0ZXhGYWN0b3J5PXR9Zm9ybUluaXRpYWxEZWxhdW5heSgpe3RoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCksdGhpcy5fc3ViZGl2PW5ldyBTbyh0aGlzLl9jb21wdXRlQXJlYUVudix0aGlzLl90b2xlcmFuY2UpLHRoaXMuX3N1YmRpdi5zZXRMb2NhdG9yKG5ldyBJbyh0aGlzLl9zdWJkaXYpKSx0aGlzLl9pbmNEZWw9bmV3IHhvKHRoaXMuX3N1YmRpdiksdGhpcy5pbnNlcnRTaXRlcyh0aGlzLl9pbml0aWFsVmVydGljZXMpfWluc2VydFNpdGUoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG1vKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPXRoaXMuX2tkdC5pbnNlcnQodC5nZXRDb29yZGluYXRlKCksdCk7aWYoZS5pc1JlcGVhdGVkKCkpe2NvbnN0IG49ZS5nZXREYXRhKCk7cmV0dXJuIG4ubWVyZ2UodCksbn1yZXR1cm4gdGhpcy5faW5jRGVsLmluc2VydFNpdGUodCksdH1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5zZXJ0U2l0ZSh0aGlzLmNyZWF0ZVZlcnRleCh0KSl9fWdldENsYXNzKCl7cmV0dXJuIHZvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX12by5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9pbml0aWFsVmVydGljZXM9bnVsbCx0aGlzLl9zZWdWZXJ0aWNlcz1udWxsLHRoaXMuX3NlZ21lbnRzPW5ldyB4LHRoaXMuX3N1YmRpdj1udWxsLHRoaXMuX2luY0RlbD1udWxsLHRoaXMuX2NvbnZleEh1bGw9bnVsbCx0aGlzLl9zcGxpdEZpbmRlcj1uZXcgX28sdGhpcy5fa2R0PW51bGwsdGhpcy5fdmVydGV4RmFjdG9yeT1udWxsLHRoaXMuX2NvbXB1dGVBcmVhRW52PW51bGwsdGhpcy5fc3BsaXRQdD1udWxsLHRoaXMuX3RvbGVyYW5jZT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2luaXRpYWxWZXJ0aWNlcz1uZXcgeCh0KSx0aGlzLl90b2xlcmFuY2U9ZSx0aGlzLl9rZHQ9bmV3IGVzKGUpfSx2by5NQVhfU1BMSVRfSVRFUj05OTtjbGFzcyBPb3tjb25zdHJ1Y3Rvcigpe09vLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGV4dHJhY3RVbmlxdWVDb29yZGluYXRlcyh0KXtpZihudWxsPT09dClyZXR1cm4gbmV3IEk7Y29uc3QgZT10LmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIE9vLnVuaXF1ZShlKX1zdGF0aWMgZW52ZWxvcGUodCl7Y29uc3QgZT1uZXcgTjtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7Y29uc3QgdD1uLm5leHQoKTtlLmV4cGFuZFRvSW5jbHVkZSh0KX1yZXR1cm4gZX1zdGF0aWMgdW5pcXVlKHQpe2NvbnN0IGU9WC5jb3B5RGVlcCh0KTtyZXR1cm4gaHQuc29ydChlKSxuZXcgSShlLCExKX1zdGF0aWMgdG9WZXJ0aWNlcyh0KXtjb25zdCBlPW5ldyB4O2ZvcihsZXQgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXtjb25zdCB0PW4ubmV4dCgpO2UuYWRkKG5ldyBwbyh0KSl9cmV0dXJuIGV9Y3JlYXRlKCl7aWYobnVsbCE9PXRoaXMuX3N1YmRpdilyZXR1cm4gbnVsbDtjb25zdCB0PU9vLmVudmVsb3BlKHRoaXMuX3NpdGVDb29yZHMpLGU9T28udG9WZXJ0aWNlcyh0aGlzLl9zaXRlQ29vcmRzKTt0aGlzLl9zdWJkaXY9bmV3IFNvKHQsdGhpcy5fdG9sZXJhbmNlKSxuZXcgeG8odGhpcy5fc3ViZGl2KS5pbnNlcnRTaXRlcyhlKX1zZXRUb2xlcmFuY2UodCl7dGhpcy5fdG9sZXJhbmNlPXR9c2V0U2l0ZXMoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHEpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NpdGVDb29yZHM9T28uZXh0cmFjdFVuaXF1ZUNvb3JkaW5hdGVzKHQpfWVsc2UgaWYoXyhhcmd1bWVudHNbMF0sZikpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3NpdGVDb29yZHM9T28udW5pcXVlKFgudG9Db29yZGluYXRlQXJyYXkodCkpfX1nZXRFZGdlcyh0KXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLl9zdWJkaXYuZ2V0RWRnZXModCl9Z2V0U3ViZGl2aXNpb24oKXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLl9zdWJkaXZ9Z2V0VHJpYW5nbGVzKHQpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuX3N1YmRpdi5nZXRUcmlhbmdsZXModCl9Z2V0Q2xhc3MoKXtyZXR1cm4gT299Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fU9vLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3NpdGVDb29yZHM9bnVsbCx0aGlzLl90b2xlcmFuY2U9MCx0aGlzLl9zdWJkaXY9bnVsbH07Y2xhc3MgYm97Y29uc3RydWN0b3IoKXtiby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBjcmVhdGVDb25zdHJhaW50U2VnbWVudHMoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT14ZS5nZXRMaW5lcyh0KSxuPW5ldyB4O2ZvcihsZXQgdD1lLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXtjb25zdCBlPXQubmV4dCgpO2JvLmNyZWF0ZUNvbnN0cmFpbnRTZWdtZW50cyhlLG4pfXJldHVybiBufWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXQuZ2V0Q29vcmRpbmF0ZXMoKTtmb3IobGV0IHQ9MTt0PG4ubGVuZ3RoO3QrKyllLmFkZChuZXcgUG8oblt0LTFdLG5bdF0pKX19Y3JlYXRlU2l0ZVZlcnRpY2VzKHQpe2NvbnN0IGU9bmV3IHg7Zm9yKGxldCBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe2NvbnN0IHQ9bi5uZXh0KCk7dGhpcy5fY29uc3RyYWludFZlcnRleE1hcC5jb250YWluc0tleSh0KXx8ZS5hZGQobmV3IG1vKHQpKX1yZXR1cm4gZX1jcmVhdGUoKXtpZihudWxsIT09dGhpcy5fc3ViZGl2KXJldHVybiBudWxsO2NvbnN0IHQ9T28uZW52ZWxvcGUodGhpcy5fc2l0ZUNvb3Jkcyk7bGV0IGU9bmV3IHg7bnVsbCE9PXRoaXMuX2NvbnN0cmFpbnRMaW5lcyYmKHQuZXhwYW5kVG9JbmNsdWRlKHRoaXMuX2NvbnN0cmFpbnRMaW5lcy5nZXRFbnZlbG9wZUludGVybmFsKCkpLHRoaXMuY3JlYXRlVmVydGljZXModGhpcy5fY29uc3RyYWludExpbmVzKSxlPWJvLmNyZWF0ZUNvbnN0cmFpbnRTZWdtZW50cyh0aGlzLl9jb25zdHJhaW50TGluZXMpKTtjb25zdCBuPXRoaXMuY3JlYXRlU2l0ZVZlcnRpY2VzKHRoaXMuX3NpdGVDb29yZHMpLHM9bmV3IHZvKG4sdGhpcy5fdG9sZXJhbmNlKTtzLnNldENvbnN0cmFpbnRzKGUsbmV3IHgodGhpcy5fY29uc3RyYWludFZlcnRleE1hcC52YWx1ZXMoKSkpLHMuZm9ybUluaXRpYWxEZWxhdW5heSgpLHMuZW5mb3JjZUNvbnN0cmFpbnRzKCksdGhpcy5fc3ViZGl2PXMuZ2V0U3ViZGl2aXNpb24oKX1zZXRUb2xlcmFuY2UodCl7dGhpcy5fdG9sZXJhbmNlPXR9c2V0Q29uc3RyYWludHModCl7dGhpcy5fY29uc3RyYWludExpbmVzPXR9c2V0U2l0ZXModCl7dGhpcy5fc2l0ZUNvb3Jkcz1Pby5leHRyYWN0VW5pcXVlQ29vcmRpbmF0ZXModCl9Z2V0RWRnZXModCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5fc3ViZGl2LmdldEVkZ2VzKHQpfWdldFN1YmRpdmlzaW9uKCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5fc3ViZGl2fWdldFRyaWFuZ2xlcyh0KXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLl9zdWJkaXYuZ2V0VHJpYW5nbGVzKHQpfWNyZWF0ZVZlcnRpY2VzKHQpe2NvbnN0IGU9dC5nZXRDb29yZGluYXRlcygpO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtjb25zdCBuPW5ldyBtbyhlW3RdKTt0aGlzLl9jb25zdHJhaW50VmVydGV4TWFwLnB1dChlW3RdLG4pfX1nZXRDbGFzcygpe3JldHVybiBib31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Ym8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fc2l0ZUNvb3Jkcz1udWxsLHRoaXMuX2NvbnN0cmFpbnRMaW5lcz1udWxsLHRoaXMuX3RvbGVyYW5jZT0wLHRoaXMuX3N1YmRpdj1udWxsLHRoaXMuX2NvbnN0cmFpbnRWZXJ0ZXhNYXA9bmV3IHJ0fTtjbGFzcyBNb3tjb25zdHJ1Y3Rvcigpe01vLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGNsaXBHZW9tZXRyeUNvbGxlY3Rpb24odCxlKXtjb25zdCBuPXQuZ2V0RmFjdG9yeSgpLnRvR2VvbWV0cnkoZSkscz1uZXcgeDtmb3IobGV0IGk9MDtpPHQuZ2V0TnVtR2VvbWV0cmllcygpO2krKyl7Y29uc3Qgcj10LmdldEdlb21ldHJ5TihpKTtsZXQgbz1udWxsO2UuY29udGFpbnMoci5nZXRFbnZlbG9wZUludGVybmFsKCkpP289cjplLmludGVyc2VjdHMoci5nZXRFbnZlbG9wZUludGVybmFsKCkpJiYobz1uLmludGVyc2VjdGlvbihyKSxvLnNldFVzZXJEYXRhKHIuZ2V0VXNlckRhdGEoKSkpLG51bGw9PT1vfHxvLmlzRW1wdHkoKXx8cy5hZGQobyl9cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihIdC50b0dlb21ldHJ5QXJyYXkocykpfWNyZWF0ZSgpe2lmKG51bGwhPT10aGlzLl9zdWJkaXYpcmV0dXJuIG51bGw7Y29uc3QgdD1Pby5lbnZlbG9wZSh0aGlzLl9zaXRlQ29vcmRzKTt0aGlzLl9kaWFncmFtRW52PXQ7Y29uc3QgZT1NYXRoLm1heCh0aGlzLl9kaWFncmFtRW52LmdldFdpZHRoKCksdGhpcy5fZGlhZ3JhbUVudi5nZXRIZWlnaHQoKSk7dGhpcy5fZGlhZ3JhbUVudi5leHBhbmRCeShlKSxudWxsIT09dGhpcy5fY2xpcEVudiYmdGhpcy5fZGlhZ3JhbUVudi5leHBhbmRUb0luY2x1ZGUodGhpcy5fY2xpcEVudik7Y29uc3Qgbj1Pby50b1ZlcnRpY2VzKHRoaXMuX3NpdGVDb29yZHMpO3RoaXMuX3N1YmRpdj1uZXcgU28odCx0aGlzLl90b2xlcmFuY2UpLG5ldyB4byh0aGlzLl9zdWJkaXYpLmluc2VydFNpdGVzKG4pfWdldERpYWdyYW0odCl7dGhpcy5jcmVhdGUoKTtjb25zdCBlPXRoaXMuX3N1YmRpdi5nZXRWb3Jvbm9pRGlhZ3JhbSh0KTtyZXR1cm4gTW8uY2xpcEdlb21ldHJ5Q29sbGVjdGlvbihlLHRoaXMuX2RpYWdyYW1FbnYpfXNldFRvbGVyYW5jZSh0KXt0aGlzLl90b2xlcmFuY2U9dH1zZXRTaXRlcygpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2l0ZUNvb3Jkcz1Pby5leHRyYWN0VW5pcXVlQ29vcmRpbmF0ZXModCl9ZWxzZSBpZihfKGFyZ3VtZW50c1swXSxmKSl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fc2l0ZUNvb3Jkcz1Pby51bmlxdWUoWC50b0Nvb3JkaW5hdGVBcnJheSh0KSl9fXNldENsaXBFbnZlbG9wZSh0KXt0aGlzLl9jbGlwRW52PXR9Z2V0U3ViZGl2aXNpb24oKXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLl9zdWJkaXZ9Z2V0Q2xhc3MoKXtyZXR1cm4gTW99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fU1vLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX3NpdGVDb29yZHM9bnVsbCx0aGlzLl90b2xlcmFuY2U9MCx0aGlzLl9zdWJkaXY9bnVsbCx0aGlzLl9jbGlwRW52PW51bGwsdGhpcy5fZGlhZ3JhbUVudj1udWxsfTt2YXIgRG89T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsVmVydGV4OnBvfSksQW89T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQ29uZm9ybWluZ0RlbGF1bmF5VHJpYW5ndWxhdGlvbkJ1aWxkZXI6Ym8sRGVsYXVuYXlUcmlhbmd1bGF0aW9uQnVpbGRlcjpPbyxWb3Jvbm9pRGlhZ3JhbUJ1aWxkZXI6TW8scXVhZGVkZ2U6RG99KTtjbGFzcyBGb3tjb25zdHJ1Y3Rvcigpe0ZvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGdldEVuZExvY2F0aW9uKHQpe2NvbnN0IGU9bmV3IEZvO3JldHVybiBlLnNldFRvRW5kKHQpLGV9c3RhdGljIHBvaW50QWxvbmdTZWdtZW50QnlGcmFjdGlvbih0LGUsbil7aWYobjw9MClyZXR1cm4gdDtpZihuPj0xKXJldHVybiBlO2NvbnN0IHM9KGUueC10LngpKm4rdC54LGk9KGUueS10LnkpKm4rdC55LHI9KGUuei10LnopKm4rdC56O3JldHVybiBuZXcgZyhzLGkscil9c3RhdGljIGNvbXBhcmVMb2NhdGlvblZhbHVlcyh0LGUsbixzLGkscil7cmV0dXJuIHQ8cz8tMTp0PnM/MTplPGk/LTE6ZT5pPzE6bjxyPy0xOm4+cj8xOjB9Z2V0U2VnbWVudEluZGV4KCl7cmV0dXJuIHRoaXMuX3NlZ21lbnRJbmRleH1nZXRDb21wb25lbnRJbmRleCgpe3JldHVybiB0aGlzLl9jb21wb25lbnRJbmRleH1pc0VuZHBvaW50KHQpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpLmdldE51bVBvaW50cygpLTE7cmV0dXJuIHRoaXMuX3NlZ21lbnRJbmRleD49ZXx8dGhpcy5fc2VnbWVudEluZGV4PT09ZSYmdGhpcy5fc2VnbWVudEZyYWN0aW9uPj0xfWlzVmFsaWQodCl7aWYodGhpcy5fY29tcG9uZW50SW5kZXg8MHx8dGhpcy5fY29tcG9uZW50SW5kZXg+PXQuZ2V0TnVtR2VvbWV0cmllcygpKXJldHVybiExO2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpO3JldHVybiEodGhpcy5fc2VnbWVudEluZGV4PDB8fHRoaXMuX3NlZ21lbnRJbmRleD5lLmdldE51bVBvaW50cygpKSYmKCh0aGlzLl9zZWdtZW50SW5kZXghPT1lLmdldE51bVBvaW50cygpfHwwPT09dGhpcy5fc2VnbWVudEZyYWN0aW9uKSYmISh0aGlzLl9zZWdtZW50RnJhY3Rpb248MHx8dGhpcy5fc2VnbWVudEZyYWN0aW9uPjEpKX1ub3JtYWxpemUoKXt0aGlzLl9zZWdtZW50RnJhY3Rpb248MCYmKHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0wKSx0aGlzLl9zZWdtZW50RnJhY3Rpb24+MSYmKHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0xKSx0aGlzLl9jb21wb25lbnRJbmRleDwwJiYodGhpcy5fY29tcG9uZW50SW5kZXg9MCx0aGlzLl9zZWdtZW50SW5kZXg9MCx0aGlzLl9zZWdtZW50RnJhY3Rpb249MCksdGhpcy5fc2VnbWVudEluZGV4PDAmJih0aGlzLl9zZWdtZW50SW5kZXg9MCx0aGlzLl9zZWdtZW50RnJhY3Rpb249MCksMT09PXRoaXMuX3NlZ21lbnRGcmFjdGlvbiYmKHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0wLHRoaXMuX3NlZ21lbnRJbmRleCs9MSl9dG9Mb3dlc3QodCl7Y29uc3QgZT10LmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCkuZ2V0TnVtUG9pbnRzKCktMTtyZXR1cm4gdGhpcy5fc2VnbWVudEluZGV4PGU/dGhpczpuZXcgRm8odGhpcy5fY29tcG9uZW50SW5kZXgsZSwxLCExKX1nZXRDb29yZGluYXRlKHQpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpLG49ZS5nZXRDb29yZGluYXRlTih0aGlzLl9zZWdtZW50SW5kZXgpO2lmKHRoaXMuX3NlZ21lbnRJbmRleD49ZS5nZXROdW1Qb2ludHMoKS0xKXJldHVybiBuO2NvbnN0IHM9ZS5nZXRDb29yZGluYXRlTih0aGlzLl9zZWdtZW50SW5kZXgrMSk7cmV0dXJuIEZvLnBvaW50QWxvbmdTZWdtZW50QnlGcmFjdGlvbihuLHMsdGhpcy5fc2VnbWVudEZyYWN0aW9uKX1nZXRTZWdtZW50RnJhY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2VnbWVudEZyYWN0aW9ufWdldFNlZ21lbnQodCl7Y29uc3QgZT10LmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCksbj1lLmdldENvb3JkaW5hdGVOKHRoaXMuX3NlZ21lbnRJbmRleCk7aWYodGhpcy5fc2VnbWVudEluZGV4Pj1lLmdldE51bVBvaW50cygpLTEpe2NvbnN0IHQ9ZS5nZXRDb29yZGluYXRlTihlLmdldE51bVBvaW50cygpLTIpO3JldHVybiBuZXcgZWUodCxuKX1jb25zdCBzPWUuZ2V0Q29vcmRpbmF0ZU4odGhpcy5fc2VnbWVudEluZGV4KzEpO3JldHVybiBuZXcgZWUobixzKX1jbGFtcCh0KXtpZih0aGlzLl9jb21wb25lbnRJbmRleD49dC5nZXROdW1HZW9tZXRyaWVzKCkpcmV0dXJuIHRoaXMuc2V0VG9FbmQodCksbnVsbDtpZih0aGlzLl9zZWdtZW50SW5kZXg+PXQuZ2V0TnVtUG9pbnRzKCkpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpO3RoaXMuX3NlZ21lbnRJbmRleD1lLmdldE51bVBvaW50cygpLTEsdGhpcy5fc2VnbWVudEZyYWN0aW9uPTF9fXNldFRvRW5kKHQpe3RoaXMuX2NvbXBvbmVudEluZGV4PXQuZ2V0TnVtR2VvbWV0cmllcygpLTE7Y29uc3QgZT10LmdldEdlb21ldHJ5Tih0aGlzLl9jb21wb25lbnRJbmRleCk7dGhpcy5fc2VnbWVudEluZGV4PWUuZ2V0TnVtUG9pbnRzKCktMSx0aGlzLl9zZWdtZW50RnJhY3Rpb249MX1jb21wYXJlVG8odCl7Y29uc3QgZT10O3JldHVybiB0aGlzLl9jb21wb25lbnRJbmRleDxlLl9jb21wb25lbnRJbmRleD8tMTp0aGlzLl9jb21wb25lbnRJbmRleD5lLl9jb21wb25lbnRJbmRleD8xOnRoaXMuX3NlZ21lbnRJbmRleDxlLl9zZWdtZW50SW5kZXg/LTE6dGhpcy5fc2VnbWVudEluZGV4PmUuX3NlZ21lbnRJbmRleD8xOnRoaXMuX3NlZ21lbnRGcmFjdGlvbjxlLl9zZWdtZW50RnJhY3Rpb24/LTE6dGhpcy5fc2VnbWVudEZyYWN0aW9uPmUuX3NlZ21lbnRGcmFjdGlvbj8xOjB9Y29weSgpe3JldHVybiBuZXcgRm8odGhpcy5fY29tcG9uZW50SW5kZXgsdGhpcy5fc2VnbWVudEluZGV4LHRoaXMuX3NlZ21lbnRGcmFjdGlvbil9dG9TdHJpbmcoKXtyZXR1cm5cIkxpbmVhckxvY1tcIit0aGlzLl9jb21wb25lbnRJbmRleCtcIiwgXCIrdGhpcy5fc2VnbWVudEluZGV4K1wiLCBcIit0aGlzLl9zZWdtZW50RnJhY3Rpb24rXCJdXCJ9aXNPblNhbWVTZWdtZW50KHQpe3JldHVybiB0aGlzLl9jb21wb25lbnRJbmRleD09PXQuX2NvbXBvbmVudEluZGV4JiYodGhpcy5fc2VnbWVudEluZGV4PT09dC5fc2VnbWVudEluZGV4fHwodC5fc2VnbWVudEluZGV4LXRoaXMuX3NlZ21lbnRJbmRleD09MSYmMD09PXQuX3NlZ21lbnRGcmFjdGlvbnx8dGhpcy5fc2VnbWVudEluZGV4LXQuX3NlZ21lbnRJbmRleD09MSYmMD09PXRoaXMuX3NlZ21lbnRGcmFjdGlvbikpfXNuYXBUb1ZlcnRleCh0LGUpe2lmKHRoaXMuX3NlZ21lbnRGcmFjdGlvbjw9MHx8dGhpcy5fc2VnbWVudEZyYWN0aW9uPj0xKXJldHVybiBudWxsO2NvbnN0IG49dGhpcy5nZXRTZWdtZW50TGVuZ3RoKHQpLHM9dGhpcy5fc2VnbWVudEZyYWN0aW9uKm4saT1uLXM7czw9aSYmczxlP3RoaXMuX3NlZ21lbnRGcmFjdGlvbj0wOmk8PXMmJmk8ZSYmKHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0xKX1jb21wYXJlTG9jYXRpb25WYWx1ZXModCxlLG4pe3JldHVybiB0aGlzLl9jb21wb25lbnRJbmRleDx0Py0xOnRoaXMuX2NvbXBvbmVudEluZGV4PnQ/MTp0aGlzLl9zZWdtZW50SW5kZXg8ZT8tMTp0aGlzLl9zZWdtZW50SW5kZXg+ZT8xOnRoaXMuX3NlZ21lbnRGcmFjdGlvbjxuPy0xOnRoaXMuX3NlZ21lbnRGcmFjdGlvbj5uPzE6MH1nZXRTZWdtZW50TGVuZ3RoKHQpe2NvbnN0IGU9dC5nZXRHZW9tZXRyeU4odGhpcy5fY29tcG9uZW50SW5kZXgpO2xldCBuPXRoaXMuX3NlZ21lbnRJbmRleDt0aGlzLl9zZWdtZW50SW5kZXg+PWUuZ2V0TnVtUG9pbnRzKCktMSYmKG49ZS5nZXROdW1Qb2ludHMoKS0yKTtjb25zdCBzPWUuZ2V0Q29vcmRpbmF0ZU4obiksaT1lLmdldENvb3JkaW5hdGVOKG4rMSk7cmV0dXJuIHMuZGlzdGFuY2UoaSl9aXNWZXJ0ZXgoKXtyZXR1cm4gdGhpcy5fc2VnbWVudEZyYWN0aW9uPD0wfHx0aGlzLl9zZWdtZW50RnJhY3Rpb24+PTF9Z2V0Q2xhc3MoKXtyZXR1cm4gRm99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW3JdfX1Gby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9jb21wb25lbnRJbmRleD0wLHRoaXMuX3NlZ21lbnRJbmRleD0wLHRoaXMuX3NlZ21lbnRGcmFjdGlvbj0wLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9jb21wb25lbnRJbmRleD10Ll9jb21wb25lbnRJbmRleCx0aGlzLl9zZWdtZW50SW5kZXg9dC5fc2VnbWVudEluZGV4LHRoaXMuX3NlZ21lbnRGcmFjdGlvbj10Ll9zZWdtZW50RnJhY3Rpb259ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Rm8uY29uc3RydWN0b3JfLmNhbGwodGhpcywwLHQsZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5fY29tcG9uZW50SW5kZXg9dCx0aGlzLl9zZWdtZW50SW5kZXg9ZSx0aGlzLl9zZWdtZW50RnJhY3Rpb249bix0aGlzLm5vcm1hbGl6ZSgpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO3RoaXMuX2NvbXBvbmVudEluZGV4PXQsdGhpcy5fc2VnbWVudEluZGV4PWUsdGhpcy5fc2VnbWVudEZyYWN0aW9uPW4scyYmdGhpcy5ub3JtYWxpemUoKX19O2NsYXNzIEdve2NvbnN0cnVjdG9yKCl7R28uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgc2VnbWVudEVuZFZlcnRleEluZGV4KHQpe3JldHVybiB0LmdldFNlZ21lbnRGcmFjdGlvbigpPjA/dC5nZXRTZWdtZW50SW5kZXgoKSsxOnQuZ2V0U2VnbWVudEluZGV4KCl9Z2V0Q29tcG9uZW50SW5kZXgoKXtyZXR1cm4gdGhpcy5fY29tcG9uZW50SW5kZXh9Z2V0TGluZSgpe3JldHVybiB0aGlzLl9jdXJyZW50TGluZX1nZXRWZXJ0ZXhJbmRleCgpe3JldHVybiB0aGlzLl92ZXJ0ZXhJbmRleH1nZXRTZWdtZW50RW5kKCl7cmV0dXJuIHRoaXMuX3ZlcnRleEluZGV4PHRoaXMuZ2V0TGluZSgpLmdldE51bVBvaW50cygpLTE/dGhpcy5fY3VycmVudExpbmUuZ2V0Q29vcmRpbmF0ZU4odGhpcy5fdmVydGV4SW5kZXgrMSk6bnVsbH1uZXh0KCl7aWYoIXRoaXMuaGFzTmV4dCgpKXJldHVybiBudWxsO3RoaXMuX3ZlcnRleEluZGV4KyssdGhpcy5fdmVydGV4SW5kZXg+PXRoaXMuX2N1cnJlbnRMaW5lLmdldE51bVBvaW50cygpJiYodGhpcy5fY29tcG9uZW50SW5kZXgrKyx0aGlzLmxvYWRDdXJyZW50TGluZSgpLHRoaXMuX3ZlcnRleEluZGV4PTApfWxvYWRDdXJyZW50TGluZSgpe2lmKHRoaXMuX2NvbXBvbmVudEluZGV4Pj10aGlzLl9udW1MaW5lcylyZXR1cm4gdGhpcy5fY3VycmVudExpbmU9bnVsbCxudWxsO3RoaXMuX2N1cnJlbnRMaW5lPXRoaXMuX2xpbmVhckdlb20uZ2V0R2VvbWV0cnlOKHRoaXMuX2NvbXBvbmVudEluZGV4KX1nZXRTZWdtZW50U3RhcnQoKXtyZXR1cm4gdGhpcy5fY3VycmVudExpbmUuZ2V0Q29vcmRpbmF0ZU4odGhpcy5fdmVydGV4SW5kZXgpfWlzRW5kT2ZMaW5lKCl7cmV0dXJuISh0aGlzLl9jb21wb25lbnRJbmRleD49dGhpcy5fbnVtTGluZXMpJiYhKHRoaXMuX3ZlcnRleEluZGV4PHRoaXMuX2N1cnJlbnRMaW5lLmdldE51bVBvaW50cygpLTEpfWhhc05leHQoKXtyZXR1cm4hKHRoaXMuX2NvbXBvbmVudEluZGV4Pj10aGlzLl9udW1MaW5lcykmJiEodGhpcy5fY29tcG9uZW50SW5kZXg9PT10aGlzLl9udW1MaW5lcy0xJiZ0aGlzLl92ZXJ0ZXhJbmRleD49dGhpcy5fY3VycmVudExpbmUuZ2V0TnVtUG9pbnRzKCkpfWdldENsYXNzKCl7cmV0dXJuIEdvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Hby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXtpZih0aGlzLl9saW5lYXJHZW9tPW51bGwsdGhpcy5fbnVtTGluZXM9bnVsbCx0aGlzLl9jdXJyZW50TGluZT1udWxsLHRoaXMuX2NvbXBvbmVudEluZGV4PTAsdGhpcy5fdmVydGV4SW5kZXg9MCwxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07R28uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LDAsMCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07R28uY29uc3RydWN0b3JfLmNhbGwodGhpcyx0LGUuZ2V0Q29tcG9uZW50SW5kZXgoKSxHby5zZWdtZW50RW5kVmVydGV4SW5kZXgoZSkpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdO2lmKCFfKHQsb3QpKXRocm93IG5ldyBuKFwiTGluZWFsIGdlb21ldHJ5IGlzIHJlcXVpcmVkXCIpO3RoaXMuX2xpbmVhckdlb209dCx0aGlzLl9udW1MaW5lcz10LmdldE51bUdlb21ldHJpZXMoKSx0aGlzLl9jb21wb25lbnRJbmRleD1lLHRoaXMuX3ZlcnRleEluZGV4PXMsdGhpcy5sb2FkQ3VycmVudExpbmUoKX19O2NsYXNzIHFve2NvbnN0cnVjdG9yKCl7cW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1zdGF0aWMgaW5kZXhPZih0LGUpe3JldHVybiBuZXcgcW8odCkuaW5kZXhPZihlKX1zdGF0aWMgaW5kZXhPZkFmdGVyKHQsZSxuKXtyZXR1cm4gbmV3IHFvKHQpLmluZGV4T2ZBZnRlcihlLG4pfWluZGV4T2YodCl7cmV0dXJuIHRoaXMuaW5kZXhPZkZyb21TdGFydCh0LG51bGwpfWluZGV4T2ZGcm9tU3RhcnQodCxlKXtsZXQgbj1pLk1BWF9WQUxVRSxzPTAscj0wLG89LTE7Y29uc3QgbD1uZXcgZWU7Zm9yKGxldCBpPW5ldyBHbyh0aGlzLl9saW5lYXJHZW9tKTtpLmhhc05leHQoKTtpLm5leHQoKSlpZighaS5pc0VuZE9mTGluZSgpKXtsLnAwPWkuZ2V0U2VnbWVudFN0YXJ0KCksbC5wMT1pLmdldFNlZ21lbnRFbmQoKTtjb25zdCBhPWwuZGlzdGFuY2UodCksYz1sLnNlZ21lbnRGcmFjdGlvbih0KSxoPWkuZ2V0Q29tcG9uZW50SW5kZXgoKSx1PWkuZ2V0VmVydGV4SW5kZXgoKTthPG4mJihudWxsPT09ZXx8ZS5jb21wYXJlTG9jYXRpb25WYWx1ZXMoaCx1LGMpPDApJiYocz1oLHI9dSxvPWMsbj1hKX1yZXR1cm4gbj09PWkuTUFYX1ZBTFVFP25ldyBGbyhlKTpuZXcgRm8ocyxyLG8pfWluZGV4T2ZBZnRlcih0LGUpe2lmKG51bGw9PT1lKXJldHVybiB0aGlzLmluZGV4T2YodCk7Y29uc3Qgbj1Gby5nZXRFbmRMb2NhdGlvbih0aGlzLl9saW5lYXJHZW9tKTtpZihuLmNvbXBhcmVUbyhlKTw9MClyZXR1cm4gbjtjb25zdCBzPXRoaXMuaW5kZXhPZkZyb21TdGFydCh0LGUpO3JldHVybiB1LmlzVHJ1ZShzLmNvbXBhcmVUbyhlKT49MCxcImNvbXB1dGVkIGxvY2F0aW9uIGlzIGJlZm9yZSBzcGVjaWZpZWQgbWluaW11bSBsb2NhdGlvblwiKSxzfWdldENsYXNzKCl7cmV0dXJuIHFvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1xby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9saW5lYXJHZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZWFyR2VvbT10fTtjbGFzcyBCb3tjb25zdHJ1Y3Rvcigpe0JvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGluZGljZXNPZih0LGUpe3JldHVybiBuZXcgQm8odCkuaW5kaWNlc09mKGUpfWluZGljZXNPZih0KXtjb25zdCBlPXQuZ2V0R2VvbWV0cnlOKDApLmdldENvb3JkaW5hdGVOKDApLG49dC5nZXRHZW9tZXRyeU4odC5nZXROdW1HZW9tZXRyaWVzKCktMSkscz1uLmdldENvb3JkaW5hdGVOKG4uZ2V0TnVtUG9pbnRzKCktMSksaT1uZXcgcW8odGhpcy5fbGluZWFyR2VvbSkscj1uZXcgQXJyYXkoMikuZmlsbChudWxsKTtyZXR1cm4gclswXT1pLmluZGV4T2YoZSksMD09PXQuZ2V0TGVuZ3RoKCk/clsxXT1yWzBdLmNvcHkoKTpyWzFdPWkuaW5kZXhPZkFmdGVyKHMsclswXSkscn1nZXRDbGFzcygpe3JldHVybiBCb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bXX19Qm8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5fbGluZWFyR2VvbT1udWxsO2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2xpbmVhckdlb209dH07Y2xhc3MgVm97Y29uc3RydWN0b3IoKXtWby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldEdlb21ldHJ5KCl7cmV0dXJuIHRoaXMuZW5kTGluZSgpLHRoaXMuX2dlb21GYWN0LmJ1aWxkR2VvbWV0cnkodGhpcy5fbGluZXMpfWdldExhc3RDb29yZGluYXRlKCl7cmV0dXJuIHRoaXMuX2xhc3RQdH1lbmRMaW5lKCl7aWYobnVsbD09PXRoaXMuX2Nvb3JkTGlzdClyZXR1cm4gbnVsbDtpZih0aGlzLl9pZ25vcmVJbnZhbGlkTGluZXMmJnRoaXMuX2Nvb3JkTGlzdC5zaXplKCk8MilyZXR1cm4gdGhpcy5fY29vcmRMaXN0PW51bGwsbnVsbDtjb25zdCB0PXRoaXMuX2Nvb3JkTGlzdC50b0Nvb3JkaW5hdGVBcnJheSgpO2xldCBlPXQ7dGhpcy5fZml4SW52YWxpZExpbmVzJiYoZT10aGlzLnZhbGlkQ29vcmRpbmF0ZVNlcXVlbmNlKHQpKSx0aGlzLl9jb29yZExpc3Q9bnVsbDtsZXQgcz1udWxsO3RyeXtzPXRoaXMuX2dlb21GYWN0LmNyZWF0ZUxpbmVTdHJpbmcoZSl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgbikpdGhyb3cgdDtpZighdGhpcy5faWdub3JlSW52YWxpZExpbmVzKXRocm93IHR9bnVsbCE9PXMmJnRoaXMuX2xpbmVzLmFkZChzKX1zZXRGaXhJbnZhbGlkTGluZXModCl7dGhpcy5fZml4SW52YWxpZExpbmVzPXR9YWRkKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3RoaXMuYWRkKHQsITApfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO251bGw9PT10aGlzLl9jb29yZExpc3QmJih0aGlzLl9jb29yZExpc3Q9bmV3IEkpLHRoaXMuX2Nvb3JkTGlzdC5hZGQodCxlKSx0aGlzLl9sYXN0UHQ9dH19c2V0SWdub3JlSW52YWxpZExpbmVzKHQpe3RoaXMuX2lnbm9yZUludmFsaWRMaW5lcz10fXZhbGlkQ29vcmRpbmF0ZVNlcXVlbmNlKHQpe2lmKHQubGVuZ3RoPj0yKXJldHVybiB0O3JldHVyblt0WzBdLHRbMF1dfWdldENsYXNzKCl7cmV0dXJuIFZvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Wby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9nZW9tRmFjdD1udWxsLHRoaXMuX2xpbmVzPW5ldyB4LHRoaXMuX2Nvb3JkTGlzdD1udWxsLHRoaXMuX2lnbm9yZUludmFsaWRMaW5lcz0hMSx0aGlzLl9maXhJbnZhbGlkTGluZXM9ITEsdGhpcy5fbGFzdFB0PW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2VvbUZhY3Q9dH07Y2xhc3Mgem97Y29uc3RydWN0b3IoKXt6by5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfXN0YXRpYyBleHRyYWN0KHQsZSxuKXtyZXR1cm4gbmV3IHpvKHQpLmV4dHJhY3QoZSxuKX1jb21wdXRlTGluZWFyKHQsZSl7Y29uc3Qgbj1uZXcgVm8odGhpcy5fbGluZS5nZXRGYWN0b3J5KCkpO24uc2V0Rml4SW52YWxpZExpbmVzKCEwKSx0LmlzVmVydGV4KCl8fG4uYWRkKHQuZ2V0Q29vcmRpbmF0ZSh0aGlzLl9saW5lKSk7Zm9yKGxldCBzPW5ldyBHbyh0aGlzLl9saW5lLHQpO3MuaGFzTmV4dCgpJiYhKGUuY29tcGFyZUxvY2F0aW9uVmFsdWVzKHMuZ2V0Q29tcG9uZW50SW5kZXgoKSxzLmdldFZlcnRleEluZGV4KCksMCk8MCk7cy5uZXh0KCkpe2NvbnN0IHQ9cy5nZXRTZWdtZW50U3RhcnQoKTtuLmFkZCh0KSxzLmlzRW5kT2ZMaW5lKCkmJm4uZW5kTGluZSgpfXJldHVybiBlLmlzVmVydGV4KCl8fG4uYWRkKGUuZ2V0Q29vcmRpbmF0ZSh0aGlzLl9saW5lKSksbi5nZXRHZW9tZXRyeSgpfWNvbXB1dGVMaW5lKHQsZSl7Y29uc3Qgbj10aGlzLl9saW5lLmdldENvb3JkaW5hdGVzKCkscz1uZXcgSTtsZXQgaT10LmdldFNlZ21lbnRJbmRleCgpO3QuZ2V0U2VnbWVudEZyYWN0aW9uKCk+MCYmKGkrPTEpO2xldCByPWUuZ2V0U2VnbWVudEluZGV4KCk7MT09PWUuZ2V0U2VnbWVudEZyYWN0aW9uKCkmJihyKz0xKSxyPj1uLmxlbmd0aCYmKHI9bi5sZW5ndGgtMSksdC5pc1ZlcnRleCgpfHxzLmFkZCh0LmdldENvb3JkaW5hdGUodGhpcy5fbGluZSkpO2ZvcihsZXQgdD1pO3Q8PXI7dCsrKXMuYWRkKG5bdF0pO2UuaXNWZXJ0ZXgoKXx8cy5hZGQoZS5nZXRDb29yZGluYXRlKHRoaXMuX2xpbmUpKSxzLnNpemUoKTw9MCYmcy5hZGQodC5nZXRDb29yZGluYXRlKHRoaXMuX2xpbmUpKTtsZXQgbz1zLnRvQ29vcmRpbmF0ZUFycmF5KCk7cmV0dXJuIG8ubGVuZ3RoPD0xJiYobz1bb1swXSxvWzBdXSksdGhpcy5fbGluZS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhvKX1leHRyYWN0KHQsZSl7cmV0dXJuIGUuY29tcGFyZVRvKHQpPDA/dGhpcy5yZXZlcnNlKHRoaXMuY29tcHV0ZUxpbmVhcihlLHQpKTp0aGlzLmNvbXB1dGVMaW5lYXIodCxlKX1yZXZlcnNlKHQpe3JldHVybiB0IGluc3RhbmNlb2YgVHR8fHQgaW5zdGFuY2VvZiBmdD90LnJldmVyc2UoKToodS5zaG91bGROZXZlclJlYWNoSGVyZShcIm5vbi1saW5lYXIgZ2VvbWV0cnkgZW5jb3VudGVyZWRcIiksbnVsbCl9Z2V0Q2xhc3MoKXtyZXR1cm4gem99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fXpvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpbmU9bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lPXR9O2NsYXNzIFlve2NvbnN0cnVjdG9yKCl7WW8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jbGFtcEluZGV4KHQpe2NvbnN0IGU9dC5jb3B5KCk7cmV0dXJuIGUuY2xhbXAodGhpcy5fbGluZWFyR2VvbSksZX1wcm9qZWN0KHQpe3JldHVybiBxby5pbmRleE9mKHRoaXMuX2xpbmVhckdlb20sdCl9Y2hlY2tHZW9tZXRyeVR5cGUoKXtpZighKHRoaXMuX2xpbmVhckdlb20gaW5zdGFuY2VvZiBUdHx8dGhpcy5fbGluZWFyR2VvbSBpbnN0YW5jZW9mIGZ0KSl0aHJvdyBuZXcgbihcIklucHV0IGdlb21ldHJ5IG11c3QgYmUgbGluZWFyXCIpfWV4dHJhY3RQb2ludCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtyZXR1cm4gYXJndW1lbnRzWzBdLmdldENvb3JkaW5hdGUodGhpcy5fbGluZWFyR2VvbSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dC50b0xvd2VzdCh0aGlzLl9saW5lYXJHZW9tKTtyZXR1cm4gbi5nZXRTZWdtZW50KHRoaXMuX2xpbmVhckdlb20pLnBvaW50QWxvbmdPZmZzZXQobi5nZXRTZWdtZW50RnJhY3Rpb24oKSxlKX19aXNWYWxpZEluZGV4KHQpe3JldHVybiB0LmlzVmFsaWQodGhpcy5fbGluZWFyR2VvbSl9Z2V0RW5kSW5kZXgoKXtyZXR1cm4gRm8uZ2V0RW5kTG9jYXRpb24odGhpcy5fbGluZWFyR2VvbSl9Z2V0U3RhcnRJbmRleCgpe3JldHVybiBuZXcgRm99aW5kZXhPZkFmdGVyKHQsZSl7cmV0dXJuIHFvLmluZGV4T2ZBZnRlcih0aGlzLl9saW5lYXJHZW9tLHQsZSl9ZXh0cmFjdExpbmUodCxlKXtyZXR1cm4gem8uZXh0cmFjdCh0aGlzLl9saW5lYXJHZW9tLHQsZSl9aW5kZXhPZih0KXtyZXR1cm4gcW8uaW5kZXhPZih0aGlzLl9saW5lYXJHZW9tLHQpfWluZGljZXNPZih0KXtyZXR1cm4gQm8uaW5kaWNlc09mKHRoaXMuX2xpbmVhckdlb20sdCl9Z2V0Q2xhc3MoKXtyZXR1cm4gWW99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVlvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpbmVhckdlb209bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lYXJHZW9tPXQsdGhpcy5jaGVja0dlb21ldHJ5VHlwZSgpfTtjbGFzcyBVb3tjb25zdHJ1Y3Rvcigpe1VvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGluZGV4T2YodCxlKXtyZXR1cm4gbmV3IFVvKHQpLmluZGV4T2YoZSl9c3RhdGljIGluZGV4T2ZBZnRlcih0LGUsbil7cmV0dXJuIG5ldyBVbyh0KS5pbmRleE9mQWZ0ZXIoZSxuKX1pbmRleE9mKHQpe3JldHVybiB0aGlzLmluZGV4T2ZGcm9tU3RhcnQodCwtMSl9aW5kZXhPZkZyb21TdGFydCh0LGUpe2xldCBuPWkuTUFYX1ZBTFVFLHM9ZSxyPTA7Y29uc3Qgbz1uZXcgZWUsbD1uZXcgR28odGhpcy5fbGluZWFyR2VvbSk7Zm9yKDtsLmhhc05leHQoKTspe2lmKCFsLmlzRW5kT2ZMaW5lKCkpe28ucDA9bC5nZXRTZWdtZW50U3RhcnQoKSxvLnAxPWwuZ2V0U2VnbWVudEVuZCgpO2NvbnN0IGk9by5kaXN0YW5jZSh0KSxhPXRoaXMuc2VnbWVudE5lYXJlc3RNZWFzdXJlKG8sdCxyKTtpPG4mJmE+ZSYmKHM9YSxuPWkpLHIrPW8uZ2V0TGVuZ3RoKCl9bC5uZXh0KCl9cmV0dXJuIHN9aW5kZXhPZkFmdGVyKHQsZSl7aWYoZTwwKXJldHVybiB0aGlzLmluZGV4T2YodCk7Y29uc3Qgbj10aGlzLl9saW5lYXJHZW9tLmdldExlbmd0aCgpO2lmKG48ZSlyZXR1cm4gbjtjb25zdCBzPXRoaXMuaW5kZXhPZkZyb21TdGFydCh0LGUpO3JldHVybiB1LmlzVHJ1ZShzPj1lLFwiY29tcHV0ZWQgaW5kZXggaXMgYmVmb3JlIHNwZWNpZmllZCBtaW5pbXVtIGluZGV4XCIpLHN9c2VnbWVudE5lYXJlc3RNZWFzdXJlKHQsZSxuKXtjb25zdCBzPXQucHJvamVjdGlvbkZhY3RvcihlKTtyZXR1cm4gczw9MD9uOnM8PTE/bitzKnQuZ2V0TGVuZ3RoKCk6bit0LmdldExlbmd0aCgpfWdldENsYXNzKCl7cmV0dXJuIFVvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Vby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9saW5lYXJHZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZWFyR2VvbT10fTtjbGFzcyBrb3tjb25zdHJ1Y3Rvcigpe2tvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIGdldExlbmd0aCh0LGUpe3JldHVybiBuZXcga28odCkuZ2V0TGVuZ3RoKGUpfXN0YXRpYyBnZXRMb2NhdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gbmV3IGtvKHQpLmdldExvY2F0aW9uKGUpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtyZXR1cm4gbmV3IGtvKHQpLmdldExvY2F0aW9uKGUsbil9fWdldExlbmd0aCh0KXtsZXQgZT0wO2NvbnN0IG49bmV3IEdvKHRoaXMuX2xpbmVhckdlb20pO2Zvcig7bi5oYXNOZXh0KCk7KXtpZighbi5pc0VuZE9mTGluZSgpKXtjb25zdCBzPW4uZ2V0U2VnbWVudFN0YXJ0KCksaT1uLmdldFNlZ21lbnRFbmQoKS5kaXN0YW5jZShzKTtpZih0LmdldENvbXBvbmVudEluZGV4KCk9PT1uLmdldENvbXBvbmVudEluZGV4KCkmJnQuZ2V0U2VnbWVudEluZGV4KCk9PT1uLmdldFZlcnRleEluZGV4KCkpcmV0dXJuIGUraSp0LmdldFNlZ21lbnRGcmFjdGlvbigpO2UrPWl9bi5uZXh0KCl9cmV0dXJuIGV9cmVzb2x2ZUhpZ2hlcih0KXtpZighdC5pc0VuZHBvaW50KHRoaXMuX2xpbmVhckdlb20pKXJldHVybiB0O2xldCBlPXQuZ2V0Q29tcG9uZW50SW5kZXgoKTtpZihlPj10aGlzLl9saW5lYXJHZW9tLmdldE51bUdlb21ldHJpZXMoKS0xKXJldHVybiB0O2Rve2UrK313aGlsZShlPHRoaXMuX2xpbmVhckdlb20uZ2V0TnVtR2VvbWV0cmllcygpLTEmJjA9PT10aGlzLl9saW5lYXJHZW9tLmdldEdlb21ldHJ5TihlKS5nZXRMZW5ndGgoKSk7cmV0dXJuIG5ldyBGbyhlLDAsMCl9Z2V0TG9jYXRpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZ2V0TG9jYXRpb24odCwhMCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2xldCBuPXQ7aWYodDwwKXtuPXRoaXMuX2xpbmVhckdlb20uZ2V0TGVuZ3RoKCkrdH1jb25zdCBzPXRoaXMuZ2V0TG9jYXRpb25Gb3J3YXJkKG4pO3JldHVybiBlP3M6dGhpcy5yZXNvbHZlSGlnaGVyKHMpfX1nZXRMb2NhdGlvbkZvcndhcmQodCl7aWYodDw9MClyZXR1cm4gbmV3IEZvO2xldCBlPTA7Y29uc3Qgbj1uZXcgR28odGhpcy5fbGluZWFyR2VvbSk7Zm9yKDtuLmhhc05leHQoKTspe2lmKG4uaXNFbmRPZkxpbmUoKSl7aWYoZT09PXQpe2NvbnN0IHQ9bi5nZXRDb21wb25lbnRJbmRleCgpLGU9bi5nZXRWZXJ0ZXhJbmRleCgpO3JldHVybiBuZXcgRm8odCxlLDApfX1lbHNle2NvbnN0IHM9bi5nZXRTZWdtZW50U3RhcnQoKSxpPW4uZ2V0U2VnbWVudEVuZCgpLmRpc3RhbmNlKHMpO2lmKGUraT50KXtjb25zdCBzPSh0LWUpL2kscj1uLmdldENvbXBvbmVudEluZGV4KCksbz1uLmdldFZlcnRleEluZGV4KCk7cmV0dXJuIG5ldyBGbyhyLG8scyl9ZSs9aX1uLm5leHQoKX1yZXR1cm4gRm8uZ2V0RW5kTG9jYXRpb24odGhpcy5fbGluZWFyR2VvbSl9Z2V0Q2xhc3MoKXtyZXR1cm4ga299Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fWtvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX2xpbmVhckdlb209bnVsbDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLl9saW5lYXJHZW9tPXR9O2NsYXNzIFhve2NvbnN0cnVjdG9yKCl7WG8uY29uc3RydWN0b3JfLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jbGFtcEluZGV4KHQpe2NvbnN0IGU9dGhpcy5wb3NpdGl2ZUluZGV4KHQpLG49dGhpcy5nZXRTdGFydEluZGV4KCk7aWYoZTxuKXJldHVybiBuO2NvbnN0IHM9dGhpcy5nZXRFbmRJbmRleCgpO3JldHVybiBlPnM/czplfWxvY2F0aW9uT2YoKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07cmV0dXJuIGtvLmdldExvY2F0aW9uKHRoaXMuX2xpbmVhckdlb20sdCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBrby5nZXRMb2NhdGlvbih0aGlzLl9saW5lYXJHZW9tLHQsZSl9fXByb2plY3QodCl7cmV0dXJuIFVvLmluZGV4T2YodGhpcy5fbGluZWFyR2VvbSx0KX1wb3NpdGl2ZUluZGV4KHQpe3JldHVybiB0Pj0wP3Q6dGhpcy5fbGluZWFyR2VvbS5nZXRMZW5ndGgoKSt0fWV4dHJhY3RQb2ludCgpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4ga28uZ2V0TG9jYXRpb24odGhpcy5fbGluZWFyR2VvbSx0KS5nZXRDb29yZGluYXRlKHRoaXMuX2xpbmVhckdlb20pfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWtvLmdldExvY2F0aW9uKHRoaXMuX2xpbmVhckdlb20sdCkudG9Mb3dlc3QodGhpcy5fbGluZWFyR2VvbSk7cmV0dXJuIG4uZ2V0U2VnbWVudCh0aGlzLl9saW5lYXJHZW9tKS5wb2ludEFsb25nT2Zmc2V0KG4uZ2V0U2VnbWVudEZyYWN0aW9uKCksZSl9fWlzVmFsaWRJbmRleCh0KXtyZXR1cm4gdD49dGhpcy5nZXRTdGFydEluZGV4KCkmJnQ8PXRoaXMuZ2V0RW5kSW5kZXgoKX1nZXRFbmRJbmRleCgpe3JldHVybiB0aGlzLl9saW5lYXJHZW9tLmdldExlbmd0aCgpfWdldFN0YXJ0SW5kZXgoKXtyZXR1cm4gMH1pbmRleE9mQWZ0ZXIodCxlKXtyZXR1cm4gVW8uaW5kZXhPZkFmdGVyKHRoaXMuX2xpbmVhckdlb20sdCxlKX1leHRyYWN0TGluZSh0LGUpe25ldyBZbyh0aGlzLl9saW5lYXJHZW9tKTtjb25zdCBuPXRoaXMuY2xhbXBJbmRleCh0KSxzPXRoaXMuY2xhbXBJbmRleChlKSxpPW49PT1zLHI9dGhpcy5sb2NhdGlvbk9mKG4saSksbz10aGlzLmxvY2F0aW9uT2Yocyk7cmV0dXJuIHpvLmV4dHJhY3QodGhpcy5fbGluZWFyR2VvbSxyLG8pfWluZGV4T2YodCl7cmV0dXJuIFVvLmluZGV4T2YodGhpcy5fbGluZWFyR2VvbSx0KX1pbmRpY2VzT2YodCl7Y29uc3QgZT1Cby5pbmRpY2VzT2YodGhpcy5fbGluZWFyR2VvbSx0KTtyZXR1cm5ba28uZ2V0TGVuZ3RoKHRoaXMuX2xpbmVhckdlb20sZVswXSksa28uZ2V0TGVuZ3RoKHRoaXMuX2xpbmVhckdlb20sZVsxXSldfWdldENsYXNzKCl7cmV0dXJuIFhvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Yby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9saW5lYXJHZW9tPW51bGw7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5fbGluZWFyR2VvbT10fTt2YXIgSG89T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsTGVuZ3RoSW5kZXhlZExpbmU6WG8sTGVuZ3RoTG9jYXRpb25NYXA6a28sTGluZWFyR2VvbWV0cnlCdWlsZGVyOlZvLExpbmVhckl0ZXJhdG9yOkdvLExpbmVhckxvY2F0aW9uOkZvLExvY2F0aW9uSW5kZXhlZExpbmU6WW99KTtjbGFzcyBXb3tjb25zdHJ1Y3Rvcigpe1dvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9c3RhdGljIHRyYW5zZm9ybSh0LGUpe2NvbnN0IG49bmV3IHg7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspbi5hZGQoZS5leGVjdXRlKHMubmV4dCgpKSk7cmV0dXJuIG59c3RhdGljIHNlbGVjdCh0LGUpe2NvbnN0IG49bmV3IHg7Zm9yKGxldCBzPXQuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe2NvbnN0IHQ9cy5uZXh0KCk7Qm9vbGVhbi5UUlVFLmVxdWFscyhlLmV4ZWN1dGUodCkpJiZuLmFkZCh0KX1yZXR1cm4gbn1zdGF0aWMgYXBwbHkodCxlKXtmb3IobGV0IG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyllLmV4ZWN1dGUobi5uZXh0KCkpfWdldENsYXNzKCl7cmV0dXJuIFdvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1Xby5GdW5jdGlvbj1mdW5jdGlvbigpe30sV28uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7fTtjbGFzcyBqb3tjb25zdHJ1Y3Rvcigpe2pvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9ZmlsdGVyKHQpe3RoaXMucHRzW3RoaXMubisrXT10fWdldENvb3JkaW5hdGVzKCl7cmV0dXJuIHRoaXMucHRzfWdldENsYXNzKCl7cmV0dXJuIGpvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltCXX19am8uY29uc3RydWN0b3JfPWZ1bmN0aW9uKCl7dGhpcy5wdHM9bnVsbCx0aGlzLm49MDtjb25zdCB0PWFyZ3VtZW50c1swXTt0aGlzLnB0cz1uZXcgQXJyYXkodCkuZmlsbChudWxsKX07Y2xhc3MgS297Y29uc3RydWN0b3IoKXtLby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWZpbHRlcih0KXt0aGlzLl9uKyt9Z2V0Q291bnQoKXtyZXR1cm4gdGhpcy5fbn1nZXRDbGFzcygpe3JldHVybiBLb31nZXQgaW50ZXJmYWNlc18oKXtyZXR1cm5bQl19fUtvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe3RoaXMuX249MH07Y2xhc3MgWm97Y29uc3RydWN0b3IoKXtaby5jb25zdHJ1Y3Rvcl8uYXBwbHkodGhpcyxhcmd1bWVudHMpfWNvdW50KHQpe2NvbnN0IGU9dGhpcy5fY291bnRzLmdldCh0KTtyZXR1cm4gbnVsbD09PWU/MDplLmNvdW50KCl9YWRkKHQpe2NvbnN0IGU9dGhpcy5fY291bnRzLmdldCh0KTtudWxsPT09ZT90aGlzLl9jb3VudHMucHV0KHQsbmV3IFFvKDEpKTplLmluY3JlbWVudCgpfWdldENsYXNzKCl7cmV0dXJuIFpvfWdldCBpbnRlcmZhY2VzXygpe3JldHVybltdfX1jbGFzcyBRb3tjb25zdHJ1Y3Rvcigpe1FvLmNvbnN0cnVjdG9yXy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y291bnQoKXtyZXR1cm4gdGhpcy5jb3VudH1pbmNyZW1lbnQoKXt0aGlzLmNvdW50Kyt9Z2V0Q2xhc3MoKXtyZXR1cm4gUW99Z2V0IGludGVyZmFjZXNfKCl7cmV0dXJuW119fVFvLmNvbnN0cnVjdG9yXz1mdW5jdGlvbigpe2lmKHRoaXMuY291bnQ9MCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF07dGhpcy5jb3VudD10fX0sWm8uQ291bnRlcj1Rbyxaby5jb25zdHJ1Y3Rvcl89ZnVuY3Rpb24oKXt0aGlzLl9jb3VudHM9bmV3IFV0fTt2YXIgSm89T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsQ29sbGVjdGlvblV0aWw6V28sQ29vcmRpbmF0ZUFycmF5RmlsdGVyOmpvLENvb3JkaW5hdGVDb3VudEZpbHRlcjpLbyxHZW9tZXRyaWNTaGFwZUZhY3Rvcnk6U2UsTnVtYmVyVXRpbDplLE9iamVjdENvdW50ZXI6Wm8sUHJpb3JpdHlRdWV1ZTpmcyxTdHJpbmdVdGlsOlN0LFVuaXF1ZUNvb3JkaW5hdGVBcnJheUZpbHRlcjpsbn0pO2NsYXNzICRve2dldCBpbnRlcmZhY2VzXygpe3JldHVybltdfWdldENsYXNzKCl7cmV0dXJuICRvfXN0YXRpYyB1bmlvbih0LGUpe2lmKHQuaXNFbXB0eSgpfHxlLmlzRW1wdHkoKSl7aWYodC5pc0VtcHR5KCkmJmUuaXNFbXB0eSgpKXJldHVybiBjci5jcmVhdGVFbXB0eVJlc3VsdChjci5VTklPTix0LGUsdC5nZXRGYWN0b3J5KCkpO2lmKHQuaXNFbXB0eSgpKXJldHVybiBlLmNvcHkoKTtpZihlLmlzRW1wdHkoKSlyZXR1cm4gdC5jb3B5KCl9cmV0dXJuIHQuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odCksdC5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbihlKSxsci5vdmVybGF5T3AodCxlLGNyLlVOSU9OKX19cS5wcm90b3R5cGUuZXF1YWxzVG9wbz1mdW5jdGlvbih0KXtyZXR1cm4hIXRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmVxdWFscyh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSkmJkdyLnJlbGF0ZSh0aGlzLHQpLmlzRXF1YWxzKHRoaXMuZ2V0RGltZW5zaW9uKCksdC5nZXREaW1lbnNpb24oKSl9LHEucHJvdG90eXBlLnVuaW9uPWZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHpyLnVuaW9uKHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gJG8udW5pb24odGhpcyx0KX19LHEucHJvdG90eXBlLmlzVmFsaWQ9ZnVuY3Rpb24oKXtyZXR1cm4gQ3IuaXNWYWxpZCh0aGlzKX0scS5wcm90b3R5cGUuaW50ZXJzZWN0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiBjci5pbnRlcnNlY3Rpb24odGhpcyx0KX0scS5wcm90b3R5cGUuY292ZXJzPWZ1bmN0aW9uKHQpe3JldHVybiBHci5jb3ZlcnModGhpcyx0KX0scS5wcm90b3R5cGUuY292ZXJlZEJ5PWZ1bmN0aW9uKHQpe3JldHVybiBHci5jb3ZlcnModCx0aGlzKX0scS5wcm90b3R5cGUudG91Y2hlcz1mdW5jdGlvbih0KXtyZXR1cm4gR3IudG91Y2hlcyh0aGlzLHQpfSxxLnByb3RvdHlwZS5pbnRlcnNlY3RzPWZ1bmN0aW9uKHQpe3JldHVybiBHci5pbnRlcnNlY3RzKHRoaXMsdCl9LHEucHJvdG90eXBlLndpdGhpbj1mdW5jdGlvbih0KXtyZXR1cm4gR3IuY29udGFpbnModCx0aGlzKX0scS5wcm90b3R5cGUub3ZlcmxhcHM9ZnVuY3Rpb24odCl7cmV0dXJuIEdyLm92ZXJsYXBzKHRoaXMsdCl9LHEucHJvdG90eXBlLmRpc2pvaW50PWZ1bmN0aW9uKHQpe3JldHVybiBHci5kaXNqb2ludCh0aGlzLHQpfSxxLnByb3RvdHlwZS5jcm9zc2VzPWZ1bmN0aW9uKHQpe3JldHVybiBHci5jcm9zc2VzKHRoaXMsdCl9LHEucHJvdG90eXBlLmJ1ZmZlcj1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtjb25zdCB0PWFyZ3VtZW50c1swXTtyZXR1cm4gU2kuYnVmZmVyT3AodGhpcyx0KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIFNpLmJ1ZmZlck9wKHRoaXMsdCxlKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIFNpLmJ1ZmZlck9wKHRoaXMsdCxlLG4pfX0scS5wcm90b3R5cGUuY29udmV4SHVsbD1mdW5jdGlvbigpe3JldHVybiBuZXcgYW4odGhpcykuZ2V0Q29udmV4SHVsbCgpfSxxLnByb3RvdHlwZS5yZWxhdGU9ZnVuY3Rpb24oLi4udCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2NvbnN0IHQ9YXJndW1lbnRzWzBdO3JldHVybiBHci5yZWxhdGUodGhpcyx0KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Y29uc3QgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIEdyLnJlbGF0ZSh0aGlzLHQpLm1hdGNoZXMoZSl9fSxxLnByb3RvdHlwZS5nZXRDZW50cm9pZD1mdW5jdGlvbigpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvaW50KCk7Y29uc3QgdD1zbi5nZXRDZW50cm9pZCh0aGlzKTtyZXR1cm4gdGhpcy5jcmVhdGVQb2ludEZyb21JbnRlcm5hbENvb3JkKHQsdGhpcyl9LHEucHJvdG90eXBlLmdldEludGVyaW9yUG9pbnQ9ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2ludCgpO2xldCB0PW51bGw7Y29uc3QgZT10aGlzLmdldERpbWVuc2lvbigpO3Q9MD09PWU/bmV3IGRuKHRoaXMpOjE9PT1lP25ldyBnbih0aGlzKTpuZXcgaG4odGhpcyk7Y29uc3Qgbj10LmdldEludGVyaW9yUG9pbnQoKTtyZXR1cm4gdGhpcy5jcmVhdGVQb2ludEZyb21JbnRlcm5hbENvb3JkKG4sdGhpcyl9LHEucHJvdG90eXBlLnN5bURpZmZlcmVuY2U9ZnVuY3Rpb24odCl7cmV0dXJuIGNyLnN5bURpZmZlcmVuY2UodGhpcyx0KX0scS5wcm90b3R5cGUuY3JlYXRlUG9pbnRGcm9tSW50ZXJuYWxDb29yZD1mdW5jdGlvbih0LGUpe3JldHVybiBlLmdldFByZWNpc2lvbk1vZGVsKCkubWFrZVByZWNpc2UodCksZS5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodCl9LHEucHJvdG90eXBlLnRvVGV4dD1mdW5jdGlvbigpe3JldHVybihuZXcgSnQpLndyaXRlKHRoaXMpfSxxLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3RoaXMudG9UZXh0KCl9LHEucHJvdG90eXBlLmNvbnRhaW5zPWZ1bmN0aW9uKHQpe3JldHVybiBHci5jb250YWlucyh0aGlzLHQpfSxxLnByb3RvdHlwZS5kaWZmZXJlbmNlPWZ1bmN0aW9uKHQpe3JldHVybiBjci5kaWZmZXJlbmNlKHRoaXMsdCl9LHEucHJvdG90eXBlLmlzU2ltcGxlPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBIcyh0aGlzKS5pc1NpbXBsZSgpfSxxLnByb3RvdHlwZS5pc1dpdGhpbkRpc3RhbmNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuISh0aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKS5kaXN0YW5jZSh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSk+ZSkmJlJpLmlzV2l0aGluRGlzdGFuY2UodGhpcyx0LGUpfSxxLnByb3RvdHlwZS5kaXN0YW5jZT1mdW5jdGlvbih0KXtyZXR1cm4gUmkuZGlzdGFuY2UodGhpcyx0KX0scS5wcm90b3R5cGUuaXNFcXVpdmFsZW50Q2xhc3M9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2V0Q2xhc3MoKT09PXQuZ2V0Q2xhc3MoKX07dC5hbGdvcml0aG09bW4sdC5kZW5zaWZ5PUVuLHQuZGlzc29sdmU9Um4sdC5nZW9tPVJlLHQuZ2VvbWdyYXBoPUpuLHQuaW5kZXg9Q3MsdC5pbz1Qcyx0LmxpbmVhcnJlZj1Ibyx0Lm5vZGluZz1Ycyx0Lm9wZXJhdGlvbj1rcix0LnByZWNpc2lvbj1Xcix0LnNpbXBsaWZ5PWhvLHQudHJpYW5ndWxhdGU9QW8sdC51dGlsPUpvLHQudmVyc2lvbj1cIjIuMS4yICg4M2I1YWVlKVwiLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anN0cy5taW4uanMubWFwIiwiLypcbiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWxcbipcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qL1xuKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemVcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xuICAgIHZhciBpc0lFID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpICYmICh0eXBlb2Ygd2luZG93Lm5hdmlnYXRvciAhPT0gdW5kZWZpbmVkVHlwZSkgJiYgKFxuICAgICAgICAvVHJpZGVudFxcL3xNU0lFIC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICApO1xuXG4gICAgdmFyIGxvZ01ldGhvZHMgPSBbXG4gICAgICAgIFwidHJhY2VcIixcbiAgICAgICAgXCJkZWJ1Z1wiLFxuICAgICAgICBcImluZm9cIixcbiAgICAgICAgXCJ3YXJuXCIsXG4gICAgICAgIFwiZXJyb3JcIlxuICAgIF07XG5cbiAgICAvLyBDcm9zcy1icm93c2VyIGJpbmQgZXF1aXZhbGVudCB0aGF0IHdvcmtzIGF0IGxlYXN0IGJhY2sgdG8gSUU2XG4gICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKG1ldGhvZCwgb2JqKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyYWNlKCkgZG9lc24ndCBwcmludCB0aGUgbWVzc2FnZSBpbiBJRSwgc28gZm9yIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIHdyYXAgaXRcbiAgICBmdW5jdGlvbiB0cmFjZUZvcklFKCkge1xuICAgICAgICBpZiAoY29uc29sZS5sb2cpIHtcbiAgICAgICAgICAgIGlmIChjb25zb2xlLmxvZy5hcHBseSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluIG9sZCBJRSwgbmF0aXZlIGNvbnNvbGUgbWV0aG9kcyB0aGVtc2VsdmVzIGRvbid0IGhhdmUgYXBwbHkoKS5cbiAgICAgICAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoY29uc29sZS5sb2csIFtjb25zb2xlLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc29sZS50cmFjZSkgY29uc29sZS50cmFjZSgpO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudlxuICAgIC8vIFdoZXJldmVyIHBvc3NpYmxlIHdlIHdhbnQgdG8gYmluZCwgbm90IHdyYXAsIHRvIHByZXNlcnZlIHN0YWNrIHRyYWNlc1xuICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykge1xuICAgICAgICAgICAgbWV0aG9kTmFtZSA9ICdsb2cnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG1ldGhvZCBwb3NzaWJsZSwgZm9yIG5vdyAtIGZpeGVkIGxhdGVyIGJ5IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXNcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAndHJhY2UnICYmIGlzSUUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFjZUZvcklFO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgP1xuICAgICAgICAgICAgICAgIG5vb3AgOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnXG4gICAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZztcbiAgICB9XG5cbiAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fFxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjdXJyZW50TGV2ZWw7XG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHN0b3JhZ2VLZXkgKz0gXCI6XCIgKyBuYW1lO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7XG4gICAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV0gPSBsZXZlbE5hbWU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIiArIGxldmVsTmFtZSArIFwiO1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgdmFyIHN0b3JlZExldmVsO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb29raWVzIGlmIGxvY2FsIHN0b3JhZ2UgZ2l2ZXMgdXMgbm90aGluZ1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb29raWUgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llO1xuICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL14oW147XSspLy5leGVjKGNvb2tpZS5zbGljZShsb2NhdGlvbikpWzFdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCBsZXZlbCBpcyBub3QgdmFsaWQsIHRyZWF0IGl0IGFzIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cbiAgICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN0b3JlZExldmVsO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICpcbiAgICAgICAqIFB1YmxpYyBsb2dnZXIgQVBJIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCBmb3IgZGV0YWlsc1xuICAgICAgICpcbiAgICAgICAqL1xuXG4gICAgICBzZWxmLm5hbWUgPSBuYW1lO1xuXG4gICAgICBzZWxmLmxldmVscyA9IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMyxcbiAgICAgICAgICBcIkVSUk9SXCI6IDQsIFwiU0lMRU5UXCI6IDV9O1xuXG4gICAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5O1xuXG4gICAgICBzZWxmLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWw7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICAgIGlmIChwZXJzaXN0ICE9PSBmYWxzZSkgeyAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZiwgbGV2ZWwsIG5hbWUpO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgbGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICBpZiAoIWdldFBlcnNpc3RlZExldmVsKCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5zZXRMZXZlbChsZXZlbCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuVFJBQ0UsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5kaXNhYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5ULCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEluaXRpYWxpemUgd2l0aCB0aGUgcmlnaHQgbGV2ZWxcbiAgICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgaWYgKGluaXRpYWxMZXZlbCA9PSBudWxsKSB7XG4gICAgICAgICAgaW5pdGlhbExldmVsID0gZGVmYXVsdExldmVsID09IG51bGwgPyBcIldBUk5cIiA6IGRlZmF1bHRMZXZlbDtcbiAgICAgIH1cbiAgICAgIHNlbGYuc2V0TGV2ZWwoaW5pdGlhbExldmVsLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKlxuICAgICAqIFRvcC1sZXZlbCBBUElcbiAgICAgKlxuICAgICAqL1xuXG4gICAgdmFyIGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cbiAgICB2YXIgX2xvZ2dlcnNCeU5hbWUgPSB7fTtcbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlciA9IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIiB8fCBuYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKFxuICAgICAgICAgICAgbmFtZSwgZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfTtcblxuICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgIHZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcbiAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiZcbiAgICAgICAgICAgICAgIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgfTtcblxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7XG4gICAgICAgIHJldHVybiBfbG9nZ2Vyc0J5TmFtZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG59KSk7XG4iLCIvLyAuZGlybmFtZSwgLmJhc2VuYW1lLCBhbmQgLmV4dG5hbWUgbWV0aG9kcyBhcmUgZXh0cmFjdGVkIGZyb20gTm9kZS5qcyB2OC4xMS4xLFxuLy8gYmFja3BvcnRlZCBhbmQgdHJhbnNwbGl0ZWQgd2l0aCBCYWJlbCwgd2l0aCBiYWNrd2FyZHMtY29tcGF0IGZpeGVzXG5cbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcuJztcbiAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gIHZhciBoYXNSb290ID0gY29kZSA9PT0gNDcgLyovKi87XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMTsgLS1pKSB7XG4gICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3JcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmQgPT09IC0xKSByZXR1cm4gaGFzUm9vdCA/ICcvJyA6ICcuJztcbiAgaWYgKGhhc1Jvb3QgJiYgZW5kID09PSAxKSB7XG4gICAgLy8gcmV0dXJuICcvLyc7XG4gICAgLy8gQmFja3dhcmRzLWNvbXBhdCBmaXg6XG4gICAgcmV0dXJuICcvJztcbiAgfVxuICByZXR1cm4gcGF0aC5zbGljZSgwLCBlbmQpO1xufTtcblxuZnVuY3Rpb24gYmFzZW5hbWUocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuXG4gIHZhciBzdGFydCA9IDA7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBpZiAocGF0aC5jaGFyQ29kZUF0KGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgIC8vIHBhdGggY29tcG9uZW50XG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIGVuZCA9IGkgKyAxO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmQgPT09IC0xKSByZXR1cm4gJyc7XG4gIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xufVxuXG4vLyBVc2VzIGEgbWl4ZWQgYXBwcm9hY2ggZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCBhcyBleHQgYmVoYXZpb3IgY2hhbmdlZFxuLy8gaW4gbmV3IE5vZGUuanMgdmVyc2lvbnMsIHNvIG9ubHkgYmFzZW5hbWUoKSBhYm92ZSBpcyBiYWNrcG9ydGVkIGhlcmVcbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbiAocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gYmFzZW5hbWUocGF0aCk7XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbiAocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuICB2YXIgc3RhcnREb3QgPSAtMTtcbiAgdmFyIHN0YXJ0UGFydCA9IDA7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcbiAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcbiAgdmFyIHByZURvdFN0YXRlID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgIC8vIGV4dGVuc2lvblxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICBlbmQgPSBpICsgMTtcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IDQ2IC8qLiovKSB7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKVxuICAgICAgICAgIHN0YXJ0RG90ID0gaTtcbiAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpXG4gICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xuICAgIH0gZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZFxuICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbiAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fCBlbmQgPT09IC0xIHx8XG4gICAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxuICAgICAgcHJlRG90U3RhdGUgPT09IDAgfHxcbiAgICAgIC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLidcbiAgICAgIHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVja3MsIGlmIHBvbHlnb24gaXMgc2ltcGxlLiBQb2x5Z29uIGlzIHNpbXBsZSwgd2hlbiBpdHMgZWRnZXMgZG9uJ3QgY3Jvc3MgZWFjaCBvdGhlci5cbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSBwb2x5Z29uIFt4MSwgeTEsIHgyLCB5Mi4uLl1cbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIFBvbHlnb24gaXMgc2ltcGxlXG4gKi9cbmZ1bmN0aW9uIElzU2ltcGxlIChwb2x5Z29uKSB7XG4gIHZhciBwID0gcG9seWdvbjtcbiAgdmFyIG4gPSBwLmxlbmd0aCA+PiAxO1xuICBpZiAobiA8IDQpIHJldHVybiB0cnVlXG4gIHZhciBhMSA9IFBvaW50KCk7XG4gIHZhciBhMiA9IFBvaW50KCk7XG4gIHZhciBiMSA9IFBvaW50KCk7XG4gIHZhciBiMiA9IFBvaW50KCk7XG4gIHZhciBjID0gUG9pbnQoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGExLnggPSBwWzIgKiBpXTtcbiAgICBhMS55ID0gcFsyICogaSArIDFdO1xuICAgIGlmIChpID09IG4gLSAxKSB7XG4gICAgICBhMi54ID0gcFswXTtcbiAgICAgIGEyLnkgPSBwWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBhMi54ID0gcFsyICogaSArIDJdO1xuICAgICAgYTIueSA9IHBbMiAqIGkgKyAzXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgaWYgKE1hdGguYWJzKGkgLSBqKSA8IDIpIGNvbnRpbnVlXG4gICAgICBpZiAoaiA9PSBuIC0gMSAmJiBpID09IDApIGNvbnRpbnVlXG4gICAgICBpZiAoaSA9PSBuIC0gMSAmJiBqID09IDApIGNvbnRpbnVlXG5cbiAgICAgIGIxLnggPSBwWzIgKiBqXTtcbiAgICAgIGIxLnkgPSBwWzIgKiBqICsgMV07XG4gICAgICBpZiAoaiA9PSBuIC0gMSkge1xuICAgICAgICBiMi54ID0gcFswXTtcbiAgICAgICAgYjIueSA9IHBbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiMi54ID0gcFsyICogaiArIDJdO1xuICAgICAgICBiMi55ID0gcFsyICogaiArIDNdO1xuICAgICAgfVxuXG4gICAgICBpZiAoR2V0TGluZUludGVyc2VjdGlvbihhMSwgYTIsIGIxLCBiMiwgYykgIT0gbnVsbCkgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5tb2R1bGUuZXhwb3J0cy5Jc1NpbXBsZSA9IElzU2ltcGxlO1xuXG4vKipcbiAqIENoZWNrcywgaWYgcG9seWdvbiBpcyBjb252ZXguIFBvbHlnb24gaXMgY29udmV4LCB3aGVuIGVhY2ggaW5uZXIgYW5nbGUgaXMgPD0gMTgwwrAuXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gcG9seWdvbiBbeDEsIHkxLCB4MiwgeTIuLi5dXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gSXNDb252ZXggKHBvbHlnb24pIHtcbiAgdmFyIHAgPSBwb2x5Z29uO1xuICBpZiAocC5sZW5ndGggPCA2KSByZXR1cm4gdHJ1ZVxuICB2YXIgbCA9IHAubGVuZ3RoIC0gNDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpICs9IDIpIHtcbiAgICBpZiAoIWNvbnZleChwW2ldLCBwW2kgKyAxXSwgcFtpICsgMl0sIHBbaSArIDNdLCBwW2kgKyA0XSwgcFtpICsgNV0pKSByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAoIWNvbnZleChwW2xdLCBwW2wgKyAxXSwgcFtsICsgMl0sIHBbbCArIDNdLCBwWzBdLCBwWzFdKSkgcmV0dXJuIGZhbHNlXG4gIGlmICghY29udmV4KHBbbCArIDJdLCBwW2wgKyAzXSwgcFswXSwgcFsxXSwgcFsyXSwgcFszXSkpIHJldHVybiBmYWxzZVxuICByZXR1cm4gdHJ1ZVxufVxubW9kdWxlLmV4cG9ydHMuSXNDb252ZXggPSBJc0NvbnZleDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhcmVhIG9mIHBvbHlnb24uXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gcG9seWdvbiBbeDEsIHkxLCB4MiwgeTIuLi5dXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBHZXRBcmVhIChwb2x5Z29uKSB7XG4gIHZhciBwID0gcG9seWdvbjtcbiAgaWYgKHAubGVuZ3RoIDwgNikgcmV0dXJuIDBcbiAgdmFyIGwgPSBwLmxlbmd0aCAtIDI7XG4gIHZhciBzdW0gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkgKz0gMikge1xuICAgIHN1bSArPSAocFtpICsgMl0gLSBwW2ldKSAqIChwW2kgKyAxXSArIHBbaSArIDNdKTtcbiAgfVxuICBzdW0gKz0gKHBbMF0gLSBwW2xdKSAqIChwW2wgKyAxXSArIHBbMV0pO1xuICByZXR1cm4gLXN1bSAqIDAuNVxufVxubW9kdWxlLmV4cG9ydHMuR2V0QXJlYSA9IEdldEFyZWE7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgQXhpcy1hbGlnbmVkIEJvdW5kaW5nIEJveCBvZiBwb2x5Z29uXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gcG9seWdvbiBbeDEsIHkxLCB4MiwgeTIuLi5dXG4gKiBAcmV0dXJucyB7QUFCQn1cbiAqIEBleGFtcGxlXG4gKiAvLz17eDowLCB5OjAsIHdpZHRoOjAsIGhlaWdodDowfVxuICovXG5mdW5jdGlvbiBHZXRBQUJCIChwb2x5Z29uKSB7XG4gIHZhciBwID0gcG9seWdvbjtcbiAgdmFyIG1pbnggPSBJbmZpbml0eTtcbiAgdmFyIG1pbnkgPSBJbmZpbml0eTtcbiAgdmFyIG1heHggPSAtbWlueDtcbiAgdmFyIG1heHkgPSAtbWlueTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgbWlueCA9IE1hdGgubWluKG1pbngsIHBbaV0pO1xuICAgIG1heHggPSBNYXRoLm1heChtYXh4LCBwW2ldKTtcbiAgICBtaW55ID0gTWF0aC5taW4obWlueSwgcFtpICsgMV0pO1xuICAgIG1heHkgPSBNYXRoLm1heChtYXh5LCBwW2kgKyAxXSk7XG4gIH1cbiAgcmV0dXJuIHt4OiBtaW54LCB5OiBtaW55LCB3aWR0aDogbWF4eCAtIG1pbngsIGhlaWdodDogbWF4eSAtIG1pbnl9XG59XG5tb2R1bGUuZXhwb3J0cy5HZXRBQUJCID0gR2V0QUFCQjtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgdHJpYW5ndWxhdGlvbi4gT3V0cHV0IGFycmF5IGlzIGFycmF5IG9mIHRyaWFuZ2xlcyAodHJpYW5nbGUgPSAzIGluZGljZXMgb2YgcG9seWdvbiB2ZXJ0aWNlcykuXG4gKlxuICogV29ya3Mgd2l0aCBzaW1wbGUgcG9seWdvbnMgb25seS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSBwb2x5Z29uIFt4MSwgeTEsIHgyLCB5Mi4uLl1cbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gYXJyYXkgb2YgdHJpYW5nbGVzICh0cmlhbmdsZSA9IDMgaW5kaWNlcyBvZiBwb2x5Z29uIHZlcnRpY2VzKVxuICogQGV4YW1wbGVcbiAqIHZhciBpZHMgPSBQb2x5Sy5Ucmlhbmd1bGF0ZShbMCwgMCwgMSwgMCwgMSwgMSwgMCwgMV0pO1xuICogLy89WzAsIDEsIDIsIDAsIDIsIDNdXG4gKi9cbmZ1bmN0aW9uIFRyaWFuZ3VsYXRlIChwb2x5Z29uKSB7XG4gIHZhciBwID0gcG9seWdvbjtcbiAgdmFyIG4gPSBwLmxlbmd0aCA+PiAxO1xuICBpZiAobiA8IDMpIHJldHVybiBbXVxuICB2YXIgdGdzID0gW107XG4gIHZhciBhdmwgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHsgYXZsLnB1c2goaSk7IH1cblxuICB2YXIgaSA9IDA7XG4gIHZhciBhbCA9IG47XG4gIHdoaWxlIChhbCA+IDMpIHtcbiAgICB2YXIgaTAgPSBhdmxbKGkgKyAwKSAlIGFsXTtcbiAgICB2YXIgaTEgPSBhdmxbKGkgKyAxKSAlIGFsXTtcbiAgICB2YXIgaTIgPSBhdmxbKGkgKyAyKSAlIGFsXTtcblxuICAgIHZhciBheCA9IHBbMiAqIGkwXTtcbiAgICB2YXIgYXkgPSBwWzIgKiBpMCArIDFdO1xuICAgIHZhciBieCA9IHBbMiAqIGkxXTtcbiAgICB2YXIgYnkgPSBwWzIgKiBpMSArIDFdO1xuICAgIHZhciBjeCA9IHBbMiAqIGkyXTtcbiAgICB2YXIgY3kgPSBwWzIgKiBpMiArIDFdO1xuXG4gICAgdmFyIGVhckZvdW5kID0gZmFsc2U7XG4gICAgaWYgKGNvbnZleChheCwgYXksIGJ4LCBieSwgY3gsIGN5KSkge1xuICAgICAgZWFyRm91bmQgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbDsgaisrKSB7XG4gICAgICAgIHZhciB2aSA9IGF2bFtqXTtcbiAgICAgICAgaWYgKHZpID09IGkwIHx8IHZpID09IGkxIHx8IHZpID09IGkyKSBjb250aW51ZVxuICAgICAgICBpZiAoUG9pbnRJblRyaWFuZ2xlKHBbMiAqIHZpXSwgcFsyICogdmkgKyAxXSwgYXgsIGF5LCBieCwgYnksIGN4LCBjeSkpIHtcbiAgICAgICAgICBlYXJGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVhckZvdW5kKSB7XG4gICAgICB0Z3MucHVzaChpMCwgaTEsIGkyKTtcbiAgICAgIGF2bC5zcGxpY2UoKGkgKyAxKSAlIGFsLCAxKTtcbiAgICAgIGFsLS07XG4gICAgICBpID0gMDtcbiAgICB9IGVsc2UgaWYgKGkrKyA+IDMgKiBhbCkgYnJlYWsgICAgLy8gbm8gY29udmV4IGFuZ2xlcyA6KFxuICB9XG4gIHRncy5wdXNoKGF2bFswXSwgYXZsWzFdLCBhdmxbMl0pO1xuICByZXR1cm4gdGdzXG59XG5tb2R1bGUuZXhwb3J0cy5Ucmlhbmd1bGF0ZSA9IFRyaWFuZ3VsYXRlO1xuXG4vKipcbiAqIFNsaWNlcyB0aGUgcG9seWdvbiB3aXRoIGxpbmUgc2VnbWVudCBBLUIsIGRlZmluZWQgYnkgW2F4LGF5XSBhbmQgW2J4LGJ5XS4gQSwgQiBtdXN0IG5vdCBsYXkgaW5zaWRlIGEgcG9seWdvbi4gUmV0dXJucyBhbiBhcnJheSBvZiBwb2x5Z29ucy5cbiAqXG4gKiBXb3JrcyB3aXRoIHNpbXBsZSBwb2x5Z29ucyBvbmx5LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyW119IHBvbHlnb24gW3gxLCB5MSwgeDIsIHkyLi4uXVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0WCBTdGFydCBDb29yZGluYXRlIFt4XVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0WSBTdGFydCBDb29yZGluYXRlIFt5XVxuICogQHBhcmFtIHtudW1iZXJ9IGVuZFggRW5kIENvb3JkaW5hdGUgW3hdXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kWSBFbmQgQ29vcmRpbmF0ZSBbeV1cbiAqIEByZXR1cm5zIHtudW1iZXJbXVtdfSBBcnJheSBvZiBQb2x5Z29uXG4gKi9cbmZ1bmN0aW9uIFNsaWNlIChwb2x5Z29uLCBzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSkge1xuICB2YXIgcCA9IHBvbHlnb247XG4gIHZhciBheCA9IHN0YXJ0WDtcbiAgdmFyIGF5ID0gc3RhcnRZO1xuICB2YXIgYnggPSBlbmRYO1xuICB2YXIgYnkgPSBlbmRZO1xuICBpZiAoQ29udGFpbnNQb2ludChwLCBheCwgYXkpIHx8IENvbnRhaW5zUG9pbnQocCwgYngsIGJ5KSkge1xuICAgIHJldHVybiBbcC5zbGljZSgwKV1cbiAgfVxuXG4gIHZhciBhID0gUG9pbnQoYXgsIGF5KTtcbiAgdmFyIGIgPSBQb2ludChieCwgYnkpO1xuICB2YXIgaXNjcyA9IFtdOyAgLy8gaW50ZXJzZWN0aW9uc1xuICB2YXIgcHMgPSBbXTsgIC8vIHBvaW50c1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBwcy5wdXNoKFBvaW50KHBbaV0sIHBbaSArIDFdKSk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpc2MgPSBQb2ludCgwLCAwKTtcbiAgICBpc2MgPSBHZXRMaW5lSW50ZXJzZWN0aW9uKGEsIGIsIHBzW2ldLCBwc1soaSArIDEpICUgcHMubGVuZ3RoXSwgaXNjKTtcbiAgICB2YXIgZmlzYyA9IGlzY3NbMF07XG4gICAgdmFyIGxpc2MgPSBpc2NzW2lzY3MubGVuZ3RoIC0gMV07XG4gICAgLy8gJiYgKGlzYy54IT1wc1tpXS54IHx8IGlzYy55IT1wc1tpXS55KSApXG4gICAgaWYgKGlzYyAmJiAoZmlzYyA9PSBudWxsIHx8IGRpc3RhbmNlKGlzYywgZmlzYykgPiAxZS0xMCkgJiYgKGxpc2MgPT0gbnVsbCB8fCBkaXN0YW5jZShpc2MsIGxpc2MpID4gMWUtMTApKSB7XG4gICAgICBpc2MuZmxhZyA9IHRydWU7XG4gICAgICBpc2NzLnB1c2goaXNjKTtcbiAgICAgIHBzLnNwbGljZShpICsgMSwgMCwgaXNjKTtcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cblxuICBpZiAoaXNjcy5sZW5ndGggPCAyKSByZXR1cm4gW3Auc2xpY2UoMCldXG4gIHZhciBjb21wID0gZnVuY3Rpb24gKHUsIHYpIHsgcmV0dXJuIGRpc3RhbmNlKGEsIHUpIC0gZGlzdGFuY2UoYSwgdikgfTtcbiAgaXNjcy5zb3J0KGNvbXApO1xuXG4gIHZhciBwZ3MgPSBbXTtcbiAgdmFyIGRpciA9IDA7XG4gIHdoaWxlIChpc2NzLmxlbmd0aCA+IDApIHtcbiAgICAvLyB2YXIgbiA9IHBzLmxlbmd0aCAvLyBpcyBhc3NpZ25lZCBhIHZhbHVlIGJ1dCBuZXZlciB1c2VkLiAobm8tdW51c2VkLXZhcnMpXG4gICAgdmFyIGkwID0gaXNjc1swXTtcbiAgICB2YXIgaTEgPSBpc2NzWzFdO1xuICAgIC8vIGlmKGkwLng9PWkxLnggJiYgaTAueT09aTEueSkgeyBpc2NzLnNwbGljZSgwLDIpOyBjb250aW51ZTt9XG4gICAgdmFyIGluZGV4MCA9IHBzLmluZGV4T2YoaTApO1xuICAgIHZhciBpbmRleDEgPSBwcy5pbmRleE9mKGkxKTtcbiAgICB2YXIgc29sdmVkID0gZmFsc2U7XG5cbiAgICBpZiAoZmlyc3RXaXRoRmxhZyhwcywgaW5kZXgwKSA9PT0gaW5kZXgxKSB7XG4gICAgICBzb2x2ZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpMCA9IGlzY3NbMV07XG4gICAgICBpMSA9IGlzY3NbMF07XG4gICAgICBpbmRleDAgPSBwcy5pbmRleE9mKGkwKTtcbiAgICAgIGluZGV4MSA9IHBzLmluZGV4T2YoaTEpO1xuICAgICAgaWYgKGZpcnN0V2l0aEZsYWcocHMsIGluZGV4MCkgPT09IGluZGV4MSkgc29sdmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHNvbHZlZCkge1xuICAgICAgZGlyLS07XG4gICAgICB2YXIgcGduID0gZ2V0UG9pbnRzKHBzLCBpbmRleDAsIGluZGV4MSk7XG4gICAgICBwZ3MucHVzaChwZ24pO1xuICAgICAgcHMgPSBnZXRQb2ludHMocHMsIGluZGV4MSwgaW5kZXgwKTtcbiAgICAgIGkwLmZsYWcgPSBpMS5mbGFnID0gZmFsc2U7XG4gICAgICBpc2NzLnNwbGljZSgwLCAyKTtcbiAgICAgIGlmIChpc2NzLmxlbmd0aCA9PSAwKSBwZ3MucHVzaChwcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpcisrO1xuICAgICAgaXNjcy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIGlmIChkaXIgPiAxKSBicmVha1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwZ3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGcgPSBwZ3NbaV07XG4gICAgdmFyIG5wZyA9IFtdO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGcubGVuZ3RoOyBqKyspIHsgbnBnLnB1c2gocGdbal0ueCwgcGdbal0ueSk7IH1cbiAgICByZXN1bHQucHVzaChucGcpO1xuICB9XG4gIHJldHVybiByZXN1bHRcbn1cbm1vZHVsZS5leHBvcnRzLlNsaWNlID0gU2xpY2U7XG5cbi8qKlxuICogQ2hlY2tzLCBpZiBwb2x5Z29uIGNvbnRhaW5zIFt4LCB5XS5cbiAqXG4gKiBXb3JrcyB3aXRoIHNpbXBsZSBwb2x5Z29ucyBvbmx5LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyW119IHBvbHlnb24gW3gxLCB5MSwgeDIsIHkyLi4uXVxuICogQHBhcmFtIHtudW1iZXJ9IHBvaW50WCBDb29yZGluYXRlIFt4XVxuICogQHBhcmFtIHtudW1iZXJ9IHBvaW50WSBDb29yZGluYXRlIFt5XVxuICogQHJldHVybnMge2Jvb2xlYW59IGRlcHRoXG4gKi9cbmZ1bmN0aW9uIENvbnRhaW5zUG9pbnQgKHBvbHlnb24sIHBvaW50WCwgcG9pbnRZKSB7XG4gIHZhciBwID0gcG9seWdvbjtcbiAgdmFyIHB4ID0gcG9pbnRYO1xuICB2YXIgcHkgPSBwb2ludFk7XG4gIHZhciBuID0gcC5sZW5ndGggPj4gMTtcbiAgdmFyIGF4O1xuICB2YXIgYXkgPSBwWzIgKiBuIC0gM10gLSBweTtcbiAgdmFyIGJ4ID0gcFsyICogbiAtIDJdIC0gcHg7XG4gIHZhciBieSA9IHBbMiAqIG4gLSAxXSAtIHB5O1xuXG4gIC8vIHZhciBsdXAgPSBieSA+IGF5O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGF4ID0gYng7XG4gICAgYXkgPSBieTtcbiAgICBieCA9IHBbMiAqIGldIC0gcHg7XG4gICAgYnkgPSBwWzIgKiBpICsgMV0gLSBweTtcbiAgICBpZiAoYXkgPT09IGJ5KSBjb250aW51ZVxuICAgIHZhciBsdXAgPSBieSA+IGF5O1xuICB9XG5cbiAgdmFyIGRlcHRoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBheCA9IGJ4O1xuICAgIGF5ID0gYnk7XG4gICAgYnggPSBwWzIgKiBpXSAtIHB4O1xuICAgIGJ5ID0gcFsyICogaSArIDFdIC0gcHk7XG4gICAgaWYgKGF5IDwgMCAmJiBieSA8IDApIGNvbnRpbnVlICAvLyBib3RoIFwidXBcIiBvciBib3RoIFwiZG93blwiXG4gICAgaWYgKGF5ID4gMCAmJiBieSA+IDApIGNvbnRpbnVlICAvLyBib3RoIFwidXBcIiBvciBib3RoIFwiZG93blwiXG4gICAgaWYgKGF4IDwgMCAmJiBieCA8IDApIGNvbnRpbnVlICAgLy8gYm90aCBwb2ludHMgb24gdGhlIGxlZnRcblxuICAgIGlmIChheSA9PT0gYnkgJiYgTWF0aC5taW4oYXgsIGJ4KSA8PSAwKSByZXR1cm4gdHJ1ZVxuICAgIGlmIChheSA9PT0gYnkpIGNvbnRpbnVlXG5cbiAgICB2YXIgbHggPSBheCArIChieCAtIGF4KSAqICgtYXkpIC8gKGJ5IC0gYXkpO1xuICAgIGlmIChseCA9PT0gMCkgcmV0dXJuIHRydWUgICAgICAvLyBwb2ludCBvbiBlZGdlXG4gICAgaWYgKGx4ID4gMCkgZGVwdGgrKztcbiAgICBpZiAoYXkgPT09IDAgJiYgbHVwICYmIGJ5ID4gYXkpIGRlcHRoLS07ICAvLyBoaXQgdmVydGV4LCBib3RoIHVwXG4gICAgaWYgKGF5ID09PSAwICYmICFsdXAgJiYgYnkgPCBheSkgZGVwdGgtLTsgLy8gaGl0IHZlcnRleCwgYm90aCBkb3duXG4gICAgbHVwID0gYnkgPiBheTtcbiAgfVxuICByZXR1cm4gKGRlcHRoICYgMSkgPT09IDFcbn1cbm1vZHVsZS5leHBvcnRzLkNvbnRhaW5zUG9pbnQgPSBDb250YWluc1BvaW50O1xuXG4vKipcbiAqIEZpbmRzIHRoZSBjbG9zZXN0IHBvaW50IG9mIHBvbHlnb24sIHdoaWNoIGxheXMgb24gcmF5IGRlZmluZWQgYnkgW3gseV0gKG9yaWdpbikgYW5kIFtkeCxkeV0gKGRpcmVjdGlvbikuXG4gKlxuICogXCJkaXN0XCIgaXMgdGhlIGRpc3RhbmNlIG9mIHRoZSBwb2x5Z29uIHBvaW50LCBcImVkZ2VcIiBpcyB0aGUgbnVtYmVyIG9mIHRoZSBlZGdlLCBvbiB3aGljaCBpbnRlcnNlY3Rpb24gb2NjdXJzLCBcIm5vcm1cIiBpcyB0aGUgbm9ybWFsIGluIHRoYXQgcGxhY2UsIFwicmVmbFwiIGlzIHJlZmxlY3RlZCBkaXJlY3Rpb24uXG4gKlxuICogV29ya3Mgd2l0aCBzaW1wbGUgcG9seWdvbnMgb25seS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSBwb2x5Z29uIFt4MSwgeTEsIHgyLCB5Mi4uLl1cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcmlnaW5YIE9yaWdpbiBbeF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcmlnaW5ZIE9yaWdpbiBbeV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb25YIERpcmVjdGlvbiBbeF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb25ZIERpcmVjdGlvbiBbeV1cbiAqIEByZXR1cm5zIHtSYXljYXN0fVxuICogQGV4YW1wbGVcbiAqIC8vPXtkaXN0OjAsIGVkZ2U6MCwgbm9ybTp7eDowLCB5OjB9LCByZWZsOnt4OjAsIHk6MH19XG4gKi9cbmZ1bmN0aW9uIFJheWNhc3QgKHBvbHlnb24sIG9yaWdpblgsIG9yaWdpblksIGRpcmVjdGlvblgsIGRpcmVjdGlvblksIGlzYykge1xuICB2YXIgcCA9IHBvbHlnb247XG4gIHZhciB4ID0gb3JpZ2luWDtcbiAgdmFyIHkgPSBvcmlnaW5ZO1xuICB2YXIgZHggPSBkaXJlY3Rpb25YO1xuICB2YXIgZHkgPSBkaXJlY3Rpb25ZO1xuICB2YXIgbCA9IHAubGVuZ3RoIC0gMjtcbiAgdmFyIGVtcHR5ID0gZW1wdHlQb2ludHMoKTtcbiAgdmFyIGExID0gZW1wdHlbMF07XG4gIHZhciBhMiA9IGVtcHR5WzFdO1xuICB2YXIgYjEgPSBlbXB0eVsyXTtcbiAgdmFyIGIyID0gZW1wdHlbM107XG4gIHZhciBjID0gZW1wdHlbNF07XG4gIGExLnggPSB4O1xuICBhMS55ID0geTtcbiAgYTIueCA9IHggKyBkeDtcbiAgYTIueSA9IHkgKyBkeTtcblxuICBpZiAoaXNjID09PSBudWxsIHx8IGlzYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaXNjID0ge2Rpc3Q6IDAsIGVkZ2U6IDAsIG5vcm06IHt4OiAwLCB5OiAwfSwgcmVmbDoge3g6IDAsIHk6IDB9fTtcbiAgfVxuICBpc2MuZGlzdCA9IEluZmluaXR5O1xuXG4gIHZhciBuaXNjO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkgKz0gMikge1xuICAgIGIxLnggPSBwW2ldO1xuICAgIGIxLnkgPSBwW2kgKyAxXTtcbiAgICBiMi54ID0gcFtpICsgMl07XG4gICAgYjIueSA9IHBbaSArIDNdO1xuICAgIG5pc2MgPSBSYXlMaW5lSW50ZXJzZWN0aW9uKGExLCBhMiwgYjEsIGIyLCBjKTtcbiAgICBpZiAobmlzYykge1xuICAgICAgaXNjID0gdXBkYXRlSVNDKGR4LCBkeSwgYTEsIGIxLCBiMiwgYywgaSAvIDIsIGlzYyk7XG4gICAgfVxuICB9XG4gIGIxLnggPSBiMi54O1xuICBiMS55ID0gYjIueTtcbiAgYjIueCA9IHBbMF07XG4gIGIyLnkgPSBwWzFdO1xuICBuaXNjID0gUmF5TGluZUludGVyc2VjdGlvbihhMSwgYTIsIGIxLCBiMiwgYyk7XG4gIGlmIChuaXNjKSB7XG4gICAgaXNjID0gdXBkYXRlSVNDKGR4LCBkeSwgYTEsIGIxLCBiMiwgYywgKHAubGVuZ3RoIC8gMikgLSAxLCBpc2MpO1xuICB9XG5cbiAgcmV0dXJuIChpc2MuZGlzdCAhPT0gSW5maW5pdHkpID8gaXNjIDogbnVsbFxufVxubW9kdWxlLmV4cG9ydHMuUmF5Y2FzdCA9IFJheWNhc3Q7XG5cbi8qKlxuICogRmluZHMgdGhlIHBvaW50IG9uIHBvbHlnb24gZWRnZXMsIHdoaWNoIGlzIGNsb3Nlc3QgdG8gW3gseV0uIFJldHVybnMgYW4gb2JqZWN0IGluIHRoaXMgZm9ybWF0XG4gKlxuICogXCJkaXN0XCIgaXMgdGhlIGRpc3RhbmNlIG9mIHRoZSBwb2x5Z29uIHBvaW50LCBcImVkZ2VcIiBpcyB0aGUgbnVtYmVyIG9mIHRoZSBjbG9zZXN0IGVkZ2UsIFwicG9pbnRcIiBpcyB0aGUgY2xvc2VzdCBwb2ludCBvbiB0aGF0IGVkZ2UsIFwibm9ybVwiIGlzIHRoZSBub3JtYWwgZnJvbSBcInBvaW50XCIgdG8gW3gseV0uXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gcG9seWdvbiBbeDEsIHkxLCB4MiwgeTIuLi5dXG4gKiBAcGFyYW0ge251bWJlcn0geCBDb29yZGluYXRlIFt4XVxuICogQHBhcmFtIHtudW1iZXJ9IHkgQ29vcmRpbmF0ZSBbeV1cbiAqIEByZXR1cm5zIHtDbG9zZXN0RWRnZX1cbiAqIEBleGFtcGxlXG4gKiAvLz17ZGlzdDowLCBlZGdlOjAsIHBvaW50Ont4OjAsIHk6MH0sIG5vcm06e3g6MCwgeTowfX1cbiAqL1xuZnVuY3Rpb24gQ2xvc2VzdEVkZ2UgKHBvbHlnb24sIHgsIHksIGlzYykge1xuICB2YXIgcCA9IHBvbHlnb247XG4gIHZhciBsID0gcC5sZW5ndGggLSAyO1xuICB2YXIgZW1wdHkgPSBlbXB0eVBvaW50cygpO1xuICB2YXIgYTEgPSBlbXB0eVswXTtcbiAgdmFyIGIxID0gZW1wdHlbMl07XG4gIHZhciBiMiA9IGVtcHR5WzNdO1xuICAvLyB2YXIgYyA9IHRwWzRdIC8vIGlzIGFzc2lnbmVkIGEgdmFsdWUgYnV0IG5ldmVyIHVzZWQuXG4gIGExLnggPSB4O1xuICBhMS55ID0geTtcblxuICBpZiAoaXNjID09IG51bGwpIHtcbiAgICBpc2MgPSB7ZGlzdDogMCwgZWRnZTogMCwgcG9pbnQ6IHt4OiAwLCB5OiAwfSwgbm9ybToge3g6IDAsIHk6IDB9fTtcbiAgfVxuICBpc2MuZGlzdCA9IEluZmluaXR5O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgYjEueCA9IHBbaV07XG4gICAgYjEueSA9IHBbaSArIDFdO1xuICAgIGIyLnggPSBwW2kgKyAyXTtcbiAgICBiMi55ID0gcFtpICsgM107XG4gICAgaXNjID0gcG9pbnRMaW5lRGlzdChhMSwgYjEsIGIyLCBpID4+IDEsIGlzYyk7XG4gIH1cbiAgYjEueCA9IGIyLng7XG4gIGIxLnkgPSBiMi55O1xuICBiMi54ID0gcFswXTtcbiAgYjIueSA9IHBbMV07XG4gIGlzYyA9IHBvaW50TGluZURpc3QoYTEsIGIxLCBiMiwgbCA+PiAxLCBpc2MpO1xuXG4gIHZhciBpZHN0ID0gMSAvIGlzYy5kaXN0O1xuICBpc2Mubm9ybS54ID0gKHggLSBpc2MucG9pbnQueCkgKiBpZHN0O1xuICBpc2Mubm9ybS55ID0gKHkgLSBpc2MucG9pbnQueSkgKiBpZHN0O1xuICByZXR1cm4gaXNjXG59XG5tb2R1bGUuZXhwb3J0cy5DbG9zZXN0RWRnZSA9IENsb3Nlc3RFZGdlO1xuXG4vKipcbiAqIFJldmVyc2VcbiAqXG4gKiBAcGFyYW0ge251bWJlcltdfSBwb2x5Z29uIFt4MSwgeTEsIHgyLCB5Mi4uLl1cbiAqL1xuZnVuY3Rpb24gUmV2ZXJzZSAocG9seWdvbikge1xuICB2YXIgcCA9IHBvbHlnb247XG4gIHZhciBucCA9IFtdO1xuICBmb3IgKHZhciBqID0gcC5sZW5ndGggLSAyOyBqID49IDA7IGogLT0gMikgeyBucC5wdXNoKHBbal0sIHBbaiArIDFdKTsgfVxuICByZXR1cm4gbnBcbn1cbm1vZHVsZS5leHBvcnRzLlJldmVyc2UgPSBSZXZlcnNlO1xuXG4vKipcbiAqIFBvaW50IExpbmUgRGlzdGFuY2VcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQb2ludH0gcFxuICogQHBhcmFtIHtQb2ludH0gYVxuICogQHBhcmFtIHtQb2ludH0gYlxuICogQHBhcmFtIHs/P30gZWRnZVxuICogQHBhcmFtIHs/P30gaXNjXG4gKiBAcmV0dXJucyB7Pz99IElTQ1xuICovXG5mdW5jdGlvbiBwb2ludExpbmVEaXN0IChwLCBhLCBiLCBlZGdlLCBpc2MpIHtcbiAgdmFyIHggPSBwLng7XG4gIHZhciB5ID0gcC55O1xuICB2YXIgeDEgPSBhLng7XG4gIHZhciB5MSA9IGEueTtcbiAgdmFyIHgyID0gYi54O1xuICB2YXIgeTIgPSBiLnk7XG5cbiAgdmFyIEEgPSB4IC0geDE7XG4gIHZhciBCID0geSAtIHkxO1xuICB2YXIgQyA9IHgyIC0geDE7XG4gIHZhciBEID0geTIgLSB5MTtcblxuICB2YXIgZG90ID0gQSAqIEMgKyBCICogRDtcbiAgdmFyIGxlblNxID0gQyAqIEMgKyBEICogRDtcbiAgdmFyIHBhcmFtID0gZG90IC8gbGVuU3E7XG5cbiAgdmFyIHh4O1xuICB2YXIgeXk7XG5cbiAgaWYgKHBhcmFtIDwgMCB8fCAoeDEgPT0geDIgJiYgeTEgPT0geTIpKSB7XG4gICAgeHggPSB4MTtcbiAgICB5eSA9IHkxO1xuICB9IGVsc2UgaWYgKHBhcmFtID4gMSkge1xuICAgIHh4ID0geDI7XG4gICAgeXkgPSB5MjtcbiAgfSBlbHNlIHtcbiAgICB4eCA9IHgxICsgcGFyYW0gKiBDO1xuICAgIHl5ID0geTEgKyBwYXJhbSAqIEQ7XG4gIH1cblxuICB2YXIgZHggPSB4IC0geHg7XG4gIHZhciBkeSA9IHkgLSB5eTtcbiAgdmFyIGRzdCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIGlmIChkc3QgPCBpc2MuZGlzdCkge1xuICAgIGlzYy5kaXN0ID0gZHN0O1xuICAgIGlzYy5lZGdlID0gZWRnZTtcbiAgICBpc2MucG9pbnQueCA9IHh4O1xuICAgIGlzYy5wb2ludC55ID0geXk7XG4gIH1cbiAgcmV0dXJuIGlzY1xufVxuXG4vKipcbiAqIFVwZGF0ZSBJU0NcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGR4XG4gKiBAcGFyYW0ge251bWJlcn0gZHlcbiAqIEBwYXJhbSB7UG9pbnR9IGExXG4gKiBAcGFyYW0ge1BvaW50fSBiMVxuICogQHBhcmFtIHtQb2ludH0gYjJcbiAqIEBwYXJhbSB7UG9pbnR9IGNcbiAqIEBwYXJhbSB7Pz99IGVkZ2VcbiAqIEBwYXJhbSB7Pz99IGlzY1xuICogQHJldHVybnMgez8/fVxuICovXG5mdW5jdGlvbiB1cGRhdGVJU0MgKGR4LCBkeSwgYTEsIGIxLCBiMiwgYywgZWRnZSwgaXNjKSB7XG4gIHZhciBucmwgPSBkaXN0YW5jZShhMSwgYyk7XG4gIGlmIChucmwgPCBpc2MuZGlzdCkge1xuICAgIHZhciBpYmwgPSAxIC8gZGlzdGFuY2UoYjEsIGIyKTtcbiAgICB2YXIgbnggPSAtKGIyLnkgLSBiMS55KSAqIGlibDtcbiAgICB2YXIgbnkgPSAoYjIueCAtIGIxLngpICogaWJsO1xuICAgIHZhciBkZG90ID0gMiAqIChkeCAqIG54ICsgZHkgKiBueSk7XG4gICAgaXNjLmRpc3QgPSBucmw7XG4gICAgaXNjLm5vcm0ueCA9IG54O1xuICAgIGlzYy5ub3JtLnkgPSBueTtcbiAgICBpc2MucmVmbC54ID0gLWRkb3QgKiBueCArIGR4O1xuICAgIGlzYy5yZWZsLnkgPSAtZGRvdCAqIG55ICsgZHk7XG4gICAgaXNjLmVkZ2UgPSBlZGdlO1xuICB9XG4gIHJldHVybiBpc2Ncbn1cblxuLyoqXG4gKiBHZXQgUG9pbnRzXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyW119IHBvaW50c1xuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4MFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4MVxuICogQHJldHVybnMge251bWJlcltdfSBwb2ludHNcbiAqL1xuZnVuY3Rpb24gZ2V0UG9pbnRzIChwb2ludHMsIGluZGV4MCwgaW5kZXgxKSB7XG4gIHZhciBuID0gcG9pbnRzLmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoaW5kZXgxIDwgaW5kZXgwKSBpbmRleDEgKz0gbjtcbiAgZm9yICh2YXIgaSA9IGluZGV4MDsgaSA8PSBpbmRleDE7IGkrKykgeyByZXN1bHQucHVzaChwb2ludHNbaSAlIG5dKTsgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogRmlyc3QgV2l0aCBGbGFnXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UG9pbnRbXX0gcG9pbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGZpcnN0V2l0aEZsYWcgKHBvaW50cywgaW5kZXgpIHtcbiAgdmFyIG4gPSBwb2ludHMubGVuZ3RoO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGluZGV4ID0gKGluZGV4ICsgMSkgJSBuO1xuICAgIGlmIChwb2ludHNbaW5kZXhdLmZsYWcpIHtcbiAgICAgIHJldHVybiBpbmRleFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFBvaW50IGluIFRyaWFuZ2xlXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBweFxuICogQHBhcmFtIHtudW1iZXJ9IHB5XG4gKiBAcGFyYW0ge251bWJlcn0gYXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBheVxuICogQHBhcmFtIHtudW1iZXJ9IGJ4XG4gKiBAcGFyYW0ge251bWJlcn0gYnlcbiAqIEBwYXJhbSB7bnVtYmVyfSBjeFxuICogQHBhcmFtIHtudW1iZXJ9IGN5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gUG9pbnRJblRyaWFuZ2xlIChweCwgcHksIGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpIHtcbiAgdmFyIHYweCA9IGN4IC0gYXg7XG4gIHZhciB2MHkgPSBjeSAtIGF5O1xuICB2YXIgdjF4ID0gYnggLSBheDtcbiAgdmFyIHYxeSA9IGJ5IC0gYXk7XG4gIHZhciB2MnggPSBweCAtIGF4O1xuICB2YXIgdjJ5ID0gcHkgLSBheTtcblxuICB2YXIgZG90MDAgPSB2MHggKiB2MHggKyB2MHkgKiB2MHk7XG4gIHZhciBkb3QwMSA9IHYweCAqIHYxeCArIHYweSAqIHYxeTtcbiAgdmFyIGRvdDAyID0gdjB4ICogdjJ4ICsgdjB5ICogdjJ5O1xuICB2YXIgZG90MTEgPSB2MXggKiB2MXggKyB2MXkgKiB2MXk7XG4gIHZhciBkb3QxMiA9IHYxeCAqIHYyeCArIHYxeSAqIHYyeTtcblxuICB2YXIgaW52RGVub20gPSAxIC8gKGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxKTtcbiAgdmFyIHUgPSAoZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIpICogaW52RGVub207XG4gIHZhciB2ID0gKGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyKSAqIGludkRlbm9tO1xuXG4gIC8vIENoZWNrIGlmIHBvaW50IGlzIGluIHRyaWFuZ2xlXG4gIHJldHVybiAodSA+PSAwKSAmJiAodiA+PSAwKSAmJiAodSArIHYgPCAxKVxufVxuXG4vKipcbiAqIFJheUxpbmUgSW50ZXJzZWN0aW9uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UG9pbnR9IGExXG4gKiBAcGFyYW0ge1BvaW50fSBhMlxuICogQHBhcmFtIHtQb2ludH0gYjFcbiAqIEBwYXJhbSB7UG9pbnR9IGIyXG4gKiBAcGFyYW0ge1BvaW50fSBjXG4gKi9cbmZ1bmN0aW9uIFJheUxpbmVJbnRlcnNlY3Rpb24gKGExLCBhMiwgYjEsIGIyLCBjKSB7XG4gIHZhciBkYXggPSAoYTEueCAtIGEyLngpO1xuICB2YXIgZGJ4ID0gKGIxLnggLSBiMi54KTtcbiAgdmFyIGRheSA9IChhMS55IC0gYTIueSk7XG4gIHZhciBkYnkgPSAoYjEueSAtIGIyLnkpO1xuXG4gIHZhciBEZW4gPSBkYXggKiBkYnkgLSBkYXkgKiBkYng7XG4gIGlmIChEZW4gPT0gMCkgcmV0dXJuIG51bGwgIC8vIHBhcmFsbGVsXG5cbiAgdmFyIEEgPSAoYTEueCAqIGEyLnkgLSBhMS55ICogYTIueCk7XG4gIHZhciBCID0gKGIxLnggKiBiMi55IC0gYjEueSAqIGIyLngpO1xuXG4gIHZhciBJID0gYztcbiAgdmFyIGlEZW4gPSAxIC8gRGVuO1xuICBJLnggPSAoQSAqIGRieCAtIGRheCAqIEIpICogaURlbjtcbiAgSS55ID0gKEEgKiBkYnkgLSBkYXkgKiBCKSAqIGlEZW47XG5cbiAgaWYgKCFJblJlY3RhbmdsZShJLCBiMSwgYjIpKSByZXR1cm4gbnVsbFxuICBpZiAoKGRheSA+IDAgJiYgSS55ID4gYTEueSkgfHwgKGRheSA8IDAgJiYgSS55IDwgYTEueSkpIHJldHVybiBudWxsXG4gIGlmICgoZGF4ID4gMCAmJiBJLnggPiBhMS54KSB8fCAoZGF4IDwgMCAmJiBJLnggPCBhMS54KSkgcmV0dXJuIG51bGxcbiAgcmV0dXJuIElcbn1cblxuLyoqXG4gKiBHZXQgTGluZSBJbnRlcnNlY3Rpb25cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQb2ludH0gYTFcbiAqIEBwYXJhbSB7UG9pbnR9IGEyXG4gKiBAcGFyYW0ge1BvaW50fSBiMVxuICogQHBhcmFtIHtQb2ludH0gYjJcbiAqIEBwYXJhbSB7UG9pbnR9IGNcbiAqIEByZXR1cm5zIHtQb2ludH1cbiAqL1xuZnVuY3Rpb24gR2V0TGluZUludGVyc2VjdGlvbiAoYTEsIGEyLCBiMSwgYjIsIGMpIHtcbiAgdmFyIGRheCA9IChhMS54IC0gYTIueCk7XG4gIHZhciBkYnggPSAoYjEueCAtIGIyLngpO1xuICB2YXIgZGF5ID0gKGExLnkgLSBhMi55KTtcbiAgdmFyIGRieSA9IChiMS55IC0gYjIueSk7XG5cbiAgdmFyIERlbiA9IGRheCAqIGRieSAtIGRheSAqIGRieDtcblxuICBpZiAoRGVuID09PSAwKSB7IHJldHVybiBudWxsIH0gLy8gcGFyYWxsZWxcblxuICB2YXIgQSA9IChhMS54ICogYTIueSAtIGExLnkgKiBhMi54KTtcbiAgdmFyIEIgPSAoYjEueCAqIGIyLnkgLSBiMS55ICogYjIueCk7XG5cbiAgdmFyIEkgPSBjO1xuICBJLnggPSAoQSAqIGRieCAtIGRheCAqIEIpIC8gRGVuO1xuICBJLnkgPSAoQSAqIGRieSAtIGRheSAqIEIpIC8gRGVuO1xuXG4gIGlmIChJblJlY3RhbmdsZShJLCBhMSwgYTIpICYmIEluUmVjdGFuZ2xlKEksIGIxLCBiMikpIHtcbiAgICByZXR1cm4gSVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbi8qKlxuICogSW4gUmVjdGFuZ2xlXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UG9pbnR9IGFcbiAqIEBwYXJhbSB7UG9pbnR9IGJcbiAqIEBwYXJhbSB7UG9pbnR9IGNcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIEluUmVjdGFuZ2xlIChhLCBiLCBjKSB7XG4gIHZhciBtaW54ID0gTWF0aC5taW4oYi54LCBjLngpO1xuICB2YXIgbWF4eCA9IE1hdGgubWF4KGIueCwgYy54KTtcbiAgdmFyIG1pbnkgPSBNYXRoLm1pbihiLnksIGMueSk7XG4gIHZhciBtYXh5ID0gTWF0aC5tYXgoYi55LCBjLnkpO1xuXG4gIGlmIChtaW54ID09PSBtYXh4KSB7IHJldHVybiAobWlueSA8PSBhLnkgJiYgYS55IDw9IG1heHkpIH1cbiAgaWYgKG1pbnkgPT09IG1heHkpIHsgcmV0dXJuIChtaW54IDw9IGEueCAmJiBhLnggPD0gbWF4eCkgfVxuXG4gIC8vIHJldHVybiAobWlueCA8PSBhLnggJiYgYS54IDw9IG1heHggJiYgbWlueSA8PSBhLnkgJiYgYS55IDw9IG1heHkpXG4gIHJldHVybiAobWlueCA8PSBhLnggKyAxZS0xMCAmJiBhLnggLSAxZS0xMCA8PSBtYXh4ICYmIG1pbnkgPD0gYS55ICsgMWUtMTAgJiYgYS55IC0gMWUtMTAgPD0gbWF4eSlcbn1cblxuLyoqXG4gKiBDb252ZXhcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQb2ludH0gYXhcbiAqIEBwYXJhbSB7UG9pbnR9IGF5XG4gKiBAcGFyYW0ge1BvaW50fSBieFxuICogQHBhcmFtIHtQb2ludH0gYnlcbiAqIEBwYXJhbSB7UG9pbnR9IGN4XG4gKiBAcGFyYW0ge1BvaW50fSBjeVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbnZleCAoYXgsIGF5LCBieCwgYnksIGN4LCBjeSkge1xuICByZXR1cm4gKGF5IC0gYnkpICogKGN4IC0gYngpICsgKGJ4IC0gYXgpICogKGN5IC0gYnkpID49IDBcbn1cblxuLyoqXG4gKiBQb2ludFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEByZXR1cm5zIHtQb2ludH1cbiAqL1xuZnVuY3Rpb24gUG9pbnQgKHgsIHkpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgZmxhZzogZmFsc2UsXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdQb2ludCBbJyArIHggKyAnLCAnICsgeSArICddJyB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXN0YW5jZVxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BvaW50fSBhXG4gKiBAcGFyYW0ge1BvaW50fSBiXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBkaXN0YW5jZSAoYSwgYikge1xuICB2YXIgZHggPSBiLnggLSBhLng7XG4gIHZhciBkeSA9IGIueSAtIGEueTtcbiAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVtcHR5IFBvaW50c1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gW251bT0xMF0gTnVtYmVyIG9mIHBvaW50c1xuICogQHJldHVybnMge1BvaW50W119XG4gKi9cbmZ1bmN0aW9uIGVtcHR5UG9pbnRzIChudW0pIHtcbiAgbnVtID0gbnVtIHx8IDEwO1xuICB2YXIgY29udGFpbmVyID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtOyBpKyspIHsgY29udGFpbmVyLnB1c2goUG9pbnQoMCwgMCkpOyB9XG4gIHJldHVybiBjb250YWluZXJcbn1cblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvbHlrLmpzLm1hcFxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxuXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovdmFyIHQ9ZnVuY3Rpb24oZSxuKXtyZXR1cm4odD1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24odCxlKXt0Ll9fcHJvdG9fXz1lfXx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIG4gaW4gZSllLmhhc093blByb3BlcnR5KG4pJiYodFtuXT1lW25dKX0pKGUsbil9O2Z1bmN0aW9uIGUoZSxuKXtmdW5jdGlvbiByKCl7dGhpcy5jb25zdHJ1Y3Rvcj1lfXQoZSxuKSxlLnByb3RvdHlwZT1udWxsPT09bj9PYmplY3QuY3JlYXRlKG4pOihyLnByb3RvdHlwZT1uLnByb3RvdHlwZSxuZXcgcil9ZnVuY3Rpb24gbigpe2Zvcih2YXIgdD0wLGU9MCxuPWFyZ3VtZW50cy5sZW5ndGg7ZTxuO2UrKyl0Kz1hcmd1bWVudHNbZV0ubGVuZ3RoO3ZhciByPUFycmF5KHQpLGE9MDtmb3IoZT0wO2U8bjtlKyspZm9yKHZhciBvPWFyZ3VtZW50c1tlXSxzPTAsaD1vLmxlbmd0aDtzPGg7cysrLGErKylyW2FdPW9bc107cmV0dXJuIHJ9ZnVuY3Rpb24gcih0LGUsbil7aWYodCYmdC5sZW5ndGgpe3ZhciByPWVbMF0sYT1lWzFdLG89TWF0aC5QSS8xODAqbixzPU1hdGguY29zKG8pLGg9TWF0aC5zaW4obyk7dC5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZT10WzBdLG49dFsxXTt0WzBdPShlLXIpKnMtKG4tYSkqaCtyLHRbMV09KGUtcikqaCsobi1hKSpzK2F9KSl9fWZ1bmN0aW9uIGEodCl7dmFyIGU9dFswXSxuPXRbMV07cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhlWzBdLW5bMF0sMikrTWF0aC5wb3coZVsxXS1uWzFdLDIpKX1mdW5jdGlvbiBvKHQsZSl7dmFyIGE9WzAsMF0sbz1NYXRoLnJvdW5kKGUuaGFjaHVyZUFuZ2xlKzkwKTtvJiZyKHQsYSxvKTt2YXIgcz1mdW5jdGlvbih0LGUpe3ZhciByPW4odCk7clswXS5qb2luKFwiLFwiKSE9PXJbci5sZW5ndGgtMV0uam9pbihcIixcIikmJnIucHVzaChbclswXVswXSxyWzBdWzFdXSk7dmFyIGE9W107aWYociYmci5sZW5ndGg+Mil7dmFyIG89ZS5oYWNodXJlR2FwO288MCYmKG89NCplLnN0cm9rZVdpZHRoKSxvPU1hdGgubWF4KG8sLjEpO2Zvcih2YXIgcz1bXSxoPTA7aDxyLmxlbmd0aC0xO2grKyl7dmFyIGk9cltoXSx1PXJbaCsxXTtpZihpWzFdIT09dVsxXSl7dmFyIHA9TWF0aC5taW4oaVsxXSx1WzFdKTtzLnB1c2goe3ltaW46cCx5bWF4Ok1hdGgubWF4KGlbMV0sdVsxXSkseDpwPT09aVsxXT9pWzBdOnVbMF0saXNsb3BlOih1WzBdLWlbMF0pLyh1WzFdLWlbMV0pfSl9fWlmKHMuc29ydCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC55bWluPGUueW1pbj8tMTp0LnltaW4+ZS55bWluPzE6dC54PGUueD8tMTp0Lng+ZS54PzE6dC55bWF4PT09ZS55bWF4PzA6KHQueW1heC1lLnltYXgpL01hdGguYWJzKHQueW1heC1lLnltYXgpfSkpLCFzLmxlbmd0aClyZXR1cm4gYTtmb3IodmFyIGM9W10sbD1zWzBdLnltaW47Yy5sZW5ndGh8fHMubGVuZ3RoOyl7aWYocy5sZW5ndGgpe3ZhciBmPS0xO2ZvcihoPTA7aDxzLmxlbmd0aCYmIShzW2hdLnltaW4+bCk7aCsrKWY9aDtzLnNwbGljZSgwLGYrMSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7Yy5wdXNoKHtzOmwsZWRnZTp0fSl9KSl9aWYoKGM9Yy5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiEodC5lZGdlLnltYXg8PWwpfSkpKS5zb3J0KChmdW5jdGlvbih0LGUpe3JldHVybiB0LmVkZ2UueD09PWUuZWRnZS54PzA6KHQuZWRnZS54LWUuZWRnZS54KS9NYXRoLmFicyh0LmVkZ2UueC1lLmVkZ2UueCl9KSksYy5sZW5ndGg+MSlmb3IoaD0wO2g8Yy5sZW5ndGg7aCs9Mil7dmFyIGQ9aCsxO2lmKGQ+PWMubGVuZ3RoKWJyZWFrO3ZhciBnPWNbaF0uZWRnZSx5PWNbZF0uZWRnZTthLnB1c2goW1tNYXRoLnJvdW5kKGcueCksbF0sW01hdGgucm91bmQoeS54KSxsXV0pfWwrPW8sYy5mb3JFYWNoKChmdW5jdGlvbih0KXt0LmVkZ2UueD10LmVkZ2UueCtvKnQuZWRnZS5pc2xvcGV9KSl9fXJldHVybiBhfSh0LGUpO3JldHVybiBvJiYocih0LGEsLW8pLGZ1bmN0aW9uKHQsZSxuKXt2YXIgYT1bXTt0LmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBhLnB1c2guYXBwbHkoYSx0KX0pKSxyKGEsZSxuKX0ocyxhLC1vKSksc312YXIgcz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5oZWxwZXI9dH1yZXR1cm4gdC5wcm90b3R5cGUuZmlsbFBvbHlnb249ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fZmlsbFBvbHlnb24odCxlKX0sdC5wcm90b3R5cGUuX2ZpbGxQb2x5Z29uPWZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj0hMSk7dmFyIHI9byh0LGUpO3JldHVybnt0eXBlOlwiZmlsbFNrZXRjaFwiLG9wczp0aGlzLnJlbmRlckxpbmVzKHIsZSxuKX19LHQucHJvdG90eXBlLnJlbmRlckxpbmVzPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIHI9W10sYT1udWxsLG89MCxzPXQ7bzxzLmxlbmd0aDtvKyspe3ZhciBoPXNbb107ci5wdXNoLmFwcGx5KHIsdGhpcy5oZWxwZXIuZG91YmxlTGluZU9wcyhoWzBdWzBdLGhbMF1bMV0saFsxXVswXSxoWzFdWzFdLGUpKSxuJiZhJiZyLnB1c2guYXBwbHkocix0aGlzLmhlbHBlci5kb3VibGVMaW5lT3BzKGFbMF0sYVsxXSxoWzBdWzBdLGhbMF1bMV0sZSkpLGE9aFsxXX1yZXR1cm4gcn0sdH0oKSxoPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4oKXtyZXR1cm4gbnVsbCE9PXQmJnQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfXJldHVybiBlKG4sdCksbi5wcm90b3R5cGUuZmlsbFBvbHlnb249ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fZmlsbFBvbHlnb24odCxlLCEwKX0sbn0ocyksaT1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKCl7cmV0dXJuIG51bGwhPT10JiZ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpc31yZXR1cm4gZShuLHQpLG4ucHJvdG90eXBlLmZpbGxQb2x5Z29uPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5fZmlsbFBvbHlnb24odCxlKSxyPU9iamVjdC5hc3NpZ24oe30sZSx7aGFjaHVyZUFuZ2xlOmUuaGFjaHVyZUFuZ2xlKzkwfSksYT10aGlzLl9maWxsUG9seWdvbih0LHIpO3JldHVybiBuLm9wcz1uLm9wcy5jb25jYXQoYS5vcHMpLG59LG59KHMpLHU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuaGVscGVyPXR9cmV0dXJuIHQucHJvdG90eXBlLmZpbGxQb2x5Z29uPWZ1bmN0aW9uKHQsZSl7dmFyIG49byh0LGU9T2JqZWN0LmFzc2lnbih7fSxlLHtjdXJ2ZVN0ZXBDb3VudDo0LGhhY2h1cmVBbmdsZTowLHJvdWdobmVzczoxfSkpO3JldHVybiB0aGlzLmRvdHNPbkxpbmVzKG4sZSl9LHQucHJvdG90eXBlLmRvdHNPbkxpbmVzPWZ1bmN0aW9uKHQsZSl7dmFyIG49W10scj1lLmhhY2h1cmVHYXA7cjwwJiYocj00KmUuc3Ryb2tlV2lkdGgpLHI9TWF0aC5tYXgociwuMSk7dmFyIG89ZS5maWxsV2VpZ2h0O288MCYmKG89ZS5zdHJva2VXaWR0aC8yKTtmb3IodmFyIHM9ci80LGg9MCxpPXQ7aDxpLmxlbmd0aDtoKyspZm9yKHZhciB1PWlbaF0scD1hKHUpLGM9cC9yLGw9TWF0aC5jZWlsKGMpLTEsZj1wLWwqcixkPSh1WzBdWzBdK3VbMV1bMF0pLzItci80LGc9TWF0aC5taW4odVswXVsxXSx1WzFdWzFdKSx5PTA7eTxsO3krKyl7dmFyIHY9ZytmK3kqcixNPXRoaXMuaGVscGVyLnJhbmRPZmZzZXRXaXRoUmFuZ2UoZC1zLGQrcyxlKSxrPXRoaXMuaGVscGVyLnJhbmRPZmZzZXRXaXRoUmFuZ2Uodi1zLHYrcyxlKSxiPXRoaXMuaGVscGVyLmVsbGlwc2UoTSxrLG8sbyxlKTtuLnB1c2guYXBwbHkobixiLm9wcyl9cmV0dXJue3R5cGU6XCJmaWxsU2tldGNoXCIsb3BzOm59fSx0fSgpLHA9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuaGVscGVyPXR9cmV0dXJuIHQucHJvdG90eXBlLmZpbGxQb2x5Z29uPWZ1bmN0aW9uKHQsZSl7dmFyIG49byh0LGUpO3JldHVybnt0eXBlOlwiZmlsbFNrZXRjaFwiLG9wczp0aGlzLmRhc2hlZExpbmUobixlKX19LHQucHJvdG90eXBlLmRhc2hlZExpbmU9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLHI9ZS5kYXNoT2Zmc2V0PDA/ZS5oYWNodXJlR2FwPDA/NCplLnN0cm9rZVdpZHRoOmUuaGFjaHVyZUdhcDplLmRhc2hPZmZzZXQsbz1lLmRhc2hHYXA8MD9lLmhhY2h1cmVHYXA8MD80KmUuc3Ryb2tlV2lkdGg6ZS5oYWNodXJlR2FwOmUuZGFzaEdhcCxzPVtdO3JldHVybiB0LmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBoPWEodCksaT1NYXRoLmZsb29yKGgvKHIrbykpLHU9KGgrby1pKihyK28pKS8yLHA9dFswXSxjPXRbMV07cFswXT5jWzBdJiYocD10WzFdLGM9dFswXSk7Zm9yKHZhciBsPU1hdGguYXRhbigoY1sxXS1wWzFdKS8oY1swXS1wWzBdKSksZj0wO2Y8aTtmKyspe3ZhciBkPWYqKHIrbyksZz1kK3IseT1bcFswXStkKk1hdGguY29zKGwpK3UqTWF0aC5jb3MobCkscFsxXStkKk1hdGguc2luKGwpK3UqTWF0aC5zaW4obCldLHY9W3BbMF0rZypNYXRoLmNvcyhsKSt1Kk1hdGguY29zKGwpLHBbMV0rZypNYXRoLnNpbihsKSt1Kk1hdGguc2luKGwpXTtzLnB1c2guYXBwbHkocyxuLmhlbHBlci5kb3VibGVMaW5lT3BzKHlbMF0seVsxXSx2WzBdLHZbMV0sZSkpfX0pKSxzfSx0fSgpLGM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuaGVscGVyPXR9cmV0dXJuIHQucHJvdG90eXBlLmZpbGxQb2x5Z29uPWZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5oYWNodXJlR2FwPDA/NCplLnN0cm9rZVdpZHRoOmUuaGFjaHVyZUdhcCxyPWUuemlnemFnT2Zmc2V0PDA/bjplLnppZ3phZ09mZnNldCxhPW8odCxlPU9iamVjdC5hc3NpZ24oe30sZSx7aGFjaHVyZUdhcDpuK3J9KSk7cmV0dXJue3R5cGU6XCJmaWxsU2tldGNoXCIsb3BzOnRoaXMuemlnemFnTGluZXMoYSxyLGUpfX0sdC5wcm90b3R5cGUuemlnemFnTGluZXM9ZnVuY3Rpb24odCxlLHIpe3ZhciBvPXRoaXMscz1bXTtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgaD1hKHQpLGk9TWF0aC5yb3VuZChoLygyKmUpKSx1PXRbMF0scD10WzFdO3VbMF0+cFswXSYmKHU9dFsxXSxwPXRbMF0pO2Zvcih2YXIgYz1NYXRoLmF0YW4oKHBbMV0tdVsxXSkvKHBbMF0tdVswXSkpLGw9MDtsPGk7bCsrKXt2YXIgZj0yKmwqZSxkPTIqKGwrMSkqZSxnPU1hdGguc3FydCgyKk1hdGgucG93KGUsMikpLHk9W3VbMF0rZipNYXRoLmNvcyhjKSx1WzFdK2YqTWF0aC5zaW4oYyldLHY9W3VbMF0rZCpNYXRoLmNvcyhjKSx1WzFdK2QqTWF0aC5zaW4oYyldLE09W3lbMF0rZypNYXRoLmNvcyhjK01hdGguUEkvNCkseVsxXStnKk1hdGguc2luKGMrTWF0aC5QSS80KV07cy5wdXNoLmFwcGx5KHMsbihvLmhlbHBlci5kb3VibGVMaW5lT3BzKHlbMF0seVsxXSxNWzBdLE1bMV0sciksby5oZWxwZXIuZG91YmxlTGluZU9wcyhNWzBdLE1bMV0sdlswXSx2WzFdLHIpKSl9fSkpLHN9LHR9KCksbD17fTt2YXIgZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5zZWVkPXR9cmV0dXJuIHQucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWVkPyhNYXRoLnBvdygyLDMxKS0xJih0aGlzLnNlZWQ9TWF0aC5pbXVsKDQ4MjcxLHRoaXMuc2VlZCkpKS9NYXRoLnBvdygyLDMxKTpNYXRoLnJhbmRvbSgpfSx0fSgpO2NvbnN0IGQ9e0E6NyxhOjcsQzo2LGM6NixIOjEsaDoxLEw6MixsOjIsTToyLG06MixROjQscTo0LFM6NCxzOjQsVDoyLHQ6MixWOjEsdjoxLFo6MCx6OjB9O2Z1bmN0aW9uIGcodCxlKXtyZXR1cm4gdC50eXBlPT09ZX1mdW5jdGlvbiB5KHQpe2NvbnN0IGU9W10sbj1mdW5jdGlvbih0KXtjb25zdCBlPW5ldyBBcnJheTtmb3IoO1wiXCIhPT10OylpZih0Lm1hdGNoKC9eKFsgXFx0XFxyXFxuLF0rKS8pKXQ9dC5zdWJzdHIoUmVnRXhwLiQxLmxlbmd0aCk7ZWxzZSBpZih0Lm1hdGNoKC9eKFthQWNDaEhsTG1NcVFzU3RUdlZ6Wl0pLykpZVtlLmxlbmd0aF09e3R5cGU6MCx0ZXh0OlJlZ0V4cC4kMX0sdD10LnN1YnN0cihSZWdFeHAuJDEubGVuZ3RoKTtlbHNle2lmKCF0Lm1hdGNoKC9eKChbLStdP1swLTldKyhcXC5bMC05XSopP3xbLStdP1xcLlswLTldKykoW2VFXVstK10/WzAtOV0rKT8pLykpcmV0dXJuW107ZVtlLmxlbmd0aF09e3R5cGU6MSx0ZXh0OlwiXCIrcGFyc2VGbG9hdChSZWdFeHAuJDEpfSx0PXQuc3Vic3RyKFJlZ0V4cC4kMS5sZW5ndGgpfXJldHVybiBlW2UubGVuZ3RoXT17dHlwZToyLHRleHQ6XCJcIn0sZX0odCk7bGV0IHI9XCJCT0RcIixhPTAsbz1uW2FdO2Zvcig7IWcobywyKTspe2xldCBzPTA7Y29uc3QgaD1bXTtpZihcIkJPRFwiPT09cil7aWYoXCJNXCIhPT1vLnRleHQmJlwibVwiIT09by50ZXh0KXJldHVybiB5KFwiTTAsMFwiK3QpO2ErKyxzPWRbby50ZXh0XSxyPW8udGV4dH1lbHNlIGcobywxKT9zPWRbcl06KGErKyxzPWRbby50ZXh0XSxyPW8udGV4dCk7aWYoIShhK3M8bi5sZW5ndGgpKXRocm93IG5ldyBFcnJvcihcIlBhdGggZGF0YSBlbmRlZCBzaG9ydFwiKTtmb3IobGV0IHQ9YTt0PGErczt0Kyspe2NvbnN0IGU9blt0XTtpZighZyhlLDEpKXRocm93IG5ldyBFcnJvcihcIlBhcmFtIG5vdCBhIG51bWJlcjogXCIrcitcIixcIitlLnRleHQpO2hbaC5sZW5ndGhdPStlLnRleHR9aWYoXCJudW1iZXJcIiE9dHlwZW9mIGRbcl0pdGhyb3cgbmV3IEVycm9yKFwiQmFkIHNlZ21lbnQ6IFwiK3IpO3tjb25zdCB0PXtrZXk6cixkYXRhOmh9O2UucHVzaCh0KSxhKz1zLG89blthXSxcIk1cIj09PXImJihyPVwiTFwiKSxcIm1cIj09PXImJihyPVwibFwiKX19cmV0dXJuIGV9ZnVuY3Rpb24gdih0KXtsZXQgZT0wLG49MCxyPTAsYT0wO2NvbnN0IG89W107Zm9yKGNvbnN0e2tleTpzLGRhdGE6aH1vZiB0KXN3aXRjaChzKXtjYXNlXCJNXCI6by5wdXNoKHtrZXk6XCJNXCIsZGF0YTpbLi4uaF19KSxbZSxuXT1oLFtyLGFdPWg7YnJlYWs7Y2FzZVwibVwiOmUrPWhbMF0sbis9aFsxXSxvLnB1c2goe2tleTpcIk1cIixkYXRhOltlLG5dfSkscj1lLGE9bjticmVhaztjYXNlXCJMXCI6by5wdXNoKHtrZXk6XCJMXCIsZGF0YTpbLi4uaF19KSxbZSxuXT1oO2JyZWFrO2Nhc2VcImxcIjplKz1oWzBdLG4rPWhbMV0sby5wdXNoKHtrZXk6XCJMXCIsZGF0YTpbZSxuXX0pO2JyZWFrO2Nhc2VcIkNcIjpvLnB1c2goe2tleTpcIkNcIixkYXRhOlsuLi5oXX0pLGU9aFs0XSxuPWhbNV07YnJlYWs7Y2FzZVwiY1wiOntjb25zdCB0PWgubWFwKCh0LHIpPT5yJTI/dCtuOnQrZSk7by5wdXNoKHtrZXk6XCJDXCIsZGF0YTp0fSksZT10WzRdLG49dFs1XTticmVha31jYXNlXCJRXCI6by5wdXNoKHtrZXk6XCJRXCIsZGF0YTpbLi4uaF19KSxlPWhbMl0sbj1oWzNdO2JyZWFrO2Nhc2VcInFcIjp7Y29uc3QgdD1oLm1hcCgodCxyKT0+ciUyP3Qrbjp0K2UpO28ucHVzaCh7a2V5OlwiUVwiLGRhdGE6dH0pLGU9dFsyXSxuPXRbM107YnJlYWt9Y2FzZVwiQVwiOm8ucHVzaCh7a2V5OlwiQVwiLGRhdGE6Wy4uLmhdfSksZT1oWzVdLG49aFs2XTticmVhaztjYXNlXCJhXCI6ZSs9aFs1XSxuKz1oWzZdLG8ucHVzaCh7a2V5OlwiQVwiLGRhdGE6W2hbMF0saFsxXSxoWzJdLGhbM10saFs0XSxlLG5dfSk7YnJlYWs7Y2FzZVwiSFwiOm8ucHVzaCh7a2V5OlwiSFwiLGRhdGE6Wy4uLmhdfSksZT1oWzBdO2JyZWFrO2Nhc2VcImhcIjplKz1oWzBdLG8ucHVzaCh7a2V5OlwiSFwiLGRhdGE6W2VdfSk7YnJlYWs7Y2FzZVwiVlwiOm8ucHVzaCh7a2V5OlwiVlwiLGRhdGE6Wy4uLmhdfSksbj1oWzBdO2JyZWFrO2Nhc2VcInZcIjpuKz1oWzBdLG8ucHVzaCh7a2V5OlwiVlwiLGRhdGE6W25dfSk7YnJlYWs7Y2FzZVwiU1wiOm8ucHVzaCh7a2V5OlwiU1wiLGRhdGE6Wy4uLmhdfSksZT1oWzJdLG49aFszXTticmVhaztjYXNlXCJzXCI6e2NvbnN0IHQ9aC5tYXAoKHQscik9PnIlMj90K246dCtlKTtvLnB1c2goe2tleTpcIlNcIixkYXRhOnR9KSxlPXRbMl0sbj10WzNdO2JyZWFrfWNhc2VcIlRcIjpvLnB1c2goe2tleTpcIlRcIixkYXRhOlsuLi5oXX0pLGU9aFswXSxuPWhbMV07YnJlYWs7Y2FzZVwidFwiOmUrPWhbMF0sbis9aFsxXSxvLnB1c2goe2tleTpcIlRcIixkYXRhOltlLG5dfSk7YnJlYWs7Y2FzZVwiWlwiOmNhc2VcInpcIjpvLnB1c2goe2tleTpcIlpcIixkYXRhOltdfSksZT1yLG49YX1yZXR1cm4gb31mdW5jdGlvbiBNKHQpe2NvbnN0IGU9W107bGV0IG49XCJcIixyPTAsYT0wLG89MCxzPTAsaD0wLGk9MDtmb3IoY29uc3R7a2V5OnUsZGF0YTpwfW9mIHQpe3N3aXRjaCh1KXtjYXNlXCJNXCI6ZS5wdXNoKHtrZXk6XCJNXCIsZGF0YTpbLi4ucF19KSxbcixhXT1wLFtvLHNdPXA7YnJlYWs7Y2FzZVwiQ1wiOmUucHVzaCh7a2V5OlwiQ1wiLGRhdGE6Wy4uLnBdfSkscj1wWzRdLGE9cFs1XSxoPXBbMl0saT1wWzNdO2JyZWFrO2Nhc2VcIkxcIjplLnB1c2goe2tleTpcIkxcIixkYXRhOlsuLi5wXX0pLFtyLGFdPXA7YnJlYWs7Y2FzZVwiSFwiOnI9cFswXSxlLnB1c2goe2tleTpcIkxcIixkYXRhOltyLGFdfSk7YnJlYWs7Y2FzZVwiVlwiOmE9cFswXSxlLnB1c2goe2tleTpcIkxcIixkYXRhOltyLGFdfSk7YnJlYWs7Y2FzZVwiU1wiOntsZXQgdD0wLG89MDtcIkNcIj09PW58fFwiU1wiPT09bj8odD1yKyhyLWgpLG89YSsoYS1pKSk6KHQ9cixvPWEpLGUucHVzaCh7a2V5OlwiQ1wiLGRhdGE6W3QsbywuLi5wXX0pLGg9cFswXSxpPXBbMV0scj1wWzJdLGE9cFszXTticmVha31jYXNlXCJUXCI6e2NvbnN0W3Qsb109cDtsZXQgcz0wLHU9MDtcIlFcIj09PW58fFwiVFwiPT09bj8ocz1yKyhyLWgpLHU9YSsoYS1pKSk6KHM9cix1PWEpO2NvbnN0IGM9cisyKihzLXIpLzMsbD1hKzIqKHUtYSkvMyxmPXQrMioocy10KS8zLGQ9bysyKih1LW8pLzM7ZS5wdXNoKHtrZXk6XCJDXCIsZGF0YTpbYyxsLGYsZCx0LG9dfSksaD1zLGk9dSxyPXQsYT1vO2JyZWFrfWNhc2VcIlFcIjp7Y29uc3RbdCxuLG8sc109cCx1PXIrMioodC1yKS8zLGM9YSsyKihuLWEpLzMsbD1vKzIqKHQtbykvMyxmPXMrMioobi1zKS8zO2UucHVzaCh7a2V5OlwiQ1wiLGRhdGE6W3UsYyxsLGYsbyxzXX0pLGg9dCxpPW4scj1vLGE9czticmVha31jYXNlXCJBXCI6e2NvbnN0IHQ9TWF0aC5hYnMocFswXSksbj1NYXRoLmFicyhwWzFdKSxvPXBbMl0scz1wWzNdLGg9cFs0XSxpPXBbNV0sdT1wWzZdO2lmKDA9PT10fHwwPT09billLnB1c2goe2tleTpcIkNcIixkYXRhOltyLGEsaSx1LGksdV19KSxyPWksYT11O2Vsc2UgaWYociE9PWl8fGEhPT11KXtiKHIsYSxpLHUsdCxuLG8scyxoKS5mb3JFYWNoKChmdW5jdGlvbih0KXtlLnB1c2goe2tleTpcIkNcIixkYXRhOnR9KX0pKSxyPWksYT11fWJyZWFrfWNhc2VcIlpcIjplLnB1c2goe2tleTpcIlpcIixkYXRhOltdfSkscj1vLGE9c31uPXV9cmV0dXJuIGV9ZnVuY3Rpb24gayh0LGUsbil7cmV0dXJuW3QqTWF0aC5jb3MobiktZSpNYXRoLnNpbihuKSx0Kk1hdGguc2luKG4pK2UqTWF0aC5jb3MobildfWZ1bmN0aW9uIGIodCxlLG4scixhLG8scyxoLGksdSl7Y29uc3QgcD0oYz1zLE1hdGguUEkqYy8xODApO3ZhciBjO2xldCBsPVtdLGY9MCxkPTAsZz0wLHk9MDtpZih1KVtmLGQsZyx5XT11O2Vsc2V7W3QsZV09ayh0LGUsLXApLFtuLHJdPWsobixyLC1wKTtjb25zdCBzPSh0LW4pLzIsdT0oZS1yKS8yO2xldCBjPXMqcy8oYSphKSt1KnUvKG8qbyk7Yz4xJiYoYz1NYXRoLnNxcnQoYyksYSo9YyxvKj1jKTtjb25zdCBsPWEqYSx2PW8qbyxNPWwqdi1sKnUqdS12KnMqcyxiPWwqdSp1K3YqcypzLG09KGg9PT1pPy0xOjEpKk1hdGguc3FydChNYXRoLmFicyhNL2IpKTtnPW0qYSp1L28rKHQrbikvMix5PW0qLW8qcy9hKyhlK3IpLzIsZj1NYXRoLmFzaW4ocGFyc2VGbG9hdCgoKGUteSkvbykudG9GaXhlZCg5KSkpLGQ9TWF0aC5hc2luKHBhcnNlRmxvYXQoKChyLXkpL28pLnRvRml4ZWQoOSkpKSx0PGcmJihmPU1hdGguUEktZiksbjxnJiYoZD1NYXRoLlBJLWQpLGY8MCYmKGY9MipNYXRoLlBJK2YpLGQ8MCYmKGQ9MipNYXRoLlBJK2QpLGkmJmY+ZCYmKGYtPTIqTWF0aC5QSSksIWkmJmQ+ZiYmKGQtPTIqTWF0aC5QSSl9bGV0IHY9ZC1mO2lmKE1hdGguYWJzKHYpPjEyMCpNYXRoLlBJLzE4MCl7Y29uc3QgdD1kLGU9bixoPXI7ZD1pJiZkPmY/ZisxMjAqTWF0aC5QSS8xODAqMTpmKzEyMCpNYXRoLlBJLzE4MCotMSxsPWIobj1nK2EqTWF0aC5jb3MoZCkscj15K28qTWF0aC5zaW4oZCksZSxoLGEsbyxzLDAsaSxbZCx0LGcseV0pfXY9ZC1mO2NvbnN0IE09TWF0aC5jb3MoZiksbT1NYXRoLnNpbihmKSx3PU1hdGguY29zKGQpLFA9TWF0aC5zaW4oZCkseD1NYXRoLnRhbih2LzQpLE89NC8zKmEqeCxTPTQvMypvKngsVD1bdCxlXSxfPVt0K08qbSxlLVMqTV0sQz1bbitPKlAsci1TKnddLFc9W24scl07aWYoX1swXT0yKlRbMF0tX1swXSxfWzFdPTIqVFsxXS1fWzFdLHUpcmV0dXJuW18sQyxXXS5jb25jYXQobCk7e2w9W18sQyxXXS5jb25jYXQobCk7Y29uc3QgdD1bXTtmb3IobGV0IGU9MDtlPGwubGVuZ3RoO2UrPTMpe2NvbnN0IG49ayhsW2VdWzBdLGxbZV1bMV0scCkscj1rKGxbZSsxXVswXSxsW2UrMV1bMV0scCksYT1rKGxbZSsyXVswXSxsW2UrMl1bMV0scCk7dC5wdXNoKFtuWzBdLG5bMV0sclswXSxyWzFdLGFbMF0sYVsxXV0pfXJldHVybiB0fX12YXIgbT17cmFuZE9mZnNldDpmdW5jdGlvbih0LGUpe3JldHVybiBFKHQsZSl9LHJhbmRPZmZzZXRXaXRoUmFuZ2U6ZnVuY3Rpb24odCxlLG4pe3JldHVybiBMKHQsZSxuKX0sZWxsaXBzZTpmdW5jdGlvbih0LGUsbixyLGEpe3ZhciBvPU8obixyLGEpO3JldHVybiBTKHQsZSxhLG8pLm9wc2V0fSxkb3VibGVMaW5lT3BzOmZ1bmN0aW9uKHQsZSxuLHIsYSl7cmV0dXJuIHoodCxlLG4scixhKX19O2Z1bmN0aW9uIHcodCxlLG4scixhKXtyZXR1cm57dHlwZTpcInBhdGhcIixvcHM6eih0LGUsbixyLGEpfX1mdW5jdGlvbiBQKHQsZSxuKXt2YXIgcj0odHx8W10pLmxlbmd0aDtpZihyPjIpe2Zvcih2YXIgYT1bXSxvPTA7bzxyLTE7bysrKWEucHVzaC5hcHBseShhLHoodFtvXVswXSx0W29dWzFdLHRbbysxXVswXSx0W28rMV1bMV0sbikpO3JldHVybiBlJiZhLnB1c2guYXBwbHkoYSx6KHRbci0xXVswXSx0W3ItMV1bMV0sdFswXVswXSx0WzBdWzFdLG4pKSx7dHlwZTpcInBhdGhcIixvcHM6YX19cmV0dXJuIDI9PT1yP3codFswXVswXSx0WzBdWzFdLHRbMV1bMF0sdFsxXVsxXSxuKTp7dHlwZTpcInBhdGhcIixvcHM6W119fWZ1bmN0aW9uIHgodCxlLG4scixhKXtyZXR1cm4gZnVuY3Rpb24odCxlKXtyZXR1cm4gUCh0LCEwLGUpfShbW3QsZV0sW3QrbixlXSxbdCtuLGUrcl0sW3QsZStyXV0sYSl9ZnVuY3Rpb24gTyh0LGUsbil7dmFyIHI9TWF0aC5zcXJ0KDIqTWF0aC5QSSpNYXRoLnNxcnQoKE1hdGgucG93KHQvMiwyKStNYXRoLnBvdyhlLzIsMikpLzIpKSxhPU1hdGgubWF4KG4uY3VydmVTdGVwQ291bnQsbi5jdXJ2ZVN0ZXBDb3VudC9NYXRoLnNxcnQoMjAwKSpyKSxvPTIqTWF0aC5QSS9hLHM9TWF0aC5hYnModC8yKSxoPU1hdGguYWJzKGUvMiksaT0xLW4uY3VydmVGaXR0aW5nO3JldHVybntpbmNyZW1lbnQ6byxyeDpzKz1FKHMqaSxuKSxyeTpoKz1FKGgqaSxuKX19ZnVuY3Rpb24gUyh0LGUsbixyKXt2YXIgYT1HKHIuaW5jcmVtZW50LHQsZSxyLnJ4LHIucnksMSxyLmluY3JlbWVudCpMKC4xLEwoLjQsMSxuKSxuKSxuKSxvPWFbMF0scz1hWzFdLGg9RyhyLmluY3JlbWVudCx0LGUsci5yeCxyLnJ5LDEuNSwwLG4pWzBdLGk9cShvLG51bGwsbiksdT1xKGgsbnVsbCxuKTtyZXR1cm57ZXN0aW1hdGVkUG9pbnRzOnMsb3BzZXQ6e3R5cGU6XCJwYXRoXCIsb3BzOmkuY29uY2F0KHUpfX19ZnVuY3Rpb24gVCh0LGUscixhLG8scyxoLGksdSl7dmFyIHA9dCxjPWUsbD1NYXRoLmFicyhyLzIpLGY9TWF0aC5hYnMoYS8yKTtsKz1FKC4wMSpsLHUpLGYrPUUoLjAxKmYsdSk7Zm9yKHZhciBkPW8sZz1zO2Q8MDspZCs9MipNYXRoLlBJLGcrPTIqTWF0aC5QSTtnLWQ+MipNYXRoLlBJJiYoZD0wLGc9MipNYXRoLlBJKTt2YXIgeT0yKk1hdGguUEkvdS5jdXJ2ZVN0ZXBDb3VudCx2PU1hdGgubWluKHkvMiwoZy1kKS8yKSxNPWoodixwLGMsbCxmLGQsZywxLHUpLGs9aih2LHAsYyxsLGYsZCxnLDEuNSx1KSxiPU0uY29uY2F0KGspO3JldHVybiBoJiYoaT9iLnB1c2guYXBwbHkoYixuKHoocCxjLHArbCpNYXRoLmNvcyhkKSxjK2YqTWF0aC5zaW4oZCksdSkseihwLGMscCtsKk1hdGguY29zKGcpLGMrZipNYXRoLnNpbihnKSx1KSkpOmIucHVzaCh7b3A6XCJsaW5lVG9cIixkYXRhOltwLGNdfSx7b3A6XCJsaW5lVG9cIixkYXRhOltwK2wqTWF0aC5jb3MoZCksYytmKk1hdGguc2luKGQpXX0pKSx7dHlwZTpcInBhdGhcIixvcHM6Yn19ZnVuY3Rpb24gXyh0LGUpe2Zvcih2YXIgbj1NKHYoeSh0KSkpLHI9W10sYT1bMCwwXSxvPVswLDBdLHM9ZnVuY3Rpb24odCxuKXtzd2l0Y2godCl7Y2FzZVwiTVwiOnZhciBzPTEqKGUubWF4UmFuZG9tbmVzc09mZnNldHx8MCk7ci5wdXNoKHtvcDpcIm1vdmVcIixkYXRhOm4ubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdCtFKHMsZSl9KSl9KSxvPVtuWzBdLG5bMV1dLGE9W25bMF0sblsxXV07YnJlYWs7Y2FzZVwiTFwiOnIucHVzaC5hcHBseShyLHoob1swXSxvWzFdLG5bMF0sblsxXSxlKSksbz1bblswXSxuWzFdXTticmVhaztjYXNlXCJDXCI6dmFyIGg9blswXSxpPW5bMV0sdT1uWzJdLHA9blszXSxjPW5bNF0sbD1uWzVdO3IucHVzaC5hcHBseShyLGZ1bmN0aW9uKHQsZSxuLHIsYSxvLHMsaCl7Zm9yKHZhciBpPVtdLHU9W2gubWF4UmFuZG9tbmVzc09mZnNldHx8MSwoaC5tYXhSYW5kb21uZXNzT2Zmc2V0fHwxKSsuM10scD1bMCwwXSxjPTA7YzwyO2MrKykwPT09Yz9pLnB1c2goe29wOlwibW92ZVwiLGRhdGE6W3NbMF0sc1sxXV19KTppLnB1c2goe29wOlwibW92ZVwiLGRhdGE6W3NbMF0rRSh1WzBdLGgpLHNbMV0rRSh1WzBdLGgpXX0pLHA9W2ErRSh1W2NdLGgpLG8rRSh1W2NdLGgpXSxpLnB1c2goe29wOlwiYmN1cnZlVG9cIixkYXRhOlt0K0UodVtjXSxoKSxlK0UodVtjXSxoKSxuK0UodVtjXSxoKSxyK0UodVtjXSxoKSxwWzBdLHBbMV1dfSk7cmV0dXJuIGl9KGgsaSx1LHAsYyxsLG8sZSkpLG89W2MsbF07YnJlYWs7Y2FzZVwiWlwiOnIucHVzaC5hcHBseShyLHoob1swXSxvWzFdLGFbMF0sYVsxXSxlKSksbz1bYVswXSxhWzFdXX19LGg9MCxpPW47aDxpLmxlbmd0aDtoKyspe3ZhciB1PWlbaF07cyh1LmtleSx1LmRhdGEpfXJldHVybnt0eXBlOlwicGF0aFwiLG9wczpyfX1mdW5jdGlvbiBDKHQsZSl7dmFyIG49W107aWYodC5sZW5ndGgpe3ZhciByPWUubWF4UmFuZG9tbmVzc09mZnNldHx8MCxhPXQubGVuZ3RoO2lmKGE+Mil7bi5wdXNoKHtvcDpcIm1vdmVcIixkYXRhOlt0WzBdWzBdK0UocixlKSx0WzBdWzFdK0UocixlKV19KTtmb3IodmFyIG89MTtvPGE7bysrKW4ucHVzaCh7b3A6XCJsaW5lVG9cIixkYXRhOlt0W29dWzBdK0UocixlKSx0W29dWzFdK0UocixlKV19KX19cmV0dXJue3R5cGU6XCJmaWxsUGF0aFwiLG9wczpufX1mdW5jdGlvbiBXKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIG49dC5maWxsU3R5bGV8fFwiaGFjaHVyZVwiO2lmKCFsW25dKXN3aXRjaChuKXtjYXNlXCJ6aWd6YWdcIjpsW25dfHwobFtuXT1uZXcgaChlKSk7YnJlYWs7Y2FzZVwiY3Jvc3MtaGF0Y2hcIjpsW25dfHwobFtuXT1uZXcgaShlKSk7YnJlYWs7Y2FzZVwiZG90c1wiOmxbbl18fChsW25dPW5ldyB1KGUpKTticmVhaztjYXNlXCJkYXNoZWRcIjpsW25dfHwobFtuXT1uZXcgcChlKSk7YnJlYWs7Y2FzZVwiemlnemFnLWxpbmVcIjpsW25dfHwobFtuXT1uZXcgYyhlKSk7YnJlYWs7Y2FzZVwiaGFjaHVyZVwiOmRlZmF1bHQ6bFtuPVwiaGFjaHVyZVwiXXx8KGxbbl09bmV3IHMoZSkpfXJldHVybiBsW25dfShlLG0pLmZpbGxQb2x5Z29uKHQsZSl9ZnVuY3Rpb24gSSh0KXtyZXR1cm4gdC5yYW5kb21pemVyfHwodC5yYW5kb21pemVyPW5ldyBmKHQuc2VlZHx8MCkpLHQucmFuZG9taXplci5uZXh0KCl9ZnVuY3Rpb24gTCh0LGUsbixyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9MSksbi5yb3VnaG5lc3MqciooSShuKSooZS10KSt0KX1mdW5jdGlvbiBFKHQsZSxuKXtyZXR1cm4gdm9pZCAwPT09biYmKG49MSksTCgtdCx0LGUsbil9ZnVuY3Rpb24geih0LGUsbixyLGEpe3ZhciBvPUEodCxlLG4scixhLCEwLCExKSxzPUEodCxlLG4scixhLCEwLCEwKTtyZXR1cm4gby5jb25jYXQocyl9ZnVuY3Rpb24gQSh0LGUsbixyLGEsbyxzKXt2YXIgaD1NYXRoLnBvdyh0LW4sMikrTWF0aC5wb3coZS1yLDIpLGk9TWF0aC5zcXJ0KGgpLHU9MTt1PWk8MjAwPzE6aT41MDA/LjQ6LS4wMDE2NjY4KmkrMS4yMzMzMzQ7dmFyIHA9YS5tYXhSYW5kb21uZXNzT2Zmc2V0fHwwO3AqcCoxMDA+aCYmKHA9aS8xMCk7dmFyIGM9cC8yLGw9LjIrLjIqSShhKSxmPWEuYm93aW5nKmEubWF4UmFuZG9tbmVzc09mZnNldCooci1lKS8yMDAsZD1hLmJvd2luZyphLm1heFJhbmRvbW5lc3NPZmZzZXQqKHQtbikvMjAwO2Y9RShmLGEsdSksZD1FKGQsYSx1KTt2YXIgZz1bXSx5PWZ1bmN0aW9uKCl7cmV0dXJuIEUoYyxhLHUpfSx2PWZ1bmN0aW9uKCl7cmV0dXJuIEUocCxhLHUpfTtyZXR1cm4gbyYmKHM/Zy5wdXNoKHtvcDpcIm1vdmVcIixkYXRhOlt0K3koKSxlK3koKV19KTpnLnB1c2goe29wOlwibW92ZVwiLGRhdGE6W3QrRShwLGEsdSksZStFKHAsYSx1KV19KSkscz9nLnB1c2goe29wOlwiYmN1cnZlVG9cIixkYXRhOltmK3QrKG4tdCkqbCt5KCksZCtlKyhyLWUpKmwreSgpLGYrdCsyKihuLXQpKmwreSgpLGQrZSsyKihyLWUpKmwreSgpLG4reSgpLHIreSgpXX0pOmcucHVzaCh7b3A6XCJiY3VydmVUb1wiLGRhdGE6W2YrdCsobi10KSpsK3YoKSxkK2UrKHItZSkqbCt2KCksZit0KzIqKG4tdCkqbCt2KCksZCtlKzIqKHItZSkqbCt2KCksbit2KCkscit2KCldfSksZ31mdW5jdGlvbiBSKHQsZSxuKXt2YXIgcj1bXTtyLnB1c2goW3RbMF1bMF0rRShlLG4pLHRbMF1bMV0rRShlLG4pXSksci5wdXNoKFt0WzBdWzBdK0UoZSxuKSx0WzBdWzFdK0UoZSxuKV0pO2Zvcih2YXIgYT0xO2E8dC5sZW5ndGg7YSsrKXIucHVzaChbdFthXVswXStFKGUsbiksdFthXVsxXStFKGUsbildKSxhPT09dC5sZW5ndGgtMSYmci5wdXNoKFt0W2FdWzBdK0UoZSxuKSx0W2FdWzFdK0UoZSxuKV0pO3JldHVybiBxKHIsbnVsbCxuKX1mdW5jdGlvbiBxKHQsZSxuKXt2YXIgcj10Lmxlbmd0aCxhPVtdO2lmKHI+Myl7dmFyIG89W10scz0xLW4uY3VydmVUaWdodG5lc3M7YS5wdXNoKHtvcDpcIm1vdmVcIixkYXRhOlt0WzFdWzBdLHRbMV1bMV1dfSk7Zm9yKHZhciBoPTE7aCsyPHI7aCsrKXt2YXIgaT10W2hdO29bMF09W2lbMF0saVsxXV0sb1sxXT1baVswXSsocyp0W2grMV1bMF0tcyp0W2gtMV1bMF0pLzYsaVsxXSsocyp0W2grMV1bMV0tcyp0W2gtMV1bMV0pLzZdLG9bMl09W3RbaCsxXVswXSsocyp0W2hdWzBdLXMqdFtoKzJdWzBdKS82LHRbaCsxXVsxXSsocyp0W2hdWzFdLXMqdFtoKzJdWzFdKS82XSxvWzNdPVt0W2grMV1bMF0sdFtoKzFdWzFdXSxhLnB1c2goe29wOlwiYmN1cnZlVG9cIixkYXRhOltvWzFdWzBdLG9bMV1bMV0sb1syXVswXSxvWzJdWzFdLG9bM11bMF0sb1szXVsxXV19KX1pZihlJiYyPT09ZS5sZW5ndGgpe3ZhciB1PW4ubWF4UmFuZG9tbmVzc09mZnNldDthLnB1c2goe29wOlwibGluZVRvXCIsZGF0YTpbZVswXStFKHUsbiksZVsxXStFKHUsbildfSl9fWVsc2UgMz09PXI/KGEucHVzaCh7b3A6XCJtb3ZlXCIsZGF0YTpbdFsxXVswXSx0WzFdWzFdXX0pLGEucHVzaCh7b3A6XCJiY3VydmVUb1wiLGRhdGE6W3RbMV1bMF0sdFsxXVsxXSx0WzJdWzBdLHRbMl1bMV0sdFsyXVswXSx0WzJdWzFdXX0pKToyPT09ciYmYS5wdXNoLmFwcGx5KGEseih0WzBdWzBdLHRbMF1bMV0sdFsxXVswXSx0WzFdWzFdLG4pKTtyZXR1cm4gYX1mdW5jdGlvbiBHKHQsZSxuLHIsYSxvLHMsaCl7dmFyIGk9W10sdT1bXSxwPUUoLjUsaCktTWF0aC5QSS8yO3UucHVzaChbRShvLGgpK2UrLjkqcipNYXRoLmNvcyhwLXQpLEUobyxoKStuKy45KmEqTWF0aC5zaW4ocC10KV0pO2Zvcih2YXIgYz1wO2M8MipNYXRoLlBJK3AtLjAxO2MrPXQpe3ZhciBsPVtFKG8saCkrZStyKk1hdGguY29zKGMpLEUobyxoKStuK2EqTWF0aC5zaW4oYyldO2kucHVzaChsKSx1LnB1c2gobCl9cmV0dXJuIHUucHVzaChbRShvLGgpK2UrcipNYXRoLmNvcyhwKzIqTWF0aC5QSSsuNSpzKSxFKG8saCkrbithKk1hdGguc2luKHArMipNYXRoLlBJKy41KnMpXSksdS5wdXNoKFtFKG8saCkrZSsuOTgqcipNYXRoLmNvcyhwK3MpLEUobyxoKStuKy45OCphKk1hdGguc2luKHArcyldKSx1LnB1c2goW0UobyxoKStlKy45KnIqTWF0aC5jb3MocCsuNSpzKSxFKG8saCkrbisuOSphKk1hdGguc2luKHArLjUqcyldKSxbdSxpXX1mdW5jdGlvbiBqKHQsZSxuLHIsYSxvLHMsaCxpKXt2YXIgdT1vK0UoLjEsaSkscD1bXTtwLnB1c2goW0UoaCxpKStlKy45KnIqTWF0aC5jb3ModS10KSxFKGgsaSkrbisuOSphKk1hdGguc2luKHUtdCldKTtmb3IodmFyIGM9dTtjPD1zO2MrPXQpcC5wdXNoKFtFKGgsaSkrZStyKk1hdGguY29zKGMpLEUoaCxpKStuK2EqTWF0aC5zaW4oYyldKTtyZXR1cm4gcC5wdXNoKFtlK3IqTWF0aC5jb3MocyksbithKk1hdGguc2luKHMpXSkscC5wdXNoKFtlK3IqTWF0aC5jb3MocyksbithKk1hdGguc2luKHMpXSkscShwLG51bGwsaSl9ZnVuY3Rpb24gWih0KXtyZXR1cm5bLi4udF19ZnVuY3Rpb24gRCh0LGUpe3JldHVybiBNYXRoLnBvdyh0WzBdLWVbMF0sMikrTWF0aC5wb3codFsxXS1lWzFdLDIpfWZ1bmN0aW9uIEYodCxlLG4pe2NvbnN0IHI9RChlLG4pO2lmKDA9PT1yKXJldHVybiBEKHQsZSk7bGV0IGE9KCh0WzBdLWVbMF0pKihuWzBdLWVbMF0pKyh0WzFdLWVbMV0pKihuWzFdLWVbMV0pKS9yO3JldHVybiBhPU1hdGgubWF4KDAsTWF0aC5taW4oMSxhKSksRCh0LFEoZSxuLGEpKX1mdW5jdGlvbiBRKHQsZSxuKXtyZXR1cm5bdFswXSsoZVswXS10WzBdKSpuLHRbMV0rKGVbMV0tdFsxXSkqbl19ZnVuY3Rpb24gSCh0LGUsbixyKXtjb25zdCBhPXJ8fFtdO2lmKGZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj10W2UrMF0scj10W2UrMV0sYT10W2UrMl0sbz10W2UrM107bGV0IHM9MypyWzBdLTIqblswXS1vWzBdO3MqPXM7bGV0IGg9MypyWzFdLTIqblsxXS1vWzFdO2gqPWg7bGV0IGk9MyphWzBdLTIqb1swXS1uWzBdO2kqPWk7bGV0IHU9MyphWzFdLTIqb1sxXS1uWzFdO3JldHVybiB1Kj11LHM8aSYmKHM9aSksaDx1JiYoaD11KSxzK2h9KHQsZSk8bil7Y29uc3Qgbj10W2UrMF07aWYoYS5sZW5ndGgpeyhvPWFbYS5sZW5ndGgtMV0scz1uLE1hdGguc3FydChEKG8scykpKT4xJiZhLnB1c2gobil9ZWxzZSBhLnB1c2gobik7YS5wdXNoKHRbZSszXSl9ZWxzZXtjb25zdCByPS41LG89dFtlKzBdLHM9dFtlKzFdLGg9dFtlKzJdLGk9dFtlKzNdLHU9UShvLHMscikscD1RKHMsaCxyKSxjPVEoaCxpLHIpLGw9USh1LHAsciksZj1RKHAsYyxyKSxkPVEobCxmLHIpO0goW28sdSxsLGRdLDAsbixhKSxIKFtkLGYsYyxpXSwwLG4sYSl9dmFyIG8scztyZXR1cm4gYX1mdW5jdGlvbiBOKHQsZSl7cmV0dXJuIFYodCwwLHQubGVuZ3RoLGUpfWZ1bmN0aW9uIFYodCxlLG4scixhKXtjb25zdCBvPWF8fFtdLHM9dFtlXSxoPXRbbi0xXTtsZXQgaT0wLHU9MTtmb3IobGV0IHI9ZSsxO3I8bi0xOysrcil7Y29uc3QgZT1GKHRbcl0scyxoKTtlPmkmJihpPWUsdT1yKX1yZXR1cm4gTWF0aC5zcXJ0KGkpPnI/KFYodCxlLHUrMSxyLG8pLFYodCx1LG4scixvKSk6KG8ubGVuZ3RofHxvLnB1c2gocyksby5wdXNoKGgpKSxvfWZ1bmN0aW9uICQodCxlPS4xNSxuKXtjb25zdCByPVtdLGE9KHQubGVuZ3RoLTEpLzM7Zm9yKGxldCBuPTA7bjxhO24rKyl7SCh0LDMqbixlLHIpfXJldHVybiBuJiZuPjA/VihyLDAsci5sZW5ndGgsbik6cn12YXIgQj1cIm5vbmVcIixKPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmRlZmF1bHRPcHRpb25zPXttYXhSYW5kb21uZXNzT2Zmc2V0OjIscm91Z2huZXNzOjEsYm93aW5nOjEsc3Ryb2tlOlwiIzAwMFwiLHN0cm9rZVdpZHRoOjEsY3VydmVUaWdodG5lc3M6MCxjdXJ2ZUZpdHRpbmc6Ljk1LGN1cnZlU3RlcENvdW50OjksZmlsbFN0eWxlOlwiaGFjaHVyZVwiLGZpbGxXZWlnaHQ6LTEsaGFjaHVyZUFuZ2xlOi00MSxoYWNodXJlR2FwOi0xLGRhc2hPZmZzZXQ6LTEsZGFzaEdhcDotMSx6aWd6YWdPZmZzZXQ6LTEsc2VlZDowLGNvbWJpbmVOZXN0ZWRTdmdQYXRoczohMX0sdGhpcy5jb25maWc9dHx8e30sdGhpcy5jb25maWcub3B0aW9ucyYmKHRoaXMuZGVmYXVsdE9wdGlvbnM9dGhpcy5fbyh0aGlzLmNvbmZpZy5vcHRpb25zKSl9cmV0dXJuIHQubmV3U2VlZD1mdW5jdGlvbigpe3JldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqTWF0aC5wb3coMiwzMSkpfSx0LnByb3RvdHlwZS5fbz1mdW5jdGlvbih0KXtyZXR1cm4gdD9PYmplY3QuYXNzaWduKHt9LHRoaXMuZGVmYXVsdE9wdGlvbnMsdCk6dGhpcy5kZWZhdWx0T3B0aW9uc30sdC5wcm90b3R5cGUuX2Q9ZnVuY3Rpb24odCxlLG4pe3JldHVybntzaGFwZTp0LHNldHM6ZXx8W10sb3B0aW9uczpufHx0aGlzLmRlZmF1bHRPcHRpb25zfX0sdC5wcm90b3R5cGUubGluZT1mdW5jdGlvbih0LGUsbixyLGEpe3ZhciBvPXRoaXMuX28oYSk7cmV0dXJuIHRoaXMuX2QoXCJsaW5lXCIsW3codCxlLG4scixvKV0sbyl9LHQucHJvdG90eXBlLnJlY3RhbmdsZT1mdW5jdGlvbih0LGUsbixyLGEpe3ZhciBvPXRoaXMuX28oYSkscz1bXSxoPXgodCxlLG4scixvKTtpZihvLmZpbGwpe3ZhciBpPVtbdCxlXSxbdCtuLGVdLFt0K24sZStyXSxbdCxlK3JdXTtcInNvbGlkXCI9PT1vLmZpbGxTdHlsZT9zLnB1c2goQyhpLG8pKTpzLnB1c2goVyhpLG8pKX1yZXR1cm4gby5zdHJva2UhPT1CJiZzLnB1c2goaCksdGhpcy5fZChcInJlY3RhbmdsZVwiLHMsbyl9LHQucHJvdG90eXBlLmVsbGlwc2U9ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgbz10aGlzLl9vKGEpLHM9W10saD1PKG4scixvKSxpPVModCxlLG8saCk7aWYoby5maWxsKWlmKFwic29saWRcIj09PW8uZmlsbFN0eWxlKXt2YXIgdT1TKHQsZSxvLGgpLm9wc2V0O3UudHlwZT1cImZpbGxQYXRoXCIscy5wdXNoKHUpfWVsc2Ugcy5wdXNoKFcoaS5lc3RpbWF0ZWRQb2ludHMsbykpO3JldHVybiBvLnN0cm9rZSE9PUImJnMucHVzaChpLm9wc2V0KSx0aGlzLl9kKFwiZWxsaXBzZVwiLHMsbyl9LHQucHJvdG90eXBlLmNpcmNsZT1mdW5jdGlvbih0LGUsbixyKXt2YXIgYT10aGlzLmVsbGlwc2UodCxlLG4sbixyKTtyZXR1cm4gYS5zaGFwZT1cImNpcmNsZVwiLGF9LHQucHJvdG90eXBlLmxpbmVhclBhdGg9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLl9vKGUpO3JldHVybiB0aGlzLl9kKFwibGluZWFyUGF0aFwiLFtQKHQsITEsbildLG4pfSx0LnByb3RvdHlwZS5hcmM9ZnVuY3Rpb24odCxlLG4scixhLG8scyxoKXt2b2lkIDA9PT1zJiYocz0hMSk7dmFyIGk9dGhpcy5fbyhoKSx1PVtdLHA9VCh0LGUsbixyLGEsbyxzLCEwLGkpO2lmKHMmJmkuZmlsbClpZihcInNvbGlkXCI9PT1pLmZpbGxTdHlsZSl7dmFyIGM9VCh0LGUsbixyLGEsbywhMCwhMSxpKTtjLnR5cGU9XCJmaWxsUGF0aFwiLHUucHVzaChjKX1lbHNlIHUucHVzaChmdW5jdGlvbih0LGUsbixyLGEsbyxzKXt2YXIgaD10LGk9ZSx1PU1hdGguYWJzKG4vMikscD1NYXRoLmFicyhyLzIpO3UrPUUoLjAxKnUscykscCs9RSguMDEqcCxzKTtmb3IodmFyIGM9YSxsPW87YzwwOyljKz0yKk1hdGguUEksbCs9MipNYXRoLlBJO2wtYz4yKk1hdGguUEkmJihjPTAsbD0yKk1hdGguUEkpO2Zvcih2YXIgZj0obC1jKS9zLmN1cnZlU3RlcENvdW50LGQ9W10sZz1jO2c8PWw7Zys9ZilkLnB1c2goW2grdSpNYXRoLmNvcyhnKSxpK3AqTWF0aC5zaW4oZyldKTtyZXR1cm4gZC5wdXNoKFtoK3UqTWF0aC5jb3MobCksaStwKk1hdGguc2luKGwpXSksZC5wdXNoKFtoLGldKSxXKGQscyl9KHQsZSxuLHIsYSxvLGkpKTtyZXR1cm4gaS5zdHJva2UhPT1CJiZ1LnB1c2gocCksdGhpcy5fZChcImFyY1wiLHUsaSl9LHQucHJvdG90eXBlLmN1cnZlPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5fbyhlKSxyPVtdLGE9ZnVuY3Rpb24odCxlKXt2YXIgbj1SKHQsMSooMSsuMiplLnJvdWdobmVzcyksZSkscj1SKHQsMS41KigxKy4yMiplLnJvdWdobmVzcyksZSk7cmV0dXJue3R5cGU6XCJwYXRoXCIsb3BzOm4uY29uY2F0KHIpfX0odCxuKTtpZihuLmZpbGwmJm4uZmlsbCE9PUImJnQubGVuZ3RoPj0zKXt2YXIgbz0kKGZ1bmN0aW9uKHQsZT0wKXtjb25zdCBuPXQubGVuZ3RoO2lmKG48Myl0aHJvdyBuZXcgRXJyb3IoXCJBIGN1cnZlIG11c3QgaGF2ZSBhdCBsZWFzdCB0aHJlZSBwb2ludHMuXCIpO2NvbnN0IHI9W107aWYoMz09PW4pci5wdXNoKFoodFswXSksWih0WzFdKSxaKHRbMl0pLFoodFsyXSkpO2Vsc2V7Y29uc3Qgbj1bXTtuLnB1c2godFswXSx0WzBdKTtmb3IobGV0IGU9MTtlPHQubGVuZ3RoO2UrKyluLnB1c2godFtlXSksZT09PXQubGVuZ3RoLTEmJm4ucHVzaCh0W2VdKTtjb25zdCBhPVtdLG89MS1lO3IucHVzaChaKG5bMF0pKTtmb3IobGV0IHQ9MTt0KzI8bi5sZW5ndGg7dCsrKXtjb25zdCBlPW5bdF07YVswXT1bZVswXSxlWzFdXSxhWzFdPVtlWzBdKyhvKm5bdCsxXVswXS1vKm5bdC0xXVswXSkvNixlWzFdKyhvKm5bdCsxXVsxXS1vKm5bdC0xXVsxXSkvNl0sYVsyXT1bblt0KzFdWzBdKyhvKm5bdF1bMF0tbypuW3QrMl1bMF0pLzYsblt0KzFdWzFdKyhvKm5bdF1bMV0tbypuW3QrMl1bMV0pLzZdLGFbM109W25bdCsxXVswXSxuW3QrMV1bMV1dLHIucHVzaChhWzFdLGFbMl0sYVszXSl9fXJldHVybiByfSh0KSwxMCwoMStuLnJvdWdobmVzcykvMik7XCJzb2xpZFwiPT09bi5maWxsU3R5bGU/ci5wdXNoKEMobyxuKSk6ci5wdXNoKFcobyxuKSl9cmV0dXJuIG4uc3Ryb2tlIT09QiYmci5wdXNoKGEpLHRoaXMuX2QoXCJjdXJ2ZVwiLHIsbil9LHQucHJvdG90eXBlLnBvbHlnb249ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLl9vKGUpLHI9W10sYT1QKHQsITAsbik7cmV0dXJuIG4uZmlsbCYmKFwic29saWRcIj09PW4uZmlsbFN0eWxlP3IucHVzaChDKHQsbikpOnIucHVzaChXKHQsbikpKSxuLnN0cm9rZSE9PUImJnIucHVzaChhKSx0aGlzLl9kKFwicG9seWdvblwiLHIsbil9LHQucHJvdG90eXBlLnBhdGg9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLl9vKGUpLHI9W107aWYoIXQpcmV0dXJuIHRoaXMuX2QoXCJwYXRoXCIscixuKTt0PSh0fHxcIlwiKS5yZXBsYWNlKC9cXG4vZyxcIiBcIikucmVwbGFjZSgvKC1cXHMpL2csXCItXCIpLnJlcGxhY2UoXCIvKHNzKS9nXCIsXCIgXCIpO3ZhciBhPW4uZmlsbCYmXCJ0cmFuc3BhcmVudFwiIT09bi5maWxsJiZuLmZpbGwhPT1CLG89bi5zdHJva2UhPT1CLHM9ISEobi5zaW1wbGlmaWNhdGlvbiYmbi5zaW1wbGlmaWNhdGlvbjwxKSxoPWZ1bmN0aW9uKHQsZSxuKXtjb25zdCByPU0odih5KHQpKSksYT1bXTtsZXQgbz1bXSxzPVswLDBdLGg9W107Y29uc3QgaT0oKT0+e2gubGVuZ3RoPj00JiZvLnB1c2goLi4uJChoLGUpKSxoPVtdfSx1PSgpPT57aSgpLG8ubGVuZ3RoJiYoYS5wdXNoKG8pLG89W10pfTtmb3IoY29uc3R7a2V5OnQsZGF0YTplfW9mIHIpc3dpdGNoKHQpe2Nhc2VcIk1cIjp1KCkscz1bZVswXSxlWzFdXSxvLnB1c2gocyk7YnJlYWs7Y2FzZVwiTFwiOmkoKSxvLnB1c2goW2VbMF0sZVsxXV0pO2JyZWFrO2Nhc2VcIkNcIjppZighaC5sZW5ndGgpe2NvbnN0IHQ9by5sZW5ndGg/b1tvLmxlbmd0aC0xXTpzO2gucHVzaChbdFswXSx0WzFdXSl9aC5wdXNoKFtlWzBdLGVbMV1dKSxoLnB1c2goW2VbMl0sZVszXV0pLGgucHVzaChbZVs0XSxlWzVdXSk7YnJlYWs7Y2FzZVwiWlwiOmkoKSxvLnB1c2goW3NbMF0sc1sxXV0pfWlmKHUoKSwhbilyZXR1cm4gYTtjb25zdCBwPVtdO2Zvcihjb25zdCB0IG9mIGEpe2NvbnN0IGU9Tih0LG4pO2UubGVuZ3RoJiZwLnB1c2goZSl9cmV0dXJuIHB9KHQsMSxzPzQtNCpuLnNpbXBsaWZpY2F0aW9uOigxK24ucm91Z2huZXNzKS8yKTtpZihhKWlmKG4uY29tYmluZU5lc3RlZFN2Z1BhdGhzKXt2YXIgaT1bXTtoLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBpLnB1c2guYXBwbHkoaSx0KX0pKSxcInNvbGlkXCI9PT1uLmZpbGxTdHlsZT9yLnB1c2goQyhpLG4pKTpyLnB1c2goVyhpLG4pKX1lbHNlIGguZm9yRWFjaCgoZnVuY3Rpb24odCl7XCJzb2xpZFwiPT09bi5maWxsU3R5bGU/ci5wdXNoKEModCxuKSk6ci5wdXNoKFcodCxuKSl9KSk7cmV0dXJuIG8mJihzP2guZm9yRWFjaCgoZnVuY3Rpb24odCl7ci5wdXNoKFAodCwhMSxuKSl9KSk6ci5wdXNoKF8odCxuKSkpLHRoaXMuX2QoXCJwYXRoXCIscixuKX0sdC5wcm90b3R5cGUub3BzVG9QYXRoPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1cIlwiLG49MCxyPXQub3BzO248ci5sZW5ndGg7bisrKXt2YXIgYT1yW25dLG89YS5kYXRhO3N3aXRjaChhLm9wKXtjYXNlXCJtb3ZlXCI6ZSs9XCJNXCIrb1swXStcIiBcIitvWzFdK1wiIFwiO2JyZWFrO2Nhc2VcImJjdXJ2ZVRvXCI6ZSs9XCJDXCIrb1swXStcIiBcIitvWzFdK1wiLCBcIitvWzJdK1wiIFwiK29bM10rXCIsIFwiK29bNF0rXCIgXCIrb1s1XStcIiBcIjticmVhaztjYXNlXCJsaW5lVG9cIjplKz1cIkxcIitvWzBdK1wiIFwiK29bMV0rXCIgXCJ9fXJldHVybiBlLnRyaW0oKX0sdC5wcm90b3R5cGUudG9QYXRocz1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5zZXRzfHxbXSxuPXQub3B0aW9uc3x8dGhpcy5kZWZhdWx0T3B0aW9ucyxyPVtdLGE9MCxvPWU7YTxvLmxlbmd0aDthKyspe3ZhciBzPW9bYV0saD1udWxsO3N3aXRjaChzLnR5cGUpe2Nhc2VcInBhdGhcIjpoPXtkOnRoaXMub3BzVG9QYXRoKHMpLHN0cm9rZTpuLnN0cm9rZSxzdHJva2VXaWR0aDpuLnN0cm9rZVdpZHRoLGZpbGw6Qn07YnJlYWs7Y2FzZVwiZmlsbFBhdGhcIjpoPXtkOnRoaXMub3BzVG9QYXRoKHMpLHN0cm9rZTpCLHN0cm9rZVdpZHRoOjAsZmlsbDpuLmZpbGx8fEJ9O2JyZWFrO2Nhc2VcImZpbGxTa2V0Y2hcIjpoPXRoaXMuZmlsbFNrZXRjaChzLG4pfWgmJnIucHVzaChoKX1yZXR1cm4gcn0sdC5wcm90b3R5cGUuZmlsbFNrZXRjaD1mdW5jdGlvbih0LGUpe3ZhciBuPWUuZmlsbFdlaWdodDtyZXR1cm4gbjwwJiYobj1lLnN0cm9rZVdpZHRoLzIpLHtkOnRoaXMub3BzVG9QYXRoKHQpLHN0cm9rZTplLmZpbGx8fEIsc3Ryb2tlV2lkdGg6bixmaWxsOkJ9fSx0fSgpLEs9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dGhpcy5jYW52YXM9dCx0aGlzLmN0eD10aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksdGhpcy5nZW49bmV3IEooZSl9cmV0dXJuIHQucHJvdG90eXBlLmRyYXc9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuc2V0c3x8W10sbj10Lm9wdGlvbnN8fHRoaXMuZ2V0RGVmYXVsdE9wdGlvbnMoKSxyPXRoaXMuY3R4LGE9MCxvPWU7YTxvLmxlbmd0aDthKyspe3ZhciBzPW9bYV07c3dpdGNoKHMudHlwZSl7Y2FzZVwicGF0aFwiOnIuc2F2ZSgpLHIuc3Ryb2tlU3R5bGU9XCJub25lXCI9PT1uLnN0cm9rZT9cInRyYW5zcGFyZW50XCI6bi5zdHJva2Usci5saW5lV2lkdGg9bi5zdHJva2VXaWR0aCx0aGlzLl9kcmF3VG9Db250ZXh0KHIscyksci5yZXN0b3JlKCk7YnJlYWs7Y2FzZVwiZmlsbFBhdGhcIjpyLnNhdmUoKSxyLmZpbGxTdHlsZT1uLmZpbGx8fFwiXCI7dmFyIGg9XCJjdXJ2ZVwiPT09dC5zaGFwZXx8XCJwb2x5Z29uXCI9PT10LnNoYXBlP1wiZXZlbm9kZFwiOlwibm9uemVyb1wiO3RoaXMuX2RyYXdUb0NvbnRleHQocixzLGgpLHIucmVzdG9yZSgpO2JyZWFrO2Nhc2VcImZpbGxTa2V0Y2hcIjp0aGlzLmZpbGxTa2V0Y2gocixzLG4pfX19LHQucHJvdG90eXBlLmZpbGxTa2V0Y2g9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW4uZmlsbFdlaWdodDtyPDAmJihyPW4uc3Ryb2tlV2lkdGgvMiksdC5zYXZlKCksdC5zdHJva2VTdHlsZT1uLmZpbGx8fFwiXCIsdC5saW5lV2lkdGg9cix0aGlzLl9kcmF3VG9Db250ZXh0KHQsZSksdC5yZXN0b3JlKCl9LHQucHJvdG90eXBlLl9kcmF3VG9Db250ZXh0PWZ1bmN0aW9uKHQsZSxuKXt2b2lkIDA9PT1uJiYobj1cIm5vbnplcm9cIiksdC5iZWdpblBhdGgoKTtmb3IodmFyIHI9MCxhPWUub3BzO3I8YS5sZW5ndGg7cisrKXt2YXIgbz1hW3JdLHM9by5kYXRhO3N3aXRjaChvLm9wKXtjYXNlXCJtb3ZlXCI6dC5tb3ZlVG8oc1swXSxzWzFdKTticmVhaztjYXNlXCJiY3VydmVUb1wiOnQuYmV6aWVyQ3VydmVUbyhzWzBdLHNbMV0sc1syXSxzWzNdLHNbNF0sc1s1XSk7YnJlYWs7Y2FzZVwibGluZVRvXCI6dC5saW5lVG8oc1swXSxzWzFdKX19XCJmaWxsUGF0aFwiPT09ZS50eXBlP3QuZmlsbChuKTp0LnN0cm9rZSgpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJnZW5lcmF0b3JcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2VufSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLHQucHJvdG90eXBlLmdldERlZmF1bHRPcHRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2VuLmRlZmF1bHRPcHRpb25zfSx0LnByb3RvdHlwZS5saW5lPWZ1bmN0aW9uKHQsZSxuLHIsYSl7dmFyIG89dGhpcy5nZW4ubGluZSh0LGUsbixyLGEpO3JldHVybiB0aGlzLmRyYXcobyksb30sdC5wcm90b3R5cGUucmVjdGFuZ2xlPWZ1bmN0aW9uKHQsZSxuLHIsYSl7dmFyIG89dGhpcy5nZW4ucmVjdGFuZ2xlKHQsZSxuLHIsYSk7cmV0dXJuIHRoaXMuZHJhdyhvKSxvfSx0LnByb3RvdHlwZS5lbGxpcHNlPWZ1bmN0aW9uKHQsZSxuLHIsYSl7dmFyIG89dGhpcy5nZW4uZWxsaXBzZSh0LGUsbixyLGEpO3JldHVybiB0aGlzLmRyYXcobyksb30sdC5wcm90b3R5cGUuY2lyY2xlPWZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBhPXRoaXMuZ2VuLmNpcmNsZSh0LGUsbixyKTtyZXR1cm4gdGhpcy5kcmF3KGEpLGF9LHQucHJvdG90eXBlLmxpbmVhclBhdGg9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdlbi5saW5lYXJQYXRoKHQsZSk7cmV0dXJuIHRoaXMuZHJhdyhuKSxufSx0LnByb3RvdHlwZS5wb2x5Z29uPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZW4ucG9seWdvbih0LGUpO3JldHVybiB0aGlzLmRyYXcobiksbn0sdC5wcm90b3R5cGUuYXJjPWZ1bmN0aW9uKHQsZSxuLHIsYSxvLHMsaCl7dm9pZCAwPT09cyYmKHM9ITEpO3ZhciBpPXRoaXMuZ2VuLmFyYyh0LGUsbixyLGEsbyxzLGgpO3JldHVybiB0aGlzLmRyYXcoaSksaX0sdC5wcm90b3R5cGUuY3VydmU9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdlbi5jdXJ2ZSh0LGUpO3JldHVybiB0aGlzLmRyYXcobiksbn0sdC5wcm90b3R5cGUucGF0aD1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2VuLnBhdGgodCxlKTtyZXR1cm4gdGhpcy5kcmF3KG4pLG59LHR9KCksVT1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsWD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXt0aGlzLnN2Zz10LHRoaXMuZ2VuPW5ldyBKKGUpfXJldHVybiB0LnByb3RvdHlwZS5kcmF3PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LnNldHN8fFtdLG49dC5vcHRpb25zfHx0aGlzLmdldERlZmF1bHRPcHRpb25zKCkscj10aGlzLnN2Zy5vd25lckRvY3VtZW50fHx3aW5kb3cuZG9jdW1lbnQsYT1yLmNyZWF0ZUVsZW1lbnROUyhVLFwiZ1wiKSxvPTAscz1lO288cy5sZW5ndGg7bysrKXt2YXIgaD1zW29dLGk9bnVsbDtzd2l0Y2goaC50eXBlKXtjYXNlXCJwYXRoXCI6KGk9ci5jcmVhdGVFbGVtZW50TlMoVSxcInBhdGhcIikpLnNldEF0dHJpYnV0ZShcImRcIix0aGlzLm9wc1RvUGF0aChoKSksaS5zdHlsZS5zdHJva2U9bi5zdHJva2UsaS5zdHlsZS5zdHJva2VXaWR0aD1uLnN0cm9rZVdpZHRoK1wiXCIsaS5zdHlsZS5maWxsPVwibm9uZVwiO2JyZWFrO2Nhc2VcImZpbGxQYXRoXCI6KGk9ci5jcmVhdGVFbGVtZW50TlMoVSxcInBhdGhcIikpLnNldEF0dHJpYnV0ZShcImRcIix0aGlzLm9wc1RvUGF0aChoKSksaS5zdHlsZS5zdHJva2U9XCJub25lXCIsaS5zdHlsZS5zdHJva2VXaWR0aD1cIjBcIixpLnN0eWxlLmZpbGw9bi5maWxsfHxcIlwiO2JyZWFrO2Nhc2VcImZpbGxTa2V0Y2hcIjppPXRoaXMuZmlsbFNrZXRjaChyLGgsbil9aSYmYS5hcHBlbmRDaGlsZChpKX1yZXR1cm4gYX0sdC5wcm90b3R5cGUuZmlsbFNrZXRjaD1mdW5jdGlvbih0LGUsbil7dmFyIHI9bi5maWxsV2VpZ2h0O3I8MCYmKHI9bi5zdHJva2VXaWR0aC8yKTt2YXIgYT10LmNyZWF0ZUVsZW1lbnROUyhVLFwicGF0aFwiKTtyZXR1cm4gYS5zZXRBdHRyaWJ1dGUoXCJkXCIsdGhpcy5vcHNUb1BhdGgoZSkpLGEuc3R5bGUuc3Ryb2tlPW4uZmlsbHx8XCJcIixhLnN0eWxlLnN0cm9rZVdpZHRoPXIrXCJcIixhLnN0eWxlLmZpbGw9XCJub25lXCIsYX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQucHJvdG90eXBlLFwiZ2VuZXJhdG9yXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdlbn0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5nZXREZWZhdWx0T3B0aW9ucz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdlbi5kZWZhdWx0T3B0aW9uc30sdC5wcm90b3R5cGUub3BzVG9QYXRoPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdlbi5vcHNUb1BhdGgodCl9LHQucHJvdG90eXBlLmxpbmU9ZnVuY3Rpb24odCxlLG4scixhKXt2YXIgbz10aGlzLmdlbi5saW5lKHQsZSxuLHIsYSk7cmV0dXJuIHRoaXMuZHJhdyhvKX0sdC5wcm90b3R5cGUucmVjdGFuZ2xlPWZ1bmN0aW9uKHQsZSxuLHIsYSl7dmFyIG89dGhpcy5nZW4ucmVjdGFuZ2xlKHQsZSxuLHIsYSk7cmV0dXJuIHRoaXMuZHJhdyhvKX0sdC5wcm90b3R5cGUuZWxsaXBzZT1mdW5jdGlvbih0LGUsbixyLGEpe3ZhciBvPXRoaXMuZ2VuLmVsbGlwc2UodCxlLG4scixhKTtyZXR1cm4gdGhpcy5kcmF3KG8pfSx0LnByb3RvdHlwZS5jaXJjbGU9ZnVuY3Rpb24odCxlLG4scil7dmFyIGE9dGhpcy5nZW4uY2lyY2xlKHQsZSxuLHIpO3JldHVybiB0aGlzLmRyYXcoYSl9LHQucHJvdG90eXBlLmxpbmVhclBhdGg9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdlbi5saW5lYXJQYXRoKHQsZSk7cmV0dXJuIHRoaXMuZHJhdyhuKX0sdC5wcm90b3R5cGUucG9seWdvbj1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2VuLnBvbHlnb24odCxlKTtyZXR1cm4gdGhpcy5kcmF3KG4pfSx0LnByb3RvdHlwZS5hcmM9ZnVuY3Rpb24odCxlLG4scixhLG8scyxoKXt2b2lkIDA9PT1zJiYocz0hMSk7dmFyIGk9dGhpcy5nZW4uYXJjKHQsZSxuLHIsYSxvLHMsaCk7cmV0dXJuIHRoaXMuZHJhdyhpKX0sdC5wcm90b3R5cGUuY3VydmU9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdlbi5jdXJ2ZSh0LGUpO3JldHVybiB0aGlzLmRyYXcobil9LHQucHJvdG90eXBlLnBhdGg9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdlbi5wYXRoKHQsZSk7cmV0dXJuIHRoaXMuZHJhdyhuKX0sdH0oKSxZPXtjYW52YXM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IEsodCxlKX0sc3ZnOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyBYKHQsZSl9LGdlbmVyYXRvcjpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IEoodCl9LG5ld1NlZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gSi5uZXdTZWVkKCl9fTttb2R1bGUuZXhwb3J0cz1ZO1xuIiwiLypcbiAqIEEgZmFzdCBqYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHNpbXBsZXggbm9pc2UgYnkgSm9uYXMgV2FnbmVyXG5cbkJhc2VkIG9uIGEgc3BlZWQtaW1wcm92ZWQgc2ltcGxleCBub2lzZSBhbGdvcml0aG0gZm9yIDJELCAzRCBhbmQgNEQgaW4gSmF2YS5cbldoaWNoIGlzIGJhc2VkIG9uIGV4YW1wbGUgY29kZSBieSBTdGVmYW4gR3VzdGF2c29uIChzdGVndUBpdG4ubGl1LnNlKS5cbldpdGggT3B0aW1pc2F0aW9ucyBieSBQZXRlciBFYXN0bWFuIChwZWFzdG1hbkBkcml6emxlLnN0YW5mb3JkLmVkdSkuXG5CZXR0ZXIgcmFuayBvcmRlcmluZyBtZXRob2QgYnkgU3RlZmFuIEd1c3RhdnNvbiBpbiAyMDEyLlxuXG5cbiBDb3B5cmlnaHQgKGMpIDIwMTggSm9uYXMgV2FnbmVyXG5cbiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiBTT0ZUV0FSRS5cbiAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIEYyID0gMC41ICogKE1hdGguc3FydCgzLjApIC0gMS4wKTtcbiAgdmFyIEcyID0gKDMuMCAtIE1hdGguc3FydCgzLjApKSAvIDYuMDtcbiAgdmFyIEYzID0gMS4wIC8gMy4wO1xuICB2YXIgRzMgPSAxLjAgLyA2LjA7XG4gIHZhciBGNCA9IChNYXRoLnNxcnQoNS4wKSAtIDEuMCkgLyA0LjA7XG4gIHZhciBHNCA9ICg1LjAgLSBNYXRoLnNxcnQoNS4wKSkgLyAyMC4wO1xuXG4gIGZ1bmN0aW9uIFNpbXBsZXhOb2lzZShyYW5kb21PclNlZWQpIHtcbiAgICB2YXIgcmFuZG9tO1xuICAgIGlmICh0eXBlb2YgcmFuZG9tT3JTZWVkID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJhbmRvbSA9IHJhbmRvbU9yU2VlZDtcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuZG9tT3JTZWVkKSB7XG4gICAgICByYW5kb20gPSBhbGVhKHJhbmRvbU9yU2VlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmRvbSA9IE1hdGgucmFuZG9tO1xuICAgIH1cbiAgICB0aGlzLnAgPSBidWlsZFBlcm11dGF0aW9uVGFibGUocmFuZG9tKTtcbiAgICB0aGlzLnBlcm0gPSBuZXcgVWludDhBcnJheSg1MTIpO1xuICAgIHRoaXMucGVybU1vZDEyID0gbmV3IFVpbnQ4QXJyYXkoNTEyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDUxMjsgaSsrKSB7XG4gICAgICB0aGlzLnBlcm1baV0gPSB0aGlzLnBbaSAmIDI1NV07XG4gICAgICB0aGlzLnBlcm1Nb2QxMltpXSA9IHRoaXMucGVybVtpXSAlIDEyO1xuICAgIH1cblxuICB9XG4gIFNpbXBsZXhOb2lzZS5wcm90b3R5cGUgPSB7XG4gICAgZ3JhZDM6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDAsXG4gICAgICAtMSwgMSwgMCxcbiAgICAgIDEsIC0xLCAwLFxuXG4gICAgICAtMSwgLTEsIDAsXG4gICAgICAxLCAwLCAxLFxuICAgICAgLTEsIDAsIDEsXG5cbiAgICAgIDEsIDAsIC0xLFxuICAgICAgLTEsIDAsIC0xLFxuICAgICAgMCwgMSwgMSxcblxuICAgICAgMCwgLTEsIDEsXG4gICAgICAwLCAxLCAtMSxcbiAgICAgIDAsIC0xLCAtMV0pLFxuICAgIGdyYWQ0OiBuZXcgRmxvYXQzMkFycmF5KFswLCAxLCAxLCAxLCAwLCAxLCAxLCAtMSwgMCwgMSwgLTEsIDEsIDAsIDEsIC0xLCAtMSxcbiAgICAgIDAsIC0xLCAxLCAxLCAwLCAtMSwgMSwgLTEsIDAsIC0xLCAtMSwgMSwgMCwgLTEsIC0xLCAtMSxcbiAgICAgIDEsIDAsIDEsIDEsIDEsIDAsIDEsIC0xLCAxLCAwLCAtMSwgMSwgMSwgMCwgLTEsIC0xLFxuICAgICAgLTEsIDAsIDEsIDEsIC0xLCAwLCAxLCAtMSwgLTEsIDAsIC0xLCAxLCAtMSwgMCwgLTEsIC0xLFxuICAgICAgMSwgMSwgMCwgMSwgMSwgMSwgMCwgLTEsIDEsIC0xLCAwLCAxLCAxLCAtMSwgMCwgLTEsXG4gICAgICAtMSwgMSwgMCwgMSwgLTEsIDEsIDAsIC0xLCAtMSwgLTEsIDAsIDEsIC0xLCAtMSwgMCwgLTEsXG4gICAgICAxLCAxLCAxLCAwLCAxLCAxLCAtMSwgMCwgMSwgLTEsIDEsIDAsIDEsIC0xLCAtMSwgMCxcbiAgICAgIC0xLCAxLCAxLCAwLCAtMSwgMSwgLTEsIDAsIC0xLCAtMSwgMSwgMCwgLTEsIC0xLCAtMSwgMF0pLFxuICAgIG5vaXNlMkQ6IGZ1bmN0aW9uKHhpbiwgeWluKSB7XG4gICAgICB2YXIgcGVybU1vZDEyID0gdGhpcy5wZXJtTW9kMTI7XG4gICAgICB2YXIgcGVybSA9IHRoaXMucGVybTtcbiAgICAgIHZhciBncmFkMyA9IHRoaXMuZ3JhZDM7XG4gICAgICB2YXIgbjAgPSAwOyAvLyBOb2lzZSBjb250cmlidXRpb25zIGZyb20gdGhlIHRocmVlIGNvcm5lcnNcbiAgICAgIHZhciBuMSA9IDA7XG4gICAgICB2YXIgbjIgPSAwO1xuICAgICAgLy8gU2tldyB0aGUgaW5wdXQgc3BhY2UgdG8gZGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggY2VsbCB3ZSdyZSBpblxuICAgICAgdmFyIHMgPSAoeGluICsgeWluKSAqIEYyOyAvLyBIYWlyeSBmYWN0b3IgZm9yIDJEXG4gICAgICB2YXIgaSA9IE1hdGguZmxvb3IoeGluICsgcyk7XG4gICAgICB2YXIgaiA9IE1hdGguZmxvb3IoeWluICsgcyk7XG4gICAgICB2YXIgdCA9IChpICsgaikgKiBHMjtcbiAgICAgIHZhciBYMCA9IGkgLSB0OyAvLyBVbnNrZXcgdGhlIGNlbGwgb3JpZ2luIGJhY2sgdG8gKHgseSkgc3BhY2VcbiAgICAgIHZhciBZMCA9IGogLSB0O1xuICAgICAgdmFyIHgwID0geGluIC0gWDA7IC8vIFRoZSB4LHkgZGlzdGFuY2VzIGZyb20gdGhlIGNlbGwgb3JpZ2luXG4gICAgICB2YXIgeTAgPSB5aW4gLSBZMDtcbiAgICAgIC8vIEZvciB0aGUgMkQgY2FzZSwgdGhlIHNpbXBsZXggc2hhcGUgaXMgYW4gZXF1aWxhdGVyYWwgdHJpYW5nbGUuXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggc2ltcGxleCB3ZSBhcmUgaW4uXG4gICAgICB2YXIgaTEsIGoxOyAvLyBPZmZzZXRzIGZvciBzZWNvbmQgKG1pZGRsZSkgY29ybmVyIG9mIHNpbXBsZXggaW4gKGksaikgY29vcmRzXG4gICAgICBpZiAoeDAgPiB5MCkge1xuICAgICAgICBpMSA9IDE7XG4gICAgICAgIGoxID0gMDtcbiAgICAgIH0gLy8gbG93ZXIgdHJpYW5nbGUsIFhZIG9yZGVyOiAoMCwwKS0+KDEsMCktPigxLDEpXG4gICAgICBlbHNlIHtcbiAgICAgICAgaTEgPSAwO1xuICAgICAgICBqMSA9IDE7XG4gICAgICB9IC8vIHVwcGVyIHRyaWFuZ2xlLCBZWCBvcmRlcjogKDAsMCktPigwLDEpLT4oMSwxKVxuICAgICAgLy8gQSBzdGVwIG9mICgxLDApIGluIChpLGopIG1lYW5zIGEgc3RlcCBvZiAoMS1jLC1jKSBpbiAoeCx5KSwgYW5kXG4gICAgICAvLyBhIHN0ZXAgb2YgKDAsMSkgaW4gKGksaikgbWVhbnMgYSBzdGVwIG9mICgtYywxLWMpIGluICh4LHkpLCB3aGVyZVxuICAgICAgLy8gYyA9ICgzLXNxcnQoMykpLzZcbiAgICAgIHZhciB4MSA9IHgwIC0gaTEgKyBHMjsgLy8gT2Zmc2V0cyBmb3IgbWlkZGxlIGNvcm5lciBpbiAoeCx5KSB1bnNrZXdlZCBjb29yZHNcbiAgICAgIHZhciB5MSA9IHkwIC0gajEgKyBHMjtcbiAgICAgIHZhciB4MiA9IHgwIC0gMS4wICsgMi4wICogRzI7IC8vIE9mZnNldHMgZm9yIGxhc3QgY29ybmVyIGluICh4LHkpIHVuc2tld2VkIGNvb3Jkc1xuICAgICAgdmFyIHkyID0geTAgLSAxLjAgKyAyLjAgKiBHMjtcbiAgICAgIC8vIFdvcmsgb3V0IHRoZSBoYXNoZWQgZ3JhZGllbnQgaW5kaWNlcyBvZiB0aGUgdGhyZWUgc2ltcGxleCBjb3JuZXJzXG4gICAgICB2YXIgaWkgPSBpICYgMjU1O1xuICAgICAgdmFyIGpqID0gaiAmIDI1NTtcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgY29udHJpYnV0aW9uIGZyb20gdGhlIHRocmVlIGNvcm5lcnNcbiAgICAgIHZhciB0MCA9IDAuNSAtIHgwICogeDAgLSB5MCAqIHkwO1xuICAgICAgaWYgKHQwID49IDApIHtcbiAgICAgICAgdmFyIGdpMCA9IHBlcm1Nb2QxMltpaSArIHBlcm1bampdXSAqIDM7XG4gICAgICAgIHQwICo9IHQwO1xuICAgICAgICBuMCA9IHQwICogdDAgKiAoZ3JhZDNbZ2kwXSAqIHgwICsgZ3JhZDNbZ2kwICsgMV0gKiB5MCk7IC8vICh4LHkpIG9mIGdyYWQzIHVzZWQgZm9yIDJEIGdyYWRpZW50XG4gICAgICB9XG4gICAgICB2YXIgdDEgPSAwLjUgLSB4MSAqIHgxIC0geTEgKiB5MTtcbiAgICAgIGlmICh0MSA+PSAwKSB7XG4gICAgICAgIHZhciBnaTEgPSBwZXJtTW9kMTJbaWkgKyBpMSArIHBlcm1bamogKyBqMV1dICogMztcbiAgICAgICAgdDEgKj0gdDE7XG4gICAgICAgIG4xID0gdDEgKiB0MSAqIChncmFkM1tnaTFdICogeDEgKyBncmFkM1tnaTEgKyAxXSAqIHkxKTtcbiAgICAgIH1cbiAgICAgIHZhciB0MiA9IDAuNSAtIHgyICogeDIgLSB5MiAqIHkyO1xuICAgICAgaWYgKHQyID49IDApIHtcbiAgICAgICAgdmFyIGdpMiA9IHBlcm1Nb2QxMltpaSArIDEgKyBwZXJtW2pqICsgMV1dICogMztcbiAgICAgICAgdDIgKj0gdDI7XG4gICAgICAgIG4yID0gdDIgKiB0MiAqIChncmFkM1tnaTJdICogeDIgKyBncmFkM1tnaTIgKyAxXSAqIHkyKTtcbiAgICAgIH1cbiAgICAgIC8vIEFkZCBjb250cmlidXRpb25zIGZyb20gZWFjaCBjb3JuZXIgdG8gZ2V0IHRoZSBmaW5hbCBub2lzZSB2YWx1ZS5cbiAgICAgIC8vIFRoZSByZXN1bHQgaXMgc2NhbGVkIHRvIHJldHVybiB2YWx1ZXMgaW4gdGhlIGludGVydmFsIFstMSwxXS5cbiAgICAgIHJldHVybiA3MC4wICogKG4wICsgbjEgKyBuMik7XG4gICAgfSxcbiAgICAvLyAzRCBzaW1wbGV4IG5vaXNlXG4gICAgbm9pc2UzRDogZnVuY3Rpb24oeGluLCB5aW4sIHppbikge1xuICAgICAgdmFyIHBlcm1Nb2QxMiA9IHRoaXMucGVybU1vZDEyO1xuICAgICAgdmFyIHBlcm0gPSB0aGlzLnBlcm07XG4gICAgICB2YXIgZ3JhZDMgPSB0aGlzLmdyYWQzO1xuICAgICAgdmFyIG4wLCBuMSwgbjIsIG4zOyAvLyBOb2lzZSBjb250cmlidXRpb25zIGZyb20gdGhlIGZvdXIgY29ybmVyc1xuICAgICAgLy8gU2tldyB0aGUgaW5wdXQgc3BhY2UgdG8gZGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggY2VsbCB3ZSdyZSBpblxuICAgICAgdmFyIHMgPSAoeGluICsgeWluICsgemluKSAqIEYzOyAvLyBWZXJ5IG5pY2UgYW5kIHNpbXBsZSBza2V3IGZhY3RvciBmb3IgM0RcbiAgICAgIHZhciBpID0gTWF0aC5mbG9vcih4aW4gKyBzKTtcbiAgICAgIHZhciBqID0gTWF0aC5mbG9vcih5aW4gKyBzKTtcbiAgICAgIHZhciBrID0gTWF0aC5mbG9vcih6aW4gKyBzKTtcbiAgICAgIHZhciB0ID0gKGkgKyBqICsgaykgKiBHMztcbiAgICAgIHZhciBYMCA9IGkgLSB0OyAvLyBVbnNrZXcgdGhlIGNlbGwgb3JpZ2luIGJhY2sgdG8gKHgseSx6KSBzcGFjZVxuICAgICAgdmFyIFkwID0gaiAtIHQ7XG4gICAgICB2YXIgWjAgPSBrIC0gdDtcbiAgICAgIHZhciB4MCA9IHhpbiAtIFgwOyAvLyBUaGUgeCx5LHogZGlzdGFuY2VzIGZyb20gdGhlIGNlbGwgb3JpZ2luXG4gICAgICB2YXIgeTAgPSB5aW4gLSBZMDtcbiAgICAgIHZhciB6MCA9IHppbiAtIFowO1xuICAgICAgLy8gRm9yIHRoZSAzRCBjYXNlLCB0aGUgc2ltcGxleCBzaGFwZSBpcyBhIHNsaWdodGx5IGlycmVndWxhciB0ZXRyYWhlZHJvbi5cbiAgICAgIC8vIERldGVybWluZSB3aGljaCBzaW1wbGV4IHdlIGFyZSBpbi5cbiAgICAgIHZhciBpMSwgajEsIGsxOyAvLyBPZmZzZXRzIGZvciBzZWNvbmQgY29ybmVyIG9mIHNpbXBsZXggaW4gKGksaixrKSBjb29yZHNcbiAgICAgIHZhciBpMiwgajIsIGsyOyAvLyBPZmZzZXRzIGZvciB0aGlyZCBjb3JuZXIgb2Ygc2ltcGxleCBpbiAoaSxqLGspIGNvb3Jkc1xuICAgICAgaWYgKHgwID49IHkwKSB7XG4gICAgICAgIGlmICh5MCA+PSB6MCkge1xuICAgICAgICAgIGkxID0gMTtcbiAgICAgICAgICBqMSA9IDA7XG4gICAgICAgICAgazEgPSAwO1xuICAgICAgICAgIGkyID0gMTtcbiAgICAgICAgICBqMiA9IDE7XG4gICAgICAgICAgazIgPSAwO1xuICAgICAgICB9IC8vIFggWSBaIG9yZGVyXG4gICAgICAgIGVsc2UgaWYgKHgwID49IHowKSB7XG4gICAgICAgICAgaTEgPSAxO1xuICAgICAgICAgIGoxID0gMDtcbiAgICAgICAgICBrMSA9IDA7XG4gICAgICAgICAgaTIgPSAxO1xuICAgICAgICAgIGoyID0gMDtcbiAgICAgICAgICBrMiA9IDE7XG4gICAgICAgIH0gLy8gWCBaIFkgb3JkZXJcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaTEgPSAwO1xuICAgICAgICAgIGoxID0gMDtcbiAgICAgICAgICBrMSA9IDE7XG4gICAgICAgICAgaTIgPSAxO1xuICAgICAgICAgIGoyID0gMDtcbiAgICAgICAgICBrMiA9IDE7XG4gICAgICAgIH0gLy8gWiBYIFkgb3JkZXJcbiAgICAgIH1cbiAgICAgIGVsc2UgeyAvLyB4MDx5MFxuICAgICAgICBpZiAoeTAgPCB6MCkge1xuICAgICAgICAgIGkxID0gMDtcbiAgICAgICAgICBqMSA9IDA7XG4gICAgICAgICAgazEgPSAxO1xuICAgICAgICAgIGkyID0gMDtcbiAgICAgICAgICBqMiA9IDE7XG4gICAgICAgICAgazIgPSAxO1xuICAgICAgICB9IC8vIFogWSBYIG9yZGVyXG4gICAgICAgIGVsc2UgaWYgKHgwIDwgejApIHtcbiAgICAgICAgICBpMSA9IDA7XG4gICAgICAgICAgajEgPSAxO1xuICAgICAgICAgIGsxID0gMDtcbiAgICAgICAgICBpMiA9IDA7XG4gICAgICAgICAgajIgPSAxO1xuICAgICAgICAgIGsyID0gMTtcbiAgICAgICAgfSAvLyBZIFogWCBvcmRlclxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpMSA9IDA7XG4gICAgICAgICAgajEgPSAxO1xuICAgICAgICAgIGsxID0gMDtcbiAgICAgICAgICBpMiA9IDE7XG4gICAgICAgICAgajIgPSAxO1xuICAgICAgICAgIGsyID0gMDtcbiAgICAgICAgfSAvLyBZIFggWiBvcmRlclxuICAgICAgfVxuICAgICAgLy8gQSBzdGVwIG9mICgxLDAsMCkgaW4gKGksaixrKSBtZWFucyBhIHN0ZXAgb2YgKDEtYywtYywtYykgaW4gKHgseSx6KSxcbiAgICAgIC8vIGEgc3RlcCBvZiAoMCwxLDApIGluIChpLGosaykgbWVhbnMgYSBzdGVwIG9mICgtYywxLWMsLWMpIGluICh4LHkseiksIGFuZFxuICAgICAgLy8gYSBzdGVwIG9mICgwLDAsMSkgaW4gKGksaixrKSBtZWFucyBhIHN0ZXAgb2YgKC1jLC1jLDEtYykgaW4gKHgseSx6KSwgd2hlcmVcbiAgICAgIC8vIGMgPSAxLzYuXG4gICAgICB2YXIgeDEgPSB4MCAtIGkxICsgRzM7IC8vIE9mZnNldHMgZm9yIHNlY29uZCBjb3JuZXIgaW4gKHgseSx6KSBjb29yZHNcbiAgICAgIHZhciB5MSA9IHkwIC0gajEgKyBHMztcbiAgICAgIHZhciB6MSA9IHowIC0gazEgKyBHMztcbiAgICAgIHZhciB4MiA9IHgwIC0gaTIgKyAyLjAgKiBHMzsgLy8gT2Zmc2V0cyBmb3IgdGhpcmQgY29ybmVyIGluICh4LHkseikgY29vcmRzXG4gICAgICB2YXIgeTIgPSB5MCAtIGoyICsgMi4wICogRzM7XG4gICAgICB2YXIgejIgPSB6MCAtIGsyICsgMi4wICogRzM7XG4gICAgICB2YXIgeDMgPSB4MCAtIDEuMCArIDMuMCAqIEczOyAvLyBPZmZzZXRzIGZvciBsYXN0IGNvcm5lciBpbiAoeCx5LHopIGNvb3Jkc1xuICAgICAgdmFyIHkzID0geTAgLSAxLjAgKyAzLjAgKiBHMztcbiAgICAgIHZhciB6MyA9IHowIC0gMS4wICsgMy4wICogRzM7XG4gICAgICAvLyBXb3JrIG91dCB0aGUgaGFzaGVkIGdyYWRpZW50IGluZGljZXMgb2YgdGhlIGZvdXIgc2ltcGxleCBjb3JuZXJzXG4gICAgICB2YXIgaWkgPSBpICYgMjU1O1xuICAgICAgdmFyIGpqID0gaiAmIDI1NTtcbiAgICAgIHZhciBrayA9IGsgJiAyNTU7XG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGNvbnRyaWJ1dGlvbiBmcm9tIHRoZSBmb3VyIGNvcm5lcnNcbiAgICAgIHZhciB0MCA9IDAuNiAtIHgwICogeDAgLSB5MCAqIHkwIC0gejAgKiB6MDtcbiAgICAgIGlmICh0MCA8IDApIG4wID0gMC4wO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBnaTAgPSBwZXJtTW9kMTJbaWkgKyBwZXJtW2pqICsgcGVybVtra11dXSAqIDM7XG4gICAgICAgIHQwICo9IHQwO1xuICAgICAgICBuMCA9IHQwICogdDAgKiAoZ3JhZDNbZ2kwXSAqIHgwICsgZ3JhZDNbZ2kwICsgMV0gKiB5MCArIGdyYWQzW2dpMCArIDJdICogejApO1xuICAgICAgfVxuICAgICAgdmFyIHQxID0gMC42IC0geDEgKiB4MSAtIHkxICogeTEgLSB6MSAqIHoxO1xuICAgICAgaWYgKHQxIDwgMCkgbjEgPSAwLjA7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGdpMSA9IHBlcm1Nb2QxMltpaSArIGkxICsgcGVybVtqaiArIGoxICsgcGVybVtrayArIGsxXV1dICogMztcbiAgICAgICAgdDEgKj0gdDE7XG4gICAgICAgIG4xID0gdDEgKiB0MSAqIChncmFkM1tnaTFdICogeDEgKyBncmFkM1tnaTEgKyAxXSAqIHkxICsgZ3JhZDNbZ2kxICsgMl0gKiB6MSk7XG4gICAgICB9XG4gICAgICB2YXIgdDIgPSAwLjYgLSB4MiAqIHgyIC0geTIgKiB5MiAtIHoyICogejI7XG4gICAgICBpZiAodDIgPCAwKSBuMiA9IDAuMDtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgZ2kyID0gcGVybU1vZDEyW2lpICsgaTIgKyBwZXJtW2pqICsgajIgKyBwZXJtW2trICsgazJdXV0gKiAzO1xuICAgICAgICB0MiAqPSB0MjtcbiAgICAgICAgbjIgPSB0MiAqIHQyICogKGdyYWQzW2dpMl0gKiB4MiArIGdyYWQzW2dpMiArIDFdICogeTIgKyBncmFkM1tnaTIgKyAyXSAqIHoyKTtcbiAgICAgIH1cbiAgICAgIHZhciB0MyA9IDAuNiAtIHgzICogeDMgLSB5MyAqIHkzIC0gejMgKiB6MztcbiAgICAgIGlmICh0MyA8IDApIG4zID0gMC4wO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBnaTMgPSBwZXJtTW9kMTJbaWkgKyAxICsgcGVybVtqaiArIDEgKyBwZXJtW2trICsgMV1dXSAqIDM7XG4gICAgICAgIHQzICo9IHQzO1xuICAgICAgICBuMyA9IHQzICogdDMgKiAoZ3JhZDNbZ2kzXSAqIHgzICsgZ3JhZDNbZ2kzICsgMV0gKiB5MyArIGdyYWQzW2dpMyArIDJdICogejMpO1xuICAgICAgfVxuICAgICAgLy8gQWRkIGNvbnRyaWJ1dGlvbnMgZnJvbSBlYWNoIGNvcm5lciB0byBnZXQgdGhlIGZpbmFsIG5vaXNlIHZhbHVlLlxuICAgICAgLy8gVGhlIHJlc3VsdCBpcyBzY2FsZWQgdG8gc3RheSBqdXN0IGluc2lkZSBbLTEsMV1cbiAgICAgIHJldHVybiAzMi4wICogKG4wICsgbjEgKyBuMiArIG4zKTtcbiAgICB9LFxuICAgIC8vIDREIHNpbXBsZXggbm9pc2UsIGJldHRlciBzaW1wbGV4IHJhbmsgb3JkZXJpbmcgbWV0aG9kIDIwMTItMDMtMDlcbiAgICBub2lzZTREOiBmdW5jdGlvbih4LCB5LCB6LCB3KSB7XG4gICAgICB2YXIgcGVybSA9IHRoaXMucGVybTtcbiAgICAgIHZhciBncmFkNCA9IHRoaXMuZ3JhZDQ7XG5cbiAgICAgIHZhciBuMCwgbjEsIG4yLCBuMywgbjQ7IC8vIE5vaXNlIGNvbnRyaWJ1dGlvbnMgZnJvbSB0aGUgZml2ZSBjb3JuZXJzXG4gICAgICAvLyBTa2V3IHRoZSAoeCx5LHosdykgc3BhY2UgdG8gZGV0ZXJtaW5lIHdoaWNoIGNlbGwgb2YgMjQgc2ltcGxpY2VzIHdlJ3JlIGluXG4gICAgICB2YXIgcyA9ICh4ICsgeSArIHogKyB3KSAqIEY0OyAvLyBGYWN0b3IgZm9yIDREIHNrZXdpbmdcbiAgICAgIHZhciBpID0gTWF0aC5mbG9vcih4ICsgcyk7XG4gICAgICB2YXIgaiA9IE1hdGguZmxvb3IoeSArIHMpO1xuICAgICAgdmFyIGsgPSBNYXRoLmZsb29yKHogKyBzKTtcbiAgICAgIHZhciBsID0gTWF0aC5mbG9vcih3ICsgcyk7XG4gICAgICB2YXIgdCA9IChpICsgaiArIGsgKyBsKSAqIEc0OyAvLyBGYWN0b3IgZm9yIDREIHVuc2tld2luZ1xuICAgICAgdmFyIFgwID0gaSAtIHQ7IC8vIFVuc2tldyB0aGUgY2VsbCBvcmlnaW4gYmFjayB0byAoeCx5LHosdykgc3BhY2VcbiAgICAgIHZhciBZMCA9IGogLSB0O1xuICAgICAgdmFyIFowID0gayAtIHQ7XG4gICAgICB2YXIgVzAgPSBsIC0gdDtcbiAgICAgIHZhciB4MCA9IHggLSBYMDsgLy8gVGhlIHgseSx6LHcgZGlzdGFuY2VzIGZyb20gdGhlIGNlbGwgb3JpZ2luXG4gICAgICB2YXIgeTAgPSB5IC0gWTA7XG4gICAgICB2YXIgejAgPSB6IC0gWjA7XG4gICAgICB2YXIgdzAgPSB3IC0gVzA7XG4gICAgICAvLyBGb3IgdGhlIDREIGNhc2UsIHRoZSBzaW1wbGV4IGlzIGEgNEQgc2hhcGUgSSB3b24ndCBldmVuIHRyeSB0byBkZXNjcmliZS5cbiAgICAgIC8vIFRvIGZpbmQgb3V0IHdoaWNoIG9mIHRoZSAyNCBwb3NzaWJsZSBzaW1wbGljZXMgd2UncmUgaW4sIHdlIG5lZWQgdG9cbiAgICAgIC8vIGRldGVybWluZSB0aGUgbWFnbml0dWRlIG9yZGVyaW5nIG9mIHgwLCB5MCwgejAgYW5kIHcwLlxuICAgICAgLy8gU2l4IHBhaXItd2lzZSBjb21wYXJpc29ucyBhcmUgcGVyZm9ybWVkIGJldHdlZW4gZWFjaCBwb3NzaWJsZSBwYWlyXG4gICAgICAvLyBvZiB0aGUgZm91ciBjb29yZGluYXRlcywgYW5kIHRoZSByZXN1bHRzIGFyZSB1c2VkIHRvIHJhbmsgdGhlIG51bWJlcnMuXG4gICAgICB2YXIgcmFua3ggPSAwO1xuICAgICAgdmFyIHJhbmt5ID0gMDtcbiAgICAgIHZhciByYW5reiA9IDA7XG4gICAgICB2YXIgcmFua3cgPSAwO1xuICAgICAgaWYgKHgwID4geTApIHJhbmt4Kys7XG4gICAgICBlbHNlIHJhbmt5Kys7XG4gICAgICBpZiAoeDAgPiB6MCkgcmFua3grKztcbiAgICAgIGVsc2UgcmFua3orKztcbiAgICAgIGlmICh4MCA+IHcwKSByYW5reCsrO1xuICAgICAgZWxzZSByYW5rdysrO1xuICAgICAgaWYgKHkwID4gejApIHJhbmt5Kys7XG4gICAgICBlbHNlIHJhbmt6Kys7XG4gICAgICBpZiAoeTAgPiB3MCkgcmFua3krKztcbiAgICAgIGVsc2UgcmFua3crKztcbiAgICAgIGlmICh6MCA+IHcwKSByYW5reisrO1xuICAgICAgZWxzZSByYW5rdysrO1xuICAgICAgdmFyIGkxLCBqMSwgazEsIGwxOyAvLyBUaGUgaW50ZWdlciBvZmZzZXRzIGZvciB0aGUgc2Vjb25kIHNpbXBsZXggY29ybmVyXG4gICAgICB2YXIgaTIsIGoyLCBrMiwgbDI7IC8vIFRoZSBpbnRlZ2VyIG9mZnNldHMgZm9yIHRoZSB0aGlyZCBzaW1wbGV4IGNvcm5lclxuICAgICAgdmFyIGkzLCBqMywgazMsIGwzOyAvLyBUaGUgaW50ZWdlciBvZmZzZXRzIGZvciB0aGUgZm91cnRoIHNpbXBsZXggY29ybmVyXG4gICAgICAvLyBzaW1wbGV4W2NdIGlzIGEgNC12ZWN0b3Igd2l0aCB0aGUgbnVtYmVycyAwLCAxLCAyIGFuZCAzIGluIHNvbWUgb3JkZXIuXG4gICAgICAvLyBNYW55IHZhbHVlcyBvZiBjIHdpbGwgbmV2ZXIgb2NjdXIsIHNpbmNlIGUuZy4geD55Pno+dyBtYWtlcyB4PHosIHk8dyBhbmQgeDx3XG4gICAgICAvLyBpbXBvc3NpYmxlLiBPbmx5IHRoZSAyNCBpbmRpY2VzIHdoaWNoIGhhdmUgbm9uLXplcm8gZW50cmllcyBtYWtlIGFueSBzZW5zZS5cbiAgICAgIC8vIFdlIHVzZSBhIHRocmVzaG9sZGluZyB0byBzZXQgdGhlIGNvb3JkaW5hdGVzIGluIHR1cm4gZnJvbSB0aGUgbGFyZ2VzdCBtYWduaXR1ZGUuXG4gICAgICAvLyBSYW5rIDMgZGVub3RlcyB0aGUgbGFyZ2VzdCBjb29yZGluYXRlLlxuICAgICAgaTEgPSByYW5reCA+PSAzID8gMSA6IDA7XG4gICAgICBqMSA9IHJhbmt5ID49IDMgPyAxIDogMDtcbiAgICAgIGsxID0gcmFua3ogPj0gMyA/IDEgOiAwO1xuICAgICAgbDEgPSByYW5rdyA+PSAzID8gMSA6IDA7XG4gICAgICAvLyBSYW5rIDIgZGVub3RlcyB0aGUgc2Vjb25kIGxhcmdlc3QgY29vcmRpbmF0ZS5cbiAgICAgIGkyID0gcmFua3ggPj0gMiA/IDEgOiAwO1xuICAgICAgajIgPSByYW5reSA+PSAyID8gMSA6IDA7XG4gICAgICBrMiA9IHJhbmt6ID49IDIgPyAxIDogMDtcbiAgICAgIGwyID0gcmFua3cgPj0gMiA/IDEgOiAwO1xuICAgICAgLy8gUmFuayAxIGRlbm90ZXMgdGhlIHNlY29uZCBzbWFsbGVzdCBjb29yZGluYXRlLlxuICAgICAgaTMgPSByYW5reCA+PSAxID8gMSA6IDA7XG4gICAgICBqMyA9IHJhbmt5ID49IDEgPyAxIDogMDtcbiAgICAgIGszID0gcmFua3ogPj0gMSA/IDEgOiAwO1xuICAgICAgbDMgPSByYW5rdyA+PSAxID8gMSA6IDA7XG4gICAgICAvLyBUaGUgZmlmdGggY29ybmVyIGhhcyBhbGwgY29vcmRpbmF0ZSBvZmZzZXRzID0gMSwgc28gbm8gbmVlZCB0byBjb21wdXRlIHRoYXQuXG4gICAgICB2YXIgeDEgPSB4MCAtIGkxICsgRzQ7IC8vIE9mZnNldHMgZm9yIHNlY29uZCBjb3JuZXIgaW4gKHgseSx6LHcpIGNvb3Jkc1xuICAgICAgdmFyIHkxID0geTAgLSBqMSArIEc0O1xuICAgICAgdmFyIHoxID0gejAgLSBrMSArIEc0O1xuICAgICAgdmFyIHcxID0gdzAgLSBsMSArIEc0O1xuICAgICAgdmFyIHgyID0geDAgLSBpMiArIDIuMCAqIEc0OyAvLyBPZmZzZXRzIGZvciB0aGlyZCBjb3JuZXIgaW4gKHgseSx6LHcpIGNvb3Jkc1xuICAgICAgdmFyIHkyID0geTAgLSBqMiArIDIuMCAqIEc0O1xuICAgICAgdmFyIHoyID0gejAgLSBrMiArIDIuMCAqIEc0O1xuICAgICAgdmFyIHcyID0gdzAgLSBsMiArIDIuMCAqIEc0O1xuICAgICAgdmFyIHgzID0geDAgLSBpMyArIDMuMCAqIEc0OyAvLyBPZmZzZXRzIGZvciBmb3VydGggY29ybmVyIGluICh4LHkseix3KSBjb29yZHNcbiAgICAgIHZhciB5MyA9IHkwIC0gajMgKyAzLjAgKiBHNDtcbiAgICAgIHZhciB6MyA9IHowIC0gazMgKyAzLjAgKiBHNDtcbiAgICAgIHZhciB3MyA9IHcwIC0gbDMgKyAzLjAgKiBHNDtcbiAgICAgIHZhciB4NCA9IHgwIC0gMS4wICsgNC4wICogRzQ7IC8vIE9mZnNldHMgZm9yIGxhc3QgY29ybmVyIGluICh4LHkseix3KSBjb29yZHNcbiAgICAgIHZhciB5NCA9IHkwIC0gMS4wICsgNC4wICogRzQ7XG4gICAgICB2YXIgejQgPSB6MCAtIDEuMCArIDQuMCAqIEc0O1xuICAgICAgdmFyIHc0ID0gdzAgLSAxLjAgKyA0LjAgKiBHNDtcbiAgICAgIC8vIFdvcmsgb3V0IHRoZSBoYXNoZWQgZ3JhZGllbnQgaW5kaWNlcyBvZiB0aGUgZml2ZSBzaW1wbGV4IGNvcm5lcnNcbiAgICAgIHZhciBpaSA9IGkgJiAyNTU7XG4gICAgICB2YXIgamogPSBqICYgMjU1O1xuICAgICAgdmFyIGtrID0gayAmIDI1NTtcbiAgICAgIHZhciBsbCA9IGwgJiAyNTU7XG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGNvbnRyaWJ1dGlvbiBmcm9tIHRoZSBmaXZlIGNvcm5lcnNcbiAgICAgIHZhciB0MCA9IDAuNiAtIHgwICogeDAgLSB5MCAqIHkwIC0gejAgKiB6MCAtIHcwICogdzA7XG4gICAgICBpZiAodDAgPCAwKSBuMCA9IDAuMDtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgZ2kwID0gKHBlcm1baWkgKyBwZXJtW2pqICsgcGVybVtrayArIHBlcm1bbGxdXV1dICUgMzIpICogNDtcbiAgICAgICAgdDAgKj0gdDA7XG4gICAgICAgIG4wID0gdDAgKiB0MCAqIChncmFkNFtnaTBdICogeDAgKyBncmFkNFtnaTAgKyAxXSAqIHkwICsgZ3JhZDRbZ2kwICsgMl0gKiB6MCArIGdyYWQ0W2dpMCArIDNdICogdzApO1xuICAgICAgfVxuICAgICAgdmFyIHQxID0gMC42IC0geDEgKiB4MSAtIHkxICogeTEgLSB6MSAqIHoxIC0gdzEgKiB3MTtcbiAgICAgIGlmICh0MSA8IDApIG4xID0gMC4wO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBnaTEgPSAocGVybVtpaSArIGkxICsgcGVybVtqaiArIGoxICsgcGVybVtrayArIGsxICsgcGVybVtsbCArIGwxXV1dXSAlIDMyKSAqIDQ7XG4gICAgICAgIHQxICo9IHQxO1xuICAgICAgICBuMSA9IHQxICogdDEgKiAoZ3JhZDRbZ2kxXSAqIHgxICsgZ3JhZDRbZ2kxICsgMV0gKiB5MSArIGdyYWQ0W2dpMSArIDJdICogejEgKyBncmFkNFtnaTEgKyAzXSAqIHcxKTtcbiAgICAgIH1cbiAgICAgIHZhciB0MiA9IDAuNiAtIHgyICogeDIgLSB5MiAqIHkyIC0gejIgKiB6MiAtIHcyICogdzI7XG4gICAgICBpZiAodDIgPCAwKSBuMiA9IDAuMDtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgZ2kyID0gKHBlcm1baWkgKyBpMiArIHBlcm1bamogKyBqMiArIHBlcm1ba2sgKyBrMiArIHBlcm1bbGwgKyBsMl1dXV0gJSAzMikgKiA0O1xuICAgICAgICB0MiAqPSB0MjtcbiAgICAgICAgbjIgPSB0MiAqIHQyICogKGdyYWQ0W2dpMl0gKiB4MiArIGdyYWQ0W2dpMiArIDFdICogeTIgKyBncmFkNFtnaTIgKyAyXSAqIHoyICsgZ3JhZDRbZ2kyICsgM10gKiB3Mik7XG4gICAgICB9XG4gICAgICB2YXIgdDMgPSAwLjYgLSB4MyAqIHgzIC0geTMgKiB5MyAtIHozICogejMgLSB3MyAqIHczO1xuICAgICAgaWYgKHQzIDwgMCkgbjMgPSAwLjA7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGdpMyA9IChwZXJtW2lpICsgaTMgKyBwZXJtW2pqICsgajMgKyBwZXJtW2trICsgazMgKyBwZXJtW2xsICsgbDNdXV1dICUgMzIpICogNDtcbiAgICAgICAgdDMgKj0gdDM7XG4gICAgICAgIG4zID0gdDMgKiB0MyAqIChncmFkNFtnaTNdICogeDMgKyBncmFkNFtnaTMgKyAxXSAqIHkzICsgZ3JhZDRbZ2kzICsgMl0gKiB6MyArIGdyYWQ0W2dpMyArIDNdICogdzMpO1xuICAgICAgfVxuICAgICAgdmFyIHQ0ID0gMC42IC0geDQgKiB4NCAtIHk0ICogeTQgLSB6NCAqIHo0IC0gdzQgKiB3NDtcbiAgICAgIGlmICh0NCA8IDApIG40ID0gMC4wO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBnaTQgPSAocGVybVtpaSArIDEgKyBwZXJtW2pqICsgMSArIHBlcm1ba2sgKyAxICsgcGVybVtsbCArIDFdXV1dICUgMzIpICogNDtcbiAgICAgICAgdDQgKj0gdDQ7XG4gICAgICAgIG40ID0gdDQgKiB0NCAqIChncmFkNFtnaTRdICogeDQgKyBncmFkNFtnaTQgKyAxXSAqIHk0ICsgZ3JhZDRbZ2k0ICsgMl0gKiB6NCArIGdyYWQ0W2dpNCArIDNdICogdzQpO1xuICAgICAgfVxuICAgICAgLy8gU3VtIHVwIGFuZCBzY2FsZSB0aGUgcmVzdWx0IHRvIGNvdmVyIHRoZSByYW5nZSBbLTEsMV1cbiAgICAgIHJldHVybiAyNy4wICogKG4wICsgbjEgKyBuMiArIG4zICsgbjQpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBidWlsZFBlcm11dGF0aW9uVGFibGUocmFuZG9tKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHAgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgcFtpXSA9IGk7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCAyNTU7IGkrKykge1xuICAgICAgdmFyIHIgPSBpICsgfn4ocmFuZG9tKCkgKiAoMjU2IC0gaSkpO1xuICAgICAgdmFyIGF1eCA9IHBbaV07XG4gICAgICBwW2ldID0gcFtyXTtcbiAgICAgIHBbcl0gPSBhdXg7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9XG4gIFNpbXBsZXhOb2lzZS5fYnVpbGRQZXJtdXRhdGlvblRhYmxlID0gYnVpbGRQZXJtdXRhdGlvblRhYmxlO1xuXG4gIGZ1bmN0aW9uIGFsZWEoKSB7XG4gICAgLy8gSm9oYW5uZXMgQmFhZ8O4ZSA8YmFhZ29lQGJhYWdvZS5jb20+LCAyMDEwXG4gICAgdmFyIHMwID0gMDtcbiAgICB2YXIgczEgPSAwO1xuICAgIHZhciBzMiA9IDA7XG4gICAgdmFyIGMgPSAxO1xuXG4gICAgdmFyIG1hc2ggPSBtYXNoZXIoKTtcbiAgICBzMCA9IG1hc2goJyAnKTtcbiAgICBzMSA9IG1hc2goJyAnKTtcbiAgICBzMiA9IG1hc2goJyAnKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzMCAtPSBtYXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICBpZiAoczAgPCAwKSB7XG4gICAgICAgIHMwICs9IDE7XG4gICAgICB9XG4gICAgICBzMSAtPSBtYXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICBpZiAoczEgPCAwKSB7XG4gICAgICAgIHMxICs9IDE7XG4gICAgICB9XG4gICAgICBzMiAtPSBtYXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICBpZiAoczIgPCAwKSB7XG4gICAgICAgIHMyICs9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIG1hc2ggPSBudWxsO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0ID0gMjA5MTYzOSAqIHMwICsgYyAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7IC8vIDJeLTMyXG4gICAgICBzMCA9IHMxO1xuICAgICAgczEgPSBzMjtcbiAgICAgIHJldHVybiBzMiA9IHQgLSAoYyA9IHQgfCAwKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIG1hc2hlcigpIHtcbiAgICB2YXIgbiA9IDB4ZWZjODI0OWQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbiArPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBoID0gMC4wMjUxOTYwMzI4MjQxNjkzOCAqIG47XG4gICAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgICBoIC09IG47XG4gICAgICAgIGggKj0gbjtcbiAgICAgICAgbiA9IGggPj4+IDA7XG4gICAgICAgIGggLT0gbjtcbiAgICAgICAgbiArPSBoICogMHgxMDAwMDAwMDA7IC8vIDJeMzJcbiAgICAgIH1cbiAgICAgIHJldHVybiAobiA+Pj4gMCkgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICAgIH07XG4gIH1cblxuICAvLyBhbWRcbiAgaWYgKHR5cGVvZiBkZWZpbmUgIT09ICd1bmRlZmluZWQnICYmIGRlZmluZS5hbWQpIGRlZmluZShmdW5jdGlvbigpIHtyZXR1cm4gU2ltcGxleE5vaXNlO30pO1xuICAvLyBjb21tb24ganNcbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykgZXhwb3J0cy5TaW1wbGV4Tm9pc2UgPSBTaW1wbGV4Tm9pc2U7XG4gIC8vIGJyb3dzZXJcbiAgZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHdpbmRvdy5TaW1wbGV4Tm9pc2UgPSBTaW1wbGV4Tm9pc2U7XG4gIC8vIG5vZGVqc1xuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNpbXBsZXhOb2lzZTtcbiAgfVxuXG59KSgpO1xuIiwiLypcbiAoYykgMjAxNywgVmxhZGltaXIgQWdhZm9ua2luXG4gU2ltcGxpZnkuanMsIGEgaGlnaC1wZXJmb3JtYW5jZSBKUyBwb2x5bGluZSBzaW1wbGlmaWNhdGlvbiBsaWJyYXJ5XG4gbW91cm5lci5naXRodWIuaW8vc2ltcGxpZnktanNcbiovXG5cbihmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuLy8gdG8gc3VpdCB5b3VyIHBvaW50IGZvcm1hdCwgcnVuIHNlYXJjaC9yZXBsYWNlIGZvciAnLngnIGFuZCAnLnknO1xuLy8gZm9yIDNEIHZlcnNpb24sIHNlZSAzZCBicmFuY2ggKGNvbmZpZ3VyYWJpbGl0eSB3b3VsZCBkcmF3IHNpZ25pZmljYW50IHBlcmZvcm1hbmNlIG92ZXJoZWFkKVxuXG4vLyBzcXVhcmUgZGlzdGFuY2UgYmV0d2VlbiAyIHBvaW50c1xuZnVuY3Rpb24gZ2V0U3FEaXN0KHAxLCBwMikge1xuXG4gICAgdmFyIGR4ID0gcDEueCAtIHAyLngsXG4gICAgICAgIGR5ID0gcDEueSAtIHAyLnk7XG5cbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbi8vIHNxdWFyZSBkaXN0YW5jZSBmcm9tIGEgcG9pbnQgdG8gYSBzZWdtZW50XG5mdW5jdGlvbiBnZXRTcVNlZ0Rpc3QocCwgcDEsIHAyKSB7XG5cbiAgICB2YXIgeCA9IHAxLngsXG4gICAgICAgIHkgPSBwMS55LFxuICAgICAgICBkeCA9IHAyLnggLSB4LFxuICAgICAgICBkeSA9IHAyLnkgLSB5O1xuXG4gICAgaWYgKGR4ICE9PSAwIHx8IGR5ICE9PSAwKSB7XG5cbiAgICAgICAgdmFyIHQgPSAoKHAueCAtIHgpICogZHggKyAocC55IC0geSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgIGlmICh0ID4gMSkge1xuICAgICAgICAgICAgeCA9IHAyLng7XG4gICAgICAgICAgICB5ID0gcDIueTtcblxuICAgICAgICB9IGVsc2UgaWYgKHQgPiAwKSB7XG4gICAgICAgICAgICB4ICs9IGR4ICogdDtcbiAgICAgICAgICAgIHkgKz0gZHkgKiB0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZHggPSBwLnggLSB4O1xuICAgIGR5ID0gcC55IC0geTtcblxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cbi8vIHJlc3Qgb2YgdGhlIGNvZGUgZG9lc24ndCBjYXJlIGFib3V0IHBvaW50IGZvcm1hdFxuXG4vLyBiYXNpYyBkaXN0YW5jZS1iYXNlZCBzaW1wbGlmaWNhdGlvblxuZnVuY3Rpb24gc2ltcGxpZnlSYWRpYWxEaXN0KHBvaW50cywgc3FUb2xlcmFuY2UpIHtcblxuICAgIHZhciBwcmV2UG9pbnQgPSBwb2ludHNbMF0sXG4gICAgICAgIG5ld1BvaW50cyA9IFtwcmV2UG9pbnRdLFxuICAgICAgICBwb2ludDtcblxuICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG5cbiAgICAgICAgaWYgKGdldFNxRGlzdChwb2ludCwgcHJldlBvaW50KSA+IHNxVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICBuZXdQb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgICAgICBwcmV2UG9pbnQgPSBwb2ludDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2UG9pbnQgIT09IHBvaW50KSBuZXdQb2ludHMucHVzaChwb2ludCk7XG5cbiAgICByZXR1cm4gbmV3UG9pbnRzO1xufVxuXG5mdW5jdGlvbiBzaW1wbGlmeURQU3RlcChwb2ludHMsIGZpcnN0LCBsYXN0LCBzcVRvbGVyYW5jZSwgc2ltcGxpZmllZCkge1xuICAgIHZhciBtYXhTcURpc3QgPSBzcVRvbGVyYW5jZSxcbiAgICAgICAgaW5kZXg7XG5cbiAgICBmb3IgKHZhciBpID0gZmlyc3QgKyAxOyBpIDwgbGFzdDsgaSsrKSB7XG4gICAgICAgIHZhciBzcURpc3QgPSBnZXRTcVNlZ0Rpc3QocG9pbnRzW2ldLCBwb2ludHNbZmlyc3RdLCBwb2ludHNbbGFzdF0pO1xuXG4gICAgICAgIGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcbiAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgIG1heFNxRGlzdCA9IHNxRGlzdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xuICAgICAgICBpZiAoaW5kZXggLSBmaXJzdCA+IDEpIHNpbXBsaWZ5RFBTdGVwKHBvaW50cywgZmlyc3QsIGluZGV4LCBzcVRvbGVyYW5jZSwgc2ltcGxpZmllZCk7XG4gICAgICAgIHNpbXBsaWZpZWQucHVzaChwb2ludHNbaW5kZXhdKTtcbiAgICAgICAgaWYgKGxhc3QgLSBpbmRleCA+IDEpIHNpbXBsaWZ5RFBTdGVwKHBvaW50cywgaW5kZXgsIGxhc3QsIHNxVG9sZXJhbmNlLCBzaW1wbGlmaWVkKTtcbiAgICB9XG59XG5cbi8vIHNpbXBsaWZpY2F0aW9uIHVzaW5nIFJhbWVyLURvdWdsYXMtUGV1Y2tlciBhbGdvcml0aG1cbmZ1bmN0aW9uIHNpbXBsaWZ5RG91Z2xhc1BldWNrZXIocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xuICAgIHZhciBsYXN0ID0gcG9pbnRzLmxlbmd0aCAtIDE7XG5cbiAgICB2YXIgc2ltcGxpZmllZCA9IFtwb2ludHNbMF1dO1xuICAgIHNpbXBsaWZ5RFBTdGVwKHBvaW50cywgMCwgbGFzdCwgc3FUb2xlcmFuY2UsIHNpbXBsaWZpZWQpO1xuICAgIHNpbXBsaWZpZWQucHVzaChwb2ludHNbbGFzdF0pO1xuXG4gICAgcmV0dXJuIHNpbXBsaWZpZWQ7XG59XG5cbi8vIGJvdGggYWxnb3JpdGhtcyBjb21iaW5lZCBmb3IgYXdlc29tZSBwZXJmb3JtYW5jZVxuZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzLCB0b2xlcmFuY2UsIGhpZ2hlc3RRdWFsaXR5KSB7XG5cbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8PSAyKSByZXR1cm4gcG9pbnRzO1xuXG4gICAgdmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICE9PSB1bmRlZmluZWQgPyB0b2xlcmFuY2UgKiB0b2xlcmFuY2UgOiAxO1xuXG4gICAgcG9pbnRzID0gaGlnaGVzdFF1YWxpdHkgPyBwb2ludHMgOiBzaW1wbGlmeVJhZGlhbERpc3QocG9pbnRzLCBzcVRvbGVyYW5jZSk7XG4gICAgcG9pbnRzID0gc2ltcGxpZnlEb3VnbGFzUGV1Y2tlcihwb2ludHMsIHNxVG9sZXJhbmNlKTtcblxuICAgIHJldHVybiBwb2ludHM7XG59XG5cbi8vIGV4cG9ydCBhcyBBTUQgbW9kdWxlIC8gTm9kZSBtb2R1bGUgLyBicm93c2VyIG9yIHdvcmtlciB2YXJpYWJsZVxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gc2ltcGxpZnk7IH0pO1xuZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNpbXBsaWZ5O1xuICAgIG1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBzaW1wbGlmeTtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSBzZWxmLnNpbXBsaWZ5ID0gc2ltcGxpZnk7XG5lbHNlIHdpbmRvdy5zaW1wbGlmeSA9IHNpbXBsaWZ5O1xuXG59KSgpO1xuIiwiaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xyXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xyXG5pbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xyXG5pbXBvcnQgeyBNYXBHZW5lcmF0b3IgfSBmcm9tICcuL21hcF9nZW5lcmF0b3InO1xyXG5cclxuLyoqXHJcbiAqIE1haW4gZW50cnkgcG9pbnQgZm9yIHRoZSBtYXAgZ2VuZXJhdG9yIHNjcmlwdFxyXG4gKiBVc2VzIGEgZml4ZWQgaW5wdXQgcGF0aCBmb3IgdGhlIEpTT04gY29uZmlndXJhdGlvbiBmaWxlIGFuZCBnZW5lcmF0ZXMgYSBtYXAgd2l0aCBzZXBhcmF0ZSBTVkcgZWxlbWVudHNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtYWluKCk6IHZvaWQge1xyXG4gICAgLy8gVXNlIGEgZml4ZWQgaW5wdXQgcGF0aCBmb3IgdGhlIGNvbmZpZ3VyYXRpb24gZmlsZVxyXG4gICAgY29uc3QgY29uZmlnUGF0aCA9ICdDOlxcXFxBUFBcXFxcQ09ERVxcXFxNYXBHZW5lcmF0b3JcXFxcc3JjXFxcXHRlc3RpbnB1dFxcXFxpbnB1dC5qc29uJztcclxuXHJcbiAgICBjb25zb2xlLmxvZyhgVXNpbmcgY29uZmlndXJhdGlvbiBmaWxlOiAke2NvbmZpZ1BhdGh9YCk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyBDcmVhdGUgYW5kIHJ1biB0aGUgbWFwIGdlbmVyYXRvclxyXG4gICAgICAgIGNvbnN0IG1hcEdlbmVyYXRvciA9IG5ldyBNYXBHZW5lcmF0b3IoY29uZmlnUGF0aCk7XHJcbiAgICAgICAgbWFwR2VuZXJhdG9yLmdlbmVyYXRlKCkuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdlbmVyYXRpbmcgbWFwOlwiLCBlcnIpO1xyXG4gICAgICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW5pdGlhbGl6aW5nIG1hcCBnZW5lcmF0b3I6XCIsIGVycik7XHJcbiAgICAgICAgcHJvY2Vzcy5leGl0KDEpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyBDYWxsIHRoZSBtYWluIGZ1bmN0aW9uIHdoZW4gdGhlIHNjcmlwdCBpcyBleGVjdXRlZFxyXG5tYWluKCk7XHJcbiIsImltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcclxuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcclxuaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcclxuaW1wb3J0IFRlbnNvckZpZWxkR1VJIGZyb20gJy4vdHMvdWkvdGVuc29yX2ZpZWxkX2d1aSc7XHJcbmltcG9ydCBNYWluR1VJIGZyb20gJy4vdHMvdWkvbWFpbl9ndWknO1xyXG5pbXBvcnQge0RlZmF1bHRDYW52YXNXcmFwcGVyfSBmcm9tICcuL3RzL3VpL2NhbnZhc193cmFwcGVyJztcclxuaW1wb3J0IERvbWFpbkNvbnRyb2xsZXIgZnJvbSAnLi90cy91aS9kb21haW5fY29udHJvbGxlcic7XHJcbmltcG9ydCBEcmFnQ29udHJvbGxlciBmcm9tICcuL3RzL3VpL2RyYWdfY29udHJvbGxlcic7XHJcbmltcG9ydCBTdHlsZSBmcm9tICcuL3RzL3VpL3N0eWxlJztcclxuaW1wb3J0IHtEZWZhdWx0U3R5bGV9IGZyb20gJy4vdHMvdWkvc3R5bGUnO1xyXG5pbXBvcnQgVmVjdG9yIGZyb20gJy4vdHMvdmVjdG9yJztcclxuaW1wb3J0IHtOb2lzZVBhcmFtc30gZnJvbSAnLi90cy9pbXBsL3RlbnNvcl9maWVsZCc7XHJcbmltcG9ydCB7U1ZHfSBmcm9tICdAc3ZnZG90anMvc3ZnLmpzJztcclxuaW1wb3J0IHsgc2F2ZUFzIH0gZnJvbSAnZmlsZS1zYXZlcic7XHJcblxyXG4vKipcclxuICogTWFwIEdlbmVyYXRvciBjbGFzcyB0aGF0IGdlbmVyYXRlcyBhIG1hcCBmcm9tIGEgSlNPTiBjb25maWd1cmF0aW9uIGZpbGVcclxuICogYW5kIGV4cG9ydHMgc2VwYXJhdGUgU1ZHIGZpbGVzIGZvciBkaWZmZXJlbnQgbWFwIGVsZW1lbnRzIHdpdGggdW5pcXVlIElEc1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE1hcEdlbmVyYXRvciB7XHJcbiAgICBwcml2YXRlIGRvbWFpbkNvbnRyb2xsZXIgPSBEb21haW5Db250cm9sbGVyLmdldEluc3RhbmNlKCk7XHJcbiAgICBwcml2YXRlIGRyYWdDb250cm9sbGVyID0gbmV3IERyYWdDb250cm9sbGVyKG51bGwpOyAvLyBObyBHVUlcclxuICAgIHByaXZhdGUgdGVuc29yRmllbGQ6IFRlbnNvckZpZWxkR1VJO1xyXG4gICAgcHJpdmF0ZSBtYWluR3VpOiBNYWluR1VJO1xyXG4gICAgcHJpdmF0ZSBzdHlsZTogU3R5bGU7XHJcbiAgICBwcml2YXRlIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQ7XHJcbiAgICBwcml2YXRlIGNvbmZpZzogYW55O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ1BhdGg6IHN0cmluZykge1xyXG4gICAgICAgIC8vIFJlYWQgYW5kIHBhcnNlIHRoZSBjb25maWd1cmF0aW9uIGZpbGVcclxuICAgICAgICBjb25zdCBjb25maWdEYXRhID0gZnMucmVhZEZpbGVTeW5jKGNvbmZpZ1BhdGgsICd1dGY4Jyk7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBKU09OLnBhcnNlKGNvbmZpZ0RhdGEpO1xyXG5cclxuICAgICAgICAvLyBTZXQgdXAgdGhlIGRvbWFpbiBjb250cm9sbGVyXHJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnpvb20gJiYgdGhpcy5jb25maWcuem9vbS56b29tKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tID0gdGhpcy5jb25maWcuem9vbS56b29tO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgY2FudmFzIGVsZW1lbnRcclxuICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gMTQ0MDtcclxuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSA5MDA7XHJcblxyXG4gICAgICAgIC8vIFNldCB1cCB0aGUgdGVuc29yIGZpZWxkXHJcbiAgICAgICAgY29uc3Qgbm9pc2VQYXJhbXNQbGFjZWhvbGRlcjogTm9pc2VQYXJhbXMgPSB7XHJcbiAgICAgICAgICAgIGdsb2JhbE5vaXNlOiBmYWxzZSxcclxuICAgICAgICAgICAgbm9pc2VTaXplUGFyazogMjAsXHJcbiAgICAgICAgICAgIG5vaXNlQW5nbGVQYXJrOiA5MCxcclxuICAgICAgICAgICAgbm9pc2VTaXplR2xvYmFsOiAzMCxcclxuICAgICAgICAgICAgbm9pc2VBbmdsZUdsb2JhbDogMjBcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLnRlbnNvckZpZWxkID0gbmV3IFRlbnNvckZpZWxkR1VJKG51bGwsIHRoaXMuZHJhZ0NvbnRyb2xsZXIsIFxyXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5vcHRpb25zPy5kcmF3Q2VudGVyIHx8IGZhbHNlLCBub2lzZVBhcmFtc1BsYWNlaG9sZGVyKTtcclxuXHJcbiAgICAgICAgLy8gQ29uZmlndXJlIHRlbnNvciBmaWVsZCBiYXNlZCBvbiBjb25maWdcclxuICAgICAgICBpZiAodGhpcy5jb25maWcudGVuc29yRmllbGQpIHtcclxuICAgICAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5zbW9vdGggPSB0aGlzLmNvbmZpZy50ZW5zb3JGaWVsZC5zbW9vdGggfHwgZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgZ3JpZHMgYW5kIHJhZGlhbHMgaWYgc3BlY2lmaWVkXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy50ZW5zb3JGaWVsZC5ncmlkcyAmJiB0aGlzLmNvbmZpZy50ZW5zb3JGaWVsZC5ncmlkcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGdyaWQgb2YgdGhpcy5jb25maWcudGVuc29yRmllbGQuZ3JpZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgZ3JpZCB3aXRoIHBhcmFtZXRlcnMgZnJvbSBjb25maWdcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdvdWxkIG5lZWQgdG8gYmUgaW1wbGVtZW50ZWQgYmFzZWQgb24gdGhlIGFjdHVhbCBncmlkIHBhcmFtZXRlcnNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFVzZSByZWNvbW1lbmRlZCBzZXR1cCBpZiBubyBncmlkcyBzcGVjaWZpZWRcclxuICAgICAgICAgICAgICAgIHRoaXMudGVuc29yRmllbGQuc2V0UmVjb21tZW5kZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFVzZSByZWNvbW1lbmRlZCBzZXR1cCBpZiBubyB0ZW5zb3IgZmllbGQgY29uZmlnXHJcbiAgICAgICAgICAgIHRoaXMudGVuc29yRmllbGQuc2V0UmVjb21tZW5kZWQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNldCB1cCB0aGUgbWFpbiBHVUlcclxuICAgICAgICB0aGlzLm1haW5HdWkgPSBuZXcgTWFpbkdVSShudWxsLCB0aGlzLnRlbnNvckZpZWxkLCAoKSA9PiB7fSk7XHJcblxyXG4gICAgICAgIC8vIENvbmZpZ3VyZSBtYXAgcGFyYW1ldGVycyBiYXNlZCBvbiBjb25maWdcclxuICAgICAgICBpZiAodGhpcy5jb25maWcubWFwKSB7XHJcbiAgICAgICAgICAgIC8vIFNldCBhbmltYXRpb24gcGFyYW1ldGVyc1xyXG4gICAgICAgICAgICB0aGlzLm1haW5HdWkuYW5pbWF0ZSA9IHRoaXMuY29uZmlnLm1hcC5hbmltYXRlICE9PSB1bmRlZmluZWQgPyB0aGlzLmNvbmZpZy5tYXAuYW5pbWF0ZSA6IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMubWFpbkd1aS5hbmltYXRpb25TcGVlZCA9IHRoaXMuY29uZmlnLm1hcC5hbmltYXRlU3BlZWQgfHwgMzA7XHJcblxyXG4gICAgICAgICAgICAvLyBDb25maWd1cmUgd2F0ZXIgcGFyYW1ldGVyc1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcubWFwLndhdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB3YXRlclBhcmFtcyA9IHRoaXMubWFpbkd1aS5jb2FzdGxpbmUucGFyYW1zO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXAud2F0ZXIuc2ltcGxpZnlUb2xlcmFuY2UgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhdGVyUGFyYW1zLnNpbXBsaWZ5VG9sZXJhbmNlID0gdGhpcy5jb25maWcubWFwLndhdGVyLnNpbXBsaWZ5VG9sZXJhbmNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXAud2F0ZXIuY29hc3RsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2F0ZXJQYXJhbXMuY29hc3ROb2lzZS5ub2lzZUVuYWJsZWQgPSB0aGlzLmNvbmZpZy5tYXAud2F0ZXIuY29hc3RsaW5lLm5vaXNlRW5hYmxlZCAhPT0gdW5kZWZpbmVkID8gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLm1hcC53YXRlci5jb2FzdGxpbmUubm9pc2VFbmFibGVkIDogdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB3YXRlclBhcmFtcy5jb2FzdE5vaXNlLm5vaXNlU2l6ZSA9IHRoaXMuY29uZmlnLm1hcC53YXRlci5jb2FzdGxpbmUubm9pc2VTaXplIHx8IDMwO1xyXG4gICAgICAgICAgICAgICAgICAgIHdhdGVyUGFyYW1zLmNvYXN0Tm9pc2Uubm9pc2VBbmdsZSA9IHRoaXMuY29uZmlnLm1hcC53YXRlci5jb2FzdGxpbmUubm9pc2VBbmdsZSB8fCAyMDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcubWFwLndhdGVyLnJpdmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2F0ZXJQYXJhbXMucml2ZXJOb2lzZS5ub2lzZUVuYWJsZWQgPSB0aGlzLmNvbmZpZy5tYXAud2F0ZXIucml2ZXIubm9pc2VFbmFibGVkICE9PSB1bmRlZmluZWQgPyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcubWFwLndhdGVyLnJpdmVyLm5vaXNlRW5hYmxlZCA6IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgd2F0ZXJQYXJhbXMucml2ZXJOb2lzZS5ub2lzZVNpemUgPSB0aGlzLmNvbmZpZy5tYXAud2F0ZXIucml2ZXIubm9pc2VTaXplIHx8IDMwO1xyXG4gICAgICAgICAgICAgICAgICAgIHdhdGVyUGFyYW1zLnJpdmVyTm9pc2Uubm9pc2VBbmdsZSA9IHRoaXMuY29uZmlnLm1hcC53YXRlci5yaXZlci5ub2lzZUFuZ2xlIHx8IDIwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXAud2F0ZXIuZGV2UGFyYW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLm1hcC53YXRlci5kZXZQYXJhbXMuZHNlcCAhPT0gdW5kZWZpbmVkKSB3YXRlclBhcmFtcy5kc2VwID0gdGhpcy5jb25maWcubWFwLndhdGVyLmRldlBhcmFtcy5kc2VwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXAud2F0ZXIuZGV2UGFyYW1zLmR0ZXN0ICE9PSB1bmRlZmluZWQpIHdhdGVyUGFyYW1zLmR0ZXN0ID0gdGhpcy5jb25maWcubWFwLndhdGVyLmRldlBhcmFtcy5kdGVzdDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcubWFwLndhdGVyLmRldlBhcmFtcy5wYXRoSXRlcmF0aW9ucyAhPT0gdW5kZWZpbmVkKSB3YXRlclBhcmFtcy5wYXRoSXRlcmF0aW9ucyA9IHRoaXMuY29uZmlnLm1hcC53YXRlci5kZXZQYXJhbXMucGF0aEl0ZXJhdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLm1hcC53YXRlci5kZXZQYXJhbXMuc2VlZFRyaWVzICE9PSB1bmRlZmluZWQpIHdhdGVyUGFyYW1zLnNlZWRUcmllcyA9IHRoaXMuY29uZmlnLm1hcC53YXRlci5kZXZQYXJhbXMuc2VlZFRyaWVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXAud2F0ZXIuZGV2UGFyYW1zLmRzdGVwICE9PSB1bmRlZmluZWQpIHdhdGVyUGFyYW1zLmRzdGVwID0gdGhpcy5jb25maWcubWFwLndhdGVyLmRldlBhcmFtcy5kc3RlcDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcubWFwLndhdGVyLmRldlBhcmFtcy5kbG9va2FoZWFkICE9PSB1bmRlZmluZWQpIHdhdGVyUGFyYW1zLmRsb29rYWhlYWQgPSB0aGlzLmNvbmZpZy5tYXAud2F0ZXIuZGV2UGFyYW1zLmRsb29rYWhlYWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLm1hcC53YXRlci5kZXZQYXJhbXMuZGNpcmNsZWpvaW4gIT09IHVuZGVmaW5lZCkgd2F0ZXJQYXJhbXMuZGNpcmNsZWpvaW4gPSB0aGlzLmNvbmZpZy5tYXAud2F0ZXIuZGV2UGFyYW1zLmRjaXJjbGVqb2luO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXAud2F0ZXIuZGV2UGFyYW1zLmpvaW5hbmdsZSAhPT0gdW5kZWZpbmVkKSB3YXRlclBhcmFtcy5qb2luYW5nbGUgPSB0aGlzLmNvbmZpZy5tYXAud2F0ZXIuZGV2UGFyYW1zLmpvaW5hbmdsZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ29uZmlndXJlIHJvYWQgcGFyYW1ldGVyc1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcubWFwLm1haW4pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1haW5QYXJhbXMgPSB0aGlzLm1haW5HdWkubWFpblJvYWRzLnBhcmFtcztcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXAubWFpbi5kc2VwICE9PSB1bmRlZmluZWQpIG1haW5QYXJhbXMuZHNlcCA9IHRoaXMuY29uZmlnLm1hcC5tYWluLmRzZXA7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcubWFwLm1haW4uZHRlc3QgIT09IHVuZGVmaW5lZCkgbWFpblBhcmFtcy5kdGVzdCA9IHRoaXMuY29uZmlnLm1hcC5tYWluLmR0ZXN0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXAubWFpbi5kZXZQYXJhbXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcubWFwLm1haW4uZGV2UGFyYW1zLnBhdGhJdGVyYXRpb25zICE9PSB1bmRlZmluZWQpIG1haW5QYXJhbXMucGF0aEl0ZXJhdGlvbnMgPSB0aGlzLmNvbmZpZy5tYXAubWFpbi5kZXZQYXJhbXMucGF0aEl0ZXJhdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLm1hcC5tYWluLmRldlBhcmFtcy5zZWVkVHJpZXMgIT09IHVuZGVmaW5lZCkgbWFpblBhcmFtcy5zZWVkVHJpZXMgPSB0aGlzLmNvbmZpZy5tYXAubWFpbi5kZXZQYXJhbXMuc2VlZFRyaWVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXAubWFpbi5kZXZQYXJhbXMuZHN0ZXAgIT09IHVuZGVmaW5lZCkgbWFpblBhcmFtcy5kc3RlcCA9IHRoaXMuY29uZmlnLm1hcC5tYWluLmRldlBhcmFtcy5kc3RlcDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcubWFwLm1haW4uZGV2UGFyYW1zLmRsb29rYWhlYWQgIT09IHVuZGVmaW5lZCkgbWFpblBhcmFtcy5kbG9va2FoZWFkID0gdGhpcy5jb25maWcubWFwLm1haW4uZGV2UGFyYW1zLmRsb29rYWhlYWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLm1hcC5tYWluLmRldlBhcmFtcy5kY2lyY2xlam9pbiAhPT0gdW5kZWZpbmVkKSBtYWluUGFyYW1zLmRjaXJjbGVqb2luID0gdGhpcy5jb25maWcubWFwLm1haW4uZGV2UGFyYW1zLmRjaXJjbGVqb2luO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXAubWFpbi5kZXZQYXJhbXMuam9pbmFuZ2xlICE9PSB1bmRlZmluZWQpIG1haW5QYXJhbXMuam9pbmFuZ2xlID0gdGhpcy5jb25maWcubWFwLm1haW4uZGV2UGFyYW1zLmpvaW5hbmdsZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcubWFwLm1haW4uZGV2UGFyYW1zLnNpbXBsaWZ5VG9sZXJhbmNlICE9PSB1bmRlZmluZWQpIG1haW5QYXJhbXMuc2ltcGxpZnlUb2xlcmFuY2UgPSB0aGlzLmNvbmZpZy5tYXAubWFpbi5kZXZQYXJhbXMuc2ltcGxpZnlUb2xlcmFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLm1hcC5tYWluLmRldlBhcmFtcy5jb2xsaWRlRWFybHkgIT09IHVuZGVmaW5lZCkgbWFpblBhcmFtcy5jb2xsaWRlRWFybHkgPSB0aGlzLmNvbmZpZy5tYXAubWFpbi5kZXZQYXJhbXMuY29sbGlkZUVhcmx5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDb25maWd1cmUgbWFqb3Igcm9hZCBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXAubWFqb3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1ham9yUGFyYW1zID0gdGhpcy5tYWluR3VpLm1ham9yUm9hZHMucGFyYW1zO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLm1hcC5tYWpvci5kc2VwICE9PSB1bmRlZmluZWQpIG1ham9yUGFyYW1zLmRzZXAgPSB0aGlzLmNvbmZpZy5tYXAubWFqb3IuZHNlcDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXAubWFqb3IuZHRlc3QgIT09IHVuZGVmaW5lZCkgbWFqb3JQYXJhbXMuZHRlc3QgPSB0aGlzLmNvbmZpZy5tYXAubWFqb3IuZHRlc3Q7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLm1hcC5tYWpvci5kZXZQYXJhbXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcubWFwLm1ham9yLmRldlBhcmFtcy5wYXRoSXRlcmF0aW9ucyAhPT0gdW5kZWZpbmVkKSBtYWpvclBhcmFtcy5wYXRoSXRlcmF0aW9ucyA9IHRoaXMuY29uZmlnLm1hcC5tYWpvci5kZXZQYXJhbXMucGF0aEl0ZXJhdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLm1hcC5tYWpvci5kZXZQYXJhbXMuc2VlZFRyaWVzICE9PSB1bmRlZmluZWQpIG1ham9yUGFyYW1zLnNlZWRUcmllcyA9IHRoaXMuY29uZmlnLm1hcC5tYWpvci5kZXZQYXJhbXMuc2VlZFRyaWVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXAubWFqb3IuZGV2UGFyYW1zLmRzdGVwICE9PSB1bmRlZmluZWQpIG1ham9yUGFyYW1zLmRzdGVwID0gdGhpcy5jb25maWcubWFwLm1ham9yLmRldlBhcmFtcy5kc3RlcDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcubWFwLm1ham9yLmRldlBhcmFtcy5kbG9va2FoZWFkICE9PSB1bmRlZmluZWQpIG1ham9yUGFyYW1zLmRsb29rYWhlYWQgPSB0aGlzLmNvbmZpZy5tYXAubWFqb3IuZGV2UGFyYW1zLmRsb29rYWhlYWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLm1hcC5tYWpvci5kZXZQYXJhbXMuZGNpcmNsZWpvaW4gIT09IHVuZGVmaW5lZCkgbWFqb3JQYXJhbXMuZGNpcmNsZWpvaW4gPSB0aGlzLmNvbmZpZy5tYXAubWFqb3IuZGV2UGFyYW1zLmRjaXJjbGVqb2luO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXAubWFqb3IuZGV2UGFyYW1zLmpvaW5hbmdsZSAhPT0gdW5kZWZpbmVkKSBtYWpvclBhcmFtcy5qb2luYW5nbGUgPSB0aGlzLmNvbmZpZy5tYXAubWFqb3IuZGV2UGFyYW1zLmpvaW5hbmdsZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcubWFwLm1ham9yLmRldlBhcmFtcy5zaW1wbGlmeVRvbGVyYW5jZSAhPT0gdW5kZWZpbmVkKSBtYWpvclBhcmFtcy5zaW1wbGlmeVRvbGVyYW5jZSA9IHRoaXMuY29uZmlnLm1hcC5tYWpvci5kZXZQYXJhbXMuc2ltcGxpZnlUb2xlcmFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLm1hcC5tYWpvci5kZXZQYXJhbXMuY29sbGlkZUVhcmx5ICE9PSB1bmRlZmluZWQpIG1ham9yUGFyYW1zLmNvbGxpZGVFYXJseSA9IHRoaXMuY29uZmlnLm1hcC5tYWpvci5kZXZQYXJhbXMuY29sbGlkZUVhcmx5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDb25maWd1cmUgbWlub3Igcm9hZCBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXAubWlub3IpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1pbm9yUGFyYW1zID0gdGhpcy5tYWluR3VpLm1pbm9yUm9hZHMucGFyYW1zO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLm1hcC5taW5vci5kc2VwICE9PSB1bmRlZmluZWQpIG1pbm9yUGFyYW1zLmRzZXAgPSB0aGlzLmNvbmZpZy5tYXAubWlub3IuZHNlcDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXAubWlub3IuZHRlc3QgIT09IHVuZGVmaW5lZCkgbWlub3JQYXJhbXMuZHRlc3QgPSB0aGlzLmNvbmZpZy5tYXAubWlub3IuZHRlc3Q7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLm1hcC5taW5vci5kZXZQYXJhbXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcubWFwLm1pbm9yLmRldlBhcmFtcy5wYXRoSXRlcmF0aW9ucyAhPT0gdW5kZWZpbmVkKSBtaW5vclBhcmFtcy5wYXRoSXRlcmF0aW9ucyA9IHRoaXMuY29uZmlnLm1hcC5taW5vci5kZXZQYXJhbXMucGF0aEl0ZXJhdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLm1hcC5taW5vci5kZXZQYXJhbXMuc2VlZFRyaWVzICE9PSB1bmRlZmluZWQpIG1pbm9yUGFyYW1zLnNlZWRUcmllcyA9IHRoaXMuY29uZmlnLm1hcC5taW5vci5kZXZQYXJhbXMuc2VlZFRyaWVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXAubWlub3IuZGV2UGFyYW1zLmRzdGVwICE9PSB1bmRlZmluZWQpIG1pbm9yUGFyYW1zLmRzdGVwID0gdGhpcy5jb25maWcubWFwLm1pbm9yLmRldlBhcmFtcy5kc3RlcDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcubWFwLm1pbm9yLmRldlBhcmFtcy5kbG9va2FoZWFkICE9PSB1bmRlZmluZWQpIG1pbm9yUGFyYW1zLmRsb29rYWhlYWQgPSB0aGlzLmNvbmZpZy5tYXAubWlub3IuZGV2UGFyYW1zLmRsb29rYWhlYWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLm1hcC5taW5vci5kZXZQYXJhbXMuZGNpcmNsZWpvaW4gIT09IHVuZGVmaW5lZCkgbWlub3JQYXJhbXMuZGNpcmNsZWpvaW4gPSB0aGlzLmNvbmZpZy5tYXAubWlub3IuZGV2UGFyYW1zLmRjaXJjbGVqb2luO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXAubWlub3IuZGV2UGFyYW1zLmpvaW5hbmdsZSAhPT0gdW5kZWZpbmVkKSBtaW5vclBhcmFtcy5qb2luYW5nbGUgPSB0aGlzLmNvbmZpZy5tYXAubWlub3IuZGV2UGFyYW1zLmpvaW5hbmdsZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcubWFwLm1pbm9yLmRldlBhcmFtcy5zaW1wbGlmeVRvbGVyYW5jZSAhPT0gdW5kZWZpbmVkKSBtaW5vclBhcmFtcy5zaW1wbGlmeVRvbGVyYW5jZSA9IHRoaXMuY29uZmlnLm1hcC5taW5vci5kZXZQYXJhbXMuc2ltcGxpZnlUb2xlcmFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLm1hcC5taW5vci5kZXZQYXJhbXMuY29sbGlkZUVhcmx5ICE9PSB1bmRlZmluZWQpIG1pbm9yUGFyYW1zLmNvbGxpZGVFYXJseSA9IHRoaXMuY29uZmlnLm1hcC5taW5vci5kZXZQYXJhbXMuY29sbGlkZUVhcmx5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDb25maWd1cmUgcGFyayBwYXJhbWV0ZXJzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXAucGFya3MpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFpbkd1aS5jbHVzdGVyQmlnUGFya3MgPSB0aGlzLmNvbmZpZy5tYXAucGFya3MuY2x1c3RlckJpZ1BhcmtzICE9PSB1bmRlZmluZWQgPyBcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5tYXAucGFya3MuY2x1c3RlckJpZ1BhcmtzIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1haW5HdWkubnVtQmlnUGFya3MgPSB0aGlzLmNvbmZpZy5tYXAucGFya3MubnVtQmlnUGFya3MgfHwgMjtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFpbkd1aS5udW1TbWFsbFBhcmtzID0gdGhpcy5jb25maWcubWFwLnBhcmtzLm51bVNtYWxsUGFya3MgfHwgMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ29uZmlndXJlIGJ1aWxkaW5nIHBhcmFtZXRlcnNcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLm1hcC5idWlsZGluZ3MpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJ1aWxkaW5nUGFyYW1zID0gdGhpcy5tYWluR3VpLmJ1aWxkaW5ncy5wYXJhbXM7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcubWFwLmJ1aWxkaW5ncy5taW5BcmVhICE9PSB1bmRlZmluZWQpIGJ1aWxkaW5nUGFyYW1zLm1pbkFyZWEgPSB0aGlzLmNvbmZpZy5tYXAuYnVpbGRpbmdzLm1pbkFyZWE7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcubWFwLmJ1aWxkaW5ncy5zaHJpbmtTcGFjaW5nICE9PSB1bmRlZmluZWQpIGJ1aWxkaW5nUGFyYW1zLnNocmlua1NwYWNpbmcgPSB0aGlzLmNvbmZpZy5tYXAuYnVpbGRpbmdzLnNocmlua1NwYWNpbmc7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcubWFwLmJ1aWxkaW5ncy5jaGFuY2VOb0RpdmlkZSAhPT0gdW5kZWZpbmVkKSBidWlsZGluZ1BhcmFtcy5jaGFuY2VOb0RpdmlkZSA9IHRoaXMuY29uZmlnLm1hcC5idWlsZGluZ3MuY2hhbmNlTm9EaXZpZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNldCB1cCB0aGUgc3R5bGVcclxuICAgICAgICAvLyBVc2UgZGVmYXVsdCBjb2xvciBzY2hlbWUgYmFzZWQgb24gdGhlIHN0eWxlLmNvbG91clNjaGVtZSB2YWx1ZVxyXG4gICAgICAgIGNvbnN0IGNvbG91clNjaGVtZU5hbWUgPSB0aGlzLmNvbmZpZy5zdHlsZT8uY29sb3VyU2NoZW1lIHx8IFwiZGVmYXVsdFwiO1xyXG4gICAgICAgIC8vIENyZWF0ZSBhIHByb3BlciBDb2xvdXJTY2hlbWUgb2JqZWN0XHJcbiAgICAgICAgY29uc3QgY29sb3VyU2NoZW1lID0ge1xyXG4gICAgICAgICAgICBiZ0NvbG91cjogXCIjZmZmZmZmXCIsXHJcbiAgICAgICAgICAgIHNlYUNvbG91cjogXCIjNzdhYWZmXCIsXHJcbiAgICAgICAgICAgIG1pbm9yUm9hZENvbG91cjogXCIjZmZmZmZmXCIsXHJcbiAgICAgICAgICAgIHpvb21CdWlsZGluZ3M6IHRoaXMuY29uZmlnLnN0eWxlPy56b29tQnVpbGRpbmdzIHx8IGZhbHNlLFxyXG4gICAgICAgICAgICBidWlsZGluZ01vZGVsczogdGhpcy5jb25maWcuc3R5bGU/LmJ1aWxkaW5nTW9kZWxzIHx8IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93RnJhbWU6IHRoaXMuY29uZmlnLnN0eWxlPy5zaG93RnJhbWUgfHwgZmFsc2VcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBTZXQgY2FtZXJhIHByb3BlcnRpZXMgb24gdGhlIGRvbWFpbiBjb250cm9sbGVyXHJcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnN0eWxlPy5jYW1lcmFYICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLmNhbWVyYVggPSB0aGlzLmNvbmZpZy5zdHlsZS5jYW1lcmFYO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jb25maWcuc3R5bGU/LmNhbWVyYVkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuY2FtZXJhWSA9IHRoaXMuY29uZmlnLnN0eWxlLmNhbWVyYVk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5zdHlsZT8ub3J0aG9ncmFwaGljICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLm9ydGhvZ3JhcGhpYyA9IHRoaXMuY29uZmlnLnN0eWxlLm9ydGhvZ3JhcGhpYztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc3R5bGUgPSBuZXcgRGVmYXVsdFN0eWxlKHRoaXMuY2FudmFzLCB0aGlzLmRyYWdDb250cm9sbGVyLCBjb2xvdXJTY2hlbWUsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgLy8gU2V0IGhpZ2ggRFBJIGlmIHNwZWNpZmllZFxyXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5vcHRpb25zICYmIHRoaXMuY29uZmlnLm9wdGlvbnMuaGlnaERQSSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlLmNhbnZhc1NjYWxlID0gMjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZSB0aGUgbWFwIGFuZCBleHBvcnQgc2VwYXJhdGUgU1ZHIGZpbGVzIGZvciBkaWZmZXJlbnQgbWFwIGVsZW1lbnRzXHJcbiAgICAgKiBFYWNoIGVsZW1lbnQgd2lsbCBoYXZlIGEgdW5pcXVlIElEIGFuZCBiZSBleHBvcnRlZCBhcyBhIHNlcGFyYXRlIFNWRyBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0gY3VzdG9tT3V0cHV0RGlyIE9wdGlvbmFsIGN1c3RvbSBvdXRwdXQgZGlyZWN0b3J5IHBhdGhcclxuICAgICAqL1xyXG4gICAgYXN5bmMgZ2VuZXJhdGUoY3VzdG9tT3V0cHV0RGlyPzogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJHZW5lcmF0aW5nIG1hcC4uLlwiKTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgdGhlIG1hcFxyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLm1haW5HdWkuZ2VuZXJhdGVFdmVyeXRoaW5nKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgb3V0cHV0IGRpcmVjdG9yeVxyXG4gICAgICAgICAgICBsZXQgb3V0cHV0RGlyOiBzdHJpbmc7XHJcbiAgICAgICAgICAgIGlmIChjdXN0b21PdXRwdXREaXIpIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dERpciA9IGN1c3RvbU91dHB1dERpcjtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbmZpZy5vdXRwdXQ/LmRpcmVjdG9yeSkge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0RGlyID0gdGhpcy5jb25maWcub3V0cHV0LmRpcmVjdG9yeTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgb3V0cHV0IGRpcmVjdG9yeVxyXG4gICAgICAgICAgICAgICAgb3V0cHV0RGlyID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdvdXRwdXQnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIG91dHB1dCBkaXJlY3RvcnkgaWYgaXQgZG9lc24ndCBleGlzdFxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKG91dHB1dERpcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBmcy5ta2RpclN5bmMob3V0cHV0RGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjcmVhdGluZyBvdXRwdXQgZGlyZWN0b3J5ICR7b3V0cHV0RGlyfTpgLCBlcnIpO1xyXG4gICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gY3VycmVudCBkaXJlY3RvcnlcclxuICAgICAgICAgICAgICAgIG91dHB1dERpciA9IHByb2Nlc3MuY3dkKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRmFsbGluZyBiYWNrIHRvIGN1cnJlbnQgZGlyZWN0b3J5OiAke291dHB1dERpcn1gKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRXhwb3J0IFNWRyBmaWxlcyB3aXRoIHNlcGFyYXRlIGVsZW1lbnRzXHJcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXhwb3J0Q29hc3RsaW5lKG91dHB1dERpciksXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV4cG9ydFJpdmVyKG91dHB1dERpciksXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV4cG9ydFJvYWRzKG91dHB1dERpciksXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV4cG9ydFBhcmtzKG91dHB1dERpciksXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV4cG9ydEJ1aWxkaW5ncyhvdXRwdXREaXIpXHJcbiAgICAgICAgICAgIF0pO1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJNYXAgZ2VuZXJhdGlvbiBjb21wbGV0ZS4gU1ZHIGZpbGVzIGV4cG9ydGVkIHRvOlwiLCBvdXRwdXREaXIpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZHVyaW5nIG1hcCBnZW5lcmF0aW9uOlwiLCBlcnIpO1xyXG4gICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXhwb3J0IGNvYXN0bGluZSBhcyBhbiBTVkcgZmlsZSB3aXRoIHVuaXF1ZSBJRCBhbmQgc3R5bGluZ1xyXG4gICAgICogQHBhcmFtIG91dHB1dERpciBUaGUgZGlyZWN0b3J5IHRvIGV4cG9ydCB0aGUgU1ZHIGZpbGUgdG9cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhc3luYyBleHBvcnRDb2FzdGxpbmUob3V0cHV0RGlyOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBjb2FzdGxpbmUgPSB0aGlzLm1haW5HdWkuY29hc3RsaW5lUG9seWdvbjtcclxuICAgICAgICBpZiAoIWNvYXN0bGluZSB8fCBjb2FzdGxpbmUubGVuZ3RoID09PSAwKSByZXR1cm47XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBTVkcgZWxlbWVudCB3aXRoIHZpZXdCb3ggZm9yIGJldHRlciBzY2FsaW5nXHJcbiAgICAgICAgICAgIGNvbnN0IHN2Z0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInN2Z1wiKTtcclxuICAgICAgICAgICAgc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ4bWxuc1wiLCBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIpO1xyXG4gICAgICAgICAgICBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMTQ0MFwiKTtcclxuICAgICAgICAgICAgc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCI5MDBcIik7XHJcbiAgICAgICAgICAgIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBcIjAgMCAxNDQwIDkwMFwiKTtcclxuICAgICAgICAgICAgc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ2ZXJzaW9uXCIsIFwiMS4xXCIpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIFNWRy5qcyBpbnN0YW5jZVxyXG4gICAgICAgICAgICBjb25zdCBzdmdEb2MgPSBTVkcoc3ZnRWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAvLyBEcmF3IGNvYXN0bGluZSB3aXRoIHVuaXF1ZSBJRCBhbmQgc3R5bGluZ1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdQb2x5Z29uVG9TVkcoXHJcbiAgICAgICAgICAgICAgICBzdmdEb2MsIFxyXG4gICAgICAgICAgICAgICAgY29hc3RsaW5lLCBcclxuICAgICAgICAgICAgICAgIFwiY29hc3RsaW5lXCIsIFxyXG4gICAgICAgICAgICAgICAgXCIjNzdhYWZmXCIsIC8vIEZpbGwgY29sb3IgKHNlYSBibHVlKVxyXG4gICAgICAgICAgICAgICAgXCIjZmZmZmZmXCIsIC8vIFN0cm9rZSBjb2xvciAod2hpdGUpXHJcbiAgICAgICAgICAgICAgICAyICAgICAgICAgIC8vIFN0cm9rZSB3aWR0aFxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgLy8gU2VyaWFsaXplIFNWRyB0byBzdHJpbmdcclxuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplciA9IG5ldyBYTUxTZXJpYWxpemVyKCk7XHJcbiAgICAgICAgICAgIGxldCBzb3VyY2UgPSBzZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nKHN2Z0VsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgLy8gQWRkIFhNTCBkZWNsYXJhdGlvblxyXG4gICAgICAgICAgICBzb3VyY2UgPSAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIHN0YW5kYWxvbmU9XCJub1wiPz5cXHJcXG4nICsgc291cmNlO1xyXG5cclxuICAgICAgICAgICAgLy8gV3JpdGUgU1ZHIGZpbGVcclxuICAgICAgICAgICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLmpvaW4ob3V0cHV0RGlyLCBgY29hc3RsaW5lLnN2Z2ApO1xyXG4gICAgICAgICAgICBmcy53cml0ZUZpbGVTeW5jKGZpbGVQYXRoLCBzb3VyY2UpO1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coYEV4cG9ydGVkIGNvYXN0bGluZS5zdmdgKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZXhwb3J0aW5nIGNvYXN0bGluZS5zdmc6YCwgZXJyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHBvcnQgcml2ZXIgYXMgYW4gU1ZHIGZpbGUgd2l0aCB1bmlxdWUgSUQgYW5kIHN0eWxpbmdcclxuICAgICAqIEBwYXJhbSBvdXRwdXREaXIgVGhlIGRpcmVjdG9yeSB0byBleHBvcnQgdGhlIFNWRyBmaWxlIHRvXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYXN5bmMgZXhwb3J0Uml2ZXIob3V0cHV0RGlyOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCByaXZlciA9IHRoaXMubWFpbkd1aS5yaXZlclBvbHlnb247XHJcbiAgICAgICAgaWYgKCFyaXZlciB8fCByaXZlci5sZW5ndGggPT09IDApIHJldHVybjtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gQ3JlYXRlIFNWRyBlbGVtZW50IHdpdGggdmlld0JveCBmb3IgYmV0dGVyIHNjYWxpbmdcclxuICAgICAgICAgICAgY29uc3Qgc3ZnRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpO1xyXG4gICAgICAgICAgICBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZShcInhtbG5zXCIsIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIik7XHJcbiAgICAgICAgICAgIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIxNDQwXCIpO1xyXG4gICAgICAgICAgICBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjkwMFwiKTtcclxuICAgICAgICAgICAgc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIsIFwiMCAwIDE0NDAgOTAwXCIpO1xyXG4gICAgICAgICAgICBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZShcInZlcnNpb25cIiwgXCIxLjFcIik7XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgU1ZHLmpzIGluc3RhbmNlXHJcbiAgICAgICAgICAgIGNvbnN0IHN2Z0RvYyA9IFNWRyhzdmdFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vIERyYXcgcml2ZXIgd2l0aCB1bmlxdWUgSUQgYW5kIHN0eWxpbmdcclxuICAgICAgICAgICAgdGhpcy5kcmF3UG9seWdvblRvU1ZHKFxyXG4gICAgICAgICAgICAgICAgc3ZnRG9jLCBcclxuICAgICAgICAgICAgICAgIHJpdmVyLCBcclxuICAgICAgICAgICAgICAgIFwicml2ZXJcIiwgXHJcbiAgICAgICAgICAgICAgICBcIiM3N2FhZmZcIiwgLy8gRmlsbCBjb2xvciAocml2ZXIgYmx1ZSlcclxuICAgICAgICAgICAgICAgIFwiIzU1ODhkZFwiLCAvLyBTdHJva2UgY29sb3IgKGRhcmtlciBibHVlKVxyXG4gICAgICAgICAgICAgICAgMSAgICAgICAgICAvLyBTdHJva2Ugd2lkdGhcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBTVkcgdG8gc3RyaW5nXHJcbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXcgWE1MU2VyaWFsaXplcigpO1xyXG4gICAgICAgICAgICBsZXQgc291cmNlID0gc2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyhzdmdFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBYTUwgZGVjbGFyYXRpb25cclxuICAgICAgICAgICAgc291cmNlID0gJzw/eG1sIHZlcnNpb249XCIxLjBcIiBzdGFuZGFsb25lPVwibm9cIj8+XFxyXFxuJyArIHNvdXJjZTtcclxuXHJcbiAgICAgICAgICAgIC8vIFdyaXRlIFNWRyBmaWxlXHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKG91dHB1dERpciwgYHJpdmVyLnN2Z2ApO1xyXG4gICAgICAgICAgICBmcy53cml0ZUZpbGVTeW5jKGZpbGVQYXRoLCBzb3VyY2UpO1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coYEV4cG9ydGVkIHJpdmVyLnN2Z2ApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBleHBvcnRpbmcgcml2ZXIuc3ZnOmAsIGVycik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXhwb3J0IHJvYWRzIGFzIFNWRyBmaWxlcyB3aXRoIHVuaXF1ZSBJRHMgZm9yIGVhY2ggcm9hZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFzeW5jIGV4cG9ydFJvYWRzKG91dHB1dERpcjogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgLy8gRXhwb3J0IG1haW4gcm9hZHNcclxuICAgICAgICBhd2FpdCB0aGlzLmV4cG9ydFJvYWRUeXBlKHRoaXMubWFpbkd1aS5tYWluUm9hZFBvbHlnb25zLCBcIm1haW5fcm9hZHNcIiwgb3V0cHV0RGlyKTtcclxuXHJcbiAgICAgICAgLy8gRXhwb3J0IG1ham9yIHJvYWRzXHJcbiAgICAgICAgYXdhaXQgdGhpcy5leHBvcnRSb2FkVHlwZSh0aGlzLm1haW5HdWkubWFqb3JSb2FkUG9seWdvbnMsIFwibWFqb3Jfcm9hZHNcIiwgb3V0cHV0RGlyKTtcclxuXHJcbiAgICAgICAgLy8gRXhwb3J0IG1pbm9yIHJvYWRzXHJcbiAgICAgICAgYXdhaXQgdGhpcy5leHBvcnRSb2FkVHlwZSh0aGlzLm1haW5HdWkubWlub3JSb2FkUG9seWdvbnMsIFwibWlub3Jfcm9hZHNcIiwgb3V0cHV0RGlyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEV4cG9ydCBhIHNwZWNpZmljIHR5cGUgb2Ygcm9hZCBhcyBhbiBTVkcgZmlsZSB3aXRoIHVuaXF1ZSBJRHMgYW5kIHN0eWxpbmcgZm9yIGVhY2ggcm9hZFxyXG4gICAgICogQHBhcmFtIHJvYWRzIFRoZSByb2FkIHBvbHlnb25zIHRvIGV4cG9ydFxyXG4gICAgICogQHBhcmFtIHR5cGVOYW1lIFRoZSB0eXBlIG9mIHJvYWQgKG1haW5fcm9hZHMsIG1ham9yX3JvYWRzLCBtaW5vcl9yb2FkcylcclxuICAgICAqIEBwYXJhbSBvdXRwdXREaXIgVGhlIGRpcmVjdG9yeSB0byBleHBvcnQgdGhlIFNWRyBmaWxlIHRvXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYXN5bmMgZXhwb3J0Um9hZFR5cGUocm9hZHM6IFZlY3RvcltdW10sIHR5cGVOYW1lOiBzdHJpbmcsIG91dHB1dERpcjogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgaWYgKCFyb2FkcyB8fCByb2Fkcy5sZW5ndGggPT09IDApIHJldHVybjtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gQ3JlYXRlIFNWRyBlbGVtZW50IHdpdGggdmlld0JveCBmb3IgYmV0dGVyIHNjYWxpbmdcclxuICAgICAgICAgICAgY29uc3Qgc3ZnRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpO1xyXG4gICAgICAgICAgICBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZShcInhtbG5zXCIsIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIik7XHJcbiAgICAgICAgICAgIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIxNDQwXCIpO1xyXG4gICAgICAgICAgICBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjkwMFwiKTtcclxuICAgICAgICAgICAgc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIsIFwiMCAwIDE0NDAgOTAwXCIpO1xyXG4gICAgICAgICAgICBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZShcInZlcnNpb25cIiwgXCIxLjFcIik7XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgU1ZHLmpzIGluc3RhbmNlXHJcbiAgICAgICAgICAgIGNvbnN0IHN2Z0RvYyA9IFNWRyhzdmdFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNldCByb2FkIHN0eWxlIGJhc2VkIG9uIHR5cGVcclxuICAgICAgICAgICAgbGV0IHN0cm9rZUNvbG9yID0gJyNmZmZmZmYnO1xyXG4gICAgICAgICAgICBsZXQgc3Ryb2tlV2lkdGggPSAxO1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVOYW1lID09PSAnbWFpbl9yb2FkcycpIHtcclxuICAgICAgICAgICAgICAgIHN0cm9rZUNvbG9yID0gJyNmZmZmZmYnO1xyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGggPSAzO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVOYW1lID09PSAnbWFqb3Jfcm9hZHMnKSB7XHJcbiAgICAgICAgICAgICAgICBzdHJva2VDb2xvciA9ICcjZmZmZmZmJztcclxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoID0gMjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0cm9rZUNvbG9yID0gJyNlZWVlZWUnO1xyXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGggPSAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEcmF3IGVhY2ggcm9hZCB3aXRoIGEgdW5pcXVlIElEIGFuZCBzdHlsaW5nXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm9hZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1BvbHlnb25Ub1NWRyhcclxuICAgICAgICAgICAgICAgICAgICBzdmdEb2MsIFxyXG4gICAgICAgICAgICAgICAgICAgIHJvYWRzW2ldLCBcclxuICAgICAgICAgICAgICAgICAgICBgJHt0eXBlTmFtZX1fJHtpfWAsIFxyXG4gICAgICAgICAgICAgICAgICAgICdub25lJywgICAgICAgLy8gTm8gZmlsbCBmb3Igcm9hZHNcclxuICAgICAgICAgICAgICAgICAgICBzdHJva2VDb2xvciwgIC8vIFN0cm9rZSBjb2xvciBiYXNlZCBvbiByb2FkIHR5cGVcclxuICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aCAgIC8vIFN0cm9rZSB3aWR0aCBiYXNlZCBvbiByb2FkIHR5cGVcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBTVkcgdG8gc3RyaW5nXHJcbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXcgWE1MU2VyaWFsaXplcigpO1xyXG4gICAgICAgICAgICBsZXQgc291cmNlID0gc2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyhzdmdFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBYTUwgZGVjbGFyYXRpb25cclxuICAgICAgICAgICAgc291cmNlID0gJzw/eG1sIHZlcnNpb249XCIxLjBcIiBzdGFuZGFsb25lPVwibm9cIj8+XFxyXFxuJyArIHNvdXJjZTtcclxuXHJcbiAgICAgICAgICAgIC8vIFdyaXRlIFNWRyBmaWxlXHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKG91dHB1dERpciwgYCR7dHlwZU5hbWV9LnN2Z2ApO1xyXG4gICAgICAgICAgICBmcy53cml0ZUZpbGVTeW5jKGZpbGVQYXRoLCBzb3VyY2UpO1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coYEV4cG9ydGVkICR7dHlwZU5hbWV9LnN2ZyB3aXRoICR7cm9hZHMubGVuZ3RofSByb2Fkc2ApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBleHBvcnRpbmcgJHt0eXBlTmFtZX0uc3ZnOmAsIGVycik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXhwb3J0IHBhcmtzIGFzIGFuIFNWRyBmaWxlIHdpdGggdW5pcXVlIElEcyBhbmQgc3R5bGluZyBmb3IgZWFjaCBwYXJrXHJcbiAgICAgKiBAcGFyYW0gb3V0cHV0RGlyIFRoZSBkaXJlY3RvcnkgdG8gZXhwb3J0IHRoZSBTVkcgZmlsZSB0b1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGFzeW5jIGV4cG9ydFBhcmtzKG91dHB1dERpcjogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgcGFya3MgPSB0aGlzLnN0eWxlLnBhcmtzO1xyXG4gICAgICAgIGlmICghcGFya3MgfHwgcGFya3MubGVuZ3RoID09PSAwKSByZXR1cm47XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBTVkcgZWxlbWVudCB3aXRoIHZpZXdCb3ggZm9yIGJldHRlciBzY2FsaW5nXHJcbiAgICAgICAgICAgIGNvbnN0IHN2Z0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInN2Z1wiKTtcclxuICAgICAgICAgICAgc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ4bWxuc1wiLCBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIpO1xyXG4gICAgICAgICAgICBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMTQ0MFwiKTtcclxuICAgICAgICAgICAgc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCI5MDBcIik7XHJcbiAgICAgICAgICAgIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBcIjAgMCAxNDQwIDkwMFwiKTtcclxuICAgICAgICAgICAgc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ2ZXJzaW9uXCIsIFwiMS4xXCIpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIFNWRy5qcyBpbnN0YW5jZVxyXG4gICAgICAgICAgICBjb25zdCBzdmdEb2MgPSBTVkcoc3ZnRWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAvLyBEcmF3IGVhY2ggcGFyayB3aXRoIGEgdW5pcXVlIElEIGFuZCBzdHlsaW5nXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFya3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1BvbHlnb25Ub1NWRyhcclxuICAgICAgICAgICAgICAgICAgICBzdmdEb2MsIFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmtzW2ldLCBcclxuICAgICAgICAgICAgICAgICAgICBgcGFya18ke2l9YCwgXHJcbiAgICAgICAgICAgICAgICAgICAgJyM4OGNjODgnLCAgLy8gRmlsbCBjb2xvciAocGFyayBncmVlbilcclxuICAgICAgICAgICAgICAgICAgICAnIzY2YWE2NicsICAvLyBTdHJva2UgY29sb3IgKGRhcmtlciBncmVlbilcclxuICAgICAgICAgICAgICAgICAgICAxICAgICAgICAgICAvLyBTdHJva2Ugd2lkdGhcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBTVkcgdG8gc3RyaW5nXHJcbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXcgWE1MU2VyaWFsaXplcigpO1xyXG4gICAgICAgICAgICBsZXQgc291cmNlID0gc2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyhzdmdFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBYTUwgZGVjbGFyYXRpb25cclxuICAgICAgICAgICAgc291cmNlID0gJzw/eG1sIHZlcnNpb249XCIxLjBcIiBzdGFuZGFsb25lPVwibm9cIj8+XFxyXFxuJyArIHNvdXJjZTtcclxuXHJcbiAgICAgICAgICAgIC8vIFdyaXRlIFNWRyBmaWxlXHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKG91dHB1dERpciwgYHBhcmtzLnN2Z2ApO1xyXG4gICAgICAgICAgICBmcy53cml0ZUZpbGVTeW5jKGZpbGVQYXRoLCBzb3VyY2UpO1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coYEV4cG9ydGVkIHBhcmtzLnN2ZyB3aXRoICR7cGFya3MubGVuZ3RofSBwYXJrc2ApO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBleHBvcnRpbmcgcGFya3Muc3ZnOmAsIGVycik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXhwb3J0IGJ1aWxkaW5ncyBhcyBhbiBTVkcgZmlsZSB3aXRoIHVuaXF1ZSBJRHMgYW5kIHN0eWxpbmcgZm9yIGVhY2ggYnVpbGRpbmdcclxuICAgICAqIEBwYXJhbSBvdXRwdXREaXIgVGhlIGRpcmVjdG9yeSB0byBleHBvcnQgdGhlIFNWRyBmaWxlIHRvXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgYXN5bmMgZXhwb3J0QnVpbGRpbmdzKG91dHB1dERpcjogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgYmxvY2tzID0gYXdhaXQgdGhpcy5tYWluR3VpLmdldEJsb2NrcygpO1xyXG4gICAgICAgICAgICBpZiAoIWJsb2NrcyB8fCBibG9ja3MubGVuZ3RoID09PSAwKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgU1ZHIGVsZW1lbnQgd2l0aCB2aWV3Qm94IGZvciBiZXR0ZXIgc2NhbGluZ1xyXG4gICAgICAgICAgICBjb25zdCBzdmdFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJzdmdcIik7XHJcbiAgICAgICAgICAgIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKFwieG1sbnNcIiwgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKTtcclxuICAgICAgICAgICAgc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjE0NDBcIik7XHJcbiAgICAgICAgICAgIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiOTAwXCIpO1xyXG4gICAgICAgICAgICBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZShcInZpZXdCb3hcIiwgXCIwIDAgMTQ0MCA5MDBcIik7XHJcbiAgICAgICAgICAgIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKFwidmVyc2lvblwiLCBcIjEuMVwiKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBTVkcuanMgaW5zdGFuY2VcclxuICAgICAgICAgICAgY29uc3Qgc3ZnRG9jID0gU1ZHKHN2Z0VsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgLy8gRHJhdyBlYWNoIGJ1aWxkaW5nIHdpdGggYSB1bmlxdWUgSUQgYW5kIHN0eWxpbmdcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIFZhcnkgYnVpbGRpbmcgY29sb3JzIHNsaWdodGx5IGZvciB2aXN1YWwgaW50ZXJlc3RcclxuICAgICAgICAgICAgICAgIGNvbnN0IGh1ZSA9IDMwICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2F0dXJhdGlvbiA9IDEwICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGlnaHRuZXNzID0gODUgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxsQ29sb3IgPSBgaHNsKCR7aHVlfSwgJHtzYXR1cmF0aW9ufSUsICR7bGlnaHRuZXNzfSUpYDtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdQb2x5Z29uVG9TVkcoXHJcbiAgICAgICAgICAgICAgICAgICAgc3ZnRG9jLCBcclxuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaV0sIFxyXG4gICAgICAgICAgICAgICAgICAgIGBidWlsZGluZ18ke2l9YCwgXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbENvbG9yLCAgIC8vIEZpbGwgY29sb3IgKGJ1aWxkaW5nIGJlaWdlIHdpdGggc2xpZ2h0IHZhcmlhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAnI2NjY2NjYycsICAgLy8gU3Ryb2tlIGNvbG9yIChsaWdodCBncmF5KVxyXG4gICAgICAgICAgICAgICAgICAgIDAuNSAgICAgICAgICAvLyBTdHJva2Ugd2lkdGhcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBTVkcgdG8gc3RyaW5nXHJcbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZXIgPSBuZXcgWE1MU2VyaWFsaXplcigpO1xyXG4gICAgICAgICAgICBsZXQgc291cmNlID0gc2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyhzdmdFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBYTUwgZGVjbGFyYXRpb25cclxuICAgICAgICAgICAgc291cmNlID0gJzw/eG1sIHZlcnNpb249XCIxLjBcIiBzdGFuZGFsb25lPVwibm9cIj8+XFxyXFxuJyArIHNvdXJjZTtcclxuXHJcbiAgICAgICAgICAgIC8vIFdyaXRlIFNWRyBmaWxlXHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKG91dHB1dERpciwgYGJ1aWxkaW5ncy5zdmdgKTtcclxuICAgICAgICAgICAgZnMud3JpdGVGaWxlU3luYyhmaWxlUGF0aCwgc291cmNlKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFeHBvcnRlZCBidWlsZGluZ3Muc3ZnIHdpdGggJHtibG9ja3MubGVuZ3RofSBidWlsZGluZ3NgKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZXhwb3J0aW5nIGJ1aWxkaW5ncy5zdmc6YCwgZXJyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGEgcG9seWdvbiB0byBhbiBTVkcgZG9jdW1lbnQgd2l0aCBhIHVuaXF1ZSBJRCBhbmQgc3R5bGluZ1xyXG4gICAgICogQHBhcmFtIHN2Z0RvYyBUaGUgU1ZHIGRvY3VtZW50IHRvIGRyYXcgdG9cclxuICAgICAqIEBwYXJhbSBwb2x5Z29uIFRoZSBwb2x5Z29uIHRvIGRyYXdcclxuICAgICAqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIElEIGZvciB0aGUgcG9seWdvblxyXG4gICAgICogQHBhcmFtIGZpbGxDb2xvciBPcHRpb25hbCBmaWxsIGNvbG9yIChkZWZhdWx0OiBub25lKVxyXG4gICAgICogQHBhcmFtIHN0cm9rZUNvbG9yIE9wdGlvbmFsIHN0cm9rZSBjb2xvciAoZGVmYXVsdDogIzAwMClcclxuICAgICAqIEBwYXJhbSBzdHJva2VXaWR0aCBPcHRpb25hbCBzdHJva2Ugd2lkdGggKGRlZmF1bHQ6IDEpXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZHJhd1BvbHlnb25Ub1NWRyhcclxuICAgICAgICBzdmdEb2M6IGFueSwgXHJcbiAgICAgICAgcG9seWdvbjogVmVjdG9yW10sIFxyXG4gICAgICAgIGlkOiBzdHJpbmcsIFxyXG4gICAgICAgIGZpbGxDb2xvciA9ICdub25lJywgXHJcbiAgICAgICAgc3Ryb2tlQ29sb3IgPSAnIzAwMCcsIFxyXG4gICAgICAgIHN0cm9rZVdpZHRoID0gMVxyXG4gICAgKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHBvbHlnb24ubGVuZ3RoIDwgMikgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgcGF0aCBkYXRhIHdpdGggcHJvcGVyIGZvcm1hdHRpbmdcclxuICAgICAgICBsZXQgcGF0aERhdGEgPSBgTSAke3BvbHlnb25bMF0ueC50b0ZpeGVkKDIpfSAke3BvbHlnb25bMF0ueS50b0ZpeGVkKDIpfWA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwb2x5Z29uLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBhdGhEYXRhICs9IGAgTCAke3BvbHlnb25baV0ueC50b0ZpeGVkKDIpfSAke3BvbHlnb25baV0ueS50b0ZpeGVkKDIpfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhdGhEYXRhICs9IFwiIFpcIjsgLy8gQ2xvc2UgcGF0aFxyXG5cclxuICAgICAgICAvLyBBZGQgcGF0aCB0byBTVkcgd2l0aCB1bmlxdWUgSUQgYW5kIHN0eWxpbmdcclxuICAgICAgICBzdmdEb2MucGF0aChwYXRoRGF0YSlcclxuICAgICAgICAgICAgLmZpbGwoZmlsbENvbG9yKVxyXG4gICAgICAgICAgICAuc3Ryb2tlKHsgd2lkdGg6IHN0cm9rZVdpZHRoLCBjb2xvcjogc3Ryb2tlQ29sb3IgfSlcclxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgaWQpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkYXRhLXR5cGUnLCBpZC5zcGxpdCgnXycpWzBdKTsgLy8gQWRkIGRhdGEtdHlwZSBhdHRyaWJ1dGUgZm9yIGVhc2llciBzZWxlY3Rpb25cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmVjdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB4OiBudW1iZXIsIHB1YmxpYyB5OiBudW1iZXIpIHt9XHJcblxyXG4gICAgc3RhdGljIHplcm9WZWN0b3IoKTogVmVjdG9yIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigwLCAwKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZnJvbVNjYWxhcihzOiBudW1iZXIpOiBWZWN0b3Ige1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHMsIHMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogLXBpIHRvIHBpXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhbmdsZUJldHdlZW4odjE6IFZlY3RvciwgdjI6IFZlY3Rvcik6IG51bWJlciB7XHJcbiAgICAgICAgLy8gLTJwaSB0byAycGlcclxuICAgICAgICBsZXQgYW5nbGVCZXR3ZWVuID0gdjEuYW5nbGUoKSAtIHYyLmFuZ2xlKCk7XHJcbiAgICAgICAgaWYgKGFuZ2xlQmV0d2VlbiA+IE1hdGguUEkpIHtcclxuICAgICAgICAgICAgYW5nbGVCZXR3ZWVuIC09IDIgKiBNYXRoLlBJO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYW5nbGVCZXR3ZWVuIDw9IC1NYXRoLlBJKSB7XHJcbiAgICAgICAgICAgIGFuZ2xlQmV0d2VlbiArPSAyICogTWF0aC5QSTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFuZ2xlQmV0d2VlbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIHdoZXRoZXIgYSBwb2ludCBsaWVzIHRvIHRoZSBsZWZ0IG9mIGEgbGluZVxyXG4gICAgICogQHBhcmFtICB7VmVjdG9yfSBsaW5lUG9pbnQgICAgIFBvaW50IG9uIHRoZSBsaW5lXHJcbiAgICAgKiBAcGFyYW0gIHtWZWN0b3J9IGxpbmVEaXJlY3Rpb24gXHJcbiAgICAgKiBAcGFyYW0gIHtWZWN0b3J9IHBvaW50XHJcbiAgICAgKiBAcmV0dXJuIHtWZWN0b3J9ICAgICAgICAgICAgICAgdHJ1ZSBpZiBsZWZ0LCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzTGVmdChsaW5lUG9pbnQ6IFZlY3RvciwgbGluZURpcmVjdGlvbjogVmVjdG9yLCBwb2ludDogVmVjdG9yKTogYm9vbGVhbiB7XHJcbiAgICAgICAgY29uc3QgcGVycGVuZGljdWxhclZlY3RvciA9IG5ldyBWZWN0b3IobGluZURpcmVjdGlvbi55LCAtbGluZURpcmVjdGlvbi54KTtcclxuICAgICAgICByZXR1cm4gcG9pbnQuY2xvbmUoKS5zdWIobGluZVBvaW50KS5kb3QocGVycGVuZGljdWxhclZlY3RvcikgPCAwO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZCh2OiBWZWN0b3IpOiBWZWN0b3Ige1xyXG4gICAgICAgIHRoaXMueCArPSB2Lng7XHJcbiAgICAgICAgdGhpcy55ICs9IHYueTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuZ2xlIGluIHJhZGlhbnMgdG8gcG9zaXRpdmUgeC1heGlzIGJldHdlZW4gLXBpIGFuZCBwaVxyXG4gICAgICovXHJcbiAgICBhbmdsZSgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMueSwgdGhpcy54KTtcclxuICAgIH1cclxuXHJcbiAgICBjbG9uZSgpOiBWZWN0b3Ige1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCwgdGhpcy55KTtcclxuICAgIH1cclxuXHJcbiAgICBjb3B5KHY6IFZlY3Rvcik6IFZlY3RvciB7XHJcbiAgICAgICAgdGhpcy54ID0gdi54O1xyXG4gICAgICAgIHRoaXMueSA9IHYueTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBjcm9zcyh2OiBWZWN0b3IpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnggKiB2LnkgLSB0aGlzLnkgKiB2Lng7XHJcbiAgICB9XHJcblxyXG4gICAgZGlzdGFuY2VUbyh2OiBWZWN0b3IpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVRvU3F1YXJlZCh2KSk7XHJcbiAgICB9XHJcblxyXG4gICAgZGlzdGFuY2VUb1NxdWFyZWQgKHY6IFZlY3Rvcik6IG51bWJlciB7XHJcbiAgICAgICAgY29uc3QgZHggPSB0aGlzLnggLSB2LnhcclxuICAgICAgICBjb25zdCBkeSA9IHRoaXMueSAtIHYueTtcclxuICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcbiAgICB9XHJcblxyXG4gICAgZGl2aWRlKHY6IFZlY3Rvcik6IFZlY3RvciB7XHJcbiAgICAgICAgaWYgKHYueCA9PT0gMCB8fCB2LnkgPT09IDApIHtcclxuICAgICAgICAgICAgbG9nLndhcm4oXCJEaXZpc2lvbiBieSB6ZXJvXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMueCAvPSB2Lng7XHJcbiAgICAgICAgdGhpcy55IC89IHYueTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBkaXZpZGVTY2FsYXIoczogbnVtYmVyKTogVmVjdG9yIHtcclxuICAgICAgICBpZiAocyA9PT0gMCkge1xyXG4gICAgICAgICAgICBsb2cud2FybihcIkRpdmlzaW9uIGJ5IHplcm9cIik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcigxIC8gcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZG90KHY6IFZlY3Rvcik6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueTtcclxuICAgIH1cclxuXHJcbiAgICBlcXVhbHModjogVmVjdG9yKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuICgodi54ID09PSB0aGlzLngpICYmICh2LnkgPT09IHRoaXMueSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGxlbmd0aCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5sZW5ndGhTcSgpKTtcclxuICAgIH1cclxuXHJcbiAgICBsZW5ndGhTcSgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnk7XHJcbiAgICB9XHJcblxyXG4gICAgbXVsdGlwbHkodjogVmVjdG9yKTogVmVjdG9yIHtcclxuICAgICAgICB0aGlzLnggKj0gdi54O1xyXG4gICAgICAgIHRoaXMueSAqPSB2Lnk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgbXVsdGlwbHlTY2FsYXIoczogbnVtYmVyKTogVmVjdG9yIHtcclxuICAgICAgICB0aGlzLnggKj0gcztcclxuICAgICAgICB0aGlzLnkgKj0gcztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBuZWdhdGUoKTogVmVjdG9yIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcigtMSk7XHJcbiAgICB9XHJcblxyXG4gICAgbm9ybWFsaXplKCk6IFZlY3RvciB7XHJcbiAgICAgICAgY29uc3QgbCA9IHRoaXMubGVuZ3RoKCk7XHJcbiAgICAgICAgaWYgKGwgPT09IDApIHtcclxuICAgICAgICAgICAgbG9nLndhcm4oXCJaZXJvIFZlY3RvclwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiB0aGlzLmRpdmlkZVNjYWxhcih0aGlzLmxlbmd0aCgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFuZ2xlIGluIHJhZGlhbnNcclxuICAgICAqL1xyXG4gICAgcm90YXRlQXJvdW5kKGNlbnRlcjogVmVjdG9yLCBhbmdsZTogbnVtYmVyKTogVmVjdG9yIHtcclxuICAgICAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZSlcclxuICAgICAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHggPSB0aGlzLnggLSBjZW50ZXIueDtcclxuICAgICAgICBjb25zdCB5ID0gdGhpcy55IC0gY2VudGVyLnk7XHJcblxyXG4gICAgICAgIHRoaXMueCA9IHggKiBjb3MgLSB5ICogc2luICsgY2VudGVyLng7XHJcbiAgICAgICAgdGhpcy55ID0geCAqIHNpbiArIHkgKiBjb3MgKyBjZW50ZXIueTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBzZXQodjogVmVjdG9yKTogVmVjdG9yIHtcclxuICAgICAgICB0aGlzLnggPSB2Lng7XHJcbiAgICAgICAgdGhpcy55ID0gdi55O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFgoeDogbnVtYmVyKTogVmVjdG9yIHtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFkoeTogbnVtYmVyKTogVmVjdG9yIHtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHNldExlbmd0aCAobGVuZ3RoOiBudW1iZXIpOiBWZWN0b3Ige1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKGxlbmd0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3ViKHY6IFZlY3Rvcik6IFZlY3RvciB7XHJcbiAgICAgICAgdGhpcy54IC09IHYueDtcclxuICAgICAgICB0aGlzLnkgLT0gdi55O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBUZW5zb3IgZnJvbSAnLi90ZW5zb3InO1xyXG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XHJcblxyXG5leHBvcnQgY29uc3QgZW51bSBGSUVMRF9UWVBFIHtcclxuICAgIFJhZGlhbCxcclxuICAgIEdyaWQsXHJcbn07XHJcblxyXG4vKipcclxuICogR3JpZCBvciBSYWRpYWwgZmllbGQgdG8gYmUgY29tYmluZWQgd2l0aCBvdGhlcnMgdG8gY3JlYXRlIHRoZSB0ZW5zb3IgZmllbGRcclxuICovXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNpc0ZpZWxkIHtcclxuICAgIGFic3RyYWN0IHJlYWRvbmx5IEZPTERFUl9OQU1FOiBzdHJpbmc7XHJcbiAgICBhYnN0cmFjdCByZWFkb25seSBGSUVMRF9UWVBFOiBudW1iZXI7XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGZvbGRlck5hbWVJbmRleDogbnVtYmVyID0gMDtcclxuICAgIHByb3RlY3RlZCBwYXJlbnRGb2xkZXI6IGRhdC5HVUk7XHJcbiAgICBwcm90ZWN0ZWQgZm9sZGVyOiBkYXQuR1VJO1xyXG4gICAgcHJvdGVjdGVkIF9jZW50cmU6IFZlY3RvcjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihjZW50cmU6IFZlY3RvciwgcHJvdGVjdGVkIF9zaXplOiBudW1iZXIsIHByb3RlY3RlZCBfZGVjYXk6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMuX2NlbnRyZSA9IGNlbnRyZS5jbG9uZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBjZW50cmUoY2VudHJlOiBWZWN0b3IpIHtcclxuICAgICAgICB0aGlzLl9jZW50cmUuY29weShjZW50cmUpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBjZW50cmUoKTogVmVjdG9yIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2VudHJlLmNsb25lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IGRlY2F5KGRlY2F5OiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLl9kZWNheSA9IGRlY2F5O1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBzaXplKHNpemU6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMuX3NpemUgPSBzaXplO1xyXG4gICAgfVxyXG5cclxuICAgIGRyYWdTdGFydExpc3RlbmVyKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuc2V0Rm9sZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZHJhZ01vdmVMaXN0ZW5lcihkZWx0YTogVmVjdG9yKTogdm9pZCB7XHJcbiAgICAgICAgLy8gRGVsdGEgYXNzdW1lZCB0byBiZSBpbiB3b3JsZCBzcGFjZSAob25seSByZWxldmFudCB3aGVuIHpvb21lZClcclxuICAgICAgICB0aGlzLl9jZW50cmUuYWRkKGRlbHRhKTtcclxuICAgIH1cclxuXHJcbiAgICBhYnN0cmFjdCBnZXRUZW5zb3IocG9pbnQ6IFZlY3Rvcik6IFRlbnNvcjtcclxuXHJcbiAgICBnZXRXZWlnaHRlZFRlbnNvcihwb2ludDogVmVjdG9yLCBzbW9vdGg6IGJvb2xlYW4pOiBUZW5zb3Ige1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFRlbnNvcihwb2ludCkuc2NhbGUodGhpcy5nZXRUZW5zb3JXZWlnaHQocG9pbnQsIHNtb290aCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldEZvbGRlcigpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5wYXJlbnRGb2xkZXIuX19mb2xkZXJzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZm9sZGVyTmFtZSBpbiB0aGlzLnBhcmVudEZvbGRlci5fX2ZvbGRlcnMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Rm9sZGVyLl9fZm9sZGVyc1tmb2xkZXJOYW1lXS5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZm9sZGVyLm9wZW4oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlRm9sZGVyRnJvbVBhcmVudCgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5wYXJlbnRGb2xkZXIuX19mb2xkZXJzICYmIE9iamVjdC52YWx1ZXModGhpcy5wYXJlbnRGb2xkZXIuX19mb2xkZXJzKS5pbmRleE9mKHRoaXMuZm9sZGVyKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50Rm9sZGVyLnJlbW92ZUZvbGRlcih0aGlzLmZvbGRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZvbGRlciBhbmQgYWRkcyBpdCB0byB0aGUgR1VJIHRvIGNvbnRyb2wgcGFyYW1zXHJcbiAgICAgKi9cclxuICAgIHNldEd1aShwYXJlbnQ6IGRhdC5HVUksIGZvbGRlcjogZGF0LkdVSSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucGFyZW50Rm9sZGVyID0gcGFyZW50O1xyXG4gICAgICAgIHRoaXMuZm9sZGVyID0gZm9sZGVyO1xyXG4gICAgICAgIGZvbGRlci5hZGQodGhpcy5fY2VudHJlLCAneCcpO1xyXG4gICAgICAgIGZvbGRlci5hZGQodGhpcy5fY2VudHJlLCAneScpO1xyXG4gICAgICAgIGZvbGRlci5hZGQodGhpcywgJ19zaXplJyk7XHJcbiAgICAgICAgZm9sZGVyLmFkZCh0aGlzLCAnX2RlY2F5JywgLTUwLCA1MCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcnBvbGF0ZXMgYmV0d2VlbiAoMCBhbmQgMSleZGVjYXlcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGdldFRlbnNvcldlaWdodChwb2ludDogVmVjdG9yLCBzbW9vdGg6IGJvb2xlYW4pOiBudW1iZXIge1xyXG4gICAgICAgIGNvbnN0IG5vcm1EaXN0YW5jZVRvQ2VudHJlID0gcG9pbnQuY2xvbmUoKS5zdWIodGhpcy5fY2VudHJlKS5sZW5ndGgoKSAvIHRoaXMuX3NpemU7XHJcbiAgICAgICAgaWYgKHNtb290aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9ybURpc3RhbmNlVG9DZW50cmUgKiogLXRoaXMuX2RlY2F5O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTdG9wICgqKiAwKSB0dXJuaW5nIHdlaWdodCBpbnRvIDEsIGZpbGxpbmcgc2NyZWVuIGV2ZW4gd2hlbiBvdXRzaWRlICdzaXplJ1xyXG4gICAgICAgIGlmICh0aGlzLl9kZWNheSA9PT0gMCAmJiBub3JtRGlzdGFuY2VUb0NlbnRyZSA+PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgKDEgLSBub3JtRGlzdGFuY2VUb0NlbnRyZSkpICoqIHRoaXMuX2RlY2F5O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgR3JpZCBleHRlbmRzIEJhc2lzRmllbGQge1xyXG4gICAgcmVhZG9ubHkgRk9MREVSX05BTUUgPSBgR3JpZCAke0dyaWQuZm9sZGVyTmFtZUluZGV4Kyt9YDtcclxuICAgIHJlYWRvbmx5IEZJRUxEX1RZUEUgPSBGSUVMRF9UWVBFLkdyaWQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IoY2VudHJlOiBWZWN0b3IsIHNpemU6IG51bWJlciwgZGVjYXk6IG51bWJlciwgcHJpdmF0ZSBfdGhldGE6IG51bWJlcikge1xyXG4gICAgICAgIHN1cGVyKGNlbnRyZSwgc2l6ZSwgZGVjYXkpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCB0aGV0YSh0aGV0YTogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5fdGhldGEgPSB0aGV0YTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRHdWkocGFyZW50OiBkYXQuR1VJLCBmb2xkZXI6IGRhdC5HVUkpOiB2b2lkIHtcclxuICAgICAgICBzdXBlci5zZXRHdWkocGFyZW50LCBmb2xkZXIpO1xyXG5cclxuICAgICAgICAvLyBHVUkgaW4gZGVncmVlcywgY29udmVydCB0byByYWRzXHJcbiAgICAgICAgY29uc3QgdGhldGFQcm9wID0ge3RoZXRhOiB0aGlzLl90aGV0YSAqIDE4MCAvIE1hdGguUEl9O1xyXG4gICAgICAgIGNvbnN0IHRoZXRhQ29udHJvbGxlciA9IGZvbGRlci5hZGQodGhldGFQcm9wLCAndGhldGEnLCAtOTAsIDkwKTtcclxuICAgICAgICB0aGV0YUNvbnRyb2xsZXIub25DaGFuZ2UodGhldGEgPT4gdGhpcy5fdGhldGEgPSB0aGV0YSAqIChNYXRoLlBJIC8gMTgwKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0VGVuc29yKHBvaW50OiBWZWN0b3IpOiBUZW5zb3Ige1xyXG4gICAgICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKDIgKiB0aGlzLl90aGV0YSk7XHJcbiAgICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4oMiAqIHRoaXMuX3RoZXRhKTtcclxuICAgICAgICByZXR1cm4gbmV3IFRlbnNvcigxLCBbY29zLCBzaW5dKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFJhZGlhbCBleHRlbmRzIEJhc2lzRmllbGQge1xyXG4gICAgcmVhZG9ubHkgRk9MREVSX05BTUUgPSBgUmFkaWFsICR7UmFkaWFsLmZvbGRlck5hbWVJbmRleCsrfWA7XHJcbiAgICByZWFkb25seSBGSUVMRF9UWVBFID0gRklFTERfVFlQRS5SYWRpYWw7XHJcblxyXG4gICAgY29uc3RydWN0b3IoY2VudHJlOiBWZWN0b3IsIHNpemU6IG51bWJlciwgZGVjYXk6IG51bWJlcikge1xyXG4gICAgICAgIHN1cGVyKGNlbnRyZSwgc2l6ZSwgZGVjYXkpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFRlbnNvcihwb2ludDogVmVjdG9yKTogVGVuc29yIHtcclxuICAgICAgICBjb25zdCB0ID0gcG9pbnQuY2xvbmUoKS5zdWIodGhpcy5fY2VudHJlKTtcclxuICAgICAgICBjb25zdCB0MSA9IHQueSoqMiAtIHQueCoqMjtcclxuICAgICAgICBjb25zdCB0MiA9IC0yICogdC54ICogdC55O1xyXG4gICAgICAgIHJldHVybiBuZXcgVGVuc29yKDEsIFt0MSwgdDJdKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xyXG5pbXBvcnQgKiBhcyBpc2VjdCBmcm9tICdpc2VjdCc7XHJcbmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzLXF1YWR0cmVlJztcclxuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xyXG5cclxuZGVjbGFyZSBtb2R1bGUgJ2lzZWN0JyB7XHJcbiAgICBleHBvcnQgZnVuY3Rpb24gYnVzaChsaW5lczogU2VnbWVudFtdKTogRGV0ZWN0SW50ZXJzZWN0aW9ucztcclxufVxyXG5cclxuaW50ZXJmYWNlIERldGVjdEludGVyc2VjdGlvbnMge1xyXG4gICAgcnVuOiAoKSA9PiBJbnRlcnNlY3Rpb25bXTtcclxufVxyXG5cclxuaW50ZXJmYWNlIFNlZ21lbnQge1xyXG4gICAgZnJvbTogVmVjdG9yO1xyXG4gICAgdG86IFZlY3RvcjtcclxufVxyXG5cclxuaW50ZXJmYWNlIEludGVyc2VjdGlvbiB7XHJcbiAgICBwb2ludDogVmVjdG9yO1xyXG4gICAgc2VnbWVudHM6IFNlZ21lbnRbXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE5vZGUgbG9jYXRlZCBhbG9uZyBhbnkgaW50ZXJzZWN0aW9uIG9yIHBvaW50IGFsb25nIHRoZSBzaW1wbGlmaWVkIHJvYWQgcG9seWxpbmVzIFxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE5vZGUge1xyXG4gICAgcHVibGljIHNlZ21lbnRzID0gbmV3IFNldDxTZWdtZW50PigpO1xyXG4gICAgcHVibGljIGFkajogTm9kZVtdO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB2YWx1ZTogVmVjdG9yLCBwdWJsaWMgbmVpZ2hib3JzPW5ldyBTZXQ8Tm9kZT4oKSkge31cclxuXHJcbiAgICBhZGRTZWdtZW50KHNlZ21lbnQ6IFNlZ21lbnQpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnNlZ21lbnRzLmFkZChzZWdtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBhZGROZWlnaGJvcihub2RlOiBOb2RlKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKG5vZGUgIT09IHRoaXMpIHtcclxuICAgICAgICAgICAgdGhpcy5uZWlnaGJvcnMuYWRkKG5vZGUpO1xyXG4gICAgICAgICAgICBub2RlLm5laWdoYm9ycy5hZGQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmFwaCB7XHJcbiAgICBwdWJsaWMgbm9kZXM6IE5vZGVbXTtcclxuICAgIHB1YmxpYyBpbnRlcnNlY3Rpb25zOiBWZWN0b3JbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIGdyYXBoIGZyb20gYSBzZXQgb2Ygc3RyZWFtbGluZXNcclxuICAgICAqIEZpbmRzIGFsbCBpbnRlcnNlY3Rpb25zLCBhbmQgY3JlYXRlcyBhIGxpc3Qgb2YgTm9kZXNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Ioc3RyZWFtbGluZXM6IFZlY3RvcltdW10sIGRzdGVwOiBudW1iZXIsIGRlbGV0ZURhbmdsaW5nPWZhbHNlKSB7XHJcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9ucyA9IGlzZWN0LmJ1c2godGhpcy5zdHJlYW1saW5lc1RvU2VnbWVudChzdHJlYW1saW5lcykpLnJ1bigpO1xyXG4gICAgICAgIGNvbnN0IHF1YWR0cmVlID0gKGQzLnF1YWR0cmVlKCkgYXMgZDMuUXVhZHRyZWU8Tm9kZT4pLngobiA9PiBuLnZhbHVlLngpLnkobiA9PiBuLnZhbHVlLnkpO1xyXG4gICAgICAgIGNvbnN0IG5vZGVBZGRSYWRpdXMgPSAwLjAwMTtcclxuXHJcbiAgICAgICAgLy8gQWRkIGFsbCBzZWdtZW50IHN0YXJ0IGFuZCBlbmRwb2ludHNcclxuICAgICAgICBmb3IgKGNvbnN0IHN0cmVhbWxpbmUgb2Ygc3RyZWFtbGluZXMpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJlYW1saW5lLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gbmV3IE5vZGUoc3RyZWFtbGluZVtpXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmFkZFNlZ21lbnQodGhpcy52ZWN0b3JzVG9TZWdtZW50KHN0cmVhbWxpbmVbaSAtIDFdLCBzdHJlYW1saW5lW2ldKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPCBzdHJlYW1saW5lLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmFkZFNlZ21lbnQodGhpcy52ZWN0b3JzVG9TZWdtZW50KHN0cmVhbWxpbmVbaV0sIHN0cmVhbWxpbmVbaSArIDFdKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5mdXp6eUFkZFRvUXVhZHRyZWUocXVhZHRyZWUsIG5vZGUsIG5vZGVBZGRSYWRpdXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBZGQgYWxsIGludGVyc2VjdGlvbnNcclxuICAgICAgICBmb3IgKGNvbnN0IGludGVyc2VjdGlvbiBvZiBpbnRlcnNlY3Rpb25zKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgTm9kZShuZXcgVmVjdG9yKGludGVyc2VjdGlvbi5wb2ludC54LCBpbnRlcnNlY3Rpb24ucG9pbnQueSkpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHMgb2YgaW50ZXJzZWN0aW9uLnNlZ21lbnRzKSBub2RlLmFkZFNlZ21lbnQocyk7XHJcbiAgICAgICAgICAgIHRoaXMuZnV6enlBZGRUb1F1YWR0cmVlKHF1YWR0cmVlLCBub2RlLCBub2RlQWRkUmFkaXVzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZvciBlYWNoIHNpbXBsaWZpZWQgc3RyZWFtbGluZSwgYnVpbGQgbGlzdCBvZiBub2RlcyBpbiBvcmRlciBhbG9uZyBzdHJlYW1saW5lXHJcbiAgICAgICAgZm9yIChjb25zdCBzdHJlYW1saW5lIG9mIHN0cmVhbWxpbmVzKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyZWFtbGluZS5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVzQWxvbmdTZWdtZW50ID1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldE5vZGVzQWxvbmdTZWdtZW50KHRoaXMudmVjdG9yc1RvU2VnbWVudChzdHJlYW1saW5lW2ldLCBzdHJlYW1saW5lW2kgKyAxXSksIHF1YWR0cmVlLCBub2RlQWRkUmFkaXVzLCBkc3RlcCk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmIChub2Rlc0Fsb25nU2VnbWVudC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2Rlc0Fsb25nU2VnbWVudC5sZW5ndGggLSAxOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNBbG9uZ1NlZ21lbnRbal0uYWRkTmVpZ2hib3Iobm9kZXNBbG9uZ1NlZ21lbnRbaisxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2cuZXJyb3IoXCJFcnJvciBHcmFwaC5qczogc2VnbWVudCB3aXRoIGxlc3MgdGhhbiAyIG5vZGVzXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBcclxuICAgICAgICBmb3IgKGNvbnN0IG4gb2YgcXVhZHRyZWUuZGF0YSgpKSB7XHJcbiAgICAgICAgICAgIGlmIChkZWxldGVEYW5nbGluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVEYW5nbGluZ05vZGVzKG4sIHF1YWR0cmVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbi5hZGogPSBBcnJheS5mcm9tKG4ubmVpZ2hib3JzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubm9kZXMgPSBxdWFkdHJlZS5kYXRhKCk7XHJcbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25zID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIGludGVyc2VjdGlvbnMpIHRoaXMuaW50ZXJzZWN0aW9ucy5wdXNoKG5ldyBWZWN0b3IoaS5wb2ludC54LCBpLnBvaW50LnkpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBkYW5nbGluZyBlZGdlcyBmcm9tIGdyYXBoIHRvIGZhY2lsaXRhdGUgcG9seWdvbiBmaW5kaW5nXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZGVsZXRlRGFuZ2xpbmdOb2RlcyhuOiBOb2RlLCBxdWFkdHJlZTogZDMuUXVhZHRyZWU8Tm9kZT4pIHtcclxuICAgICAgICBpZiAobi5uZWlnaGJvcnMuc2l6ZSA9PT0gMSkge1xyXG4gICAgICAgICAgICBxdWFkdHJlZS5yZW1vdmUobik7XHJcbiAgICAgICAgICAgIGZvciAobGV0IG5laWdoYm9yIG9mIG4ubmVpZ2hib3JzKSB7XHJcbiAgICAgICAgICAgICAgICBuZWlnaGJvci5uZWlnaGJvcnMuZGVsZXRlKG4pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVEYW5nbGluZ05vZGVzKG5laWdoYm9yLCBxdWFkdHJlZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhIHNlZ21lbnQsIHN0ZXAgYWxvbmcgc2VnbWVudCBhbmQgZmluZCBhbGwgbm9kZXMgYWxvbmcgaXRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZXROb2Rlc0Fsb25nU2VnbWVudChzZWdtZW50OiBTZWdtZW50LCBxdWFkdHJlZTogZDMuUXVhZHRyZWU8Tm9kZT4sIHJhZGl1czogbnVtYmVyLCBzdGVwOiBudW1iZXIpOiBOb2RlW10ge1xyXG4gICAgICAgIC8vIFdhbGsgZHN0ZXAgYWxvbmcgZWFjaCBzdHJlYW1saW5lLCBhZGRpbmcgbm9kZXMgd2l0aGluIGRzdGVwLzJcclxuICAgICAgICAvLyBhbmQgY29ubmVjdGVkIHRvIHRoaXMgc3RyZWFtbGluZSAoZnV6enkgLSBub2RlQWRkUmFkaXVzKSB0byBsaXN0LCByZW1vdmluZyBmcm9tXHJcbiAgICAgICAgLy8gcXVhZHRyZWUgYW5kIGFkZGluZyB0aGVtIGFsbCBiYWNrIGF0IHRoZSBlbmRcclxuXHJcbiAgICAgICAgY29uc3QgZm91bmROb2RlcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IG5vZGVzQWxvbmdTZWdtZW50OiBOb2RlW10gPSBbXTtcclxuXHJcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgVmVjdG9yKHNlZ21lbnQuZnJvbS54LCBzZWdtZW50LmZyb20ueSk7XHJcbiAgICAgICAgY29uc3QgZW5kID0gbmV3IFZlY3RvcihzZWdtZW50LnRvLngsIHNlZ21lbnQudG8ueSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgZGlmZmVyZW5jZVZlY3RvciA9IGVuZC5jbG9uZSgpLnN1YihzdGFydCk7XHJcbiAgICAgICAgc3RlcCA9IE1hdGgubWluKHN0ZXAsIGRpZmZlcmVuY2VWZWN0b3IubGVuZ3RoKCkgLyAyKTsgIC8vIE1pbiBvZiAyIHN0ZXAgYWxvbmcgdmVjdG9yXHJcbiAgICAgICAgY29uc3Qgc3RlcHMgPSBNYXRoLmNlaWwoZGlmZmVyZW5jZVZlY3Rvci5sZW5ndGgoKSAvIHN0ZXApO1xyXG4gICAgICAgIGNvbnN0IGRpZmZlcmVuY2VWZWN0b3JMZW5ndGggPSBkaWZmZXJlbmNlVmVjdG9yLmxlbmd0aCgpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBzdGVwczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50UG9pbnQgPSBzdGFydC5jbG9uZSgpLmFkZChkaWZmZXJlbmNlVmVjdG9yLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoaSAvIHN0ZXBzKSk7XHJcblxyXG4gICAgICAgICAgICAvLyBPcmRlciBub2Rlcywgbm90IGJ5ICdjbG9zZW5lc3MnLCBidXQgYnkgZG90IHByb2R1Y3RcclxuICAgICAgICAgICAgbGV0IG5vZGVzVG9BZGQgPSBbXTtcclxuICAgICAgICAgICAgbGV0IGNsb3Nlc3ROb2RlID0gcXVhZHRyZWUuZmluZChjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnksIHJhZGl1cyArIHN0ZXAvMik7XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAoY2xvc2VzdE5vZGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcXVhZHRyZWUucmVtb3ZlKGNsb3Nlc3ROb2RlKTtcclxuICAgICAgICAgICAgICAgIGZvdW5kTm9kZXMucHVzaChjbG9zZXN0Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGxldCBub2RlT25TZWdtZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzIG9mIGNsb3Nlc3ROb2RlLnNlZ21lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZnV6enlTZWdtZW50c0VxdWFsKHMsIHNlZ21lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVPblNlZ21lbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVPblNlZ21lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2Rlc1RvQWRkLnB1c2goY2xvc2VzdE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNsb3Nlc3ROb2RlID0gcXVhZHRyZWUuZmluZChjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnksIHJhZGl1cyArIHN0ZXAvMik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG5vZGVzVG9BZGQuc29ydCgoZmlyc3Q6IE5vZGUsIHNlY29uZDogTm9kZSkgPT5cclxuICAgICAgICAgICAgICAgIHRoaXMuZG90UHJvZHVjdFRvU2VnbWVudChmaXJzdCwgc3RhcnQsIGRpZmZlcmVuY2VWZWN0b3IpIC0gdGhpcy5kb3RQcm9kdWN0VG9TZWdtZW50KHNlY29uZCwgc3RhcnQsIGRpZmZlcmVuY2VWZWN0b3IpKTtcclxuICAgICAgICAgICAgbm9kZXNBbG9uZ1NlZ21lbnQucHVzaCguLi5ub2Rlc1RvQWRkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHF1YWR0cmVlLmFkZEFsbChmb3VuZE5vZGVzKTtcclxuICAgICAgICByZXR1cm4gbm9kZXNBbG9uZ1NlZ21lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBmdXp6eVNlZ21lbnRzRXF1YWwoczE6IFNlZ21lbnQsIHMyOiBTZWdtZW50LCB0b2xlcmFuY2U9MC4wMDAxKTogYm9vbGVhbiB7XHJcbiAgICAgICAgLy8gRnJvbVxyXG4gICAgICAgIGlmIChzMS5mcm9tLnggLSBzMi5mcm9tLnggPiB0b2xlcmFuY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHMxLmZyb20ueSAtIHMyLmZyb20ueSA+IHRvbGVyYW5jZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUb1xyXG5cclxuICAgICAgICBpZiAoczEudG8ueCAtIHMyLnRvLnggPiB0b2xlcmFuY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHMxLnRvLnkgLSBzMi50by55ID4gdG9sZXJhbmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZG90UHJvZHVjdFRvU2VnbWVudChub2RlOiBOb2RlLCBzdGFydDogVmVjdG9yLCBkaWZmZXJlbmNlVmVjdG9yOiBWZWN0b3IpOiBudW1iZXIge1xyXG4gICAgICAgIGNvbnN0IGRvdFZlY3RvciA9IG5vZGUudmFsdWUuY2xvbmUoKS5zdWIoc3RhcnQpO1xyXG4gICAgICAgIHJldHVybiBkaWZmZXJlbmNlVmVjdG9yLmRvdChkb3RWZWN0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZnV6enlBZGRUb1F1YWR0cmVlKHF1YWR0cmVlOiBkMy5RdWFkdHJlZTxOb2RlPiwgbm9kZTogTm9kZSwgcmFkaXVzOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICAvLyBPbmx5IGFkZCBpZiB0aGVyZSBpc24ndCBhIG5vZGUgd2l0aGluIHJhZGl1c1xyXG4gICAgICAgIC8vIFJlbWVtYmVyIHRvIGNoZWNrIGZvciBkb3VibGUgcmFkaXVzIHdoZW4gcXVlcnlpbmcgdHJlZSwgb3IgcG9pbnQgbWlnaHQgYmUgbWlzc2VkXHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdOb2RlID0gcXVhZHRyZWUuZmluZChub2RlLnZhbHVlLngsIG5vZGUudmFsdWUueSwgcmFkaXVzKTtcclxuICAgICAgICBpZiAoZXhpc3RpbmdOb2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcXVhZHRyZWUuYWRkKG5vZGUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmVpZ2hib3Igb2Ygbm9kZS5uZWlnaGJvcnMpIGV4aXN0aW5nTm9kZS5hZGROZWlnaGJvcihuZWlnaGJvcik7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBub2RlLnNlZ21lbnRzKSBleGlzdGluZ05vZGUuYWRkU2VnbWVudChzZWdtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdHJlYW1saW5lc1RvU2VnbWVudChzdHJlYW1saW5lczogVmVjdG9yW11bXSk6IFNlZ21lbnRbXSB7XHJcbiAgICAgICAgY29uc3Qgb3V0OiBTZWdtZW50W10gPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHMgb2Ygc3RyZWFtbGluZXMpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgb3V0LnB1c2godGhpcy52ZWN0b3JzVG9TZWdtZW50KHNbaV0sIHNbaSArIDFdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB2ZWN0b3JzVG9TZWdtZW50KHYxOiBWZWN0b3IsIHYyOiBWZWN0b3IpOiBTZWdtZW50IHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmcm9tOiB2MSxcclxuICAgICAgICAgICAgdG86ICAgdjJcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XHJcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcclxuXHJcbi8qKlxyXG4gKiBDYXJ0ZXNpYW4gZ3JpZCBhY2NlbGVyYXRlZCBkYXRhIHN0cnVjdHVyZVxyXG4gKiBHcmlkIG9mIGNlbGxzLCBlYWNoIGNvbnRhaW5pbmcgYSBsaXN0IG9mIHZlY3RvcnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyaWRTdG9yYWdlIHtcclxuXHJcbiAgICBwcml2YXRlIGdyaWREaW1lbnNpb25zOiBWZWN0b3I7XHJcbiAgICBwcml2YXRlIGdyaWQ6IFZlY3RvcltdW11bXTtcclxuICAgIHByaXZhdGUgZHNlcFNxOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB3b3JsZERpbWVuc2lvbnMgYXNzdW1lcyBvcmlnaW4gb2YgMCwwXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHNlcCBTZXBhcmF0aW9uIGRpc3RhbmNlIGJldHdlZW4gc2FtcGxlc1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvciAocHJpdmF0ZSB3b3JsZERpbWVuc2lvbnM6IFZlY3RvciwgcHJpdmF0ZSBvcmlnaW46IFZlY3RvciwgcHJpdmF0ZSBkc2VwOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLmRzZXBTcSA9IHRoaXMuZHNlcCAqIHRoaXMuZHNlcDtcclxuICAgICAgICB0aGlzLmdyaWREaW1lbnNpb25zID0gd29ybGREaW1lbnNpb25zLmNsb25lKCkuZGl2aWRlU2NhbGFyKHRoaXMuZHNlcCk7XHJcbiAgICAgICAgdGhpcy5ncmlkID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLmdyaWREaW1lbnNpb25zLng7IHgrKykge1xyXG4gICAgICAgICAgICB0aGlzLmdyaWQucHVzaChbXSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5ncmlkRGltZW5zaW9ucy55OyB5KyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZFt4XS5wdXNoKFtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhbGwgc2FtcGxlcyBmcm9tIGFub3RoZXIgZ3JpZCB0byB0aGlzIG9uZVxyXG4gICAgICovXHJcbiAgICBhZGRBbGwoZ3JpZFN0b3JhZ2U6IEdyaWRTdG9yYWdlKTogdm9pZCB7XHJcbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgZ3JpZFN0b3JhZ2UuZ3JpZCkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2Ygcm93KSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNhbXBsZSBvZiBjZWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRTYW1wbGUoc2FtcGxlKTsgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFkZFBvbHlsaW5lKGxpbmU6IFZlY3RvcltdKTogdm9pZCB7XHJcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIGxpbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRTYW1wbGUodilcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEb2VzIG5vdCBlbmZvcmNlIHNlcGFyYXRpb25cclxuICAgICAqIERvZXMgbm90IGNsb25lXHJcbiAgICAgKi9cclxuICAgIGFkZFNhbXBsZSh2OiBWZWN0b3IsIGNvb3Jkcz86IFZlY3Rvcik6IHZvaWQge1xyXG4gICAgICAgIGlmICghY29vcmRzKSB7XHJcbiAgICAgICAgICAgIGNvb3JkcyA9IHRoaXMuZ2V0U2FtcGxlQ29vcmRzKHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdyaWRbY29vcmRzLnhdW2Nvb3Jkcy55XS5wdXNoKHYpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgd2hldGhlciB2IGlzIGF0IGxlYXN0IGQgYXdheSBmcm9tIHNhbXBsZXNcclxuICAgICAqIFBlcmZvcm1hbmNlIHZlcnkgaW1wb3J0YW50IC0gdGhpcyBpcyBjYWxsZWQgYXQgZXZlcnkgaW50ZWdyYXRpb24gc3RlcFxyXG4gICAgICogQHBhcmFtIGRTcT10aGlzLmRzZXBTcSBzcXVhcmVkIHRlc3QgZGlzdGFuY2VcclxuICAgICAqIENvdWxkIGJlIGR0ZXN0IGlmIHdlIGFyZSBpbnRlZ3JhdGluZyBhIHN0cmVhbWxpbmVcclxuICAgICAqL1xyXG4gICAgaXNWYWxpZFNhbXBsZSh2OiBWZWN0b3IsIGRTcT10aGlzLmRzZXBTcSk6IGJvb2xlYW4ge1xyXG4gICAgICAgIC8vIENvZGUgZHVwbGljYXRpb24gd2l0aCB0aGlzLmdldE5lYXJieVBvaW50cyBidXQgbXVjaCBzbG93ZXIgd2hlbiBjYWxsaW5nXHJcbiAgICAgICAgLy8gdGhpcy5nZXROZWFyYnlQb2ludHMgZHVlIHRvIGFycmF5IGNyZWF0aW9uIGluIHRoYXQgbWV0aG9kXHJcblxyXG4gICAgICAgIGNvbnN0IGNvb3JkcyA9IHRoaXMuZ2V0U2FtcGxlQ29vcmRzKHYpO1xyXG5cclxuICAgICAgICAvLyBDaGVjayBzYW1wbGVzIGluIDkgY2VsbHMgaW4gM3gzIGdyaWRcclxuICAgICAgICBmb3IgKGxldCB4ID0gLTE7IHggPD0gMTsgeCsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAtMTsgeSA8PSAxOyB5KyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBjb29yZHMuY2xvbmUoKS5hZGQobmV3IFZlY3Rvcih4LCB5KSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudmVjdG9yT3V0T2ZCb3VuZHMoY2VsbCwgdGhpcy5ncmlkRGltZW5zaW9ucykpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMudmVjdG9yRmFyRnJvbVZlY3RvcnModiwgdGhpcy5ncmlkW2NlbGwueF1bY2VsbC55XSwgZFNxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IHdoZXRoZXIgdiBpcyBhdCBsZWFzdCBkIGF3YXkgZnJvbSB2ZWN0b3JzXHJcbiAgICAgKiBQZXJmb3JtYW5jZSB2ZXJ5IGltcG9ydGFudCAtIHRoaXMgaXMgY2FsbGVkIGF0IGV2ZXJ5IGludGVncmF0aW9uIHN0ZXBcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSAgIGRTcSAgICAgc3F1YXJlZCB0ZXN0IGRpc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHZlY3RvckZhckZyb21WZWN0b3JzKHY6IFZlY3RvciwgdmVjdG9yczogVmVjdG9yW10sIGRTcTogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgZm9yIChjb25zdCBzYW1wbGUgb2YgdmVjdG9ycykge1xyXG4gICAgICAgICAgICBpZiAoc2FtcGxlICE9PSB2KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZVNxID0gc2FtcGxlLmRpc3RhbmNlVG9TcXVhcmVkKHYpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlU3EgPCBkU3EpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBwb2ludHMgaW4gY2VsbHMgc3Vycm91bmRpbmcgdlxyXG4gICAgICogUmVzdWx0cyBpbmNsdWRlIHYsIGlmIGl0IGV4aXN0cyBpbiB0aGUgZ3JpZFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJldHVybnMgc2FtcGxlcyAoa2luZCBvZikgY2xvc2VyIHRoYW4gZGlzdGFuY2UgLSByZXR1cm5zIGFsbCBzYW1wbGVzIGluIFxyXG4gICAgICogY2VsbHMgc28gYXBwcm94aW1hdGlvbiAoc3F1YXJlIHRvIGFwcHJveGltYXRlIGNpcmNsZSlcclxuICAgICAqL1xyXG4gICAgZ2V0TmVhcmJ5UG9pbnRzKHY6IFZlY3RvciwgZGlzdGFuY2U6IG51bWJlcik6IFZlY3RvcltdIHtcclxuICAgICAgICBjb25zdCByYWRpdXMgPSBNYXRoLmNlaWwoKGRpc3RhbmNlL3RoaXMuZHNlcCkgLSAwLjUpO1xyXG4gICAgICAgIGNvbnN0IGNvb3JkcyA9IHRoaXMuZ2V0U2FtcGxlQ29vcmRzKHYpO1xyXG4gICAgICAgIGNvbnN0IG91dDogVmVjdG9yW10gPSBbXTtcclxuICAgICAgICBmb3IgKGxldCB4ID0gLTEgKiByYWRpdXM7IHggPD0gMSAqIHJhZGl1czsgeCsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAtMSAqIHJhZGl1czsgeSA8PSAxICogcmFkaXVzOyB5KyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBjb29yZHMuY2xvbmUoKS5hZGQobmV3IFZlY3Rvcih4LCB5KSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudmVjdG9yT3V0T2ZCb3VuZHMoY2VsbCwgdGhpcy5ncmlkRGltZW5zaW9ucykpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYyIG9mIHRoaXMuZ3JpZFtjZWxsLnhdW2NlbGwueV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2godjIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHdvcmxkVG9HcmlkKHY6IFZlY3Rvcik6IFZlY3RvciB7XHJcbiAgICAgICAgcmV0dXJuIHYuY2xvbmUoKS5zdWIodGhpcy5vcmlnaW4pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ3JpZFRvV29ybGQodjogVmVjdG9yKTogVmVjdG9yIHtcclxuICAgICAgICByZXR1cm4gdi5jbG9uZSgpLmFkZCh0aGlzLm9yaWdpbik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB2ZWN0b3JPdXRPZkJvdW5kcyhncmlkVjogVmVjdG9yLCBib3VuZHM6IFZlY3Rvcik6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiAoZ3JpZFYueCA8IDAgfHwgZ3JpZFYueSA8IDAgfHxcclxuICAgICAgICAgICAgZ3JpZFYueCA+PSBib3VuZHMueCB8fCBncmlkVi55ID49IGJvdW5kcy55KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4ge1ZlY3Rvcn0gICBDZWxsIGNvb3JkcyBjb3JyZXNwb25kaW5nIHRvIHZlY3RvclxyXG4gICAgICogUGVyZm9ybWFuY2UgaW1wb3J0YW50IC0gY2FsbGVkIGF0IGV2ZXJ5IGludGVncmF0aW9uIHN0ZXBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZXRTYW1wbGVDb29yZHMod29ybGRWOiBWZWN0b3IpOiBWZWN0b3Ige1xyXG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLndvcmxkVG9HcmlkKHdvcmxkVik7XHJcbiAgICAgICAgaWYgKHRoaXMudmVjdG9yT3V0T2ZCb3VuZHModiwgdGhpcy53b3JsZERpbWVuc2lvbnMpKSB7XHJcbiAgICAgICAgICAgIC8vIGxvZy5lcnJvcihcIlRyaWVkIHRvIGFjY2VzcyBvdXQtb2YtYm91bmRzIHNhbXBsZSBpbiBncmlkXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gVmVjdG9yLnplcm9WZWN0b3IoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKFxyXG4gICAgICAgICAgICBNYXRoLmZsb29yKHYueCAvIHRoaXMuZHNlcCksXHJcbiAgICAgICAgICAgIE1hdGguZmxvb3Iodi55IC8gdGhpcy5kc2VwKVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IFRlbnNvckZpZWxkIGZyb20gJy4vdGVuc29yX2ZpZWxkJztcclxuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xyXG5pbXBvcnQge1N0cmVhbWxpbmVQYXJhbXN9IGZyb20gJy4vc3RyZWFtbGluZXMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgRmllbGRJbnRlZ3JhdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBmaWVsZDogVGVuc29yRmllbGQpIHt9XHJcblxyXG4gICAgYWJzdHJhY3QgaW50ZWdyYXRlKHBvaW50OiBWZWN0b3IsIG1ham9yOiBib29sZWFuKTogVmVjdG9yO1xyXG5cclxuICAgIHByb3RlY3RlZCBzYW1wbGVGaWVsZFZlY3Rvcihwb2ludDogVmVjdG9yLCBtYWpvcjogYm9vbGVhbik6IFZlY3RvciB7XHJcbiAgICAgICAgY29uc3QgdGVuc29yID0gdGhpcy5maWVsZC5zYW1wbGVQb2ludChwb2ludCk7XHJcbiAgICAgICAgaWYgKG1ham9yKSByZXR1cm4gdGVuc29yLmdldE1ham9yKCk7XHJcbiAgICAgICAgcmV0dXJuIHRlbnNvci5nZXRNaW5vcigpO1xyXG4gICAgfVxyXG5cclxuICAgIG9uTGFuZChwb2ludDogVmVjdG9yKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGQub25MYW5kKHBvaW50KTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEV1bGVySW50ZWdyYXRvciBleHRlbmRzIEZpZWxkSW50ZWdyYXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmaWVsZDogVGVuc29yRmllbGQsIHByaXZhdGUgcGFyYW1zOiBTdHJlYW1saW5lUGFyYW1zKSB7XHJcbiAgICAgICAgc3VwZXIoZmllbGQpO1xyXG4gICAgfVxyXG5cclxuICAgIGludGVncmF0ZShwb2ludDogVmVjdG9yLCBtYWpvcjogYm9vbGVhbik6IFZlY3RvciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FtcGxlRmllbGRWZWN0b3IocG9pbnQsIG1ham9yKS5tdWx0aXBseVNjYWxhcih0aGlzLnBhcmFtcy5kc3RlcCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBSSzRJbnRlZ3JhdG9yIGV4dGVuZHMgRmllbGRJbnRlZ3JhdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKGZpZWxkOiBUZW5zb3JGaWVsZCwgcHJpdmF0ZSBwYXJhbXM6IFN0cmVhbWxpbmVQYXJhbXMpIHtcclxuICAgICAgICBzdXBlcihmaWVsZCk7XHJcbiAgICB9XHJcblxyXG4gICAgaW50ZWdyYXRlKHBvaW50OiBWZWN0b3IsIG1ham9yOiBib29sZWFuKTogVmVjdG9yIHtcclxuICAgICAgICBjb25zdCBrMSA9IHRoaXMuc2FtcGxlRmllbGRWZWN0b3IocG9pbnQsIG1ham9yKTtcclxuICAgICAgICBjb25zdCBrMjMgPSB0aGlzLnNhbXBsZUZpZWxkVmVjdG9yKHBvaW50LmNsb25lKCkuYWRkKFZlY3Rvci5mcm9tU2NhbGFyKHRoaXMucGFyYW1zLmRzdGVwIC8gMikpLCBtYWpvcik7XHJcbiAgICAgICAgY29uc3QgazQgPSB0aGlzLnNhbXBsZUZpZWxkVmVjdG9yKHBvaW50LmNsb25lKCkuYWRkKFZlY3Rvci5mcm9tU2NhbGFyKHRoaXMucGFyYW1zLmRzdGVwKSksIG1ham9yKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGsxLmFkZChrMjMubXVsdGlwbHlTY2FsYXIoNCkpLmFkZChrNCkubXVsdGlwbHlTY2FsYXIodGhpcy5wYXJhbXMuZHN0ZXAgLyA2KTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xyXG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XHJcbmltcG9ydCB7Tm9kZX0gZnJvbSAnLi9ncmFwaCc7XHJcbmltcG9ydCBQb2x5Z29uVXRpbCBmcm9tICcuL3BvbHlnb25fdXRpbCc7XHJcbmltcG9ydCBUZW5zb3JGaWVsZCBmcm9tICcuL3RlbnNvcl9maWVsZCc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFBvbHlnb25QYXJhbXMge1xyXG4gICAgbWF4TGVuZ3RoOiBudW1iZXI7XHJcbiAgICBtaW5BcmVhOiBudW1iZXI7XHJcbiAgICBzaHJpbmtTcGFjaW5nOiBudW1iZXI7XHJcbiAgICBjaGFuY2VOb0RpdmlkZTogbnVtYmVyO1xyXG59XHJcblxyXG4vKipcclxuICogRmluZHMgcG9seWdvbnMgaW4gYSBncmFwaCwgdXNlZCBmb3IgZmluZGluZyBsb3RzIGFuZCBwYXJrc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9seWdvbkZpbmRlciB7XHJcbiAgICBwcml2YXRlIF9wb2x5Z29uczogVmVjdG9yW11bXSA9IFtdO1xyXG4gICAgcHJpdmF0ZSBfc2hydW5rUG9seWdvbnM6IFZlY3RvcltdW10gPSBbXTtcclxuICAgIHByaXZhdGUgX2RpdmlkZWRQb2x5Z29uczogVmVjdG9yW11bXSA9IFtdO1xyXG4gICAgcHJpdmF0ZSB0b1NocmluazogVmVjdG9yW11bXSA9IFtdO1xyXG4gICAgcHJpdmF0ZSByZXNvbHZlU2hyaW5rOiAoKSA9PiB2b2lkO1xyXG4gICAgcHJpdmF0ZSB0b0RpdmlkZTogVmVjdG9yW11bXSA9IFtdO1xyXG4gICAgcHJpdmF0ZSByZXNvbHZlRGl2aWRlOiAoKSA9PiB2b2lkO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbm9kZXM6IE5vZGVbXSwgcHJpdmF0ZSBwYXJhbXM6IFBvbHlnb25QYXJhbXMsIHByaXZhdGUgdGVuc29yRmllbGQ6IFRlbnNvckZpZWxkKSB7fVxyXG5cclxuICAgIGdldCBwb2x5Z29ucygpOiBWZWN0b3JbXVtdIHtcclxuICAgICAgICBpZiAodGhpcy5fZGl2aWRlZFBvbHlnb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RpdmlkZWRQb2x5Z29ucztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9zaHJ1bmtQb2x5Z29ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaHJ1bmtQb2x5Z29ucztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl9wb2x5Z29ucztcclxuICAgIH1cclxuXHJcbiAgICByZXNldCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnRvU2hyaW5rID0gW107XHJcbiAgICAgICAgdGhpcy50b0RpdmlkZSA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3BvbHlnb25zID0gW107XHJcbiAgICAgICAgdGhpcy5fc2hydW5rUG9seWdvbnMgPSBbXVxyXG4gICAgICAgIHRoaXMuX2RpdmlkZWRQb2x5Z29ucyA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZSgpOiBib29sZWFuIHtcclxuICAgICAgICBsZXQgY2hhbmdlID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHRoaXMudG9TaHJpbmsubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlID0gdGhpcy50b1Nocmluay5sZW5ndGggPT09IDE7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0ZXBTaHJpbmsodGhpcy50b1Nocmluay5wb3AoKSkpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChyZXNvbHZlKSB0aGlzLnJlc29sdmVTaHJpbmsoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnRvRGl2aWRlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZSA9IHRoaXMudG9EaXZpZGUubGVuZ3RoID09PSAxO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdGVwRGl2aWRlKHRoaXMudG9EaXZpZGUucG9wKCkpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzb2x2ZSkgdGhpcy5yZXNvbHZlRGl2aWRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjaGFuZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9wZXJseSBzaHJpbmsgcG9seWdvbiBzbyB0aGUgZWRnZXMgYXJlIGFsbCB0aGUgc2FtZSBkaXN0YW5jZSBmcm9tIHRoZSByb2FkXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHNocmluayhhbmltYXRlPWZhbHNlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KHJlc29sdmUgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcG9seWdvbnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmRQb2x5Z29ucygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoYW5pbWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BvbHlnb25zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy50b1NocmluayA9IHRoaXMuX3BvbHlnb25zLnNsaWNlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVTaHJpbmsgPSByZXNvbHZlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hydW5rUG9seWdvbnMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLl9wb2x5Z29ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RlcFNocmluayhwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RlcFNocmluayhwb2x5Z29uOiBWZWN0b3JbXSk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGNvbnN0IHNocnVuayA9IFBvbHlnb25VdGlsLnJlc2l6ZUdlb21ldHJ5KHBvbHlnb24sIC10aGlzLnBhcmFtcy5zaHJpbmtTcGFjaW5nKTtcclxuICAgICAgICBpZiAoc2hydW5rLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5fc2hydW5rUG9seWdvbnMucHVzaChzaHJ1bmspXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgZGl2aWRlKGFuaW1hdGU9ZmFsc2UpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4ocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9wb2x5Z29ucy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmluZFBvbHlnb25zKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCBwb2x5Z29ucyA9IHRoaXMuX3BvbHlnb25zO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fc2hydW5rUG9seWdvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcG9seWdvbnMgPSB0aGlzLl9zaHJ1bmtQb2x5Z29ucztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGFuaW1hdGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwb2x5Z29ucy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMudG9EaXZpZGUgPSBwb2x5Z29ucy5zbGljZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlRGl2aWRlID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RpdmlkZWRQb2x5Z29ucyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIHBvbHlnb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGVwRGl2aWRlKHApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGVwRGl2aWRlKHBvbHlnb246IFZlY3RvcltdKTogYm9vbGVhbiB7XHJcbiAgICAgICAgLy8gVE9ETyBuZWVkIHRvIGZpbHRlciBzaHJ1bmsgcG9seWdvbnMgdXNpbmcgYXNwZWN0IHJhdGlvLCBhcmVhIFxyXG4gICAgICAgIC8vIHRoaXMgc2tpcHMgdGhlIGZpbHRlciBpbiBQb2x5Z29uVXRpbC5zdWJkaXZpZGVQb2x5Z29uXHJcbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLmNoYW5jZU5vRGl2aWRlID4gMCAmJiBNYXRoLnJhbmRvbSgpIDwgdGhpcy5wYXJhbXMuY2hhbmNlTm9EaXZpZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGl2aWRlZFBvbHlnb25zLnB1c2gocG9seWdvbik7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkaXZpZGVkID0gUG9seWdvblV0aWwuc3ViZGl2aWRlUG9seWdvbihwb2x5Z29uLCB0aGlzLnBhcmFtcy5taW5BcmVhKTtcclxuICAgICAgICBpZiAoZGl2aWRlZC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpdmlkZWRQb2x5Z29ucy5wdXNoKC4uLmRpdmlkZWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGZpbmRQb2x5Z29ucygpOiB2b2lkIHtcclxuICAgICAgICAvLyBOb2RlXHJcbiAgICAgICAgLy8geCwgeSwgdmFsdWUgKFZlY3RvcjIpLCBhZGogKGxpc3Qgb2Ygbm9kZSByZWZzKVxyXG4gICAgICAgIC8vIEdvbm5hIGVkaXQgYWRqIGZvciBub3dcclxuXHJcbiAgICAgICAgLy8gV2FsayBhIGNsb2Nrd2lzZSBwYXRoIHVudGlsIHBvbHlnb24gZm91bmQgb3IgbGltaXQgcmVhY2hlZFxyXG4gICAgICAgIC8vIFdoZW4gd2UgZmluZCBhIHBvbHlnb24sIG1hcmsgYWxsIGVkZ2VzIGFzIHRyYXZlcnNlZCAoaW4gcGFydGljdWxhciBkaXJlY3Rpb24pXHJcbiAgICAgICAgLy8gRWFjaCBlZGdlIHNlcGFyYXRlcyB0d28gcG9seWdvbnNcclxuICAgICAgICAvLyBJZiBlZGdlIGFscmVhZHkgdHJhdmVyc2VkIGluIHRoaXMgZGlyZWN0aW9uLCB0aGlzIHBvbHlnb24gaGFzIGFscmVhZHkgYmVlbiBmb3VuZFxyXG4gICAgICAgIHRoaXMuX3NocnVua1BvbHlnb25zID0gW107XHJcbiAgICAgICAgdGhpcy5fZGl2aWRlZFBvbHlnb25zID0gW107XHJcbiAgICAgICAgY29uc3QgcG9seWdvbnMgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMubm9kZXMpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUuYWRqLmxlbmd0aCA8IDIpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5leHROb2RlIG9mIG5vZGUuYWRqKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb2x5Z29uID0gdGhpcy5yZWN1cnNpdmVXYWxrKFtub2RlLCBuZXh0Tm9kZV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvbHlnb24gIT09IG51bGwgJiYgcG9seWdvbi5sZW5ndGggPCB0aGlzLnBhcmFtcy5tYXhMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVBvbHlnb25BZGphY2VuY2llcyhwb2x5Z29uKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29ucy5wdXNoKHBvbHlnb24ubWFwKG4gPT4gbi52YWx1ZS5jbG9uZSgpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3BvbHlnb25zID0gdGhpcy5maWx0ZXJQb2x5Z29uc0J5V2F0ZXIocG9seWdvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZmlsdGVyUG9seWdvbnNCeVdhdGVyKHBvbHlnb25zOiBWZWN0b3JbXVtdKTogVmVjdG9yW11bXSB7XHJcbiAgICAgICAgY29uc3Qgb3V0OiBWZWN0b3JbXVtdID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHBvbHlnb25zKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGF2ZXJhZ2VQb2ludCA9IFBvbHlnb25VdGlsLmF2ZXJhZ2VQb2ludChwKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGVuc29yRmllbGQub25MYW5kKGF2ZXJhZ2VQb2ludCkgJiYgIXRoaXMudGVuc29yRmllbGQuaW5QYXJrcyhhdmVyYWdlUG9pbnQpKSBvdXQucHVzaChwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlbW92ZVBvbHlnb25BZGphY2VuY2llcyhwb2x5Z29uOiBOb2RlW10pOiB2b2lkIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvbHlnb24ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHBvbHlnb25baV07XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBwb2x5Z29uWyhpICsgMSkgJSBwb2x5Z29uLmxlbmd0aF07XHJcblxyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGN1cnJlbnQuYWRqLmluZGV4T2YobmV4dCk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50LmFkai5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKFwiUG9seWdvbkZpbmRlciAtIG5vZGUgbm90IGluIGFkalwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlY3Vyc2l2ZVdhbGsodmlzaXRlZDogTm9kZVtdLCBjb3VudD0wKTogTm9kZVtdIHtcclxuICAgICAgICBpZiAoY291bnQgPj0gdGhpcy5wYXJhbXMubWF4TGVuZ3RoKSByZXR1cm4gbnVsbDtcclxuICAgICAgICAvLyBUT0RPIGJhY2t0cmFja2luZyB0byBmaW5kIHBvbHlnb25zIHdpdGggZGVhZCBlbmQgcm9hZHMgaW5zaWRlIHRoZW1cclxuICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IHRoaXMuZ2V0UmlnaHRtb3N0Tm9kZSh2aXNpdGVkW3Zpc2l0ZWQubGVuZ3RoIC0gMl0sIHZpc2l0ZWRbdmlzaXRlZC5sZW5ndGggLSAxXSk7XHJcbiAgICAgICAgaWYgKG5leHROb2RlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAgLy8gQ3VycmVudGx5IGlnbm9yZXMgcG9seWdvbnMgd2l0aCBkZWFkIGVuZCBpbnNpZGVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHZpc2l0ZWRJbmRleCA9IHZpc2l0ZWQuaW5kZXhPZihuZXh0Tm9kZSk7XHJcbiAgICAgICAgaWYgKHZpc2l0ZWRJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2aXNpdGVkLnNsaWNlKHZpc2l0ZWRJbmRleCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmlzaXRlZC5wdXNoKG5leHROb2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVjdXJzaXZlV2Fsayh2aXNpdGVkLCBjb3VudCsrKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRSaWdodG1vc3ROb2RlKG5vZGVGcm9tOiBOb2RlLCBub2RlVG86IE5vZGUpOiBOb2RlIHtcclxuICAgICAgICAvLyBXZSB3YW50IHRvIHR1cm4gcmlnaHQgYXQgZXZlcnkganVuY3Rpb25cclxuICAgICAgICBpZiAobm9kZVRvLmFkai5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICBjb25zdCBiYWNrd2FyZHNEaWZmZXJlbmNlVmVjdG9yID0gbm9kZUZyb20udmFsdWUuY2xvbmUoKS5zdWIobm9kZVRvLnZhbHVlKTtcclxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1BbmdsZSA9IE1hdGguYXRhbjIoYmFja3dhcmRzRGlmZmVyZW5jZVZlY3Rvci55LCBiYWNrd2FyZHNEaWZmZXJlbmNlVmVjdG9yLngpO1xyXG5cclxuICAgICAgICBsZXQgcmlnaHRtb3N0Tm9kZSA9IG51bGw7XHJcbiAgICAgICAgbGV0IHNtYWxsZXN0VGhldGEgPSBNYXRoLlBJICogMjtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBuZXh0Tm9kZSBvZiBub2RlVG8uYWRqKSB7XHJcbiAgICAgICAgICAgIGlmIChuZXh0Tm9kZSAhPT0gbm9kZUZyb20pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRWZWN0b3IgPSBuZXh0Tm9kZS52YWx1ZS5jbG9uZSgpLnN1Yihub2RlVG8udmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgbGV0IG5leHRBbmdsZSA9IE1hdGguYXRhbjIobmV4dFZlY3Rvci55LCBuZXh0VmVjdG9yLngpIC0gdHJhbnNmb3JtQW5nbGU7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dEFuZ2xlIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRBbmdsZSArPSBNYXRoLlBJICogMjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dEFuZ2xlIDwgc21hbGxlc3RUaGV0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNtYWxsZXN0VGhldGEgPSBuZXh0QW5nbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRtb3N0Tm9kZSA9IG5leHROb2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmlnaHRtb3N0Tm9kZTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xyXG5pbXBvcnQgKiBhcyBQb2x5SyBmcm9tICdwb2x5ayc7XHJcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcclxuaW1wb3J0ICogYXMganN0cyBmcm9tICdqc3RzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvbHlnb25VdGlsIHtcclxuICAgIHByaXZhdGUgc3RhdGljIGdlb21ldHJ5RmFjdG9yeSA9IG5ldyBqc3RzLmdlb20uR2VvbWV0cnlGYWN0b3J5KCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTbGljZXMgcmVjdGFuZ2xlIGJ5IGxpbmUsIHJldHVybmluZyBzbWFsbGVzdCBwb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc2xpY2VSZWN0YW5nbGUob3JpZ2luOiBWZWN0b3IsIHdvcmxkRGltZW5zaW9uczogVmVjdG9yLCBwMTogVmVjdG9yLCBwMjogVmVjdG9yKTogVmVjdG9yW10ge1xyXG4gICAgICAgIGNvbnN0IHJlY3RhbmdsZSA9IFtcclxuICAgICAgICAgICAgb3JpZ2luLngsIG9yaWdpbi55LFxyXG4gICAgICAgICAgICBvcmlnaW4ueCArIHdvcmxkRGltZW5zaW9ucy54LCBvcmlnaW4ueSxcclxuICAgICAgICAgICAgb3JpZ2luLnggKyB3b3JsZERpbWVuc2lvbnMueCwgb3JpZ2luLnkgKyB3b3JsZERpbWVuc2lvbnMueSxcclxuICAgICAgICAgICAgb3JpZ2luLngsIG9yaWdpbi55ICsgd29ybGREaW1lbnNpb25zLnksXHJcbiAgICAgICAgXTtcclxuICAgICAgICBjb25zdCBzbGljZWQgPSBQb2x5Sy5TbGljZShyZWN0YW5nbGUsIHAxLngsIHAxLnksIHAyLngsIHAyLnkpLm1hcChwID0+IFBvbHlnb25VdGlsLnBvbHlnb25BcnJheVRvUG9seWdvbihwKSk7XHJcbiAgICAgICAgY29uc3QgbWluQXJlYSA9IFBvbHlnb25VdGlsLmNhbGNQb2x5Z29uQXJlYShzbGljZWRbMF0pO1xyXG5cclxuICAgICAgICBpZiAoc2xpY2VkLmxlbmd0aCA+IDEgJiYgUG9seWdvblV0aWwuY2FsY1BvbHlnb25BcmVhKHNsaWNlZFsxXSkgPCBtaW5BcmVhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzbGljZWRbMV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc2xpY2VkWzBdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byBjcmVhdGUgc2VhIHBvbHlnb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBsaW5lUmVjdGFuZ2xlUG9seWdvbkludGVyc2VjdGlvbihvcmlnaW46IFZlY3Rvciwgd29ybGREaW1lbnNpb25zOiBWZWN0b3IsIGxpbmU6IFZlY3RvcltdKTogVmVjdG9yW10ge1xyXG4gICAgICAgIGNvbnN0IGpzdHNMaW5lID0gUG9seWdvblV0aWwubGluZVRvSnRzKGxpbmUpO1xyXG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IFtcclxuICAgICAgICAgICAgb3JpZ2luLFxyXG4gICAgICAgICAgICBuZXcgVmVjdG9yKG9yaWdpbi54ICsgd29ybGREaW1lbnNpb25zLngsIG9yaWdpbi55KSxcclxuICAgICAgICAgICAgbmV3IFZlY3RvcihvcmlnaW4ueCArIHdvcmxkRGltZW5zaW9ucy54LCBvcmlnaW4ueSArIHdvcmxkRGltZW5zaW9ucy55KSxcclxuICAgICAgICAgICAgbmV3IFZlY3RvcihvcmlnaW4ueCwgb3JpZ2luLnkgKyB3b3JsZERpbWVuc2lvbnMueSksXHJcbiAgICAgICAgXTtcclxuICAgICAgICBjb25zdCBib3VuZGluZ1BvbHkgPSBQb2x5Z29uVXRpbC5wb2x5Z29uVG9KdHMoYm91bmRzKTtcclxuICAgICAgICBjb25zdCB1bmlvbiA9IGJvdW5kaW5nUG9seS5nZXRFeHRlcmlvclJpbmcoKS51bmlvbihqc3RzTGluZSk7XHJcbiAgICAgICAgY29uc3QgcG9seWdvbml6ZXIgPSBuZXcgKGpzdHMub3BlcmF0aW9uIGFzIGFueSkucG9seWdvbml6ZS5Qb2x5Z29uaXplcigpO1xyXG4gICAgICAgIHBvbHlnb25pemVyLmFkZCh1bmlvbik7XHJcbiAgICAgICAgY29uc3QgcG9seWdvbnMgPSBwb2x5Z29uaXplci5nZXRQb2x5Z29ucygpO1xyXG5cclxuICAgICAgICBsZXQgc21hbGxlc3RBcmVhID0gSW5maW5pdHk7XHJcbiAgICAgICAgbGV0IHNtYWxsZXN0UG9seTtcclxuICAgICAgICBmb3IgKGxldCBpID0gcG9seWdvbnMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvbHlnb24gPSBpLm5leHQoKTtcclxuICAgICAgICAgICAgY29uc3QgYXJlYSA9IHBvbHlnb24uZ2V0QXJlYSgpO1xyXG4gICAgICAgICAgICBpZiAoYXJlYSA8IHNtYWxsZXN0QXJlYSkge1xyXG4gICAgICAgICAgICAgICAgc21hbGxlc3RBcmVhID0gYXJlYTtcclxuICAgICAgICAgICAgICAgIHNtYWxsZXN0UG9seSA9IHBvbHlnb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghc21hbGxlc3RQb2x5KSByZXR1cm4gW107XHJcbiAgICAgICAgcmV0dXJuIHNtYWxsZXN0UG9seS5nZXRDb29yZGluYXRlcygpLm1hcCgoYzogYW55KSA9PiBuZXcgVmVjdG9yKGMueCwgYy55KSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBjYWxjUG9seWdvbkFyZWEocG9seWdvbjogVmVjdG9yW10pOiBudW1iZXIge1xyXG4gICAgICAgIGxldCB0b3RhbCA9IDA7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9seWdvbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgY29uc3QgYWRkWCA9IHBvbHlnb25baV0ueDtcclxuICAgICAgICAgIGNvbnN0IGFkZFkgPSBwb2x5Z29uW2kgPT0gcG9seWdvbi5sZW5ndGggLSAxID8gMCA6IGkgKyAxXS55O1xyXG4gICAgICAgICAgY29uc3Qgc3ViWCA9IHBvbHlnb25baSA9PSBwb2x5Z29uLmxlbmd0aCAtIDEgPyAwIDogaSArIDFdLng7XHJcbiAgICAgICAgICBjb25zdCBzdWJZID0gcG9seWdvbltpXS55O1xyXG5cclxuICAgICAgICAgIHRvdGFsICs9IChhZGRYICogYWRkWSAqIDAuNSk7XHJcbiAgICAgICAgICB0b3RhbCAtPSAoc3ViWCAqIHN1YlkgKiAwLjUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRvdGFsKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlY3Vyc2l2ZWx5IGRpdmlkZSBhIHBvbHlnb24gYnkgaXRzIGxvbmdlc3Qgc2lkZSB1bnRpbCB0aGUgbWluQXJlYSBzdG9wcGluZyBjb25kaXRpb24gaXMgbWV0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgc3ViZGl2aWRlUG9seWdvbihwOiBWZWN0b3JbXSwgbWluQXJlYTogbnVtYmVyKTogVmVjdG9yW11bXSB7XHJcbiAgICAgICAgY29uc3QgYXJlYSA9IFBvbHlnb25VdGlsLmNhbGNQb2x5Z29uQXJlYShwKTtcclxuICAgICAgICBpZiAoYXJlYSA8IDAuNSAqIG1pbkFyZWEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkaXZpZGVkOiBWZWN0b3JbXVtdID0gW107ICAvLyBBcnJheSBvZiBwb2x5Z29uc1xyXG5cclxuICAgICAgICBsZXQgbG9uZ2VzdFNpZGVMZW5ndGggPSAwO1xyXG4gICAgICAgIGxldCBsb25nZXN0U2lkZSA9IFtwWzBdLCBwWzFdXTtcclxuXHJcbiAgICAgICAgbGV0IHBlcmltZXRlciA9IDA7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBzaWRlTGVuZ3RoID0gcFtpXS5jbG9uZSgpLnN1YihwWyhpKzEpICUgcC5sZW5ndGhdKS5sZW5ndGgoKTtcclxuICAgICAgICAgICAgcGVyaW1ldGVyICs9IHNpZGVMZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChzaWRlTGVuZ3RoID4gbG9uZ2VzdFNpZGVMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGxvbmdlc3RTaWRlTGVuZ3RoID0gc2lkZUxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGxvbmdlc3RTaWRlID0gW3BbaV0sIHBbKGkrMSkgJSBwLmxlbmd0aF1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTaGFwZSBpbmRleFxyXG4gICAgICAgIC8vIFVzaW5nIHJlY3RhbmdsZSByYXRpbyBvZiAxOjQgYXMgbGltaXRcclxuICAgICAgICAvLyBpZiAoYXJlYSAvIHBlcmltZXRlciAqIHBlcmltZXRlciA8IDAuMDQpIHtcclxuICAgICAgICBpZiAoYXJlYSAvIChwZXJpbWV0ZXIgKiBwZXJpbWV0ZXIpIDwgMC4wNCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYXJlYSA8IDIgKiBtaW5BcmVhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbcF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBCZXR3ZWVuIDAuNCBhbmQgMC42XHJcbiAgICAgICAgY29uc3QgZGV2aWF0aW9uID0gKE1hdGgucmFuZG9tKCkgKiAwLjIpICsgMC40O1xyXG5cclxuICAgICAgICBjb25zdCBhdmVyYWdlUG9pbnQgPSBsb25nZXN0U2lkZVswXS5jbG9uZSgpLmFkZChsb25nZXN0U2lkZVsxXSkubXVsdGlwbHlTY2FsYXIoZGV2aWF0aW9uKTtcclxuICAgICAgICBjb25zdCBkaWZmZXJlbmNlVmVjdG9yID0gbG9uZ2VzdFNpZGVbMF0uY2xvbmUoKS5zdWIobG9uZ2VzdFNpZGVbMV0pO1xyXG4gICAgICAgIGNvbnN0IHBlcnBWZWN0b3IgPSAobmV3IFZlY3RvcihkaWZmZXJlbmNlVmVjdG9yLnksIC0xICogZGlmZmVyZW5jZVZlY3Rvci54KSlcclxuICAgICAgICAgICAgLm5vcm1hbGl6ZSgpXHJcbiAgICAgICAgICAgIC5tdWx0aXBseVNjYWxhcigxMDApO1xyXG5cclxuICAgICAgICBjb25zdCBiaXNlY3QgPSBbYXZlcmFnZVBvaW50LmNsb25lKCkuYWRkKHBlcnBWZWN0b3IpLCBhdmVyYWdlUG9pbnQuY2xvbmUoKS5zdWIocGVycFZlY3RvcildO1xyXG5cclxuICAgICAgICAvLyBBcnJheSBvZiBwb2x5Z29uc1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlZCA9IFBvbHlLLlNsaWNlKFBvbHlnb25VdGlsLnBvbHlnb25Ub1BvbHlnb25BcnJheShwKSwgYmlzZWN0WzBdLngsIGJpc2VjdFswXS55LCBiaXNlY3RbMV0ueCwgYmlzZWN0WzFdLnkpO1xyXG4gICAgICAgICAgICAvLyBSZWN1cnNpdmUgY2FsbFxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHMgb2Ygc2xpY2VkKSB7XHJcbiAgICAgICAgICAgICAgICBkaXZpZGVkLnB1c2goLi4uUG9seWdvblV0aWwuc3ViZGl2aWRlUG9seWdvbihQb2x5Z29uVXRpbC5wb2x5Z29uQXJyYXlUb1BvbHlnb24ocyksIG1pbkFyZWEpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGRpdmlkZWQ7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgbG9nLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNocmluayBvciBleHBhbmQgcG9seWdvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlc2l6ZUdlb21ldHJ5KGdlb21ldHJ5OiBWZWN0b3JbXSwgc3BhY2luZzogbnVtYmVyLCBpc1BvbHlnb249dHJ1ZSk6IFZlY3RvcltdIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBqc3RzR2VvbWV0cnkgPSBpc1BvbHlnb24/IFBvbHlnb25VdGlsLnBvbHlnb25Ub0p0cyhnZW9tZXRyeSkgOiBQb2x5Z29uVXRpbC5saW5lVG9KdHMoZ2VvbWV0cnkpO1xyXG4gICAgICAgICAgICBjb25zdCByZXNpemVkID0ganN0c0dlb21ldHJ5LmJ1ZmZlcihzcGFjaW5nLCB1bmRlZmluZWQsIChqc3RzIGFzIGFueSkub3BlcmF0aW9uLmJ1ZmZlci5CdWZmZXJQYXJhbWV0ZXJzLkNBUF9GTEFUKTtcclxuICAgICAgICAgICAgaWYgKCFyZXNpemVkLmlzU2ltcGxlKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzaXplZC5nZXRDb29yZGluYXRlcygpLm1hcChjID0+IG5ldyBWZWN0b3IoYy54LCBjLnkpKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBsb2cuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgYXZlcmFnZVBvaW50KHBvbHlnb246IFZlY3RvcltdKTogVmVjdG9yIHtcclxuICAgICAgICBpZiAocG9seWdvbi5sZW5ndGggPT09IDApIHJldHVybiBWZWN0b3IuemVyb1ZlY3RvcigpO1xyXG4gICAgICAgIGNvbnN0IHN1bSA9IFZlY3Rvci56ZXJvVmVjdG9yKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHBvbHlnb24pIHtcclxuICAgICAgICAgICAgc3VtLmFkZCh2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1bS5kaXZpZGVTY2FsYXIocG9seWdvbi5sZW5ndGgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgaW5zaWRlUG9seWdvbihwb2ludDogVmVjdG9yLCBwb2x5Z29uOiBWZWN0b3JbXSk6IGJvb2xlYW4ge1xyXG4gICAgICAgIC8vIHJheS1jYXN0aW5nIGFsZ29yaXRobSBiYXNlZCBvblxyXG4gICAgICAgIC8vIGh0dHA6Ly93d3cuZWNzZS5ycGkuZWR1L0hvbWVwYWdlcy93cmYvUmVzZWFyY2gvU2hvcnRfTm90ZXMvcG5wb2x5Lmh0bWxcclxuXHJcbiAgICAgICAgaWYgKHBvbHlnb24ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBpbnNpZGUgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IHBvbHlnb24ubGVuZ3RoIC0gMTsgaSA8IHBvbHlnb24ubGVuZ3RoOyBqID0gaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHhpID0gcG9seWdvbltpXS54LCB5aSA9IHBvbHlnb25baV0ueTtcclxuICAgICAgICAgICAgY29uc3QgeGogPSBwb2x5Z29uW2pdLngsIHlqID0gcG9seWdvbltqXS55O1xyXG5cclxuICAgICAgICAgICAgY29uc3QgaW50ZXJzZWN0ID0gKCh5aSA+IHBvaW50LnkpICE9ICh5aiA+IHBvaW50LnkpKVxyXG4gICAgICAgICAgICAgICAgJiYgKHBvaW50LnggPCAoeGogLSB4aSkgKiAocG9pbnQueSAtIHlpKSAvICh5aiAtIHlpKSArIHhpKTtcclxuICAgICAgICAgICAgaWYgKGludGVyc2VjdCkgaW5zaWRlID0gIWluc2lkZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBpbnNpZGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBwb2ludEluUmVjdGFuZ2xlKHBvaW50OiBWZWN0b3IsIG9yaWdpbjogVmVjdG9yLCBkaW1lbnNpb25zOiBWZWN0b3IpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gcG9pbnQueCA+PSBvcmlnaW4ueCAmJiBwb2ludC55ID49IG9yaWdpbi55ICYmIHBvaW50LnggPD0gZGltZW5zaW9ucy54ICYmIHBvaW50LnkgPD0gZGltZW5zaW9ucy55O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGxpbmVUb0p0cyhsaW5lOiBWZWN0b3JbXSk6IGpzdHMuZ2VvbS5MaW5lU3RyaW5nIHtcclxuICAgICAgICBjb25zdCBjb29yZHMgPSBsaW5lLm1hcCh2ID0+IG5ldyBqc3RzLmdlb20uQ29vcmRpbmF0ZSh2LngsIHYueSkpO1xyXG4gICAgICAgIHJldHVybiBQb2x5Z29uVXRpbC5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhjb29yZHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIHBvbHlnb25Ub0p0cyhwb2x5Z29uOiBWZWN0b3JbXSk6IGpzdHMuZ2VvbS5Qb2x5Z29uIHtcclxuICAgICAgICBjb25zdCBnZW9JbnB1dCA9IHBvbHlnb24ubWFwKHYgPT4gbmV3IGpzdHMuZ2VvbS5Db29yZGluYXRlKHYueCwgdi55KSk7XHJcbiAgICAgICAgZ2VvSW5wdXQucHVzaChnZW9JbnB1dFswXSk7ICAvLyBDcmVhdGUgbG9vcFxyXG4gICAgICAgIHJldHVybiBQb2x5Z29uVXRpbC5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbihQb2x5Z29uVXRpbC5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhnZW9JbnB1dCksIFtdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFsgdi54LCB2LnksIHYueCwgdi55IF0uLi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcG9seWdvblRvUG9seWdvbkFycmF5KHA6IFZlY3RvcltdKTogbnVtYmVyW10ge1xyXG4gICAgICAgIGNvbnN0IG91dFA6IG51bWJlcltdID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHApIHtcclxuICAgICAgICAgICAgb3V0UC5wdXNoKHYueCk7XHJcbiAgICAgICAgICAgIG91dFAucHVzaCh2LnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0UDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFsgdi54LCB2LnksIHYueCwgdi55IF0uLi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcG9seWdvbkFycmF5VG9Qb2x5Z29uKHA6IG51bWJlcltdKTogVmVjdG9yW10ge1xyXG4gICAgICAgIGNvbnN0IG91dFAgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHAubGVuZ3RoIC8gMjsgaSsrKSB7XHJcbiAgICAgICAgICAgIG91dFAucHVzaChuZXcgVmVjdG9yKHBbMippXSwgcFsyKmkgKyAxXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0UDtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xyXG5pbXBvcnQgKiBhcyBzaW1wbGlmeSBmcm9tICdzaW1wbGlmeS1qcyc7XHJcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcclxuaW1wb3J0IEdyaWRTdG9yYWdlIGZyb20gJy4vZ3JpZF9zdG9yYWdlJztcclxuaW1wb3J0IEZpZWxkSW50ZWdyYXRvciBmcm9tICcuL2ludGVncmF0b3InO1xyXG5cclxuaW50ZXJmYWNlIFN0cmVhbWxpbmVJbnRlZ3JhdGlvbiB7XHJcbiAgICBzZWVkOiBWZWN0b3I7XHJcbiAgICBvcmlnaW5hbERpcjogVmVjdG9yO1xyXG4gICAgc3RyZWFtbGluZTogVmVjdG9yW107XHJcbiAgICBwcmV2aW91c0RpcmVjdGlvbjogVmVjdG9yO1xyXG4gICAgcHJldmlvdXNQb2ludDogVmVjdG9yO1xyXG4gICAgdmFsaWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RyZWFtbGluZVBhcmFtcyB7XHJcbiAgICBba2V5OiBzdHJpbmddOiBhbnk7XHJcbiAgICBkc2VwOiBudW1iZXI7ICAvLyBTdHJlYW1saW5lIHNlZWQgc2VwYXJhdGluZyBkaXN0YW5jZVxyXG4gICAgZHRlc3Q6IG51bWJlcjsgIC8vIFN0cmVhbWxpbmUgaW50ZWdyYXRpb24gc2VwYXJhdGluZyBkaXN0YW5jZVxyXG4gICAgZHN0ZXA6IG51bWJlcjsgIC8vIFN0ZXAgc2l6ZVxyXG4gICAgZGNpcmNsZWpvaW46IG51bWJlcjsgIC8vIEhvdyBmYXIgdG8gbG9vayB0byBqb2luIGNpcmNsZXMgLSAoZS5nLiAyIHggZHN0ZXApXHJcbiAgICBkbG9va2FoZWFkOiBudW1iZXI7ICAvLyBIb3cgZmFyIHRvIGxvb2sgYWhlYWQgdG8gam9pbiB1cCBkYW5nbGluZ1xyXG4gICAgam9pbmFuZ2xlOiBudW1iZXI7ICAvLyBBbmdsZSB0byBqb2luIHJvYWRzIGluIHJhZGlhbnNcclxuICAgIHBhdGhJdGVyYXRpb25zOiBudW1iZXI7ICAvLyBQYXRoIGludGVncmF0aW9uIGl0ZXJhdGlvbiBsaW1pdFxyXG4gICAgc2VlZFRyaWVzOiBudW1iZXI7ICAvLyBNYXggZmFpbGVkIHNlZWRzXHJcbiAgICBzaW1wbGlmeVRvbGVyYW5jZTogbnVtYmVyO1xyXG4gICAgY29sbGlkZUVhcmx5OiBudW1iZXI7ICAvLyBDaGFuY2Ugb2YgZWFybHkgY29sbGlzaW9uIDAtMVxyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBwb2x5bGluZXMgdGhhdCBtYWtlIHVwIHRoZSByb2FkcyBieSBpbnRlZ3JhdGluZyB0aGUgdGVuc29yIGZpZWxkXHJcbiAqIFNlZSB0aGUgcGFwZXIgJ0ludGVyYWN0aXZlIFByb2NlZHVyYWwgU3RyZWV0IE1vZGVsaW5nJyBmb3IgYSB0aG9yb3VnaCBleHBsYW5hdGlvblxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RyZWFtbGluZUdlbmVyYXRvciB7XHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgU0VFRF9BVF9FTkRQT0lOVFMgPSBmYWxzZTtcclxuICAgIHByb3RlY3RlZCByZWFkb25seSBORUFSX0VER0UgPSAzOyAgLy8gU2FtcGxlIG5lYXIgZWRnZVxyXG5cclxuICAgIHByb3RlY3RlZCBtYWpvckdyaWQ6IEdyaWRTdG9yYWdlO1xyXG4gICAgcHJvdGVjdGVkIG1pbm9yR3JpZDogR3JpZFN0b3JhZ2U7XHJcbiAgICBwcm90ZWN0ZWQgcGFyYW1zU3E6IFN0cmVhbWxpbmVQYXJhbXM7XHJcblxyXG4gICAgLy8gSG93IG1hbnkgc2FtcGxlcyB0byBza2lwIHdoZW4gY2hlY2tpbmcgc3RyZWFtbGluZSBjb2xsaXNpb24gd2l0aCBpdHNlbGZcclxuICAgIHByb3RlY3RlZCBuU3RyZWFtbGluZVN0ZXA6IG51bWJlcjtcclxuICAgIC8vIEhvdyBtYW55IHNhbXBsZXMgdG8gaWdub3JlIGJhY2t3YXJkcyB3aGVuIGNoZWNraW5nIHN0cmVhbWxpbmUgY29sbGlzaW9uIHdpdGggaXRzZWxmXHJcbiAgICBwcm90ZWN0ZWQgblN0cmVhbWxpbmVMb29rQmFjazogbnVtYmVyO1xyXG4gICAgcHJvdGVjdGVkIGRjb2xsaWRlc2VsZlNxOiBudW1iZXI7XHJcblxyXG4gICAgcHJvdGVjdGVkIGNhbmRpZGF0ZVNlZWRzTWFqb3I6IFZlY3RvcltdID0gW107XHJcbiAgICBwcm90ZWN0ZWQgY2FuZGlkYXRlU2VlZHNNaW5vcjogVmVjdG9yW10gPSBbXTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RyZWFtbGluZXNEb25lID0gdHJ1ZTtcclxuICAgIHByb3RlY3RlZCByZXNvbHZlOiAoKSA9PiB2b2lkO1xyXG4gICAgcHJvdGVjdGVkIGxhc3RTdHJlYW1saW5lTWFqb3IgPSB0cnVlO1xyXG5cclxuICAgIHB1YmxpYyBhbGxTdHJlYW1saW5lczogVmVjdG9yW11bXSA9IFtdO1xyXG4gICAgcHVibGljIHN0cmVhbWxpbmVzTWFqb3I6IFZlY3RvcltdW10gPSBbXTtcclxuICAgIHB1YmxpYyBzdHJlYW1saW5lc01pbm9yOiBWZWN0b3JbXVtdID0gW107XHJcbiAgICBwdWJsaWMgYWxsU3RyZWFtbGluZXNTaW1wbGU6IFZlY3RvcltdW10gPSBbXTsgIC8vIFJlZHVjZWQgdmVydGV4IGNvdW50XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VzIHdvcmxkLXNwYWNlIGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBpbnRlZ3JhdG9yOiBGaWVsZEludGVncmF0b3IsXHJcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgb3JpZ2luOiBWZWN0b3IsXHJcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgd29ybGREaW1lbnNpb25zOiBWZWN0b3IsXHJcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyYW1zOiBTdHJlYW1saW5lUGFyYW1zKSB7XHJcbiAgICAgICAgaWYgKHBhcmFtcy5kc3RlcCA+IHBhcmFtcy5kc2VwKSB7XHJcbiAgICAgICAgICAgIGxvZy5lcnJvcihcIlNUUkVBTUxJTkUgU0FNUExFIERJU1RBTkNFIEJJR0dFUiBUSEFOIERTRVBcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFbmZvcmNlIHRlc3QgPCBzZXBcclxuICAgICAgICBwYXJhbXMuZHRlc3QgPSBNYXRoLm1pbihwYXJhbXMuZHRlc3QsIHBhcmFtcy5kc2VwKTtcclxuXHJcbiAgICAgICAgLy8gTmVlZHMgdG8gYmUgbGVzcyB0aGFuIGNpcmNsZWpvaW5cclxuICAgICAgICB0aGlzLmRjb2xsaWRlc2VsZlNxID0gKHBhcmFtcy5kY2lyY2xlam9pbiAvIDIpICoqIDI7XHJcbiAgICAgICAgdGhpcy5uU3RyZWFtbGluZVN0ZXAgPSBNYXRoLmZsb29yKHBhcmFtcy5kY2lyY2xlam9pbiAvIHBhcmFtcy5kc3RlcCk7XHJcbiAgICAgICAgdGhpcy5uU3RyZWFtbGluZUxvb2tCYWNrID0gMiAqIHRoaXMublN0cmVhbWxpbmVTdGVwO1xyXG5cclxuICAgICAgICB0aGlzLm1ham9yR3JpZCA9IG5ldyBHcmlkU3RvcmFnZSh0aGlzLndvcmxkRGltZW5zaW9ucywgdGhpcy5vcmlnaW4sIHBhcmFtcy5kc2VwKTtcclxuICAgICAgICB0aGlzLm1pbm9yR3JpZCA9IG5ldyBHcmlkU3RvcmFnZSh0aGlzLndvcmxkRGltZW5zaW9ucywgdGhpcy5vcmlnaW4sIHBhcmFtcy5kc2VwKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRQYXJhbXNTcSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyU3RyZWFtbGluZXMoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lc1NpbXBsZSA9IFtdO1xyXG4gICAgICAgIHRoaXMuc3RyZWFtbGluZXNNYWpvciA9IFtdO1xyXG4gICAgICAgIHRoaXMuc3RyZWFtbGluZXNNaW5vciA9IFtdO1xyXG4gICAgICAgIHRoaXMuYWxsU3RyZWFtbGluZXMgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVkaXRzIHN0cmVhbWxpbmVzXHJcbiAgICAgKi9cclxuICAgIGpvaW5EYW5nbGluZ1N0cmVhbWxpbmVzKCk6IHZvaWQge1xyXG4gICAgICAgIC8vIFRPRE8gZG8gaW4gdXBkYXRlIG1ldGhvZFxyXG4gICAgICAgIGZvciAoY29uc3QgbWFqb3Igb2YgW3RydWUsIGZhbHNlXSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN0cmVhbWxpbmUgb2YgdGhpcy5zdHJlYW1saW5lcyhtYWpvcikpIHtcclxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBjaXJjbGVzXHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtbGluZVswXS5lcXVhbHMoc3RyZWFtbGluZVtzdHJlYW1saW5lLmxlbmd0aCAtIDFdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1N0YXJ0ID0gdGhpcy5nZXRCZXN0TmV4dFBvaW50KHN0cmVhbWxpbmVbMF0sIHN0cmVhbWxpbmVbNF0sIHN0cmVhbWxpbmUpXHJcbiAgICAgICAgICAgICAgICBpZiAobmV3U3RhcnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5wb2ludHNCZXR3ZWVuKHN0cmVhbWxpbmVbMF0sIG5ld1N0YXJ0LCB0aGlzLnBhcmFtcy5kc3RlcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtbGluZS51bnNoaWZ0KHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyaWQobWFqb3IpLmFkZFNhbXBsZShwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RW5kID0gdGhpcy5nZXRCZXN0TmV4dFBvaW50KHN0cmVhbWxpbmVbc3RyZWFtbGluZS5sZW5ndGggLSAxXSwgc3RyZWFtbGluZVtzdHJlYW1saW5lLmxlbmd0aCAtIDRdLCBzdHJlYW1saW5lKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdFbmQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5wb2ludHNCZXR3ZWVuKHN0cmVhbWxpbmVbc3RyZWFtbGluZS5sZW5ndGggLSAxXSwgbmV3RW5kLCB0aGlzLnBhcmFtcy5kc3RlcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtbGluZS5wdXNoKHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyaWQobWFqb3IpLmFkZFNhbXBsZShwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlc2V0IHNpbXBsaWZpZWQgc3RyZWFtbGluZXNcclxuICAgICAgICB0aGlzLmFsbFN0cmVhbWxpbmVzU2ltcGxlID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHRoaXMuYWxsU3RyZWFtbGluZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lc1NpbXBsZS5wdXNoKHRoaXMuc2ltcGxpZnlTdHJlYW1saW5lKHMpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFycmF5IG9mIHBvaW50cyBmcm9tIHYxIHRvIHYyIHN1Y2ggdGhhdCB0aGV5IGFyZSBzZXBhcmF0ZWQgYnkgYXQgbW9zdCBkc2VwXHJcbiAgICAgKiBub3QgaW5jbHVkaW5nIHYxXHJcbiAgICAgKi9cclxuICAgIHBvaW50c0JldHdlZW4odjE6IFZlY3RvciwgdjI6IFZlY3RvciwgZHN0ZXA6IG51bWJlcik6IFZlY3RvcltdIHtcclxuICAgICAgICBjb25zdCBkID0gdjEuZGlzdGFuY2VUbyh2Mik7XHJcbiAgICAgICAgY29uc3QgblBvaW50cyA9IE1hdGguZmxvb3IoZCAvIGRzdGVwKTtcclxuICAgICAgICBpZiAoblBvaW50cyA9PT0gMCkgcmV0dXJuIFtdO1xyXG5cclxuICAgICAgICBjb25zdCBzdGVwVmVjdG9yID0gdjIuY2xvbmUoKS5zdWIodjEpO1xyXG5cclxuICAgICAgICBjb25zdCBvdXQgPSBbXTtcclxuICAgICAgICBsZXQgaSA9IDE7XHJcbiAgICAgICAgbGV0IG5leHQgPSB2MS5jbG9uZSgpLmFkZChzdGVwVmVjdG9yLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoaSAvIG5Qb2ludHMpKTtcclxuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IG5Qb2ludHM7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pbnRlZ3JhdG9yLmludGVncmF0ZShuZXh0LCB0cnVlKS5sZW5ndGhTcSgpID4gMC4wMDEpIHsgIC8vIFRlc3QgZm9yIGRlZ2VuZXJhdGUgcG9pbnRcclxuICAgICAgICAgICAgICAgIG91dC5wdXNoKG5leHQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXh0ID0gdjEuY2xvbmUoKS5hZGQoc3RlcFZlY3Rvci5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKGkgLyBuUG9pbnRzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBuZXh0IGJlc3QgcG9pbnQgdG8gam9pbiBzdHJlYW1saW5lXHJcbiAgICAgKiByZXR1cm5zIG51bGwgaWYgdGhlcmUgYXJlIG5vIGdvb2QgY2FuZGlkYXRlc1xyXG4gICAgICovXHJcbiAgICBnZXRCZXN0TmV4dFBvaW50KHBvaW50OiBWZWN0b3IsIHByZXZpb3VzUG9pbnQ6IFZlY3Rvciwgc3RyZWFtbGluZTogVmVjdG9yW10pOiBWZWN0b3Ige1xyXG4gICAgICAgIGNvbnN0IG5lYXJieVBvaW50cyA9IHRoaXMubWFqb3JHcmlkLmdldE5lYXJieVBvaW50cyhwb2ludCwgdGhpcy5wYXJhbXMuZGxvb2thaGVhZCk7XHJcbiAgICAgICAgbmVhcmJ5UG9pbnRzLnB1c2goLi4udGhpcy5taW5vckdyaWQuZ2V0TmVhcmJ5UG9pbnRzKHBvaW50LCB0aGlzLnBhcmFtcy5kbG9va2FoZWFkKSk7XHJcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gcG9pbnQuY2xvbmUoKS5zdWIocHJldmlvdXNQb2ludCk7XHJcblxyXG4gICAgICAgIGxldCBjbG9zZXN0U2FtcGxlID0gbnVsbDtcclxuICAgICAgICBsZXQgY2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XHJcblxyXG4gICAgICAgIGZvciAoY29uc3Qgc2FtcGxlIG9mIG5lYXJieVBvaW50cykge1xyXG4gICAgICAgICAgICBpZiAoIXNhbXBsZS5lcXVhbHMocG9pbnQpICYmICFzYW1wbGUuZXF1YWxzKHByZXZpb3VzUG9pbnQpKSB7Ly8gJiYgIXN0cmVhbWxpbmUuaW5jbHVkZXMoc2FtcGxlKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZmVyZW5jZVZlY3RvciA9IHNhbXBsZS5jbG9uZSgpLnN1Yihwb2ludCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlmZmVyZW5jZVZlY3Rvci5kb3QoZGlyZWN0aW9uKSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBCYWNrd2FyZHNcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gQWN1dGUgYW5nbGUgYmV0d2VlbiB2ZWN0b3JzIChhZ25vc3RpYyBvZiBDVywgQUNXKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2VUb1NhbXBsZSA9IHBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKHNhbXBsZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2VUb1NhbXBsZSA8IDIgKiB0aGlzLnBhcmFtc1NxLmRzdGVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdFNhbXBsZSA9IHNhbXBsZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGFuZ2xlQmV0d2VlbiA9IE1hdGguYWJzKFZlY3Rvci5hbmdsZUJldHdlZW4oZGlyZWN0aW9uLCBkaWZmZXJlbmNlVmVjdG9yKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRmlsdGVyIGJ5IGFuZ2xlXHJcbiAgICAgICAgICAgICAgICBpZiAoYW5nbGVCZXR3ZWVuIDwgdGhpcy5wYXJhbXMuam9pbmFuZ2xlICYmIGRpc3RhbmNlVG9TYW1wbGUgPCBjbG9zZXN0RGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0RGlzdGFuY2UgPSBkaXN0YW5jZVRvU2FtcGxlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RTYW1wbGUgPSBzYW1wbGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRPRE8gaXMgcmVpbXBsZW1lbnQgc2ltcGxpZnktanMgdG8gcHJlc2VydmUgaW50ZXJzZWN0aW9uIHBvaW50c1xyXG4gICAgICAgIC8vICAtIHRoaXMgaXMgdGhlIHByaW1hcnkgcmVhc29uIHBvbHlnb25zIGFyZW4ndCBmb3VuZFxyXG4gICAgICAgIC8vIElmIHRyeWluZyB0byBmaW5kIGludGVyc2VjdGlvbnMgaW4gdGhlIHNpbXBsaWZpZWQgZ3JhcGhcclxuICAgICAgICAvLyBwcmV2ZW50IGVuZHMgZ2V0dGluZyBwdWxsZWQgYXdheSBmcm9tIHNpbXBsaWZpZWQgbGluZXNcclxuICAgICAgICBpZiAoY2xvc2VzdFNhbXBsZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjbG9zZXN0U2FtcGxlID0gY2xvc2VzdFNhbXBsZS5jbG9uZSgpLmFkZChkaXJlY3Rpb24uc2V0TGVuZ3RoKHRoaXMucGFyYW1zLnNpbXBsaWZ5VG9sZXJhbmNlICogNCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3RTYW1wbGU7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXNzdW1lcyBzIGhhcyBhbHJlYWR5IGdlbmVyYXRlZFxyXG4gICAgICovXHJcbiAgICBhZGRFeGlzdGluZ1N0cmVhbWxpbmVzKHM6IFN0cmVhbWxpbmVHZW5lcmF0b3IpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm1ham9yR3JpZC5hZGRBbGwocy5tYWpvckdyaWQpO1xyXG4gICAgICAgIHRoaXMubWlub3JHcmlkLmFkZEFsbChzLm1pbm9yR3JpZCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0R3JpZChzOiBTdHJlYW1saW5lR2VuZXJhdG9yKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5tYWpvckdyaWQgPSBzLm1ham9yR3JpZDtcclxuICAgICAgICB0aGlzLm1pbm9yR3JpZCA9IHMubWlub3JHcmlkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJucyB0cnVlIGlmIHN0YXRlIHVwZGF0ZXNcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmICghdGhpcy5zdHJlYW1saW5lc0RvbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5sYXN0U3RyZWFtbGluZU1ham9yID0gIXRoaXMubGFzdFN0cmVhbWxpbmVNYWpvcjtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNyZWF0ZVN0cmVhbWxpbmUodGhpcy5sYXN0U3RyZWFtbGluZU1ham9yKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1saW5lc0RvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGwgYXQgb25jZSAtIHdpbGwgZnJlZXplIGlmIGRzZXAgc21hbGxcclxuICAgICAqL1xyXG4gICAgYXN5bmMgY3JlYXRlQWxsU3RyZWFtbGluZXMoYW5pbWF0ZT1mYWxzZSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPihyZXNvbHZlID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZVxyXG4gICAgICAgICAgICB0aGlzLnN0cmVhbWxpbmVzRG9uZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFhbmltYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWFqb3IgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuY3JlYXRlU3RyZWFtbGluZShtYWpvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYWpvciA9ICFtYWpvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLnRoZW4oKCkgPT4gdGhpcy5qb2luRGFuZ2xpbmdTdHJlYW1saW5lcygpKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc2ltcGxpZnlTdHJlYW1saW5lKHN0cmVhbWxpbmU6IFZlY3RvcltdKTogVmVjdG9yW10ge1xyXG4gICAgICAgIGNvbnN0IHNpbXBsaWZpZWQgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIHNpbXBsaWZ5KHN0cmVhbWxpbmUsIHRoaXMucGFyYW1zLnNpbXBsaWZ5VG9sZXJhbmNlKSkge1xyXG4gICAgICAgICAgICBzaW1wbGlmaWVkLnB1c2gobmV3IFZlY3Rvcihwb2ludC54LCBwb2ludC55KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzaW1wbGlmaWVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmluZHMgc2VlZCBhbmQgY3JlYXRlcyBhIHN0cmVhbWxpbmUgZnJvbSB0aGF0IHBvaW50XHJcbiAgICAgKiBQdXNoZXMgbmV3IGNhbmRpZGF0ZSBzZWVkcyB0byBxdWV1ZVxyXG4gICAgICogQHJldHVybiB7VmVjdG9yW119IHJldHVybnMgZmFsc2UgaWYgc2VlZCBpc24ndCBmb3VuZCB3aXRoaW4gcGFyYW1zLnNlZWRUcmllc1xyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlU3RyZWFtbGluZShtYWpvcjogYm9vbGVhbik6IGJvb2xlYW4ge1xyXG4gICAgICAgIGNvbnN0IHNlZWQgPSB0aGlzLmdldFNlZWQobWFqb3IpO1xyXG4gICAgICAgIGlmIChzZWVkID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3RyZWFtbGluZSA9IHRoaXMuaW50ZWdyYXRlU3RyZWFtbGluZShzZWVkLCBtYWpvcik7XHJcbiAgICAgICAgaWYgKHRoaXMudmFsaWRTdHJlYW1saW5lKHN0cmVhbWxpbmUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JpZChtYWpvcikuYWRkUG9seWxpbmUoc3RyZWFtbGluZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtbGluZXMobWFqb3IpLnB1c2goc3RyZWFtbGluZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWxsU3RyZWFtbGluZXMucHVzaChzdHJlYW1saW5lKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuYWxsU3RyZWFtbGluZXNTaW1wbGUucHVzaCh0aGlzLnNpbXBsaWZ5U3RyZWFtbGluZShzdHJlYW1saW5lKSk7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgY2FuZGlkYXRlIHNlZWRzXHJcbiAgICAgICAgICAgIGlmICghc3RyZWFtbGluZVswXS5lcXVhbHMoc3RyZWFtbGluZVtzdHJlYW1saW5lLmxlbmd0aCAtIDFdKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW5kaWRhdGVTZWVkcyghbWFqb3IpLnB1c2goc3RyZWFtbGluZVswXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmRpZGF0ZVNlZWRzKCFtYWpvcikucHVzaChzdHJlYW1saW5lW3N0cmVhbWxpbmUubGVuZ3RoIC0gMV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgdmFsaWRTdHJlYW1saW5lKHM6IFZlY3RvcltdKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHMubGVuZ3RoID4gNTtcclxuICAgIH0gXHJcblxyXG4gICAgcHJvdGVjdGVkIHNldFBhcmFtc1NxKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucGFyYW1zU3EgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBhcmFtcyk7XHJcbiAgICAgICAgZm9yIChjb25zdCBwIGluIHRoaXMucGFyYW1zU3EpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnBhcmFtc1NxW3BdID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtc1NxW3BdICo9IHRoaXMucGFyYW1zU3FbcF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHNhbXBsZVBvaW50KCk6IFZlY3RvciB7XHJcbiAgICAgICAgLy8gVE9ETyBiZXR0ZXIgc2VlZGluZyBzY2hlbWVcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihcclxuICAgICAgICAgICAgTWF0aC5yYW5kb20oKSAqIHRoaXMud29ybGREaW1lbnNpb25zLngsXHJcbiAgICAgICAgICAgIE1hdGgucmFuZG9tKCkgKiB0aGlzLndvcmxkRGltZW5zaW9ucy55KVxyXG4gICAgICAgICAgICAuYWRkKHRoaXMub3JpZ2luKTtcclxuICAgIH1cclxuIFxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmllcyB0aGlzLmNhbmRpZGF0ZVNlZWRzIGZpcnN0LCB0aGVuIHNhbXBsZXMgdXNpbmcgdGhpcy5zYW1wbGVQb2ludFxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgZ2V0U2VlZChtYWpvcjogYm9vbGVhbik6IFZlY3RvciB7XHJcbiAgICAgICAgLy8gQ2FuZGlkYXRlIHNlZWRzIGZpcnN0XHJcbiAgICAgICAgaWYgKHRoaXMuU0VFRF9BVF9FTkRQT0lOVFMgJiYgdGhpcy5jYW5kaWRhdGVTZWVkcyhtYWpvcikubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5jYW5kaWRhdGVTZWVkcyhtYWpvcikubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VlZCA9IHRoaXMuY2FuZGlkYXRlU2VlZHMobWFqb3IpLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZFNhbXBsZShtYWpvciwgc2VlZCwgdGhpcy5wYXJhbXNTcS5kc2VwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgc2VlZCA9IHRoaXMuc2FtcGxlUG9pbnQoKTtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKCF0aGlzLmlzVmFsaWRTYW1wbGUobWFqb3IsIHNlZWQsIHRoaXMucGFyYW1zU3EuZHNlcCkpIHtcclxuICAgICAgICAgICAgaWYgKGkgPj0gdGhpcy5wYXJhbXMuc2VlZFRyaWVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWVkID0gdGhpcy5zYW1wbGVQb2ludCgpO1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc2VlZDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgaXNWYWxpZFNhbXBsZShtYWpvcjogYm9vbGVhbiwgcG9pbnQ6IFZlY3RvciwgZFNxOiBudW1iZXIsIGJvdGhHcmlkcz1mYWxzZSk6IGJvb2xlYW4ge1xyXG4gICAgICAgIC8vIGRTcSA9IGRTcSAqIHBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKFZlY3Rvci56ZXJvVmVjdG9yKCkpO1xyXG4gICAgICAgIGxldCBncmlkVmFsaWQgPSB0aGlzLmdyaWQobWFqb3IpLmlzVmFsaWRTYW1wbGUocG9pbnQsIGRTcSk7XHJcbiAgICAgICAgaWYgKGJvdGhHcmlkcykge1xyXG4gICAgICAgICAgICBncmlkVmFsaWQgPSBncmlkVmFsaWQgJiYgdGhpcy5ncmlkKCFtYWpvcikuaXNWYWxpZFNhbXBsZShwb2ludCwgZFNxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZWdyYXRvci5vbkxhbmQocG9pbnQpICYmIGdyaWRWYWxpZDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY2FuZGlkYXRlU2VlZHMobWFqb3I6IGJvb2xlYW4pOiBWZWN0b3JbXSB7XHJcbiAgICAgICAgcmV0dXJuIG1ham9yID8gdGhpcy5jYW5kaWRhdGVTZWVkc01ham9yIDogdGhpcy5jYW5kaWRhdGVTZWVkc01pbm9yO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdHJlYW1saW5lcyhtYWpvcjogYm9vbGVhbik6IFZlY3RvcltdW10ge1xyXG4gICAgICAgIHJldHVybiBtYWpvciA/IHRoaXMuc3RyZWFtbGluZXNNYWpvciA6IHRoaXMuc3RyZWFtbGluZXNNaW5vcjtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgZ3JpZChtYWpvcjogYm9vbGVhbik6IEdyaWRTdG9yYWdlIHtcclxuICAgICAgICByZXR1cm4gbWFqb3IgPyB0aGlzLm1ham9yR3JpZCA6IHRoaXMubWlub3JHcmlkO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBwb2ludEluQm91bmRzKHY6IFZlY3Rvcik6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiAodi54ID49IHRoaXMub3JpZ2luLnhcclxuICAgICAgICAgICAgJiYgdi55ID49IHRoaXMub3JpZ2luLnlcclxuICAgICAgICAgICAgJiYgdi54IDwgdGhpcy53b3JsZERpbWVuc2lvbnMueCArIHRoaXMub3JpZ2luLnhcclxuICAgICAgICAgICAgJiYgdi55IDwgdGhpcy53b3JsZERpbWVuc2lvbnMueSArIHRoaXMub3JpZ2luLnlcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGlkbid0IGVuZCB1cCB1c2luZyAtIGJpdCBleHBlbnNpdmUsIHVzZWQgc3RyZWFtbGluZVR1cm5lZCBpbnN0ZWFkXHJcbiAgICAgKiBTdG9wcyBzcGlyYWxzIGZyb20gZm9ybWluZ1xyXG4gICAgICogdXNlcyAwLjUgZGNpcmNsZWpvaW4gc28gdGhhdCBjaXJjbGVzIGFyZSBzdGlsbCBqb2luZWQgdXBcclxuICAgICAqIHRlc3RTYW1wbGUgaXMgY2FuZGlkYXRlIHRvIHB1c2hlZCBvbiBlbmQgb2Ygc3RyZWFtbGluZUZvcndhcmRzXHJcbiAgICAgKiByZXR1cm5zIHRydWUgaWYgc3RyZWFtbGluZSBjb2xsaWRlcyB3aXRoIGl0c2VsZlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgZG9lc1N0cmVhbWxpbmVDb2xsaWRlU2VsZih0ZXN0U2FtcGxlOiBWZWN0b3IsIHN0cmVhbWxpbmVGb3J3YXJkczogVmVjdG9yW10sIHN0cmVhbWxpbmVCYWNrd2FyZHM6IFZlY3RvcltdKTogYm9vbGVhbiB7XHJcbiAgICAgICAgLy8gU3RyZWFtbGluZSBsb25nIGVub3VnaFxyXG4gICAgICAgIGlmIChzdHJlYW1saW5lRm9yd2FyZHMubGVuZ3RoID4gdGhpcy5uU3RyZWFtbGluZUxvb2tCYWNrKSB7XHJcbiAgICAgICAgICAgIC8vIEZvcndhcmRzIGNoZWNrXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyZWFtbGluZUZvcndhcmRzLmxlbmd0aCAtIHRoaXMublN0cmVhbWxpbmVMb29rQmFjazsgaSArPSB0aGlzLm5TdHJlYW1saW5lU3RlcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRlc3RTYW1wbGUuZGlzdGFuY2VUb1NxdWFyZWQoc3RyZWFtbGluZUZvcndhcmRzW2ldKSA8IHRoaXMuZGNvbGxpZGVzZWxmU3EpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQmFja3dhcmRzIGNoZWNrXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyZWFtbGluZUJhY2t3YXJkcy5sZW5ndGg7IGkgKz0gdGhpcy5uU3RyZWFtbGluZVN0ZXApIHtcclxuICAgICAgICAgICAgICAgIGlmICh0ZXN0U2FtcGxlLmRpc3RhbmNlVG9TcXVhcmVkKHN0cmVhbWxpbmVCYWNrd2FyZHNbaV0pIDwgdGhpcy5kY29sbGlkZXNlbGZTcSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyB3aGV0aGVyIHN0cmVhbWxpbmUgaGFzIHR1cm5lZCB0aHJvdWdoIGdyZWF0ZXIgdGhhbiAxODAgZGVncmVlc1xyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgc3RyZWFtbGluZVR1cm5lZChzZWVkOiBWZWN0b3IsIG9yaWdpbmFsRGlyOiBWZWN0b3IsIHBvaW50OiBWZWN0b3IsIGRpcmVjdGlvbjogVmVjdG9yKTogYm9vbGVhbiB7XHJcbiAgICAgICAgaWYgKG9yaWdpbmFsRGlyLmRvdChkaXJlY3Rpb24pIDwgMCkge1xyXG4gICAgICAgICAgICAvLyBUT0RPIG9wdGltaXNlXHJcbiAgICAgICAgICAgIGNvbnN0IHBlcnBlbmRpY3VsYXJWZWN0b3IgPSBuZXcgVmVjdG9yKG9yaWdpbmFsRGlyLnksIC1vcmlnaW5hbERpci54KTtcclxuICAgICAgICAgICAgY29uc3QgaXNMZWZ0ID0gcG9pbnQuY2xvbmUoKS5zdWIoc2VlZCkuZG90KHBlcnBlbmRpY3VsYXJWZWN0b3IpIDwgMDtcclxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uVXAgPSBkaXJlY3Rpb24uZG90KHBlcnBlbmRpY3VsYXJWZWN0b3IpID4gMDtcclxuICAgICAgICAgICAgcmV0dXJuIGlzTGVmdCA9PT0gZGlyZWN0aW9uVXA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAvLyBUT0RPIHRoaXMgZG9lc24ndCB3b3JrIHdlbGwgLSBjb25zaWRlciBzb21ldGhpbmcgZGlzYWxsb3dpbmcgb25lIGRpcmVjdGlvbiAoRi9CKSB0byB0dXJuIG1vcmUgdGhhbiAxODAgZGVnXHJcbiAgICAgKiBPbmUgc3RlcCBvZiB0aGUgc3RyZWFtbGluZSBpbnRlZ3JhdGlvbiBwcm9jZXNzXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdHJlYW1saW5lSW50ZWdyYXRpb25TdGVwKHBhcmFtczogU3RyZWFtbGluZUludGVncmF0aW9uLCBtYWpvcjogYm9vbGVhbiwgY29sbGlkZUJvdGg6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICBpZiAocGFyYW1zLnZhbGlkKSB7XHJcbiAgICAgICAgICAgIHBhcmFtcy5zdHJlYW1saW5lLnB1c2gocGFyYW1zLnByZXZpb3VzUG9pbnQpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXh0RGlyZWN0aW9uID0gdGhpcy5pbnRlZ3JhdG9yLmludGVncmF0ZShwYXJhbXMucHJldmlvdXNQb2ludCwgbWFqb3IpO1xyXG5cclxuICAgICAgICAgICAgLy8gU3RvcCBhdCBkZWdlbmVyYXRlIHBvaW50XHJcbiAgICAgICAgICAgIGlmIChuZXh0RGlyZWN0aW9uLmxlbmd0aFNxKCkgPCAwLjAxKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMudmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHRyYXZlbCBpbiB0aGUgc2FtZSBkaXJlY3Rpb25cclxuICAgICAgICAgICAgaWYgKG5leHREaXJlY3Rpb24uZG90KHBhcmFtcy5wcmV2aW91c0RpcmVjdGlvbikgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0RGlyZWN0aW9uLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBuZXh0UG9pbnQgPSBwYXJhbXMucHJldmlvdXNQb2ludC5jbG9uZSgpLmFkZChuZXh0RGlyZWN0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFZpc3VhbGlzZSBzdG9wcGluZyBwb2ludHNcclxuICAgICAgICAgICAgLy8gaWYgKHRoaXMuc3RyZWFtbGluZVR1cm5lZChwYXJhbXMuc2VlZCwgcGFyYW1zLm9yaWdpbmFsRGlyLCBuZXh0UG9pbnQsIG5leHREaXJlY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIC8vICAgICBwYXJhbXMudmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgLy8gICAgIHBhcmFtcy5zdHJlYW1saW5lLnB1c2goVmVjdG9yLnplcm9WZWN0b3IoKSk7XHJcbiAgICAgICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBvaW50SW5Cb3VuZHMobmV4dFBvaW50KVxyXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5pc1ZhbGlkU2FtcGxlKG1ham9yLCBuZXh0UG9pbnQsIHRoaXMucGFyYW1zU3EuZHRlc3QsIGNvbGxpZGVCb3RoKVxyXG4gICAgICAgICAgICAgICAgJiYgIXRoaXMuc3RyZWFtbGluZVR1cm5lZChwYXJhbXMuc2VlZCwgcGFyYW1zLm9yaWdpbmFsRGlyLCBuZXh0UG9pbnQsIG5leHREaXJlY3Rpb24pKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMucHJldmlvdXNQb2ludCA9IG5leHRQb2ludDtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5wcmV2aW91c0RpcmVjdGlvbiA9IG5leHREaXJlY3Rpb247XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPbmUgbW9yZSBzdGVwXHJcbiAgICAgICAgICAgICAgICBwYXJhbXMuc3RyZWFtbGluZS5wdXNoKG5leHRQb2ludCk7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMudmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ5IHNpbXVsdGFuZW91c2x5IGludGVncmF0aW5nIGluIGJvdGggZGlyZWN0aW9ucyB3ZSByZWR1Y2UgdGhlIGltcGFjdCBvZiBjaXJjbGVzIG5vdCBqb2luaW5nXHJcbiAgICAgKiB1cCBhcyB0aGUgZXJyb3IgbWF0Y2hlcyBhdCB0aGUgam9pblxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgaW50ZWdyYXRlU3RyZWFtbGluZShzZWVkOiBWZWN0b3IsIG1ham9yOiBib29sZWFuKTogVmVjdG9yW10ge1xyXG4gICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgbGV0IHBvaW50c0VzY2FwZWQgPSBmYWxzZTsgIC8vIFRydWUgb25jZSB0d28gaW50ZWdyYXRpb24gZnJvbnRzIGhhdmUgbW92ZWQgZGxvb2thaGVhZCBhd2F5XHJcblxyXG4gICAgICAgIC8vIFdoZXRoZXIgb3Igbm90IHRvIHRlc3QgdmFsaWRpdHkgdXNpbmcgYm90aCBncmlkIHN0b3JhZ2VzXHJcbiAgICAgICAgLy8gKENvbGxpZGUgd2l0aCBib3RoIG1ham9yIGFuZCBtaW5vcilcclxuICAgICAgICBjb25zdCBjb2xsaWRlQm90aCA9IE1hdGgucmFuZG9tKCkgPCB0aGlzLnBhcmFtcy5jb2xsaWRlRWFybHk7XHJcblxyXG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmludGVncmF0b3IuaW50ZWdyYXRlKHNlZWQsIG1ham9yKTtcclxuXHJcbiAgICAgICAgY29uc3QgZm9yd2FyZFBhcmFtczogU3RyZWFtbGluZUludGVncmF0aW9uID0ge1xyXG4gICAgICAgICAgICBzZWVkOiBzZWVkLFxyXG4gICAgICAgICAgICBvcmlnaW5hbERpcjogZCxcclxuICAgICAgICAgICAgc3RyZWFtbGluZTogW3NlZWRdLFxyXG4gICAgICAgICAgICBwcmV2aW91c0RpcmVjdGlvbjogZCxcclxuICAgICAgICAgICAgcHJldmlvdXNQb2ludDogc2VlZC5jbG9uZSgpLmFkZChkKSxcclxuICAgICAgICAgICAgdmFsaWQ6IHRydWUsXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3J3YXJkUGFyYW1zLnZhbGlkID0gdGhpcy5wb2ludEluQm91bmRzKGZvcndhcmRQYXJhbXMucHJldmlvdXNQb2ludCk7XHJcblxyXG4gICAgICAgIGNvbnN0IG5lZ0QgPSBkLmNsb25lKCkubmVnYXRlKCk7XHJcbiAgICAgICAgY29uc3QgYmFja3dhcmRQYXJhbXM6IFN0cmVhbWxpbmVJbnRlZ3JhdGlvbiA9IHtcclxuICAgICAgICAgICAgc2VlZDogc2VlZCxcclxuICAgICAgICAgICAgb3JpZ2luYWxEaXI6IG5lZ0QsXHJcbiAgICAgICAgICAgIHN0cmVhbWxpbmU6IFtdLFxyXG4gICAgICAgICAgICBwcmV2aW91c0RpcmVjdGlvbjogbmVnRCxcclxuICAgICAgICAgICAgcHJldmlvdXNQb2ludDogc2VlZC5jbG9uZSgpLmFkZChuZWdEKSxcclxuICAgICAgICAgICAgdmFsaWQ6IHRydWUsXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBiYWNrd2FyZFBhcmFtcy52YWxpZCA9IHRoaXMucG9pbnRJbkJvdW5kcyhiYWNrd2FyZFBhcmFtcy5wcmV2aW91c1BvaW50KTtcclxuXHJcbiAgICAgICAgd2hpbGUgKGNvdW50IDwgdGhpcy5wYXJhbXMucGF0aEl0ZXJhdGlvbnMgJiYgKGZvcndhcmRQYXJhbXMudmFsaWQgfHwgYmFja3dhcmRQYXJhbXMudmFsaWQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtbGluZUludGVncmF0aW9uU3RlcChmb3J3YXJkUGFyYW1zLCBtYWpvciwgY29sbGlkZUJvdGgpO1xyXG4gICAgICAgICAgICB0aGlzLnN0cmVhbWxpbmVJbnRlZ3JhdGlvblN0ZXAoYmFja3dhcmRQYXJhbXMsIG1ham9yLCBjb2xsaWRlQm90aCk7XHJcblxyXG4gICAgICAgICAgICAvLyBKb2luIHVwIGNpcmNsZXNcclxuICAgICAgICAgICAgY29uc3Qgc3FEaXN0YW5jZUJldHdlZW5Qb2ludHMgPSBmb3J3YXJkUGFyYW1zLnByZXZpb3VzUG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoYmFja3dhcmRQYXJhbXMucHJldmlvdXNQb2ludCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXBvaW50c0VzY2FwZWQgJiYgc3FEaXN0YW5jZUJldHdlZW5Qb2ludHMgPiB0aGlzLnBhcmFtc1NxLmRjaXJjbGVqb2luKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludHNFc2NhcGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHBvaW50c0VzY2FwZWQgJiYgc3FEaXN0YW5jZUJldHdlZW5Qb2ludHMgPD0gdGhpcy5wYXJhbXNTcS5kY2lyY2xlam9pbikge1xyXG4gICAgICAgICAgICAgICAgZm9yd2FyZFBhcmFtcy5zdHJlYW1saW5lLnB1c2goZm9yd2FyZFBhcmFtcy5wcmV2aW91c1BvaW50KTtcclxuICAgICAgICAgICAgICAgIGZvcndhcmRQYXJhbXMuc3RyZWFtbGluZS5wdXNoKGJhY2t3YXJkUGFyYW1zLnByZXZpb3VzUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgYmFja3dhcmRQYXJhbXMuc3RyZWFtbGluZS5wdXNoKGJhY2t3YXJkUGFyYW1zLnByZXZpb3VzUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBiYWNrd2FyZFBhcmFtcy5zdHJlYW1saW5lLnJldmVyc2UoKS5wdXNoKC4uLmZvcndhcmRQYXJhbXMuc3RyZWFtbGluZSk7XHJcbiAgICAgICAgcmV0dXJuIGJhY2t3YXJkUGFyYW1zLnN0cmVhbWxpbmU7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVuc29yIHtcclxuICAgIHByaXZhdGUgb2xkVGhldGE6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIF90aGV0YTogbnVtYmVyO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgcjogbnVtYmVyLCBwcml2YXRlIG1hdHJpeDogbnVtYmVyW10pIHtcclxuICAgICAgICAvLyBSZXByZXNlbnQgdGhlIG1hdHJpeCBhcyBhIDIgZWxlbWVudCBsaXN0XHJcbiAgICAgICAgLy8gWyAwLCAxXHJcbiAgICAgICAgLy8gICAxLCAtMCBdXHJcbiAgICAgICAgdGhpcy5vbGRUaGV0YSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3RoZXRhID0gdGhpcy5jYWxjdWxhdGVUaGV0YSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBmcm9tQW5nbGUoYW5nbGU6IG51bWJlcik6IFRlbnNvciB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3IoMSwgW01hdGguY29zKGFuZ2xlICogNCksIE1hdGguc2luKGFuZ2xlICogNCldKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZnJvbVZlY3Rvcih2ZWN0b3I6IFZlY3Rvcik6IFRlbnNvciB7XHJcbiAgICAgICAgY29uc3QgdDEgPSB2ZWN0b3IueCAqKiAyIC0gdmVjdG9yLnkgKiogMjtcclxuICAgICAgICBjb25zdCB0MiA9IDIgKiB2ZWN0b3IueCAqIHZlY3Rvci55O1xyXG4gICAgICAgIGNvbnN0IHQzID0gdDEgKiogMiAtIHQyICoqIDI7XHJcbiAgICAgICAgY29uc3QgdDQgPSAyICogdDEgKiB0MjtcclxuICAgICAgICByZXR1cm4gbmV3IFRlbnNvcigxLCBbdDMsIHQ0XSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGdldCB6ZXJvKCk6IFRlbnNvciB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3IoMCwgWzAsIDBdKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgdGhldGEoKTogbnVtYmVyIHtcclxuICAgICAgICBpZiAodGhpcy5vbGRUaGV0YSkge1xyXG4gICAgICAgICAgICB0aGlzLl90aGV0YSA9IHRoaXMuY2FsY3VsYXRlVGhldGEoKTtcclxuICAgICAgICAgICAgdGhpcy5vbGRUaGV0YSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RoZXRhO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZCh0ZW5zb3I6IFRlbnNvciwgc21vb3RoOiBib29sZWFuKTogVGVuc29yIHtcclxuICAgICAgICB0aGlzLm1hdHJpeCA9IHRoaXMubWF0cml4Lm1hcCgodiwgaSkgPT4gdiAqIHRoaXMuciArIHRlbnNvci5tYXRyaXhbaV0gKiB0ZW5zb3Iucik7XHJcblxyXG4gICAgICAgIGlmIChzbW9vdGgpIHtcclxuICAgICAgICAgICAgdGhpcy5yID0gTWF0aC5oeXBvdCguLi50aGlzLm1hdHJpeCk7XHJcbiAgICAgICAgICAgIHRoaXMubWF0cml4ID0gdGhpcy5tYXRyaXgubWFwKHYgPT4gdiAvIHRoaXMucik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yID0gMjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMub2xkVGhldGEgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHNjYWxlKHM6IG51bWJlcik6IFRlbnNvciB7XHJcbiAgICAgICAgdGhpcy5yICo9IHM7XHJcbiAgICAgICAgdGhpcy5vbGRUaGV0YSA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmFkaWFuc1xyXG4gICAgcm90YXRlKHRoZXRhOiBudW1iZXIpOiBUZW5zb3Ige1xyXG4gICAgICAgIGlmICh0aGV0YSA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5ld1RoZXRhID0gdGhpcy50aGV0YSArIHRoZXRhO1xyXG4gICAgICAgIGlmIChuZXdUaGV0YSA8IE1hdGguUEkpIHtcclxuICAgICAgICAgICAgbmV3VGhldGEgKz0gTWF0aC5QSTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChuZXdUaGV0YSA+PSBNYXRoLlBJKSB7XHJcbiAgICAgICAgICAgIG5ld1RoZXRhIC09IE1hdGguUEk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm1hdHJpeFswXSA9IE1hdGguY29zKDIgKiBuZXdUaGV0YSkgKiB0aGlzLnI7XHJcbiAgICAgICAgdGhpcy5tYXRyaXhbMV0gPSBNYXRoLnNpbigyICogbmV3VGhldGEpICogdGhpcy5yO1xyXG4gICAgICAgIHRoaXMuX3RoZXRhID0gbmV3VGhldGE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0TWFqb3IoKTogVmVjdG9yIHtcclxuICAgICAgICAvLyBEZWdlbmVyYXRlIGNhc2VcclxuICAgICAgICBpZiAodGhpcy5yID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBWZWN0b3IuemVyb1ZlY3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihNYXRoLmNvcyh0aGlzLnRoZXRhKSwgTWF0aC5zaW4odGhpcy50aGV0YSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldE1pbm9yKCk6IFZlY3RvciB7XHJcbiAgICAgICAgLy8gRGVnZW5lcmF0ZSBjYXNlXHJcbiAgICAgICAgaWYgKHRoaXMuciA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gVmVjdG9yLnplcm9WZWN0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYW5nbGUgPSB0aGlzLnRoZXRhICsgTWF0aC5QSSAvIDI7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoTWF0aC5jb3MoYW5nbGUpLCBNYXRoLnNpbihhbmdsZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY2FsY3VsYXRlVGhldGEoKTogbnVtYmVyIHtcclxuICAgICAgICBpZiAodGhpcy5yID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLm1hdHJpeFsxXSAvIHRoaXMuciwgdGhpcy5tYXRyaXhbMF0gLyB0aGlzLnIpIC8gMjtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xyXG4vLyBpbXBvcnQgKiBhcyBub2lzZSBmcm9tICdub2lzZWpzJztcclxuaW1wb3J0ICogYXMgU2ltcGxleE5vaXNlIGZyb20gJ3NpbXBsZXgtbm9pc2UnO1xyXG5pbXBvcnQgVGVuc29yIGZyb20gJy4vdGVuc29yJztcclxuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xyXG5pbXBvcnQge0dyaWQsIFJhZGlhbCwgQmFzaXNGaWVsZH0gZnJvbSAnLi9iYXNpc19maWVsZCc7XHJcbmltcG9ydCBQb2x5Z29uVXRpbCBmcm9tICcuL3BvbHlnb25fdXRpbCc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE5vaXNlUGFyYW1zIHtcclxuICAgIGdsb2JhbE5vaXNlOiBib29sZWFuO1xyXG4gICAgbm9pc2VTaXplUGFyazogbnVtYmVyO1xyXG4gICAgbm9pc2VBbmdsZVBhcms6IG51bWJlcjsgIC8vIERlZ3JlZXNcclxuICAgIG5vaXNlU2l6ZUdsb2JhbDogbnVtYmVyO1xyXG4gICAgbm9pc2VBbmdsZUdsb2JhbDogbnVtYmVyO1xyXG59XHJcblxyXG4vKipcclxuICogQ29tYmluZXMgYmFzaXMgZmllbGRzXHJcbiAqIE5vaXNlIGFkZGVkIHdoZW4gc2FtcGxpbmcgYSBwb2ludCBpbiBhIHBhcmtcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlbnNvckZpZWxkIHtcclxuICAgIHByaXZhdGUgYmFzaXNGaWVsZHM6IEJhc2lzRmllbGRbXSA9IFtdO1xyXG4gICAgcHJpdmF0ZSBub2lzZTogU2ltcGxleE5vaXNlO1xyXG5cclxuICAgIHB1YmxpYyBwYXJrczogVmVjdG9yW11bXSA9IFtdO1xyXG4gICAgcHVibGljIHNlYTogVmVjdG9yW10gPSBbXTtcclxuICAgIHB1YmxpYyByaXZlcjogVmVjdG9yW10gPSBbXTtcclxuICAgIHB1YmxpYyBpZ25vcmVSaXZlciA9IGZhbHNlO1xyXG5cclxuICAgIHB1YmxpYyBzbW9vdGggPSBmYWxzZTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgbm9pc2VQYXJhbXM6IE5vaXNlUGFyYW1zKSB7XHJcbiAgICAgICAgdGhpcy5ub2lzZSA9IG5ldyBTaW1wbGV4Tm9pc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgd2hlbiBpbnRlZ3JhdGluZyBjb2FzdGxpbmUgYW5kIHJpdmVyXHJcbiAgICAgKi9cclxuICAgIGVuYWJsZUdsb2JhbE5vaXNlKGFuZ2xlOiBudW1iZXIsIHNpemU6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubm9pc2VQYXJhbXMuZ2xvYmFsTm9pc2UgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubm9pc2VQYXJhbXMubm9pc2VBbmdsZUdsb2JhbCA9IGFuZ2xlO1xyXG4gICAgICAgIHRoaXMubm9pc2VQYXJhbXMubm9pc2VTaXplR2xvYmFsID0gc2l6ZTtcclxuICAgIH1cclxuXHJcbiAgICBkaXNhYmxlR2xvYmFsTm9pc2UoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5ub2lzZVBhcmFtcy5nbG9iYWxOb2lzZSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZEdyaWQoY2VudHJlOiBWZWN0b3IsIHNpemU6IG51bWJlciwgZGVjYXk6IG51bWJlciwgdGhldGE6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGdyaWQgPSBuZXcgR3JpZChjZW50cmUsIHNpemUsIGRlY2F5LCB0aGV0YSk7XHJcbiAgICAgICAgdGhpcy5hZGRGaWVsZChncmlkKTsgICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIGFkZFJhZGlhbChjZW50cmU6IFZlY3Rvciwgc2l6ZTogbnVtYmVyLCBkZWNheTogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgcmFkaWFsID0gbmV3IFJhZGlhbChjZW50cmUsIHNpemUsIGRlY2F5KTtcclxuICAgICAgICB0aGlzLmFkZEZpZWxkKHJhZGlhbCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGFkZEZpZWxkKGZpZWxkOiBCYXNpc0ZpZWxkKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5iYXNpc0ZpZWxkcy5wdXNoKGZpZWxkKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVtb3ZlRmllbGQoZmllbGQ6IEJhc2lzRmllbGQpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuYmFzaXNGaWVsZHMuaW5kZXhPZihmaWVsZCk7XHJcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5iYXNpc0ZpZWxkcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXNldCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmJhc2lzRmllbGRzID0gW107XHJcbiAgICAgICAgdGhpcy5wYXJrcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuc2VhID0gW107XHJcbiAgICAgICAgdGhpcy5yaXZlciA9IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIGdldENlbnRyZVBvaW50cygpOiBWZWN0b3JbXSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzaXNGaWVsZHMubWFwKGZpZWxkID0+IGZpZWxkLmNlbnRyZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0QmFzaXNGaWVsZHMoKTogQmFzaXNGaWVsZFtdIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iYXNpc0ZpZWxkcztcclxuICAgIH1cclxuXHJcbiAgICBzYW1wbGVQb2ludChwb2ludDogVmVjdG9yKTogVGVuc29yIHtcclxuICAgICAgICBpZiAoIXRoaXMub25MYW5kKHBvaW50KSkge1xyXG4gICAgICAgICAgICAvLyBEZWdlbmVyYXRlIHBvaW50XHJcbiAgICAgICAgICAgIHJldHVybiBUZW5zb3IuemVybztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlZmF1bHQgZmllbGQgaXMgYSBncmlkXHJcbiAgICAgICAgaWYgKHRoaXMuYmFzaXNGaWVsZHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGVuc29yKDEsIFswLCAwXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0ZW5zb3JBY2MgPSBUZW5zb3IuemVybztcclxuICAgICAgICB0aGlzLmJhc2lzRmllbGRzLmZvckVhY2goZmllbGQgPT4gdGVuc29yQWNjLmFkZChmaWVsZC5nZXRXZWlnaHRlZFRlbnNvcihwb2ludCwgdGhpcy5zbW9vdGgpLCB0aGlzLnNtb290aCkpO1xyXG5cclxuICAgICAgICAvLyBBZGQgcm90YXRpb25hbCBub2lzZSBmb3IgcGFya3MgLSByYW5nZSAtcGkvMiB0byBwaS8yXHJcbiAgICAgICAgaWYgKHRoaXMucGFya3Muc29tZShwID0+IFBvbHlnb25VdGlsLmluc2lkZVBvbHlnb24ocG9pbnQsIHApKSkge1xyXG4gICAgICAgICAgICAvLyBUT0RPIG9wdGltaXNlIGluc2lkZVBvbHlnb24gZS5nLiBkaXN0YW5jZVxyXG4gICAgICAgICAgICB0ZW5zb3JBY2Mucm90YXRlKHRoaXMuZ2V0Um90YXRpb25hbE5vaXNlKHBvaW50LCB0aGlzLm5vaXNlUGFyYW1zLm5vaXNlU2l6ZVBhcmssIHRoaXMubm9pc2VQYXJhbXMubm9pc2VBbmdsZVBhcmspKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm5vaXNlUGFyYW1zLmdsb2JhbE5vaXNlKSB7XHJcbiAgICAgICAgICAgIHRlbnNvckFjYy5yb3RhdGUodGhpcy5nZXRSb3RhdGlvbmFsTm9pc2UocG9pbnQsIHRoaXMubm9pc2VQYXJhbXMubm9pc2VTaXplR2xvYmFsLCB0aGlzLm5vaXNlUGFyYW1zLm5vaXNlQW5nbGVHbG9iYWwpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0ZW5zb3JBY2M7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb2lzZSBBbmdsZSBpcyBpbiBkZWdyZWVzXHJcbiAgICAgKi9cclxuICAgIGdldFJvdGF0aW9uYWxOb2lzZShwb2ludDogVmVjdG9yLCBub2lzZVNpemU6IG51bWJlciwgbm9pc2VBbmdsZTogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub2lzZS5ub2lzZTJEKHBvaW50LnggLyBub2lzZVNpemUsIHBvaW50LnkgLyBub2lzZVNpemUpICogbm9pc2VBbmdsZSAqIE1hdGguUEkgLyAxODA7XHJcbiAgICB9XHJcblxyXG4gICAgb25MYW5kKHBvaW50OiBWZWN0b3IpOiBib29sZWFuIHtcclxuICAgICAgICBjb25zdCBpblNlYSA9IFBvbHlnb25VdGlsLmluc2lkZVBvbHlnb24ocG9pbnQsIHRoaXMuc2VhKTtcclxuICAgICAgICBpZiAodGhpcy5pZ25vcmVSaXZlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gIWluU2VhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuICFpblNlYSAmJiAhUG9seWdvblV0aWwuaW5zaWRlUG9seWdvbihwb2ludCwgdGhpcy5yaXZlcik7XHJcbiAgICB9XHJcblxyXG4gICAgaW5QYXJrcyhwb2ludDogVmVjdG9yKTogYm9vbGVhbiB7XHJcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMucGFya3MpIHtcclxuICAgICAgICAgICAgaWYgKFBvbHlnb25VdGlsLmluc2lkZVBvbHlnb24ocG9pbnQsIHApKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XHJcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcclxuaW1wb3J0IEZpZWxkSW50ZWdyYXRvciBmcm9tICcuL2ludGVncmF0b3InO1xyXG5pbXBvcnQgU3RyZWFtbGluZUdlbmVyYXRvciBmcm9tICcuL3N0cmVhbWxpbmVzJztcclxuaW1wb3J0IHtTdHJlYW1saW5lUGFyYW1zfSBmcm9tICcuL3N0cmVhbWxpbmVzJztcclxuaW1wb3J0IFRlbnNvckZpZWxkIGZyb20gJy4vdGVuc29yX2ZpZWxkJztcclxuaW1wb3J0IFBvbHlnb25VdGlsIGZyb20gJy4vcG9seWdvbl91dGlsJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgV2F0ZXJQYXJhbXMgZXh0ZW5kcyBTdHJlYW1saW5lUGFyYW1zIHtcclxuICAgIGNvYXN0Tm9pc2U6IE5vaXNlU3RyZWFtbGluZVBhcmFtcztcclxuICAgIHJpdmVyTm9pc2U6IE5vaXNlU3RyZWFtbGluZVBhcmFtcztcclxuICAgIHJpdmVyQmFua1NpemU6IG51bWJlcjtcclxuICAgIHJpdmVyU2l6ZTogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE5vaXNlU3RyZWFtbGluZVBhcmFtcyB7XHJcbiAgICBub2lzZUVuYWJsZWQ6IGJvb2xlYW47XHJcbiAgICBub2lzZVNpemU6IG51bWJlcjtcclxuICAgIG5vaXNlQW5nbGU6IG51bWJlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEludGVncmF0ZXMgcG9seWxpbmVzIHRvIGNyZWF0ZSBjb2FzdGxpbmUgYW5kIHJpdmVyLCB3aXRoIGNvbnRyb2xsYWJsZSBub2lzZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2F0ZXJHZW5lcmF0b3IgZXh0ZW5kcyBTdHJlYW1saW5lR2VuZXJhdG9yIHtcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgVFJJRVMgPSAxMDA7XHJcbiAgICBwcml2YXRlIGNvYXN0bGluZU1ham9yID0gdHJ1ZTtcclxuICAgIHByaXZhdGUgX2NvYXN0bGluZTogVmVjdG9yW10gPSBbXTsgIC8vIE5vaXN5IGxpbmVcclxuICAgIHByaXZhdGUgX3NlYVBvbHlnb246IFZlY3RvcltdID0gW107ICAvLyBVc2VzIHNjcmVlbiByZWN0YW5nbGUgYW5kIHNpbXBsaWZpZWQgcm9hZFxyXG4gICAgcHJpdmF0ZSBfcml2ZXJQb2x5Z29uOiBWZWN0b3JbXSA9IFtdOyAvLyBTaW1wbGlmaWVkXHJcbiAgICBwcml2YXRlIF9yaXZlclNlY29uZGFyeVJvYWQ6IFZlY3RvcltdID0gW107XHJcblxyXG4gICAgY29uc3RydWN0b3IoaW50ZWdyYXRvcjogRmllbGRJbnRlZ3JhdG9yLFxyXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBWZWN0b3IsXHJcbiAgICAgICAgICAgICAgICB3b3JsZERpbWVuc2lvbnM6IFZlY3RvcixcclxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJhbXM6IFdhdGVyUGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSB0ZW5zb3JGaWVsZDogVGVuc29yRmllbGQpIHtcclxuICAgICAgICBzdXBlcihpbnRlZ3JhdG9yLCBvcmlnaW4sIHdvcmxkRGltZW5zaW9ucywgcGFyYW1zKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgY29hc3RsaW5lKCk6IFZlY3RvcltdIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29hc3RsaW5lO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBzZWFQb2x5Z29uKCk6IFZlY3RvcltdIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2VhUG9seWdvbjtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgcml2ZXJQb2x5Z29uKCk6IFZlY3RvcltdIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcml2ZXJQb2x5Z29uO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCByaXZlclNlY29uZGFyeVJvYWQoKTogVmVjdG9yW10ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yaXZlclNlY29uZGFyeVJvYWQ7XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlQ29hc3QoKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGNvYXN0U3RyZWFtbGluZTtcclxuICAgICAgICBsZXQgc2VlZDtcclxuICAgICAgICBsZXQgbWFqb3I7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy5jb2FzdE5vaXNlLm5vaXNlRW5hYmxlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnRlbnNvckZpZWxkLmVuYWJsZUdsb2JhbE5vaXNlKHRoaXMucGFyYW1zLmNvYXN0Tm9pc2Uubm9pc2VBbmdsZSwgdGhpcy5wYXJhbXMuY29hc3ROb2lzZS5ub2lzZVNpemUpOyAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLlRSSUVTOyBpKyspIHtcclxuICAgICAgICAgICAgbWFqb3IgPSBNYXRoLnJhbmRvbSgpIDwgMC41O1xyXG4gICAgICAgICAgICBzZWVkID0gdGhpcy5nZXRTZWVkKG1ham9yKTtcclxuICAgICAgICAgICAgY29hc3RTdHJlYW1saW5lID0gdGhpcy5leHRlbmRTdHJlYW1saW5lKHRoaXMuaW50ZWdyYXRlU3RyZWFtbGluZShzZWVkLCBtYWpvcikpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMucmVhY2hlc0VkZ2VzKGNvYXN0U3RyZWFtbGluZSkpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudGVuc29yRmllbGQuZGlzYWJsZUdsb2JhbE5vaXNlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuX2NvYXN0bGluZSA9IGNvYXN0U3RyZWFtbGluZTtcclxuICAgICAgICB0aGlzLmNvYXN0bGluZU1ham9yID0gbWFqb3I7XHJcblxyXG4gICAgICAgIGNvbnN0IHJvYWQgPSB0aGlzLnNpbXBsaWZ5U3RyZWFtbGluZShjb2FzdFN0cmVhbWxpbmUpO1xyXG4gICAgICAgIHRoaXMuX3NlYVBvbHlnb24gPSB0aGlzLmdldFNlYVBvbHlnb24ocm9hZCk7XHJcbiAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lc1NpbXBsZS5wdXNoKHJvYWQpO1xyXG4gICAgICAgIHRoaXMudGVuc29yRmllbGQuc2VhID0gKHRoaXMuX3NlYVBvbHlnb24pO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgaW50ZXJtZWRpYXRlIHNhbXBsZXNcclxuICAgICAgICBjb25zdCBjb21wbGV4ID0gdGhpcy5jb21wbGV4aWZ5U3RyZWFtbGluZShyb2FkKTtcclxuICAgICAgICB0aGlzLmdyaWQobWFqb3IpLmFkZFBvbHlsaW5lKGNvbXBsZXgpO1xyXG4gICAgICAgIHRoaXMuc3RyZWFtbGluZXMobWFqb3IpLnB1c2goY29tcGxleCk7XHJcbiAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lcy5wdXNoKGNvbXBsZXgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZVJpdmVyKCk6IHZvaWQge1xyXG4gICAgICAgIGxldCByaXZlclN0cmVhbWxpbmU7XHJcbiAgICAgICAgbGV0IHNlZWQ7XHJcblxyXG4gICAgICAgIC8vIE5lZWQgdG8gaWdub3JlIHNlYSB3aGVuIGludGVncmF0aW5nIGZvciBlZGdlIGNoZWNrXHJcbiAgICAgICAgY29uc3Qgb2xkU2VhID0gdGhpcy50ZW5zb3JGaWVsZC5zZWE7XHJcbiAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5zZWEgPSBbXTtcclxuICAgICAgICBpZiAodGhpcy5wYXJhbXMucml2ZXJOb2lzZS5ub2lzZUVuYWJsZWQpIHtcclxuICAgICAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5lbmFibGVHbG9iYWxOb2lzZSh0aGlzLnBhcmFtcy5yaXZlck5vaXNlLm5vaXNlQW5nbGUsIHRoaXMucGFyYW1zLnJpdmVyTm9pc2Uubm9pc2VTaXplKTsgICAgXHJcbiAgICAgICAgfSAgICAgICAgXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLlRSSUVTOyBpKyspIHtcclxuICAgICAgICAgICAgc2VlZCA9IHRoaXMuZ2V0U2VlZCghdGhpcy5jb2FzdGxpbmVNYWpvcik7XHJcbiAgICAgICAgICAgIHJpdmVyU3RyZWFtbGluZSA9IHRoaXMuZXh0ZW5kU3RyZWFtbGluZSh0aGlzLmludGVncmF0ZVN0cmVhbWxpbmUoc2VlZCwgIXRoaXMuY29hc3RsaW5lTWFqb3IpKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWNoZXNFZGdlcyhyaXZlclN0cmVhbWxpbmUpKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpID09PSB0aGlzLlRSSUVTIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKCdGYWlsZWQgdG8gZmluZCByaXZlciByZWFjaGluZyBlZGdlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5zZWEgPSBvbGRTZWE7XHJcbiAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5kaXNhYmxlR2xvYmFsTm9pc2UoKTtcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIHJpdmVyIHJvYWRzXHJcbiAgICAgICAgY29uc3QgZXhwYW5kZWROb2lzeSA9IHRoaXMuY29tcGxleGlmeVN0cmVhbWxpbmUoUG9seWdvblV0aWwucmVzaXplR2VvbWV0cnkocml2ZXJTdHJlYW1saW5lLCB0aGlzLnBhcmFtcy5yaXZlclNpemUsIGZhbHNlKSk7XHJcbiAgICAgICAgdGhpcy5fcml2ZXJQb2x5Z29uID0gUG9seWdvblV0aWwucmVzaXplR2VvbWV0cnkocml2ZXJTdHJlYW1saW5lLCB0aGlzLnBhcmFtcy5yaXZlclNpemUgLSB0aGlzLnBhcmFtcy5yaXZlckJhbmtTaXplLCBmYWxzZSk7XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHJpdmVyUG9seWdvblswXSBpcyBvZmYgc2NyZWVuXHJcbiAgICAgICAgY29uc3QgZmlyc3RPZmZTY3JlZW4gPSBleHBhbmRlZE5vaXN5LmZpbmRJbmRleCh2ID0+IHRoaXMudmVjdG9yT2ZmU2NyZWVuKHYpKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpcnN0T2ZmU2NyZWVuOyBpKyspIHtcclxuICAgICAgICAgICAgZXhwYW5kZWROb2lzeS5wdXNoKGV4cGFuZGVkTm9pc3kuc2hpZnQoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDcmVhdGUgcml2ZXIgcm9hZHNcclxuICAgICAgICBjb25zdCByaXZlclNwbGl0UG9seSA9IHRoaXMuZ2V0U2VhUG9seWdvbihyaXZlclN0cmVhbWxpbmUpO1xyXG4gICAgICAgIGNvbnN0IHJvYWQxID0gZXhwYW5kZWROb2lzeS5maWx0ZXIodiA9PlxyXG4gICAgICAgICAgICAhUG9seWdvblV0aWwuaW5zaWRlUG9seWdvbih2LCB0aGlzLl9zZWFQb2x5Z29uKVxyXG4gICAgICAgICAgICAmJiAhdGhpcy52ZWN0b3JPZmZTY3JlZW4odilcclxuICAgICAgICAgICAgJiYgUG9seWdvblV0aWwuaW5zaWRlUG9seWdvbih2LCByaXZlclNwbGl0UG9seSkpO1xyXG4gICAgICAgIGNvbnN0IHJvYWQxU2ltcGxlID0gdGhpcy5zaW1wbGlmeVN0cmVhbWxpbmUocm9hZDEpO1xyXG4gICAgICAgIGNvbnN0IHJvYWQyID0gZXhwYW5kZWROb2lzeS5maWx0ZXIodiA9PlxyXG4gICAgICAgICAgICAhUG9seWdvblV0aWwuaW5zaWRlUG9seWdvbih2LCB0aGlzLl9zZWFQb2x5Z29uKVxyXG4gICAgICAgICAgICAmJiAhdGhpcy52ZWN0b3JPZmZTY3JlZW4odilcclxuICAgICAgICAgICAgJiYgIVBvbHlnb25VdGlsLmluc2lkZVBvbHlnb24odiwgcml2ZXJTcGxpdFBvbHkpKTtcclxuICAgICAgICBjb25zdCByb2FkMlNpbXBsZSA9IHRoaXMuc2ltcGxpZnlTdHJlYW1saW5lKHJvYWQyKTtcclxuXHJcbiAgICAgICAgaWYgKHJvYWQxLmxlbmd0aCA9PT0gMCB8fCByb2FkMi5sZW5ndGggPT09IDApIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKHJvYWQxWzBdLmRpc3RhbmNlVG9TcXVhcmVkKHJvYWQyWzBdKSA8IHJvYWQxWzBdLmRpc3RhbmNlVG9TcXVhcmVkKHJvYWQyW3JvYWQyLmxlbmd0aCAtIDFdKSkge1xyXG4gICAgICAgICAgICByb2FkMlNpbXBsZS5yZXZlcnNlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnRlbnNvckZpZWxkLnJpdmVyID0gcm9hZDFTaW1wbGUuY29uY2F0KHJvYWQyU2ltcGxlKTtcclxuXHJcbiAgICAgICAgLy8gUm9hZCAxXHJcbiAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lc1NpbXBsZS5wdXNoKHJvYWQxU2ltcGxlKTtcclxuICAgICAgICB0aGlzLl9yaXZlclNlY29uZGFyeVJvYWQgPSByb2FkMlNpbXBsZTtcclxuXHJcbiAgICAgICAgdGhpcy5ncmlkKCF0aGlzLmNvYXN0bGluZU1ham9yKS5hZGRQb2x5bGluZShyb2FkMSk7XHJcbiAgICAgICAgdGhpcy5ncmlkKCF0aGlzLmNvYXN0bGluZU1ham9yKS5hZGRQb2x5bGluZShyb2FkMik7XHJcbiAgICAgICAgdGhpcy5zdHJlYW1saW5lcyghdGhpcy5jb2FzdGxpbmVNYWpvcikucHVzaChyb2FkMSk7XHJcbiAgICAgICAgdGhpcy5zdHJlYW1saW5lcyghdGhpcy5jb2FzdGxpbmVNYWpvcikucHVzaChyb2FkMik7XHJcbiAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lcy5wdXNoKHJvYWQxKTtcclxuICAgICAgICB0aGlzLmFsbFN0cmVhbWxpbmVzLnB1c2gocm9hZDIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXNzdW1lcyBzaW1wbGlmaWVkXHJcbiAgICAgKiBVc2VkIGZvciBhZGRpbmcgcml2ZXIgcm9hZHNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBtYW51YWxseUFkZFN0cmVhbWxpbmUoczogVmVjdG9yW10sIG1ham9yOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lc1NpbXBsZS5wdXNoKHMpO1xyXG4gICAgICAgIC8vIENyZWF0ZSBpbnRlcm1lZGlhdGUgc2FtcGxlc1xyXG4gICAgICAgIGNvbnN0IGNvbXBsZXggPSB0aGlzLmNvbXBsZXhpZnlTdHJlYW1saW5lKHMpO1xyXG4gICAgICAgIHRoaXMuZ3JpZChtYWpvcikuYWRkUG9seWxpbmUoY29tcGxleCk7XHJcbiAgICAgICAgdGhpcy5zdHJlYW1saW5lcyhtYWpvcikucHVzaChjb21wbGV4KTtcclxuICAgICAgICB0aGlzLmFsbFN0cmVhbWxpbmVzLnB1c2goY29tcGxleCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNaWdodCByZXZlcnNlIGlucHV0IGFycmF5XHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0U2VhUG9seWdvbihwb2x5bGluZTogVmVjdG9yW10pOiBWZWN0b3JbXSB7XHJcbiAgICAgICAgLy8gY29uc3Qgc2VhUG9seWdvbiA9IFBvbHlnb25VdGlsLnNsaWNlUmVjdGFuZ2xlKHRoaXMub3JpZ2luLCB0aGlzLndvcmxkRGltZW5zaW9ucyxcclxuICAgICAgICAvLyAgICAgcG9seWxpbmVbMF0sIHBvbHlsaW5lW3BvbHlsaW5lLmxlbmd0aCAtIDFdKTtcclxuXHJcbiAgICAgICAgLy8gLy8gUmVwbGFjZSB0aGUgbG9uZ2VzdCBzaWRlIHdpdGggY29hc3RsaW5lXHJcbiAgICAgICAgLy8gbGV0IGxvbmdlc3RJbmRleCA9IDA7XHJcbiAgICAgICAgLy8gbGV0IGxvbmdlc3RMZW5ndGggPSAwO1xyXG4gICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgc2VhUG9seWdvbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIC8vICAgICBjb25zdCBuZXh0ID0gKGkgKyAxKSAlIHNlYVBvbHlnb24ubGVuZ3RoO1xyXG4gICAgICAgIC8vICAgICBjb25zdCBkID0gc2VhUG9seWdvbltpXS5kaXN0YW5jZVRvU3F1YXJlZChzZWFQb2x5Z29uW25leHRdKTtcclxuICAgICAgICAvLyAgICAgaWYgKGQgPiBsb25nZXN0TGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gICAgICAgICBsb25nZXN0TGVuZ3RoID0gZDtcclxuICAgICAgICAvLyAgICAgICAgIGxvbmdlc3RJbmRleCA9IGk7XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIC8vIGNvbnN0IGluc2VydEJhY2t3YXJkcyA9IHNlYVBvbHlnb25bbG9uZ2VzdEluZGV4XS5kaXN0YW5jZVRvU3F1YXJlZChwb2x5bGluZVswXSkgPiBzZWFQb2x5Z29uW2xvbmdlc3RJbmRleF0uZGlzdGFuY2VUb1NxdWFyZWQocG9seWxpbmVbcG9seWxpbmUubGVuZ3RoIC0gMV0pO1xyXG4gICAgICAgIC8vIGlmIChpbnNlcnRCYWNrd2FyZHMpIHtcclxuICAgICAgICAvLyAgICAgcG9seWxpbmUucmV2ZXJzZSgpO1xyXG4gICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgLy8gc2VhUG9seWdvbi5zcGxpY2UoKGxvbmdlc3RJbmRleCArIDEpICUgc2VhUG9seWdvbi5sZW5ndGgsIDAsIC4uLnBvbHlsaW5lKTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gUG9seWdvblV0aWwubGluZVJlY3RhbmdsZVBvbHlnb25JbnRlcnNlY3Rpb24odGhpcy5vcmlnaW4sIHRoaXMud29ybGREaW1lbnNpb25zLCBwb2x5bGluZSk7XHJcblxyXG4gICAgICAgIC8vIHJldHVybiBQb2x5Z29uVXRpbC5ib3VuZFBvbHlUb1NjcmVlbih0aGlzLm9yaWdpbiwgdGhpcy53b3JsZERpbWVuc2lvbnMsIHNlYVBvbHlnb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0IHNhbXBsZXMgaW4gc3RyZWFtbGluZSB1bnRpbCBzZXBhcmF0ZWQgYnkgZHN0ZXBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjb21wbGV4aWZ5U3RyZWFtbGluZShzOiBWZWN0b3JbXSk6IFZlY3RvcltdIHtcclxuICAgICAgICBjb25zdCBvdXQ6IFZlY3RvcltdID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICBvdXQucHVzaCguLi50aGlzLmNvbXBsZXhpZnlTdHJlYW1saW5lUmVjdXJzaXZlKHNbaV0sIHNbaSsxXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY29tcGxleGlmeVN0cmVhbWxpbmVSZWN1cnNpdmUodjE6IFZlY3RvciwgdjI6IFZlY3Rvcik6IFZlY3RvcltdIHtcclxuICAgICAgICBpZiAodjEuZGlzdGFuY2VUb1NxdWFyZWQodjIpIDw9IHRoaXMucGFyYW1zU3EuZHN0ZXApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFt2MSwgdjJdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkID0gdjIuY2xvbmUoKS5zdWIodjEpO1xyXG4gICAgICAgIGNvbnN0IGhhbGZ3YXkgPSB2MS5jbG9uZSgpLmFkZChkLm11bHRpcGx5U2NhbGFyKDAuNSkpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IGNvbXBsZXggPSB0aGlzLmNvbXBsZXhpZnlTdHJlYW1saW5lUmVjdXJzaXZlKHYxLCBoYWxmd2F5KTtcclxuICAgICAgICBjb21wbGV4LnB1c2goLi4udGhpcy5jb21wbGV4aWZ5U3RyZWFtbGluZVJlY3Vyc2l2ZShoYWxmd2F5LCB2MikpO1xyXG4gICAgICAgIHJldHVybiBjb21wbGV4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTXV0YXRlcyBzdHJlYW1saW5lXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZXh0ZW5kU3RyZWFtbGluZShzdHJlYW1saW5lOiBWZWN0b3JbXSk6IFZlY3RvcltdIHtcclxuICAgICAgICAgICAgc3RyZWFtbGluZS51bnNoaWZ0KHN0cmVhbWxpbmVbMF0uY2xvbmUoKS5hZGQoXHJcbiAgICAgICAgICAgICAgICBzdHJlYW1saW5lWzBdLmNsb25lKCkuc3ViKHN0cmVhbWxpbmVbMV0pLnNldExlbmd0aCh0aGlzLnBhcmFtcy5kc3RlcCAqIDUpKSk7XHJcbiAgICAgICAgICAgIHN0cmVhbWxpbmUucHVzaChzdHJlYW1saW5lW3N0cmVhbWxpbmUubGVuZ3RoIC0gMV0uY2xvbmUoKS5hZGQoXHJcbiAgICAgICAgICAgICAgICBzdHJlYW1saW5lW3N0cmVhbWxpbmUubGVuZ3RoIC0gMV0uY2xvbmUoKS5zdWIoc3RyZWFtbGluZVtzdHJlYW1saW5lLmxlbmd0aCAtIDJdKS5zZXRMZW5ndGgodGhpcy5wYXJhbXMuZHN0ZXAgKiA1KSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyZWFtbGluZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSByZWFjaGVzRWRnZXMoc3RyZWFtbGluZTogVmVjdG9yW10pOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52ZWN0b3JPZmZTY3JlZW4oc3RyZWFtbGluZVswXSkgJiYgdGhpcy52ZWN0b3JPZmZTY3JlZW4oc3RyZWFtbGluZVtzdHJlYW1saW5lLmxlbmd0aCAtIDFdKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHZlY3Rvck9mZlNjcmVlbih2OiBWZWN0b3IpOiBib29sZWFuIHtcclxuICAgICAgICBjb25zdCB0b09yaWdpbiA9IHYuY2xvbmUoKS5zdWIodGhpcy5vcmlnaW4pO1xyXG4gICAgICAgIHJldHVybiB0b09yaWdpbi54IDw9IDAgfHwgdG9PcmlnaW4ueSA8PSAwIHx8XHJcbiAgICAgICAgICAgIHRvT3JpZ2luLnggPj0gdGhpcy53b3JsZERpbWVuc2lvbnMueCB8fCB0b09yaWdpbi55ID49IHRoaXMud29ybGREaW1lbnNpb25zLnk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcclxuaW1wb3J0IERvbWFpbkNvbnRyb2xsZXIgZnJvbSAnLi9kb21haW5fY29udHJvbGxlcic7XHJcbmltcG9ydCBUZW5zb3JGaWVsZCBmcm9tICcuLi9pbXBsL3RlbnNvcl9maWVsZCc7XHJcbmltcG9ydCBHcmFwaCBmcm9tICcuLi9pbXBsL2dyYXBoJztcclxuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xyXG5pbXBvcnQgUG9seWdvbkZpbmRlciBmcm9tICcuLi9pbXBsL3BvbHlnb25fZmluZGVyJztcclxuaW1wb3J0IHtQb2x5Z29uUGFyYW1zfSBmcm9tICcuLi9pbXBsL3BvbHlnb25fZmluZGVyJztcclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEJ1aWxkaW5nTW9kZWwge1xyXG4gICAgaGVpZ2h0OiBudW1iZXI7XHJcbiAgICBsb3RXb3JsZDogVmVjdG9yW107IC8vIEluIHdvcmxkIHNwYWNlXHJcbiAgICBsb3RTY3JlZW46IFZlY3RvcltdOyAvLyBJbiBzY3JlZW4gc3BhY2VcclxuICAgIHJvb2Y6IFZlY3RvcltdOyAvLyBJbiBzY3JlZW4gc3BhY2VcclxuICAgIHNpZGVzOiBWZWN0b3JbXVtdOyAvLyBJbiBzY3JlZW4gc3BhY2VcclxufVxyXG5cclxuLyoqXHJcbiAqIFBzZXVkbyAzRCBidWlsZGluZ3NcclxuICovXHJcbmNsYXNzIEJ1aWxkaW5nTW9kZWxzIHtcclxuICAgIHByaXZhdGUgZG9tYWluQ29udHJvbGxlciA9IERvbWFpbkNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgIHByaXZhdGUgX2J1aWxkaW5nTW9kZWxzOiBCdWlsZGluZ01vZGVsW10gPSBbXTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihsb3RzOiBWZWN0b3JbXVtdKSB7ICAvLyBMb3RzIGluIHdvcmxkIHNwYWNlXHJcbiAgICAgICAgZm9yIChjb25zdCBsb3Qgb2YgbG90cykge1xyXG4gICAgICAgICAgICB0aGlzLl9idWlsZGluZ01vZGVscy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGhlaWdodDogTWF0aC5yYW5kb20oKSAqIDIwICsgMjAsXHJcbiAgICAgICAgICAgICAgICBsb3RXb3JsZDogbG90LFxyXG4gICAgICAgICAgICAgICAgbG90U2NyZWVuOiBbXSxcclxuICAgICAgICAgICAgICAgIHJvb2Y6IFtdLFxyXG4gICAgICAgICAgICAgICAgc2lkZXM6IFtdXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9idWlsZGluZ01vZGVscy5zb3J0KChhLCBiKSA9PiBhLmhlaWdodCAtIGIuaGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgYnVpbGRpbmdNb2RlbHMoKTogQnVpbGRpbmdNb2RlbFtdIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRpbmdNb2RlbHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWNhbGN1bGF0ZWQgd2hlbiB0aGUgY2FtZXJhIG1vdmVzXHJcbiAgICAgKi9cclxuICAgIHNldEJ1aWxkaW5nUHJvamVjdGlvbnMoKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgZCA9IDEwMDAgLyB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbTtcclxuICAgICAgICBjb25zdCBjYW1lcmFQb3MgPSB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuZ2V0Q2FtZXJhUG9zaXRpb24oKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGIgb2YgdGhpcy5fYnVpbGRpbmdNb2RlbHMpIHtcclxuICAgICAgICAgICAgYi5sb3RTY3JlZW4gPSBiLmxvdFdvcmxkLm1hcCh2ID0+IHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZFRvU2NyZWVuKHYuY2xvbmUoKSkpO1xyXG4gICAgICAgICAgICBiLnJvb2YgPSBiLmxvdFNjcmVlbi5tYXAodiA9PiB0aGlzLmhlaWdodFZlY3RvclRvU2NyZWVuKHYsIGIuaGVpZ2h0LCBkLCBjYW1lcmFQb3MpKTtcclxuICAgICAgICAgICAgYi5zaWRlcyA9IHRoaXMuZ2V0QnVpbGRpbmdTaWRlcyhiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBoZWlnaHRWZWN0b3JUb1NjcmVlbih2OiBWZWN0b3IsIGg6IG51bWJlciwgZDogbnVtYmVyLCBjYW1lcmE6IFZlY3Rvcik6IFZlY3RvciB7XHJcbiAgICAgICAgY29uc3Qgc2NhbGUgPSAoZCAvIChkIC0gaCkpOyAvLyAwLjFcclxuICAgICAgICBpZiAodGhpcy5kb21haW5Db250cm9sbGVyLm9ydGhvZ3JhcGhpYykge1xyXG4gICAgICAgICAgICBjb25zdCBkaWZmID0gdGhpcy5kb21haW5Db250cm9sbGVyLmNhbWVyYURpcmVjdGlvbi5tdWx0aXBseVNjYWxhcigtaCAqIHNjYWxlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHYuY2xvbmUoKS5hZGQoZGlmZik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHYuY2xvbmUoKS5zdWIoY2FtZXJhKS5tdWx0aXBseVNjYWxhcihzY2FsZSkuYWRkKGNhbWVyYSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHNpZGVzIG9mIGJ1aWxkaW5ncyBieSBqb2luaW5nIGNvcnJlc3BvbmRpbmcgZWRnZXMgYmV0d2VlbiB0aGUgcm9vZiBhbmQgZ3JvdW5kXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0QnVpbGRpbmdTaWRlcyhiOiBCdWlsZGluZ01vZGVsKTogVmVjdG9yW11bXSB7XHJcbiAgICAgICAgY29uc3QgcG9seWdvbnM6IFZlY3RvcltdW10gPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGIubG90U2NyZWVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSAoaSArIDEpICUgYi5sb3RTY3JlZW4ubGVuZ3RoO1xyXG4gICAgICAgICAgICBwb2x5Z29ucy5wdXNoKFtiLmxvdFNjcmVlbltpXSwgYi5sb3RTY3JlZW5bbmV4dF0sIGIucm9vZltuZXh0XSwgYi5yb29mW2ldXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwb2x5Z29ucztcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEZpbmRzIGJ1aWxkaW5nIGxvdHMgYW5kIG9wdGlvbmFsbHkgcHNldWRvM0QgYnVpbGRpbmdzXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdWlsZGluZ3Mge1xyXG4gICAgcHJpdmF0ZSBwb2x5Z29uRmluZGVyOiBQb2x5Z29uRmluZGVyO1xyXG4gICAgcHJpdmF0ZSBhbGxTdHJlYW1saW5lczogVmVjdG9yW11bXSA9IFtdO1xyXG4gICAgcHJpdmF0ZSBkb21haW5Db250cm9sbGVyID0gRG9tYWluQ29udHJvbGxlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgcHJpdmF0ZSBwcmVHZW5lcmF0ZUNhbGxiYWNrOiAoKSA9PiBhbnkgPSAoKSA9PiB7fTtcclxuICAgIHByaXZhdGUgcG9zdEdlbmVyYXRlQ2FsbGJhY2s6ICgpID0+IGFueSA9ICgpID0+IHt9O1xyXG4gICAgcHJpdmF0ZSBfbW9kZWxzOiBCdWlsZGluZ01vZGVscyA9IG5ldyBCdWlsZGluZ01vZGVscyhbXSk7XHJcbiAgICBwcml2YXRlIF9ibG9ja3M6IFZlY3RvcltdW10gPSBbXTtcclxuXHJcbiAgICBwcml2YXRlIGJ1aWxkaW5nUGFyYW1zOiBQb2x5Z29uUGFyYW1zID0ge1xyXG4gICAgICAgIG1heExlbmd0aDogMjAsXHJcbiAgICAgICAgbWluQXJlYTogNTAsXHJcbiAgICAgICAgc2hyaW5rU3BhY2luZzogNCxcclxuICAgICAgICBjaGFuY2VOb0RpdmlkZTogMC4wNSxcclxuICAgIH07XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSB0ZW5zb3JGaWVsZDogVGVuc29yRmllbGQsXHJcbiAgICAgICAgICAgICAgICBmb2xkZXI6IGRhdC5HVUksXHJcbiAgICAgICAgICAgICAgICBwcml2YXRlIHJlZHJhdzogKCkgPT4gdm9pZCxcclxuICAgICAgICAgICAgICAgIHByaXZhdGUgZHN0ZXA6IG51bWJlcixcclxuICAgICAgICAgICAgICAgIHByaXZhdGUgX2FuaW1hdGU6IGJvb2xlYW4pIHtcclxuICAgICAgICBmb2xkZXIuYWRkKHsnQWRkQnVpbGRpbmdzJzogKCkgPT4gdGhpcy5nZW5lcmF0ZSh0aGlzLl9hbmltYXRlKX0sICdBZGRCdWlsZGluZ3MnKTtcclxuICAgICAgICBmb2xkZXIuYWRkKHRoaXMuYnVpbGRpbmdQYXJhbXMsICdtaW5BcmVhJyk7XHJcbiAgICAgICAgZm9sZGVyLmFkZCh0aGlzLmJ1aWxkaW5nUGFyYW1zLCAnc2hyaW5rU3BhY2luZycpO1xyXG4gICAgICAgIGZvbGRlci5hZGQodGhpcy5idWlsZGluZ1BhcmFtcywgJ2NoYW5jZU5vRGl2aWRlJyk7XHJcbiAgICAgICAgdGhpcy5wb2x5Z29uRmluZGVyID0gbmV3IFBvbHlnb25GaW5kZXIoW10sIHRoaXMuYnVpbGRpbmdQYXJhbXMsIHRoaXMudGVuc29yRmllbGQpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBhbmltYXRlKHY6IGJvb2xlYW4pIHtcclxuICAgICAgICB0aGlzLl9hbmltYXRlID0gdjtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgbG90cygpOiBWZWN0b3JbXVtdIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wb2x5Z29uRmluZGVyLnBvbHlnb25zLm1hcChwID0+IHAubWFwKHYgPT4gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkVG9TY3JlZW4odi5jbG9uZSgpKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogT25seSB1c2VkIHdoZW4gY3JlYXRpbmcgdGhlIDNEIG1vZGVsIHRvICdmYWtlJyB0aGUgcm9hZHNcclxuICAgICAqL1xyXG4gICAgZ2V0QmxvY2tzKCk6IFByb21pc2U8VmVjdG9yW11bXT4ge1xyXG4gICAgICAgIGNvbnN0IGcgPSBuZXcgR3JhcGgodGhpcy5hbGxTdHJlYW1saW5lcywgdGhpcy5kc3RlcCwgdHJ1ZSk7XHJcbiAgICAgICAgY29uc3QgYmxvY2tQYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJ1aWxkaW5nUGFyYW1zKTtcclxuICAgICAgICBibG9ja1BhcmFtcy5zaHJpbmtTcGFjaW5nID0gYmxvY2tQYXJhbXMuc2hyaW5rU3BhY2luZy8yO1xyXG4gICAgICAgIGNvbnN0IHBvbHlnb25GaW5kZXIgPSBuZXcgUG9seWdvbkZpbmRlcihnLm5vZGVzLCBibG9ja1BhcmFtcywgdGhpcy50ZW5zb3JGaWVsZCk7XHJcbiAgICAgICAgcG9seWdvbkZpbmRlci5maW5kUG9seWdvbnMoKTtcclxuICAgICAgICByZXR1cm4gcG9seWdvbkZpbmRlci5zaHJpbmsoZmFsc2UpLnRoZW4oKCkgPT4gcG9seWdvbkZpbmRlci5wb2x5Z29ucy5tYXAocCA9PiBwLm1hcCh2ID0+IHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZFRvU2NyZWVuKHYuY2xvbmUoKSkpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IG1vZGVscygpOiBCdWlsZGluZ01vZGVsW10ge1xyXG4gICAgICAgIHRoaXMuX21vZGVscy5zZXRCdWlsZGluZ1Byb2plY3Rpb25zKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vZGVscy5idWlsZGluZ01vZGVscztcclxuICAgIH1cclxuXHJcbiAgICBzZXRBbGxTdHJlYW1saW5lcyhzOiBWZWN0b3JbXVtdKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5hbGxTdHJlYW1saW5lcyA9IHM7XHJcbiAgICB9XHJcblxyXG4gICAgcmVzZXQoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5wb2x5Z29uRmluZGVyLnJlc2V0KCk7XHJcbiAgICAgICAgdGhpcy5fbW9kZWxzID0gbmV3IEJ1aWxkaW5nTW9kZWxzKFtdKTtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9seWdvbkZpbmRlci51cGRhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmRzIGJsb2Nrcywgc2hyaW5rcyBhbmQgZGl2aWRlcyB0aGVtIHRvIGNyZWF0ZSBidWlsZGluZyBsb3RzXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIGdlbmVyYXRlKGFuaW1hdGU6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICB0aGlzLnByZUdlbmVyYXRlQ2FsbGJhY2soKTtcclxuICAgICAgICB0aGlzLl9tb2RlbHMgPSBuZXcgQnVpbGRpbmdNb2RlbHMoW10pO1xyXG4gICAgICAgIGNvbnN0IGcgPSBuZXcgR3JhcGgodGhpcy5hbGxTdHJlYW1saW5lcywgdGhpcy5kc3RlcCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIHRoaXMucG9seWdvbkZpbmRlciA9IG5ldyBQb2x5Z29uRmluZGVyKGcubm9kZXMsIHRoaXMuYnVpbGRpbmdQYXJhbXMsIHRoaXMudGVuc29yRmllbGQpO1xyXG4gICAgICAgIHRoaXMucG9seWdvbkZpbmRlci5maW5kUG9seWdvbnMoKTtcclxuICAgICAgICBhd2FpdCB0aGlzLnBvbHlnb25GaW5kZXIuc2hyaW5rKGFuaW1hdGUpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMucG9seWdvbkZpbmRlci5kaXZpZGUoYW5pbWF0ZSk7XHJcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcclxuICAgICAgICB0aGlzLl9tb2RlbHMgPSBuZXcgQnVpbGRpbmdNb2RlbHModGhpcy5wb2x5Z29uRmluZGVyLnBvbHlnb25zKTtcclxuXHJcbiAgICAgICAgdGhpcy5wb3N0R2VuZXJhdGVDYWxsYmFjaygpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFByZUdlbmVyYXRlQ2FsbGJhY2soY2FsbGJhY2s6ICgpID0+IGFueSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucHJlR2VuZXJhdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFBvc3RHZW5lcmF0ZUNhbGxiYWNrKGNhbGxiYWNrOiAoKSA9PiBhbnkpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnBvc3RHZW5lcmF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xyXG5pbXBvcnQgVmVjdG9yIGZyb20gJy4uL3ZlY3Rvcic7XHJcbmltcG9ydCB7IFNWRyB9IGZyb20gJ0Bzdmdkb3Rqcy9zdmcuanMnO1xyXG5pbXBvcnQgVXRpbCBmcm9tICcuLi91dGlsJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUm91Z2hPcHRpb25zIHtcclxuICAgIHJvdWdobmVzcz86IG51bWJlcjtcclxuICAgIGJvd2luZz86IG51bWJlcjtcclxuICAgIHNlZWQ/OiBudW1iZXI7XHJcbiAgICBzdHJva2U/OiBzdHJpbmc7XHJcbiAgICBzdHJva2VXaWR0aD86IG51bWJlcjtcclxuICAgIGZpbGw/OiBzdHJpbmc7XHJcbiAgICBmaWxsU3R5bGU/OiBzdHJpbmc7XHJcbiAgICBmaWxsV2VpZ2h0PzogbnVtYmVyO1xyXG4gICAgaGFjaHVyZUFuZ2xlPzogbnVtYmVyO1xyXG4gICAgaGFjaHVyZUdhcD86IG51bWJlcjtcclxuICAgIGRhc2hPZmZzZXQ/OiBudW1iZXI7XHJcbiAgICBkYXNoR2FwPzogbnVtYmVyO1xyXG4gICAgemlnemFnT2Zmc2V0PzogbnVtYmVyO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpbiB3cmFwcGVyIGFyb3VuZCBIVE1MIGNhbnZhcywgYWJzdHJhY3RzIGRyYXdpbmcgZnVuY3Rpb25zIHNvIHdlIGNhbiB1c2UgdGhlIFJvdWdoSlMgY2FudmFzIG9yIHRoZSBkZWZhdWx0IG9uZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgQ2FudmFzV3JhcHBlciB7XHJcbiAgICBwcm90ZWN0ZWQgc3ZnTm9kZTogYW55O1xyXG4gICAgcHJvdGVjdGVkIF93aWR0aDogbnVtYmVyO1xyXG4gICAgcHJvdGVjdGVkIF9oZWlnaHQ6IG51bWJlcjtcclxuICAgIHB1YmxpYyBuZWVkc1VwZGF0ZTogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgcHJvdGVjdGVkIF9zY2FsZT0xLCByZXNpemVUb1dpbmRvdz10cnVlKSB7XHJcbiAgICAgICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XHJcbiAgICAgICAgdGhpcy5yZXNpemVDYW52YXMoKTtcclxuICAgICAgICBpZiAocmVzaXplVG9XaW5kb3cpIHtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsICgpOiB2b2lkID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RGltZW5zaW9ucygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemVDYW52YXMoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBhcHBlbmRTdmdOb2RlKG5vZGU6IGFueSk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLnN2Z05vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5zdmdOb2RlLmFwcGVuZENoaWxkKG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVTVkcoc3ZnRWxlbWVudDogYW55KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5zdmdOb2RlID0gc3ZnRWxlbWVudDtcclxuICAgIH1cclxuXHJcbiAgICBhYnN0cmFjdCBkcmF3RnJhbWUobGVmdDogbnVtYmVyLCByaWdodDogbnVtYmVyLCB1cDogbnVtYmVyLCBkb3duOiBudW1iZXIpOiB2b2lkO1xyXG5cclxuICAgIHNldERpbWVuc2lvbnMoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCAqIHRoaXMuX3NjYWxlO1xyXG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAqIHRoaXMuX3NjYWxlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCB3aWR0aCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgaGVpZ2h0KCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgY2FudmFzU2NhbGUoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGU7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IGNhbnZhc1NjYWxlKHM6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMuX3NjYWxlID0gcztcclxuICAgICAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcclxuICAgICAgICB0aGlzLnJlc2l6ZUNhbnZhcygpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCB6b29tVmVjdG9ycyh2czogVmVjdG9yW10pOiBWZWN0b3JbXSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NjYWxlID09PSAxKSByZXR1cm4gdnM7XHJcbiAgICAgICAgcmV0dXJuIHZzLm1hcCh2ID0+IHYuY2xvbmUoKS5tdWx0aXBseVNjYWxhcih0aGlzLl9zY2FsZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZXNpemVDYW52YXMoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLl93aWR0aDtcclxuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBEZWZhdWx0Q2FudmFzV3JhcHBlciBleHRlbmRzIENhbnZhc1dyYXBwZXIge1xyXG4gICAgcHJpdmF0ZSBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcclxuICAgIHByaXZhdGUgc3ZnOiBhbnk7XHJcblxyXG4gICAgY29uc3RydWN0b3IoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgc2NhbGU9MSwgcmVzaXplVG9XaW5kb3c9dHJ1ZSkge1xyXG4gICAgICAgIHN1cGVyKGNhbnZhcywgc2NhbGUsIHJlc2l6ZVRvV2luZG93KTtcclxuICAgICAgICB0aGlzLmN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gJ2JsYWNrJztcclxuICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCgwLCAwLCB3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVTVkcoc3ZnRWxlbWVudDogYW55KTogdm9pZCB7XHJcbiAgICAgICAgc3VwZXIuY3JlYXRlU1ZHKHN2Z0VsZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuc3ZnID0gU1ZHKHN2Z0VsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldEZpbGxTdHlsZShjb2xvdXI6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGNvbG91cjtcclxuICAgIH1cclxuXHJcbiAgICBjbGVhckNhbnZhcygpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5zdmdOb2RlKSB7XHJcbiAgICAgICAgICAgIC8vIEV4cGFuZGVkIHRvIGNvdmVyIHdob2xlIGRyYXduIGFyZWFcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnRXID0gd2luZG93LmlubmVyV2lkdGggKiAoVXRpbC5EUkFXX0lORkxBVEVfQU1PVU5UIC0gMSkgLyAyO1xyXG4gICAgICAgICAgICBjb25zdCBzdGFydEggPSB3aW5kb3cuaW5uZXJIZWlnaHQgKiAoVXRpbC5EUkFXX0lORkxBVEVfQU1PVU5UIC0gMSkgLyAyO1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdSZWN0YW5nbGUoLXN0YXJ0VywgLXN0YXJ0SCwgd2luZG93LmlubmVyV2lkdGggKiBVdGlsLkRSQVdfSU5GTEFURV9BTU9VTlQsIHdpbmRvdy5pbm5lckhlaWdodCAqIFV0aWwuRFJBV19JTkZMQVRFX0FNT1VOVCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kcmF3UmVjdGFuZ2xlKDAsIDAsIHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBkcmF3RnJhbWUobGVmdDogbnVtYmVyLCByaWdodDogbnVtYmVyLCB1cDogbnVtYmVyLCBkb3duOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmRyYXdSZWN0YW5nbGUoMCwgMCwgdGhpcy5fd2lkdGgvdGhpcy5fc2NhbGUsIHVwKTtcclxuICAgICAgICB0aGlzLmRyYXdSZWN0YW5nbGUoMCwgMCwgbGVmdCwgdGhpcy5faGVpZ2h0L3RoaXMuX3NjYWxlKTtcclxuICAgICAgICB0aGlzLmRyYXdSZWN0YW5nbGUodGhpcy5fd2lkdGgvdGhpcy5fc2NhbGUgLSByaWdodCwgMCwgcmlnaHQsIHRoaXMuX2hlaWdodC90aGlzLl9zY2FsZSk7XHJcbiAgICAgICAgdGhpcy5kcmF3UmVjdGFuZ2xlKDAsIHRoaXMuX2hlaWdodC90aGlzLl9zY2FsZSAtIGRvd24sIHRoaXMuX3dpZHRoL3RoaXMuX3NjYWxlLCBkb3duKTtcclxuICAgIH1cclxuXHJcbiAgICBkcmF3Q2l0eU5hbWUoKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgZm9udFNpemUgPSA1MCAqIHRoaXMuX3NjYWxlO1xyXG4gICAgICAgIHRoaXMuY3R4LmZvbnQgPSBgc21hbGwtY2FwcyAke2ZvbnRTaXplfXB4IFZlcmRhbmFgO1xyXG4gICAgICAgIHRoaXMuY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICAgICAgdGhpcy5jdHguZmlsbFRleHQoXCJzYW4gZnJhbmNpc2NvXCIsIHRoaXMuX3dpZHRoLzIsIHRoaXMuX2hlaWdodCAtICg4MCAqIHRoaXMuX3NjYWxlIC0gZm9udFNpemUpKTtcclxuICAgIH1cclxuXHJcbiAgICBkcmF3UmVjdGFuZ2xlKHg6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9zY2FsZSAhPT0gMSkge1xyXG4gICAgICAgICAgICB4ICo9IHRoaXMuX3NjYWxlO1xyXG4gICAgICAgICAgICB5ICo9IHRoaXMuX3NjYWxlO1xyXG4gICAgICAgICAgICB3aWR0aCAqPSB0aGlzLl9zY2FsZTtcclxuICAgICAgICAgICAgaGVpZ2h0ICo9IHRoaXMuX3NjYWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc3ZnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ZnLnJlY3Qoe1xyXG4gICAgICAgICAgICAgICAgZmlsbDogdGhpcy5jdHguZmlsbFN0eWxlLFxyXG4gICAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDEsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IHRoaXMuY3R4LnN0cm9rZVN0eWxlLFxyXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHRoaXMuY3R4LmxpbmVXaWR0aCxcclxuICAgICAgICAgICAgICAgIHg6IHgsXHJcbiAgICAgICAgICAgICAgICB5OiB5LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBkcmF3UG9seWdvbihwb2x5Z29uOiBWZWN0b3JbXSk6IHZvaWQge1xyXG4gICAgICAgIGlmIChwb2x5Z29uLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBvbHlnb24gPSB0aGlzLnpvb21WZWN0b3JzKHBvbHlnb24pO1xyXG5cclxuICAgICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8ocG9seWdvblswXS54LCBwb2x5Z29uWzBdLnkpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBvbHlnb24ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5jdHgubGluZVRvKHBvbHlnb25baV0ueCwgcG9seWdvbltpXS55KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jdHgubGluZVRvKHBvbHlnb25bMF0ueCwgcG9seWdvblswXS55KTtcclxuXHJcbiAgICAgICAgdGhpcy5jdHguZmlsbCgpO1xyXG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5zdmcpIHtcclxuICAgICAgICAgICAgY29uc3QgdmVjdG9yQXJyYXkgPSBwb2x5Z29uLm1hcCh2ID0+IFt2LngsIHYueV0pO1xyXG4gICAgICAgICAgICB2ZWN0b3JBcnJheS5wdXNoKHZlY3RvckFycmF5WzBdKTtcclxuICAgICAgICAgICAgdGhpcy5zdmcucG9seWxpbmUodmVjdG9yQXJyYXkpLmF0dHIoe1xyXG4gICAgICAgICAgICAgICAgZmlsbDogdGhpcy5jdHguZmlsbFN0eWxlLFxyXG4gICAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDEsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6IHRoaXMuY3R4LnN0cm9rZVN0eWxlLFxyXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IHRoaXMuY3R4LmxpbmVXaWR0aCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGRyYXdDaXJjbGUoY2VudHJlOiBWZWN0b3IsIHJhZGl1czogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgVEFVID0gMiAqIE1hdGguUEk7XHJcbiAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgdGhpcy5jdHguYXJjKGNlbnRyZS54LCBjZW50cmUueSwgcmFkaXVzLCAwLCBUQVUpO1xyXG4gICAgICAgIHRoaXMuY3R4LmZpbGwoKTtcclxuICAgIH1cclxuXHJcbiAgICBkcmF3U3F1YXJlKGNlbnRyZTogVmVjdG9yLCByYWRpdXM6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZHJhd1JlY3RhbmdsZShjZW50cmUueCAtIHJhZGl1cywgY2VudHJlLnkgLSByYWRpdXMsIDIgKiByYWRpdXMsIDIgKiByYWRpdXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldExpbmVXaWR0aCh3aWR0aDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NjYWxlICE9PSAxKSB7XHJcbiAgICAgICAgICAgIHdpZHRoICo9IHRoaXMuX3NjYWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmN0eC5saW5lV2lkdGggPSB3aWR0aDtcclxuICAgIH1cclxuXHJcbiAgICBzZXRTdHJva2VTdHlsZShjb2xvdXI6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gY29sb3VyO1xyXG4gICAgfVxyXG5cclxuICAgIGRyYXdQb2x5bGluZShsaW5lOiBWZWN0b3JbXSk6IHZvaWQge1xyXG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGluZSA9IHRoaXMuem9vbVZlY3RvcnMobGluZSk7XHJcblxyXG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIHRoaXMuY3R4Lm1vdmVUbyhsaW5lWzBdLngsIGxpbmVbMF0ueSk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5saW5lVG8obGluZVtpXS54LCBsaW5lW2ldLnkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnN2Zykge1xyXG4gICAgICAgICAgICBjb25zdCB2ZWN0b3JBcnJheSA9IGxpbmUubWFwKHYgPT4gW3YueCwgdi55XSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3ZnLnBvbHlsaW5lKHZlY3RvckFycmF5KS5hdHRyKHtcclxuICAgICAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiAwLFxyXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiB0aGlzLmN0eC5zdHJva2VTdHlsZSxcclxuICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiB0aGlzLmN0eC5saW5lV2lkdGgsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFJvdWdoQ2FudmFzV3JhcHBlciBleHRlbmRzIENhbnZhc1dyYXBwZXIge1xyXG4gICAgcHJpdmF0ZSByID0gcmVxdWlyZSgncm91Z2hqcy9idW5kbGVkL3JvdWdoLmNqcycpO1xyXG4gICAgcHJpdmF0ZSByYzogYW55O1xyXG4gICAgICAgIFxyXG4gICAgcHJpdmF0ZSBvcHRpb25zOiBSb3VnaE9wdGlvbnMgPSB7XHJcbiAgICAgICAgcm91Z2huZXNzOiAxLFxyXG4gICAgICAgIGJvd2luZzogMSxcclxuICAgICAgICBzdHJva2U6ICcjMDAwMDAwJyxcclxuICAgICAgICBzdHJva2VXaWR0aDogMSxcclxuICAgICAgICBmaWxsOiAnIzAwMDAwMCcsXHJcbiAgICAgICAgZmlsbFN0eWxlOiAnc29saWQnLFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCBzY2FsZT0xLCByZXNpemVUb1dpbmRvdz10cnVlKSB7XHJcbiAgICAgICAgc3VwZXIoY2FudmFzLCBzY2FsZSwgcmVzaXplVG9XaW5kb3cpO1xyXG4gICAgICAgIHRoaXMucmMgPSB0aGlzLnIuY2FudmFzKGNhbnZhcyk7XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlU1ZHKHN2Z0VsZW1lbnQ6IGFueSk6IHZvaWQge1xyXG4gICAgICAgIHN1cGVyLmNyZWF0ZVNWRyhzdmdFbGVtZW50KTtcclxuICAgICAgICB0aGlzLnJjID0gdGhpcy5yLnN2Zyh0aGlzLnN2Z05vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGRyYXdGcmFtZShsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIHVwOiBudW1iZXIsIGRvd246IG51bWJlcik6IHZvaWQge1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBzZXRPcHRpb25zKG9wdGlvbnM6IFJvdWdoT3B0aW9ucyk6IHZvaWQge1xyXG4gICAgICAgIGlmIChvcHRpb25zLnN0cm9rZVdpZHRoKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuc3Ryb2tlV2lkdGggKj0gdGhpcy5fc2NhbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICBjbGVhckNhbnZhcygpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5zdmdOb2RlKSB7XHJcbiAgICAgICAgICAgIC8vIEV4cGFuZGVkIHRvIGNvdmVyIHdob2xlIGRyYXduIGFyZWFcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnRXID0gd2luZG93LmlubmVyV2lkdGggKiAoVXRpbC5EUkFXX0lORkxBVEVfQU1PVU5UIC0gMSkgLyAyO1xyXG4gICAgICAgICAgICBjb25zdCBzdGFydEggPSB3aW5kb3cuaW5uZXJIZWlnaHQgKiAoVXRpbC5EUkFXX0lORkxBVEVfQU1PVU5UIC0gMSkgLyAyO1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdSZWN0YW5nbGUoLXN0YXJ0VywgLXN0YXJ0SCwgd2luZG93LmlubmVyV2lkdGggKiBVdGlsLkRSQVdfSU5GTEFURV9BTU9VTlQsIHdpbmRvdy5pbm5lckhlaWdodCAqIFV0aWwuRFJBV19JTkZMQVRFX0FNT1VOVCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kcmF3UmVjdGFuZ2xlKDAsIDAsIHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBkcmF3UmVjdGFuZ2xlKHg6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9zY2FsZSAhPT0gMSkge1xyXG4gICAgICAgICAgICB4ICo9IHRoaXMuX3NjYWxlO1xyXG4gICAgICAgICAgICB5ICo9IHRoaXMuX3NjYWxlO1xyXG4gICAgICAgICAgICB3aWR0aCAqPSB0aGlzLl9zY2FsZTtcclxuICAgICAgICAgICAgaGVpZ2h0ICo9IHRoaXMuX3NjYWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFwcGVuZFN2Z05vZGUodGhpcy5yYy5yZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgdGhpcy5vcHRpb25zKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZHJhd1BvbHlnb24ocG9seWdvbjogVmVjdG9yW10pOiB2b2lkIHtcclxuICAgICAgICBpZiAocG9seWdvbi5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX3NjYWxlICE9PSAxKSB7XHJcbiAgICAgICAgICAgIHBvbHlnb24gPSBwb2x5Z29uLm1hcCh2ID0+IHYuY2xvbmUoKS5tdWx0aXBseVNjYWxhcih0aGlzLl9zY2FsZSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5hcHBlbmRTdmdOb2RlKHRoaXMucmMucG9seWdvbihwb2x5Z29uLm1hcCh2ID0+IFt2LngsIHYueV0pLCB0aGlzLm9wdGlvbnMpKTtcclxuICAgIH1cclxuXHJcbiAgICBkcmF3U3F1YXJlKGNlbnRyZTogVmVjdG9yLCByYWRpdXM6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHByZXZTdHJva2UgPSB0aGlzLm9wdGlvbnMuc3Ryb2tlO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucy5zdHJva2UgPSAnbm9uZSc7XHJcbiAgICAgICAgdGhpcy5kcmF3UmVjdGFuZ2xlKGNlbnRyZS54IC0gcmFkaXVzLCBjZW50cmUueSAtIHJhZGl1cywgMiAqIHJhZGl1cywgMiAqIHJhZGl1cyk7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zLnN0cm9rZSA9IHByZXZTdHJva2U7XHJcbiAgICB9XHJcblxyXG4gICAgZHJhd1BvbHlsaW5lKGxpbmU6IFZlY3RvcltdKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoIDwgMikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5fc2NhbGUgIT09IDEpIHtcclxuICAgICAgICAgICAgbGluZSA9IGxpbmUubWFwKHYgPT4gdi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHRoaXMuX3NjYWxlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmFwcGVuZFN2Z05vZGUodGhpcy5yYy5saW5lYXJQYXRoKGxpbmUubWFwKHYgPT4gW3YueCwgdi55XSksIHRoaXMub3B0aW9ucykpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XHJcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcclxuaW1wb3J0IFV0aWwgZnJvbSAnLi4vdXRpbCc7XHJcblxyXG4vKipcclxuICogU2luZ2xldG9uXHJcbiAqIENvbnRyb2xzIHBhbm5pbmcgYW5kIHpvb21pbmdcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvbWFpbkNvbnRyb2xsZXIge1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IERvbWFpbkNvbnRyb2xsZXI7XHJcblxyXG4gICAgcHJpdmF0ZSByZWFkb25seSBaT09NX1NQRUVEID0gMC45NjtcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgU0NST0xMX0RFTEFZID0gMTAwO1xyXG5cclxuICAgIC8vIExvY2F0aW9uIG9mIHNjcmVlbiBvcmlnaW4gaW4gd29ybGQgc3BhY2VcclxuICAgIHByaXZhdGUgX29yaWdpbjogVmVjdG9yID0gVmVjdG9yLnplcm9WZWN0b3IoKTtcclxuICAgIFxyXG4gICAgLy8gU2NyZWVuLXNwYWNlIHdpZHRoIGFuZCBoZWlnaHRcclxuICAgIHByaXZhdGUgX3NjcmVlbkRpbWVuc2lvbnMgPSBWZWN0b3IuemVyb1ZlY3RvcigpO1xyXG5cclxuICAgIC8vIFJhdGlvIG9mIHNjcmVlbiBwaXhlbHMgdG8gd29ybGQgcGl4ZWxzXHJcbiAgICBwcml2YXRlIF96b29tOiBudW1iZXIgPSAxO1xyXG4gICAgcHJpdmF0ZSB6b29tQ2FsbGJhY2s6ICgpID0+IGFueSA9ICgpID0+IHt9O1xyXG4gICAgcHJpdmF0ZSBsYXN0U2Nyb2xsdGltZSA9IC10aGlzLlNDUk9MTF9ERUxBWTtcclxuICAgIHByaXZhdGUgcmVmcmVzaGVkQWZ0ZXJTY3JvbGwgPSBmYWxzZTtcclxuXHJcbiAgICBwcml2YXRlIF9jYW1lcmFEaXJlY3Rpb24gPSBWZWN0b3IuemVyb1ZlY3RvcigpO1xyXG4gICAgcHJpdmF0ZSBfb3J0aG9ncmFwaGljID0gZmFsc2U7XHJcblxyXG4gICAgLy8gU2V0IGFmdGVyIHBhbiBvciB6b29tXHJcbiAgICBwdWJsaWMgbW92ZWQgPSBmYWxzZTtcclxuXHJcblxyXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnNldFNjcmVlbkRpbWVuc2lvbnMoKTtcclxuXHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsICgpOiB2b2lkID0+IHRoaXMuc2V0U2NyZWVuRGltZW5zaW9ucygpKTtcclxuXHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgKGU6IGFueSk6IHZvaWQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZS50YXJnZXQuaWQgPT09IFV0aWwuQ0FOVkFTX0lEKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RTY3JvbGx0aW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaGVkQWZ0ZXJTY3JvbGwgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhOiBudW1iZXIgPSBlLmRlbHRhWTtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gc2NhbGUgYnkgdmFsdWUgb2YgZGVsdGFcclxuICAgICAgICAgICAgICAgIGlmIChkZWx0YSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnpvb20gPSB0aGlzLl96b29tICogdGhpcy5aT09NX1NQRUVEO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnpvb20gPSB0aGlzLl96b29tIC8gdGhpcy5aT09NX1NQRUVEO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byBzdG9wIGRyYXdpbmcgYnVpbGRpbmdzIHdoaWxlIHNjcm9sbGluZyBmb3IgY2VydGFpbiBzdHlsZXNcclxuICAgICAqIHRvIGtlZXAgdGhlIGZyYW1lcmF0ZSB1cFxyXG4gICAgICovXHJcbiAgICBnZXQgaXNTY3JvbGxpbmcoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSB0aGlzLmxhc3RTY3JvbGx0aW1lIDwgdGhpcy5TQ1JPTExfREVMQVk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzZXRTY3JlZW5EaW1lbnNpb25zKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3NjcmVlbkRpbWVuc2lvbnMuc2V0WCh3aW5kb3cuaW5uZXJXaWR0aCk7XHJcbiAgICAgICAgdGhpcy5fc2NyZWVuRGltZW5zaW9ucy5zZXRZKHdpbmRvdy5pbm5lckhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBEb21haW5Db250cm9sbGVyIHtcclxuICAgICAgICBpZiAoIURvbWFpbkNvbnRyb2xsZXIuaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgRG9tYWluQ29udHJvbGxlci5pbnN0YW5jZSA9IG5ldyBEb21haW5Db250cm9sbGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBEb21haW5Db250cm9sbGVyLmluc3RhbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtWZWN0b3J9IGRlbHRhIGluIHdvcmxkIHNwYWNlXHJcbiAgICAgKi9cclxuICAgIHBhbihkZWx0YTogVmVjdG9yKSB7XHJcbiAgICAgICAgdGhpcy5tb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fb3JpZ2luLnN1YihkZWx0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTY3JlZW4gb3JpZ2luIGluIHdvcmxkIHNwYWNlXHJcbiAgICAgKi9cclxuICAgIGdldCBvcmlnaW4oKTogVmVjdG9yIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb3JpZ2luLmNsb25lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHpvb20oKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fem9vbTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgc2NyZWVuRGltZW5zaW9ucygpOiBWZWN0b3Ige1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zY3JlZW5EaW1lbnNpb25zLmNsb25lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtWZWN0b3J9IHdvcmxkLXNwYWNlIHcvaCB2aXNpYmxlIG9uIHNjcmVlblxyXG4gICAgICovXHJcbiAgICBnZXQgd29ybGREaW1lbnNpb25zKCk6IFZlY3RvciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuRGltZW5zaW9ucy5kaXZpZGVTY2FsYXIodGhpcy5fem9vbSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IHNjcmVlbkRpbWVuc2lvbnModjogVmVjdG9yKSB7XHJcbiAgICAgICAgdGhpcy5tb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fc2NyZWVuRGltZW5zaW9ucy5jb3B5KHYpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCB6b29tKHo6IG51bWJlcikge1xyXG4gICAgICAgIGlmICh6ID49IDAuMyAmJiB6IDw9IDIwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zdCBvbGRXb3JsZFNwYWNlTWlkcG9pbnQgPSB0aGlzLm9yaWdpbi5hZGQodGhpcy53b3JsZERpbWVuc2lvbnMuZGl2aWRlU2NhbGFyKDIpKTtcclxuICAgICAgICAgICAgdGhpcy5fem9vbSA9IHo7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1dvcmxkU3BhY2VNaWRwb2ludCA9IHRoaXMub3JpZ2luLmFkZCh0aGlzLndvcmxkRGltZW5zaW9ucy5kaXZpZGVTY2FsYXIoMikpO1xyXG4gICAgICAgICAgICB0aGlzLnBhbihuZXdXb3JsZFNwYWNlTWlkcG9pbnQuc3ViKG9sZFdvcmxkU3BhY2VNaWRwb2ludCkpO1xyXG4gICAgICAgICAgICB0aGlzLnpvb21DYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvblNjcmVlbih2OiBWZWN0b3IpOiBib29sZWFuIHtcclxuICAgICAgICBjb25zdCBzY3JlZW5TcGFjZSA9IHRoaXMud29ybGRUb1NjcmVlbih2LmNsb25lKCkpO1xyXG4gICAgICAgIHJldHVybiBzY3JlZW5TcGFjZS54ID49IDAgJiYgc2NyZWVuU3BhY2UueSA+PSAwXHJcbiAgICAgICAgICAgICYmIHNjcmVlblNwYWNlLnggPD0gdGhpcy5zY3JlZW5EaW1lbnNpb25zLnggJiYgc2NyZWVuU3BhY2UueSA8PSB0aGlzLnNjcmVlbkRpbWVuc2lvbnMueTtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgb3J0aG9ncmFwaGljKHY6IGJvb2xlYW4pIHtcclxuICAgICAgICB0aGlzLl9vcnRob2dyYXBoaWMgPSB2O1xyXG4gICAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBvcnRob2dyYXBoaWMoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29ydGhvZ3JhcGhpYztcclxuICAgIH1cclxuXHJcbiAgICBzZXQgY2FtZXJhRGlyZWN0aW9uKHY6IFZlY3Rvcikge1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYURpcmVjdGlvbiA9IHY7XHJcbiAgICAgICAgLy8gU2NyZWVuIHVwZGF0ZVxyXG4gICAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBjYW1lcmFEaXJlY3Rpb24oKTogVmVjdG9yIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2FtZXJhRGlyZWN0aW9uLmNsb25lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Q2FtZXJhUG9zaXRpb24oKTogVmVjdG9yIHtcclxuICAgICAgICBjb25zdCBjZW50cmUgPSBuZXcgVmVjdG9yKHRoaXMuX3NjcmVlbkRpbWVuc2lvbnMueCAvIDIsIHRoaXMuX3NjcmVlbkRpbWVuc2lvbnMueSAvIDIpO1xyXG4gICAgICAgIGlmICh0aGlzLl9vcnRob2dyYXBoaWMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNlbnRyZS5hZGQoY2VudHJlLmNsb25lKCkubXVsdGlwbHkodGhpcy5fY2FtZXJhRGlyZWN0aW9uKS5tdWx0aXBseVNjYWxhcigxMDApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNlbnRyZS5hZGQoY2VudHJlLmNsb25lKCkubXVsdGlwbHkodGhpcy5fY2FtZXJhRGlyZWN0aW9uKSk7XHJcbiAgICAgICAgLy8gdGhpcy5zY3JlZW5EaW1lbnNpb25zLmRpdmlkZVNjYWxhcigyKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRab29tVXBkYXRlKGNhbGxiYWNrOiAoKSA9PiBhbnkpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnpvb21DYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRWRpdHMgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHpvb21Ub1dvcmxkKHY6IFZlY3Rvcik6IFZlY3RvciB7XHJcbiAgICAgICAgcmV0dXJuIHYuZGl2aWRlU2NhbGFyKHRoaXMuX3pvb20pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRWRpdHMgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHpvb21Ub1NjcmVlbih2OiBWZWN0b3IpOiBWZWN0b3Ige1xyXG4gICAgICAgIHJldHVybiB2Lm11bHRpcGx5U2NhbGFyKHRoaXMuX3pvb20pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRWRpdHMgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHNjcmVlblRvV29ybGQodjogVmVjdG9yKTogVmVjdG9yIHtcclxuICAgICAgICByZXR1cm4gdGhpcy56b29tVG9Xb3JsZCh2KS5hZGQodGhpcy5fb3JpZ2luKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEVkaXRzIHZlY3RvclxyXG4gICAgICovXHJcbiAgICB3b3JsZFRvU2NyZWVuKHY6IFZlY3Rvcik6IFZlY3RvciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuem9vbVRvU2NyZWVuKHYuc3ViKHRoaXMuX29yaWdpbikpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XHJcbmltcG9ydCBpbnRlcmFjdCBmcm9tICdpbnRlcmFjdGpzJztcclxuaW1wb3J0IFV0aWwgZnJvbSAnLi4vdXRpbCc7XHJcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vVmVjdG9yJztcclxuaW1wb3J0IERvbWFpbkNvbnRyb2xsZXIgZnJvbSAnLi9kb21haW5fY29udHJvbGxlcic7XHJcblxyXG5pbnRlcmZhY2UgRHJhZ2dhYmxlIHtcclxuICAgIGdldENlbnRyZTogKCgpID0+IFZlY3Rvcik7XHJcbiAgICBzdGFydExpc3RlbmVyOiAoKCkgPT4gdm9pZCk7XHJcbiAgICBtb3ZlTGlzdGVuZXI6ICgodjogVmVjdG9yKSA9PiB2b2lkKTtcclxufVxyXG5cclxuLyoqXHJcbiogUmVnaXN0ZXIgbXVsdGlwbGUgY2VudHJlIHBvaW50c1xyXG4qIENsb3Nlc3Qgb25lIHRvIG1vdXNlIGNsaWNrIHdpbGwgYmUgc2VsZWN0ZWQgdG8gZHJhZ1xyXG4qIFVwIHRvIGNhbGxlciB0byBhY3R1YWxseSBtb3ZlIHRoZWlyIGNlbnRyZSBwb2ludCB2aWEgY2FsbGJhY2tcclxuKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRHJhZ0NvbnRyb2xsZXIge1xyXG4gICAgLy8gSG93IGNsb3NlIHRvIGRyYWcgaGFuZGxlIHBvaW50ZXIgbmVlZHMgdG8gYmVcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgTUlOX0RSQUdfRElTVEFOQ0UgPSA1MDtcclxuXHJcbiAgICBwcml2YXRlIGRyYWdnYWJsZXM6IERyYWdnYWJsZVtdID0gW107XHJcbiAgICBwcml2YXRlIGN1cnJlbnRseURyYWdnaW5nOiBEcmFnZ2FibGUgPSBudWxsOyAgLy8gVGVuc29yIGZpZWxkXHJcbiAgICBwcml2YXRlIF9pc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIGRvbWFpbkNvbnRyb2xsZXIgPSBEb21haW5Db250cm9sbGVyLmdldEluc3RhbmNlKCk7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBndWk6IGRhdC5HVUkpIHtcclxuICAgICAgICBpbnRlcmFjdChgIyR7VXRpbC5DQU5WQVNfSUR9YCkuZHJhZ2dhYmxlKHtcclxuICAgICAgICAgICAgb25zdGFydDogdGhpcy5kcmFnU3RhcnQuYmluZCh0aGlzKSxcclxuICAgICAgICAgICAgb25tb3ZlOiB0aGlzLmRyYWdNb3ZlLmJpbmQodGhpcyksXHJcbiAgICAgICAgICAgIG9uZW5kOiB0aGlzLmRyYWdFbmQuYmluZCh0aGlzKSxcclxuICAgICAgICAgICAgY3Vyc29yQ2hlY2tlcjogdGhpcy5nZXRDdXJzb3IuYmluZCh0aGlzKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBzZXREcmFnRGlzYWJsZWQoZGlzYWJsZTogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBkaXNhYmxlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlIGN1cnNvciBzdHlsZVxyXG4gICAgICovXHJcbiAgICBnZXRDdXJzb3IoYWN0aW9uOiBhbnksIGludGVyYWN0YWJsZTogYW55LCBlbGVtZW50OiBhbnksIGludGVyYWN0aW5nOiBib29sZWFuKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAoaW50ZXJhY3RpbmcpIHJldHVybiAnZ3JhYmJpbmcnO1xyXG4gICAgICAgIHJldHVybiAnZ3JhYic7XHJcbiAgICB9XHJcblxyXG4gICAgZHJhZ1N0YXJ0KGV2ZW50OiBhbnkpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICAvLyBUcmFuc2Zvcm0gc2NyZWVuIHNwYWNlIHRvIHdvcmxkIHNwYWNlXHJcbiAgICAgICAgY29uc3Qgb3JpZ2luID0gdGhpcy5kb21haW5Db250cm9sbGVyLnNjcmVlblRvV29ybGQobmV3IFZlY3RvcihldmVudC54MCwgZXZlbnQueTApKTtcclxuICAgICAgICBcclxuICAgICAgICBsZXQgY2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XHJcbiAgICAgICAgdGhpcy5kcmFnZ2FibGVzLmZvckVhY2goZHJhZ2dhYmxlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZCA9IGRyYWdnYWJsZS5nZXRDZW50cmUoKS5kaXN0YW5jZVRvKG9yaWdpbik7XHJcbiAgICAgICAgICAgIGlmIChkIDwgY2xvc2VzdERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBjbG9zZXN0RGlzdGFuY2UgPSBkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50bHlEcmFnZ2luZyA9IGRyYWdnYWJsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBab29tIHNjcmVlbiBzaXplIHRvIHdvcmxkIHNpemUgZm9yIGNvbnNpc3RlbnQgZHJhZyBkaXN0YW5jZSB3aGlsZSB6b29tZWQgaW5cclxuICAgICAgICBjb25zdCBzY2FsZWREcmFnRGlzdGFuY2UgPSB0aGlzLk1JTl9EUkFHX0RJU1RBTkNFIC8gdGhpcy5kb21haW5Db250cm9sbGVyLnpvb207XHJcblxyXG4gICAgICAgIGlmIChjbG9zZXN0RGlzdGFuY2UgPiBzY2FsZWREcmFnRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50bHlEcmFnZ2luZyA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50bHlEcmFnZ2luZy5zdGFydExpc3RlbmVyKCk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZHJhZ01vdmUoZXZlbnQ6IGFueSk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGRlbHRhID0gbmV3IFZlY3RvcihldmVudC5kZWx0YS54LCBldmVudC5kZWx0YS55KTtcclxuICAgICAgICB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbVRvV29ybGQoZGVsdGEpO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy5jdXJyZW50bHlEcmFnZ2luZyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBEcmFnIGZpZWxkXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudGx5RHJhZ2dpbmcubW92ZUxpc3RlbmVyKGRlbHRhKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBNb3ZlIG1hcFxyXG4gICAgICAgICAgICB0aGlzLmRvbWFpbkNvbnRyb2xsZXIucGFuKGRlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZHJhZ0VuZCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLnBhbihWZWN0b3IuemVyb1ZlY3RvcigpKTsgIC8vIFRyaWdnZXJzIGNhbnZhcyB1cGRhdGVcclxuICAgICAgICB0aGlzLmN1cnJlbnRseURyYWdnaW5nID0gbnVsbDtcclxuICAgICAgICBVdGlsLnVwZGF0ZUd1aSh0aGlzLmd1aSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGlzRHJhZ2dpbmcoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRHJhZ2dpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0geygoKSA9PiBWZWN0b3IpfSBHZXRzIGNlbnRyZSBwb2ludFxyXG4gICAgICogQHBhcmFtIHsoKHY6IFZlY3RvcikgPT4gdm9pZCl9IENhbGxlZCBvbiBtb3ZlIHdpdGggZGVsdGEgdmVjdG9yXHJcbiAgICAgKiBAcGFyYW0geygoKSA9PiB2b2lkKX0gQ2FsbGVkIG9uIHN0YXJ0XHJcbiAgICAgKiBAcmV0dXJucyB7KCgpID0+IHZvaWQpfSBGdW5jdGlvbiB0byBkZXJlZ2lzdGVyIGNhbGxiYWNrXHJcbiAgICAgKi9cclxuICAgIHJlZ2lzdGVyKGdldENlbnRyZTogKCgpID0+IFZlY3RvciksXHJcbiAgICAgICAgICAgICBvbk1vdmU6ICgodjogVmVjdG9yKSA9PiB2b2lkKSxcclxuICAgICAgICAgICAgIG9uU3RhcnQ6ICgoKSA9PiB2b2lkKSxcclxuICAgICAgICAgICAgICk6ICgoKSA9PiB2b2lkKSB7XHJcbiAgICAgICAgY29uc3QgZHJhZ2dhYmxlOiBEcmFnZ2FibGUgPSB7XHJcbiAgICAgICAgICAgIGdldENlbnRyZTogZ2V0Q2VudHJlLFxyXG4gICAgICAgICAgICBtb3ZlTGlzdGVuZXI6IG9uTW92ZSxcclxuICAgICAgICAgICAgc3RhcnRMaXN0ZW5lcjogb25TdGFydCxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmRyYWdnYWJsZXMucHVzaChkcmFnZ2FibGUpO1xyXG4gICAgICAgIHJldHVybiAoKCk6IHZvaWQgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZHJhZ2dhYmxlcy5pbmRleE9mKGRyYWdnYWJsZSk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnYWJsZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLmJpbmQodGhpcyk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcclxuaW1wb3J0IERvbWFpbkNvbnRyb2xsZXIgZnJvbSAnLi9kb21haW5fY29udHJvbGxlcic7XHJcbmltcG9ydCBUZW5zb3JGaWVsZCBmcm9tICcuLi9pbXBsL3RlbnNvcl9maWVsZCc7XHJcbmltcG9ydCB7Uks0SW50ZWdyYXRvcn0gZnJvbSAnLi4vaW1wbC9pbnRlZ3JhdG9yJztcclxuaW1wb3J0IEZpZWxkSW50ZWdyYXRvciBmcm9tICcuLi9pbXBsL2ludGVncmF0b3InO1xyXG5pbXBvcnQge1N0cmVhbWxpbmVQYXJhbXN9IGZyb20gJy4uL2ltcGwvc3RyZWFtbGluZXMnO1xyXG5pbXBvcnQge1dhdGVyUGFyYW1zfSBmcm9tICcuLi9pbXBsL3dhdGVyX2dlbmVyYXRvcic7XHJcbmltcG9ydCBHcmFwaCBmcm9tICcuLi9pbXBsL2dyYXBoJztcclxuaW1wb3J0IFJvYWRHVUkgZnJvbSAnLi9yb2FkX2d1aSc7XHJcbmltcG9ydCBXYXRlckdVSSBmcm9tICcuL3dhdGVyX2d1aSc7XHJcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcclxuaW1wb3J0IFBvbHlnb25GaW5kZXIgZnJvbSAnLi4vaW1wbC9wb2x5Z29uX2ZpbmRlcic7XHJcbmltcG9ydCB7UG9seWdvblBhcmFtc30gZnJvbSAnLi4vaW1wbC9wb2x5Z29uX2ZpbmRlcic7XHJcbmltcG9ydCBTdHJlYW1saW5lR2VuZXJhdG9yIGZyb20gJy4uL2ltcGwvc3RyZWFtbGluZXMnO1xyXG5pbXBvcnQgV2F0ZXJHZW5lcmF0b3IgZnJvbSAnLi4vaW1wbC93YXRlcl9nZW5lcmF0b3InO1xyXG5pbXBvcnQgU3R5bGUgZnJvbSAnLi9zdHlsZSc7XHJcbmltcG9ydCB7RGVmYXVsdFN0eWxlLCBSb3VnaFN0eWxlfSBmcm9tICcuL3N0eWxlJztcclxuaW1wb3J0IENhbnZhc1dyYXBwZXIgZnJvbSAnLi9jYW52YXNfd3JhcHBlcic7XHJcbmltcG9ydCBCdWlsZGluZ3MsIHtCdWlsZGluZ01vZGVsfSBmcm9tICcuL2J1aWxkaW5ncyc7XHJcbmltcG9ydCBQb2x5Z29uVXRpbCBmcm9tICcuLi9pbXBsL3BvbHlnb25fdXRpbCc7XHJcblxyXG4vKipcclxuICogSGFuZGxlcyBNYXAgZm9sZGVyLCBnbHVlcyB0b2dldGhlciBpbXBsXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYWluR1VJIHtcclxuICAgIHByaXZhdGUgbnVtQmlnUGFya3M6IG51bWJlciA9IDI7XHJcbiAgICBwcml2YXRlIG51bVNtYWxsUGFya3M6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIGNsdXN0ZXJCaWdQYXJrczogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIHByaXZhdGUgZG9tYWluQ29udHJvbGxlciA9IERvbWFpbkNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgIHByaXZhdGUgaW50ZXJzZWN0aW9uczogVmVjdG9yW10gPSBbXTtcclxuICAgIHByaXZhdGUgYmlnUGFya3M6IFZlY3RvcltdW10gPSBbXTtcclxuICAgIHByaXZhdGUgc21hbGxQYXJrczogVmVjdG9yW11bXSA9IFtdO1xyXG4gICAgcHJpdmF0ZSBhbmltYXRlOiBib29sZWFuID0gdHJ1ZTtcclxuICAgIHByaXZhdGUgYW5pbWF0aW9uU3BlZWQ6IG51bWJlciA9IDMwO1xyXG5cclxuICAgIHByaXZhdGUgY29hc3RsaW5lOiBXYXRlckdVSTtcclxuICAgIHByaXZhdGUgbWFpblJvYWRzOiBSb2FkR1VJO1xyXG4gICAgcHJpdmF0ZSBtYWpvclJvYWRzOiBSb2FkR1VJO1xyXG4gICAgcHJpdmF0ZSBtaW5vclJvYWRzOiBSb2FkR1VJO1xyXG4gICAgcHJpdmF0ZSBidWlsZGluZ3M6IEJ1aWxkaW5ncztcclxuXHJcbiAgICAvLyBQYXJhbXNcclxuICAgIHByaXZhdGUgY29hc3RsaW5lUGFyYW1zOiBXYXRlclBhcmFtcztcclxuICAgIHByaXZhdGUgbWFpblBhcmFtczogU3RyZWFtbGluZVBhcmFtcztcclxuICAgIHByaXZhdGUgbWFqb3JQYXJhbXM6IFN0cmVhbWxpbmVQYXJhbXM7XHJcbiAgICBwcml2YXRlIG1pbm9yUGFyYW1zOiBTdHJlYW1saW5lUGFyYW1zID0ge1xyXG4gICAgICAgIGRzZXA6IDIwLFxyXG4gICAgICAgIGR0ZXN0OiAxNSxcclxuICAgICAgICBkc3RlcDogMSxcclxuICAgICAgICBkbG9va2FoZWFkOiA0MCxcclxuICAgICAgICBkY2lyY2xlam9pbjogNSxcclxuICAgICAgICBqb2luYW5nbGU6IDAuMSwgIC8vIGFwcHJveCAzMGRlZ1xyXG4gICAgICAgIHBhdGhJdGVyYXRpb25zOiAxMDAwLFxyXG4gICAgICAgIHNlZWRUcmllczogMzAwLFxyXG4gICAgICAgIHNpbXBsaWZ5VG9sZXJhbmNlOiAwLjUsXHJcbiAgICAgICAgY29sbGlkZUVhcmx5OiAwLFxyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIHJlZHJhdzogYm9vbGVhbiA9IHRydWU7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBndWlGb2xkZXI6IGRhdC5HVUksIHByaXZhdGUgdGVuc29yRmllbGQ6IFRlbnNvckZpZWxkLCBwcml2YXRlIGNsb3NlVGVuc29yRm9sZGVyOiAoKSA9PiB2b2lkKSB7XHJcbiAgICAgICAgZ3VpRm9sZGVyLmFkZCh0aGlzLCAnZ2VuZXJhdGVFdmVyeXRoaW5nJyk7XHJcbiAgICAgICAgLy8gZ3VpRm9sZGVyLmFkZCh0aGlzLCAnc2ltcGxlQmVuY2hNYXJrJyk7XHJcbiAgICAgICAgY29uc3QgYW5pbWF0ZUNvbnRyb2xsZXIgPSBndWlGb2xkZXIuYWRkKHRoaXMsICdhbmltYXRlJyk7XHJcbiAgICAgICAgZ3VpRm9sZGVyLmFkZCh0aGlzLCAnYW5pbWF0aW9uU3BlZWQnKTtcclxuXHJcbiAgICAgICAgdGhpcy5jb2FzdGxpbmVQYXJhbXMgPSBPYmplY3QuYXNzaWduKHtcclxuICAgICAgICAgICAgY29hc3ROb2lzZToge1xyXG4gICAgICAgICAgICAgICAgbm9pc2VFbmFibGVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgbm9pc2VTaXplOiAzMCxcclxuICAgICAgICAgICAgICAgIG5vaXNlQW5nbGU6IDIwLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByaXZlck5vaXNlOiB7XHJcbiAgICAgICAgICAgICAgICBub2lzZUVuYWJsZWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBub2lzZVNpemU6IDMwLFxyXG4gICAgICAgICAgICAgICAgbm9pc2VBbmdsZTogMjAsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJpdmVyQmFua1NpemU6IDEwLFxyXG4gICAgICAgICAgICByaXZlclNpemU6IDMwLFxyXG4gICAgICAgIH0sIHRoaXMubWlub3JQYXJhbXMpO1xyXG4gICAgICAgIHRoaXMuY29hc3RsaW5lUGFyYW1zLnBhdGhJdGVyYXRpb25zID0gMTAwMDA7XHJcbiAgICAgICAgdGhpcy5jb2FzdGxpbmVQYXJhbXMuc2ltcGxpZnlUb2xlcmFuY2UgPSAxMDtcclxuXHJcbiAgICAgICAgdGhpcy5tYWpvclBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMubWlub3JQYXJhbXMpO1xyXG4gICAgICAgIHRoaXMubWFqb3JQYXJhbXMuZHNlcCA9IDEwMDtcclxuICAgICAgICB0aGlzLm1ham9yUGFyYW1zLmR0ZXN0ID0gMzA7XHJcbiAgICAgICAgdGhpcy5tYWpvclBhcmFtcy5kbG9va2FoZWFkID0gMjAwO1xyXG4gICAgICAgIHRoaXMubWFqb3JQYXJhbXMuY29sbGlkZUVhcmx5ID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5tYWluUGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5taW5vclBhcmFtcyk7XHJcbiAgICAgICAgdGhpcy5tYWluUGFyYW1zLmRzZXAgPSA0MDA7XHJcbiAgICAgICAgdGhpcy5tYWluUGFyYW1zLmR0ZXN0ID0gMjAwO1xyXG4gICAgICAgIHRoaXMubWFpblBhcmFtcy5kbG9va2FoZWFkID0gNTAwO1xyXG4gICAgICAgIHRoaXMubWFpblBhcmFtcy5jb2xsaWRlRWFybHkgPSAwO1xyXG5cclxuICAgICAgICBjb25zdCBpbnRlZ3JhdG9yID0gbmV3IFJLNEludGVncmF0b3IodGVuc29yRmllbGQsIHRoaXMubWlub3JQYXJhbXMpO1xyXG4gICAgICAgIGNvbnN0IHJlZHJhdyA9ICgpID0+IHRoaXMucmVkcmF3ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5jb2FzdGxpbmUgPSBuZXcgV2F0ZXJHVUkodGVuc29yRmllbGQsIHRoaXMuY29hc3RsaW5lUGFyYW1zLCBpbnRlZ3JhdG9yLFxyXG4gICAgICAgICAgICB0aGlzLmd1aUZvbGRlciwgY2xvc2VUZW5zb3JGb2xkZXIsICdXYXRlcicsIHJlZHJhdykuaW5pdEZvbGRlcigpO1xyXG4gICAgICAgIHRoaXMubWFpblJvYWRzID0gbmV3IFJvYWRHVUkodGhpcy5tYWluUGFyYW1zLCBpbnRlZ3JhdG9yLCB0aGlzLmd1aUZvbGRlciwgY2xvc2VUZW5zb3JGb2xkZXIsICdNYWluJywgcmVkcmF3KS5pbml0Rm9sZGVyKCk7XHJcbiAgICAgICAgdGhpcy5tYWpvclJvYWRzID0gbmV3IFJvYWRHVUkodGhpcy5tYWpvclBhcmFtcywgaW50ZWdyYXRvciwgdGhpcy5ndWlGb2xkZXIsIGNsb3NlVGVuc29yRm9sZGVyLCAnTWFqb3InLCByZWRyYXcsIHRoaXMuYW5pbWF0ZSkuaW5pdEZvbGRlcigpO1xyXG4gICAgICAgIHRoaXMubWlub3JSb2FkcyA9IG5ldyBSb2FkR1VJKHRoaXMubWlub3JQYXJhbXMsIGludGVncmF0b3IsIHRoaXMuZ3VpRm9sZGVyLCBjbG9zZVRlbnNvckZvbGRlciwgJ01pbm9yJywgcmVkcmF3LCB0aGlzLmFuaW1hdGUpLmluaXRGb2xkZXIoKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBwYXJrcyA9IGd1aUZvbGRlci5hZGRGb2xkZXIoJ1BhcmtzJyk7XHJcbiAgICAgICAgcGFya3MuYWRkKHtHZW5lcmF0ZTogKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkaW5ncy5yZXNldCgpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZFBhcmtzKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVkcmF3ID0gdHJ1ZTtcclxuICAgICAgICB9fSwgJ0dlbmVyYXRlJyk7XHJcbiAgICAgICAgcGFya3MuYWRkKHRoaXMsICdjbHVzdGVyQmlnUGFya3MnKTtcclxuICAgICAgICBwYXJrcy5hZGQodGhpcywgJ251bUJpZ1BhcmtzJyk7XHJcbiAgICAgICAgcGFya3MuYWRkKHRoaXMsICdudW1TbWFsbFBhcmtzJyk7XHJcblxyXG4gICAgICAgIGNvbnN0IGJ1aWxkaW5nc0ZvbGRlciA9IGd1aUZvbGRlci5hZGRGb2xkZXIoJ0J1aWxkaW5ncycpO1xyXG4gICAgICAgIHRoaXMuYnVpbGRpbmdzID0gbmV3IEJ1aWxkaW5ncyh0ZW5zb3JGaWVsZCwgYnVpbGRpbmdzRm9sZGVyLCByZWRyYXcsIHRoaXMubWlub3JQYXJhbXMuZHN0ZXAsIHRoaXMuYW5pbWF0ZSk7XHJcbiAgICAgICAgdGhpcy5idWlsZGluZ3Muc2V0UHJlR2VuZXJhdGVDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFsbFN0cmVhbWxpbmVzID0gW107XHJcbiAgICAgICAgICAgIGFsbFN0cmVhbWxpbmVzLnB1c2goLi4udGhpcy5tYWluUm9hZHMuYWxsU3RyZWFtbGluZXMpO1xyXG4gICAgICAgICAgICBhbGxTdHJlYW1saW5lcy5wdXNoKC4uLnRoaXMubWFqb3JSb2Fkcy5hbGxTdHJlYW1saW5lcyk7XHJcbiAgICAgICAgICAgIGFsbFN0cmVhbWxpbmVzLnB1c2goLi4udGhpcy5taW5vclJvYWRzLmFsbFN0cmVhbWxpbmVzKTtcclxuICAgICAgICAgICAgYWxsU3RyZWFtbGluZXMucHVzaCguLi50aGlzLmNvYXN0bGluZS5zdHJlYW1saW5lc1dpdGhTZWNvbmRhcnlSb2FkKTtcclxuICAgICAgICAgICAgdGhpcy5idWlsZGluZ3Muc2V0QWxsU3RyZWFtbGluZXMoYWxsU3RyZWFtbGluZXMpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBhbmltYXRlQ29udHJvbGxlci5vbkNoYW5nZSgoYjogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm1ham9yUm9hZHMuYW5pbWF0ZSA9IGI7XHJcbiAgICAgICAgICAgIHRoaXMubWlub3JSb2Fkcy5hbmltYXRlID0gYjtcclxuICAgICAgICAgICAgdGhpcy5idWlsZGluZ3MuYW5pbWF0ZSA9IGI7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMubWlub3JSb2Fkcy5zZXRFeGlzdGluZ1N0cmVhbWxpbmVzKFt0aGlzLmNvYXN0bGluZSwgdGhpcy5tYWluUm9hZHMsIHRoaXMubWFqb3JSb2Fkc10pO1xyXG4gICAgICAgIHRoaXMubWFqb3JSb2Fkcy5zZXRFeGlzdGluZ1N0cmVhbWxpbmVzKFt0aGlzLmNvYXN0bGluZSwgdGhpcy5tYWluUm9hZHNdKTtcclxuICAgICAgICB0aGlzLm1haW5Sb2Fkcy5zZXRFeGlzdGluZ1N0cmVhbWxpbmVzKFt0aGlzLmNvYXN0bGluZV0pO1xyXG5cclxuICAgICAgICB0aGlzLmNvYXN0bGluZS5zZXRQcmVHZW5lcmF0ZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5tYWluUm9hZHMuY2xlYXJTdHJlYW1saW5lcygpO1xyXG4gICAgICAgICAgICB0aGlzLm1ham9yUm9hZHMuY2xlYXJTdHJlYW1saW5lcygpO1xyXG4gICAgICAgICAgICB0aGlzLm1pbm9yUm9hZHMuY2xlYXJTdHJlYW1saW5lcygpO1xyXG4gICAgICAgICAgICB0aGlzLmJpZ1BhcmtzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuc21hbGxQYXJrcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkaW5ncy5yZXNldCgpO1xyXG4gICAgICAgICAgICB0ZW5zb3JGaWVsZC5wYXJrcyA9IFtdO1xyXG4gICAgICAgICAgICB0ZW5zb3JGaWVsZC5zZWEgPSBbXTtcclxuICAgICAgICAgICAgdGVuc29yRmllbGQucml2ZXIgPSBbXTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5tYWluUm9hZHMuc2V0UHJlR2VuZXJhdGVDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubWFqb3JSb2Fkcy5jbGVhclN0cmVhbWxpbmVzKCk7XHJcbiAgICAgICAgICAgIHRoaXMubWlub3JSb2Fkcy5jbGVhclN0cmVhbWxpbmVzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYmlnUGFya3MgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5zbWFsbFBhcmtzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRpbmdzLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIHRlbnNvckZpZWxkLnBhcmtzID0gW107XHJcbiAgICAgICAgICAgIHRlbnNvckZpZWxkLmlnbm9yZVJpdmVyID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5tYWluUm9hZHMuc2V0UG9zdEdlbmVyYXRlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgICAgICB0ZW5zb3JGaWVsZC5pZ25vcmVSaXZlciA9IGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLm1ham9yUm9hZHMuc2V0UHJlR2VuZXJhdGVDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubWlub3JSb2Fkcy5jbGVhclN0cmVhbWxpbmVzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYmlnUGFya3MgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5zbWFsbFBhcmtzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRpbmdzLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIHRlbnNvckZpZWxkLnBhcmtzID0gW107XHJcbiAgICAgICAgICAgIHRlbnNvckZpZWxkLmlnbm9yZVJpdmVyID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5tYWpvclJvYWRzLnNldFBvc3RHZW5lcmF0ZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgdGVuc29yRmllbGQuaWdub3JlUml2ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5hZGRQYXJrcygpO1xyXG4gICAgICAgICAgICB0aGlzLnJlZHJhdyA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMubWlub3JSb2Fkcy5zZXRQcmVHZW5lcmF0ZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZGluZ3MucmVzZXQoKTtcclxuICAgICAgICAgICAgdGhpcy5zbWFsbFBhcmtzID0gW107XHJcbiAgICAgICAgICAgIHRlbnNvckZpZWxkLnBhcmtzID0gdGhpcy5iaWdQYXJrcztcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5taW5vclJvYWRzLnNldFBvc3RHZW5lcmF0ZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5hZGRQYXJrcygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGFkZFBhcmtzKCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGcgPSBuZXcgR3JhcGgodGhpcy5tYWpvclJvYWRzLmFsbFN0cmVhbWxpbmVzXHJcbiAgICAgICAgICAgIC5jb25jYXQodGhpcy5tYWluUm9hZHMuYWxsU3RyZWFtbGluZXMpXHJcbiAgICAgICAgICAgIC5jb25jYXQodGhpcy5taW5vclJvYWRzLmFsbFN0cmVhbWxpbmVzKSwgdGhpcy5taW5vclBhcmFtcy5kc3RlcCk7XHJcbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25zID0gZy5pbnRlcnNlY3Rpb25zO1xyXG5cclxuICAgICAgICBjb25zdCBwID0gbmV3IFBvbHlnb25GaW5kZXIoZy5ub2Rlcywge1xyXG4gICAgICAgICAgICAgICAgbWF4TGVuZ3RoOiAyMCxcclxuICAgICAgICAgICAgICAgIG1pbkFyZWE6IDgwLFxyXG4gICAgICAgICAgICAgICAgc2hyaW5rU3BhY2luZzogNCxcclxuICAgICAgICAgICAgICAgIGNoYW5jZU5vRGl2aWRlOiAxLFxyXG4gICAgICAgICAgICB9LCB0aGlzLnRlbnNvckZpZWxkKTtcclxuICAgICAgICBwLmZpbmRQb2x5Z29ucygpO1xyXG4gICAgICAgIGNvbnN0IHBvbHlnb25zID0gcC5wb2x5Z29ucztcclxuXHJcbiAgICAgICAgaWYgKHRoaXMubWlub3JSb2Fkcy5hbGxTdHJlYW1saW5lcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgLy8gQmlnIHBhcmtzXHJcbiAgICAgICAgICAgIHRoaXMuYmlnUGFya3MgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5zbWFsbFBhcmtzID0gW107XHJcbiAgICAgICAgICAgIGlmIChwb2x5Z29ucy5sZW5ndGggPiB0aGlzLm51bUJpZ1BhcmtzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jbHVzdGVyQmlnUGFya3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBHcm91cCBpbiBhZGphY2VudCBwb2x5Z29ucyBcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJrSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAocG9seWdvbnMubGVuZ3RoIC0gdGhpcy5udW1CaWdQYXJrcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBwYXJrSW5kZXg7IGkgPCBwYXJrSW5kZXggKyB0aGlzLm51bUJpZ1BhcmtzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iaWdQYXJrcy5wdXNoKHBvbHlnb25zW2ldKTsgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubnVtQmlnUGFya3M7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJrSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwb2x5Z29ucy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJpZ1BhcmtzLnB1c2gocG9seWdvbnNbcGFya0luZGV4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iaWdQYXJrcy5wdXNoKC4uLnBvbHlnb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFNtYWxsIHBhcmtzXHJcbiAgICAgICAgICAgIHRoaXMuc21hbGxQYXJrcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubnVtU21hbGxQYXJrczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJrSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwb2x5Z29ucy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zbWFsbFBhcmtzLnB1c2gocG9seWdvbnNbcGFya0luZGV4XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMudGVuc29yRmllbGQucGFya3MgPSBbXTtcclxuICAgICAgICB0aGlzLnRlbnNvckZpZWxkLnBhcmtzLnB1c2goLi4udGhpcy5iaWdQYXJrcyk7XHJcbiAgICAgICAgdGhpcy50ZW5zb3JGaWVsZC5wYXJrcy5wdXNoKC4uLnRoaXMuc21hbGxQYXJrcyk7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgZ2VuZXJhdGVFdmVyeXRoaW5nKCkge1xyXG4gICAgICAgIHRoaXMuY29hc3RsaW5lLmdlbmVyYXRlUm9hZHMoKTtcclxuICAgICAgICBhd2FpdCB0aGlzLm1haW5Sb2Fkcy5nZW5lcmF0ZVJvYWRzKCk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5tYWpvclJvYWRzLmdlbmVyYXRlUm9hZHModGhpcy5hbmltYXRlKTtcclxuICAgICAgICBhd2FpdCB0aGlzLm1pbm9yUm9hZHMuZ2VuZXJhdGVSb2Fkcyh0aGlzLmFuaW1hdGUpO1xyXG4gICAgICAgIHRoaXMucmVkcmF3ID0gdHJ1ZTtcclxuICAgICAgICBhd2FpdCB0aGlzLmJ1aWxkaW5ncy5nZW5lcmF0ZSh0aGlzLmFuaW1hdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZSgpIHtcclxuICAgICAgICBsZXQgY29udGludWVVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgd2hpbGUgKGNvbnRpbnVlVXBkYXRlICYmIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQgPCB0aGlzLmFuaW1hdGlvblNwZWVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pbm9yQ2hhbmdlZCA9IHRoaXMubWlub3JSb2Fkcy51cGRhdGUoKTtcclxuICAgICAgICAgICAgY29uc3QgbWFqb3JDaGFuZ2VkID0gdGhpcy5tYWpvclJvYWRzLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICBjb25zdCBtYWluQ2hhbmdlZCA9IHRoaXMubWFpblJvYWRzLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICBjb25zdCBidWlsZGluZ3NDaGFuZ2VkID0gdGhpcy5idWlsZGluZ3MudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlVXBkYXRlID0gbWlub3JDaGFuZ2VkIHx8IG1ham9yQ2hhbmdlZCB8fCBtYWluQ2hhbmdlZCB8fCBidWlsZGluZ3NDaGFuZ2VkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB0aGlzLnJlZHJhdyA9IHRoaXMucmVkcmF3IHx8IGNvbnRpbnVlVXBkYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIGRyYXcoc3R5bGU6IFN0eWxlLCBmb3JjZURyYXc9ZmFsc2UsIGN1c3RvbUNhbnZhcz86IENhbnZhc1dyYXBwZXIpOiB2b2lkIHtcclxuICAgICAgICBpZiAoIXN0eWxlLm5lZWRzVXBkYXRlICYmICFmb3JjZURyYXcgJiYgIXRoaXMucmVkcmF3ICYmICF0aGlzLmRvbWFpbkNvbnRyb2xsZXIubW92ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3R5bGUubmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmRvbWFpbkNvbnRyb2xsZXIubW92ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnJlZHJhdyA9IGZhbHNlO1xyXG5cclxuICAgICAgICBzdHlsZS5zZWFQb2x5Z29uID0gdGhpcy5jb2FzdGxpbmUuc2VhUG9seWdvbjtcclxuICAgICAgICBzdHlsZS5jb2FzdGxpbmUgPSB0aGlzLmNvYXN0bGluZS5jb2FzdGxpbmU7XHJcbiAgICAgICAgc3R5bGUucml2ZXIgPSB0aGlzLmNvYXN0bGluZS5yaXZlcjtcclxuICAgICAgICBzdHlsZS5sb3RzID0gdGhpcy5idWlsZGluZ3MubG90cztcclxuXHJcbiAgICAgICAgaWYgKHN0eWxlIGluc3RhbmNlb2YgRGVmYXVsdFN0eWxlICYmIHN0eWxlLnNob3dCdWlsZGluZ01vZGVscyB8fCBzdHlsZSBpbnN0YW5jZW9mIFJvdWdoU3R5bGUpIHtcclxuICAgICAgICAgICAgc3R5bGUuYnVpbGRpbmdNb2RlbHMgPSB0aGlzLmJ1aWxkaW5ncy5tb2RlbHM7ICAgIFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3R5bGUucGFya3MgPSBbXTtcclxuICAgICAgICBzdHlsZS5wYXJrcy5wdXNoKC4uLnRoaXMuYmlnUGFya3MubWFwKHAgPT4gcC5tYXAodiA9PiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGRUb1NjcmVlbih2LmNsb25lKCkpKSkpO1xyXG4gICAgICAgIHN0eWxlLnBhcmtzLnB1c2goLi4udGhpcy5zbWFsbFBhcmtzLm1hcChwID0+IHAubWFwKHYgPT4gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkVG9TY3JlZW4odi5jbG9uZSgpKSkpKTtcclxuICAgICAgICBzdHlsZS5taW5vclJvYWRzID0gdGhpcy5taW5vclJvYWRzLnJvYWRzO1xyXG4gICAgICAgIHN0eWxlLm1ham9yUm9hZHMgPSB0aGlzLm1ham9yUm9hZHMucm9hZHM7XHJcbiAgICAgICAgc3R5bGUubWFpblJvYWRzID0gdGhpcy5tYWluUm9hZHMucm9hZHM7XHJcbiAgICAgICAgc3R5bGUuY29hc3RsaW5lUm9hZHMgPSB0aGlzLmNvYXN0bGluZS5yb2FkcztcclxuICAgICAgICBzdHlsZS5zZWNvbmRhcnlSaXZlciA9IHRoaXMuY29hc3RsaW5lLnNlY29uZGFyeVJpdmVyO1xyXG4gICAgICAgIHN0eWxlLmRyYXcoY3VzdG9tQ2FudmFzKTtcclxuICAgIH1cclxuXHJcbiAgICByb2Fkc0VtcHR5KCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1ham9yUm9hZHMucm9hZHNFbXB0eSgpXHJcbiAgICAgICAgICAgICYmIHRoaXMubWlub3JSb2Fkcy5yb2Fkc0VtcHR5KClcclxuICAgICAgICAgICAgJiYgdGhpcy5tYWluUm9hZHMucm9hZHNFbXB0eSgpXHJcbiAgICAgICAgICAgICYmIHRoaXMuY29hc3RsaW5lLnJvYWRzRW1wdHkoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBPQkogRXhwb3J0IG1ldGhvZHNcclxuXHJcbiAgICBwdWJsaWMgZ2V0IHNlYVBvbHlnb24oKTogVmVjdG9yW10ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvYXN0bGluZS5zZWFQb2x5Z29uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgcml2ZXJQb2x5Z29uKCk6IFZlY3RvcltdIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2FzdGxpbmUucml2ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBidWlsZGluZ01vZGVscygpOiBCdWlsZGluZ01vZGVsW10ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkaW5ncy5tb2RlbHM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEJsb2NrcygpOiBQcm9taXNlPFZlY3RvcltdW10+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5idWlsZGluZ3MuZ2V0QmxvY2tzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBtaW5vclJvYWRQb2x5Z29ucygpOiBWZWN0b3JbXVtdIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5taW5vclJvYWRzLnJvYWRzLm1hcChyID0+IFBvbHlnb25VdGlsLnJlc2l6ZUdlb21ldHJ5KHIsIDEgKiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSwgZmFsc2UpKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IG1ham9yUm9hZFBvbHlnb25zKCk6IFZlY3RvcltdW10ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1ham9yUm9hZHMucm9hZHMuY29uY2F0KFt0aGlzLmNvYXN0bGluZS5zZWNvbmRhcnlSaXZlcl0pLm1hcChyID0+IFBvbHlnb25VdGlsLnJlc2l6ZUdlb21ldHJ5KHIsIDIgKiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSwgZmFsc2UpKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IG1haW5Sb2FkUG9seWdvbnMoKTogVmVjdG9yW11bXSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFpblJvYWRzLnJvYWRzLmNvbmNhdCh0aGlzLmNvYXN0bGluZS5yb2FkcykubWFwKHIgPT4gUG9seWdvblV0aWwucmVzaXplR2VvbWV0cnkociwgMi41ICogdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20sIGZhbHNlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBjb2FzdGxpbmVQb2x5Z29uKCk6IFZlY3RvcltdIHtcclxuICAgICAgICByZXR1cm4gUG9seWdvblV0aWwucmVzaXplR2VvbWV0cnkodGhpcy5jb2FzdGxpbmUuY29hc3RsaW5lLCAxNSAqIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tLCBmYWxzZSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcclxuaW1wb3J0IENhbnZhc1dyYXBwZXIgZnJvbSAnLi9jYW52YXNfd3JhcHBlcic7XHJcbmltcG9ydCBEb21haW5Db250cm9sbGVyIGZyb20gJy4vZG9tYWluX2NvbnRyb2xsZXInO1xyXG5pbXBvcnQgVXRpbCBmcm9tICcuLi91dGlsJztcclxuaW1wb3J0IEZpZWxkSW50ZWdyYXRvciBmcm9tICcuLi9pbXBsL2ludGVncmF0b3InO1xyXG5pbXBvcnQge1N0cmVhbWxpbmVQYXJhbXN9IGZyb20gJy4uL2ltcGwvc3RyZWFtbGluZXMnO1xyXG5pbXBvcnQgU3RyZWFtbGluZUdlbmVyYXRvciBmcm9tICcuLi9pbXBsL3N0cmVhbWxpbmVzJztcclxuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xyXG5cclxuLyoqXHJcbiAqIEhhbmRsZXMgY3JlYXRpb24gb2Ygcm9hZHNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvYWRHVUkge1xyXG4gICAgcHJvdGVjdGVkIHN0cmVhbWxpbmVzOiBTdHJlYW1saW5lR2VuZXJhdG9yO1xyXG4gICAgcHJpdmF0ZSBleGlzdGluZ1N0cmVhbWxpbmVzOiBSb2FkR1VJW10gPSBbXTtcclxuICAgIHByb3RlY3RlZCBkb21haW5Db250cm9sbGVyID0gRG9tYWluQ29udHJvbGxlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgcHJvdGVjdGVkIHByZUdlbmVyYXRlQ2FsbGJhY2s6ICgpID0+IGFueSA9ICgpID0+IHt9O1xyXG4gICAgcHJvdGVjdGVkIHBvc3RHZW5lcmF0ZUNhbGxiYWNrOiAoKSA9PiBhbnkgPSAoKSA9PiB7fTtcclxuXHJcbiAgICBwcml2YXRlIHN0cmVhbWxpbmVzSW5Qcm9ncmVzczogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBwYXJhbXM6IFN0cmVhbWxpbmVQYXJhbXMsXHJcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgaW50ZWdyYXRvcjogRmllbGRJbnRlZ3JhdG9yLFxyXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIGd1aUZvbGRlcjogZGF0LkdVSSxcclxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBjbG9zZVRlbnNvckZvbGRlcjogKCkgPT4gdm9pZCxcclxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBmb2xkZXJOYW1lOiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcmVkcmF3OiAoKSA9PiB2b2lkLFxyXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIF9hbmltYXRlPWZhbHNlKSB7XHJcbiAgICAgICAgdGhpcy5zdHJlYW1saW5lcyA9IG5ldyBTdHJlYW1saW5lR2VuZXJhdG9yKFxyXG4gICAgICAgICAgICB0aGlzLmludGVncmF0b3IsIHRoaXMuZG9tYWluQ29udHJvbGxlci5vcmlnaW4sXHJcbiAgICAgICAgICAgIHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZERpbWVuc2lvbnMsIHRoaXMucGFyYW1zKTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHBhdGggaXRlcmF0aW9ucyBiYXNlZCBvbiB3aW5kb3cgc2l6ZVxyXG4gICAgICAgIHRoaXMuc2V0UGF0aEl0ZXJhdGlvbnMoKTtcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCk6IHZvaWQgPT4gdGhpcy5zZXRQYXRoSXRlcmF0aW9ucygpKTtcclxuICAgIH1cclxuXHJcbiAgICBpbml0Rm9sZGVyKCk6IFJvYWRHVUkge1xyXG4gICAgICAgIGNvbnN0IHJvYWRHVUkgPSB7XHJcbiAgICAgICAgICAgIEdlbmVyYXRlOiAoKSA9PiB0aGlzLmdlbmVyYXRlUm9hZHModGhpcy5fYW5pbWF0ZSkudGhlbigoKSA9PiB0aGlzLnJlZHJhdygpKSxcclxuICAgICAgICAgICAgSm9pbkRhbmdsaW5nOiAoKTogdm9pZCA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbWxpbmVzLmpvaW5EYW5nbGluZ1N0cmVhbWxpbmVzKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZHJhdygpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IGZvbGRlciA9IHRoaXMuZ3VpRm9sZGVyLmFkZEZvbGRlcih0aGlzLmZvbGRlck5hbWUpO1xyXG4gICAgICAgIGZvbGRlci5hZGQocm9hZEdVSSwgJ0dlbmVyYXRlJyk7XHJcbiAgICAgICAgLy8gZm9sZGVyLmFkZChyb2FkR1VJLCAnSm9pbkRhbmdsaW5nJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgcGFyYW1zRm9sZGVyID0gZm9sZGVyLmFkZEZvbGRlcignUGFyYW1zJyk7XHJcbiAgICAgICAgcGFyYW1zRm9sZGVyLmFkZCh0aGlzLnBhcmFtcywgJ2RzZXAnKTtcclxuICAgICAgICBwYXJhbXNGb2xkZXIuYWRkKHRoaXMucGFyYW1zLCAnZHRlc3QnKTtcclxuXHJcbiAgICAgICAgY29uc3QgZGV2UGFyYW1zRm9sZGVyID0gcGFyYW1zRm9sZGVyLmFkZEZvbGRlcignRGV2Jyk7XHJcbiAgICAgICAgdGhpcy5hZGREZXZQYXJhbXNUb0ZvbGRlcih0aGlzLnBhcmFtcywgZGV2UGFyYW1zRm9sZGVyKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBzZXQgYW5pbWF0ZShiOiBib29sZWFuKSB7XHJcbiAgICAgICAgdGhpcy5fYW5pbWF0ZSA9IGI7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGFsbFN0cmVhbWxpbmVzKCk6IFZlY3RvcltdW10ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbWxpbmVzLmFsbFN0cmVhbWxpbmVzU2ltcGxlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCByb2FkcygpOiBWZWN0b3JbXVtdIHtcclxuICAgICAgICAvLyBGb3IgZHJhd2luZyBub3QgZ2VuZXJhdGlvbiwgcHJvYmFibHkgZmluZSB0byBsZWF2ZSBtYXBcclxuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1saW5lcy5hbGxTdHJlYW1saW5lc1NpbXBsZS5tYXAocyA9PlxyXG4gICAgICAgICAgICBzLm1hcCh2ID0+IHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZFRvU2NyZWVuKHYuY2xvbmUoKSkpXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByb2Fkc0VtcHR5KCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbWxpbmVzLmFsbFN0cmVhbWxpbmVzU2ltcGxlLmxlbmd0aCA9PT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBzZXRFeGlzdGluZ1N0cmVhbWxpbmVzKGV4aXN0aW5nU3RyZWFtbGluZXM6IFJvYWRHVUlbXSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZXhpc3RpbmdTdHJlYW1saW5lcyA9IGV4aXN0aW5nU3RyZWFtbGluZXM7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0UHJlR2VuZXJhdGVDYWxsYmFjayhjYWxsYmFjazogKCkgPT4gYW55KSB7XHJcbiAgICAgICAgdGhpcy5wcmVHZW5lcmF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0UG9zdEdlbmVyYXRlQ2FsbGJhY2soY2FsbGJhY2s6ICgpID0+IGFueSkge1xyXG4gICAgICAgIHRoaXMucG9zdEdlbmVyYXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgIH1cclxuXHJcbiAgICBjbGVhclN0cmVhbWxpbmVzKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuc3RyZWFtbGluZXMuY2xlYXJTdHJlYW1saW5lcygpO1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGdlbmVyYXRlUm9hZHMoYW5pbWF0ZT1mYWxzZSk6IFByb21pc2U8dW5rbm93bj4ge1xyXG4gICAgICAgIHRoaXMucHJlR2VuZXJhdGVDYWxsYmFjaygpO1xyXG5cclxuICAgICAgICB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSA9IHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tIC8gVXRpbC5EUkFXX0lORkxBVEVfQU1PVU5UO1xyXG4gICAgICAgIHRoaXMuc3RyZWFtbGluZXMgPSBuZXcgU3RyZWFtbGluZUdlbmVyYXRvcihcclxuICAgICAgICAgICAgdGhpcy5pbnRlZ3JhdG9yLCB0aGlzLmRvbWFpbkNvbnRyb2xsZXIub3JpZ2luLFxyXG4gICAgICAgICAgICB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGREaW1lbnNpb25zLCBPYmplY3QuYXNzaWduKHt9LHRoaXMucGFyYW1zKSk7XHJcbiAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20gPSB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSAqIFV0aWwuRFJBV19JTkZMQVRFX0FNT1VOVDtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHRoaXMuZXhpc3RpbmdTdHJlYW1saW5lcykge1xyXG4gICAgICAgICAgICB0aGlzLnN0cmVhbWxpbmVzLmFkZEV4aXN0aW5nU3RyZWFtbGluZXMocy5zdHJlYW1saW5lcykgICBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuY2xvc2VUZW5zb3JGb2xkZXIoKTtcclxuICAgICAgICB0aGlzLnJlZHJhdygpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbWxpbmVzLmNyZWF0ZUFsbFN0cmVhbWxpbmVzKGFuaW1hdGUpLnRoZW4oKCkgPT4gdGhpcy5wb3N0R2VuZXJhdGVDYWxsYmFjaygpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBzdHJlYW1saW5lcyBjaGFuZ2VzXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZSgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1saW5lcy51cGRhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgYWRkRGV2UGFyYW1zVG9Gb2xkZXIocGFyYW1zOiBTdHJlYW1saW5lUGFyYW1zLCBmb2xkZXI6IGRhdC5HVUkpOiB2b2lkIHtcclxuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ3BhdGhJdGVyYXRpb25zJyk7XHJcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdzZWVkVHJpZXMnKTtcclxuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ2RzdGVwJyk7XHJcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdkbG9va2FoZWFkJyk7XHJcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdkY2lyY2xlam9pbicpO1xyXG4gICAgICAgIGZvbGRlci5hZGQocGFyYW1zLCAnam9pbmFuZ2xlJyk7XHJcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdzaW1wbGlmeVRvbGVyYW5jZScpO1xyXG4gICAgICAgIGZvbGRlci5hZGQocGFyYW1zLCAnY29sbGlkZUVhcmx5Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHBhdGggaXRlcmF0aW9ucyBzbyB0aGF0IGEgcm9hZCBjYW4gY292ZXIgdGhlIHNjcmVlblxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIHNldFBhdGhJdGVyYXRpb25zKCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG1heCA9IDEuNSAqIE1hdGgubWF4KHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xyXG4gICAgICAgIHRoaXMucGFyYW1zLnBhdGhJdGVyYXRpb25zID0gbWF4L3RoaXMucGFyYW1zLmRzdGVwO1xyXG4gICAgICAgIFV0aWwudXBkYXRlR3VpKHRoaXMuZ3VpRm9sZGVyKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xyXG5pbXBvcnQgKiBhcyBkYXQgZnJvbSAnZGF0Lmd1aSc7XHJcbmltcG9ydCBUZW5zb3JGaWVsZEdVSSBmcm9tICcuL3RlbnNvcl9maWVsZF9ndWknO1xyXG5pbXBvcnQge05vaXNlUGFyYW1zfSBmcm9tICcuLi9pbXBsL3RlbnNvcl9maWVsZCc7XHJcbmltcG9ydCBDYW52YXNXcmFwcGVyIGZyb20gJy4vY2FudmFzX3dyYXBwZXInO1xyXG5pbXBvcnQge0RlZmF1bHRDYW52YXNXcmFwcGVyLCBSb3VnaENhbnZhc1dyYXBwZXJ9IGZyb20gJy4vY2FudmFzX3dyYXBwZXInO1xyXG5pbXBvcnQgVXRpbCBmcm9tICcuLi91dGlsJztcclxuaW1wb3J0IFBvbHlnb25VdGlsIGZyb20gJy4uL2ltcGwvcG9seWdvbl91dGlsJztcclxuaW1wb3J0IERyYWdDb250cm9sbGVyIGZyb20gJy4vZHJhZ19jb250cm9sbGVyJztcclxuaW1wb3J0IERvbWFpbkNvbnRyb2xsZXIgZnJvbSAnLi9kb21haW5fY29udHJvbGxlcic7XHJcbmltcG9ydCBWZWN0b3IgZnJvbSAnLi4vdmVjdG9yJztcclxuaW1wb3J0IHtCdWlsZGluZ01vZGVsfSBmcm9tICcuL2J1aWxkaW5ncyc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENvbG91clNjaGVtZSB7XHJcbiAgICBiZ0NvbG91cjogc3RyaW5nO1xyXG4gICAgYmdDb2xvdXJJbj86IHN0cmluZztcclxuICAgIGJ1aWxkaW5nQ29sb3VyPzogc3RyaW5nO1xyXG4gICAgYnVpbGRpbmdTaWRlQ29sb3VyPzogc3RyaW5nO1xyXG4gICAgYnVpbGRpbmdTdHJva2U/OiBzdHJpbmc7XHJcbiAgICBzZWFDb2xvdXI6IHN0cmluZztcclxuICAgIGdyYXNzQ29sb3VyPzogc3RyaW5nO1xyXG4gICAgbWlub3JSb2FkQ29sb3VyOiBzdHJpbmc7XHJcbiAgICBtaW5vclJvYWRPdXRsaW5lPzogc3RyaW5nO1xyXG4gICAgbWFqb3JSb2FkQ29sb3VyPzogc3RyaW5nO1xyXG4gICAgbWFqb3JSb2FkT3V0bGluZT86IHN0cmluZztcclxuICAgIG1haW5Sb2FkQ29sb3VyPzogc3RyaW5nO1xyXG4gICAgbWFpblJvYWRPdXRsaW5lPzogc3RyaW5nO1xyXG4gICAgb3V0bGluZVNpemU/OiBudW1iZXI7XHJcbiAgICBtaW5vcldpZHRoPzogbnVtYmVyO1xyXG4gICAgbWFqb3JXaWR0aD86IG51bWJlcjtcclxuICAgIG1haW5XaWR0aD86IG51bWJlcjtcclxuICAgIHpvb21CdWlsZGluZ3M/OiBib29sZWFuO1xyXG4gICAgYnVpbGRpbmdNb2RlbHM/OiBib29sZWFuO1xyXG4gICAgZnJhbWVDb2xvdXI/OiBzdHJpbmc7XHJcbiAgICBmcmFtZVRleHRDb2xvdXI/OiBzdHJpbmc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb250cm9scyBob3cgc2NyZWVuLXNwYWNlIGRhdGEgaXMgZHJhd25cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFN0eWxlIHtcclxuICAgIHByb3RlY3RlZCBjYW52YXM6IENhbnZhc1dyYXBwZXI7XHJcbiAgICBwcm90ZWN0ZWQgZG9tYWluQ29udHJvbGxlcjogRG9tYWluQ29udHJvbGxlciA9IERvbWFpbkNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgIHB1YmxpYyBhYnN0cmFjdCBjcmVhdGVDYW52YXNXcmFwcGVyKGM6IEhUTUxDYW52YXNFbGVtZW50LCBzY2FsZTogbnVtYmVyLCByZXNpemVUb1dpbmRvdzogYm9vbGVhbik6IENhbnZhc1dyYXBwZXI7XHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgZHJhdyhjYW52YXM/OiBDYW52YXNXcmFwcGVyKTogdm9pZDtcclxuXHJcbiAgICBwdWJsaWMgdXBkYXRlKCk6IHZvaWQge31cclxuXHJcbiAgICAvLyBQb2x5Z29uc1xyXG4gICAgcHVibGljIHNlYVBvbHlnb246IFZlY3RvcltdID0gW107XHJcbiAgICBwdWJsaWMgbG90czogVmVjdG9yW11bXSA9IFtdO1xyXG4gICAgcHVibGljIGJ1aWxkaW5nTW9kZWxzOiBCdWlsZGluZ01vZGVsW10gPSBbXTtcclxuICAgIHB1YmxpYyBwYXJrczogVmVjdG9yW11bXSA9IFtdO1xyXG5cclxuICAgIC8vIFBvbHlsaW5lc1xyXG4gICAgcHVibGljIGNvYXN0bGluZTogVmVjdG9yW10gPSBbXTtcclxuICAgIHB1YmxpYyByaXZlcjogVmVjdG9yW10gPSBbXTtcclxuICAgIHB1YmxpYyBzZWNvbmRhcnlSaXZlcjogVmVjdG9yW10gPSBbXTtcclxuICAgIHB1YmxpYyBtaW5vclJvYWRzOiBWZWN0b3JbXVtdID0gW107XHJcbiAgICBwdWJsaWMgbWFqb3JSb2FkczogVmVjdG9yW11bXSA9IFtdO1xyXG4gICAgcHVibGljIG1haW5Sb2FkczogVmVjdG9yW11bXSA9IFtdO1xyXG4gICAgcHVibGljIGNvYXN0bGluZVJvYWRzOiBWZWN0b3JbXVtdID0gW107XHJcbiAgICBwdWJsaWMgc2hvd0ZyYW1lOiBib29sZWFuO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBkcmFnQ29udHJvbGxlcjogRHJhZ0NvbnRyb2xsZXIsIHByb3RlY3RlZCBjb2xvdXJTY2hlbWU6IENvbG91clNjaGVtZSkge1xyXG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLmJnQ29sb3VyKSBsb2cuZXJyb3IoXCJDb2xvdXJTY2hlbWUgRXJyb3IgLSBiZ0NvbG91ciBub3QgZGVmaW5lZFwiKTtcclxuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5zZWFDb2xvdXIpIGxvZy5lcnJvcihcIkNvbG91clNjaGVtZSBFcnJvciAtIHNlYUNvbG91ciBub3QgZGVmaW5lZFwiKTtcclxuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5taW5vclJvYWRDb2xvdXIpIGxvZy5lcnJvcihcIkNvbG91clNjaGVtZSBFcnJvciAtIG1pbm9yUm9hZENvbG91ciBub3QgZGVmaW5lZFwiKTtcclxuXHJcbiAgICAgICAgLy8gRGVmYXVsdCBjb2xvdXJzY2hlbWUgY2FzY2FkZVxyXG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLmJnQ29sb3VySW4pIGNvbG91clNjaGVtZS5iZ0NvbG91ckluID0gY29sb3VyU2NoZW1lLmJnQ29sb3VyO1xyXG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLmJ1aWxkaW5nQ29sb3VyKSBjb2xvdXJTY2hlbWUuYnVpbGRpbmdDb2xvdXIgPSBjb2xvdXJTY2hlbWUuYmdDb2xvdXI7XHJcbiAgICAgICAgaWYgKCFjb2xvdXJTY2hlbWUuYnVpbGRpbmdTdHJva2UpIGNvbG91clNjaGVtZS5idWlsZGluZ1N0cm9rZSA9IGNvbG91clNjaGVtZS5iZ0NvbG91cjtcclxuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5ncmFzc0NvbG91cikgY29sb3VyU2NoZW1lLmdyYXNzQ29sb3VyID0gY29sb3VyU2NoZW1lLmJnQ29sb3VyO1xyXG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLm1pbm9yUm9hZE91dGxpbmUpIGNvbG91clNjaGVtZS5taW5vclJvYWRPdXRsaW5lID0gY29sb3VyU2NoZW1lLm1pbm9yUm9hZENvbG91cjtcclxuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5tYWpvclJvYWRDb2xvdXIpIGNvbG91clNjaGVtZS5tYWpvclJvYWRDb2xvdXIgPSBjb2xvdXJTY2hlbWUubWlub3JSb2FkQ29sb3VyO1xyXG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLm1ham9yUm9hZE91dGxpbmUpIGNvbG91clNjaGVtZS5tYWpvclJvYWRPdXRsaW5lID0gY29sb3VyU2NoZW1lLm1pbm9yUm9hZE91dGxpbmU7XHJcbiAgICAgICAgaWYgKCFjb2xvdXJTY2hlbWUubWFpblJvYWRDb2xvdXIpIGNvbG91clNjaGVtZS5tYWluUm9hZENvbG91ciA9IGNvbG91clNjaGVtZS5tYWpvclJvYWRDb2xvdXI7XHJcbiAgICAgICAgaWYgKCFjb2xvdXJTY2hlbWUubWFpblJvYWRPdXRsaW5lKSBjb2xvdXJTY2hlbWUubWFpblJvYWRPdXRsaW5lID0gY29sb3VyU2NoZW1lLm1ham9yUm9hZE91dGxpbmU7XHJcbiAgICAgICAgaWYgKCFjb2xvdXJTY2hlbWUub3V0bGluZVNpemUpIGNvbG91clNjaGVtZS5vdXRsaW5lU2l6ZSA9IDE7XHJcbiAgICAgICAgaWYgKCFjb2xvdXJTY2hlbWUuem9vbUJ1aWxkaW5ncykgY29sb3VyU2NoZW1lLnpvb21CdWlsZGluZ3MgPSBmYWxzZTtcclxuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5idWlsZGluZ01vZGVscykgY29sb3VyU2NoZW1lLmJ1aWxkaW5nTW9kZWxzID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKCFjb2xvdXJTY2hlbWUubWlub3JXaWR0aCkgY29sb3VyU2NoZW1lLm1pbm9yV2lkdGggPSAyO1xyXG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLm1ham9yV2lkdGgpIGNvbG91clNjaGVtZS5tYWpvcldpZHRoID0gNDtcclxuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5tYWluV2lkdGgpIGNvbG91clNjaGVtZS5tYWluV2lkdGggPSA1O1xyXG4gICAgICAgIGlmICghY29sb3VyU2NoZW1lLm1haW5XaWR0aCkgY29sb3VyU2NoZW1lLm1haW5XaWR0aCA9IDU7XHJcbiAgICAgICAgaWYgKCFjb2xvdXJTY2hlbWUuZnJhbWVDb2xvdXIpIGNvbG91clNjaGVtZS5mcmFtZUNvbG91ciA9IGNvbG91clNjaGVtZS5iZ0NvbG91cjtcclxuICAgICAgICBpZiAoIWNvbG91clNjaGVtZS5mcmFtZVRleHRDb2xvdXIpIGNvbG91clNjaGVtZS5mcmFtZVRleHRDb2xvdXIgPSBjb2xvdXJTY2hlbWUubWlub3JSb2FkT3V0bGluZTtcclxuXHJcbiAgICAgICAgaWYgKCFjb2xvdXJTY2hlbWUuYnVpbGRpbmdTaWRlQ29sb3VyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJnYiA9IFV0aWwucGFyc2VDU1NDb2xvcihjb2xvdXJTY2hlbWUuYnVpbGRpbmdDb2xvdXIpLm1hcCh2ID0+IE1hdGgubWF4KDAsIHYgLSA0MCkpO1xyXG4gICAgICAgICAgICBpZiAocGFyc2VkUmdiKSB7XHJcbiAgICAgICAgICAgICAgICBjb2xvdXJTY2hlbWUuYnVpbGRpbmdTaWRlQ29sb3VyID0gYHJnYigke3BhcnNlZFJnYlswXX0sJHtwYXJzZWRSZ2JbMV19LCR7cGFyc2VkUmdiWzJdfSlgO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29sb3VyU2NoZW1lLmJ1aWxkaW5nU2lkZUNvbG91ciA9IGNvbG91clNjaGVtZS5idWlsZGluZ0NvbG91cjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0IHpvb21CdWlsZGluZ3MoYjogYm9vbGVhbikge1xyXG4gICAgICAgIHRoaXMuY29sb3VyU2NoZW1lLnpvb21CdWlsZGluZ3MgPSBiO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgc2hvd0J1aWxkaW5nTW9kZWxzKGI6IGJvb2xlYW4pIHtcclxuICAgICAgICB0aGlzLmNvbG91clNjaGVtZS5idWlsZGluZ01vZGVscyA9IGI7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBzaG93QnVpbGRpbmdNb2RlbHMoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sb3VyU2NoZW1lLmJ1aWxkaW5nTW9kZWxzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgY2FudmFzU2NhbGUoc2NhbGU6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMuY2FudmFzLmNhbnZhc1NjYWxlID0gc2NhbGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBuZWVkc1VwZGF0ZSgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMubmVlZHNVcGRhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldCBuZWVkc1VwZGF0ZShuOiBib29sZWFuKSB7XHJcbiAgICAgICAgdGhpcy5jYW52YXMubmVlZHNVcGRhdGUgPSBuO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgRGVmYXVsdFN0eWxlIGV4dGVuZHMgU3R5bGUge1xyXG4gICAgY29uc3RydWN0b3IoYzogSFRNTENhbnZhc0VsZW1lbnQsIGRyYWdDb250cm9sbGVyOiBEcmFnQ29udHJvbGxlciwgY29sb3VyU2NoZW1lOiBDb2xvdXJTY2hlbWUsIHByaXZhdGUgaGVpZ2h0bWFwPWZhbHNlKSB7XHJcbiAgICAgICAgc3VwZXIoZHJhZ0NvbnRyb2xsZXIsIGNvbG91clNjaGVtZSk7XHJcbiAgICAgICAgdGhpcy5jYW52YXMgPSB0aGlzLmNyZWF0ZUNhbnZhc1dyYXBwZXIoYywgMSwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNyZWF0ZUNhbnZhc1dyYXBwZXIoYzogSFRNTENhbnZhc0VsZW1lbnQsIHNjYWxlPTEsIHJlc2l6ZVRvV2luZG93PXRydWUpOiBDYW52YXNXcmFwcGVyIHtcclxuICAgICAgICByZXR1cm4gbmV3IERlZmF1bHRDYW52YXNXcmFwcGVyKGMsIHNjYWxlLCByZXNpemVUb1dpbmRvdyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRyYXcoY2FudmFzPXRoaXMuY2FudmFzIGFzIERlZmF1bHRDYW52YXNXcmFwcGVyKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IGJnQ29sb3VyO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbG91clNjaGVtZS56b29tQnVpbGRpbmdzKSB7XHJcbiAgICAgICAgICAgIGJnQ29sb3VyID0gdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20gPj0gMiA/IHRoaXMuY29sb3VyU2NoZW1lLmJnQ29sb3VySW4gOiB0aGlzLmNvbG91clNjaGVtZS5iZ0NvbG91cjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBiZ0NvbG91ciA9IHRoaXMuY29sb3VyU2NoZW1lLmJnQ29sb3VyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuXHJcbiAgICAgICAgY2FudmFzLnNldEZpbGxTdHlsZShiZ0NvbG91cik7XHJcbiAgICAgICAgY2FudmFzLmNsZWFyQ2FudmFzKCk7XHJcblxyXG4gICAgICAgIC8vIFNlYVxyXG4gICAgICAgIGNhbnZhcy5zZXRGaWxsU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUuc2VhQ29sb3VyKTtcclxuICAgICAgICBjYW52YXMuc2V0U3Ryb2tlU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUuc2VhQ29sb3VyKTtcclxuICAgICAgICBjYW52YXMuc2V0TGluZVdpZHRoKDAuMSk7XHJcbiAgICAgICAgY2FudmFzLmRyYXdQb2x5Z29uKHRoaXMuc2VhUG9seWdvbik7XHJcblxyXG4gICAgICAgIC8vIENvYXN0bGluZVxyXG4gICAgICAgIGNhbnZhcy5zZXRTdHJva2VTdHlsZShiZ0NvbG91cik7XHJcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCgzMCAqIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tKTtcclxuICAgICAgICBjYW52YXMuZHJhd1BvbHlsaW5lKHRoaXMuY29hc3RsaW5lKTtcclxuXHJcbiAgICAgICAgLy8gUGFya3NcclxuICAgICAgICBjYW52YXMuc2V0TGluZVdpZHRoKDEpO1xyXG4gICAgICAgIGNhbnZhcy5zZXRGaWxsU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUuZ3Jhc3NDb2xvdXIpO1xyXG4gICAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLnBhcmtzKSBjYW52YXMuZHJhd1BvbHlnb24ocCk7XHJcblxyXG4gICAgICAgIC8vIFJpdmVyXHJcbiAgICAgICAgY2FudmFzLnNldEZpbGxTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5zZWFDb2xvdXIpO1xyXG4gICAgICAgIGNhbnZhcy5zZXRTdHJva2VTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5zZWFDb2xvdXIpO1xyXG4gICAgICAgIGNhbnZhcy5zZXRMaW5lV2lkdGgoMSk7XHJcbiAgICAgICAgY2FudmFzLmRyYXdQb2x5Z29uKHRoaXMucml2ZXIpO1xyXG5cclxuICAgICAgICAvLyBSb2FkIG91dGxpbmVcclxuICAgICAgICBjYW52YXMuc2V0U3Ryb2tlU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUubWlub3JSb2FkT3V0bGluZSk7XHJcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCh0aGlzLmNvbG91clNjaGVtZS5vdXRsaW5lU2l6ZSArIHRoaXMuY29sb3VyU2NoZW1lLm1pbm9yV2lkdGggKiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSk7XHJcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHRoaXMubWlub3JSb2FkcykgY2FudmFzLmRyYXdQb2x5bGluZShzKTtcclxuXHJcbiAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKHRoaXMuY29sb3VyU2NoZW1lLm1ham9yUm9hZE91dGxpbmUpO1xyXG4gICAgICAgIGNhbnZhcy5zZXRMaW5lV2lkdGgodGhpcy5jb2xvdXJTY2hlbWUub3V0bGluZVNpemUgKyB0aGlzLmNvbG91clNjaGVtZS5tYWpvcldpZHRoICogdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20pO1xyXG4gICAgICAgIGZvciAoY29uc3QgcyBvZiB0aGlzLm1ham9yUm9hZHMpIGNhbnZhcy5kcmF3UG9seWxpbmUocyk7XHJcbiAgICAgICAgY2FudmFzLmRyYXdQb2x5bGluZSh0aGlzLnNlY29uZGFyeVJpdmVyKTtcclxuXHJcbiAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKHRoaXMuY29sb3VyU2NoZW1lLm1haW5Sb2FkT3V0bGluZSk7XHJcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCh0aGlzLmNvbG91clNjaGVtZS5vdXRsaW5lU2l6ZSArIHRoaXMuY29sb3VyU2NoZW1lLm1haW5XaWR0aCAqIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgdGhpcy5tYWluUm9hZHMpIGNhbnZhcy5kcmF3UG9seWxpbmUocyk7XHJcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHRoaXMuY29hc3RsaW5lUm9hZHMpIGNhbnZhcy5kcmF3UG9seWxpbmUocyk7XHJcblxyXG4gICAgICAgIC8vIFJvYWQgaW5saW5lXHJcbiAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKHRoaXMuY29sb3VyU2NoZW1lLm1pbm9yUm9hZENvbG91cik7XHJcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCh0aGlzLmNvbG91clNjaGVtZS5taW5vcldpZHRoICogdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20pO1xyXG4gICAgICAgIGZvciAoY29uc3QgcyBvZiB0aGlzLm1pbm9yUm9hZHMpIGNhbnZhcy5kcmF3UG9seWxpbmUocyk7XHJcblxyXG4gICAgICAgIGNhbnZhcy5zZXRTdHJva2VTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5tYWpvclJvYWRDb2xvdXIpO1xyXG4gICAgICAgIGNhbnZhcy5zZXRMaW5lV2lkdGgodGhpcy5jb2xvdXJTY2hlbWUubWFqb3JXaWR0aCAqIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgdGhpcy5tYWpvclJvYWRzKSBjYW52YXMuZHJhd1BvbHlsaW5lKHMpO1xyXG4gICAgICAgIGNhbnZhcy5kcmF3UG9seWxpbmUodGhpcy5zZWNvbmRhcnlSaXZlcik7XHJcblxyXG4gICAgICAgIGNhbnZhcy5zZXRTdHJva2VTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5tYWluUm9hZENvbG91cik7XHJcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCh0aGlzLmNvbG91clNjaGVtZS5tYWluV2lkdGggKiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSk7XHJcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHRoaXMubWFpblJvYWRzKSBjYW52YXMuZHJhd1BvbHlsaW5lKHMpO1xyXG4gICAgICAgIGZvciAoY29uc3QgcyBvZiB0aGlzLmNvYXN0bGluZVJvYWRzKSBjYW52YXMuZHJhd1BvbHlsaW5lKHMpO1xyXG5cclxuXHJcbiAgICAgICAgY2FudmFzLnNldExpbmVXaWR0aCgxKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0bWFwKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgYiBvZiB0aGlzLmJ1aWxkaW5nTW9kZWxzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDb2xvdXIgYmFzZWQgb24gaGVpZ2h0XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkUmdiID0gVXRpbC5wYXJzZUNTU0NvbG9yKHRoaXMuY29sb3VyU2NoZW1lLmJnQ29sb3VyKS5tYXAodiA9PiBNYXRoLm1pbigyNTUsIHYgKyAoYi5oZWlnaHQgKiAzLjUpKSk7XHJcbiAgICAgICAgICAgICAgICBjYW52YXMuc2V0RmlsbFN0eWxlKGByZ2IoJHtwYXJzZWRSZ2JbMF19LCR7cGFyc2VkUmdiWzFdfSwke3BhcnNlZFJnYlsyXX0pYCk7XHJcbiAgICAgICAgICAgICAgICBjYW52YXMuc2V0U3Ryb2tlU3R5bGUoYHJnYigke3BhcnNlZFJnYlswXX0sJHtwYXJzZWRSZ2JbMV19LCR7cGFyc2VkUmdiWzJdfSlgKTtcclxuICAgICAgICAgICAgICAgIGNhbnZhcy5kcmF3UG9seWdvbihiLmxvdFNjcmVlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBCdWlsZGluZ3NcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbG91clNjaGVtZS56b29tQnVpbGRpbmdzIHx8IHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tID49IDIpIHtcclxuICAgICAgICAgICAgICAgIGNhbnZhcy5zZXRGaWxsU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUuYnVpbGRpbmdDb2xvdXIpO1xyXG4gICAgICAgICAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKHRoaXMuY29sb3VyU2NoZW1lLmJ1aWxkaW5nU3Ryb2tlKTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYiBvZiB0aGlzLmxvdHMpIGNhbnZhcy5kcmF3UG9seWdvbihiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUHNldWRvLTNEXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbG91clNjaGVtZS5idWlsZGluZ01vZGVscyAmJiAoIXRoaXMuY29sb3VyU2NoZW1lLnpvb21CdWlsZGluZ3MgfHwgdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20gPj0gMi41KSkge1xyXG4gICAgICAgICAgICAgICAgY2FudmFzLnNldEZpbGxTdHlsZSh0aGlzLmNvbG91clNjaGVtZS5idWlsZGluZ1NpZGVDb2xvdXIpO1xyXG4gICAgICAgICAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKHRoaXMuY29sb3VyU2NoZW1lLmJ1aWxkaW5nU2lkZUNvbG91cik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGNoZWFwIGFwcHJveGltYXRpb24gdGhhdCBvZnRlbiBjcmVhdGVzIHZpc3VhbCBhcnRlZmFjdHNcclxuICAgICAgICAgICAgICAgIC8vIERyYXdzIGJ1aWxkaW5nIHNpZGVzLCB0aGVuIHJvb3ZlcyBpbnN0ZWFkIG9mIHByb3Blcmx5IGNsaXBwaW5nIHBvbHlnb25zIGV0Yy5cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYiBvZiB0aGlzLmJ1aWxkaW5nTW9kZWxzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzIG9mIGIuc2lkZXMpIGNhbnZhcy5kcmF3UG9seWdvbihzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhbnZhcy5zZXRGaWxsU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUuYnVpbGRpbmdDb2xvdXIpO1xyXG4gICAgICAgICAgICAgICAgY2FudmFzLnNldFN0cm9rZVN0eWxlKHRoaXMuY29sb3VyU2NoZW1lLmJ1aWxkaW5nU3Ryb2tlKTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYiBvZiB0aGlzLmJ1aWxkaW5nTW9kZWxzKSBjYW52YXMuZHJhd1BvbHlnb24oYi5yb29mKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc2hvd0ZyYW1lKSB7XHJcbiAgICAgICAgICAgIGNhbnZhcy5zZXRGaWxsU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUuZnJhbWVDb2xvdXIpO1xyXG4gICAgICAgICAgICBjYW52YXMuc2V0U3Ryb2tlU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUuZnJhbWVDb2xvdXIpO1xyXG4gICAgICAgICAgICBjYW52YXMuZHJhd0ZyYW1lKDMwLCAzMCwgMzAsIDMwKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNhbnZhcy5zZXRGaWxsU3R5bGUodGhpcy5jb2xvdXJTY2hlbWUuZnJhbWVUZXh0Q29sb3VyKTtcclxuICAgICAgICAgICAgLy8gY2FudmFzLmRyYXdDaXR5TmFtZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFJvdWdoU3R5bGUgZXh0ZW5kcyBTdHlsZSB7XHJcbiAgICBwcml2YXRlIGRyYWdnaW5nID0gZmFsc2U7XHJcblxyXG4gICAgY29uc3RydWN0b3IoYzogSFRNTENhbnZhc0VsZW1lbnQsIGRyYWdDb250cm9sbGVyOiBEcmFnQ29udHJvbGxlciwgY29sb3VyU2NoZW1lOiBDb2xvdXJTY2hlbWUpIHtcclxuICAgICAgICBzdXBlcihkcmFnQ29udHJvbGxlciwgY29sb3VyU2NoZW1lKTtcclxuICAgICAgICB0aGlzLmNhbnZhcyA9IHRoaXMuY3JlYXRlQ2FudmFzV3JhcHBlcihjLCAxLCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY3JlYXRlQ2FudmFzV3JhcHBlcihjOiBIVE1MQ2FudmFzRWxlbWVudCwgc2NhbGU9MSwgcmVzaXplVG9XaW5kb3c9dHJ1ZSk6IENhbnZhc1dyYXBwZXIge1xyXG4gICAgICAgIHJldHVybiBuZXcgUm91Z2hDYW52YXNXcmFwcGVyKGMsIHNjYWxlLCByZXNpemVUb1dpbmRvdyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHVwZGF0ZSgpIHtcclxuICAgICAgICBjb25zdCBkcmFnZ2luZyA9IHRoaXMuZHJhZ0NvbnRyb2xsZXIuaXNEcmFnZ2luZyB8fCB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuaXNTY3JvbGxpbmc7XHJcbiAgICAgICAgaWYgKCFkcmFnZ2luZyAmJiB0aGlzLmRyYWdnaW5nKSB0aGlzLmNhbnZhcy5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGRyYWdnaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBkcmF3KGNhbnZhcz10aGlzLmNhbnZhcyBhcyBSb3VnaENhbnZhc1dyYXBwZXIpOiB2b2lkIHtcclxuICAgICAgICBjYW52YXMuc2V0T3B0aW9ucyh7XHJcbiAgICAgICAgICAgIGZpbGw6IHRoaXMuY29sb3VyU2NoZW1lLmJnQ29sb3VyLFxyXG4gICAgICAgICAgICByb3VnaG5lc3M6IDEsXHJcbiAgICAgICAgICAgIGJvd2luZzogMSxcclxuICAgICAgICAgICAgZmlsbFN0eWxlOiAnc29saWQnLFxyXG4gICAgICAgICAgICBzdHJva2U6IFwibm9uZVwiLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjYW52YXMuY2xlYXJDYW52YXMoKTtcclxuXHJcbiAgICAgICAgLy8gU2VhXHJcbiAgICAgICAgY2FudmFzLnNldE9wdGlvbnMoe1xyXG4gICAgICAgICAgICByb3VnaG5lc3M6IDAsXHJcbiAgICAgICAgICAgIGZpbGxXZWlnaHQ6IDEsXHJcbiAgICAgICAgICAgIGZpbGw6IHRoaXMuY29sb3VyU2NoZW1lLnNlYUNvbG91cixcclxuICAgICAgICAgICAgZmlsbFN0eWxlOiAnc29saWQnLFxyXG4gICAgICAgICAgICBzdHJva2U6IFwibm9uZVwiLFxyXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMSxcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY2FudmFzLmRyYXdQb2x5Z29uKHRoaXMuc2VhUG9seWdvbik7XHJcblxyXG4gICAgICAgIGNhbnZhcy5zZXRPcHRpb25zKHtcclxuICAgICAgICAgICAgc3Ryb2tlOiB0aGlzLmNvbG91clNjaGVtZS5iZ0NvbG91cixcclxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDMwLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNhbnZhcy5kcmF3UG9seWxpbmUodGhpcy5jb2FzdGxpbmUpO1xyXG5cclxuICAgICAgICBjYW52YXMuc2V0T3B0aW9ucyh7XHJcbiAgICAgICAgICAgIHJvdWdobmVzczogMCxcclxuICAgICAgICAgICAgZmlsbFdlaWdodDogMSxcclxuICAgICAgICAgICAgZmlsbDogdGhpcy5jb2xvdXJTY2hlbWUuc2VhQ29sb3VyLFxyXG4gICAgICAgICAgICBmaWxsU3R5bGU6ICdzb2xpZCcsXHJcbiAgICAgICAgICAgIHN0cm9rZTogXCJub25lXCIsXHJcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjYW52YXMuZHJhd1BvbHlnb24odGhpcy5yaXZlcik7XHJcblxyXG4gICAgICAgIC8vIFBhcmtzXHJcbiAgICAgICAgY2FudmFzLnNldE9wdGlvbnMoe1xyXG4gICAgICAgICAgICBmaWxsOiB0aGlzLmNvbG91clNjaGVtZS5ncmFzc0NvbG91cixcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnBhcmtzLmZvckVhY2gocCA9PiBjYW52YXMuZHJhd1BvbHlnb24ocCkpO1xyXG5cclxuICAgICAgICAvLyBSb2Fkc1xyXG4gICAgICAgIGNhbnZhcy5zZXRPcHRpb25zKHtcclxuICAgICAgICAgICAgc3Ryb2tlOiB0aGlzLmNvbG91clNjaGVtZS5taW5vclJvYWRDb2xvdXIsXHJcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLFxyXG4gICAgICAgICAgICBmaWxsOiAnbm9uZScsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMubWlub3JSb2Fkcy5mb3JFYWNoKHMgPT4gY2FudmFzLmRyYXdQb2x5bGluZShzKSk7XHJcblxyXG4gICAgICAgIGNhbnZhcy5zZXRPcHRpb25zKHtcclxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDIsXHJcbiAgICAgICAgICAgIHN0cm9rZTogdGhpcy5jb2xvdXJTY2hlbWUubWFqb3JSb2FkQ29sb3VyLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLm1ham9yUm9hZHMuZm9yRWFjaChzID0+IGNhbnZhcy5kcmF3UG9seWxpbmUocykpO1xyXG4gICAgICAgIGNhbnZhcy5kcmF3UG9seWxpbmUodGhpcy5zZWNvbmRhcnlSaXZlcik7XHJcblxyXG4gICAgICAgIGNhbnZhcy5zZXRPcHRpb25zKHtcclxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDMsXHJcbiAgICAgICAgICAgIHN0cm9rZTogdGhpcy5jb2xvdXJTY2hlbWUubWFpblJvYWRDb2xvdXIsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMubWFpblJvYWRzLmZvckVhY2gocyA9PiBjYW52YXMuZHJhd1BvbHlsaW5lKHMpKTtcclxuICAgICAgICB0aGlzLmNvYXN0bGluZVJvYWRzLmZvckVhY2gocyA9PiBjYW52YXMuZHJhd1BvbHlsaW5lKHMpKTtcclxuXHJcbiAgICAgICAgLy8gQnVpbGRpbmdzXHJcbiAgICAgICAgaWYgKCF0aGlzLmRyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgIC8vIExvdHNcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbG91clNjaGVtZS56b29tQnVpbGRpbmdzIHx8IHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tID49IDIpIHtcclxuICAgICAgICAgICAgICAgIC8vIExvdHNcclxuICAgICAgICAgICAgICAgIGNhbnZhcy5zZXRPcHRpb25zKHtcclxuICAgICAgICAgICAgICAgICAgICByb3VnaG5lc3M6IDEuMixcclxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHRoaXMuY29sb3VyU2NoZW1lLmJ1aWxkaW5nU3Ryb2tlLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6ICcnLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGIgb2YgdGhpcy5sb3RzKSBjYW52YXMuZHJhd1BvbHlnb24oYik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFBzZXVkby0zRFxyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvdXJTY2hlbWUuYnVpbGRpbmdNb2RlbHMgJiYgKCF0aGlzLmNvbG91clNjaGVtZS56b29tQnVpbGRpbmdzIHx8IHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tID49IDIuNSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFBzZXVkby0zRFxyXG4gICAgICAgICAgICAgICAgY2FudmFzLnNldE9wdGlvbnMoe1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdWdobmVzczogMS4yLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogdGhpcy5jb2xvdXJTY2hlbWUuYnVpbGRpbmdTdHJva2UsXHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogdGhpcy5jb2xvdXJTY2hlbWUuYnVpbGRpbmdTaWRlQ29sb3VyLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyB0aGlzIGNhbiBiZSBodWdlbHkgaW1wcm92ZWRcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFsbFNpZGVzRGlzdGFuY2VzOiBhbnlbXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2FtZXJhID0gdGhpcy5kb21haW5Db250cm9sbGVyLmdldENhbWVyYVBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGIgb2YgdGhpcy5idWlsZGluZ01vZGVscykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcyBvZiBiLnNpZGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF2ZXJhZ2VQb2ludCA9IHNbMF0uY2xvbmUoKS5hZGQoc1sxXSkuZGl2aWRlU2NhbGFyKDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxTaWRlc0Rpc3RhbmNlcy5wdXNoKFthdmVyYWdlUG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoY2FtZXJhKSwgc10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFsbFNpZGVzRGlzdGFuY2VzLnNvcnQoKGEsIGIpID0+IGJbMF0gLSBhWzBdKTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiBhbGxTaWRlc0Rpc3RhbmNlcykgY2FudmFzLmRyYXdQb2x5Z29uKHBbMV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhbnZhcy5zZXRPcHRpb25zKHtcclxuICAgICAgICAgICAgICAgICAgICByb3VnaG5lc3M6IDEuMixcclxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHRoaXMuY29sb3VyU2NoZW1lLmJ1aWxkaW5nU3Ryb2tlLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IHRoaXMuY29sb3VyU2NoZW1lLmJ1aWxkaW5nQ29sb3VyLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiIG9mIHRoaXMuYnVpbGRpbmdNb2RlbHMpIGNhbnZhcy5kcmF3UG9seWdvbihiLnJvb2YpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCAqIGFzIGxvZyBmcm9tICdsb2dsZXZlbCc7XHJcbmltcG9ydCB7RGVmYXVsdENhbnZhc1dyYXBwZXJ9IGZyb20gJy4vY2FudmFzX3dyYXBwZXInO1xyXG5pbXBvcnQgRG9tYWluQ29udHJvbGxlciBmcm9tICcuL2RvbWFpbl9jb250cm9sbGVyJztcclxuaW1wb3J0IERyYWdDb250cm9sbGVyIGZyb20gJy4vZHJhZ19jb250cm9sbGVyJztcclxuaW1wb3J0IFRlbnNvckZpZWxkIGZyb20gJy4uL2ltcGwvdGVuc29yX2ZpZWxkJztcclxuaW1wb3J0IHtOb2lzZVBhcmFtc30gZnJvbSAnLi4vaW1wbC90ZW5zb3JfZmllbGQnO1xyXG5pbXBvcnQge0Jhc2lzRmllbGQsIEZJRUxEX1RZUEV9IGZyb20gJy4uL2ltcGwvYmFzaXNfZmllbGQnO1xyXG5pbXBvcnQgVXRpbCBmcm9tICcuLi91dGlsJztcclxuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xyXG5cclxuLyoqXHJcbiAqIEV4dGVuc2lvbiBvZiBUZW5zb3JGaWVsZCB0aGF0IGhhbmRsZXMgaW50ZXJhY3Rpb24gd2l0aCBkYXQuR1VJXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZW5zb3JGaWVsZEdVSSBleHRlbmRzIFRlbnNvckZpZWxkIHtcclxuICAgIHByaXZhdGUgVEVOU09SX0xJTkVfRElBTUVURVIgPSAyMDtcclxuICAgIHByaXZhdGUgVEVOU09SX1NQQVdOX1NDQUxFID0gMC43OyAgLy8gSG93IG11Y2ggdG8gc2hyaW5rIHdvcmxkRGltZW5zaW9ucyB0byBmaW5kIHNwYXduIHBvaW50XHJcbiAgICBwcml2YXRlIGRvbWFpbkNvbnRyb2xsZXIgPSBEb21haW5Db250cm9sbGVyLmdldEluc3RhbmNlKCk7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBndWlGb2xkZXI6IGRhdC5HVUksIHByaXZhdGUgZHJhZ0NvbnRyb2xsZXI6IERyYWdDb250cm9sbGVyLFxyXG4gICAgICAgIHB1YmxpYyBkcmF3Q2VudHJlOiBib29sZWFuLCBub2lzZVBhcmFtczogTm9pc2VQYXJhbXMpIHtcclxuICAgICAgICBzdXBlcihub2lzZVBhcmFtcyk7XHJcbiAgICAgICAgLy8gRm9yIGN1c3RvbSBuYW1pbmcgb2YgZ3VpIGJ1dHRvbnNcclxuICAgICAgICBjb25zdCB0ZW5zb3JGaWVsZEd1aU9iaiA9IHtcclxuICAgICAgICAgICAgcmVzZXQ6ICgpOiB2b2lkID0+IHRoaXMucmVzZXQoKSxcclxuICAgICAgICAgICAgc2V0UmVjb21tZW5kZWQ6ICgpOiB2b2lkID0+IHRoaXMuc2V0UmVjb21tZW5kZWQoKSxcclxuICAgICAgICAgICAgYWRkUmFkaWFsOiAoKTogdm9pZCA9PiB0aGlzLmFkZFJhZGlhbFJhbmRvbSgpLFxyXG4gICAgICAgICAgICBhZGRHcmlkOiAoKTogdm9pZCA9PiB0aGlzLmFkZEdyaWRSYW5kb20oKSxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmd1aUZvbGRlci5hZGQodGVuc29yRmllbGRHdWlPYmosICdyZXNldCcpO1xyXG4gICAgICAgIHRoaXMuZ3VpRm9sZGVyLmFkZCh0aGlzLCAnc21vb3RoJyk7XHJcbiAgICAgICAgdGhpcy5ndWlGb2xkZXIuYWRkKHRlbnNvckZpZWxkR3VpT2JqLCAnc2V0UmVjb21tZW5kZWQnKTtcclxuICAgICAgICB0aGlzLmd1aUZvbGRlci5hZGQodGVuc29yRmllbGRHdWlPYmosICdhZGRSYWRpYWwnKTtcclxuICAgICAgICB0aGlzLmd1aUZvbGRlci5hZGQodGVuc29yRmllbGRHdWlPYmosICdhZGRHcmlkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiA0IEdyaWRzLCBvbmUgcmFkaWFsXHJcbiAgICAgKi9cclxuICAgIHNldFJlY29tbWVuZGVkKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkRGltZW5zaW9ucy5tdWx0aXBseVNjYWxhcih0aGlzLlRFTlNPUl9TUEFXTl9TQ0FMRSk7XHJcbiAgICAgICAgY29uc3QgbmV3T3JpZ2luID0gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkRGltZW5zaW9uc1xyXG4gICAgICAgICAgICAubXVsdGlwbHlTY2FsYXIoKDEgLSB0aGlzLlRFTlNPUl9TUEFXTl9TQ0FMRSkgLyAyKVxyXG4gICAgICAgICAgICAuYWRkKHRoaXMuZG9tYWluQ29udHJvbGxlci5vcmlnaW4pO1xyXG4gICAgICAgIHRoaXMuYWRkR3JpZEF0TG9jYXRpb24obmV3T3JpZ2luKTtcclxuICAgICAgICB0aGlzLmFkZEdyaWRBdExvY2F0aW9uKG5ld09yaWdpbi5jbG9uZSgpLmFkZChzaXplKSk7XHJcbiAgICAgICAgdGhpcy5hZGRHcmlkQXRMb2NhdGlvbihuZXdPcmlnaW4uY2xvbmUoKS5hZGQobmV3IFZlY3RvcihzaXplLngsIDApKSk7XHJcbiAgICAgICAgdGhpcy5hZGRHcmlkQXRMb2NhdGlvbihuZXdPcmlnaW4uY2xvbmUoKS5hZGQobmV3IFZlY3RvcigwLCBzaXplLnkpKSk7XHJcbiAgICAgICAgdGhpcy5hZGRSYWRpYWxSYW5kb20oKTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRSYWRpYWxSYW5kb20oKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGREaW1lbnNpb25zLng7XHJcbiAgICAgICAgdGhpcy5hZGRSYWRpYWwodGhpcy5yYW5kb21Mb2NhdGlvbigpLFxyXG4gICAgICAgICAgICBVdGlsLnJhbmRvbVJhbmdlKHdpZHRoIC8gMTAsIHdpZHRoIC8gNSksICAvLyBTaXplXHJcbiAgICAgICAgICAgIFV0aWwucmFuZG9tUmFuZ2UoNTApKTsgIC8vIERlY2F5XHJcbiAgICB9XHJcblxyXG4gICAgYWRkR3JpZFJhbmRvbSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmFkZEdyaWRBdExvY2F0aW9uKHRoaXMucmFuZG9tTG9jYXRpb24oKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhZGRHcmlkQXRMb2NhdGlvbihsb2NhdGlvbjogVmVjdG9yKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGREaW1lbnNpb25zLng7XHJcbiAgICAgICAgdGhpcy5hZGRHcmlkKGxvY2F0aW9uLFxyXG4gICAgICAgICAgICBVdGlsLnJhbmRvbVJhbmdlKHdpZHRoIC8gNCwgd2lkdGgpLCAgLy8gU2l6ZVxyXG4gICAgICAgICAgICBVdGlsLnJhbmRvbVJhbmdlKDUwKSwgIC8vIERlY2F5XHJcbiAgICAgICAgICAgIFV0aWwucmFuZG9tUmFuZ2UoTWF0aC5QSSAvIDIpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdvcmxkLXNwYWNlIHJhbmRvbSBsb2NhdGlvbiBmb3IgdGVuc29yIGZpZWxkIHNwYXduXHJcbiAgICAgKiBTYW1wbGVkIGZyb20gbWlkZGxlIG9mIHNjcmVlbiAoc2hydW5rIHJlY3RhbmdsZSlcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByYW5kb21Mb2NhdGlvbigpOiBWZWN0b3Ige1xyXG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGREaW1lbnNpb25zLm11bHRpcGx5U2NhbGFyKHRoaXMuVEVOU09SX1NQQVdOX1NDQUxFKTtcclxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IG5ldyBWZWN0b3IoTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSkubXVsdGlwbHkoc2l6ZSk7XHJcbiAgICAgICAgY29uc3QgbmV3T3JpZ2luID0gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkRGltZW5zaW9ucy5tdWx0aXBseVNjYWxhcigoMSAtIHRoaXMuVEVOU09SX1NQQVdOX1NDQUxFKSAvIDIpO1xyXG4gICAgICAgIHJldHVybiBsb2NhdGlvbi5hZGQodGhpcy5kb21haW5Db250cm9sbGVyLm9yaWdpbikuYWRkKG5ld09yaWdpbik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRDcm9zc0xvY2F0aW9ucygpOiBWZWN0b3JbXSB7XHJcbiAgICAgICAgLy8gR2V0cyBncmlkIG9mIHBvaW50cyBmb3IgdmVjdG9yIGZpZWxkIHZpcyBpbiB3b3JsZCBzcGFjZVxyXG4gICAgICAgIGNvbnN0IGRpYW1ldGVyID0gdGhpcy5URU5TT1JfTElORV9ESUFNRVRFUiAvIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tO1xyXG4gICAgICAgIGNvbnN0IHdvcmxkRGltZW5zaW9ucyA9IHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZERpbWVuc2lvbnM7XHJcbiAgICAgICAgY29uc3QgbkhvciA9IE1hdGguY2VpbCh3b3JsZERpbWVuc2lvbnMueCAvIGRpYW1ldGVyKSArIDE7IC8vIFByZXZlbnQgcG9wLWluXHJcbiAgICAgICAgY29uc3QgblZlciA9IE1hdGguY2VpbCh3b3JsZERpbWVuc2lvbnMueSAvIGRpYW1ldGVyKSArIDE7XHJcbiAgICAgICAgY29uc3Qgb3JpZ2luWCA9IGRpYW1ldGVyICogTWF0aC5mbG9vcih0aGlzLmRvbWFpbkNvbnRyb2xsZXIub3JpZ2luLnggLyBkaWFtZXRlcik7XHJcbiAgICAgICAgY29uc3Qgb3JpZ2luWSA9IGRpYW1ldGVyICogTWF0aC5mbG9vcih0aGlzLmRvbWFpbkNvbnRyb2xsZXIub3JpZ2luLnkgLyBkaWFtZXRlcik7XHJcblxyXG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDw9IG5Ib3I7IHgrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8PSBuVmVyOyB5KyspIHtcclxuICAgICAgICAgICAgICAgIG91dC5wdXNoKG5ldyBWZWN0b3Iob3JpZ2luWCArICh4ICogZGlhbWV0ZXIpLCBvcmlnaW5ZICsgKHkgKiBkaWFtZXRlcikpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGdldFRlbnNvckxpbmUocG9pbnQ6IFZlY3RvciwgdGVuc29yVjogVmVjdG9yKTogVmVjdG9yW10ge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUG9pbnQgPSB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGRUb1NjcmVlbihwb2ludC5jbG9uZSgpKTtcclxuXHJcbiAgICAgICAgY29uc3QgZGlmZiA9IHRlbnNvclYubXVsdGlwbHlTY2FsYXIodGhpcy5URU5TT1JfTElORV9ESUFNRVRFUiAvIDIpOyAgLy8gQXNzdW1lcyBub3JtYWxpc2VkXHJcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0cmFuc2Zvcm1lZFBvaW50LmNsb25lKCkuc3ViKGRpZmYpO1xyXG4gICAgICAgIGNvbnN0IGVuZCA9IHRyYW5zZm9ybWVkUG9pbnQuY2xvbmUoKS5hZGQoZGlmZik7XHJcbiAgICAgICAgcmV0dXJuIFtzdGFydCwgZW5kXTtcclxuICAgIH1cclxuXHJcbiAgICBkcmF3KGNhbnZhczogRGVmYXVsdENhbnZhc1dyYXBwZXIpOiB2b2lkIHtcclxuICAgICAgICAvLyBEcmF3IHRlbnNvciBmaWVsZFxyXG4gICAgICAgIGNhbnZhcy5zZXRGaWxsU3R5bGUoJ2JsYWNrJyk7XHJcbiAgICAgICAgY2FudmFzLmNsZWFyQ2FudmFzKCk7XHJcblxyXG4gICAgICAgIGNhbnZhcy5zZXRTdHJva2VTdHlsZSgnd2hpdGUnKTtcclxuICAgICAgICBjYW52YXMuc2V0TGluZVdpZHRoKDEpO1xyXG4gICAgICAgIGNvbnN0IHRlbnNvclBvaW50cyA9IHRoaXMuZ2V0Q3Jvc3NMb2NhdGlvbnMoKTtcclxuICAgICAgICB0ZW5zb3JQb2ludHMuZm9yRWFjaChwID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMuc2FtcGxlUG9pbnQocCk7XHJcbiAgICAgICAgICAgIGNhbnZhcy5kcmF3UG9seWxpbmUodGhpcy5nZXRUZW5zb3JMaW5lKHAsIHQuZ2V0TWFqb3IoKSkpO1xyXG4gICAgICAgICAgICBjYW52YXMuZHJhd1BvbHlsaW5lKHRoaXMuZ2V0VGVuc29yTGluZShwLCB0LmdldE1pbm9yKCkpKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gRHJhdyBjZW50cmUgcG9pbnRzIG9mIGZpZWxkc1xyXG4gICAgICAgIGlmICh0aGlzLmRyYXdDZW50cmUpIHtcclxuICAgICAgICAgICAgY2FudmFzLnNldEZpbGxTdHlsZSgncmVkJyk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0QmFzaXNGaWVsZHMoKS5mb3JFYWNoKGZpZWxkID0+IFxyXG4gICAgICAgICAgICAgICAgZmllbGQuRklFTERfVFlQRSA9PT0gRklFTERfVFlQRS5HcmlkID9cclxuICAgICAgICAgICAgICAgIGNhbnZhcy5kcmF3U3F1YXJlKHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZFRvU2NyZWVuKGZpZWxkLmNlbnRyZSksIDcpIDpcclxuICAgICAgICAgICAgICAgIGNhbnZhcy5kcmF3Q2lyY2xlKHRoaXMuZG9tYWluQ29udHJvbGxlci53b3JsZFRvU2NyZWVuKGZpZWxkLmNlbnRyZSksIDcpKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgYWRkRmllbGQoZmllbGQ6IEJhc2lzRmllbGQpOiB2b2lkIHtcclxuICAgICAgICBzdXBlci5hZGRGaWVsZChmaWVsZCk7XHJcbiAgICAgICAgY29uc3QgZm9sZGVyID0gdGhpcy5ndWlGb2xkZXIuYWRkRm9sZGVyKGAke2ZpZWxkLkZPTERFUl9OQU1FfWApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEZ1bmN0aW9uIHRvIGRlcmVnaXN0ZXIgZnJvbSBkcmFnIGNvbnRyb2xsZXJcclxuICAgICAgICBjb25zdCBkZXJlZ2lzdGVyRHJhZyA9IHRoaXMuZHJhZ0NvbnRyb2xsZXIucmVnaXN0ZXIoXHJcbiAgICAgICAgICAgICgpID0+IGZpZWxkLmNlbnRyZSxcclxuICAgICAgICAgICAgZmllbGQuZHJhZ01vdmVMaXN0ZW5lci5iaW5kKGZpZWxkKSxcclxuICAgICAgICAgICAgZmllbGQuZHJhZ1N0YXJ0TGlzdGVuZXIuYmluZChmaWVsZClcclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnN0IHJlbW92ZUZpZWxkT2JqID0ge3JlbW92ZTogKCkgPT4gdGhpcy5yZW1vdmVGaWVsZEdVSShmaWVsZCwgZGVyZWdpc3RlckRyYWcpfTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBHaXZlIGRhdCBndWkgcmVtb3ZlRmllbGQgYnV0dG9uXHJcbiAgICAgICAgZm9sZGVyLmFkZChyZW1vdmVGaWVsZE9iaiwgJ3JlbW92ZScpO1xyXG4gICAgICAgIGZpZWxkLnNldEd1aSh0aGlzLmd1aUZvbGRlciwgZm9sZGVyKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlbW92ZUZpZWxkR1VJKGZpZWxkOiBCYXNpc0ZpZWxkLCBkZXJlZ2lzdGVyRHJhZzogKCgpID0+IHZvaWQpKTogdm9pZCB7XHJcbiAgICAgICAgc3VwZXIucmVtb3ZlRmllbGQoZmllbGQpO1xyXG4gICAgICAgIGZpZWxkLnJlbW92ZUZvbGRlckZyb21QYXJlbnQoKTtcclxuICAgICAgICAvLyBEZXJlZ2lzdGVyIGZyb20gZHJhZyBjb250cm9sbGVyXHJcbiAgICAgICAgZGVyZWdpc3RlckRyYWcoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXNldCgpOiB2b2lkIHtcclxuICAgICAgICAvLyBUT0RPIGtpbmQgb2YgaGFja3kgLSBjYWxsaW5nIHJlbW92ZSBjYWxsYmFja3MgZnJvbSBndWkgb2JqZWN0LCBzaG91bGQgc3RvcmUgY2FsbGJhY2tzXHJcbiAgICAgICAgLy8gaW4gYWRkZmllbGQgYW5kIGNhbGwgdGhlbSAocmVxdWlyZXMgbWFraW5nIHN1cmUgdGhleSdyZSBpZGVtcG90ZW50KVxyXG4gICAgICAgIGZvciAoY29uc3QgZmllbGRGb2xkZXJOYW1lIGluIHRoaXMuZ3VpRm9sZGVyLl9fZm9sZGVycykge1xyXG4gICAgICAgICAgICBjb25zdCBmaWVsZEZvbGRlciA9IHRoaXMuZ3VpRm9sZGVyLl9fZm9sZGVyc1tmaWVsZEZvbGRlck5hbWVdO1xyXG4gICAgICAgICAgICAoZmllbGRGb2xkZXIuX19jb250cm9sbGVyc1swXSBhcyBhbnkpLmluaXRpYWxWYWx1ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3VwZXIucmVzZXQoKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xyXG5pbXBvcnQgQ2FudmFzV3JhcHBlciBmcm9tICcuL2NhbnZhc193cmFwcGVyJztcclxuaW1wb3J0IERvbWFpbkNvbnRyb2xsZXIgZnJvbSAnLi9kb21haW5fY29udHJvbGxlcic7XHJcbmltcG9ydCBVdGlsIGZyb20gJy4uL3V0aWwnO1xyXG5pbXBvcnQgRmllbGRJbnRlZ3JhdG9yIGZyb20gJy4uL2ltcGwvaW50ZWdyYXRvcic7XHJcbmltcG9ydCB7U3RyZWFtbGluZVBhcmFtc30gZnJvbSAnLi4vaW1wbC9zdHJlYW1saW5lcyc7XHJcbmltcG9ydCB7V2F0ZXJQYXJhbXN9IGZyb20gJy4uL2ltcGwvd2F0ZXJfZ2VuZXJhdG9yJztcclxuaW1wb3J0IFdhdGVyR2VuZXJhdG9yIGZyb20gJy4uL2ltcGwvd2F0ZXJfZ2VuZXJhdG9yJztcclxuaW1wb3J0IFZlY3RvciBmcm9tICcuLi92ZWN0b3InO1xyXG5pbXBvcnQgUG9seWdvbkZpbmRlciBmcm9tICcuLi9pbXBsL3BvbHlnb25fZmluZGVyJztcclxuaW1wb3J0IFBvbHlnb25VdGlsIGZyb20gJy4uL2ltcGwvcG9seWdvbl91dGlsJztcclxuaW1wb3J0IFJvYWRHVUkgZnJvbSAnLi9yb2FkX2d1aSc7XHJcbmltcG9ydCB7Tm9pc2VQYXJhbXN9IGZyb20gJy4uL2ltcGwvdGVuc29yX2ZpZWxkJztcclxuaW1wb3J0IFRlbnNvckZpZWxkIGZyb20gJy4uL2ltcGwvdGVuc29yX2ZpZWxkJztcclxuXHJcbi8qKlxyXG4gKiBIYW5kbGVzIGdlbmVyYXRpb24gb2Ygcml2ZXIgYW5kIGNvYXN0bGluZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2F0ZXJHVUkgZXh0ZW5kcyBSb2FkR1VJIHtcclxuICAgIHByb3RlY3RlZCBzdHJlYW1saW5lczogV2F0ZXJHZW5lcmF0b3I7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSB0ZW5zb3JGaWVsZDogVGVuc29yRmllbGQsXHJcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyYW1zOiBXYXRlclBhcmFtcyxcclxuICAgICAgICAgICAgICAgIGludGVncmF0b3I6IEZpZWxkSW50ZWdyYXRvcixcclxuICAgICAgICAgICAgICAgIGd1aUZvbGRlcjogZGF0LkdVSSxcclxuICAgICAgICAgICAgICAgIGNsb3NlVGVuc29yRm9sZGVyOiAoKSA9PiB2b2lkLFxyXG4gICAgICAgICAgICAgICAgZm9sZGVyTmFtZTogc3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgcmVkcmF3OiAoKSA9PiB2b2lkKSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1zLCBpbnRlZ3JhdG9yLCBndWlGb2xkZXIsIGNsb3NlVGVuc29yRm9sZGVyLCBmb2xkZXJOYW1lLCByZWRyYXcpO1xyXG4gICAgICAgIHRoaXMuc3RyZWFtbGluZXMgPSBuZXcgV2F0ZXJHZW5lcmF0b3IoXHJcbiAgICAgICAgICAgIHRoaXMuaW50ZWdyYXRvciwgdGhpcy5kb21haW5Db250cm9sbGVyLm9yaWdpbixcclxuICAgICAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkRGltZW5zaW9ucyxcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSx0aGlzLnBhcmFtcyksIHRoaXMudGVuc29yRmllbGQpO1xyXG4gICAgfVxyXG5cclxuICAgIGluaXRGb2xkZXIoKTogV2F0ZXJHVUkge1xyXG4gICAgICAgIGNvbnN0IGZvbGRlciA9IHRoaXMuZ3VpRm9sZGVyLmFkZEZvbGRlcih0aGlzLmZvbGRlck5hbWUpO1xyXG4gICAgICAgIGZvbGRlci5hZGQoe0dlbmVyYXRlOiAoKSA9PiB0aGlzLmdlbmVyYXRlUm9hZHMoKX0sICdHZW5lcmF0ZScpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IGNvYXN0UGFyYW1zRm9sZGVyID0gZm9sZGVyLmFkZEZvbGRlcignQ29hc3RQYXJhbXMnKTtcclxuICAgICAgICBjb2FzdFBhcmFtc0ZvbGRlci5hZGQodGhpcy5wYXJhbXMuY29hc3ROb2lzZSwgJ25vaXNlRW5hYmxlZCcpO1xyXG4gICAgICAgIGNvYXN0UGFyYW1zRm9sZGVyLmFkZCh0aGlzLnBhcmFtcy5jb2FzdE5vaXNlLCAnbm9pc2VTaXplJyk7XHJcbiAgICAgICAgY29hc3RQYXJhbXNGb2xkZXIuYWRkKHRoaXMucGFyYW1zLmNvYXN0Tm9pc2UsICdub2lzZUFuZ2xlJyk7XHJcbiAgICAgICAgY29uc3Qgcml2ZXJQYXJhbXNGb2xkZXIgPSBmb2xkZXIuYWRkRm9sZGVyKCdSaXZlclBhcmFtcycpO1xyXG4gICAgICAgIHJpdmVyUGFyYW1zRm9sZGVyLmFkZCh0aGlzLnBhcmFtcy5yaXZlck5vaXNlLCAnbm9pc2VFbmFibGVkJyk7XHJcbiAgICAgICAgcml2ZXJQYXJhbXNGb2xkZXIuYWRkKHRoaXMucGFyYW1zLnJpdmVyTm9pc2UsICdub2lzZVNpemUnKTtcclxuICAgICAgICByaXZlclBhcmFtc0ZvbGRlci5hZGQodGhpcy5wYXJhbXMucml2ZXJOb2lzZSwgJ25vaXNlQW5nbGUnKTtcclxuICAgICAgICBcclxuICAgICAgICBmb2xkZXIuYWRkKHRoaXMucGFyYW1zLCAnc2ltcGxpZnlUb2xlcmFuY2UnKTtcclxuICAgICAgICBjb25zdCBkZXZQYXJhbXNGb2xkZXIgPSBmb2xkZXIuYWRkRm9sZGVyKCdEZXYnKTtcclxuICAgICAgICB0aGlzLmFkZERldlBhcmFtc1RvRm9sZGVyKHRoaXMucGFyYW1zLCBkZXZQYXJhbXNGb2xkZXIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGdlbmVyYXRlUm9hZHMoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgdGhpcy5wcmVHZW5lcmF0ZUNhbGxiYWNrKCk7XHJcblxyXG4gICAgICAgIHRoaXMuZG9tYWluQ29udHJvbGxlci56b29tID0gdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20gLyBVdGlsLkRSQVdfSU5GTEFURV9BTU9VTlQ7XHJcbiAgICAgICAgdGhpcy5zdHJlYW1saW5lcyA9IG5ldyBXYXRlckdlbmVyYXRvcihcclxuICAgICAgICAgICAgdGhpcy5pbnRlZ3JhdG9yLCB0aGlzLmRvbWFpbkNvbnRyb2xsZXIub3JpZ2luLFxyXG4gICAgICAgICAgICB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGREaW1lbnNpb25zLFxyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LHRoaXMucGFyYW1zKSwgdGhpcy50ZW5zb3JGaWVsZCk7XHJcbiAgICAgICAgdGhpcy5kb21haW5Db250cm9sbGVyLnpvb20gPSB0aGlzLmRvbWFpbkNvbnRyb2xsZXIuem9vbSAqIFV0aWwuRFJBV19JTkZMQVRFX0FNT1VOVDtcclxuXHJcbiAgICAgICAgdGhpcy5zdHJlYW1saW5lcy5jcmVhdGVDb2FzdCgpO1xyXG4gICAgICAgIHRoaXMuc3RyZWFtbGluZXMuY3JlYXRlUml2ZXIoKTtcclxuICAgICAgIFxyXG4gICAgICAgIHRoaXMuY2xvc2VUZW5zb3JGb2xkZXIoKTtcclxuICAgICAgICB0aGlzLnJlZHJhdygpO1xyXG4gICAgICAgIHRoaXMucG9zdEdlbmVyYXRlQ2FsbGJhY2soKTtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4ocmVzb2x2ZSA9PiByZXNvbHZlKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2Vjb25kYXJ5IHJvYWQgcnVucyBhbG9uZyBvdGhlciBzaWRlIG9mIHJpdmVyXHJcbiAgICAgKi9cclxuICAgIGdldCBzdHJlYW1saW5lc1dpdGhTZWNvbmRhcnlSb2FkKCk6IFZlY3RvcltdW10ge1xyXG4gICAgICAgIGNvbnN0IHdpdGhTZWNvbmRhcnkgPSB0aGlzLnN0cmVhbWxpbmVzLmFsbFN0cmVhbWxpbmVzU2ltcGxlLnNsaWNlKCk7XHJcbiAgICAgICAgd2l0aFNlY29uZGFyeS5wdXNoKHRoaXMuc3RyZWFtbGluZXMucml2ZXJTZWNvbmRhcnlSb2FkKTtcclxuICAgICAgICByZXR1cm4gd2l0aFNlY29uZGFyeTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgcml2ZXIoKTogVmVjdG9yW10ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbWxpbmVzLnJpdmVyUG9seWdvbi5tYXAodiA9PiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGRUb1NjcmVlbih2LmNsb25lKCkpKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgc2Vjb25kYXJ5Uml2ZXIoKTogVmVjdG9yW10ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbWxpbmVzLnJpdmVyU2Vjb25kYXJ5Um9hZC5tYXAodiA9PiB0aGlzLmRvbWFpbkNvbnRyb2xsZXIud29ybGRUb1NjcmVlbih2LmNsb25lKCkpKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgY29hc3RsaW5lKCk6IFZlY3RvcltdIHtcclxuICAgICAgICAvLyBVc2UgdW5zaW1wbGlmaWVkIG5vaXN5IHN0cmVhbWxpbmUgYXMgY29hc3RsaW5lXHJcbiAgICAgICAgLy8gVmlzdWFsIG9ubHksIG5vIHJvYWQgbG9naWMgcGVyZm9ybWVkIHVzaW5nIHRoaXNcclxuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1saW5lcy5jb2FzdGxpbmUubWFwKHYgPT4gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkVG9TY3JlZW4odi5jbG9uZSgpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHNlYVBvbHlnb24oKTogVmVjdG9yW10ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbWxpbmVzLnNlYVBvbHlnb24ubWFwKHYgPT4gdGhpcy5kb21haW5Db250cm9sbGVyLndvcmxkVG9TY3JlZW4odi5jbG9uZSgpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGFkZERldlBhcmFtc1RvRm9sZGVyKHBhcmFtczogU3RyZWFtbGluZVBhcmFtcywgZm9sZGVyOiBkYXQuR1VJKTogdm9pZCB7XHJcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdkc2VwJyk7XHJcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdkdGVzdCcpO1xyXG4gICAgICAgIGZvbGRlci5hZGQocGFyYW1zLCAncGF0aEl0ZXJhdGlvbnMnKTtcclxuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ3NlZWRUcmllcycpO1xyXG4gICAgICAgIGZvbGRlci5hZGQocGFyYW1zLCAnZHN0ZXAnKTtcclxuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ2Rsb29rYWhlYWQnKTtcclxuICAgICAgICBmb2xkZXIuYWRkKHBhcmFtcywgJ2RjaXJjbGVqb2luJyk7XHJcbiAgICAgICAgZm9sZGVyLmFkZChwYXJhbXMsICdqb2luYW5nbGUnKTtcclxuICAgIH1cclxuICAgIFxyXG59XHJcbiIsImV4cG9ydCBpbnRlcmZhY2UgUmFuZG9tUmFuZ2Uge1xyXG4gICAgbWluPzogbnVtYmVyO1xyXG4gICAgbWF4OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFV0aWwge1xyXG4gICAgLy8gTXVzdCBtYXRjaCBzdHlsZS5jc3MgYW5kIGluZGV4Lmh0bWxcclxuICAgIHN0YXRpYyByZWFkb25seSBDQU5WQVNfSUQgPSAnbWFwLWNhbnZhcyc7XHJcbiAgICBzdGF0aWMgcmVhZG9ubHkgSU1HX0NBTlZBU19JRCA9ICdpbWctY2FudmFzJztcclxuICAgIHN0YXRpYyByZWFkb25seSBTVkdfSUQgPSAnbWFwLXN2Zyc7XHJcblxyXG4gICAgLy8gSG93IGZhciB0byBpbnRlZ3JhdGUgc3RyZWFtbGluZXMgYmV5b25kIHNjcmVlbiAtIGZvciBtYWtpbmcgYnVpbGRpbmdzIHJlYWNoIHRoZSBlZGdlXHJcbiAgICBzdGF0aWMgcmVhZG9ubHkgRFJBV19JTkZMQVRFX0FNT1VOVCA9IDEuMjtcclxuXHJcbiAgICAvLyBSZWZyZXNoIGRhdC5HVUkgdmFsdWVzXHJcbiAgICBzdGF0aWMgdXBkYXRlR3VpKGd1aTogZGF0LkdVSSk6IHZvaWQge1xyXG4gICAgICAgIGlmIChndWkuX19jb250cm9sbGVycykge1xyXG4gICAgICAgICAgICBndWkuX19jb250cm9sbGVycy5mb3JFYWNoKGMgPT4gYy51cGRhdGVEaXNwbGF5KCkpOyAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGd1aS5fX2ZvbGRlcnMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBmb2xkZXJOYW1lIGluIGd1aS5fX2ZvbGRlcnMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlR3VpKGd1aS5fX2ZvbGRlcnNbZm9sZGVyTmFtZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyByZW1vdmVBbGxGb2xkZXJzKGd1aTogZGF0LkdVSSk6IHZvaWQge1xyXG4gICAgICAgIGlmIChndWkuX19mb2xkZXJzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZm9sZGVyTmFtZSBpbiBndWkuX19mb2xkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBndWkucmVtb3ZlRm9sZGVyKGd1aS5fX2ZvbGRlcnNbZm9sZGVyTmFtZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyByYW5kb21SYW5nZShtYXg6IG51bWJlciwgbWluPTApOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiAoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pKSArIG1pbjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gQ1NTIGNvbG91ciBwYXJzZXJcclxuXHJcbiAgICAvLyAoYykgRGVhbiBNY05hbWVlIDxkZWFuQGdtYWlsLmNvbT4sIDIwMTIuXHJcbiAgICAvL1xyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2RlYW5tL2Nzcy1jb2xvci1wYXJzZXItanNcclxuICAgIC8vXHJcbiAgICAvLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XHJcbiAgICAvLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0b1xyXG4gICAgLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcclxuICAgIC8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxyXG4gICAgLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuICAgIC8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcbiAgICAvL1xyXG4gICAgLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cclxuICAgIC8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4gICAgLy9cclxuICAgIC8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICAgIC8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gICAgLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAgICAvLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAgICAvLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xyXG4gICAgLy8gRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HU1xyXG4gICAgLy8gSU4gVEhFIFNPRlRXQVJFLlxyXG5cclxuICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtY29sb3IvXHJcbiAgICBwcml2YXRlIHN0YXRpYyBrQ1NTQ29sb3JUYWJsZTogYW55ID0ge1xyXG4gICAgICAgIFwidHJhbnNwYXJlbnRcIjogWzAsMCwwLDBdLCBcImFsaWNlYmx1ZVwiOiBbMjQwLDI0OCwyNTUsMV0sXHJcbiAgICAgICAgXCJhbnRpcXVld2hpdGVcIjogWzI1MCwyMzUsMjE1LDFdLCBcImFxdWFcIjogWzAsMjU1LDI1NSwxXSxcclxuICAgICAgICBcImFxdWFtYXJpbmVcIjogWzEyNywyNTUsMjEyLDFdLCBcImF6dXJlXCI6IFsyNDAsMjU1LDI1NSwxXSxcclxuICAgICAgICBcImJlaWdlXCI6IFsyNDUsMjQ1LDIyMCwxXSwgXCJiaXNxdWVcIjogWzI1NSwyMjgsMTk2LDFdLFxyXG4gICAgICAgIFwiYmxhY2tcIjogWzAsMCwwLDFdLCBcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsMjM1LDIwNSwxXSxcclxuICAgICAgICBcImJsdWVcIjogWzAsMCwyNTUsMV0sIFwiYmx1ZXZpb2xldFwiOiBbMTM4LDQzLDIyNiwxXSxcclxuICAgICAgICBcImJyb3duXCI6IFsxNjUsNDIsNDIsMV0sIFwiYnVybHl3b29kXCI6IFsyMjIsMTg0LDEzNSwxXSxcclxuICAgICAgICBcImNhZGV0Ymx1ZVwiOiBbOTUsMTU4LDE2MCwxXSwgXCJjaGFydHJldXNlXCI6IFsxMjcsMjU1LDAsMV0sXHJcbiAgICAgICAgXCJjaG9jb2xhdGVcIjogWzIxMCwxMDUsMzAsMV0sIFwiY29yYWxcIjogWzI1NSwxMjcsODAsMV0sXHJcbiAgICAgICAgXCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLDE0OSwyMzcsMV0sIFwiY29ybnNpbGtcIjogWzI1NSwyNDgsMjIwLDFdLFxyXG4gICAgICAgIFwiY3JpbXNvblwiOiBbMjIwLDIwLDYwLDFdLCBcImN5YW5cIjogWzAsMjU1LDI1NSwxXSxcclxuICAgICAgICBcImRhcmtibHVlXCI6IFswLDAsMTM5LDFdLCBcImRhcmtjeWFuXCI6IFswLDEzOSwxMzksMV0sXHJcbiAgICAgICAgXCJkYXJrZ29sZGVucm9kXCI6IFsxODQsMTM0LDExLDFdLCBcImRhcmtncmF5XCI6IFsxNjksMTY5LDE2OSwxXSxcclxuICAgICAgICBcImRhcmtncmVlblwiOiBbMCwxMDAsMCwxXSwgXCJkYXJrZ3JleVwiOiBbMTY5LDE2OSwxNjksMV0sXHJcbiAgICAgICAgXCJkYXJra2hha2lcIjogWzE4OSwxODMsMTA3LDFdLCBcImRhcmttYWdlbnRhXCI6IFsxMzksMCwxMzksMV0sXHJcbiAgICAgICAgXCJkYXJrb2xpdmVncmVlblwiOiBbODUsMTA3LDQ3LDFdLCBcImRhcmtvcmFuZ2VcIjogWzI1NSwxNDAsMCwxXSxcclxuICAgICAgICBcImRhcmtvcmNoaWRcIjogWzE1Myw1MCwyMDQsMV0sIFwiZGFya3JlZFwiOiBbMTM5LDAsMCwxXSxcclxuICAgICAgICBcImRhcmtzYWxtb25cIjogWzIzMywxNTAsMTIyLDFdLCBcImRhcmtzZWFncmVlblwiOiBbMTQzLDE4OCwxNDMsMV0sXHJcbiAgICAgICAgXCJkYXJrc2xhdGVibHVlXCI6IFs3Miw2MSwxMzksMV0sIFwiZGFya3NsYXRlZ3JheVwiOiBbNDcsNzksNzksMV0sXHJcbiAgICAgICAgXCJkYXJrc2xhdGVncmV5XCI6IFs0Nyw3OSw3OSwxXSwgXCJkYXJrdHVycXVvaXNlXCI6IFswLDIwNiwyMDksMV0sXHJcbiAgICAgICAgXCJkYXJrdmlvbGV0XCI6IFsxNDgsMCwyMTEsMV0sIFwiZGVlcHBpbmtcIjogWzI1NSwyMCwxNDcsMV0sXHJcbiAgICAgICAgXCJkZWVwc2t5Ymx1ZVwiOiBbMCwxOTEsMjU1LDFdLCBcImRpbWdyYXlcIjogWzEwNSwxMDUsMTA1LDFdLFxyXG4gICAgICAgIFwiZGltZ3JleVwiOiBbMTA1LDEwNSwxMDUsMV0sIFwiZG9kZ2VyYmx1ZVwiOiBbMzAsMTQ0LDI1NSwxXSxcclxuICAgICAgICBcImZpcmVicmlja1wiOiBbMTc4LDM0LDM0LDFdLCBcImZsb3JhbHdoaXRlXCI6IFsyNTUsMjUwLDI0MCwxXSxcclxuICAgICAgICBcImZvcmVzdGdyZWVuXCI6IFszNCwxMzksMzQsMV0sIFwiZnVjaHNpYVwiOiBbMjU1LDAsMjU1LDFdLFxyXG4gICAgICAgIFwiZ2FpbnNib3JvXCI6IFsyMjAsMjIwLDIyMCwxXSwgXCJnaG9zdHdoaXRlXCI6IFsyNDgsMjQ4LDI1NSwxXSxcclxuICAgICAgICBcImdvbGRcIjogWzI1NSwyMTUsMCwxXSwgXCJnb2xkZW5yb2RcIjogWzIxOCwxNjUsMzIsMV0sXHJcbiAgICAgICAgXCJncmF5XCI6IFsxMjgsMTI4LDEyOCwxXSwgXCJncmVlblwiOiBbMCwxMjgsMCwxXSxcclxuICAgICAgICBcImdyZWVueWVsbG93XCI6IFsxNzMsMjU1LDQ3LDFdLCBcImdyZXlcIjogWzEyOCwxMjgsMTI4LDFdLFxyXG4gICAgICAgIFwiaG9uZXlkZXdcIjogWzI0MCwyNTUsMjQwLDFdLCBcImhvdHBpbmtcIjogWzI1NSwxMDUsMTgwLDFdLFxyXG4gICAgICAgIFwiaW5kaWFucmVkXCI6IFsyMDUsOTIsOTIsMV0sIFwiaW5kaWdvXCI6IFs3NSwwLDEzMCwxXSxcclxuICAgICAgICBcIml2b3J5XCI6IFsyNTUsMjU1LDI0MCwxXSwgXCJraGFraVwiOiBbMjQwLDIzMCwxNDAsMV0sXHJcbiAgICAgICAgXCJsYXZlbmRlclwiOiBbMjMwLDIzMCwyNTAsMV0sIFwibGF2ZW5kZXJibHVzaFwiOiBbMjU1LDI0MCwyNDUsMV0sXHJcbiAgICAgICAgXCJsYXduZ3JlZW5cIjogWzEyNCwyNTIsMCwxXSwgXCJsZW1vbmNoaWZmb25cIjogWzI1NSwyNTAsMjA1LDFdLFxyXG4gICAgICAgIFwibGlnaHRibHVlXCI6IFsxNzMsMjE2LDIzMCwxXSwgXCJsaWdodGNvcmFsXCI6IFsyNDAsMTI4LDEyOCwxXSxcclxuICAgICAgICBcImxpZ2h0Y3lhblwiOiBbMjI0LDI1NSwyNTUsMV0sIFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwyNTAsMjEwLDFdLFxyXG4gICAgICAgIFwibGlnaHRncmF5XCI6IFsyMTEsMjExLDIxMSwxXSwgXCJsaWdodGdyZWVuXCI6IFsxNDQsMjM4LDE0NCwxXSxcclxuICAgICAgICBcImxpZ2h0Z3JleVwiOiBbMjExLDIxMSwyMTEsMV0sIFwibGlnaHRwaW5rXCI6IFsyNTUsMTgyLDE5MywxXSxcclxuICAgICAgICBcImxpZ2h0c2FsbW9uXCI6IFsyNTUsMTYwLDEyMiwxXSwgXCJsaWdodHNlYWdyZWVuXCI6IFszMiwxNzgsMTcwLDFdLFxyXG4gICAgICAgIFwibGlnaHRza3libHVlXCI6IFsxMzUsMjA2LDI1MCwxXSwgXCJsaWdodHNsYXRlZ3JheVwiOiBbMTE5LDEzNiwxNTMsMV0sXHJcbiAgICAgICAgXCJsaWdodHNsYXRlZ3JleVwiOiBbMTE5LDEzNiwxNTMsMV0sIFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwxOTYsMjIyLDFdLFxyXG4gICAgICAgIFwibGlnaHR5ZWxsb3dcIjogWzI1NSwyNTUsMjI0LDFdLCBcImxpbWVcIjogWzAsMjU1LDAsMV0sXHJcbiAgICAgICAgXCJsaW1lZ3JlZW5cIjogWzUwLDIwNSw1MCwxXSwgXCJsaW5lblwiOiBbMjUwLDI0MCwyMzAsMV0sXHJcbiAgICAgICAgXCJtYWdlbnRhXCI6IFsyNTUsMCwyNTUsMV0sIFwibWFyb29uXCI6IFsxMjgsMCwwLDFdLFxyXG4gICAgICAgIFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLDIwNSwxNzAsMV0sIFwibWVkaXVtYmx1ZVwiOiBbMCwwLDIwNSwxXSxcclxuICAgICAgICBcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LDg1LDIxMSwxXSwgXCJtZWRpdW1wdXJwbGVcIjogWzE0NywxMTIsMjE5LDFdLFxyXG4gICAgICAgIFwibWVkaXVtc2VhZ3JlZW5cIjogWzYwLDE3OSwxMTMsMV0sIFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsMTA0LDIzOCwxXSxcclxuICAgICAgICBcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLDI1MCwxNTQsMV0sIFwibWVkaXVtdHVycXVvaXNlXCI6IFs3MiwyMDksMjA0LDFdLFxyXG4gICAgICAgIFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksMjEsMTMzLDFdLCBcIm1pZG5pZ2h0Ymx1ZVwiOiBbMjUsMjUsMTEyLDFdLFxyXG4gICAgICAgIFwibWludGNyZWFtXCI6IFsyNDUsMjU1LDI1MCwxXSwgXCJtaXN0eXJvc2VcIjogWzI1NSwyMjgsMjI1LDFdLFxyXG4gICAgICAgIFwibW9jY2FzaW5cIjogWzI1NSwyMjgsMTgxLDFdLCBcIm5hdmFqb3doaXRlXCI6IFsyNTUsMjIyLDE3MywxXSxcclxuICAgICAgICBcIm5hdnlcIjogWzAsMCwxMjgsMV0sIFwib2xkbGFjZVwiOiBbMjUzLDI0NSwyMzAsMV0sXHJcbiAgICAgICAgXCJvbGl2ZVwiOiBbMTI4LDEyOCwwLDFdLCBcIm9saXZlZHJhYlwiOiBbMTA3LDE0MiwzNSwxXSxcclxuICAgICAgICBcIm9yYW5nZVwiOiBbMjU1LDE2NSwwLDFdLCBcIm9yYW5nZXJlZFwiOiBbMjU1LDY5LDAsMV0sXHJcbiAgICAgICAgXCJvcmNoaWRcIjogWzIxOCwxMTIsMjE0LDFdLCBcInBhbGVnb2xkZW5yb2RcIjogWzIzOCwyMzIsMTcwLDFdLFxyXG4gICAgICAgIFwicGFsZWdyZWVuXCI6IFsxNTIsMjUxLDE1MiwxXSwgXCJwYWxldHVycXVvaXNlXCI6IFsxNzUsMjM4LDIzOCwxXSxcclxuICAgICAgICBcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwxMTIsMTQ3LDFdLCBcInBhcGF5YXdoaXBcIjogWzI1NSwyMzksMjEzLDFdLFxyXG4gICAgICAgIFwicGVhY2hwdWZmXCI6IFsyNTUsMjE4LDE4NSwxXSwgXCJwZXJ1XCI6IFsyMDUsMTMzLDYzLDFdLFxyXG4gICAgICAgIFwicGlua1wiOiBbMjU1LDE5MiwyMDMsMV0sIFwicGx1bVwiOiBbMjIxLDE2MCwyMjEsMV0sXHJcbiAgICAgICAgXCJwb3dkZXJibHVlXCI6IFsxNzYsMjI0LDIzMCwxXSwgXCJwdXJwbGVcIjogWzEyOCwwLDEyOCwxXSxcclxuICAgICAgICBcInJlYmVjY2FwdXJwbGVcIjogWzEwMiw1MSwxNTMsMV0sXHJcbiAgICAgICAgXCJyZWRcIjogWzI1NSwwLDAsMV0sIFwicm9zeWJyb3duXCI6IFsxODgsMTQzLDE0MywxXSxcclxuICAgICAgICBcInJveWFsYmx1ZVwiOiBbNjUsMTA1LDIyNSwxXSwgXCJzYWRkbGVicm93blwiOiBbMTM5LDY5LDE5LDFdLFxyXG4gICAgICAgIFwic2FsbW9uXCI6IFsyNTAsMTI4LDExNCwxXSwgXCJzYW5keWJyb3duXCI6IFsyNDQsMTY0LDk2LDFdLFxyXG4gICAgICAgIFwic2VhZ3JlZW5cIjogWzQ2LDEzOSw4NywxXSwgXCJzZWFzaGVsbFwiOiBbMjU1LDI0NSwyMzgsMV0sXHJcbiAgICAgICAgXCJzaWVubmFcIjogWzE2MCw4Miw0NSwxXSwgXCJzaWx2ZXJcIjogWzE5MiwxOTIsMTkyLDFdLFxyXG4gICAgICAgIFwic2t5Ymx1ZVwiOiBbMTM1LDIwNiwyMzUsMV0sIFwic2xhdGVibHVlXCI6IFsxMDYsOTAsMjA1LDFdLFxyXG4gICAgICAgIFwic2xhdGVncmF5XCI6IFsxMTIsMTI4LDE0NCwxXSwgXCJzbGF0ZWdyZXlcIjogWzExMiwxMjgsMTQ0LDFdLFxyXG4gICAgICAgIFwic25vd1wiOiBbMjU1LDI1MCwyNTAsMV0sIFwic3ByaW5nZ3JlZW5cIjogWzAsMjU1LDEyNywxXSxcclxuICAgICAgICBcInN0ZWVsYmx1ZVwiOiBbNzAsMTMwLDE4MCwxXSwgXCJ0YW5cIjogWzIxMCwxODAsMTQwLDFdLFxyXG4gICAgICAgIFwidGVhbFwiOiBbMCwxMjgsMTI4LDFdLCBcInRoaXN0bGVcIjogWzIxNiwxOTEsMjE2LDFdLFxyXG4gICAgICAgIFwidG9tYXRvXCI6IFsyNTUsOTksNzEsMV0sIFwidHVycXVvaXNlXCI6IFs2NCwyMjQsMjA4LDFdLFxyXG4gICAgICAgIFwidmlvbGV0XCI6IFsyMzgsMTMwLDIzOCwxXSwgXCJ3aGVhdFwiOiBbMjQ1LDIyMiwxNzksMV0sXHJcbiAgICAgICAgXCJ3aGl0ZVwiOiBbMjU1LDI1NSwyNTUsMV0sIFwid2hpdGVzbW9rZVwiOiBbMjQ1LDI0NSwyNDUsMV0sXHJcbiAgICAgICAgXCJ5ZWxsb3dcIjogWzI1NSwyNTUsMCwxXSwgXCJ5ZWxsb3dncmVlblwiOiBbMTU0LDIwNSw1MCwxXX1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBjbGFtcF9jc3NfYnl0ZShpOiBudW1iZXIpOiBudW1iZXIgeyAgLy8gQ2xhbXAgdG8gaW50ZWdlciAwIC4uIDI1NS5cclxuICAgICAgICBpID0gTWF0aC5yb3VuZChpKTsgIC8vIFNlZW1zIHRvIGJlIHdoYXQgQ2hyb21lIGRvZXMgKHZzIHRydW5jYXRpb24pLlxyXG4gICAgICAgIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMjU1ID8gMjU1IDogaTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBjbGFtcF9jc3NfZmxvYXQoZjogbnVtYmVyKTogbnVtYmVyIHsgIC8vIENsYW1wIHRvIGZsb2F0IDAuMCAuLiAxLjAuXHJcbiAgICAgICAgcmV0dXJuIGYgPCAwID8gMCA6IGYgPiAxID8gMSA6IGY7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcGFyc2VfY3NzX2ludChzdHI6IHN0cmluZyk6IG51bWJlciB7ICAvLyBpbnQgb3IgcGVyY2VudGFnZS5cclxuICAgICAgICBpZiAoc3RyW3N0ci5sZW5ndGggLSAxXSA9PT0gJyUnKVxyXG4gICAgICAgIHJldHVybiBVdGlsLmNsYW1wX2Nzc19ieXRlKHBhcnNlRmxvYXQoc3RyKSAvIDEwMCAqIDI1NSk7XHJcbiAgICAgICAgcmV0dXJuIFV0aWwuY2xhbXBfY3NzX2J5dGUocGFyc2VJbnQoc3RyKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcGFyc2VfY3NzX2Zsb2F0KHN0cjogc3RyaW5nKTogbnVtYmVyIHsgIC8vIGZsb2F0IG9yIHBlcmNlbnRhZ2UuXHJcbiAgICAgICAgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICclJylcclxuICAgICAgICByZXR1cm4gVXRpbC5jbGFtcF9jc3NfZmxvYXQocGFyc2VGbG9hdChzdHIpIC8gMTAwKTtcclxuICAgICAgICByZXR1cm4gVXRpbC5jbGFtcF9jc3NfZmxvYXQocGFyc2VGbG9hdChzdHIpKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBjc3NfaHVlX3RvX3JnYihtMTogbnVtYmVyLCBtMjogbnVtYmVyLCBoOiBudW1iZXIpIHtcclxuICAgICAgICBpZiAoaCA8IDApIGggKz0gMTtcclxuICAgICAgICBlbHNlIGlmIChoID4gMSkgaCAtPSAxO1xyXG5cclxuICAgICAgICBpZiAoaCAqIDYgPCAxKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiBoICogNjtcclxuICAgICAgICBpZiAoaCAqIDIgPCAxKSByZXR1cm4gbTI7XHJcbiAgICAgICAgaWYgKGggKiAzIDwgMikgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogKDIvMyAtIGgpICogNjtcclxuICAgICAgICByZXR1cm4gbTE7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHBhcnNlQ1NTQ29sb3IoY3NzX3N0cjogc3RyaW5nKTogbnVtYmVyW10ge1xyXG4gICAgICAgIC8vIFJlbW92ZSBhbGwgd2hpdGVzcGFjZSwgbm90IGNvbXBsaWFudCwgYnV0IHNob3VsZCBqdXN0IGJlIG1vcmUgYWNjZXB0aW5nLlxyXG4gICAgICAgIHZhciBzdHIgPSBjc3Nfc3RyLnJlcGxhY2UoLyAvZywgJycpLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgIC8vIENvbG9yIGtleXdvcmRzIChhbmQgdHJhbnNwYXJlbnQpIGxvb2t1cC5cclxuICAgICAgICBpZiAoc3RyIGluIFV0aWwua0NTU0NvbG9yVGFibGUpIHJldHVybiBVdGlsLmtDU1NDb2xvclRhYmxlW3N0cl0uc2xpY2UoKTsgIC8vIGR1cC5cclxuXHJcbiAgICAgICAgLy8gI2FiYyBhbmQgI2FiYzEyMyBzeW50YXguXHJcbiAgICAgICAgaWYgKHN0clswXSA9PT0gJyMnKSB7XHJcbiAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID09PSA0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cclxuICAgICAgICAgICAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmYpKSByZXR1cm4gbnVsbDsgIC8vIENvdmVycyBOYU4uXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWygoaXYgJiAweGYwMCkgPj4gNCkgfCAoKGl2ICYgMHhmMDApID4+IDgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgKGl2ICYgMHhmMCkgfCAoKGl2ICYgMHhmMCkgPj4gNCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAoaXYgJiAweGYpIHwgKChpdiAmIDB4ZikgPDwgNCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAxXTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHIubGVuZ3RoID09PSA3KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cclxuICAgICAgICAgICAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmZmZmYpKSByZXR1cm4gbnVsbDsgIC8vIENvdmVycyBOYU4uXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWyhpdiAmIDB4ZmYwMDAwKSA+PiAxNixcclxuICAgICAgICAgICAgICAgICAgICAgIChpdiAmIDB4ZmYwMCkgPj4gOCxcclxuICAgICAgICAgICAgICAgICAgICAgIGl2ICYgMHhmZixcclxuICAgICAgICAgICAgICAgICAgICAgIDFdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBvcCA9IHN0ci5pbmRleE9mKCcoJyksIGVwID0gc3RyLmluZGV4T2YoJyknKTtcclxuICAgICAgICBpZiAob3AgIT09IC0xICYmIGVwICsgMSA9PT0gc3RyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgZm5hbWUgPSBzdHIuc3Vic3RyKDAsIG9wKTtcclxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHN0ci5zdWJzdHIob3ArMSwgZXAtKG9wKzEpKS5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICB2YXIgYWxwaGEgPSAxOyAgLy8gVG8gYWxsb3cgY2FzZSBmYWxsdGhyb3VnaC5cclxuICAgICAgICAgICAgc3dpdGNoIChmbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncmdiYSc6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGFscGhhID0gVXRpbC5wYXJzZV9jc3NfZmxvYXQocGFyYW1zLnBvcCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBGYWxsIHRocm91Z2guXHJcbiAgICAgICAgICAgICAgICBjYXNlICdyZ2InOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1V0aWwucGFyc2VfY3NzX2ludChwYXJhbXNbMF0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVXRpbC5wYXJzZV9jc3NfaW50KHBhcmFtc1sxXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBVdGlsLnBhcnNlX2Nzc19pbnQocGFyYW1zWzJdKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdoc2xhJzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSBVdGlsLnBhcnNlX2Nzc19mbG9hdChwYXJhbXMucG9wKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaC5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2hzbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoID0gKCgocGFyc2VGbG9hdChwYXJhbXNbMF0pICUgMzYwKSArIDM2MCkgJSAzNjApIC8gMzYwOyAgLy8gMCAuLiAxXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URShkZWFubSk6IEFjY29yZGluZyB0byB0aGUgQ1NTIHNwZWMgcy9sIHNob3VsZCBvbmx5IGJlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcGVyY2VudGFnZXMsIGJ1dCB3ZSBkb24ndCBib3RoZXIgYW5kIGxldCBmbG9hdCBvciBwZXJjZW50YWdlLlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gVXRpbC5wYXJzZV9jc3NfZmxvYXQocGFyYW1zWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbCA9IFV0aWwucGFyc2VfY3NzX2Zsb2F0KHBhcmFtc1syXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0yID0gbCA8PSAwLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0xID0gbCAqIDIgLSBtMjtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1V0aWwuY2xhbXBfY3NzX2J5dGUoVXRpbC5jc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgrMS8zKSAqIDI1NSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBVdGlsLmNsYW1wX2Nzc19ieXRlKFV0aWwuY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoKSAqIDI1NSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBVdGlsLmNsYW1wX2Nzc19ieXRlKFV0aWwuY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoLTEvMykgKiAyNTUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGFdO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgbG9nIGZyb20gJ2xvZ2xldmVsJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlY3RvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgeDogbnVtYmVyLCBwdWJsaWMgeTogbnVtYmVyKSB7fVxyXG5cclxuICAgIHN0YXRpYyB6ZXJvVmVjdG9yKCk6IFZlY3RvciB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoMCwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGZyb21TY2FsYXIoczogbnVtYmVyKTogVmVjdG9yIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihzLCBzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIC1waSB0byBwaVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYW5nbGVCZXR3ZWVuKHYxOiBWZWN0b3IsIHYyOiBWZWN0b3IpOiBudW1iZXIge1xyXG4gICAgICAgIC8vIC0ycGkgdG8gMnBpXHJcbiAgICAgICAgbGV0IGFuZ2xlQmV0d2VlbiA9IHYxLmFuZ2xlKCkgLSB2Mi5hbmdsZSgpO1xyXG4gICAgICAgIGlmIChhbmdsZUJldHdlZW4gPiBNYXRoLlBJKSB7XHJcbiAgICAgICAgICAgIGFuZ2xlQmV0d2VlbiAtPSAyICogTWF0aC5QSTtcclxuICAgICAgICB9IGVsc2UgaWYgKGFuZ2xlQmV0d2VlbiA8PSAtTWF0aC5QSSkge1xyXG4gICAgICAgICAgICBhbmdsZUJldHdlZW4gKz0gMiAqIE1hdGguUEk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhbmdsZUJldHdlZW47XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyB3aGV0aGVyIGEgcG9pbnQgbGllcyB0byB0aGUgbGVmdCBvZiBhIGxpbmVcclxuICAgICAqIEBwYXJhbSAge1ZlY3Rvcn0gbGluZVBvaW50ICAgICBQb2ludCBvbiB0aGUgbGluZVxyXG4gICAgICogQHBhcmFtICB7VmVjdG9yfSBsaW5lRGlyZWN0aW9uIFxyXG4gICAgICogQHBhcmFtICB7VmVjdG9yfSBwb2ludFxyXG4gICAgICogQHJldHVybiB7VmVjdG9yfSAgICAgICAgICAgICAgIHRydWUgaWYgbGVmdCwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0xlZnQobGluZVBvaW50OiBWZWN0b3IsIGxpbmVEaXJlY3Rpb246IFZlY3RvciwgcG9pbnQ6IFZlY3Rvcik6IGJvb2xlYW4ge1xyXG4gICAgICAgIGNvbnN0IHBlcnBlbmRpY3VsYXJWZWN0b3IgPSBuZXcgVmVjdG9yKGxpbmVEaXJlY3Rpb24ueSwgLWxpbmVEaXJlY3Rpb24ueCk7XHJcbiAgICAgICAgcmV0dXJuIHBvaW50LmNsb25lKCkuc3ViKGxpbmVQb2ludCkuZG90KHBlcnBlbmRpY3VsYXJWZWN0b3IpIDwgMDtcclxuICAgIH1cclxuXHJcbiAgICBhZGQodjogVmVjdG9yKTogVmVjdG9yIHtcclxuICAgICAgICB0aGlzLnggKz0gdi54O1xyXG4gICAgICAgIHRoaXMueSArPSB2Lnk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbmdsZSBpbiByYWRpYW5zIHRvIHBvc2l0aXZlIHgtYXhpcyBiZXR3ZWVuIC1waSBhbmQgcGlcclxuICAgICAqL1xyXG4gICAgYW5nbGUoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLnksIHRoaXMueCk7XHJcbiAgICB9XHJcblxyXG4gICAgY2xvbmUoKTogVmVjdG9yIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLngsIHRoaXMueSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29weSh2OiBWZWN0b3IpOiBWZWN0b3Ige1xyXG4gICAgICAgIHRoaXMueCA9IHYueDtcclxuICAgICAgICB0aGlzLnkgPSB2Lnk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgY3Jvc3ModjogVmVjdG9yKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy54ICogdi55IC0gdGhpcy55ICogdi54O1xyXG4gICAgfVxyXG5cclxuICAgIGRpc3RhbmNlVG8odjogVmVjdG9yKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQodikpO1xyXG4gICAgfVxyXG5cclxuICAgIGRpc3RhbmNlVG9TcXVhcmVkICh2OiBWZWN0b3IpOiBudW1iZXIge1xyXG4gICAgICAgIGNvbnN0IGR4ID0gdGhpcy54IC0gdi54XHJcbiAgICAgICAgY29uc3QgZHkgPSB0aGlzLnkgLSB2Lnk7XHJcbiAgICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG4gICAgfVxyXG5cclxuICAgIGRpdmlkZSh2OiBWZWN0b3IpOiBWZWN0b3Ige1xyXG4gICAgICAgIGlmICh2LnggPT09IDAgfHwgdi55ID09PSAwKSB7XHJcbiAgICAgICAgICAgIGxvZy53YXJuKFwiRGl2aXNpb24gYnkgemVyb1wiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnggLz0gdi54O1xyXG4gICAgICAgIHRoaXMueSAvPSB2Lnk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgZGl2aWRlU2NhbGFyKHM6IG51bWJlcik6IFZlY3RvciB7XHJcbiAgICAgICAgaWYgKHMgPT09IDApIHtcclxuICAgICAgICAgICAgbG9nLndhcm4oXCJEaXZpc2lvbiBieSB6ZXJvXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoMSAvIHMpO1xyXG4gICAgfVxyXG5cclxuICAgIGRvdCh2OiBWZWN0b3IpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2Lnk7XHJcbiAgICB9XHJcblxyXG4gICAgZXF1YWxzKHY6IFZlY3Rvcik6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiAoKHYueCA9PT0gdGhpcy54KSAmJiAodi55ID09PSB0aGlzLnkpKTtcclxuICAgIH1cclxuXHJcbiAgICBsZW5ndGgoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMubGVuZ3RoU3EoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGVuZ3RoU3EoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55O1xyXG4gICAgfVxyXG5cclxuICAgIG11bHRpcGx5KHY6IFZlY3Rvcik6IFZlY3RvciB7XHJcbiAgICAgICAgdGhpcy54ICo9IHYueDtcclxuICAgICAgICB0aGlzLnkgKj0gdi55O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIG11bHRpcGx5U2NhbGFyKHM6IG51bWJlcik6IFZlY3RvciB7XHJcbiAgICAgICAgdGhpcy54ICo9IHM7XHJcbiAgICAgICAgdGhpcy55ICo9IHM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgbmVnYXRlKCk6IFZlY3RvciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoLTEpO1xyXG4gICAgfVxyXG5cclxuICAgIG5vcm1hbGl6ZSgpOiBWZWN0b3Ige1xyXG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLmxlbmd0aCgpO1xyXG4gICAgICAgIGlmIChsID09PSAwKSB7XHJcbiAgICAgICAgICAgIGxvZy53YXJuKFwiWmVybyBWZWN0b3JcIik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbmdsZSBpbiByYWRpYW5zXHJcbiAgICAgKi9cclxuICAgIHJvdGF0ZUFyb3VuZChjZW50ZXI6IFZlY3RvciwgYW5nbGU6IG51bWJlcik6IFZlY3RvciB7XHJcbiAgICAgICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGUpXHJcbiAgICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xyXG5cclxuICAgICAgICBjb25zdCB4ID0gdGhpcy54IC0gY2VudGVyLng7XHJcbiAgICAgICAgY29uc3QgeSA9IHRoaXMueSAtIGNlbnRlci55O1xyXG5cclxuICAgICAgICB0aGlzLnggPSB4ICogY29zIC0geSAqIHNpbiArIGNlbnRlci54O1xyXG4gICAgICAgIHRoaXMueSA9IHggKiBzaW4gKyB5ICogY29zICsgY2VudGVyLnk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0KHY6IFZlY3Rvcik6IFZlY3RvciB7XHJcbiAgICAgICAgdGhpcy54ID0gdi54O1xyXG4gICAgICAgIHRoaXMueSA9IHYueTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBzZXRYKHg6IG51bWJlcik6IFZlY3RvciB7XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBzZXRZKHk6IG51bWJlcik6IFZlY3RvciB7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBzZXRMZW5ndGggKGxlbmd0aDogbnVtYmVyKTogVmVjdG9yIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihsZW5ndGgpO1xyXG4gICAgfVxyXG5cclxuICAgIHN1Yih2OiBWZWN0b3IpOiBWZWN0b3Ige1xyXG4gICAgICAgIHRoaXMueCAtPSB2Lng7XHJcbiAgICAgICAgdGhpcy55IC09IHYueTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxyXG4iXX0=
